using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using FluffyUnderware.Curvy.Controllers;
using ONSPPropagationInterface;
using ONSPPropagationInterface.Unity_Native;
using Oculus.Platform;
using Oculus.Platform.Models;
using RootMotion.FinalIK;
using TMPro;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.XR;

[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
[ExecuteInEditMode]
public class FadeInPixelLights : MonoBehaviour
{
	public float MaxDistance = 70f;

	public float Fadelength = 10f;

	public float Intensity = 1f;

	private float distance;

	private float factor = 1f;

	private Light lt;

	private void Awake()
	{
		lt = base.gameObject.GetComponent<Light>();
	}

	private void Update()
	{
		distance = (base.transform.position - Camera.main.transform.position).magnitude;
		factor = Mathf.Clamp01((MaxDistance - distance) / Fadelength);
		lt.intensity = Intensity * factor;
	}
}
public class GBSettings : MonoBehaviour
{
	public enum RaycastMode
	{
		coneCast,
		sphereCast
	}

	public float brushSize = 10f;

	public bool fireFromCamera;

	public float minScale = 1f;

	public float maxScale = 1f;

	public float spacing = 5f;

	public bool preventOverlap;

	public float yOffset;

	public bool alignToNormal = true;

	public bool randomRotX;

	public bool randomRotY;

	public bool randomRotZ;

	public bool brushActive = true;

	public Vector3 randomRotation = new Vector3(0f, 360f, 0f);

	public bool delete;

	public RaycastMode raycastMode;

	public GameObject parentObject;

	public float minBrushSize = 0.1f;

	public float maxBrushSize = 8f;

	public float minMinScale = 0.1f;

	public float maxMinScale = 5f;

	public float minMaxScale = 0.1f;

	public float maxMaxScale = 5f;

	public float minYOffset = -2.5f;

	public float maxYOffset = 2.5f;

	public float minSpacing = 0.1f;

	public float maxSpacing = 50f;

	public Vector3 gizmoPos;

	public bool gizmoActive;

	public List<GameObject> activeGeometry;

	public List<string> activeGeometryPaths;

	private void OnDrawGizmos()
	{
		if (!gizmoActive)
		{
			return;
		}
		if (raycastMode == RaycastMode.coneCast)
		{
			if (!delete)
			{
				Gizmos.color = Color.green;
			}
			else
			{
				Gizmos.color = Color.red;
			}
			Gizmos.DrawWireSphere(gizmoPos, brushSize);
		}
		else if (raycastMode == RaycastMode.sphereCast)
		{
			if (!delete)
			{
				Gizmos.color = Color.cyan;
			}
			else
			{
				Gizmos.color = Color.red;
			}
			Gizmos.DrawWireSphere(gizmoPos, 0.3f);
		}
	}
}
[AddComponentMenu("AFS/Mesh/AFS Combine Children")]
public class CombineChildrenAFS : MonoBehaviour
{
	public bool hideChildren;

	public Terrain UnderlayingTerrain;

	[Range(0f, 4f)]
	public float GroundMaxDistance = 0.25f;

	public bool bakeGroundLightingGrass;

	public Color HealthyColor = new Color(1f, 1f, 1f, 1f);

	public Color DryColor = new Color(1f, 1f, 1f, 1f);

	[Range(0f, 1f)]
	public float NoiseSpread = 0.1f;

	public bool bakeGroundLightingFoliage;

	[Range(0f, 1f)]
	public float randomBrightness = 0.25f;

	[Range(0f, 1f)]
	public float randomPulse = 0.3f;

	[Range(0f, 1f)]
	public float randomBending = 0.3f;

	[Range(0f, 1f)]
	public float randomFluttering = 0.3f;

	[Range(0f, 1f)]
	public float NoiseSpreadFoliage = 0.1f;

	public bool bakeScale = true;

	public bool debugNormals;

	public bool destroyChildObjectsInPlaymode = true;

	public bool CastShadows = true;

	public bool UseLightprobes;

	public float RealignGroundMaxDistance = 4f;

	public bool ForceRealignment;

	public bool createUniqueUV2;

	private bool createUniqueUV2playmode;

	public bool isStaticallyCombined;

	public bool simplyCombine;

	public bool useUV4;

	private void Start()
	{
		Combine();
	}

	[ContextMenu("Realign Objects")]
	public void Realign()
	{
		Component[] componentsInChildren = GetComponentsInChildren(typeof(MeshFilter));
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Renderer component = componentsInChildren[i].GetComponent<Renderer>();
			Vector3 position = component.transform.position;
			if ((!Physics.Raycast(position + Vector3.up * GroundMaxDistance * 0.5f, Vector3.down, out var hitInfo, GroundMaxDistance) || ForceRealignment) && Physics.Raycast(position + Vector3.up * RealignGroundMaxDistance * 0.5f, Vector3.down, out hitInfo, RealignGroundMaxDistance))
			{
				component.transform.position = hitInfo.point;
				Quaternion rotation = component.transform.rotation;
				component.transform.rotation = Quaternion.FromToRotation(Vector3.up, hitInfo.normal);
				rotation = new Quaternion(component.transform.rotation.x, rotation.y, component.transform.rotation.z, component.transform.rotation.w);
				component.transform.rotation = rotation;
			}
		}
	}

	public bool GetDebugNormalsScript()
	{
		GameObject gameObject = base.gameObject;
		Component component = gameObject.GetComponent<DebugNormalsInEditmode>();
		if (component == null)
		{
			return false;
		}
		return true;
	}

	public void EnableDebugging()
	{
		GameObject gameObject = base.gameObject;
		if (!GetDebugNormalsScript())
		{
			gameObject.AddComponent<DebugNormalsInEditmode>();
		}
		gameObject.GetComponent<DebugNormalsInEditmode>().enabled = true;
	}

	public void DisableDebugging()
	{
		GameObject gameObject = base.gameObject;
		if (GetDebugNormalsScript())
		{
			gameObject.GetComponent<DebugNormalsInEditmode>().enabled = false;
		}
	}

	[ContextMenu("Combine Now")]
	public void Combine()
	{
		if (isStaticallyCombined)
		{
			return;
		}
		Component[] componentsInChildren = GetComponentsInChildren(typeof(MeshFilter));
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		Hashtable hashtable = new Hashtable();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			MeshFilter meshFilter = (MeshFilter)componentsInChildren[i];
			Renderer component = componentsInChildren[i].GetComponent<Renderer>();
			Vector3 position = component.transform.position;
			if (Physics.Raycast(position + Vector3.up * GroundMaxDistance * 0.5f, Vector3.down, out var hitInfo, GroundMaxDistance))
			{
				if (debugNormals)
				{
					Debug.DrawLine(position + Vector3.up * GroundMaxDistance * 0.5f, position - GroundMaxDistance * Vector3.up * 0.5f, Color.green, 5f, depthTest: false);
					if (debugNormals)
					{
						Debug.DrawLine(position, position + hitInfo.normal, Color.red, 5f, depthTest: false);
					}
					if ((bool)UnderlayingTerrain)
					{
						Vector3 vector = (hitInfo.point - UnderlayingTerrain.transform.position) / UnderlayingTerrain.terrainData.size.x;
						if (hitInfo.transform.gameObject.name == UnderlayingTerrain.name)
						{
							if (debugNormals)
							{
								Debug.DrawLine(position, position + UnderlayingTerrain.terrainData.GetInterpolatedNormal(vector.x, vector.z), Color.blue, 5f, depthTest: false);
							}
							hitInfo.normal = UnderlayingTerrain.terrainData.GetInterpolatedNormal(vector.x, vector.z);
						}
					}
				}
			}
			else
			{
				hitInfo.normal = new Vector3(0f, 1f, 0f);
				if (debugNormals)
				{
					Debug.DrawLine(position, position + 1f * hitInfo.normal, Color.yellow, 5f, depthTest: false);
				}
			}
			MeshCombineUtilityAFS.MeshInstance meshInstance = default(MeshCombineUtilityAFS.MeshInstance);
			meshInstance.mesh = meshFilter.sharedMesh;
			meshInstance.groundNormal = hitInfo.normal;
			meshInstance.scale = meshFilter.transform.localScale.x;
			meshInstance.pivot = meshFilter.transform.position;
			if (!(component != null) || !component.enabled || !(meshInstance.mesh != null))
			{
				continue;
			}
			meshInstance.transform = worldToLocalMatrix * meshFilter.transform.localToWorldMatrix;
			Material[] sharedMaterials = component.sharedMaterials;
			for (int j = 0; j < sharedMaterials.Length; j++)
			{
				meshInstance.subMeshIndex = Math.Min(j, meshInstance.mesh.subMeshCount - 1);
				ArrayList arrayList = (ArrayList)hashtable[sharedMaterials[j]];
				if (arrayList != null)
				{
					arrayList.Add(meshInstance);
					continue;
				}
				arrayList = new ArrayList();
				arrayList.Add(meshInstance);
				hashtable.Add(sharedMaterials[j], arrayList);
			}
			if (UnityEngine.Application.isPlaying)
			{
				if (destroyChildObjectsInPlaymode)
				{
					UnityEngine.Object.Destroy(component.gameObject);
				}
			}
			else if (destroyChildObjectsInPlaymode)
			{
				UnityEngine.Object.DestroyImmediate(component.gameObject);
				isStaticallyCombined = true;
			}
			else
			{
				component.gameObject.SetActive(value: false);
				isStaticallyCombined = true;
			}
		}
		foreach (DictionaryEntry item in hashtable)
		{
			ArrayList arrayList2 = (ArrayList)item.Value;
			MeshCombineUtilityAFS.MeshInstance[] combines = (MeshCombineUtilityAFS.MeshInstance[])arrayList2.ToArray(typeof(MeshCombineUtilityAFS.MeshInstance));
			if (hashtable.Count == 1)
			{
				if (GetComponent(typeof(MeshFilter)) == null)
				{
					base.gameObject.AddComponent(typeof(MeshFilter));
				}
				if (!GetComponent("MeshRenderer"))
				{
					base.gameObject.AddComponent<MeshRenderer>();
				}
				MeshFilter meshFilter2 = (MeshFilter)GetComponent(typeof(MeshFilter));
				GetComponent<Renderer>().material = (Material)item.Key;
				bakeGroundLightingGrass = false;
				bakeGroundLightingFoliage = false;
				simplyCombine = false;
				if (UnityEngine.Application.isPlaying)
				{
					switch (GetComponent<Renderer>().material.GetTag("AfsMode", searchFallbacks: true, string.Empty))
					{
					case "Grass":
					case "AfsGrassModelSingleSided":
						bakeGroundLightingGrass = true;
						break;
					case "Foliage":
						if (GetComponent<Renderer>().material.HasProperty("_GroundLightingAttunation"))
						{
							bakeGroundLightingFoliage = true;
						}
						else
						{
							simplyCombine = true;
						}
						if (GetComponent<Renderer>().material.GetFloat("_BendingControls") == 1f)
						{
							useUV4 = true;
						}
						break;
					}
					meshFilter2.mesh = MeshCombineUtilityAFS.Combine(combines, bakeGroundLightingGrass, bakeGroundLightingFoliage, randomBrightness, randomPulse, randomBending, randomFluttering, HealthyColor, DryColor, NoiseSpread, bakeScale, simplyCombine, NoiseSpreadFoliage, createUniqueUV2playmode, useUV4);
				}
				else
				{
					switch (GetComponent<Renderer>().sharedMaterial.GetTag("AfsMode", searchFallbacks: true, string.Empty))
					{
					case "Grass":
					case "AfsGrassModelSingleSided":
						bakeGroundLightingGrass = true;
						break;
					case "Foliage":
						if (GetComponent<Renderer>().sharedMaterial.HasProperty("_GroundLightingAttunation"))
						{
							bakeGroundLightingFoliage = true;
						}
						else
						{
							simplyCombine = true;
						}
						if (GetComponent<Renderer>().material.GetFloat("_BendingControls") == 1f)
						{
							useUV4 = true;
						}
						break;
					}
					meshFilter2.sharedMesh = MeshCombineUtilityAFS.Combine(combines, bakeGroundLightingGrass, bakeGroundLightingFoliage, randomBrightness, randomPulse, randomBending, randomFluttering, HealthyColor, DryColor, NoiseSpread, bakeScale, simplyCombine, NoiseSpreadFoliage, createUniqueUV2, useUV4);
				}
				GetComponent<Renderer>().enabled = true;
				if (CastShadows)
				{
					GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.On;
				}
				else
				{
					GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.Off;
				}
				if (UseLightprobes)
				{
					GetComponent<Renderer>().useLightProbes = true;
				}
				else
				{
					GetComponent<Renderer>().useLightProbes = false;
				}
				continue;
			}
			GameObject gameObject = new GameObject("Combined mesh");
			gameObject.transform.parent = base.transform;
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.AddComponent(typeof(MeshFilter));
			gameObject.AddComponent<MeshRenderer>();
			gameObject.GetComponent<Renderer>().material = (Material)item.Key;
			gameObject.layer = gameObject.transform.parent.gameObject.layer;
			bakeGroundLightingGrass = false;
			bakeGroundLightingFoliage = false;
			simplyCombine = false;
			switch ((!UnityEngine.Application.isPlaying) ? gameObject.GetComponent<Renderer>().sharedMaterial.GetTag("AfsMode", searchFallbacks: true, string.Empty) : gameObject.GetComponent<Renderer>().material.GetTag("AfsMode", searchFallbacks: true, string.Empty))
			{
			case "Grass":
			case "AfsGrassModelSingleSided":
				bakeGroundLightingGrass = true;
				break;
			case "Foliage":
				if (UnityEngine.Application.isPlaying)
				{
					if (gameObject.GetComponent<Renderer>().material.HasProperty("_GroundLightingAttunation"))
					{
						bakeGroundLightingFoliage = true;
					}
					else
					{
						simplyCombine = true;
					}
					if (gameObject.GetComponent<Renderer>().material.GetFloat("_BendingControls") == 1f)
					{
						useUV4 = true;
					}
				}
				else
				{
					if (gameObject.GetComponent<Renderer>().sharedMaterial.HasProperty("_GroundLightingAttunation"))
					{
						bakeGroundLightingFoliage = true;
					}
					else
					{
						simplyCombine = true;
					}
					if (gameObject.GetComponent<Renderer>().sharedMaterial.GetFloat("_BendingControls") == 1f)
					{
						useUV4 = true;
					}
				}
				break;
			}
			MeshFilter meshFilter3 = (MeshFilter)gameObject.GetComponent(typeof(MeshFilter));
			if (UnityEngine.Application.isPlaying)
			{
				meshFilter3.mesh = MeshCombineUtilityAFS.Combine(combines, bakeGroundLightingGrass, bakeGroundLightingFoliage, randomBrightness, randomPulse, randomBending, randomFluttering, HealthyColor, DryColor, NoiseSpread, bakeScale, simplyCombine, NoiseSpreadFoliage, createUniqueUV2playmode, useUV4);
			}
			else
			{
				meshFilter3.sharedMesh = MeshCombineUtilityAFS.Combine(combines, bakeGroundLightingGrass, bakeGroundLightingFoliage, randomBrightness, randomPulse, randomBending, randomFluttering, HealthyColor, DryColor, NoiseSpread, bakeScale, simplyCombine, NoiseSpreadFoliage, createUniqueUV2, useUV4);
			}
			if (CastShadows)
			{
				gameObject.GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.On;
			}
			else
			{
				gameObject.GetComponent<Renderer>().shadowCastingMode = ShadowCastingMode.Off;
			}
			if (UseLightprobes)
			{
				gameObject.GetComponent<Renderer>().useLightProbes = true;
			}
			else
			{
				gameObject.GetComponent<Renderer>().useLightProbes = false;
			}
		}
	}
}
[ExecuteInEditMode]
public class DebugNormalsInEditmode : MonoBehaviour
{
	private CombineChildrenAFS cc;

	private void Update()
	{
		if (UnityEngine.Application.isPlaying)
		{
			return;
		}
		cc = GetComponent<CombineChildrenAFS>();
		Component[] componentsInChildren = GetComponentsInChildren(typeof(MeshFilter));
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Renderer component = componentsInChildren[i].GetComponent<Renderer>();
			Vector3 position = component.transform.position;
			if (cc.GroundMaxDistance < 0f)
			{
				cc.GroundMaxDistance = 0.01f;
			}
			if (Physics.Raycast(position + Vector3.up * cc.GroundMaxDistance * 0.5f, Vector3.down, out var hitInfo, cc.GroundMaxDistance))
			{
				Debug.DrawLine(position + Vector3.up * cc.GroundMaxDistance * 0.5f, position - cc.GroundMaxDistance * Vector3.up * 0.5f, Color.green, 0.1f, depthTest: false);
				Debug.DrawLine(position, position + 1f * hitInfo.normal, Color.red, 0.1f, depthTest: false);
				if (!cc.UnderlayingTerrain)
				{
					continue;
				}
				Vector3 vector = (hitInfo.point - cc.UnderlayingTerrain.transform.position) / cc.UnderlayingTerrain.terrainData.size.x;
				if (hitInfo.transform.gameObject.name == cc.UnderlayingTerrain.name)
				{
					if (cc.debugNormals)
					{
						Debug.DrawLine(position, position + cc.UnderlayingTerrain.terrainData.GetInterpolatedNormal(vector.x, vector.z), Color.blue, 5f, depthTest: false);
					}
					hitInfo.normal = cc.UnderlayingTerrain.terrainData.GetInterpolatedNormal(vector.x, vector.z);
				}
			}
			else
			{
				hitInfo.normal = new Vector3(0f, 1f, 0f);
				Debug.DrawLine(position, position + 1f * hitInfo.normal, Color.yellow, 0.1f, depthTest: false);
			}
		}
	}
}
public class MeshCombineUtilityAFS
{
	public struct MeshInstance
	{
		public Mesh mesh;

		public int subMeshIndex;

		public Matrix4x4 transform;

		public Vector3 groundNormal;

		public float scale;

		public Vector3 pivot;
	}

	public static Mesh Combine(MeshInstance[] combines, bool bakeGroundLightingGrass, bool bakeGroundLightingFoliage, float randomBrightness, float randomPulse, float randomBending, float randomFluttering, Color HealthyColor, Color DryColor, float NoiseSpread, bool bakeScale, bool simplyCombine, float NoiseSpreadFoliage, bool createUniqueUV2, bool useUV4)
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < combines.Length; i++)
		{
			MeshInstance meshInstance = combines[i];
			if ((bool)meshInstance.mesh)
			{
				num += meshInstance.mesh.vertexCount;
				num2 += meshInstance.mesh.GetTriangles(meshInstance.subMeshIndex).Length;
			}
		}
		Vector3[] array = new Vector3[num];
		Vector3[] array2 = new Vector3[num];
		Vector4[] array3 = new Vector4[num];
		Vector2[] array4 = new Vector2[num];
		Vector2[] array5 = new Vector2[num];
		Color[] array6 = new Color[num];
		Vector2[] array7 = new Vector2[num];
		int[] array8 = new int[num2];
		int offset = 0;
		bool flag = false;
		for (int j = 0; j < combines.Length; j++)
		{
			MeshInstance meshInstance2 = combines[j];
			if ((bool)meshInstance2.mesh)
			{
				Copy(meshInstance2.mesh.vertexCount, meshInstance2.mesh.vertices, array, ref offset, meshInstance2.transform);
			}
		}
		offset = 0;
		for (int k = 0; k < combines.Length; k++)
		{
			MeshInstance meshInstance3 = combines[k];
			if ((bool)meshInstance3.mesh)
			{
				Matrix4x4 transform = meshInstance3.transform;
				transform = transform.inverse.transpose;
				if (bakeGroundLightingGrass)
				{
					CopyNormalGround(meshInstance3.mesh.vertexCount, meshInstance3.mesh.normals, array2, ref offset, transform, meshInstance3.groundNormal);
				}
				else
				{
					CopyNormal(meshInstance3.mesh.vertexCount, meshInstance3.mesh.normals, array2, ref offset, transform);
				}
			}
		}
		offset = 0;
		for (int l = 0; l < combines.Length; l++)
		{
			MeshInstance meshInstance4 = combines[l];
			if ((bool)meshInstance4.mesh)
			{
				Matrix4x4 transform2 = meshInstance4.transform;
				transform2 = transform2.inverse.transpose;
				CopyTangents(meshInstance4.mesh.vertexCount, meshInstance4.mesh.tangents, array3, ref offset, transform2);
			}
		}
		offset = 0;
		for (int m = 0; m < combines.Length; m++)
		{
			MeshInstance meshInstance5 = combines[m];
			if ((bool)meshInstance5.mesh)
			{
				Copy(meshInstance5.mesh.vertexCount, meshInstance5.mesh.uv, array4, ref offset);
			}
		}
		offset = 0;
		if (bakeGroundLightingFoliage)
		{
			for (int n = 0; n < combines.Length; n++)
			{
				MeshInstance meshInstance6 = combines[n];
				if ((bool)meshInstance6.mesh)
				{
					Copy_uv1(meshInstance6.mesh.vertexCount, meshInstance6.mesh.uv, array5, ref offset, new Vector2(meshInstance6.groundNormal.x, meshInstance6.groundNormal.z));
				}
			}
			offset = 0;
		}
		for (int num3 = 0; num3 < combines.Length; num3++)
		{
			MeshInstance meshInstance7 = combines[num3];
			if (meshInstance7.mesh.uv4 != null && useUV4)
			{
				flag = true;
				Copy_uv4(meshInstance7.mesh.vertexCount, meshInstance7.mesh.uv4, array7, ref offset, meshInstance7.scale, bakeScale, meshInstance7.pivot, NoiseSpreadFoliage, randomBending);
			}
		}
		offset = 0;
		for (int num4 = 0; num4 < combines.Length; num4++)
		{
			MeshInstance meshInstance8 = combines[num4];
			if ((bool)meshInstance8.mesh)
			{
				if (bakeGroundLightingGrass)
				{
					CopyColors_grass(meshInstance8.mesh.vertexCount, meshInstance8.mesh.colors, array6, ref offset, HealthyColor, DryColor, NoiseSpread, meshInstance8.pivot);
				}
				else
				{
					CopyColors(meshInstance8.mesh.vertexCount, meshInstance8.mesh.colors, array6, ref offset, meshInstance8.scale, bakeScale, meshInstance8.pivot, NoiseSpreadFoliage, randomPulse, randomFluttering, randomBrightness, randomBending, flag);
				}
			}
		}
		int num5 = 0;
		int num6 = 0;
		for (int num7 = 0; num7 < combines.Length; num7++)
		{
			MeshInstance meshInstance9 = combines[num7];
			if ((bool)meshInstance9.mesh)
			{
				int[] triangles = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				for (int num8 = 0; num8 < triangles.Length; num8++)
				{
					array8[num8 + num5] = triangles[num8] + num6;
				}
				num5 += triangles.Length;
				num6 += meshInstance9.mesh.vertexCount;
				triangles = null;
			}
		}
		Mesh mesh = new Mesh();
		mesh.name = "Combined Mesh";
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.colors = array6;
		mesh.uv = array4;
		if (bakeGroundLightingFoliage)
		{
			mesh.uv2 = array5;
		}
		if (flag)
		{
			mesh.uv4 = array7;
		}
		mesh.tangents = array3;
		mesh.triangles = array8;
		array = null;
		array2 = null;
		array3 = null;
		array4 = null;
		array5 = null;
		array6 = null;
		array8 = null;
		return mesh;
	}

	private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			ref Vector3 reference = ref dst[i + offset];
			reference = transform.MultiplyPoint(src[i]);
		}
		offset += vertexcount;
	}

	private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			ref Vector3 reference = ref dst[i + offset];
			reference = transform.MultiplyVector(src[i]).normalized;
		}
		offset += vertexcount;
	}

	private static void CopyNormalGround(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform, Vector3 groundNormal)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = groundNormal;
		}
		offset += vertexcount;
	}

	private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			ref Vector2 reference = ref dst[i + offset];
			reference = src[i];
		}
		offset += vertexcount;
	}

	private static void Copy_uv4(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset, float scale, bool bakeScale, Vector3 pivot, float NoiseSpread, float randomBending)
	{
		float num = Mathf.PerlinNoise(pivot.x, pivot.y);
		if (!bakeScale)
		{
			scale = 1f;
		}
		for (int i = 0; i < src.Length; i++)
		{
			ref Vector2 reference = ref dst[i + offset];
			reference = new Vector2(src[i].x * scale * (1f - randomBending * num), src[i].y);
		}
		offset += vertexcount;
	}

	private static void Copy_uv1(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset, Vector2 groundNormal)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = groundNormal;
		}
		offset += vertexcount;
	}

	private static void CopyColors(int vertexcount, Color[] src, Color[] dst, ref int offset, float scale, bool bakeScale, Vector3 pivot, float NoiseSpread, float randomPulse, float randomFluttering, float randomBrightness, float randomBending, bool copyUV4)
	{
		float num = Mathf.PerlinNoise(pivot.x * pivot.x, pivot.z * pivot.z);
		float num2 = Mathf.PerlinNoise(pivot.x * pivot.x * pivot.x, pivot.z * pivot.z * pivot.z);
		for (int i = 0; i < src.Length; i++)
		{
			src[i].r += randomPulse * num * 0.25f;
			src[i].g = src[i].g * (1f + randomFluttering * (num - 0.5f));
			if (bakeScale)
			{
				src[i].b = src[i].b * scale * (1f + randomBending * num);
			}
			else
			{
				src[i].b = src[i].b * (1f + randomBending * num);
			}
			if (copyUV4)
			{
				src[i].b = randomPulse * num2 * num2;
			}
			src[i].a = src[i].a - num * randomBrightness;
			ref Color reference = ref dst[i + offset];
			reference = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyColors_groundNormal_old(int vertexcount, Color[] src, Color[] dst, ref int offset, Color RandColor, Vector2 groundNormal)
	{
		for (int i = 0; i < src.Length; i++)
		{
			ref Color reference = ref dst[i + offset];
			reference = src[i] + RandColor;
			dst[i + offset].r = groundNormal.x;
			dst[i + offset].g = groundNormal.y;
		}
		offset += vertexcount;
	}

	private static void CopyColors_grass(int vertexcount, Color[] src, Color[] dst, ref int offset, Color HealthyColor, Color DryColor, float NoiseSpread, Vector3 pivot)
	{
		Color color = Color.Lerp(HealthyColor, DryColor, Mathf.PerlinNoise(pivot.x * NoiseSpread, pivot.y * NoiseSpread));
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset].a = src[i].a;
			dst[i + offset].r = Mathf.Lerp(1f, color.r, color.a) * src[i].b;
			dst[i + offset].g = Mathf.Lerp(1f, color.g, color.a) * src[i].b;
			dst[i + offset].b = Mathf.Lerp(1f, color.b, color.a) * src[i].b;
		}
		offset += vertexcount;
	}

	private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			Vector4 vector = src[i];
			Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
			vector2 = transform.MultiplyVector(vector2).normalized;
			ref Vector4 reference = ref dst[i + offset];
			reference = new Vector4(vector2.x, vector2.y, vector2.z, vector.w);
		}
		offset += vertexcount;
	}
}
[ExecuteInEditMode]
[AddComponentMenu("AFS/Setup Advanced Foliage Shader")]
public class SetupAdvancedFoliageShader : MonoBehaviour
{
	public bool isLinear;

	public bool AmbientLightingSH;

	public GameObject TerrianLight0;

	public GameObject TerrianLight1;

	public GameObject DirectionalLightReference;

	private Vector3 DirectlightDir;

	private Light Sunlight;

	private Vector3 SunLightCol;

	private float SunLuminance;

	public bool GrassApproxTrans;

	public int AFSFog_Mode = 2;

	public string AFSShader_Folder = "Assets/Advanced Foliage Shader v4/Shaders/";

	public bool disableFoginShader;

	public Vector4 Wind = new Vector4(0.85f, 0.075f, 0.4f, 0.5f);

	[Range(0.01f, 2f)]
	public float WindFrequency = 0.25f;

	[Range(0.1f, 25f)]
	public float WaveSizeFoliageShader = 10f;

	[Range(0f, 10f)]
	public float LeafTurbulenceFoliageShader = 4f;

	[Range(0.01f, 1f)]
	public float WindMultiplierForGrassshader = 1f;

	[Range(0f, 10f)]
	public float WaveSizeForGrassshader = 1f;

	[Range(0f, 1f)]
	public float WindJitterFrequencyForGrassshader = 0.25f;

	[Range(0f, 1f)]
	public float WindJitterScaleForGrassshader = 0.15f;

	public bool SyncWindDir;

	[Range(0f, 10f)]
	public float WindMuliplierForTreeShaderPrimary = 1f;

	[Range(0f, 10f)]
	public float WindMuliplierForTreeShaderSecondary = 1f;

	public Vector4 WindMuliplierForTreeShader = new Vector4(1f, 1f, 1f, 1f);

	private float temp_WindFrequency = 0.25f;

	private float temp_WindJitterFrequency = 0.25f;

	private const float TwoPI = (float)Math.PI * 2f;

	private float freqSpeed = 0.05f;

	private float domainTime_Wind;

	private float domainTime_2ndBending;

	private float domainTime_Grass;

	[Range(0f, 1f)]
	public float RainAmount;

	[Range(0f, 1f)]
	public float VertexLitAlphaCutOff = 0.3f;

	public Color VertexLitTranslucencyColor = new Color(0.73f, 0.85f, 0.4f, 1f);

	[Range(0f, 1f)]
	public float VertexLitTranslucencyViewDependency = 0.7f;

	[Range(0f, 1f)]
	public float VertexLitShadowStrength = 0.8f;

	public Color VertexLitSpecularReflectivity = new Color(0.2f, 0.2f, 0.2f, 1f);

	[Range(0f, 100f)]
	public Vector2 AfsSpecFade = new Vector2(30f, 10f);

	public Texture TerrainFoliageNrmSpecMap;

	public bool AutoSyncToTerrain;

	public Terrain SyncedTerrain;

	public bool AutoSyncInPlaymode;

	public float DetailDistanceForGrassShader = 80f;

	[Range(0f, 1000f)]
	public float BillboardStart = 50f;

	[Range(0f, 30f)]
	public float BillboardFadeLenght = 5f;

	public bool GrassAnimateNormal;

	public Color GrassWavingTint = Color.white;

	public Color AFSTreeColor = Color.black;

	private Camera MainCam;

	public bool TreeBillboardShadows;

	[Range(10f, 100f)]
	public float BillboardFadeOutLength = 60f;

	public bool BillboardAdjustToCamera = true;

	[Range(10f, 90f)]
	public float BillboardAngleLimit = 30f;

	public Color BillboardShadowColor;

	[Range(0f, 4f)]
	public float BillboardAmbientLightFactor = 1f;

	[Range(0f, 2f)]
	public float BillboardAmbientLightDesaturationFactor = 0.7f;

	public bool AutosyncShadowColor;

	public bool EnableCameraLayerCulling;

	[Range(10f, 300f)]
	public int SmallDetailsDistance = 70;

	[Range(10f, 300f)]
	public int MediumDetailsDistance = 90;

	public bool AllGrassObjectsCombined;

	private Vector4 TempWind;

	private float GrassWindSpeed;

	private float SinusWave;

	private Vector4 TriangleWaves;

	private float Oscillation;

	private Vector3 CameraForward = new Vector3(0f, 0f, 0f);

	private Vector3 ShadowCameraForward = new Vector3(0f, 0f, 0f);

	private Vector3 CameraForwardVec;

	private float rollingX;

	private float rollingXShadow;

	private Vector3 lightDir;

	private Vector3 templightDir;

	private float CameraAngle;

	private Terrain[] allTerrains;

	private Vector3[] fLight = new Vector3[9];

	private Vector4[] vCoeff = new Vector4[3];

	private void Awake()
	{
		afsSyncFrequencies();
		afsCheckColorSpace();
		afsLightingSettings();
		afsUpdateWind();
		afsUpdateRain();
		afsSetupTerrainEngine();
		afsAutoSyncToTerrain();
		afsUpdateGrassTreesBillboards();
		afsSetupCameraLayerCulling();
		afsFogSettings();
		afsSetupGrassShader();
	}

	public void Update()
	{
		afsLightingSettings();
		afsUpdateRain();
		afsAutoSyncToTerrain();
		afsUpdateGrassTreesBillboards();
	}

	public void FixedUpdate()
	{
		afsUpdateWind();
	}

	private void afsSyncFrequencies()
	{
		temp_WindFrequency = WindFrequency;
		temp_WindJitterFrequency = WindJitterFrequencyForGrassshader;
		domainTime_Wind = 0f;
		domainTime_2ndBending = 0f;
		domainTime_Grass = 0f;
	}

	private void afsCheckColorSpace()
	{
	}

	private void afsLightingSettings()
	{
		if (DirectionalLightReference != null)
		{
			DirectlightDir = DirectionalLightReference.transform.forward;
			if (Sunlight == null)
			{
				Sunlight = DirectionalLightReference.GetComponent<Light>();
			}
			if (!Sunlight.enabled)
			{
				Shader.SetGlobalVector("_AfsDirectSunDir", new Vector4(0f, 0f, 0f, 0f));
			}
			else
			{
				SunLightCol = new Vector3(Sunlight.color.r, Sunlight.color.g, Sunlight.color.b) * Sunlight.intensity;
				SunLuminance = Vector3.Dot(SunLightCol, new Vector3(0.22f, 0.707f, 0.071f));
				Shader.SetGlobalVector("_AfsDirectSunDir", new Vector4(DirectlightDir.x, DirectlightDir.y, DirectlightDir.z, SunLuminance));
				Shader.SetGlobalVector("_AfsDirectSunCol", SunLightCol);
			}
		}
		else
		{
			Shader.SetGlobalVector("_AfsDirectSunDir", new Vector4(0f, 0f, 0f, 0f));
			Shader.SetGlobalVector("_AfsDirectSunCol", new Vector3(0f, 0f, 0f));
		}
		UpdateLightingForClassicBillboards();
		Shader.SetGlobalVector("_AfsSpecFade", new Vector4(AfsSpecFade.x, AfsSpecFade.y, 1f, 1f));
		if (GrassApproxTrans)
		{
			Shader.EnableKeyword("_AFS_GRASS_APPROXTRANS");
		}
		else
		{
			Shader.DisableKeyword("_AFS_GRASS_APPROXTRANS");
		}
	}

	private void afsFogSettings()
	{
		if (disableFoginShader)
		{
			Shader.EnableKeyword("_AFS_DEFERRED");
		}
		else
		{
			Shader.DisableKeyword("_AFS_DEFERRED");
		}
	}

	private void afsSetupGrassShader()
	{
		if (UnityEngine.Application.isPlaying || AllGrassObjectsCombined)
		{
			Shader.DisableKeyword("IN_EDITMODE");
			Shader.EnableKeyword("IN_PLAYMODE");
		}
		else
		{
			Shader.DisableKeyword("IN_PLAYMODE");
			Shader.EnableKeyword("IN_EDITMODE");
		}
	}

	private void afsSetupTerrainEngine()
	{
		Shader.SetGlobalFloat("_AfsAlphaCutOff", VertexLitAlphaCutOff);
		Shader.SetGlobalFloat("_AfsTranslucencyViewDependency", VertexLitTranslucencyViewDependency);
		Shader.SetGlobalFloat("_AfsShadowStrength", VertexLitShadowStrength);
		Shader.SetGlobalColor("_AfsTranslucencyColor", VertexLitTranslucencyColor);
		if (isLinear)
		{
			Shader.SetGlobalColor("_AfsSpecularReflectivity", VertexLitSpecularReflectivity.linear);
		}
		else
		{
			Shader.SetGlobalColor("_AfsSpecularReflectivity", VertexLitSpecularReflectivity);
		}
		if (TerrainFoliageNrmSpecMap != null)
		{
			Shader.SetGlobalTexture("_TerrianBumpTransSpecMap", TerrainFoliageNrmSpecMap);
		}
		else
		{
			Shader.SetGlobalTexture("_TerrianBumpTransSpecMap", null);
		}
	}

	private void afsUpdateWind()
	{
		if (SyncWindDir)
		{
			Wind = new Vector4(base.transform.forward.x, base.transform.forward.y, base.transform.forward.z, Wind.w);
		}
		TempWind = Wind;
		TempWind.w *= 2f;
		Shader.SetGlobalVector("_Wind", TempWind);
		Shader.SetGlobalFloat("_WindFrequency", WindFrequency);
		domainTime_Wind += temp_WindFrequency * Time.deltaTime * 2f;
		domainTime_2ndBending += Time.deltaTime;
		Shader.SetGlobalVector("_AfsTimeFrequency", new Vector4(domainTime_Wind, domainTime_2ndBending, 0.375f * (1f + temp_WindFrequency * LeafTurbulenceFoliageShader), 0.193f * (1f + temp_WindFrequency * LeafTurbulenceFoliageShader)));
		temp_WindFrequency = Mathf.MoveTowards(temp_WindFrequency, WindFrequency, freqSpeed);
		SinusWave = Mathf.Sin(domainTime_Wind);
		TriangleWaves = SmoothTriangleWave(new Vector4(SinusWave, SinusWave * 0.8f, 0f, 0f));
		Oscillation = TriangleWaves.x + TriangleWaves.y * TriangleWaves.y;
		Oscillation = (Oscillation + 8f) * 0.125f * TempWind.w;
		TempWind.x *= Oscillation;
		TempWind.z *= Oscillation;
		Shader.SetGlobalFloat("_AfsWaveSize", 0.5f / WaveSizeFoliageShader);
		Shader.SetGlobalFloat("_AfsWindJitterScale", WindJitterScaleForGrassshader * 10f);
		Shader.SetGlobalVector("_AfsGrassWind", TempWind * WindMultiplierForGrassshader);
		domainTime_Grass += temp_WindJitterFrequency * Time.deltaTime;
		temp_WindJitterFrequency = Mathf.MoveTowards(temp_WindJitterFrequency, WindJitterFrequencyForGrassshader, freqSpeed);
		GrassWindSpeed = domainTime_Grass * 0.1f;
		Shader.SetGlobalVector("_AfsWaveAndDistance", new Vector4(GrassWindSpeed, WaveSizeForGrassshader, TempWind.w, DetailDistanceForGrassShader * DetailDistanceForGrassShader));
		Shader.SetGlobalVector("_AFSWindMuliplier", WindMuliplierForTreeShader);
	}

	private void afsUpdateRain()
	{
		Shader.SetGlobalFloat("_AfsRainamount", RainAmount);
	}

	private void afsAutoSyncToTerrain()
	{
		if (AutoSyncToTerrain && SyncedTerrain != null)
		{
			DetailDistanceForGrassShader = SyncedTerrain.detailObjectDistance;
			BillboardStart = SyncedTerrain.treeBillboardDistance;
			if (UnityEngine.Application.isPlaying && !TreeBillboardShadows)
			{
				BillboardFadeLenght = SyncedTerrain.treeCrossFadeLength;
			}
			GrassWavingTint = SyncedTerrain.terrainData.wavingGrassTint;
		}
	}

	private void afsUpdateGrassTreesBillboards()
	{
		Shader.SetGlobalColor("_AfsWavingTint", GrassWavingTint);
		Shader.SetGlobalColor("_AfsTreeColor", AFSTreeColor);
		Shader.SetGlobalVector("_AfsTerrainTrees", new Vector4(BillboardStart, BillboardFadeLenght, BillboardFadeOutLength, 0f));
		if (BillboardAdjustToCamera)
		{
			if ((bool)Camera.main)
			{
				MainCam = Camera.main;
				CameraForward = MainCam.transform.forward;
				ShadowCameraForward = CameraForward;
				rollingX = MainCam.transform.eulerAngles.x;
				if (rollingX >= 270f)
				{
					rollingX -= 270f;
					rollingX = 90f - rollingX;
					rollingXShadow = rollingX;
				}
				else
				{
					rollingXShadow = 0f - rollingX;
					if (rollingX > BillboardAngleLimit)
					{
						rollingX = Mathf.Lerp(rollingX, 0f, rollingX / BillboardAngleLimit - 1f);
					}
					rollingX *= -1f;
				}
			}
		}
		else
		{
			rollingX = 0f;
			rollingXShadow = 0f;
		}
		CameraForward *= rollingX / 90f;
		ShadowCameraForward *= rollingXShadow / 90f;
		Shader.SetGlobalVector("_AfsBillboardCameraForward", new Vector4(CameraForward.x, CameraForward.y, CameraForward.z, 1f));
		Shader.SetGlobalVector("_AfsBillboardShadowCameraForward", new Vector4(ShadowCameraForward.x, ShadowCameraForward.y, ShadowCameraForward.z, 1f));
	}

	private void afsSetupCameraLayerCulling()
	{
		if (EnableCameraLayerCulling)
		{
			for (int i = 0; i < Camera.allCameras.Length; i++)
			{
				float[] array = new float[32];
				array = Camera.allCameras[i].layerCullDistances;
				array[8] = SmallDetailsDistance;
				array[9] = MediumDetailsDistance;
				Camera.allCameras[i].layerCullDistances = array;
				array = null;
			}
		}
	}

	private void UpdateLightingForClassicBillboards()
	{
		if (RenderSettings.ambientMode == AmbientMode.Skybox)
		{
			AmbientLightingSH = true;
			UdpateSHLightingforBillboards();
			Shader.EnableKeyword("AFS_SH_AMBIENT");
			Shader.DisableKeyword("AFS_COLOR_AMBIENT");
			Shader.DisableKeyword("AFS_GRADIENT_AMBIENT");
		}
		else if (RenderSettings.ambientMode == AmbientMode.Trilight)
		{
			AmbientLightingSH = false;
			if (isLinear)
			{
				Shader.SetGlobalColor("_AfsSkyColor", RenderSettings.ambientSkyColor.linear);
				Shader.SetGlobalColor("_AfsGroundColor", RenderSettings.ambientGroundColor.linear);
				Shader.SetGlobalColor("_AfsEquatorColor", RenderSettings.ambientEquatorColor.linear);
			}
			else
			{
				Shader.SetGlobalColor("_AfsSkyColor", RenderSettings.ambientSkyColor);
				Shader.SetGlobalColor("_AfsGroundColor", RenderSettings.ambientGroundColor);
				Shader.SetGlobalColor("_AfsEquatorColor", RenderSettings.ambientEquatorColor);
			}
			Shader.DisableKeyword("AFS_SH_AMBIENT");
			Shader.DisableKeyword("AFS_COLOR_AMBIENT");
			Shader.EnableKeyword("AFS_GRADIENT_AMBIENT");
		}
		else if (RenderSettings.ambientMode == AmbientMode.Flat)
		{
			AmbientLightingSH = false;
			Shader.SetGlobalVector("_AfsAmbientColor", RenderSettings.ambientLight);
			Shader.DisableKeyword("AFS_SH_AMBIENT");
			Shader.EnableKeyword("AFS_COLOR_AMBIENT");
			Shader.DisableKeyword("AFS_GRADIENT_AMBIENT");
		}
	}

	private void UdpateSHLightingforBillboards()
	{
		fLight[0].x = RenderSettings.ambientProbe[0, 0];
		fLight[0].y = RenderSettings.ambientProbe[1, 0];
		fLight[0].z = RenderSettings.ambientProbe[2, 0];
		fLight[1].x = RenderSettings.ambientProbe[0, 1];
		fLight[1].y = RenderSettings.ambientProbe[1, 1];
		fLight[1].z = RenderSettings.ambientProbe[2, 1];
		fLight[2].x = RenderSettings.ambientProbe[0, 2];
		fLight[2].y = RenderSettings.ambientProbe[1, 2];
		fLight[2].z = RenderSettings.ambientProbe[2, 2];
		fLight[3].x = RenderSettings.ambientProbe[0, 3];
		fLight[3].y = RenderSettings.ambientProbe[1, 3];
		fLight[3].z = RenderSettings.ambientProbe[2, 3];
		fLight[4].x = RenderSettings.ambientProbe[0, 4];
		fLight[4].y = RenderSettings.ambientProbe[1, 4];
		fLight[4].z = RenderSettings.ambientProbe[2, 4];
		fLight[5].x = RenderSettings.ambientProbe[0, 5];
		fLight[5].y = RenderSettings.ambientProbe[1, 5];
		fLight[5].z = RenderSettings.ambientProbe[2, 5];
		fLight[6].x = RenderSettings.ambientProbe[0, 6];
		fLight[6].y = RenderSettings.ambientProbe[1, 6];
		fLight[6].z = RenderSettings.ambientProbe[2, 6];
		fLight[7].x = RenderSettings.ambientProbe[0, 7];
		fLight[7].y = RenderSettings.ambientProbe[1, 7];
		fLight[7].z = RenderSettings.ambientProbe[2, 7];
		fLight[8].x = RenderSettings.ambientProbe[0, 8];
		fLight[8].y = RenderSettings.ambientProbe[1, 8];
		fLight[8].z = RenderSettings.ambientProbe[2, 8];
		float num = 3.5449078f;
		float num2 = 1f / (2f * num);
		float num3 = Mathf.Sqrt(3f) / (3f * num);
		float num4 = Mathf.Sqrt(15f) / (8f * num);
		float num5 = Mathf.Sqrt(5f) / (16f * num);
		float num6 = 0.5f * num4;
		for (int i = 0; i < 3; i++)
		{
			vCoeff[i].x = (0f - num3) * fLight[3][i];
			vCoeff[i].y = (0f - num3) * fLight[1][i];
			vCoeff[i].z = num3 * fLight[2][i];
			vCoeff[i].w = num2 * fLight[0][i] - num5 * fLight[6][i];
		}
		Shader.SetGlobalVector("afs_SHAr", vCoeff[0] * RenderSettings.ambientIntensity);
		Shader.SetGlobalVector("afs_SHAg", vCoeff[1] * RenderSettings.ambientIntensity);
		Shader.SetGlobalVector("afs_SHAb", vCoeff[2] * RenderSettings.ambientIntensity);
		for (int i = 0; i < 3; i++)
		{
			vCoeff[i].x = num4 * fLight[4][i];
			vCoeff[i].y = (0f - num4) * fLight[5][i];
			vCoeff[i].z = 3f * num5 * fLight[6][i];
			vCoeff[i].w = (0f - num4) * fLight[7][i];
		}
		Shader.SetGlobalVector("afs_SHBr", vCoeff[0] * RenderSettings.ambientIntensity);
		Shader.SetGlobalVector("afs_SHBg", vCoeff[1] * RenderSettings.ambientIntensity);
		Shader.SetGlobalVector("afs_SHBb", vCoeff[2] * RenderSettings.ambientIntensity);
		vCoeff[0].x = num6 * fLight[8][0];
		vCoeff[0].y = num6 * fLight[8][1];
		vCoeff[0].z = num6 * fLight[8][2];
		vCoeff[0].w = 1f;
		Shader.SetGlobalVector("afs_SHC", vCoeff[0] * RenderSettings.ambientIntensity);
	}

	private Color Desaturate(float r, float g, float b)
	{
		float num = 0.3f * r + 0.59f * g + 0.11f * b;
		r = num * BillboardAmbientLightDesaturationFactor + r * (1f - BillboardAmbientLightDesaturationFactor);
		g = num * BillboardAmbientLightDesaturationFactor + g * (1f - BillboardAmbientLightDesaturationFactor);
		b = num * BillboardAmbientLightDesaturationFactor + b * (1f - BillboardAmbientLightDesaturationFactor);
		return new Color(r, g, b, 1f);
	}

	private float CubicSmooth(float x)
	{
		return x * x * (3f - 2f * x);
	}

	private float TriangleWave(float x)
	{
		return Mathf.Abs((x + 0.5f) % 1f * 2f - 1f);
	}

	private float SmoothTriangleWave(float x)
	{
		return CubicSmooth(TriangleWave(x));
	}

	private Vector4 CubicSmooth(Vector4 x)
	{
		x = Vector4.Scale(x, x);
		x = Vector4.Scale(x, new Vector4(3f, 3f, 3f, 3f) - 2f * x);
		return x;
	}

	private Vector4 TriangleWave(Vector4 x)
	{
		x = (x + new Vector4(0.5f, 0.5f, 0.5f, 0.5f)) * 2f - new Vector4(1f, 1f, 1f, 1f);
		return AbsVecFour(x);
	}

	private Vector4 SmoothTriangleWave(Vector4 x)
	{
		return CubicSmooth(TriangleWave(x));
	}

	private Vector4 FracVecFour(Vector4 a)
	{
		a.x %= 1f;
		a.y %= 1f;
		a.z %= 1f;
		a.w %= 1f;
		return a;
	}

	private Vector4 AbsVecFour(Vector4 a)
	{
		a.x = Mathf.Abs(a.x);
		a.y = Mathf.Abs(a.y);
		a.z = Mathf.Abs(a.z);
		a.w = Mathf.Abs(a.w);
		return a;
	}
}
[AddComponentMenu("AFS/Touch Bending/CollisionGS")]
public class touchBendingCollisionGS : MonoBehaviour
{
	public Material simpleBendingMaterial;

	public Material touchBendingMaterial;

	public float stiffness = 10f;

	public float disturbance = 0.3f;

	public float duration = 5f;

	private Transform myTransform;

	private Renderer myRenderer;

	private Matrix4x4 myMatrix;

	private Vector3 axis;

	private Vector3 axis1;

	private bool touched;

	private bool doubletouched;

	private bool left;

	private bool finished = true;

	private bool left1;

	private bool finished1 = true;

	private float intialTouchForce;

	private float touchBending;

	private float targetTouchBending;

	private float easingControl;

	private float intialTouchForce1;

	private float touchBending1;

	private float targetTouchBending1;

	private float easingControl1;

	private int Player_ID;

	private touchBendingPlayerListener PlayerVars;

	private Vector3 Player_Direction;

	private float Player_Speed;

	private int Player1_ID;

	private touchBendingPlayerListener PlayerVars1;

	private Vector3 Player_Direction1;

	private float Player_Speed1;

	private float timer;

	private float timer1;

	private float lerptime;

	private void Awake()
	{
		myTransform = base.transform;
		myRenderer = GetComponent<Renderer>();
	}

	private void Start()
	{
		myRenderer.sharedMaterial = simpleBendingMaterial;
	}

	private void OnTriggerEnter(Collider other)
	{
		touchBendingPlayerListener component = other.GetComponent<touchBendingPlayerListener>();
		if (!(component != null) || !component.enabled)
		{
			return;
		}
		if (!touched)
		{
			Player_ID = other.GetInstanceID();
			UnityEngine.Object.Destroy(myRenderer.material);
			PlayerVars = component;
			Player_Direction = PlayerVars.Player_Direction;
			Player_Speed = PlayerVars.Player_Speed;
			intialTouchForce = Player_Speed;
			myRenderer.material = touchBendingMaterial;
			myRenderer.material.SetVector("_TouchBendingPosition", new Vector4(myTransform.position.x, myTransform.position.y, myTransform.position.z, 0f));
			axis = PlayerVars.Player_Direction;
			axis = Quaternion.Euler(0f, 90f, 0f) * axis;
			timer = 0f;
			touched = true;
			left = false;
			targetTouchBending = 1f;
			touchBending = targetTouchBending;
			finished = false;
			return;
		}
		if (doubletouched)
		{
			SwapTouchBending();
		}
		Player1_ID = other.GetInstanceID();
		PlayerVars1 = component;
		Player_Direction1 = PlayerVars1.Player_Direction;
		Player_Speed1 = PlayerVars1.Player_Speed;
		intialTouchForce1 = Player_Speed1;
		axis1 = Player_Direction1;
		axis1 = Quaternion.Euler(0f, 90f, 0f) * axis1;
		timer1 = 0f;
		left1 = false;
		targetTouchBending1 = 1f;
		touchBending1 = targetTouchBending1;
		finished1 = false;
		lerptime = duration - timer;
		doubletouched = true;
	}

	private void OnTriggerExit(Collider other)
	{
		if (Player_ID != Player1_ID)
		{
			if (other.GetInstanceID() == Player_ID)
			{
				left = true;
				targetTouchBending = 0f;
			}
			else
			{
				left1 = true;
				targetTouchBending1 = 0f;
			}
		}
		else
		{
			left = true;
			targetTouchBending = 0f;
			left1 = true;
			targetTouchBending1 = 0f;
		}
	}

	private void Update()
	{
		if (!touched)
		{
			return;
		}
		Player_Speed = PlayerVars.Player_Speed;
		touchBending = Mathf.Lerp(touchBending, targetTouchBending, timer / duration);
		easingControl = Bounce(timer);
		if (!doubletouched)
		{
			if (finished && targetTouchBending == 0f)
			{
				ResetTouchBending();
				return;
			}
			Quaternion q = Quaternion.Euler(axis * (intialTouchForce * stiffness) * easingControl);
			myMatrix.SetTRS(Vector3.zero, q, new Vector3(1f, 1f, 1f));
			myRenderer.material.SetMatrix("_RotMatrix", myMatrix);
			myRenderer.material.SetVector("_TouchBendingForce", new Vector4(Player_Direction.x, Player_Direction.y, Player_Direction.z, Player_Speed * easingControl * disturbance));
			if (left)
			{
				timer += Time.deltaTime;
			}
			else
			{
				timer += Time.deltaTime * Player_Speed;
			}
			return;
		}
		if (finished && targetTouchBending == 0f)
		{
			SwapTouchBending();
			doubletouched = false;
			Player_Speed = PlayerVars.Player_Speed;
			touchBending = Mathf.Lerp(touchBending, targetTouchBending, timer / duration);
			easingControl = Bounce(timer);
			if (finished && targetTouchBending == 0f)
			{
				ResetTouchBending();
				return;
			}
			Quaternion q2 = Quaternion.Euler(axis * (intialTouchForce * stiffness) * easingControl);
			myMatrix.SetTRS(Vector3.zero, q2, new Vector3(1f, 1f, 1f));
			myRenderer.material.SetMatrix("_RotMatrix", myMatrix);
			myRenderer.material.SetVector("_TouchBendingForce", new Vector4(Player_Direction.x, Player_Direction.y, Player_Direction.z, Player_Speed * easingControl * disturbance));
			if (left)
			{
				timer += Time.deltaTime;
			}
			else
			{
				timer += Time.deltaTime * Player_Speed;
			}
			return;
		}
		Player_Speed1 = PlayerVars1.Player_Speed;
		touchBending1 = Mathf.Lerp(touchBending1, targetTouchBending1, timer1 / duration);
		easingControl1 = Bounce1(timer1);
		if (finished1 && targetTouchBending1 == 0f)
		{
			doubletouched = false;
			return;
		}
		Quaternion q3 = Quaternion.Euler(axis * (intialTouchForce * stiffness) * easingControl);
		Quaternion quaternion = Quaternion.Euler(axis1 * (intialTouchForce1 * stiffness) * easingControl1);
		q3 *= quaternion;
		myMatrix.SetTRS(Vector3.zero, q3, new Vector3(1f, 1f, 1f));
		myRenderer.material.SetMatrix("_RotMatrix", myMatrix);
		myRenderer.material.SetVector("_TouchBendingForce", Vector4.Lerp(new Vector4(Player_Direction.x, Player_Direction.y, Player_Direction.z, Player_Speed * easingControl1 * disturbance), new Vector4(Player_Direction1.x, Player_Direction1.y, Player_Direction1.z, Player_Speed1 * easingControl1 * disturbance), timer1 / (lerptime + 0.0001f) * 8f));
		if (left)
		{
			timer += Time.deltaTime;
		}
		else
		{
			timer += Time.deltaTime * Player_Speed;
		}
		if (left1)
		{
			timer1 += Time.deltaTime;
		}
		else
		{
			timer1 += Time.deltaTime * Player_Speed1;
		}
	}

	public float Bounce(float x)
	{
		if (x / duration >= 1f)
		{
			if (easingControl == 0f && left)
			{
				finished = true;
			}
			return targetTouchBending;
		}
		return Mathf.Lerp(Mathf.Sin(x * 10f / duration) / (x + 1.25f) * 8f, touchBending, Mathf.Sqrt(x / duration));
	}

	public float Bounce1(float x)
	{
		if (x / duration >= 1f)
		{
			if (easingControl1 == 0f && left1)
			{
				finished1 = true;
			}
			return targetTouchBending1;
		}
		return Mathf.Lerp(Mathf.Sin(x * 10f / duration) / (x + 1.25f) * 8f, touchBending1, Mathf.Sqrt(x / duration));
	}

	public void SwapTouchBending()
	{
		Player_ID = Player1_ID;
		PlayerVars = PlayerVars1;
		Player_Direction = Player_Direction1;
		Player_Speed = Player_Speed1;
		intialTouchForce = intialTouchForce1;
		touchBending = touchBending1;
		targetTouchBending = targetTouchBending1;
		easingControl = easingControl1;
		left = left1;
		finished = finished1;
		axis = axis1;
		timer = timer1;
	}

	public void ResetTouchBending()
	{
		UnityEngine.Object.DestroyImmediate(myRenderer.material);
		myRenderer.sharedMaterial = simpleBendingMaterial;
		touched = false;
		doubletouched = false;
	}
}
[AddComponentMenu("AFS/Touch Bending/Player Listener")]
public class touchBendingPlayerListener : MonoBehaviour
{
	public float maxSpeed = 8f;

	public float Player_DampSpeed = 0.75f;

	private Transform myTransform;

	private Vector3 Player_Position;

	private Vector3 Player_OldPosition;

	public float Player_Speed;

	private float Player_NewSpeed;

	public Vector3 Player_Direction;

	public bool Update_PlayerVars = true;

	private void Awake()
	{
		myTransform = base.transform;
	}

	private void Start()
	{
		Player_Position = base.transform.position;
		Player_OldPosition = Player_Position;
	}

	private void LateUpdate()
	{
		Player_Position = myTransform.position;
		Player_NewSpeed = (Player_Position - Player_OldPosition).magnitude / Time.deltaTime / maxSpeed;
		float num = 1f - Mathf.Exp(-20f * Time.deltaTime);
		float num2 = 0.25f * num;
		num *= 0.125f;
		if (Player_NewSpeed < Player_Speed)
		{
			Player_Speed = Mathf.Lerp(Player_Speed, Player_NewSpeed, num * Player_DampSpeed);
		}
		else
		{
			Player_Speed = Mathf.Lerp(Player_Speed, Player_NewSpeed, num2 * Player_DampSpeed);
		}
		if (Player_Position != Player_OldPosition)
		{
			Player_Direction = Vector3.Normalize(Player_Position - Player_OldPosition);
		}
		Player_OldPosition = Player_Position;
	}
}
[AddComponentMenu("")]
public abstract class PostProcessBase : MonoBehaviour
{
	protected Shader shader;

	private Material m_Material;

	protected Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = new Material(shader);
				m_Material.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_Material;
		}
	}

	protected void OnEnable()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shader || !shader.isSupported)
		{
			base.enabled = false;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_Material)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Aubergine/Image Effects/Wiggle")]
public sealed class PP_Wiggle : PostProcessBase
{
	public float speed = 10f;

	public float amplitude = 0.01f;

	private void Awake()
	{
		shader = Shader.Find("Hidden/Aubergine/ImageEffects/Wiggle");
	}

	private void Start()
	{
		base.material.SetFloat("_Speed", speed);
		base.material.SetFloat("_Amplitude", amplitude);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_Speed", speed);
		base.material.SetFloat("_Amplitude", amplitude);
		Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
public class RenderReflRefr : MonoBehaviour
{
	public LayerMask ReflectLayers = -1;

	public LayerMask RefractLayers = -1;

	public float ClipPlaneOffset = 0.07f;

	private RenderTexture reflTex;

	private RenderTexture refrTex;

	private Camera reflCam;

	private Camera refrCam;

	private static bool SafeGuard;

	public void OnWillRenderObject()
	{
		if (base.enabled && (bool)GetComponent<Renderer>() && (bool)GetComponent<Renderer>().sharedMaterial && GetComponent<Renderer>().enabled && SystemInfo.supportsRenderTextures)
		{
			Camera current = Camera.current;
			if ((bool)current && !SafeGuard)
			{
				SafeGuard = true;
				CreateTextures(256, 256, 16);
				CreateCameras(current);
				UpdateCameras(current);
				Vector3 position = base.transform.position;
				Vector3 up = base.transform.up;
				Vector4 planeEquation = GetPlaneEquation(up, position, ClipPlaneOffset);
				Matrix4x4 mtx = Matrix4x4.zero;
				SetReflectionMatrix(ref mtx, planeEquation);
				Vector3 position2 = current.transform.position;
				Vector3 position3 = mtx.MultiplyPoint(position2);
				reflCam.worldToCameraMatrix = current.worldToCameraMatrix * mtx;
				Vector4 plane = CameraSpacePlane(reflCam, position, up, ClipPlaneOffset, 1f);
				Matrix4x4 proj = current.projectionMatrix;
				SetObliqueMatrix(ref proj, plane);
				reflCam.projectionMatrix = proj;
				GL.SetRevertBackfacing(revertBackFaces: true);
				reflCam.transform.position = position3;
				Vector3 eulerAngles = current.transform.eulerAngles;
				reflCam.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
				reflCam.Render();
				reflCam.transform.position = position2;
				GL.SetRevertBackfacing(revertBackFaces: false);
				GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", reflTex);
				refrCam.worldToCameraMatrix = current.worldToCameraMatrix;
				Vector4 plane2 = CameraSpacePlane(refrCam, position, up, ClipPlaneOffset, -1f);
				Matrix4x4 proj2 = current.projectionMatrix;
				SetObliqueMatrix(ref proj2, plane2);
				refrCam.projectionMatrix = proj2;
				refrCam.transform.position = current.transform.position;
				refrCam.transform.rotation = current.transform.rotation;
				refrCam.Render();
				GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", refrTex);
				SafeGuard = false;
			}
		}
	}

	private void OnBecameVisible()
	{
		base.enabled = true;
	}

	private void OnBecameInvisible()
	{
		base.enabled = false;
	}

	private void OnDisable()
	{
		if ((bool)reflTex)
		{
			UnityEngine.Object.DestroyImmediate(reflTex);
			reflTex = null;
		}
		if ((bool)reflCam)
		{
			UnityEngine.Object.DestroyImmediate(reflCam.gameObject);
			reflCam = null;
		}
		if ((bool)refrTex)
		{
			UnityEngine.Object.DestroyImmediate(refrTex);
			refrTex = null;
		}
		if ((bool)refrCam)
		{
			UnityEngine.Object.DestroyImmediate(refrCam.gameObject);
			refrCam = null;
		}
	}

	private void OnDestroy()
	{
		if ((bool)reflTex)
		{
			UnityEngine.Object.DestroyImmediate(reflTex);
			reflTex = null;
		}
		if ((bool)reflCam)
		{
			UnityEngine.Object.DestroyImmediate(reflCam.gameObject);
			reflCam = null;
		}
		if ((bool)refrTex)
		{
			UnityEngine.Object.DestroyImmediate(refrTex);
			refrTex = null;
		}
		if ((bool)refrCam)
		{
			UnityEngine.Object.DestroyImmediate(refrCam.gameObject);
			refrCam = null;
		}
	}

	private void CreateTextures(int width, int height, int depth)
	{
		if (!reflTex)
		{
			reflTex = new RenderTexture(width, height, depth);
			reflTex.name = "ReflectTexture";
			reflTex.isPowerOfTwo = true;
			reflTex.hideFlags = HideFlags.DontSave;
		}
		if (!refrTex)
		{
			refrTex = new RenderTexture(width, height, depth);
			refrTex.name = "RefractTexture";
			refrTex.isPowerOfTwo = true;
			refrTex.hideFlags = HideFlags.DontSave;
		}
	}

	private void CreateCameras(Camera current)
	{
		if (!reflCam)
		{
			GameObject gameObject = new GameObject("ReflectCamera" + GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflCam = gameObject.GetComponent<Camera>();
			reflCam.enabled = false;
			reflCam.transform.position = base.transform.position;
			reflCam.transform.rotation = base.transform.rotation;
			reflCam.gameObject.AddComponent<FlareLayer>();
			gameObject.hideFlags = HideFlags.HideAndDontSave;
		}
		if (!refrCam)
		{
			GameObject gameObject2 = new GameObject("RefractCamera" + GetInstanceID(), typeof(Camera), typeof(Skybox));
			refrCam = gameObject2.GetComponent<Camera>();
			refrCam.enabled = false;
			refrCam.transform.position = base.transform.position;
			refrCam.transform.rotation = base.transform.rotation;
			refrCam.gameObject.AddComponent<FlareLayer>();
			gameObject2.hideFlags = HideFlags.HideAndDontSave;
		}
	}

	private void UpdateCameras(Camera current)
	{
		if (reflCam == null || refrCam == null)
		{
			return;
		}
		reflCam.backgroundColor = current.backgroundColor;
		refrCam.backgroundColor = current.backgroundColor;
		if (current.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = current.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = reflCam.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox3 = refrCam.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
				skybox3.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
				skybox3.enabled = true;
				skybox3.material = skybox.material;
			}
		}
		reflCam.farClipPlane = current.farClipPlane;
		reflCam.nearClipPlane = current.nearClipPlane;
		reflCam.orthographic = current.orthographic;
		reflCam.fieldOfView = current.fieldOfView;
		reflCam.aspect = current.aspect;
		reflCam.orthographicSize = current.orthographicSize;
		reflCam.cullingMask = -17 & ReflectLayers.value;
		reflCam.targetTexture = reflTex;
		refrCam.farClipPlane = current.farClipPlane;
		refrCam.nearClipPlane = current.nearClipPlane;
		refrCam.orthographic = current.orthographic;
		refrCam.fieldOfView = current.fieldOfView;
		refrCam.aspect = current.aspect;
		refrCam.orthographicSize = current.orthographicSize;
		refrCam.cullingMask = -17 & RefractLayers.value;
		refrCam.targetTexture = refrTex;
	}

	private static Vector4 GetPlaneEquation(Vector3 normal, Vector3 position, float offset)
	{
		float w = 0f - Vector3.Dot(normal, position) - offset;
		return new Vector4(normal.x, normal.y, normal.z, w);
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 norm, float offs, float side)
	{
		Vector3 point = pos + norm * offs;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(norm).normalized * side;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static float Sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private static void SetObliqueMatrix(ref Matrix4x4 proj, Vector4 plane)
	{
		Vector4 b = proj.inverse * new Vector4(Sgn(plane.x), Sgn(plane.y), 1f, 1f);
		Vector4 vector = plane * (2f / Vector4.Dot(plane, b));
		proj[2] = vector.x - proj[3];
		proj[6] = vector.y - proj[7];
		proj[10] = vector.z - proj[11];
		proj[14] = vector.w - proj[15];
	}

	private static void SetReflectionMatrix(ref Matrix4x4 mtx, Vector4 plane)
	{
		mtx.m00 = 1f - 2f * plane[0] * plane[0];
		mtx.m01 = -2f * plane[0] * plane[1];
		mtx.m02 = -2f * plane[0] * plane[2];
		mtx.m03 = -2f * plane[3] * plane[0];
		mtx.m10 = -2f * plane[1] * plane[0];
		mtx.m11 = 1f - 2f * plane[1] * plane[1];
		mtx.m12 = -2f * plane[1] * plane[2];
		mtx.m13 = -2f * plane[3] * plane[1];
		mtx.m20 = -2f * plane[2] * plane[0];
		mtx.m21 = -2f * plane[2] * plane[1];
		mtx.m22 = 1f - 2f * plane[2] * plane[2];
		mtx.m23 = -2f * plane[3] * plane[2];
		mtx.m30 = 0f;
		mtx.m31 = 0f;
		mtx.m32 = 0f;
		mtx.m33 = 1f;
	}
}
[ExecuteInEditMode]
public class WaterFlow : MonoBehaviour
{
	public float FlowSpeed = 0.05f;

	public float Cycle = 0.5f;

	private float HalfCycle = 0.25f;

	private float FlowMapOffset0;

	private float FlowMapOffset1;

	private void Awake()
	{
		HalfCycle = Cycle * 0.5f;
		FlowMapOffset0 = 0f;
		FlowMapOffset1 = HalfCycle;
		GetComponent<Renderer>().sharedMaterial.SetFloat("_HalfCycle", HalfCycle);
		GetComponent<Renderer>().sharedMaterial.SetFloat("_FlowOffset0", FlowMapOffset0);
		GetComponent<Renderer>().sharedMaterial.SetFloat("_FlowOffset1", FlowMapOffset1);
	}

	private void Update()
	{
		FlowMapOffset0 += FlowSpeed * Time.deltaTime;
		FlowMapOffset1 += FlowSpeed * Time.deltaTime;
		if (FlowMapOffset0 >= Cycle)
		{
			FlowMapOffset0 = 0f;
		}
		if (FlowMapOffset1 >= Cycle)
		{
			FlowMapOffset1 = 0f;
		}
		GetComponent<Renderer>().sharedMaterial.SetFloat("_FlowOffset0", FlowMapOffset0);
		GetComponent<Renderer>().sharedMaterial.SetFloat("_FlowOffset1", FlowMapOffset1);
	}
}
[ExecuteInEditMode]
public class WaterManagerPRO : MonoBehaviour
{
	public Transform DirectionalLight;

	public Color UnderWaterFogColor;

	public float UnderWaterFogDensity = 0.5f;

	private Color SceneFogColor;

	private float SceneFogDensity;

	private FogMode SceneFogMode;

	private PP_Wiggle wiggle;

	public LayerMask ReflectLayers = -1;

	public LayerMask RefractLayers = -1;

	public float ClipPlaneOffset = 0.07f;

	private RenderTexture reflTex;

	private RenderTexture refrTex;

	private Camera reflCam;

	private Camera refrCam;

	private static bool SafeGuard;

	private void Awake()
	{
		wiggle = Camera.main.GetComponent<PP_Wiggle>();
		SceneFogColor = RenderSettings.fogColor;
		SceneFogDensity = RenderSettings.fogDensity;
		SceneFogMode = RenderSettings.fogMode;
	}

	public void OnWillRenderObject()
	{
		if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled || !SystemInfo.supportsRenderTextures)
		{
			return;
		}
		Camera current = Camera.current;
		if (!current || SafeGuard)
		{
			return;
		}
		SafeGuard = true;
		CreateTextures(256, 256, 16);
		CreateCameras(current);
		UpdateCameras(current);
		if ((bool)DirectionalLight)
		{
			GetComponent<Renderer>().sharedMaterial.SetVector("_LightDir", DirectionalLight.forward);
		}
		Vector3 position = base.transform.position;
		Vector3 vector = base.transform.up;
		float num = Mathf.Sign(GetSide(vector, position, ClipPlaneOffset, Camera.main.transform.position));
		if (num < 1f)
		{
			vector = new Vector3(0f - vector.x, 0f - vector.y, 0f - vector.z);
			RenderSettings.fog = true;
			RenderSettings.fogMode = FogMode.Exponential;
			RenderSettings.fogColor = UnderWaterFogColor;
			RenderSettings.fogDensity = UnderWaterFogDensity;
			if ((bool)wiggle)
			{
				wiggle.enabled = true;
			}
		}
		else
		{
			RenderSettings.fogMode = SceneFogMode;
			RenderSettings.fogColor = SceneFogColor;
			RenderSettings.fogDensity = SceneFogDensity;
			if ((bool)wiggle)
			{
				wiggle.enabled = false;
			}
		}
		Vector4 planeEquation = GetPlaneEquation(vector, position, ClipPlaneOffset);
		Matrix4x4 mtx = Matrix4x4.zero;
		SetReflectionMatrix(ref mtx, planeEquation);
		Vector3 position2 = current.transform.position;
		Vector3 position3 = mtx.MultiplyPoint(position2);
		reflCam.worldToCameraMatrix = current.worldToCameraMatrix * mtx;
		Vector4 plane = CameraSpacePlane(reflCam, position, vector, ClipPlaneOffset, 1f);
		Matrix4x4 proj = current.projectionMatrix;
		SetObliqueMatrix(ref proj, plane);
		reflCam.projectionMatrix = proj;
		GL.SetRevertBackfacing(revertBackFaces: true);
		reflCam.transform.position = position3;
		Vector3 eulerAngles = current.transform.eulerAngles;
		reflCam.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
		reflCam.Render();
		reflCam.transform.position = position2;
		GL.SetRevertBackfacing(revertBackFaces: false);
		GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", reflTex);
		refrCam.worldToCameraMatrix = current.worldToCameraMatrix;
		Vector4 plane2 = CameraSpacePlane(refrCam, position, vector, ClipPlaneOffset, -1f);
		Matrix4x4 proj2 = current.projectionMatrix;
		SetObliqueMatrix(ref proj2, plane2);
		refrCam.projectionMatrix = proj2;
		refrCam.transform.position = current.transform.position;
		refrCam.transform.rotation = current.transform.rotation;
		refrCam.Render();
		GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", refrTex);
		SafeGuard = false;
	}

	private void OnBecameVisible()
	{
		base.enabled = true;
	}

	private void OnBecameInvisible()
	{
		base.enabled = false;
	}

	private void OnDisable()
	{
		if ((bool)reflTex)
		{
			UnityEngine.Object.DestroyImmediate(reflTex);
			reflTex = null;
		}
		if ((bool)reflCam)
		{
			UnityEngine.Object.DestroyImmediate(reflCam.gameObject);
			reflCam = null;
		}
		if ((bool)refrTex)
		{
			UnityEngine.Object.DestroyImmediate(refrTex);
			refrTex = null;
		}
		if ((bool)refrCam)
		{
			UnityEngine.Object.DestroyImmediate(refrCam.gameObject);
			refrCam = null;
		}
		RenderSettings.fogMode = SceneFogMode;
		RenderSettings.fogColor = SceneFogColor;
		RenderSettings.fogDensity = SceneFogDensity;
		if ((bool)wiggle)
		{
			wiggle.enabled = false;
		}
	}

	private void CreateTextures(int width, int height, int depth)
	{
		if (!reflTex)
		{
			reflTex = new RenderTexture(width, height, depth);
			reflTex.name = "ReflectTexture";
			reflTex.isPowerOfTwo = true;
			reflTex.hideFlags = HideFlags.DontSave;
		}
		if (!refrTex)
		{
			refrTex = new RenderTexture(width, height, depth);
			refrTex.name = "RefractTexture";
			refrTex.isPowerOfTwo = true;
			refrTex.hideFlags = HideFlags.DontSave;
		}
	}

	private void CreateCameras(Camera current)
	{
		if (!reflCam)
		{
			GameObject gameObject = new GameObject("ReflectCamera" + GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflCam = gameObject.GetComponent<Camera>();
			reflCam.enabled = false;
			reflCam.transform.position = base.transform.position;
			reflCam.transform.rotation = base.transform.rotation;
			reflCam.gameObject.AddComponent<FlareLayer>();
			gameObject.hideFlags = HideFlags.HideAndDontSave;
		}
		if (!refrCam)
		{
			GameObject gameObject2 = new GameObject("RefractCamera" + GetInstanceID(), typeof(Camera), typeof(Skybox));
			refrCam = gameObject2.GetComponent<Camera>();
			refrCam.enabled = false;
			refrCam.transform.position = base.transform.position;
			refrCam.transform.rotation = base.transform.rotation;
			refrCam.gameObject.AddComponent<FlareLayer>();
			gameObject2.hideFlags = HideFlags.HideAndDontSave;
		}
	}

	private void UpdateCameras(Camera current)
	{
		if (reflCam == null || refrCam == null)
		{
			return;
		}
		reflCam.backgroundColor = current.backgroundColor;
		refrCam.backgroundColor = current.backgroundColor;
		if (current.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = current.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = reflCam.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox3 = refrCam.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
				skybox3.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
				skybox3.enabled = true;
				skybox3.material = skybox.material;
			}
		}
		reflCam.farClipPlane = current.farClipPlane;
		reflCam.nearClipPlane = current.nearClipPlane;
		reflCam.orthographic = current.orthographic;
		reflCam.fieldOfView = current.fieldOfView;
		reflCam.aspect = current.aspect;
		reflCam.orthographicSize = current.orthographicSize;
		reflCam.cullingMask = -17 & ReflectLayers.value;
		reflCam.targetTexture = reflTex;
		refrCam.farClipPlane = current.farClipPlane;
		refrCam.nearClipPlane = current.nearClipPlane;
		refrCam.orthographic = current.orthographic;
		refrCam.fieldOfView = current.fieldOfView;
		refrCam.aspect = current.aspect;
		refrCam.orthographicSize = current.orthographicSize;
		refrCam.cullingMask = -17 & RefractLayers.value;
		refrCam.targetTexture = refrTex;
	}

	private static Vector4 GetPlaneEquation(Vector3 normal, Vector3 position, float offset)
	{
		float w = 0f - Vector3.Dot(normal, position) - offset;
		return new Vector4(normal.x, normal.y, normal.z, w);
	}

	private static float GetSide(Vector3 normal, Vector3 position, float offset, Vector3 testPos)
	{
		Vector4 planeEquation = GetPlaneEquation(normal, position, offset);
		return planeEquation.x * testPos.x + planeEquation.y * testPos.y + planeEquation.z * testPos.z + planeEquation.w;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 norm, float offs, float side)
	{
		Vector3 point = pos + norm * offs;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(norm).normalized * side;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static float Sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private static void SetObliqueMatrix(ref Matrix4x4 proj, Vector4 plane)
	{
		Vector4 b = proj.inverse * new Vector4(Sgn(plane.x), Sgn(plane.y), 1f, 1f);
		Vector4 vector = plane * (2f / Vector4.Dot(plane, b));
		proj[2] = vector.x - proj[3];
		proj[6] = vector.y - proj[7];
		proj[10] = vector.z - proj[11];
		proj[14] = vector.w - proj[15];
	}

	private static void SetReflectionMatrix(ref Matrix4x4 mtx, Vector4 plane)
	{
		mtx.m00 = 1f - 2f * plane[0] * plane[0];
		mtx.m01 = -2f * plane[0] * plane[1];
		mtx.m02 = -2f * plane[0] * plane[2];
		mtx.m03 = -2f * plane[3] * plane[0];
		mtx.m10 = -2f * plane[1] * plane[0];
		mtx.m11 = 1f - 2f * plane[1] * plane[1];
		mtx.m12 = -2f * plane[1] * plane[2];
		mtx.m13 = -2f * plane[3] * plane[1];
		mtx.m20 = -2f * plane[2] * plane[0];
		mtx.m21 = -2f * plane[2] * plane[1];
		mtx.m22 = 1f - 2f * plane[2] * plane[2];
		mtx.m23 = -2f * plane[3] * plane[2];
		mtx.m30 = 0f;
		mtx.m31 = 0f;
		mtx.m32 = 0f;
		mtx.m33 = 1f;
	}
}
public class WaterSpecular : MonoBehaviour
{
	public Transform DirectionalLight;

	private void Update()
	{
		GetComponent<Renderer>().sharedMaterial.SetVector("_LightDir", DirectionalLight.forward.normalized);
	}
}
public class BelugaWhale : MonoBehaviour
{
	public bool freeze;

	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed;

	public float minDistance = 1.1f;

	public float repulseForce = 0.55f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	public float playerTurnSpeed = 1f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float playerRotateToTargetSpeed = 2f;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float targetSwimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private FoodSources foodSources;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public Transform staticBone;

	private Vector3 staticAxis;

	private float reverseTimer;

	public float lerpToPlayerPosSpeed = 10f;

	public AnimationCurve barrelRollCurve;

	public Vector2 barrelRollTimeRange = new Vector2(5f, 20f);

	private float barrelRollTimer;

	private float barrelRollTime = 12f;

	private Vector3 fluidTargetPosition;

	public float targetLerpSpeed = 1f;

	public AnimationCurve nearPlayerTailCurve;

	private float tailCurveAmount;

	private float targetTailCurveAmount;

	public bool nearPlayerAcrobatics;

	public int tailFlipChance = 300;

	private bool flipTail;

	private BoxCollider movementZone;

	private float distanceToPlayer;

	public Vector3 acrobaticsNoiseAmplitudes = new Vector3(1f, 1f, 1f);

	public float acrobaticsNoiseFrequency = 0.5f;

	private float noiseTimer;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		foodSources = GameObject.Find("_Helper Scripts").GetComponent<FoodSources>();
		eatThings = GetComponent<EatThings>();
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		targetPos = target.position;
		fluidTargetPosition = targetPos;
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
		movementZone = base.transform.Find("Target").GetComponent<MovingTarget>().movementZone;
		StartCoroutine(checkPlayerIsWithinBounds());
	}

	private IEnumerator checkPlayerIsWithinBounds()
	{
		while (true)
		{
			yield return new WaitForSeconds(5f);
			if (!movementZone.bounds.Contains(player.transform.position))
			{
				playerIsTarget = false;
			}
		}
	}

	private void FixedUpdate()
	{
		if (!foodIsTarget && Random.Range(0, hungryness) == 1)
		{
			setFoodTarget(foodSources.getRandom());
		}
		if (Random.Range(0, friendliness) == 1)
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
			barrelRollTime = Random.Range(barrelRollTimeRange.x, barrelRollTimeRange.y);
			barrelRollTimer = 0f;
		}
		if (Random.Range(0, tailFlipChance) == 1)
		{
			flipTail = !flipTail;
		}
		if (Random.Range(0, speedChangeChance) == 1 && !doBarrelRoll)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		targetSwimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyZ = Random.Range(swimFreqRangeZ.x, swimFreqRangeZ.y);
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	public float getCurrentSpeed()
	{
		return moveSpeed;
	}

	private void Update()
	{
		distanceToPlayer = (player.transform.position + new Vector3(0f, 0f, 0f) - head.transform.position).magnitude;
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (foodIsTarget)
		{
			turnSpeed = attackingTurnSpeed;
		}
		else
		{
			turnSpeed = defaultTurnSpeed;
		}
		if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = Vector3.Lerp(targetPos, food.transform.position, Time.deltaTime * 5f);
			}
		}
		else if (playerIsTarget)
		{
			turnSpeed = playerTurnSpeed;
			rotateToTargetSpeed = playerRotateToTargetSpeed;
			targetPos = Vector3.Lerp(targetPos, player.transform.position + new Vector3(0f, 0.05f, 0f), Time.deltaTime * lerpToPlayerPosSpeed);
			if (distanceToPlayer < nearPlayerDistance)
			{
				nearPlayerAcrobatics = true;
				targetSpeed = nearPlayerSpeed;
			}
			else
			{
				nearPlayerAcrobatics = false;
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, Time.deltaTime * targetLerpSpeed);
			turnSpeed = defaultTurnSpeed;
			rotateToTargetSpeed = defaultRotateToTargetSpeed;
		}
		if (distanceToPlayer < minDistance)
		{
			Vector3 normalized = (head.transform.position - player.transform.position).normalized;
			normalized.y = 0f;
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			if (Random.Range(0, 100) == 1)
			{
				turnSpeed = 0.5f;
			}
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration * Time.deltaTime;
		}
		else
		{
			moveSpeed -= maxAcceleration * Time.deltaTime;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		if (!freeze)
		{
			head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		}
		if (nearPlayerAcrobatics && !freeze)
		{
			float num = (-0.5f + Mathf.PerlinNoise(noiseTimer, 0f)) * acrobaticsNoiseAmplitudes.x;
			float num2 = (-0.5f + Mathf.PerlinNoise(noiseTimer + 3f, 0f)) * acrobaticsNoiseAmplitudes.y;
			float num3 = (-0.5f + Mathf.PerlinNoise(noiseTimer + 6f, 0f)) * acrobaticsNoiseAmplitudes.z;
			noiseTimer += Time.deltaTime * acrobaticsNoiseFrequency;
			head.transform.Translate(Vector3.right * num * Time.deltaTime);
			head.transform.Translate(Vector3.up * num2 * Time.deltaTime);
		}
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay * Time.deltaTime;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		if (doBarrelRoll)
		{
			targetSpeed = defaultSpeed;
			float num4 = barrelRollCurve.Evaluate(barrelRollTimer / barrelRollTime) * barrelRollSpeed;
			swimComponent *= Quaternion.Euler(Vector3.forward * num4 * 100f * Time.deltaTime);
			barrelRollTimer += Time.deltaTime;
			if (barrelRollTimer > barrelRollTime)
			{
				doBarrelRoll = false;
			}
		}
		fluidTargetPosition = Vector3.Lerp(fluidTargetPosition, targetPos, Time.deltaTime * targetLerpSpeed);
		targetDir = fluidTargetPosition - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir, head.up);
		rot = Quaternion.Lerp(head.transform.rotation, targetQuat, rotateToTargetSpeed * Time.deltaTime * 0.2f);
		if (!freeze)
		{
			head.transform.rotation = rot * swimComponent;
		}
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimAmplitudeY = Mathf.Lerp(swimAmplitudeY, targetSwimAmplitudeY, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			Quaternion quaternion = ((i <= 0) ? localRotation : bones[i - 1].localRotation);
			float z = localRotation.eulerAngles.z;
			float num = Mathf.DeltaAngle(quaternion.eulerAngles.z, localRotation.eulerAngles.z);
			if (i > 1 && num > 150f)
			{
				z = 0f;
			}
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude -= tailAmplitudeDecay * Time.deltaTime;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j <= 1)
			{
				continue;
			}
			float value = (float)j / (float)bones.Length;
			value = Mathf.Clamp01(value);
			float num2 = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
			float num3 = 0f;
			if (!nearPlayerAcrobatics)
			{
				targetTailCurveAmount = 0f;
				num3 = 0.25f;
			}
			else
			{
				num3 = 0.03f;
				targetSwimAmplitudeY = 11f;
				if (flipTail)
				{
					targetTailCurveAmount = -20f;
				}
				else
				{
					targetTailCurveAmount = 20f;
				}
			}
			targetTailCurveAmount = 0f;
			tailCurveAmount = Mathf.Lerp(tailCurveAmount, targetTailCurveAmount, Time.deltaTime * num3);
			num2 += nearPlayerTailCurve.Evaluate((float)j / (float)bones.Length) * tailCurveAmount;
			bones[j].Rotate(tailAxis, num2);
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class BlueWhaleBlendShapeAnimation : MonoBehaviour
{
	public string note;

	public SkinnedMeshRenderer renderer;

	public bool moveEyes = true;

	public Vector2 changeTimeRange = new Vector2(0.2f, 0.5f);

	public int changeChance = 50;

	public float lerpSpeed = 5f;

	public float restBlend = 30f;

	private float timer;

	private float blendVal;

	private Quaternion baseRotation;

	private Quaternion baseRotation2;

	public int[] blendShapeIndex;

	public float openAmplitude = 100f;

	public float minNoiseAmplitude = -50f;

	public float maxNoiseAmplitude = 100f;

	public float noiseFrequency = 0.2f;

	private float noise;

	public bool addNoise;

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (timer <= 0f && Random.Range(0, changeChance) == 1)
		{
			timer = Random.Range(changeTimeRange.x, changeTimeRange.y);
		}
	}

	private void Update()
	{
		if (addNoise)
		{
			noise = minNoiseAmplitude + Mathf.PerlinNoise(Time.time * noiseFrequency, 0f) * maxNoiseAmplitude;
		}
		else
		{
			noise = 0f;
		}
		if (timer > 0f)
		{
			blendVal = Mathf.Lerp(blendVal, openAmplitude, Time.deltaTime * lerpSpeed);
		}
		else
		{
			blendVal = Mathf.Lerp(blendVal, restBlend + noise, Time.deltaTime * lerpSpeed);
		}
		for (int i = 0; i < blendShapeIndex.Length; i++)
		{
			renderer.SetBlendShapeWeight(blendShapeIndex[i], blendVal);
		}
		timer -= Time.deltaTime;
	}
}
public class Crab : MonoBehaviour
{
	public float maxSpeed = 5f;

	public float turnSpeed = 0.5f;

	public float gravity = 20f;

	public float animationScaler = 0.8f;

	public Transform target;

	public float changeMoveDirectionSpeed = 0.1f;

	public int randomStop = 60;

	public bool bStopped;

	public float baseSpeed = 0.1f;

	private Vector3 moveDirection = Vector3.zero;

	protected Animator animator;

	private float curDir;

	private float targetSpeed = 5f;

	private float speed;

	private Vector3 targetDirection;

	private Vector3 prevTargetPosition;

	private Vector3 targetRotation;

	private float errorAngle;

	public float speedChangeEvery = 4f;

	public void Start()
	{
		bStopped = true;
		animator = GetComponent<Animator>();
		StartCoroutine(changeSpeed());
	}

	public void FixedUpdate()
	{
		if (Random.Range(0, randomStop) == 1)
		{
			bStopped = !bStopped;
		}
		base.transform.Translate(Vector3.right * speed * Time.deltaTime);
	}

	public void Update()
	{
		if (bStopped)
		{
			targetSpeed = 0.01f;
		}
		else
		{
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(targetRotation), Time.deltaTime);
			targetSpeed = maxSpeed;
		}
		speed = Mathf.Lerp(speed, targetSpeed, Time.deltaTime);
		targetDirection = Vector3.Cross(target.position - base.transform.position, Vector3.up);
		targetDirection.Normalize();
		targetDirection.y = 0f;
		moveDirection = targetDirection;
		targetRotation = Vector3.RotateTowards(base.transform.forward, targetDirection, turnSpeed * speed, 0f);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(targetRotation), Time.deltaTime);
		prevTargetPosition = target.position;
		GetComponent<Animation>()["walk_sideways"].speed = baseSpeed + speed * animationScaler;
	}

	private IEnumerator changeSpeed()
	{
		targetSpeed = Random.Range(maxSpeed * 0.1f, maxSpeed);
		yield return new WaitForSeconds(speedChangeEvery);
	}

	private void CalculateFacingForAnimation()
	{
		Vector3 forward = base.transform.forward;
		float f = Vector3.Dot(forward, base.transform.forward);
		float num = Mathf.Acos(f);
		float y = Vector3.Cross(base.transform.forward, forward).y;
		num *= Mathf.Sign(y);
		animator.SetFloat("hspeed", Mathf.Clamp(Mathf.Sin(num), -1f, 1f));
		animator.SetFloat("speed", speed);
		animator.speed = Mathf.Clamp(animationScaler * speed, 0.25f, 10f);
	}
}
public class QuadAlignToTerrain : MonoBehaviour
{
	public float lerpSpeed = 1f;

	public int updateEvery = 1;

	public Transform backLeft;

	public Transform backRight;

	public Transform frontLeft;

	public Transform frontRight;

	private Vector3 currentUp = Vector3.up;

	private Vector3 surfaceNormal;

	private Vector3 myNormal;

	private Vector3 myForward;

	private int counter;

	private void Start()
	{
		counter = 0;
	}

	private void FixedUpdate()
	{
		if (counter > updateEvery)
		{
			counter = 0;
			Physics.Raycast(backLeft.position + Vector3.up, Vector3.down, out var hitInfo);
			Physics.Raycast(backRight.position + Vector3.up, Vector3.down, out var hitInfo2);
			Physics.Raycast(frontLeft.position + Vector3.up, Vector3.down, out var hitInfo3);
			Physics.Raycast(frontRight.position + Vector3.up, Vector3.down, out var hitInfo4);
			surfaceNormal = (Vector3.Cross(hitInfo2.point - Vector3.up, hitInfo.point - Vector3.up) + Vector3.Cross(hitInfo.point - Vector3.up, hitInfo3.point - Vector3.up) + Vector3.Cross(hitInfo3.point - Vector3.up, hitInfo4.point - Vector3.up) + Vector3.Cross(hitInfo4.point - Vector3.up, hitInfo2.point - Vector3.up)).normalized;
			myNormal = Vector3.Lerp(myNormal, surfaceNormal, lerpSpeed * Time.deltaTime);
			myForward = Vector3.Cross(base.transform.right, myNormal);
			Quaternion b = Quaternion.LookRotation(myForward, myNormal);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, lerpSpeed * Time.deltaTime);
		}
		counter++;
	}

	private void drawDebugLine(Vector3 dir, Color colour)
	{
		Debug.DrawLine(base.transform.position, base.transform.position + dir * 5f, colour);
	}
}
public class SimpleAlignToTerrain : MonoBehaviour
{
	public float groundAlignSpeed = 1f;

	private Vector3 curNormal = Vector3.up;

	private Vector3 myForward;

	private void Start()
	{
	}

	private void Update()
	{
		if (Physics.Raycast(base.transform.position + curNormal, -curNormal, out var hitInfo) && (hitInfo.collider.tag == "Terrain" || hitInfo.collider.tag == "T4MObj"))
		{
			processRay(-curNormal, hitInfo);
		}
	}

	private void processRay(Vector3 direction, RaycastHit hit)
	{
		curNormal = Vector3.Lerp(curNormal, hit.normal, 4f * Time.deltaTime);
		myForward = Vector3.Cross(base.transform.right, curNormal);
		Quaternion b = Quaternion.LookRotation(myForward, curNormal);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, groundAlignSpeed * Time.deltaTime);
		float y = Mathf.Lerp(base.transform.position.y, hit.point.y, groundAlignSpeed * Time.deltaTime);
		Vector3 position = base.transform.position;
		position.y = y;
		base.transform.position = position;
	}
}
public class DolphinEyes : MonoBehaviour
{
	public SkinnedMeshRenderer renderer;

	public bool moveEyes = true;

	public Vector2 blinkTimeRange = new Vector2(0.2f, 0.5f);

	public int blinkChance = 50;

	public float eyeCloseSpeed = 1f;

	public float eyeOpenSpeed = 1f;

	public float restEyeBlend = 30f;

	private float blinkTimer;

	private float blinkBlendVal;

	public Vector2 microTickMinMax = new Vector2(0f, 0f);

	public float microMax = 0.01f;

	public float verticalBias = 2f;

	private float microTimer;

	private float microTime = float.PositiveInfinity;

	private Vector3 microOffset = new Vector3(0f, 0f, 0f);

	private Quaternion baseRotation;

	private Quaternion baseRotation2;

	public Transform leftEye;

	public Transform rightEye;

	public int blendShapeIndex;

	private void Start()
	{
		microTime = Random.Range(microTickMinMax.x, microTickMinMax.y);
		if (moveEyes)
		{
			baseRotation = leftEye.localRotation;
			baseRotation2 = rightEye.localRotation;
		}
	}

	private void Update()
	{
		if (Random.Range(0, blinkChance) == 1)
		{
			blinkTimer = Random.Range(blinkTimeRange.x, blinkTimeRange.y);
		}
		if (blinkTimer > 0f)
		{
			blinkBlendVal = Mathf.Lerp(blinkBlendVal, 100f, Time.deltaTime * eyeCloseSpeed);
		}
		else
		{
			blinkBlendVal = Mathf.Lerp(blinkBlendVal, restEyeBlend, Time.deltaTime * eyeOpenSpeed);
		}
		renderer.SetBlendShapeWeight(blendShapeIndex, blinkBlendVal);
		blinkTimer -= Time.deltaTime;
		if (moveEyes)
		{
			microTimer += Time.deltaTime;
			if (microTimer > microTime)
			{
				microOffset = new Vector3(Random.Range(0f - microMax, microMax), Random.Range(0f - microMax, microMax) * verticalBias, Random.Range(0f - microMax, microMax));
				microTimer = 0f;
				microTime = Random.Range(microTickMinMax.x, microTickMinMax.y);
			}
			leftEye.localRotation = baseRotation * Quaternion.Euler(microOffset);
			rightEye.localRotation = baseRotation2 * Quaternion.Euler(-microOffset);
		}
	}
}
public class DolphinLOD : MonoBehaviour
{
	public float maxDistance = 10f;

	public float tick = 1.5f;

	public GameObject upperTeeth;

	public GameObject lowerTeeth;

	public GameObject leftEye;

	public GameObject rightEye;

	private GameObject player;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		StartCoroutine(switchOnOff());
	}

	private void Update()
	{
	}

	private IEnumerator switchOnOff()
	{
		while (true)
		{
			float distanceToPlayer = (player.transform.position - upperTeeth.transform.position).magnitude;
			if (distanceToPlayer > maxDistance)
			{
				upperTeeth.SetActive(value: false);
				lowerTeeth.SetActive(value: false);
				leftEye.SetActive(value: false);
				rightEye.SetActive(value: false);
			}
			else
			{
				upperTeeth.SetActive(value: true);
				lowerTeeth.SetActive(value: true);
				leftEye.SetActive(value: true);
				rightEye.SetActive(value: true);
			}
			yield return new WaitForSeconds(tick);
		}
	}
}
public class DolphinMouth : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw;

	public float upperJawOpenSize = 5f;

	public float lowerJawOpenSize = 10f;

	public float openSpeed = 2f;

	public float closeSpeed = 15f;

	public float chatteringSpeedMin = 5f;

	public float chatteringSpeedMax = 20f;

	public int mouthOpenChance = 300;

	public Vector2 mouthOpenTimeRange = new Vector2(1f, 3f);

	public AudioSource mouthAudioSource;

	public AudioClip[] sounds;

	private Quaternion upperJawOpen;

	private Quaternion upperJawClosed;

	private Quaternion lowerJawOpen;

	private Quaternion lowerJawClosed;

	private float openMouthTimer;

	public Vector3 axis = new Vector3(0f, 1f, 0f);

	private bool hasTeeth;

	public ParticleSystem mouthBubblesPS1;

	private bool mouthBubbles;

	private float chatteringTimer;

	private float chatteringSpeed;

	private float mouthOscillator;

	private void Start()
	{
		upperJawOpen = upperJaw.localRotation * Quaternion.Euler((0f - upperJawOpenSize) * axis);
		lowerJawOpen = lowerJaw.localRotation * Quaternion.Euler((0f - lowerJawOpenSize) * axis);
		upperJawClosed = upperJaw.localRotation * Quaternion.Euler(0f, 0f, 0f);
		lowerJawClosed = lowerJaw.localRotation * Quaternion.Euler(0f, 0f, 0f);
		openMouthTimer = 0f;
		if (mouthBubblesPS1 != null)
		{
			mouthBubbles = true;
		}
		else
		{
			mouthBubbles = false;
		}
	}

	private void FixedUpdate()
	{
		mouthOscillator = Mathf.Sin(chatteringTimer * chatteringSpeed);
		if (Random.Range(1, mouthOpenChance) == 1)
		{
			openMouthTimer = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
			chatteringSpeed = Random.Range(chatteringSpeedMin, chatteringSpeedMax);
			chatteringTimer = 0f;
			if ((bool)mouthAudioSource)
			{
				mouthAudioSource.PlayOneShot(sounds[Random.Range(0, sounds.Length)]);
			}
		}
		if (openMouthTimer > 0f)
		{
			if (mouthOscillator > 0f)
			{
				upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawOpen, Time.deltaTime * openSpeed);
				lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawOpen, Time.deltaTime * openSpeed);
			}
			else
			{
				upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawClosed, Time.deltaTime * closeSpeed);
				lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawClosed, Time.deltaTime * closeSpeed);
			}
		}
		else
		{
			upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawClosed, Time.deltaTime * closeSpeed);
			lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawClosed, Time.deltaTime * closeSpeed);
		}
		openMouthTimer -= Time.deltaTime;
		chatteringTimer += Time.deltaTime;
	}
}
public class ActiveDistance : MonoBehaviour
{
	public float activeDistance = 100f;

	public float tick = 1f;

	private Transform player;

	public Transform body;

	private void Start()
	{
		player = GameObject.Find("Dummy Player").transform;
		StartCoroutine(processActiveDistance());
		if (body == null)
		{
			body = base.transform;
		}
	}

	private IEnumerator processActiveDistance()
	{
		while (true)
		{
			float distanceToPlayer = (player.position - body.transform.position).magnitude;
			if (distanceToPlayer > activeDistance)
			{
				base.transform.GetChild(0).gameObject.SetActive(value: false);
			}
			else
			{
				base.transform.GetChild(0).gameObject.SetActive(value: true);
			}
			yield return new WaitForSeconds(tick);
		}
	}
}
public class AdvancedFlippers : MonoBehaviour
{
	public Transform frontLeftFin;

	public Transform frontRightFin;

	public float amplitudeWeight;

	public float speedWeight;

	public float baseAmplitudeWeight;

	public float baseSpeed;

	private Quaternion baseFrontLeftFinRotation;

	private Quaternion baseFrontRightFinRotation;

	private AquaticDinosaur baseScript;

	private float finTimer;

	public float finDefaultOffset;

	public AnimationCurve curve1;

	private void Start()
	{
		baseFrontLeftFinRotation = frontLeftFin.localRotation;
		baseFrontRightFinRotation = frontRightFin.localRotation;
		baseScript = GetComponent<AquaticDinosaur>();
	}

	private void Update()
	{
		float headingAngle = baseScript.getHeadingAngle();
		float value = headingAngle / 90f;
		value = Mathf.Clamp(value, -1f, 1f);
		float num = Mathf.Abs(value);
		num = amplitudeWeight;
		float z = curve1.Evaluate(finTimer) * num + finDefaultOffset;
		float num2 = curve1.Evaluate(finTimer) * num + finDefaultOffset;
		frontLeftFin.localRotation = Quaternion.Slerp(frontLeftFin.localRotation, baseFrontLeftFinRotation * Quaternion.Euler(0f, 0f, z), Time.deltaTime * 1f);
		frontRightFin.localRotation = Quaternion.Slerp(frontRightFin.localRotation, baseFrontRightFinRotation * Quaternion.Euler(0f, 0f, 0f - num2), Time.deltaTime * 1f);
		finTimer += Time.deltaTime * baseSpeed;
	}
}
public class AquaticCreature : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public DynamicFish dynamicFish;

	public JawsAnimator jawsAnimator;

	public float defaultSpeed;

	public float fastestSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float turnSpeed;

	private float defaultTurnSpeed;

	public float attackingTurnSpeed = 2f;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	private void Start()
	{
		defaultTurnSpeed = turnSpeed;
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		swimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		swimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		float amount = 0.4f + (targetSpeed - moveSpeed) / fastestSpeed;
		dynamicFish.kickTail(amount);
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		swimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		swimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		swimTimer = 0f;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
	}

	private void Update()
	{
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if ((targetPos - head.transform.position).magnitude < 5f)
		{
			targetSpeed = defaultSpeed;
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 0.4f, 0f);
			if ((double)(targetPos - head.transform.position).magnitude < 3.0)
			{
				targetSpeed = defaultSpeed * 0.5f;
			}
			if ((targetPos - head.transform.position).magnitude < 1f)
			{
				playerIsTarget = false;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((targetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			targetPos = target.position;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 5f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		angleX = Mathf.Sin(swimFrequencyX * swimTimer);
		angleY = Mathf.Sin(swimFrequencyY * swimTimer);
		if (foodIsTarget)
		{
			turnSpeed = attackingTurnSpeed;
		}
		else
		{
			turnSpeed = defaultTurnSpeed;
		}
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleX);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		if (!doBarrelRoll)
		{
			rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		}
		else
		{
			rot = head.transform.rotation;
		}
		head.transform.rotation = rot * swimComponent;
		swimTimer += Time.deltaTime;
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
		dynamicFish.kickTail(1.5f);
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
		if (jawsAnimator != null && Random.Range(1, 4) == 3)
		{
			jawsAnimator.setBiting(val: true);
		}
	}
}
public class AquaticDinosaur : MonoBehaviour
{
	public bool playerIsTarget;

	public Transform head;

	public Rigidbody body;

	public DynamicFish dynamicFish;

	public AdvancedJawsAnimator jawsAnimator;

	public float defaultSpeed;

	public float fastestSpeed;

	public float attackingSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float turnSpeed;

	public float attackingTurnSpeed;

	public Transform cage;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	public BoxCollider safeZone;

	public float defaultRotateToTargetTime;

	public float attackingRotateToTargetTime;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int speedChangeChance = 200;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float swimFrequencyZ;

	private float rotateToTargetTime;

	private GameObject player;

	private Vector3 targetPos;

	private float rotateTimer;

	private Vector3 prevTargetPos;

	private float targetSwimAmplitudeX;

	private float targetSwimAmplitudeY;

	private float targetSwimFrequencyX;

	private float targetSwimFrequencyY;

	public float amplitudeSlerpSpeed = 1f;

	private float rotateToTargetTimer;

	private float speedError;

	public int barrelRollChance;

	public float barrelRollSpeed = 1f;

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float repulseTimer;

	private Vector3 repulseNormal;

	private float thrashingTimer;

	private bool bThrashing;

	public int thrashingChance = 500;

	private void Start()
	{
		bThrashing = false;
		thrashingTimer = 0f;
		repulseTimer = 0f;
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		rotateToTargetTime = defaultRotateToTargetTime;
		rotateToTargetTimer = 0f;
		targetSwimAmplitudeX = swimAmplitudeX;
		targetSwimAmplitudeY = swimAmplitudeY;
		jawsAnimator = GetComponent<AdvancedJawsAnimator>();
	}

	private void changeBehaviour()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		if (targetSpeed > 0f)
		{
			speedError = 0.3f + (targetSpeed - moveSpeed) / fastestSpeed;
		}
		if (dynamicFish != null)
		{
			dynamicFish.kickTail(speedError);
		}
		targetSwimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		targetSwimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		swimAmplitudeZ = 0f;
		angleZ = 0f;
	}

	private void activateThrashing()
	{
		MonoBehaviour.print("trashing!");
		thrashingTimer = Random.Range(0.5f, 2.5f);
		targetSwimAmplitudeX = Random.Range(40, 80);
		targetSwimFrequencyX = Random.Range(4, 9);
		bThrashing = true;
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, thrashingChance) == 1)
		{
			activateThrashing();
		}
		if (bThrashing && thrashingTimer < 0f)
		{
			changeBehaviour();
			bThrashing = false;
		}
		if (!doBarrelRoll)
		{
			if (jawsAnimator.getBiting())
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
				activateThrashing();
				thrashingTimer = 5.5f;
				targetSwimAmplitudeX = 80f;
				targetSwimAmplitudeY = 0f;
				targetSwimFrequencyX = 8f;
				targetSwimFrequencyY = 0f;
				bThrashing = true;
			}
			if (Random.Range(0, barrelRollChance) == 1)
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
			}
		}
		if (Random.Range(0, friendliness) == 1)
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1 && !doBarrelRoll)
		{
			playerIsTarget = false;
			activateThrashing();
		}
		if (safeZone != null)
		{
			if (safeZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = false;
				playerIsTarget = false;
			}
			else
			{
				jawsAnimator.hostile = true;
			}
		}
		if (playerIsTarget)
		{
			dynamicFish.kickTail(1000f);
			targetPos = player.transform.position + new Vector3(0f, 0.6f, 0f);
			float magnitude = (targetPos - head.transform.position).magnitude;
			targetSpeed = attackingSpeed;
			rotateToTargetTime = attackingRotateToTargetTime;
		}
		else
		{
			targetPos = target.position;
			if ((targetPos - head.position).magnitude < 2f && target.GetComponent<MovingTarget>() != null)
			{
				target.GetComponent<MovingTarget>().change();
			}
			rotateToTargetTime = defaultRotateToTargetTime;
		}
		if (!playerIsTarget && prevTargetPos != targetPos)
		{
			rotateTimer = 0f;
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			changeBehaviour();
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration;
		}
		swimAmplitudeX = Mathf.Lerp(swimAmplitudeX, targetSwimAmplitudeX, Time.deltaTime * amplitudeSlerpSpeed);
		swimAmplitudeY = Mathf.Lerp(swimAmplitudeY, targetSwimAmplitudeY, Time.deltaTime * amplitudeSlerpSpeed);
		swimFrequencyX = targetSwimFrequencyX;
		swimFrequencyY = targetSwimFrequencyY;
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (repulseTimer > 0f)
		{
			head.GetComponent<Rigidbody>().AddForce(repulseNormal * 1.8f, ForceMode.Impulse);
		}
		if (playerIsTarget)
		{
			angleX = Mathf.Sin(swimFrequencyX * swimTimer) * attackingTurnSpeed;
			angleY = Mathf.Sin(swimFrequencyY * swimTimer) * attackingTurnSpeed;
			angleZ = Mathf.Sin(swimFrequencyZ * swimTimer) * attackingTurnSpeed;
		}
		else
		{
			angleX = Mathf.Sin(swimFrequencyX * swimTimer) * turnSpeed;
			angleY = Mathf.Sin(swimFrequencyY * swimTimer) * turnSpeed;
			angleZ = Mathf.Sin(swimFrequencyZ * swimTimer) * turnSpeed;
		}
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * angleZ * swimAmplitudeZ);
		float num = 0f;
		float num2 = 0.1f;
		float num3 = 1f;
		float num4 = 1f;
		float num5 = 200f;
		if (doBarrelRoll)
		{
			if (barrelRollAngle < 180f)
			{
				num = num2 + barrelRollAngle / 180f;
			}
			float num6 = num * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num6;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num6);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, rotateToTargetTime * Time.deltaTime * rotateTimer);
		head.transform.rotation = rot * swimComponent;
		headingAngle = getAngle(head.rotation, targetQuat);
		swimTimer += Time.deltaTime;
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		rotateTimer += Time.deltaTime * 0.8f;
		repulseTimer -= Time.deltaTime;
		thrashingTimer -= Time.deltaTime;
		if (rotateTimer > 1f)
		{
			rotateTimer = 1f;
		}
		prevTargetPos = targetPos;
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
		dynamicFish.kickTail(1.5f);
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		repulseNormal = normal;
		int num = Random.Range(0, 2);
		if (!jawsAnimator.hostile)
		{
			playerIsTarget = false;
		}
		target.position = head.position + Vector3.Cross(normal, Vector3.up) * 5f;
		activateThrashing();
		swimAmplitudeZ = Random.Range(0, 60);
		swimFrequencyZ = Random.Range(2, 8);
		struggle();
		target.GetComponent<MovingTarget>().setTimer(0f);
		repulseTimer = 1f;
	}
}
public class BelugaWhaleNeck : MonoBehaviour
{
	private Transform player;

	public BelugaWhale baseScript;

	public Transform neckBone;

	private Quaternion rotation;

	public float maxHorizontalOffset = 20f;

	public float maxVerticalOffset = 20f;

	public float maxDiagonalOffset = 20f;

	private Vector3 offset;

	private Quaternion neckBaseRotation;

	private Quaternion targetRotation;

	public AnimationCurve lerpCurve;

	private float timer;

	public float lookDirectionTime = 1f;

	public Vector2 targetLerpRange = new Vector2(0.5f, 1f);

	public Vector2 neckLerpRange = new Vector2(0.5f, 1f);

	private float neckLerpSpeed;

	private float targetLerpSpeed;

	private Quaternion smoothTargetRotation;

	public AnimationCurve speedCurve;

	public Vector3 headOffset;

	private void Start()
	{
		player = LAC_VRCameraRig.instance.getCenterCamera().transform;
		baseScript = GetComponent<BelugaWhale>();
		neckBaseRotation = neckBone.localRotation * Quaternion.Euler(headOffset);
		targetRotation = neckBone.localRotation;
		smoothTargetRotation = neckBone.localRotation;
		timer = 0.01f;
	}

	private void Update()
	{
		if (timer > lookDirectionTime)
		{
			offset = new Vector3(Random.Range(0f - maxHorizontalOffset, maxHorizontalOffset), Random.Range(0f - maxVerticalOffset, maxVerticalOffset), Random.Range(0f - maxDiagonalOffset, maxDiagonalOffset));
			targetRotation = neckBaseRotation * Quaternion.Euler(offset.x, offset.y, offset.z * 0.4f);
			neckLerpSpeed = Random.Range(neckLerpRange.x, neckLerpRange.y);
			targetLerpSpeed = Random.Range(targetLerpRange.x, targetLerpRange.y);
			timer = 0f;
		}
		float num = speedCurve.Evaluate(baseScript.getCurrentSpeed());
		smoothTargetRotation = Quaternion.Slerp(smoothTargetRotation, targetRotation, targetLerpSpeed * Time.deltaTime * num);
		neckBone.localRotation = Quaternion.Slerp(neckBone.localRotation, smoothTargetRotation, neckLerpSpeed * Time.deltaTime * num);
		timer += Time.deltaTime;
	}
}
public class BoneBlink : MonoBehaviour
{
	public Transform upperLid1;

	public Transform lowerLid1;

	public Transform upperLid2;

	public Transform lowerLid2;

	public float upperLidOpenSize = 5f;

	public float lowerLidOpenSize = 10f;

	public float openSpeed = 2f;

	public float closeSpeed = 15f;

	private Quaternion upperLid1Open;

	private Quaternion upperLid1Closed;

	private Quaternion lowerLid1Open;

	private Quaternion lowerLid1Closed;

	private Quaternion upperLid2Open;

	private Quaternion upperLid2Closed;

	private Quaternion lowerLid2Open;

	private Quaternion lowerLid2Closed;

	public int mouthOpenChance = 300;

	public Vector2 mouthOpenTimeRange = new Vector2(1f, 3f);

	private float openMouthTimer;

	public Vector3 axis;

	public bool flipRightEye;

	private void Start()
	{
		int num = 1;
		if (flipRightEye)
		{
			num = -1;
		}
		upperLid1Open = upperLid1.localRotation * Quaternion.Euler(axis * (0f - upperLidOpenSize) * num);
		lowerLid1Open = lowerLid1.localRotation * Quaternion.Euler(axis * (0f - lowerLidOpenSize) * num);
		upperLid2Open = upperLid2.localRotation * Quaternion.Euler(axis * (0f - upperLidOpenSize));
		lowerLid2Open = lowerLid2.localRotation * Quaternion.Euler(axis * (0f - lowerLidOpenSize));
		upperLid1Closed = upperLid1.localRotation;
		lowerLid1Closed = lowerLid1.localRotation;
		upperLid2Closed = upperLid2.localRotation;
		lowerLid2Closed = lowerLid2.localRotation;
		openMouthTimer = 0f;
	}

	private void Update()
	{
		if (Random.Range(0, mouthOpenChance) == 1)
		{
			openMouthTimer = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
		}
		if (openMouthTimer > 0f)
		{
			upperLid1.localRotation = Quaternion.Slerp(upperLid1.localRotation, upperLid1Open, Time.deltaTime * closeSpeed);
			lowerLid1.localRotation = Quaternion.Slerp(lowerLid1.localRotation, lowerLid1Open, Time.deltaTime * closeSpeed);
			upperLid2.localRotation = Quaternion.Slerp(upperLid2.localRotation, upperLid2Open, Time.deltaTime * closeSpeed);
			lowerLid2.localRotation = Quaternion.Slerp(lowerLid2.localRotation, lowerLid2Open, Time.deltaTime * closeSpeed);
		}
		else
		{
			upperLid1.localRotation = Quaternion.Slerp(upperLid1.localRotation, upperLid1Closed, Time.deltaTime * closeSpeed);
			lowerLid1.localRotation = Quaternion.Slerp(lowerLid1.localRotation, lowerLid1Closed, Time.deltaTime * closeSpeed);
			upperLid2.localRotation = Quaternion.Slerp(upperLid2.localRotation, upperLid2Closed, Time.deltaTime * closeSpeed);
			lowerLid2.localRotation = Quaternion.Slerp(lowerLid2.localRotation, lowerLid2Closed, Time.deltaTime * closeSpeed);
		}
		openMouthTimer -= Time.deltaTime;
	}
}
public class Dolphin : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed;

	public float minDistance = 1.1f;

	public float repulseForce = 0.55f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	public float playerTurnSpeed = 1f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float playerRotateToTargetSpeed = 2f;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int satiatedness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private FoodSources foodSources;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public Transform staticBone;

	private Vector3 staticAxis;

	private float reverseTimer;

	public float lerpToTargetPosSpeed = 10f;

	public BoxCollider movementZone;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		foodSources = GameObject.Find("_Helper Scripts").GetComponent<FoodSources>();
		eatThings = GetComponent<EatThings>();
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		targetPos = target.position;
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
		movementZone = base.transform.Find("Target").GetComponent<MovingTarget>().movementZone;
	}

	private void FixedUpdate()
	{
		if (!movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = false;
		}
		if (!foodIsTarget)
		{
			if (Random.Range(0, hungryness) == 1)
			{
				setFoodTarget(foodSources.getRandom());
			}
		}
		else if (Random.Range(0, satiatedness) == 1)
		{
			setFoodTarget(null);
		}
		if (Random.Range(0, friendliness) == 1)
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyZ = Random.Range(swimFreqRangeZ.x, swimFreqRangeZ.y);
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	private void Update()
	{
		float magnitude = (player.transform.position + new Vector3(0f, 0f, 0f) - head.transform.position).magnitude;
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (foodIsTarget)
		{
			turnSpeed = attackingTurnSpeed;
		}
		else
		{
			turnSpeed = defaultTurnSpeed;
		}
		if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = Vector3.Lerp(targetPos, food.transform.position, Time.smoothDeltaTime * 5f);
			}
		}
		else if (playerIsTarget)
		{
			turnSpeed = playerTurnSpeed;
			rotateToTargetSpeed = playerRotateToTargetSpeed;
			targetPos = Vector3.Lerp(targetPos, player.transform.position + new Vector3(0f, 0.05f, 0f), Time.smoothDeltaTime * lerpToTargetPosSpeed);
			if (magnitude < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, Time.smoothDeltaTime * lerpToTargetPosSpeed);
			turnSpeed = defaultTurnSpeed;
			rotateToTargetSpeed = defaultRotateToTargetSpeed;
		}
		if (magnitude < minDistance)
		{
			Vector3 normalized = (head.transform.position - player.transform.position).normalized;
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			if (Random.Range(0, 100) == 1)
			{
				turnSpeed = 0.5f;
			}
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration * Time.smoothDeltaTime;
		}
		else
		{
			moveSpeed -= maxAcceleration * Time.smoothDeltaTime;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.smoothDeltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay * Time.smoothDeltaTime;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.smoothDeltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.smoothDeltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.smoothDeltaTime * swimAmplitudeZ * angleZ);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.smoothDeltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		if (!doBarrelRoll)
		{
			rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.smoothDeltaTime));
		}
		else
		{
			rot = head.transform.rotation;
		}
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.smoothDeltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.smoothDeltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.smoothDeltaTime * swimFrequencyLerp);
		swimXTimer += Time.smoothDeltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.smoothDeltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.smoothDeltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			Quaternion quaternion = ((i <= 0) ? localRotation : bones[i - 1].localRotation);
			float z = localRotation.eulerAngles.z;
			float num = Mathf.DeltaAngle(quaternion.eulerAngles.z, localRotation.eulerAngles.z);
			if (i > 1 && num > 150f)
			{
				z = 0f;
			}
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.smoothDeltaTime * tailAmplitudeLerp);
		targetTailAmplitude -= tailAmplitudeDecay * Time.smoothDeltaTime;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		if (food == null)
		{
			foodIsTarget = false;
		}
		else
		{
			foodIsTarget = true;
		}
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class DoubleJawAnimator : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw1;

	public Transform lowerJaw2;

	public float upperOpenSize = 5f;

	public float lowerOpenSize1 = 5f;

	public float lowerOpenSize2 = 5f;

	public float openSpeed = 2f;

	public int mouthOpenChance = 300;

	public Vector2 mouthOpenTimeRange = new Vector2(1f, 3f);

	public AnimationCurve mouthLerpCurve;

	public float upperJawOffset;

	public float lowerJawOffset1;

	public float lowerJawOffset2;

	public Vector3 lowerJawAxis1 = new Vector3(0f, 1f, 0f);

	public Vector3 lowerJawAxis2 = new Vector3(0f, 0f, 1f);

	private Quaternion upperJawClosed;

	private Quaternion upperJawOpen;

	private Quaternion upperJawBiting;

	private Quaternion lowerJawClosed1;

	private Quaternion lowerJawOpen1;

	private Quaternion lowerJawClosed2;

	private Quaternion lowerJawOpen2;

	private float openMouthTimer;

	private float openMouthTime = 1f;

	private Quaternion upperJawTargetRotation;

	private Quaternion lowerJawTargetRotation1;

	private Quaternion lowerJawTargetRotation2;

	public float lerpSpeed = 1f;

	private void Start()
	{
		lowerJawClosed1 = lowerJaw1.localRotation * Quaternion.Euler(lowerJawAxis1 * (0f - lowerJawOffset1));
		lowerJawClosed2 = lowerJaw2.localRotation * Quaternion.Euler(lowerJawAxis2 * (0f - lowerJawOffset2));
		lowerJawOpen1 = lowerJaw1.localRotation * Quaternion.Euler(lowerJawAxis1 * lowerOpenSize1);
		lowerJawOpen2 = lowerJaw2.localRotation * Quaternion.Euler(lowerJawAxis2 * lowerOpenSize2);
		upperJawClosed = upperJaw.localRotation * Quaternion.Euler(0f, 0f, upperJawOffset);
		upperJawOpen = upperJawClosed * Quaternion.Euler(0f, 0f, 0f - upperOpenSize);
		upperJaw.localRotation = upperJawClosed;
		lowerJaw1.localRotation = lowerJawClosed1;
		lowerJaw2.localRotation = lowerJawClosed2;
		openMouthTimer = 0f;
	}

	private void Update()
	{
		if (openMouthTimer > openMouthTime * 2f && Random.Range(1, mouthOpenChance) == 1)
		{
			openMouthTime = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
			openMouthTimer = 0f;
			float num = Random.Range(0f, 5f);
			lowerJawOpen1 = lowerJaw1.localRotation * Quaternion.Euler(lowerJawAxis1 * lowerOpenSize1 * num);
			lowerJawOpen2 = lowerJaw2.localRotation * Quaternion.Euler(lowerJawAxis2 * lowerOpenSize2 * num);
			upperJawOpen = upperJawClosed * Quaternion.Euler(0f, 0f, 0f - upperOpenSize);
			lerpSpeed = Random.Range(1f, 6f);
		}
		float num2 = 0f;
		if (openMouthTimer < openMouthTime / 1f)
		{
			upperJawTargetRotation = upperJawOpen;
			lowerJawTargetRotation1 = lowerJawOpen1;
			lowerJawTargetRotation2 = lowerJawOpen2;
		}
		else
		{
			upperJawTargetRotation = upperJawClosed;
			lowerJawTargetRotation1 = lowerJawClosed1;
			lowerJawTargetRotation2 = lowerJawClosed2;
		}
		num2 = 0.001f + mouthLerpCurve.Evaluate(openMouthTimer / openMouthTime / 2f);
		openMouthTimer += Time.deltaTime;
		upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawTargetRotation, Time.deltaTime * lerpSpeed * num2);
		lowerJaw1.localRotation = Quaternion.Slerp(lowerJaw1.localRotation, lowerJawTargetRotation1, Time.deltaTime * lerpSpeed * num2);
		lowerJaw2.localRotation = Quaternion.Slerp(lowerJaw2.localRotation, lowerJawTargetRotation2, Time.deltaTime * lerpSpeed * num2);
	}
}
public class DynamicFish : MonoBehaviour
{
	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public float defaultFrequency = 1f;

	public float maxFrequency = 3f;

	public float frequencyDecay = 0.01f;

	public float maxAmplitude = 60f;

	private float targetAmplitude = 1f;

	private float amplitude = 1f;

	private float targetFrequency;

	public float phase = 0.3f;

	public float[] tailAmplifier;

	public Vector3 axis = new Vector3(1f, 0f, 0f);

	private float swimTimer;

	private float frequency;

	private float kickTimer;

	private float turningAngle;

	public float tailLerp = 1f;

	public Transform staticBone;

	private Vector3 staticAxis = new Vector3(0f, 0f, 0f);

	private Quaternion swimComponent;

	private void Start()
	{
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		frequency = defaultFrequency;
		swimTimer = (float)Math.PI;
		kickTimer = 101f;
		kickTail(10000f);
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
	}

	public void kickTail(float amount)
	{
		if (kickTimer > 1f)
		{
			targetFrequency = maxFrequency * amount;
			targetAmplitude = maxAmplitude;
		}
		targetFrequency = Mathf.Clamp(targetFrequency, defaultFrequency, maxFrequency);
	}

	public void updateTurningAngle(float angle)
	{
		turningAngle = angle;
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		swimComponent = Quaternion.identity;
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, localRotation.eulerAngles.z);
			transform.localRotation = localRotation;
			Quaternion quaternion = ((i <= 0) ? localRotation : bones[i - 1].localRotation);
			float z = localRotation.eulerAngles.z;
			float num = Mathf.DeltaAngle(quaternion.eulerAngles.z, localRotation.eulerAngles.z);
			if (i > 1 && num > 150f)
			{
				z = 0f;
			}
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, z);
			transform.localRotation = localRotation;
		}
		amplitude = Mathf.Lerp(amplitude, targetAmplitude, Time.deltaTime * tailLerp);
		frequency = Mathf.Lerp(frequency, targetFrequency, Time.deltaTime * tailLerp);
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float angle = Mathf.Sin(swimTimer + phase * (float)j) * (amplitude * tailAmplifier[j]);
				bones[j].Rotate(axis, angle);
			}
		}
		targetFrequency *= frequencyDecay;
		targetAmplitude *= frequencyDecay;
		swimTimer += Time.deltaTime * targetFrequency;
		kickTimer += Time.deltaTime;
	}
}
public class DynamicSnake : MonoBehaviour
{
	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	private void Start()
	{
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
	}

	private void Update()
	{
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
		}
	}
}
public class EatThings : MonoBehaviour
{
	private bool bHungry;

	private FoodSources foodSources;

	public float updateFoodEvery = 3f;

	public int hungriness = 1000;

	public int satiatedness = 10000;

	private Transform foodTarget;

	private float updateFoodTimer;

	private GameObject currentFood;

	private void Start()
	{
		foodSources = GameObject.Find("_Helper Scripts").GetComponent<FoodSources>();
		updateFoodTimer = float.PositiveInfinity;
	}

	private void Update()
	{
		if (Random.Range(0, hungriness) == 1)
		{
			bHungry = true;
		}
		if (Random.Range(0, satiatedness) == 1)
		{
			bHungry = false;
		}
		if (bHungry && updateFoodTimer > updateFoodEvery)
		{
			currentFood = foodSources.getRandom();
			if (!(currentFood != null))
			{
				bHungry = false;
			}
			updateFoodTimer = 0f;
		}
		updateFoodTimer += Time.deltaTime;
	}

	public GameObject getCurrentFood()
	{
		return currentFood;
	}
}
public class Edible : MonoBehaviour
{
	private void Start()
	{
	}
}
public class FlipperFlapper : MonoBehaviour
{
	public bool stroking;

	public Transform leftFlipper;

	public Transform rightFlipper;

	public float amplitude;

	public float frequency;

	public Vector3 axis = new Vector3(0f, 1f, 0f);

	private float timer;

	public float startTimer = -1000f;

	public AnimationCurve strokeCurve;

	private Quaternion baseFrontLeftFinRotation;

	private Quaternion baseFrontRightFinRotation;

	public float finOffset = -30f;

	private Vector3 prevAngle;

	private Vector3 currAngle;

	private SoftFlipper leftSoftFlipper;

	private SoftFlipper rightSoftFlipper;

	public Vector3 leftRestRotation;

	public Vector3 rightRestRotation;

	public float flipperRestSpeed = 2f;

	public float flipperStrokePower = 10f;

	public float transitionLerp = 5f;

	private float defaultFlipperRestSpeed;

	private float defaultFlipperStrokePower;

	public Vector3 flipperRotationalOffset = new Vector3(0f, 0f, 0f);

	public bool flipRightFlipper;

	public Vector2 strokeTimeRange = new Vector2(0.5f, 1f);

	private float strokeTimer;

	private float flipperTimer;

	private bool drawStroke;

	private void Start()
	{
		defaultFlipperRestSpeed = flipperRestSpeed;
		defaultFlipperStrokePower = flipperStrokePower;
		timer = 0f;
		baseFrontLeftFinRotation = leftFlipper.localRotation * Quaternion.Euler(flipperRotationalOffset);
		baseFrontRightFinRotation = rightFlipper.localRotation * Quaternion.Euler(-flipperRotationalOffset);
		prevAngle = new Vector3(0f, 0f, 0f);
		leftSoftFlipper = leftFlipper.GetComponent<SoftFlipper>();
		rightSoftFlipper = rightFlipper.GetComponent<SoftFlipper>();
		strokeTimer = startTimer;
	}

	private void Update()
	{
		if (strokeTimer < 0f)
		{
			stroking = false;
		}
		else
		{
			stroking = true;
		}
		if (stroking)
		{
			flipperRestSpeed = Mathf.Lerp(flipperRestSpeed, 0f, Time.deltaTime * transitionLerp);
			flipperStrokePower = Mathf.Lerp(flipperStrokePower, defaultFlipperStrokePower, Time.deltaTime * transitionLerp);
		}
		else
		{
			flipperStrokePower = Mathf.Lerp(flipperStrokePower, 0f, Time.deltaTime * transitionLerp);
			flipperRestSpeed = Mathf.Lerp(flipperRestSpeed, defaultFlipperRestSpeed, Time.deltaTime * transitionLerp);
		}
		leftFlipper.localRotation = Quaternion.Lerp(leftFlipper.localRotation, Quaternion.Euler(leftRestRotation), Time.deltaTime * flipperRestSpeed);
		rightFlipper.localRotation = Quaternion.Lerp(rightFlipper.localRotation, Quaternion.Euler(rightRestRotation), Time.deltaTime * flipperRestSpeed);
		SimpleStroke();
		strokeTimer -= Time.deltaTime;
	}

	private void SimpleStroke()
	{
		float num = strokeCurve.Evaluate(timer);
		float num2 = num * amplitude + finOffset;
		leftFlipper.localRotation = Quaternion.Slerp(leftFlipper.localRotation, baseFrontLeftFinRotation * Quaternion.Euler(0f, 0f, num2), Time.deltaTime * flipperStrokePower);
		if (flipRightFlipper)
		{
			num2 *= -1f;
		}
		rightFlipper.localRotation = Quaternion.Slerp(rightFlipper.localRotation, baseFrontRightFinRotation * Quaternion.Euler(0f, 0f, num2), Time.deltaTime * flipperStrokePower);
		timer += Time.deltaTime * frequency;
		leftSoftFlipper.SetVelocity(num * flipperStrokePower);
		rightSoftFlipper.SetVelocity(num * flipperStrokePower);
	}

	public void Stroke()
	{
		strokeTimer = Random.Range(strokeTimeRange.x, strokeTimeRange.y);
	}
}
public class FoodSources : MonoBehaviour
{
	public GameObject[] food;

	public float updateEvery = 5f;

	private float updateTimer;

	private void Start()
	{
		updateTimer = float.PositiveInfinity;
	}

	public GameObject getRandom()
	{
		if (food.Length == 0)
		{
			return null;
		}
		return food[Random.Range(0, food.Length)];
	}

	private void Update()
	{
		if (updateTimer > updateEvery)
		{
			food = GameObject.FindGameObjectsWithTag("Food");
			updateTimer = 0f;
		}
		updateTimer += Time.deltaTime;
	}
}
public class GreatWhiteShark : MonoBehaviour
{
	public bool playerIsTarget;

	public Transform head;

	public Rigidbody body;

	public DynamicFish dynamicFish;

	public AdvancedJawsAnimator jawsAnimator;

	public float defaultSpeed;

	public float fastestSpeed;

	public float attackingSpeed;

	public float cageAttackingSpeed = 1.5f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float turnSpeed;

	public float attackingTurnSpeed;

	public Transform cage;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	public BoxCollider safeZone;

	public BoxCollider hostileZone;

	public float defaultRotateToTargetTime;

	public float attackingPlayerRotateToTargetTime = 3f;

	public float attackingCageRotateToTargetTime = 2f;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int speedChangeChance = 200;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float swimFrequencyZ;

	private float rotateToTargetTime;

	private GameObject player;

	private Vector3 targetPos;

	private float rotateTimer;

	private Vector3 prevTargetPos;

	private float targetSwimAmplitudeX;

	private float targetSwimAmplitudeY;

	private float targetSwimFrequencyX;

	private float targetSwimFrequencyY;

	public float amplitudeSlerpSpeed = 1f;

	private float rotateToTargetTimer;

	private float speedError;

	public int barrelRollChance;

	public float barrelRollSpeed = 1f;

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float repulseTimer;

	private Vector3 repulseNormal;

	private float thrashingTimer;

	private bool bThrashing;

	public int thrashingChance = 500;

	private void Start()
	{
		bThrashing = false;
		thrashingTimer = 0f;
		repulseTimer = 0f;
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		rotateToTargetTime = defaultRotateToTargetTime;
		rotateToTargetTimer = 0f;
		targetSwimAmplitudeX = swimAmplitudeX;
		targetSwimAmplitudeY = swimAmplitudeY;
		jawsAnimator = GetComponent<AdvancedJawsAnimator>();
		changeBehaviour();
	}

	private void changeBehaviour()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		if (targetSpeed > 0f)
		{
			speedError = 0.3f + (targetSpeed - moveSpeed) / fastestSpeed;
		}
		if (dynamicFish != null)
		{
			dynamicFish.kickTail(speedError);
		}
		targetSwimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		targetSwimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		swimAmplitudeZ = 0f;
		angleZ = 0f;
	}

	private void activateThrashing()
	{
		thrashingTimer = Random.Range(0.5f, 2.5f);
		targetSwimAmplitudeX = Random.Range(40, 80);
		targetSwimFrequencyX = Random.Range(3, 12);
		bThrashing = true;
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, thrashingChance) == 1)
		{
			activateThrashing();
		}
		if (bThrashing && thrashingTimer < 0f)
		{
			changeBehaviour();
			bThrashing = false;
		}
		if (!doBarrelRoll)
		{
			if (jawsAnimator.getBiting())
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
				activateThrashing();
				thrashingTimer = 5.5f;
				targetSwimAmplitudeX = 80f;
				targetSwimAmplitudeY = 0f;
				targetSwimFrequencyX = 8f;
				targetSwimFrequencyY = 0f;
				bThrashing = true;
			}
			if (Random.Range(0, barrelRollChance) == 1)
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
			}
		}
		if (Random.Range(0, friendliness) == 1)
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1 && !doBarrelRoll)
		{
			playerIsTarget = false;
			activateThrashing();
		}
		if (safeZone != null)
		{
			if (safeZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = false;
			}
			else
			{
				jawsAnimator.hostile = true;
				playerIsTarget = true;
			}
		}
		if (hostileZone != null)
		{
			if (hostileZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = true;
			}
			else
			{
				jawsAnimator.hostile = false;
				playerIsTarget = false;
			}
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 0.6f, 0f);
			float magnitude = (targetPos - head.transform.position).magnitude;
			if (jawsAnimator.hostile)
			{
				targetSpeed = attackingSpeed;
			}
			else
			{
				targetSpeed = cageAttackingSpeed;
			}
			if (jawsAnimator.hostile)
			{
				rotateToTargetTime = attackingPlayerRotateToTargetTime;
			}
			else
			{
				rotateToTargetTime = attackingCageRotateToTargetTime;
			}
		}
		else
		{
			targetPos = target.position;
			if ((targetPos - head.position).magnitude < 2f && target.GetComponent<MovingTarget>() != null)
			{
				target.GetComponent<MovingTarget>().change();
			}
			rotateToTargetTime = defaultRotateToTargetTime;
		}
		if (!playerIsTarget && prevTargetPos != targetPos)
		{
			rotateTimer = 0f;
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			changeBehaviour();
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration;
		}
		swimAmplitudeX = Mathf.Lerp(swimAmplitudeX, targetSwimAmplitudeX, Time.deltaTime * amplitudeSlerpSpeed);
		swimAmplitudeY = Mathf.Lerp(swimAmplitudeY, targetSwimAmplitudeY, Time.deltaTime * amplitudeSlerpSpeed);
		swimFrequencyX = targetSwimFrequencyX;
		swimFrequencyY = targetSwimFrequencyY;
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (repulseTimer > 0f)
		{
			head.GetComponent<Rigidbody>().AddForce(repulseNormal * 1.5f, ForceMode.Impulse);
		}
		if (playerIsTarget)
		{
			angleX = Mathf.Sin(swimFrequencyX * swimTimer) * attackingTurnSpeed;
			angleY = Mathf.Sin(swimFrequencyY * swimTimer) * attackingTurnSpeed;
			angleZ = Mathf.Sin(swimFrequencyZ * swimTimer) * attackingTurnSpeed;
		}
		else
		{
			angleX = Mathf.Sin(swimFrequencyX * swimTimer) * turnSpeed;
			angleY = Mathf.Sin(swimFrequencyY * swimTimer) * turnSpeed;
			angleZ = Mathf.Sin(swimFrequencyZ * swimTimer) * turnSpeed;
		}
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * angleZ * swimAmplitudeZ);
		float num = 0f;
		float num2 = 0.1f;
		float num3 = 1f;
		float num4 = 1f;
		float num5 = 200f;
		if (doBarrelRoll)
		{
			if (barrelRollAngle < 180f)
			{
				num = num2 + barrelRollAngle / 180f;
			}
			float num6 = num * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num6;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num6);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, rotateToTargetTime * Time.deltaTime * rotateTimer);
		head.transform.rotation = rot * swimComponent;
		headingAngle = getAngle(head.rotation, targetQuat);
		swimTimer += Time.deltaTime;
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		rotateTimer += Time.deltaTime * 0.8f;
		repulseTimer -= Time.deltaTime;
		thrashingTimer -= Time.deltaTime;
		if (rotateTimer > 1f)
		{
			rotateTimer = 1f;
		}
		prevTargetPos = targetPos;
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
		dynamicFish.kickTail(1.5f);
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		repulseNormal = normal;
		int num = Random.Range(0, 2);
		if (!jawsAnimator.hostile)
		{
			playerIsTarget = false;
		}
		target.position = head.position + Vector3.Cross(normal, Vector3.up) * 5f;
		activateThrashing();
		if (Random.Range(0, 3) == 1)
		{
			swimAmplitudeZ = Random.Range(0, 60);
			swimFrequencyZ = Random.Range(1, 7);
		}
		if (Random.Range(0, 3) == 1)
		{
			targetSpeed = defaultSpeed;
		}
		if (Random.Range(0, 3) == 1)
		{
			struggle();
		}
		target.GetComponent<MovingTarget>().setTimer(0f);
		repulseTimer = Random.Range(0.1f, 1f);
	}
}
[Serializable]
public class BendingSegment
{
	public Transform firstTransform;

	public Transform lastTransform;

	public float thresholdAngleDifference;

	public float bendingMultiplier = 0.6f;

	public float maxAngleDifference = 30f;

	public float maxBendingAngle = 80f;

	public float responsiveness = 5f;

	internal float angleH;

	internal float angleV;

	internal Vector3 dirUp;

	internal Vector3 referenceLookDir;

	internal Vector3 referenceUpDir;

	internal int chainLength;

	internal Quaternion[] origRotations;
}
[Serializable]
public class NonAffectedJoints
{
	public Transform joint;

	public float effect;
}
public class HeadLookController : MonoBehaviour
{
	public Transform rootNode;

	public BendingSegment[] segments;

	public NonAffectedJoints[] nonAffectedJoints;

	public Vector3 headLookVector = Vector3.forward;

	public Vector3 headUpVector = Vector3.up;

	public Transform target;

	public float effect = 1f;

	public bool overrideAnimation;

	private void Start()
	{
		if (rootNode == null)
		{
			rootNode = base.transform;
		}
		BendingSegment[] array = segments;
		foreach (BendingSegment bendingSegment in array)
		{
			Quaternion rotation = bendingSegment.firstTransform.parent.rotation;
			Quaternion quaternion = Quaternion.Inverse(rotation);
			bendingSegment.referenceLookDir = quaternion * rootNode.rotation * headLookVector.normalized;
			bendingSegment.referenceUpDir = quaternion * rootNode.rotation * headUpVector.normalized;
			bendingSegment.angleH = 0f;
			bendingSegment.angleV = 0f;
			bendingSegment.dirUp = bendingSegment.referenceUpDir;
			bendingSegment.chainLength = 1;
			Transform transform = bendingSegment.lastTransform;
			while (transform != bendingSegment.firstTransform && transform != transform.root)
			{
				bendingSegment.chainLength++;
				transform = transform.parent;
			}
			bendingSegment.origRotations = new Quaternion[bendingSegment.chainLength];
			transform = bendingSegment.lastTransform;
			for (int num = bendingSegment.chainLength - 1; num >= 0; num--)
			{
				ref Quaternion reference = ref bendingSegment.origRotations[num];
				reference = transform.localRotation;
				transform = transform.parent;
			}
		}
	}

	private void LateUpdate()
	{
		if (Time.deltaTime == 0f)
		{
			return;
		}
		Vector3[] array = new Vector3[nonAffectedJoints.Length];
		for (int i = 0; i < nonAffectedJoints.Length; i++)
		{
			{
				IEnumerator enumerator = nonAffectedJoints[i].joint.GetEnumerator();
				try
				{
					if (enumerator.MoveNext())
					{
						Transform transform = (Transform)enumerator.Current;
						ref Vector3 reference = ref array[i];
						reference = transform.position - nonAffectedJoints[i].joint.position;
					}
				}
				finally
				{
					IDisposable disposable = enumerator as IDisposable;
					if (disposable != null)
					{
						disposable.Dispose();
					}
				}
			}
		}
		BendingSegment[] array2 = segments;
		foreach (BendingSegment bendingSegment in array2)
		{
			Transform transform2 = bendingSegment.lastTransform;
			if (overrideAnimation)
			{
				for (int num = bendingSegment.chainLength - 1; num >= 0; num--)
				{
					transform2.localRotation = bendingSegment.origRotations[num];
					transform2 = transform2.parent;
				}
			}
			Quaternion rotation = bendingSegment.firstTransform.parent.rotation;
			Quaternion quaternion = Quaternion.Inverse(rotation);
			Vector3 normalized = (target.position - bendingSegment.lastTransform.position).normalized;
			Vector3 vector = quaternion * normalized;
			float f = AngleAroundAxis(bendingSegment.referenceLookDir, vector, bendingSegment.referenceUpDir);
			Vector3 axis = Vector3.Cross(bendingSegment.referenceUpDir, vector);
			Vector3 dirA = vector - Vector3.Project(vector, bendingSegment.referenceUpDir);
			float f2 = AngleAroundAxis(dirA, vector, axis);
			float f3 = Mathf.Max(0f, Mathf.Abs(f) - bendingSegment.thresholdAngleDifference) * Mathf.Sign(f);
			float f4 = Mathf.Max(0f, Mathf.Abs(f2) - bendingSegment.thresholdAngleDifference) * Mathf.Sign(f2);
			f = Mathf.Max(Mathf.Abs(f3) * Mathf.Abs(bendingSegment.bendingMultiplier), Mathf.Abs(f) - bendingSegment.maxAngleDifference) * Mathf.Sign(f) * Mathf.Sign(bendingSegment.bendingMultiplier);
			f2 = Mathf.Max(Mathf.Abs(f4) * Mathf.Abs(bendingSegment.bendingMultiplier), Mathf.Abs(f2) - bendingSegment.maxAngleDifference) * Mathf.Sign(f2) * Mathf.Sign(bendingSegment.bendingMultiplier);
			f = Mathf.Clamp(f, 0f - bendingSegment.maxBendingAngle, bendingSegment.maxBendingAngle);
			f2 = Mathf.Clamp(f2, 0f - bendingSegment.maxBendingAngle, bendingSegment.maxBendingAngle);
			Vector3 axis2 = Vector3.Cross(bendingSegment.referenceUpDir, bendingSegment.referenceLookDir);
			bendingSegment.angleH = Mathf.Lerp(bendingSegment.angleH, f, Time.deltaTime * bendingSegment.responsiveness);
			bendingSegment.angleV = Mathf.Lerp(bendingSegment.angleV, f2, Time.deltaTime * bendingSegment.responsiveness);
			vector = Quaternion.AngleAxis(bendingSegment.angleH, bendingSegment.referenceUpDir) * Quaternion.AngleAxis(bendingSegment.angleV, axis2) * bendingSegment.referenceLookDir;
			Vector3 tangent = bendingSegment.referenceUpDir;
			Vector3.OrthoNormalize(ref vector, ref tangent);
			Vector3 normal = vector;
			bendingSegment.dirUp = Vector3.Slerp(bendingSegment.dirUp, tangent, Time.deltaTime * 5f);
			Vector3.OrthoNormalize(ref normal, ref bendingSegment.dirUp);
			Quaternion b = rotation * Quaternion.LookRotation(normal, bendingSegment.dirUp) * Quaternion.Inverse(rotation * Quaternion.LookRotation(bendingSegment.referenceLookDir, bendingSegment.referenceUpDir));
			Quaternion quaternion2 = Quaternion.Slerp(Quaternion.identity, b, effect / (float)bendingSegment.chainLength);
			transform2 = bendingSegment.lastTransform;
			for (int k = 0; k < bendingSegment.chainLength; k++)
			{
				transform2.rotation = quaternion2 * transform2.rotation;
				transform2 = transform2.parent;
			}
		}
		for (int l = 0; l < nonAffectedJoints.Length; l++)
		{
			Vector3 vector2 = Vector3.zero;
			{
				IEnumerator enumerator2 = nonAffectedJoints[l].joint.GetEnumerator();
				try
				{
					if (enumerator2.MoveNext())
					{
						Transform transform3 = (Transform)enumerator2.Current;
						vector2 = transform3.position - nonAffectedJoints[l].joint.position;
					}
				}
				finally
				{
					IDisposable disposable2 = enumerator2 as IDisposable;
					if (disposable2 != null)
					{
						disposable2.Dispose();
					}
				}
			}
			Vector3 toDirection = Vector3.Slerp(array[l], vector2, nonAffectedJoints[l].effect);
			nonAffectedJoints[l].joint.rotation = Quaternion.FromToRotation(vector2, toDirection) * nonAffectedJoints[l].joint.rotation;
		}
	}

	public static float AngleAroundAxis(Vector3 dirA, Vector3 dirB, Vector3 axis)
	{
		dirA -= Vector3.Project(dirA, axis);
		dirB -= Vector3.Project(dirB, axis);
		float num = Vector3.Angle(dirA, dirB);
		return num * (float)((!(Vector3.Dot(axis, Vector3.Cross(dirA, dirB)) < 0f)) ? 1 : (-1));
	}
}
public class HumpbackWhale : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	public float playerTurnSpeed = 1f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float playerRotateToTargetSpeed = 2f;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private FoodSources foodSources;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public Transform staticBone;

	private Vector3 staticAxis;

	private float reverseTimer;

	private Vector3 fluidTargetPosition;

	public float targetPosLerp = 1f;

	public float minDistanceToPlayer = 2f;

	public float repulseForce = 1f;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		foodSources = GameObject.Find("_Helper Scripts").GetComponent<FoodSources>();
		targetPos = target.position;
		fluidTargetPosition = targetPos;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		eatThings = GetComponent<EatThings>();
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, hungryness) == 1)
		{
			setFoodTarget(foodSources.getRandom());
		}
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
			targetSpeed = defaultSpeed;
		}
		if (!doBarrelRoll && Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyZ = Random.Range(swimFreqRangeZ.x, swimFreqRangeZ.y);
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	private void Update()
	{
		float magnitude = (player.transform.position + new Vector3(0f, 0f, 0f) - head.transform.position).magnitude;
		if ((target.position - head.transform.position).magnitude < 6f)
		{
			target.GetComponent<MovingTarget>().change();
		}
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (foodIsTarget)
		{
			turnSpeed = attackingTurnSpeed;
		}
		else
		{
			turnSpeed = defaultTurnSpeed;
		}
		if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
			}
		}
		else if (playerIsTarget)
		{
			turnSpeed = playerTurnSpeed;
			rotateToTargetSpeed = playerRotateToTargetSpeed;
			targetPos = player.transform.position + new Vector3(0f, 0.25f, 0f);
			if (magnitude < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, Time.deltaTime * targetPosLerp);
			turnSpeed = defaultTurnSpeed;
		}
		if (magnitude < minDistanceToPlayer)
		{
			Vector3 normalized = (head.transform.position - player.transform.position).normalized;
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			if (Random.Range(0, 100) == 1)
			{
				turnSpeed = 0.5f;
			}
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		if (doBarrelRoll)
		{
			float num = 0.01f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 350f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		float num4 = 0.5f;
		fluidTargetPosition = Vector3.Lerp(fluidTargetPosition, targetPos, Time.deltaTime * num4);
		targetDir = fluidTargetPosition - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		if (!doBarrelRoll)
		{
			rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		}
		else
		{
			rot = head.transform.rotation;
		}
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			Quaternion quaternion = ((i <= 0) ? localRotation : bones[i - 1].localRotation);
			float z = localRotation.eulerAngles.z;
			float num = Mathf.DeltaAngle(quaternion.eulerAngles.z, localRotation.eulerAngles.z);
			if (i > 1 && num > 150f)
			{
				z = 0f;
			}
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class LargeAquaticCreature : MonoBehaviour
{
	public bool speedGovernsXSwimAmplitude;

	public bool speedGovernsYSwimAmplitude;

	public bool speedGovernsXSwimFrequency;

	public bool speedGovernsYSwimFrequency;

	public bool playerIsTarget;

	public Transform head;

	public Rigidbody body;

	public DynamicFish dynamicFish;

	public AdvancedJawsAnimator jawsAnimator;

	public float defaultSpeed;

	public float fastestSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float turnSpeed;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	public float defaultRotateToTargetTime;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int speedChangeChance = 200;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float rotateToTargetTime;

	private GameObject player;

	private Vector3 targetPos;

	private Transform waterSurface;

	private float rotateTimer;

	private Vector3 prevTargetPos;

	private float targetSwimAmplitudeX;

	private float targetSwimAmplitudeY;

	private float targetSwimFrequencyX;

	private float targetSwimFrequencyY;

	public float amplitudeSlerpSpeed = 1f;

	private float rotateToTargetTimer;

	private float speedError;

	public int barrelRollChance;

	public float barrelRollSpeed = 1f;

	private bool doBarrelRoll;

	private float barrelRollAngle;

	public float activeDistance = 10000f;

	private void Start()
	{
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		player = LAC_VRCameraRig.instance.getCenterCamera().gameObject;
		targetPos = target.position;
		rotateToTargetTime = defaultRotateToTargetTime;
		rotateToTargetTimer = 0f;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		targetSwimAmplitudeX = swimAmplitudeX;
		targetSwimAmplitudeY = swimAmplitudeY;
		jawsAnimator = GetComponent<AdvancedJawsAnimator>();
	}

	private void FixedUpdate()
	{
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
		}
		if (Random.Range(1, friendliness) == 1)
		{
			playerIsTarget = true;
		}
		if (Random.Range(1, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			float num = Random.Range(defaultSpeed, fastestSpeed);
			if (targetSpeed > 0f)
			{
				speedError = 0.3f + (targetSpeed - moveSpeed) / fastestSpeed;
			}
			targetSwimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
			targetSwimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
			targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
			targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		}
	}

	private void Update()
	{
		float magnitude = (player.transform.position - head.position).magnitude;
		if (magnitude < activeDistance)
		{
			head.gameObject.SetActive(value: true);
		}
		else
		{
			head.gameObject.SetActive(value: false);
		}
		if (speedGovernsXSwimAmplitude)
		{
			targetSwimAmplitudeX = swimAmplitudeMaxX * targetSpeed;
		}
		if (speedGovernsYSwimAmplitude)
		{
			targetSwimAmplitudeY = swimAmplitudeMaxY * targetSpeed;
		}
		if (speedGovernsXSwimFrequency)
		{
			targetSwimFrequencyX = swimFreqRangeX.y * targetSpeed;
		}
		if (speedGovernsYSwimFrequency)
		{
			targetSwimFrequencyY = swimFreqRangeY.y * targetSpeed;
		}
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 1f, 0f);
			float magnitude2 = (targetPos - head.transform.position).magnitude;
		}
		else
		{
			targetPos = target.position;
			if ((targetPos - head.position).magnitude < 2f && target.GetComponent<MovingTarget>() != null)
			{
				target.GetComponent<MovingTarget>().change();
			}
		}
		if (prevTargetPos != targetPos)
		{
			rotateTimer = 0f;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration;
		}
		swimAmplitudeX = Mathf.Lerp(swimAmplitudeX, targetSwimAmplitudeX, Time.deltaTime * amplitudeSlerpSpeed);
		swimAmplitudeY = Mathf.Lerp(swimAmplitudeY, targetSwimAmplitudeY, Time.deltaTime * amplitudeSlerpSpeed);
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * amplitudeSlerpSpeed);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * amplitudeSlerpSpeed);
		moveDirection = Vector3.zero;
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		angleX = Mathf.Sin(swimFrequencyX * swimTimer) * turnSpeed;
		angleY = Mathf.Sin(swimFrequencyY * swimTimer) * turnSpeed;
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY);
		float num = 0.1f;
		float num2 = 1.5f;
		float num3 = 1.5f;
		if (doBarrelRoll)
		{
			float num4 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * num3) : Mathf.Clamp01(num + barrelRollAngle / 180f * num2));
			float num5 = num4 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num5;
			if (barrelRollAngle > 350f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
				rotateTimer = 0f;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num5);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		if (!doBarrelRoll)
		{
			rot = Quaternion.Slerp(head.transform.rotation, targetQuat, rotateToTargetTime * Time.deltaTime * rotateTimer);
		}
		else
		{
			rot = head.transform.rotation;
		}
		head.transform.rotation = rot * swimComponent;
		headingAngle = getAngle(head.rotation, targetQuat);
		swimTimer += Time.deltaTime;
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		rotateTimer += Time.deltaTime * 0.1f;
		if (rotateTimer > 1f)
		{
			rotateTimer = 1f;
		}
		prevTargetPos = targetPos;
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
		dynamicFish.kickTail(1.5f);
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
		if (jawsAnimator != null && Random.Range(1, 4) == 3)
		{
			jawsAnimator.setBiting(val: true);
		}
	}
}
public class Manatee : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public DynamicFish dynamicFish;

	public JawsAnimator jawsAnimator;

	public float defaultSpeed;

	public float fastestSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float minDistance = 1.1f;

	public float repulseForce = 0.55f;

	public float turnSpeed;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollTimeRange = new Vector2(10f, 20f);

	public float barrelRollSpeed = 0.75f;

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float angleX;

	private float angleY;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	private Vector3 fluidTargetPosition;

	public float targetLerpSpeed = 1f;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float targetSwimFrequencyX;

	private float targetSwimFrequencyY;

	public float swimFrequencyLerp = 1f;

	private float barrelRollTimer;

	private float barrelRollTime = 12f;

	public AnimationCurve barrelRollCurve;

	public float targetPosLerp = 1f;

	private void Start()
	{
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		player = GameObject.Find("Dummy Player");
		targetPos = target.position;
		fluidTargetPosition = targetPos;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinZ, swimAmplitudeMaxZ);
		swimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		swimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, friendliness) == 1)
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollTime = Random.Range(barrelRollTimeRange.x, barrelRollTimeRange.y);
			barrelRollTimer = 0f;
		}
		if (Random.Range(0, speedChangeChance) == 1 && !doBarrelRoll)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		targetSpeed = Random.Range(defaultSpeed, fastestSpeed);
		float amount = 0.5f + (targetSpeed - moveSpeed) / fastestSpeed;
		dynamicFish.kickTail(amount);
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		swimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		swimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		swimTimer = 0f;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
	}

	private void Update()
	{
		float magnitude = (player.transform.position + new Vector3(0f, 0f, 0f) - head.transform.position).magnitude;
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y - 0.3f)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (playerIsTarget)
		{
			Vector3 b = player.transform.position + new Vector3(0f, 0.5f, 0f);
			targetPos = Vector3.Lerp(targetPos, b, Time.deltaTime * targetPosLerp);
			if ((targetPos - head.transform.position).magnitude < 2f)
			{
				targetSpeed = defaultSpeed;
			}
			if ((targetPos - head.transform.position).magnitude < 2f)
			{
				targetSpeed = 0.01f;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((targetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, targetPosLerp * Time.deltaTime);
		}
		if (magnitude < minDistance)
		{
			Vector3 normalized = (head.transform.position - player.transform.position).normalized;
			normalized.y = 0f;
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 5f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		if (doBarrelRoll)
		{
			targetSpeed = defaultSpeed;
			float num = barrelRollCurve.Evaluate(barrelRollTimer / barrelRollTime) * barrelRollSpeed;
			swimComponent *= Quaternion.Euler(Vector3.forward * num);
			barrelRollTimer += Time.deltaTime;
			if (barrelRollTimer > barrelRollTime)
			{
				doBarrelRoll = false;
			}
		}
		fluidTargetPosition = Vector3.Lerp(fluidTargetPosition, targetPos, Time.deltaTime * targetLerpSpeed);
		targetDir = fluidTargetPosition - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		head.transform.rotation = rot * swimComponent;
		swimTimer += Time.deltaTime;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
		dynamicFish.kickTail(1.5f);
	}

	public float getMoveSpeed()
	{
		return moveSpeed;
	}

	public float getMaxMoveSpeed()
	{
		return fastestSpeed;
	}

	public Transform getTarget()
	{
		return target;
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
		if (jawsAnimator != null && Random.Range(1, 4) == 3)
		{
			jawsAnimator.setBiting(val: true);
		}
	}
}
public class ManateeNeck : MonoBehaviour
{
	public Manatee mainScript;

	public Transform neckBone;

	private Quaternion rotation;

	public float maxHorizontalOffset = 20f;

	public float maxVerticalOffset = 20f;

	public float maxDiagonalOffset = 20f;

	public int neckMoveChance = 120;

	private Vector3 offset;

	private Quaternion neckBaseRotation;

	private Quaternion targetRotation;

	public AnimationCurve lerpCurve;

	private float perc;

	private float timer;

	public Vector2 targetLerpRange = new Vector2(0.5f, 1f);

	public Vector2 neckLerpRange = new Vector2(0.5f, 1f);

	private float neckLerpSpeed;

	private float targetLerpSpeed;

	private Quaternion smoothTargetRotation;

	private void Start()
	{
		mainScript = GetComponent<Manatee>();
		neckBaseRotation = neckBone.localRotation;
		targetRotation = neckBone.localRotation;
		smoothTargetRotation = neckBone.localRotation;
		perc = 1f;
		timer = 0.01f;
	}

	private void Update()
	{
		if (Random.Range(0, neckMoveChance) == 1)
		{
			offset = new Vector3(Random.Range(0f - maxHorizontalOffset, maxHorizontalOffset), Random.Range(0f - maxVerticalOffset, maxVerticalOffset), Random.Range(0f - maxDiagonalOffset, maxDiagonalOffset));
			targetRotation = neckBaseRotation * Quaternion.Euler(offset.x, offset.y, offset.z * 0.4f);
			neckLerpSpeed = Random.Range(neckLerpRange.x, neckLerpRange.y);
			targetLerpSpeed = Random.Range(targetLerpRange.x, targetLerpRange.y);
		}
		smoothTargetRotation = Quaternion.Slerp(smoothTargetRotation, targetRotation, targetLerpSpeed * Time.deltaTime);
		neckBone.localRotation = Quaternion.Slerp(neckBone.localRotation, smoothTargetRotation, neckLerpSpeed * Time.deltaTime);
	}
}
public class Marlin : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed = 1f;

	public float fastestTurnSpeed = 3f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public float swimFrequencyDeteriationRate = 0.997f;

	public float flexingDeteriationRate = 0.997f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	public Transform staticBone;

	private Vector3 staticAxis;

	public float[] tailWeights;

	private GameObject[] whales;

	private void Start()
	{
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
		whales = GameObject.FindGameObjectsWithTag("Whale");
		StartCoroutine(CheckForWhales());
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		targetSpeed = Random.Range(fastestSpeed, fastestSpeed);
		swimAmplitudeX = swimAmplitudeMaxX;
		float num = (fastestSpeed - defaultSpeed) / (fastestSpeed - defaultSpeed);
		targetSwimFrequencyX = num * swimFreqRangeX.y;
		turnSpeed = num * fastestTurnSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	private IEnumerator CheckForWhales()
	{
		while (true)
		{
			GameObject[] array = whales;
			foreach (GameObject gameObject in array)
			{
				Vector3 vector = gameObject.transform.position - head.transform.position;
				if (vector.magnitude < 9f)
				{
					Vector3 position = head.position + -vector.normalized * 10f;
					position.y = head.position.y;
					target.position = position;
				}
			}
			yield return new WaitForSeconds(0.5f);
		}
	}

	private void Update()
	{
		if (targetSwimFrequencyX > swimFreqRangeX.x)
		{
			targetSwimFrequencyX *= swimFrequencyDeteriationRate;
		}
		if (turnSpeed > defaultTurnSpeed)
		{
			turnSpeed *= flexingDeteriationRate;
		}
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 0.1f, 0f);
			if ((targetPos - head.transform.position).magnitude < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
			if ((targetPos - head.transform.position).magnitude < 1f)
			{
				playerIsTarget = false;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((targetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			targetPos = target.position;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleZ);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, localRotation.eulerAngles.z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j >= 0)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimXTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class Mosasaur : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float attackingSpeed = 5f;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed;

	public float minDistance = 1.1f;

	public float repulseForce = 0.55f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	public float playerTurnSpeed = 1f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float playerRotateToTargetSpeed = 2f;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private FoodSources foodSources;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public Transform staticBone;

	private Vector3 staticAxis;

	private float reverseTimer;

	public float targetChangeDistance = 5f;

	public float targetLerpRate = 0.1f;

	public AdvancedJawsAnimator jawsAnimator;

	public BoxCollider hostileZone;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		foodSources = GameObject.Find("_Helper Scripts").GetComponent<FoodSources>();
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		eatThings = GetComponent<EatThings>();
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
		hostileZone = target.GetComponent<MovingTarget>().movementZone;
	}

	private void FixedUpdate()
	{
		if (!foodIsTarget && Random.Range(0, hungryness) == 1)
		{
			setFoodTarget(foodSources.getRandom());
		}
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag("Info Sphere");
			bool flag = true;
			GameObject[] array2 = array;
			foreach (GameObject gameObject in array2)
			{
				InfoSphere component = gameObject.GetComponent<InfoSphere>();
				if (component.isSwitchedOn())
				{
					flag = false;
				}
			}
			if (flag)
			{
				playerIsTarget = true;
			}
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
		if (hostileZone != null)
		{
			if (hostileZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = true;
			}
			else
			{
				jawsAnimator.hostile = false;
				playerIsTarget = false;
			}
		}
		if (playerIsTarget)
		{
			targetSpeed = attackingSpeed;
		}
	}

	public void RandomiseParameters()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyZ = Random.Range(swimFreqRangeZ.x, swimFreqRangeZ.y);
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	private void Update()
	{
		float magnitude = (target.position - head.transform.position).magnitude;
		if (magnitude < targetChangeDistance)
		{
			target.GetComponent<MovingTarget>().change();
		}
		float magnitude2 = (player.transform.position + new Vector3(0f, 0f, 0f) - head.transform.position).magnitude;
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (foodIsTarget)
		{
			turnSpeed = attackingTurnSpeed;
		}
		else
		{
			turnSpeed = defaultTurnSpeed;
		}
		if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
			}
		}
		else if (playerIsTarget)
		{
			turnSpeed = playerTurnSpeed;
			rotateToTargetSpeed = playerRotateToTargetSpeed;
			targetPos = player.transform.position + new Vector3(0f, 0.25f, 0f);
			if (magnitude2 < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, targetLerpRate * Time.deltaTime);
			turnSpeed = defaultTurnSpeed;
			rotateToTargetSpeed = defaultRotateToTargetSpeed;
		}
		if (magnitude2 < minDistance)
		{
			Vector3 normalized = (head.transform.position - player.transform.position).normalized;
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			if (Random.Range(0, 100) == 1)
			{
				turnSpeed = 0.5f;
			}
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleZ);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		if (!doBarrelRoll)
		{
			rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		}
		else
		{
			rot = head.transform.rotation;
		}
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			Quaternion quaternion = ((i <= 0) ? localRotation : bones[i - 1].localRotation);
			float z = localRotation.eulerAngles.z;
			float num = Mathf.DeltaAngle(quaternion.eulerAngles.z, localRotation.eulerAngles.z);
			if (i > 1 && num > 150f)
			{
				z = 0f;
			}
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class PerlinNoiseFlippers : MonoBehaviour
{
	public Transform leftFin;

	public Transform rightFin;

	private Quaternion leftFlipperDefaultRotation;

	private Quaternion rightFlipperDefaultRotation;

	public Vector3 flipperAmplitudes = new Vector3(0f, 0f, 0f);

	public float frequency = 1f;

	private float timer;

	private void Start()
	{
		leftFlipperDefaultRotation = leftFin.localRotation;
		rightFlipperDefaultRotation = rightFin.localRotation;
	}

	private void Update()
	{
		float num = 1f;
		Vector3 vector = new Vector3((-0.5f + Mathf.PerlinNoise(0f, timer * num)) * (0f - flipperAmplitudes.x), (-0.5f + Mathf.PerlinNoise(0f, timer + 2f * num)) * (0f - flipperAmplitudes.y), (-0.5f + Mathf.PerlinNoise(0f, timer + 3f * num)) * flipperAmplitudes.z);
		num = 2f;
		Vector3 vector2 = new Vector3((-0.5f + Mathf.PerlinNoise(0f, timer * num + 2f)) * (0f - flipperAmplitudes.x), (-0.5f + Mathf.PerlinNoise(0f, timer + 2f * num)) * (0f - flipperAmplitudes.y), (-0.5f + Mathf.PerlinNoise(0f, timer + 3f * num)) * flipperAmplitudes.z);
		Quaternion b = leftFlipperDefaultRotation * Quaternion.Euler(vector * 1f);
		Quaternion b2 = rightFlipperDefaultRotation * Quaternion.Euler(vector2 * 1f);
		leftFin.localRotation = Quaternion.Lerp(leftFin.localRotation, b, Time.deltaTime * 5f);
		rightFin.localRotation = Quaternion.Lerp(rightFin.localRotation, b2, Time.deltaTime * 5f);
		timer += Time.deltaTime * Mathf.PerlinNoise(0f, timer) * frequency;
	}
}
public class PerlinNoiseNeck : MonoBehaviour
{
	public Transform neck;

	private Quaternion neckDefaultRotation;

	public Vector3 amplitudes = new Vector3(10f, 10f, 10f);

	public AnimationCurve mouthActivityCurve;

	private float mouthActivityTimer;

	public float mouthActivityRate = 1f;

	public Vector3 axis = new Vector3(0f, 0f, 1f);

	private float timer;

	private void Start()
	{
		neckDefaultRotation = neck.localRotation;
	}

	private void Update()
	{
		float num = 1f;
		float num2 = mouthActivityCurve.Evaluate(mouthActivityTimer);
		Vector3 vector = new Vector3(Mathf.PerlinNoise(0f, timer * num) * amplitudes.x * num2, Mathf.PerlinNoise(0f, (timer + 2f) * num) * amplitudes.y * num2, Mathf.PerlinNoise(0f, (timer + 4f) * num) * amplitudes.z * num2);
		Quaternion b = neckDefaultRotation * Quaternion.Euler(vector * 1f);
		neck.localRotation = Quaternion.Lerp(neck.localRotation, b, Time.deltaTime * 5f);
		timer += Time.deltaTime * Mathf.PerlinNoise(0f, timer) * 1.5f;
		mouthActivityTimer += Time.deltaTime * mouthActivityRate;
	}
}
public class PerlinNoiseNeck2 : MonoBehaviour
{
	public Transform neck;

	private Quaternion neckDefaultRotation;

	public Vector3 amplitudes = new Vector3(10f, 10f, 10f);

	public AnimationCurve mouthActivityCurve;

	public float frequency = 0.2f;

	public Vector3 neckOffset;

	private float timer;

	private void Start()
	{
		neckDefaultRotation = neck.localRotation * Quaternion.Euler(neckOffset);
	}

	private void Update()
	{
		float num = 1f;
		Vector3 euler = new Vector3((-0.5f + Mathf.PerlinNoise(0f, timer * num)) * amplitudes.z, (-0.5f + Mathf.PerlinNoise(0f, timer + 2f) * num) * amplitudes.x, (-0.5f + Mathf.PerlinNoise(0f, timer + 4f) * num) * amplitudes.y);
		Quaternion b = neckDefaultRotation * Quaternion.Euler(euler);
		neck.localRotation = Quaternion.Lerp(neck.localRotation, b, Time.deltaTime * 5f);
		timer += Time.deltaTime * frequency * Mathf.PerlinNoise(timer, 0f);
	}
}
public class PlayerPushback : MonoBehaviour
{
	public float howLong = 10f;

	public float force = 1f;

	private float timer;

	private Vector3 vectorToPlayer;

	private void Start()
	{
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject.tag == "Player")
		{
			timer = howLong;
			vectorToPlayer = (collision.contacts[0].point - base.transform.position).normalized;
			vectorToPlayer.y = 0f;
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.gameObject.tag == "Player")
		{
			timer = howLong;
			vectorToPlayer = (other.gameObject.transform.position - base.transform.position).normalized;
			vectorToPlayer.y = 0f;
		}
	}

	private void Update()
	{
		if (timer > 0f)
		{
			GetComponent<Rigidbody>().AddForce(-vectorToPlayer * force, ForceMode.Impulse);
			timer -= Time.deltaTime;
		}
	}
}
public class Plesiosaur : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed;

	public float minDistance = 1.1f;

	public float repulseForce = 0.55f;

	public float repulseTime = 1f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	public float playerTurnSpeed = 1f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float playerRotateToTargetSpeed = 2f;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private FoodSources foodSources;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public Transform staticBone;

	private Vector3 staticAxis;

	private float reverseTimer;

	public Vector3 testAxis = new Vector3(0f, 90f, 0f);

	public FlipperFlapper flipperFlapper;

	public float targetLerpRate = 3f;

	private float repulseTimer;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		foodSources = GameObject.Find("_Helper Scripts").GetComponent<FoodSources>();
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		eatThings = GetComponent<EatThings>();
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		flipperFlapper = GetComponent<FlipperFlapper>();
		RandomiseParameters();
	}

	private void FixedUpdate()
	{
		if (!foodIsTarget && Random.Range(0, hungryness) == 1)
		{
			setFoodTarget(foodSources.getRandom());
		}
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
			flipperFlapper.Stroke();
		}
	}

	public void RandomiseParameters()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyZ = Random.Range(swimFreqRangeZ.x, swimFreqRangeZ.y);
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	private void Update()
	{
		float magnitude = (player.transform.position + new Vector3(0f, 0f, 0f) - head.transform.position).magnitude;
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (foodIsTarget)
		{
			turnSpeed = attackingTurnSpeed;
		}
		else
		{
			turnSpeed = defaultTurnSpeed;
		}
		if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = Vector3.Lerp(targetPos, food.transform.position, Time.deltaTime * targetLerpRate);
			}
		}
		else if (playerIsTarget)
		{
			turnSpeed = playerTurnSpeed;
			rotateToTargetSpeed = playerRotateToTargetSpeed;
			Vector3 b = player.transform.position + new Vector3(0f, -0.05f, 0f);
			targetPos = Vector3.Lerp(targetPos, b, Time.deltaTime * targetLerpRate);
			if (magnitude < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, Time.deltaTime * targetLerpRate);
			turnSpeed = defaultTurnSpeed;
			rotateToTargetSpeed = defaultRotateToTargetSpeed;
		}
		Vector3 normalized = (head.transform.position - player.transform.position).normalized;
		if (magnitude < minDistance)
		{
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			if (Random.Range(0, 100) == 1)
			{
				turnSpeed = 0.5f;
			}
			repulseTimer = repulseTime;
		}
		if (repulseTimer > 0f)
		{
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			repulseTimer -= Time.deltaTime;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		if (doBarrelRoll)
		{
			float num = 0.01f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		if (!doBarrelRoll)
		{
			rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		}
		else
		{
			rot = head.transform.rotation;
		}
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis) * Quaternion.Euler(testAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			Quaternion quaternion = ((i <= 0) ? localRotation : bones[i - 1].localRotation);
			float z = localRotation.eulerAngles.z;
			float num = Mathf.DeltaAngle(quaternion.eulerAngles.z, localRotation.eulerAngles.z);
			if (i > 1 && num > 150f)
			{
				z = 0f;
			}
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class Pliosaur : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public Transform staticBone;

	private Vector3 staticAxis;

	public float targetPosLerp = 1f;

	private void Start()
	{
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		eatThings = GetComponent<EatThings>();
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		if (eatThings.getCurrentFood() != null)
		{
			setFoodTarget(eatThings.getCurrentFood());
		}
		targetSpeed = Random.Range(defaultSpeed, fastestSpeed);
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyZ = Random.Range(swimFreqRangeZ.x, swimFreqRangeZ.y);
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	private void Update()
	{
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 0.1f, 0f);
			if ((targetPos - head.transform.position).magnitude < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
			if ((targetPos - head.transform.position).magnitude < 1f)
			{
				playerIsTarget = false;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((targetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, Time.deltaTime * targetPosLerp);
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleZ);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, localRotation.eulerAngles.z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	public float getMoveSpeed()
	{
		return moveSpeed;
	}

	public float getMinMoveSpeed()
	{
		return defaultSpeed;
	}

	public float getMaxMoveSpeed()
	{
		return fastestSpeed;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class PliosaurHead : MonoBehaviour
{
	public Transform neckBone1;

	public Transform neckBone2;

	private Quaternion rotation;

	public float maxHorizontalOffset = 20f;

	public float maxVerticalOffset = 20f;

	public float maxDiagonalOffset = 20f;

	public int neckMoveChance = 120;

	private Vector3 offset;

	private Quaternion neckBaseRotation1;

	private Quaternion targetRotation1;

	private Quaternion neckBaseRotation2;

	private Quaternion targetRotation2;

	public AnimationCurve lerpCurve;

	private float perc;

	private float timer;

	public Vector2 targetLerpRange = new Vector2(0.5f, 1f);

	public Vector2 neckLerpRange = new Vector2(0.5f, 1f);

	private float neckLerpSpeed;

	private float targetLerpSpeed;

	private Quaternion smoothTargetRotation1;

	private Quaternion smoothTargetRotation2;

	public float mouthOpenSize = 20f;

	private float mouthTargetAngle;

	public int mouthOpenChance = 120;

	public Vector2 mouthOpenTimeRange = new Vector2(0.5f, 1f);

	private float mouthOpenTimer;

	private void Start()
	{
		neckBaseRotation1 = neckBone1.localRotation;
		targetRotation1 = neckBone1.localRotation;
		smoothTargetRotation1 = neckBone1.localRotation;
		neckBaseRotation2 = neckBone2.localRotation;
		targetRotation2 = neckBone2.localRotation;
		smoothTargetRotation2 = neckBone2.localRotation;
		perc = 1f;
		timer = 0.01f;
	}

	private void Update()
	{
		if (Random.Range(0, mouthOpenChance) == 1)
		{
			mouthOpenTimer = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
		}
		if (Random.Range(0, neckMoveChance) == 1)
		{
			offset = new Vector3(Random.Range(0f - maxHorizontalOffset, maxHorizontalOffset), Random.Range(0f - maxVerticalOffset, maxVerticalOffset), Random.Range(0f - maxDiagonalOffset, maxDiagonalOffset));
			neckLerpSpeed = Random.Range(neckLerpRange.x, neckLerpRange.y);
			targetLerpSpeed = Random.Range(targetLerpRange.x, targetLerpRange.y);
		}
		targetRotation1 = neckBaseRotation1 * Quaternion.Euler(offset.x, offset.y, offset.z * 0.4f);
		targetRotation2 = neckBaseRotation2 * Quaternion.Euler(offset.x, offset.y, offset.z * 0.4f);
		if (mouthOpenTimer > 0f)
		{
			targetRotation1 *= Quaternion.Euler(0f, 0f, 0f - mouthOpenSize);
			targetRotation2 *= Quaternion.Euler(0f, 0f, mouthOpenSize);
		}
		smoothTargetRotation1 = Quaternion.Slerp(smoothTargetRotation1, targetRotation1, targetLerpSpeed * Time.deltaTime);
		neckBone1.localRotation = Quaternion.Slerp(neckBone1.localRotation, smoothTargetRotation1, neckLerpSpeed * Time.deltaTime);
		smoothTargetRotation2 = Quaternion.Slerp(smoothTargetRotation2, targetRotation2, targetLerpSpeed * Time.deltaTime);
		neckBone2.localRotation = Quaternion.Slerp(neckBone2.localRotation, smoothTargetRotation2, neckLerpSpeed * Time.deltaTime);
		mouthOpenTimer -= Time.deltaTime;
	}
}
public class PushPlayer : MonoBehaviour
{
	private OVRSwimController playerController;

	private float pushForce;

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Player")
		{
			Vector3 normalized = (other.transform.position - base.transform.position).normalized;
			playerController.PushBack(normalized, pushForce);
			pushForce += 100f * Time.deltaTime;
		}
	}

	private void Update()
	{
		pushForce *= 0.95f;
	}

	private void Start()
	{
		playerController = GameObject.Find("Player(Clone)").GetComponent<OVRSwimController>();
	}
}
public class QuadFinsAnimator : MonoBehaviour
{
	public Transform frontLeftFin;

	public Transform frontRightFin;

	public Transform backLeftFin;

	public Transform backRightFin;

	public float finDefaultOffset = 20f;

	public float finAmplitude;

	public float finSpeed;

	private float finPhaseOffset;

	private Quaternion baseFrontLeftFinRotation;

	private Quaternion baseFrontRightFinRotation;

	private Quaternion baseBackLeftFinRotation;

	private Quaternion baseBackRightFinRotation;

	public float maxRotation = 70f;

	public float minRotation = -10f;

	public float frontBackPhaseOffset = 0.5f;

	private Quaternion frontFinHigh;

	private Quaternion frontFinLow;

	private float finTimer;

	private void Start()
	{
		baseFrontLeftFinRotation = frontLeftFin.localRotation;
		baseFrontRightFinRotation = frontRightFin.localRotation;
		if (backLeftFin != null)
		{
			baseBackLeftFinRotation = backLeftFin.localRotation;
			baseBackRightFinRotation = backRightFin.localRotation;
		}
		finPhaseOffset = (float)Math.PI;
	}

	private void Update()
	{
		float num = Mathf.Sin(finTimer * finSpeed) * finAmplitude + finDefaultOffset;
		float num2 = Mathf.Sin(finPhaseOffset + finTimer * finSpeed) * finAmplitude + finDefaultOffset;
		frontLeftFin.localRotation = baseFrontLeftFinRotation * Quaternion.Euler(0f, 0f, num);
		frontRightFin.localRotation = baseFrontRightFinRotation * Quaternion.Euler(0f, 0f, 0f - num);
		if (backLeftFin != null)
		{
			backLeftFin.localRotation = baseBackLeftFinRotation * Quaternion.Euler(0f, 0f, num2);
			backRightFin.localRotation = baseBackRightFinRotation * Quaternion.Euler(0f, 0f, 0f - num2);
		}
		finTimer += Time.deltaTime;
	}
}
public class RandomizeSize : MonoBehaviour
{
	public Vector2 sizeRange;

	public int monsterChance = 100;

	public float monsterSize = 1f;

	private void Start()
	{
		float num = Random.Range(sizeRange.x, sizeRange.y);
		if (Random.Range(0, monsterChance) == 1)
		{
			num = monsterSize;
		}
		base.transform.localScale = new Vector3(num, num, num);
	}

	private void Update()
	{
	}
}
public class ReefShark : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed = 1f;

	public float fastestTurnSpeed = 3f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public float swimFrequencyDeteriationRate = 0.997f;

	public float flexingDeteriationRate = 0.997f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	public Transform staticBone;

	private Vector3 staticAxis;

	public float[] tailWeights;

	private void Start()
	{
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		targetSpeed = Random.Range(fastestSpeed, fastestSpeed);
		swimAmplitudeX = swimAmplitudeMaxX;
		float num = (fastestSpeed - defaultSpeed) / (fastestSpeed - defaultSpeed);
		targetSwimFrequencyX = num * swimFreqRangeX.y;
		turnSpeed = num * fastestTurnSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
	}

	private void Update()
	{
		if (targetSwimFrequencyX > swimFreqRangeX.x)
		{
			targetSwimFrequencyX *= swimFrequencyDeteriationRate;
		}
		if (turnSpeed > defaultTurnSpeed)
		{
			turnSpeed *= flexingDeteriationRate;
		}
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 0.1f, 0f);
			if ((targetPos - head.transform.position).magnitude < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
			if ((targetPos - head.transform.position).magnitude < 1f)
			{
				playerIsTarget = false;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((targetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			targetPos = target.position;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleZ);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, localRotation.eulerAngles.z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j >= 0)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimXTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class SeaLion : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float nearPlayerDistance = 3f;

	public float nearPlayerSpeed = 0.4f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed;

	public float minDistance = 1.1f;

	public float repulseForce = 0.55f;

	public float repulseTime = 1f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	public float playerTurnSpeed = 1f;

	private Vector3 moveDirection;

	public Transform target;

	public float defaultRotateToTargetSpeed;

	public float playerRotateToTargetSpeed = 2f;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float targetSwimAmplitudeX;

	private float targetSwimAmplitudeY;

	private float targetSwimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private float targetRotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private FoodSources foodSources;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public Transform staticBone;

	private Vector3 staticAxis;

	private float reverseTimer;

	public Vector3 testAxis = new Vector3(0f, 90f, 0f);

	public FlipperFlapper flipperFlapper;

	public float targetLerpRate = 3f;

	private float repulseTimer;

	public float swimAmplitudeLerp = 1f;

	public float swimFrequencyLerp = 1f;

	public BoxCollider ringInterestZone;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		foodSources = GameObject.Find("_Helper Scripts").GetComponent<FoodSources>();
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		eatThings = GetComponent<EatThings>();
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetRotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		flipperFlapper = GetComponent<FlipperFlapper>();
		RandomiseParameters();
	}

	private void FixedUpdate()
	{
		if (!foodIsTarget && Random.Range(0, hungryness) == 1)
		{
			GameObject random = foodSources.getRandom();
			if (random != null && ringInterestZone.bounds.Contains(random.transform.position))
			{
				setFoodTarget(random);
			}
		}
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
			flipperFlapper.Stroke();
		}
	}

	public void RandomiseParameters()
	{
		float num = Random.Range(defaultSpeed, fastestSpeed);
		if (num > moveSpeed)
		{
			targetSpeed = num;
		}
		targetSwimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		targetSwimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		targetSwimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		targetSwimFrequencyZ = Random.Range(swimFreqRangeZ.x, swimFreqRangeZ.y);
		targetTailAmplitude = tailMaxAmplitude;
	}

	private void Update()
	{
		rotateToTargetSpeed = Mathf.Lerp(rotateToTargetSpeed, targetRotateToTargetSpeed, Time.deltaTime);
		float magnitude = (player.transform.position + new Vector3(0f, 0f, 0f) - head.transform.position).magnitude;
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (foodIsTarget)
		{
			turnSpeed = Mathf.Lerp(turnSpeed, attackingTurnSpeed, Time.deltaTime);
		}
		else
		{
			turnSpeed = Mathf.Lerp(turnSpeed, defaultTurnSpeed, Time.deltaTime);
		}
		if (foodIsTarget)
		{
			targetRotateToTargetSpeed = Mathf.Lerp(targetRotateToTargetSpeed, attackingRotateToTargetSpeed, Time.deltaTime);
			if (food == null)
			{
				foodIsTarget = false;
				targetPos = target.position;
			}
			else
			{
				targetPos = Vector3.Lerp(targetPos, food.transform.position, Time.deltaTime * targetLerpRate);
				if ((targetPos - head.transform.position).magnitude < 0.2f)
				{
					foodIsTarget = false;
					targetPos = target.position;
				}
			}
		}
		else if (playerIsTarget)
		{
			targetRotateToTargetSpeed = Mathf.Lerp(targetRotateToTargetSpeed, playerRotateToTargetSpeed, Time.deltaTime);
			turnSpeed = Mathf.Lerp(turnSpeed, playerTurnSpeed, Time.deltaTime);
			Vector3 b = player.transform.position + new Vector3(0f, -0.05f, 0f);
			targetPos = Vector3.Lerp(targetPos, b, Time.deltaTime * targetLerpRate);
			if (magnitude < nearPlayerDistance)
			{
				targetSpeed = nearPlayerSpeed;
			}
		}
		else
		{
			targetPos = Vector3.Lerp(targetPos, target.position, Time.deltaTime * targetLerpRate);
			turnSpeed = Mathf.Lerp(turnSpeed, defaultTurnSpeed, Time.deltaTime);
			targetRotateToTargetSpeed = Mathf.Lerp(targetRotateToTargetSpeed, defaultRotateToTargetSpeed, Time.deltaTime);
		}
		Vector3 normalized = (head.transform.position - player.transform.position).normalized;
		if (magnitude < minDistance)
		{
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			repulseTimer = repulseTime;
		}
		if (repulseTimer > 0f)
		{
			body.AddForce(normalized * repulseForce, ForceMode.Impulse);
			repulseTimer -= Time.deltaTime;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		swimAmplitudeX = Mathf.Lerp(swimAmplitudeX, targetSwimAmplitudeX, Time.deltaTime * swimAmplitudeLerp);
		swimAmplitudeY = Mathf.Lerp(swimAmplitudeY, targetSwimAmplitudeY, Time.deltaTime * swimAmplitudeLerp);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		if (doBarrelRoll)
		{
			float num = 0.01f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		if (!doBarrelRoll)
		{
			rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		}
		else
		{
			rot = head.transform.rotation;
		}
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = bones[0].rotation * Quaternion.Euler(staticAxis) * Quaternion.Euler(testAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			Quaternion quaternion = ((i <= 0) ? localRotation : bones[i - 1].localRotation);
			float z = localRotation.eulerAngles.z;
			float num = Mathf.DeltaAngle(quaternion.eulerAngles.z, localRotation.eulerAngles.z);
			if (i > 1 && num > 150f)
			{
				z = 0f;
			}
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
	}
}
public class SeaLionNeck : MonoBehaviour
{
	public Transform neckBone;

	public Transform parentBone;

	private Vector3 staticAxis;

	private Quaternion rotation;

	public Vector3 neckOffset = new Vector3(0f, 0f, 0f);

	public float maxHorizontalOffset = 20f;

	public float maxVerticalOffset = 20f;

	public float maxDiagonalOffset = 20f;

	private Vector3 offset;

	private Quaternion neckBaseRotation;

	private Quaternion targetRotation;

	public AnimationCurve lerpCurve;

	private float perc;

	private float timer;

	public Vector2 targetLerpRange = new Vector2(0.5f, 1f);

	public Vector2 neckLerpRange = new Vector2(0.5f, 1f);

	private float neckLerpSpeed;

	private float targetLerpSpeed;

	public float lookDirectionTime = 1f;

	public Vector3 parentAxis = new Vector3(0f, 0f, 180f);

	private Quaternion smoothTargetRotation;

	private void Start()
	{
		neckBaseRotation = neckBone.localRotation;
		targetRotation = neckBone.localRotation;
		smoothTargetRotation = neckBone.localRotation;
		perc = 1f;
		timer = 0.01f;
		staticAxis = new Vector3(0f - neckBone.localEulerAngles.x, 0f - neckBone.localEulerAngles.y, 0f - neckBone.localEulerAngles.z);
	}

	public void LateUpdate()
	{
		neckBaseRotation = parentBone.localRotation * Quaternion.Euler(parentAxis) * Quaternion.Euler(neckOffset);
		if (timer > lookDirectionTime)
		{
			offset = new Vector3(Random.Range(0f - maxHorizontalOffset, maxHorizontalOffset), Random.Range(0f - maxVerticalOffset, maxVerticalOffset), Random.Range(0f - maxDiagonalOffset, maxDiagonalOffset));
			targetRotation = neckBaseRotation * Quaternion.Euler(offset.x, offset.y, offset.z * 0.4f);
			neckLerpSpeed = Random.Range(neckLerpRange.x, neckLerpRange.y);
			targetLerpSpeed = Random.Range(targetLerpRange.x, targetLerpRange.y);
			timer = 0f;
		}
		smoothTargetRotation = Quaternion.Slerp(smoothTargetRotation, targetRotation, targetLerpSpeed * Time.deltaTime);
		neckBone.localRotation = Quaternion.Slerp(neckBone.localRotation, smoothTargetRotation, neckLerpSpeed * Time.deltaTime);
		timer += Time.deltaTime;
	}
}
public class SimpleMouth : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw;

	public float upperJawOpenSize = 5f;

	public float lowerJawOpenSize = 10f;

	public float openSpeed = 2f;

	public float closeSpeed = 15f;

	private Quaternion upperJawOpen;

	private Quaternion upperJawClosed;

	private Quaternion lowerJawOpen;

	private Quaternion lowerJawClosed;

	public int mouthOpenChance = 300;

	public Vector2 mouthOpenTimeRange = new Vector2(1f, 3f);

	private float openMouthTimer;

	public Vector3 axis;

	private void Start()
	{
		upperJawOpen = upperJaw.localRotation * Quaternion.Euler(axis * (0f - upperJawOpenSize));
		lowerJawOpen = lowerJaw.localRotation * Quaternion.Euler(axis * (0f - lowerJawOpenSize));
		upperJawClosed = upperJaw.localRotation;
		lowerJawClosed = lowerJaw.localRotation;
		openMouthTimer = 0f;
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, mouthOpenChance) == 1)
		{
			openMouthTimer = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
		}
		if (openMouthTimer > 0f)
		{
			upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawOpen, Time.deltaTime * closeSpeed);
			lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawOpen, Time.deltaTime * closeSpeed);
		}
		else
		{
			upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawClosed, Time.deltaTime * closeSpeed);
			lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawClosed, Time.deltaTime * closeSpeed);
		}
		openMouthTimer -= Time.deltaTime;
	}
}
public class SimpleNeckAnimator : MonoBehaviour
{
	public SeaTurtle mainScript;

	public Transform neckBone;

	public float lerpSpeed = 0.1f;

	private Quaternion rotation;

	public float offsetAmount;

	public int neckMoveChance = 120;

	public float maxNeckAngle = 80f;

	private Vector3 offset;

	private void Start()
	{
		mainScript = GetComponent<SeaTurtle>();
	}

	private void Update()
	{
		if (Random.Range(0, neckMoveChance) == 1)
		{
			offset = new Vector3(Random.Range(0f - offsetAmount, offsetAmount), Random.Range(0f - offsetAmount, offsetAmount), Random.Range(0f - offsetAmount, offsetAmount));
		}
		Quaternion a = neckBone.rotation;
		Vector3 forward = mainScript.theModel.forward;
		forward.Normalize();
		Vector3 vector = mainScript.target.transform.position + offset;
		Vector3 to = vector - neckBone.position;
		to.Normalize();
		float num = Vector3.Angle(forward, to);
		if (num < 70f)
		{
			neckBone.LookAt(vector);
			neckBone.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion b = neckBone.rotation;
			neckBone.rotation = Quaternion.Slerp(a, b, Time.deltaTime * lerpSpeed);
		}
	}
}
public class SmoothMouth : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw;

	public float upperJawOpenSize = 5f;

	public float lowerJawOpenSize = 10f;

	public float openSpeed = 2f;

	public float closeSpeed = 15f;

	private Quaternion upperJawOpen;

	private Quaternion upperJawClosed;

	private Quaternion lowerJawOpen;

	private Quaternion lowerJawClosed;

	public int mouthOpenChance = 300;

	public Vector2 mouthOpenTimeRange = new Vector2(1f, 3f);

	private float openMouthTimer;

	private float openMouthTime;

	public Vector3 axis;

	public AnimationCurve lerpCurve;

	private void Start()
	{
		upperJawOpen = upperJaw.localRotation * Quaternion.Euler(axis * (0f - upperJawOpenSize));
		lowerJawOpen = lowerJaw.localRotation * Quaternion.Euler(axis * (0f - lowerJawOpenSize));
		upperJawClosed = upperJaw.localRotation;
		lowerJawClosed = lowerJaw.localRotation;
		openMouthTimer = 0.01f;
		openMouthTime = 1f;
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, mouthOpenChance) == 1)
		{
			openMouthTime = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
			openMouthTimer = 0.01f;
		}
		float t = 0.01f + lerpCurve.Evaluate(openMouthTimer / openMouthTime);
		if (openMouthTimer < openMouthTime)
		{
			upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawOpen, t);
			lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawOpen, t);
		}
		else
		{
			upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawClosed, t);
			lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawClosed, t);
		}
		openMouthTimer += Time.deltaTime;
	}
}
public class SoftFlipper : MonoBehaviour
{
	private Transform[] joints;

	private Vector3[] defaultAngles;

	private Vector3 prevAngle;

	public bool useVelocity = true;

	public bool flip;

	public float multiplier = 0.1f;

	private float velocity;

	public Vector3 axis = new Vector3(0f, 0f, 1f);

	public void SetVelocity(float v)
	{
		velocity = v;
	}

	private void Start()
	{
		joints = GetComponentsInChildren<Transform>();
		defaultAngles = new Vector3[joints.Length];
		for (int i = 0; i < joints.Length; i++)
		{
			ref Vector3 reference = ref defaultAngles[i];
			reference = joints[i].localEulerAngles;
		}
		prevAngle = new Vector3(0f, 0f, 0f);
		if (flip)
		{
			multiplier *= -1f;
		}
	}

	private void Update()
	{
		for (int i = 1; i < joints.Length; i++)
		{
			Vector3 localEulerAngles = defaultAngles[i] + axis * multiplier * velocity;
			joints[i].localEulerAngles = localEulerAngles;
			velocity *= 0.97f;
		}
	}
}
public class SoftFlippers2 : MonoBehaviour
{
	private Transform[] joints;

	private Vector3[] defaultAngles;

	private Vector3 prevAngle;

	public float multiplier = 0.1f;

	public twinFlippers flipperSystem;

	private float prevTiming;

	public bool flip;

	private float sign = 1f;

	public float forwardDamper = 0.25f;

	private void Start()
	{
		joints = GetComponentsInChildren<Transform>();
		defaultAngles = new Vector3[joints.Length];
		for (int i = 0; i < joints.Length; i++)
		{
			ref Vector3 reference = ref defaultAngles[i];
			reference = joints[i].localEulerAngles;
		}
		prevTiming = 1f;
		if (flip)
		{
			sign *= -1f;
		}
	}

	private void Update()
	{
		float num = 1f;
		float strokeTime = flipperSystem.getStrokeTime();
		float num2 = (prevTiming - strokeTime) / Time.deltaTime;
		MonoBehaviour.print(num2);
		if (num2 > 0f)
		{
			for (int i = 1; i < joints.Length; i++)
			{
				MonoBehaviour.print("boob");
				Vector3 localEulerAngles = defaultAngles[i] + new Vector3(0f, 0f, 1f) * multiplier * sign * num2 * num;
				joints[i].localEulerAngles = localEulerAngles;
			}
		}
		prevTiming = strokeTime;
	}
}
public class SuperDynamicGreatWhiteShark : MonoBehaviour
{
	public bool physics;

	public bool playerIsTarget;

	public bool foodIsTarget;

	public AdvancedJawsAnimator jawsAnimator;

	public Transform head;

	public Rigidbody body;

	public GameObject articulatedFigure;

	public float defaultSpeed;

	public float fastestSpeed;

	public float attackingSpeed = 1.5f;

	public float cageAttackingSpeed = 1.5f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed = 1f;

	public float fastestTurnSpeed = 3f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	private Vector3 moveDirection;

	public Transform target;

	public BoxCollider safeZone;

	public BoxCollider hostileZone;

	public float defaultRotateToTargetSpeed;

	public float attackingPlayerRotateToTargetSpeed = 3f;

	public float attackingCageRotateToTargetSpeed = 2f;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public float swimAmplitudeDecay = 0.995f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public float swimFrequencyDeteriationRate = 0.997f;

	public float flexingDeteriationRate = 0.997f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	public Transform staticBone;

	private Vector3 staticAxis;

	private Rigidbody[] bodies;

	private PhysicsShark physicsShark;

	private void Start()
	{
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		jawsAnimator = GetComponent<AdvancedJawsAnimator>();
		physicsShark = GetComponent<PhysicsShark>();
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
		bodies = GetComponentsInChildren<Rigidbody>();
		setPhysics(val: false);
	}

	private void setPhysics(bool val)
	{
		physics = val;
		if (!val)
		{
			Rigidbody[] array = bodies;
			foreach (Rigidbody rigidbody in array)
			{
				if (rigidbody.name != "Leader")
				{
					rigidbody.useGravity = false;
					rigidbody.isKinematic = true;
					rigidbody.mass = 1f;
					rigidbody.transform.GetComponent<CapsuleCollider>().enabled = false;
				}
			}
		}
		else
		{
			Rigidbody[] array2 = bodies;
			foreach (Rigidbody rigidbody2 in array2)
			{
				if (rigidbody2.name != "Leader")
				{
					rigidbody2.useGravity = false;
					rigidbody2.isKinematic = false;
					rigidbody2.transform.GetComponent<CapsuleCollider>().enabled = true;
				}
			}
		}
		if ((bool)physicsShark)
		{
			if (physics)
			{
				physicsShark.enabled = true;
			}
			else
			{
				physicsShark.enabled = false;
			}
		}
		if (!articulatedFigure)
		{
			return;
		}
		if (val)
		{
			articulatedFigure.transform.parent = null;
			return;
		}
		for (int k = 0; k < bones.Length; k++)
		{
			targets[k].position = bones[k].position + bones[k].transform.rotation * -Vector3.right * 1f;
		}
		head.transform.position = bones[0].transform.position;
		head.transform.rotation = bones[0].transform.rotation * Quaternion.Euler(0f, 90f, 90f);
		articulatedFigure.transform.parent = head.transform;
		moveSpeed = 0f;
		RandomiseParameters();
	}

	private void FixedUpdate()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			setPhysics(!physics);
		}
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (safeZone != null)
		{
			if (safeZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = false;
			}
			else
			{
				jawsAnimator.hostile = true;
				playerIsTarget = true;
			}
		}
		if (hostileZone != null)
		{
			if (hostileZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = true;
			}
			else
			{
				jawsAnimator.hostile = false;
				playerIsTarget = false;
			}
		}
		if (!doBarrelRoll)
		{
			if (jawsAnimator.getBiting())
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
				swimAmplitudeX = 80f;
				swimAmplitudeY = 0f;
				targetSwimFrequencyX = 8f;
				targetSwimFrequencyY = 0f;
			}
			if (Random.Range(0, barrelRollChance) == 1)
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
				barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
			}
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		float num = targetSpeed;
		targetSpeed = Random.Range(defaultSpeed, fastestSpeed);
		swimAmplitudeX = swimAmplitudeMaxX;
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		float num2 = (fastestSpeed - defaultSpeed) / (fastestSpeed - defaultSpeed);
		targetSwimFrequencyX = num2 * swimFreqRangeX.y;
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		turnSpeed = num2 * fastestTurnSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		if (targetSpeed > num)
		{
			targetTailAmplitude = num2 * tailMaxAmplitude;
		}
	}

	private void Update()
	{
		if (targetSwimFrequencyX > swimFreqRangeX.x)
		{
			targetSwimFrequencyX *= swimFrequencyDeteriationRate;
		}
		if (turnSpeed > defaultTurnSpeed)
		{
			turnSpeed *= flexingDeteriationRate;
		}
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (playerIsTarget)
		{
			if (jawsAnimator.hostile)
			{
				targetSpeed = attackingSpeed;
			}
			else
			{
				targetSpeed = cageAttackingSpeed;
			}
			targetPos = player.transform.position + new Vector3(0f, 0.6f, 0f);
			if (jawsAnimator.hostile)
			{
				rotateToTargetSpeed = attackingPlayerRotateToTargetSpeed;
			}
			else
			{
				rotateToTargetSpeed = attackingCageRotateToTargetSpeed;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((targetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			targetPos = target.position;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		float magnitude = body.velocity.magnitude;
		body.AddForce(head.forward * targetSpeed * 3f, ForceMode.Impulse);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleZ);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		if (!physics)
		{
			head.transform.rotation = rot * swimComponent;
		}
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
		if (swimAmplitudeX > swimAmplitudeMinX)
		{
			swimAmplitudeX *= swimAmplitudeDecay;
		}
	}

	private void LateUpdate()
	{
		if (physics)
		{
			return;
		}
		if ((bool)staticBone)
		{
			staticBone.rotation = staticBone.parent.rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, localRotation.eulerAngles.z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j >= 0)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimXTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
	}
}
public class SuperGreatWhiteShark : MonoBehaviour
{
	public bool playerIsTarget;

	private bool prevPlayerIsTarget;

	public bool foodIsTarget;

	public AdvancedJawsAnimator jawsAnimator;

	public Transform head;

	public Rigidbody body;

	public GameObject articulatedFigure;

	public float defaultSpeed;

	public float fastestSpeed;

	public float attackingSpeed = 1.5f;

	public float cageAttackingSpeed = 1.5f;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed = 1f;

	public float fastestTurnSpeed = 3f;

	public float cageAttackTurnSpeed = 5f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	private Vector3 moveDirection;

	public Transform target;

	public BoxCollider safeZone;

	public BoxCollider hostileZone;

	public float defaultRotateToTargetSpeed;

	public float attackingPlayerRotateToTargetSpeed = 3f;

	public float attackingCageRotateToTargetSpeed = 2f;

	private float repulseTimer;

	private Vector3 repulseNormal;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public float swimAmplitudeDecay = 0.995f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public Vector2 swimFreqRangeZ = new Vector2(0f, 0f);

	public float swimFrequencyLerp = 1f;

	public float swimFrequencyDeteriationRate = 0.997f;

	public float flexingDeteriationRate = 0.997f;

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float angleZ;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float swimFrequencyZ;

	private float targetSwimFrequencyZ;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	private float swimZTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailAmplitudeDecay = 0.996f;

	public float tailAmplitudeLerp = 3f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	public Transform staticBone;

	private Vector3 staticAxis;

	private Rigidbody[] bodies;

	private float thrashingTimer;

	private bool bThrashing;

	public float repulsePower = 4f;

	private Vector3 lerpTargetPos;

	public float targetLerpSpeed = 0.5f;

	private void Start()
	{
		player = LAC_VRCameraRig.instance.getCenterCamera().gameObject;
		targetPos = target.position;
		lerpTargetPos = target.position;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		jawsAnimator = GetComponent<AdvancedJawsAnimator>();
		turnSpeed = defaultTurnSpeed;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		if ((bool)staticBone)
		{
			staticAxis = new Vector3(0f - staticBone.localEulerAngles.x, 0f - staticBone.localEulerAngles.y, 0f - staticBone.localEulerAngles.z);
		}
		RandomiseParameters();
		repulseTimer = 0f;
		thrashingTimer = 0f;
		bThrashing = false;
		if (hostileZone == null && safeZone == null)
		{
			hostileZone = target.GetComponent<MovingTarget>().movementZone;
		}
	}

	private void activateThrashing()
	{
		float num = Random.Range(3f, 10f);
		float num2 = Random.Range(50, 80);
		float num3 = Random.Range(2f, 4f);
		float num4 = Random.Range(-20, 20);
		turnSpeed = cageAttackTurnSpeed;
		thrashingTimer = Random.Range(1f, 4f);
		swimFrequencyX = num;
		targetSwimFrequencyX = num;
		num2 = num2;
		swimAmplitudeY = num4;
		targetSwimFrequencyY = num3;
		targetTailAmplitude = 0.5f * tailMaxAmplitude;
		bThrashing = true;
	}

	private void FixedUpdate()
	{
		if (bThrashing && thrashingTimer < 0f)
		{
			RandomiseParameters();
			bThrashing = false;
		}
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag("Info Sphere");
			bool flag = true;
			GameObject[] array2 = array;
			foreach (GameObject gameObject in array2)
			{
				InfoSphere component = gameObject.GetComponent<InfoSphere>();
				if (component.isSwitchedOn())
				{
					flag = false;
				}
			}
			if (flag)
			{
				playerIsTarget = true;
				targetTailAmplitude = tailMaxAmplitude;
				turnSpeed = fastestTurnSpeed;
			}
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (safeZone != null)
		{
			if (safeZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = false;
			}
			else
			{
				jawsAnimator.hostile = true;
				playerIsTarget = true;
			}
		}
		if (hostileZone != null)
		{
			if (hostileZone.bounds.Contains(player.transform.position))
			{
				jawsAnimator.hostile = true;
			}
			else
			{
				jawsAnimator.hostile = false;
				playerIsTarget = false;
			}
		}
		if (!doBarrelRoll)
		{
			if (jawsAnimator.getBiting())
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
				swimAmplitudeX = 20f;
				swimAmplitudeY = 0f;
				targetSwimFrequencyX = 8f;
				targetSwimFrequencyY = 0f;
				barrelRollSpeed = barrelRollSpeedRange.x;
			}
			if (Random.Range(0, barrelRollChance) == 1)
			{
				doBarrelRoll = true;
				barrelRollAngle = 0f;
				barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
			}
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
		repulseNormal = (head.transform.position - player.transform.position).normalized;
		if (repulseTimer > 0f)
		{
			head.GetComponent<Rigidbody>().AddForce(repulseNormal * repulsePower, ForceMode.Impulse);
		}
	}

	public void setBarrelRolling(bool val)
	{
		doBarrelRoll = val;
	}

	public void RandomiseParameters()
	{
		float num = targetSpeed;
		targetSpeed = Random.Range(defaultSpeed, fastestSpeed);
		swimAmplitudeX = swimAmplitudeMaxX;
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		float num2 = (fastestSpeed - defaultSpeed) / (fastestSpeed - defaultSpeed);
		targetSwimFrequencyX = swimFreqRangeX.y;
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		turnSpeed = num2 * fastestTurnSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		if (targetSpeed > moveSpeed)
		{
			targetTailAmplitude = num2 * tailMaxAmplitude;
		}
		turnSpeed = num2 * fastestTurnSpeed;
	}

	private void Update()
	{
		if (!bThrashing && targetSwimFrequencyX > swimFreqRangeX.x)
		{
			targetSwimFrequencyX *= swimFrequencyDeteriationRate;
		}
		if (!bThrashing && turnSpeed > defaultTurnSpeed)
		{
			turnSpeed *= flexingDeteriationRate;
		}
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (playerIsTarget)
		{
			if (jawsAnimator.hostile)
			{
				targetSpeed = attackingSpeed;
				turnSpeed = attackingTurnSpeed;
			}
			else
			{
				targetSpeed = cageAttackingSpeed;
			}
			lerpTargetPos = player.transform.position + new Vector3(0f, 0f, 0f);
			targetPos = player.transform.position + new Vector3(0f, 0f, 0f);
			if (jawsAnimator.hostile)
			{
				rotateToTargetSpeed = attackingPlayerRotateToTargetSpeed;
			}
			else
			{
				rotateToTargetSpeed = attackingCageRotateToTargetSpeed;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				lerpTargetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((lerpTargetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			lerpTargetPos = target.position;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 2f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		angleZ = swimCurve.Evaluate(swimZTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleZ);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		targetPos = Vector3.Lerp(targetPos, lerpTargetPos, Time.deltaTime * targetLerpSpeed);
		targetDir = targetPos - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		head.transform.rotation = rot * swimComponent;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * swimFrequencyLerp);
		swimFrequencyZ = Mathf.Lerp(swimFrequencyZ, targetSwimFrequencyZ, Time.deltaTime * swimFrequencyLerp);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		swimZTimer += Time.deltaTime * (swimFrequencyZ / 7f);
		if (swimAmplitudeX > swimAmplitudeMinX)
		{
			swimAmplitudeX *= swimAmplitudeDecay;
		}
		repulseTimer -= Time.deltaTime;
		thrashingTimer -= Time.deltaTime;
	}

	private void LateUpdate()
	{
		if ((bool)staticBone)
		{
			staticBone.rotation = staticBone.parent.rotation * Quaternion.Euler(staticAxis);
		}
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, localRotation.eulerAngles.z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeDecay;
		if (targetTailAmplitude < tailRestAmplitude)
		{
			targetTailAmplitude = tailRestAmplitude;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j >= 0)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimXTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		repulseNormal = normal;
		int num = Random.Range(0, 10);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		if (Random.Range(0, 3) == 1)
		{
			playerIsTarget = false;
		}
		target.GetComponent<MovingTarget>().setTimer(0f);
		repulseTimer = 0.7f;
		activateThrashing();
		if (Random.Range(0, 3) == 1)
		{
			targetSpeed = 0.8f;
		}
	}
}
public class TwoFinsAnimator : MonoBehaviour
{
	public Transform frontLeftFin;

	public Transform frontRightFin;

	public float finAmplitude;

	public float finSpeed;

	private Quaternion baseFrontLeftFinRotation;

	private Quaternion baseFrontRightFinRotation;

	public float maxRotation = 70f;

	public float minRotation = -10f;

	private Quaternion frontFinHigh;

	private Quaternion frontFinLow;

	private float finTimer;

	private void Start()
	{
		baseFrontLeftFinRotation = frontLeftFin.localRotation;
		baseFrontRightFinRotation = frontRightFin.localRotation;
	}

	private void Update()
	{
		float z = Mathf.Sin(finTimer * finSpeed) * finAmplitude;
		float num = Mathf.Sin(finTimer * finSpeed) * finAmplitude;
		frontLeftFin.localRotation = baseFrontLeftFinRotation * Quaternion.Euler(0f, 0f, z);
		frontRightFin.localRotation = baseFrontRightFinRotation * Quaternion.Euler(0f, 0f, 0f - num);
		finTimer += Time.deltaTime;
	}
}
public class Vocalise : MonoBehaviour
{
	public AudioClip[] sounds;

	public float every;

	public float randomise;

	private float timer;

	public Vector2 pitchRange = new Vector2(1f, 1f);

	private void Start()
	{
		timer = float.PositiveInfinity;
	}

	private void Update()
	{
		if (timer > every)
		{
			GetComponent<AudioSource>().pitch = Random.Range(pitchRange.x, pitchRange.y);
			GetComponent<AudioSource>().PlayOneShot(sounds[Random.Range(0, sounds.Length)]);
			timer = 0f;
			timer += Random.Range(0f - randomise, randomise);
		}
		timer += Time.deltaTime;
	}
}
public class VocaliseMultiple : MonoBehaviour
{
	public AudioClip[] sounds;

	public float every;

	public float randomise;

	public Vector2 callSizeRange = new Vector2(3f, 5f);

	public float delayBetweenCalls = 1f;

	private float timer;

	private int callCount;

	private float callTimer;

	public Vector2 pitchRange = new Vector2(0.8f, 1.2f);

	private void Start()
	{
		timer = Random.Range(0f, every);
	}

	private void Update()
	{
		if (timer > every)
		{
			callCount = Random.Range((int)callSizeRange.x, (int)callSizeRange.y);
		}
		if (callCount > 0 && callTimer < 0f)
		{
			GetComponent<AudioSource>().pitch = Random.Range(pitchRange.x, pitchRange.y);
			GetComponent<AudioSource>().PlayOneShot(sounds[Random.Range(0, sounds.Length)]);
			timer = 0f;
			timer += Random.Range(0f - randomise, randomise);
			callCount--;
			callTimer = delayBetweenCalls;
		}
		callTimer -= Time.deltaTime;
		timer += Time.deltaTime;
	}
}
public class WaterSurfaceInteraction : MonoBehaviour
{
	public Rigidbody body;

	private Transform waterSurface;

	public ParticleSystem waterStreamParticleSystem;

	public ParticleSystem waterSplashParticleSystem;

	public ParticleSystem dolphinBubblesParticleSystem;

	public float streamTime = 1f;

	public float surfaceoffset = 0.5f;

	public AudioSource audioSource;

	public AudioClip splashSound;

	private float streamTimer;

	private void Start()
	{
		waterStreamParticleSystem.enableEmission = false;
		waterSplashParticleSystem.enableEmission = false;
		dolphinBubblesParticleSystem.enableEmission = false;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		streamTimer = -1f;
	}

	private void Update()
	{
		if ((bool)body && (bool)waterSurface)
		{
			if (body.position.y > waterSurface.position.y - surfaceoffset)
			{
				if (streamTimer < 0f)
				{
					audioSource.PlayOneShot(splashSound, 0.8f);
				}
				streamTimer = streamTime;
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (streamTimer > 0f)
		{
			waterStreamParticleSystem.enableEmission = true;
			waterSplashParticleSystem.enableEmission = true;
			dolphinBubblesParticleSystem.enableEmission = true;
		}
		else
		{
			waterStreamParticleSystem.enableEmission = false;
			waterSplashParticleSystem.enableEmission = false;
			dolphinBubblesParticleSystem.enableEmission = false;
		}
		streamTimer -= Time.deltaTime;
	}
}
[AddComponentMenu("Camera-Control/Smooth Mouse Orbit - Unluck Software")]
public class SmoothCameraOrbit : MonoBehaviour
{
	public Transform target;

	public Vector3 targetOffset;

	public float distance = 5f;

	public float maxDistance = 20f;

	public float minDistance = 0.6f;

	public float xSpeed = 200f;

	public float ySpeed = 200f;

	public int yMinLimit = -80;

	public int yMaxLimit = 80;

	public int zoomRate = 40;

	public float panSpeed = 0.3f;

	public float zoomDampening = 5f;

	public float autoRotate = 1f;

	private float xDeg;

	private float yDeg;

	private float currentDistance;

	private float desiredDistance;

	private Quaternion currentRotation;

	private Quaternion desiredRotation;

	private Quaternion rotation;

	private Vector3 position;

	private float idleTimer;

	private float idleSmooth;

	private void Start()
	{
		Init();
	}

	private void OnEnable()
	{
		Init();
	}

	public void Init()
	{
		if (!target)
		{
			GameObject gameObject = new GameObject("Cam Target");
			gameObject.transform.position = base.transform.position + base.transform.forward * distance;
			target = gameObject.transform;
		}
		currentDistance = distance;
		desiredDistance = distance;
		position = base.transform.position;
		rotation = base.transform.rotation;
		currentRotation = base.transform.rotation;
		desiredRotation = base.transform.rotation;
		xDeg = Vector3.Angle(Vector3.right, base.transform.right);
		yDeg = Vector3.Angle(Vector3.up, base.transform.up);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
	}

	private void LateUpdate()
	{
		if (Input.GetMouseButton(2) && Input.GetKey(KeyCode.LeftAlt) && Input.GetKey(KeyCode.LeftControl))
		{
			desiredDistance -= Input.GetAxis("Mouse Y") * Time.deltaTime * (float)zoomRate * 0.125f * Mathf.Abs(desiredDistance);
		}
		else if (Input.GetMouseButton(0))
		{
			xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, Time.deltaTime * zoomDampening);
			base.transform.rotation = rotation;
			idleTimer = 0f;
			idleSmooth = 0f;
		}
		else
		{
			idleTimer += Time.deltaTime;
			if (idleTimer > autoRotate && autoRotate > 0f)
			{
				idleSmooth += (Time.deltaTime + idleSmooth) * 0.005f;
				idleSmooth = Mathf.Clamp(idleSmooth, 0f, 1f);
				xDeg += xSpeed * 0.001f * idleSmooth;
			}
			yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
			desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
			currentRotation = base.transform.rotation;
			rotation = Quaternion.Lerp(currentRotation, desiredRotation, Time.deltaTime * zoomDampening * 2f);
			base.transform.rotation = rotation;
		}
		desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * Time.deltaTime * (float)zoomRate * Mathf.Abs(desiredDistance);
		desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
		currentDistance = Mathf.Lerp(currentDistance, desiredDistance, Time.deltaTime * zoomDampening);
		position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
		base.transform.position = position;
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class AdvancedJawsAnimator : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw;

	public float openSize = 5f;

	public float biteSize = 30f;

	public float openSpeed = 2f;

	public float biteSpeed = 15f;

	public int mouthOpenChance = 300;

	public bool bitingCage;

	public Vector2 mouthOpenTimeRange = new Vector2(1f, 3f);

	public bool bBite;

	public GameObject biteParticleSystem;

	public GameObject bubblesParticleSystem;

	public float initialJawOffset = 4.5f;

	public bool randomBiting;

	private GameObject player;

	private float biteTimer;

	private Quaternion upperJawClosed;

	private Quaternion upperJawOpen;

	private Quaternion upperJawBiting;

	private Quaternion lowerJawClosed;

	private Quaternion lowerJawOpen;

	private Quaternion lowerJawBiting;

	private float openMouthTimer;

	public bool hostile;

	public bool eatsFood;

	private Quaternion upperJawTargetRotation;

	private Quaternion lowerJawTargetRotation;

	private float lerpSpeed = 1f;

	public PreyDetector preyDetector;

	public PreyDetector bitingDetector;

	private bool hasGeneratedBlood;

	public AudioClip biteSound;

	private float chompingTimer;

	private float chompingSpeed = 1f;

	private float mouthOscillator;

	public Vector3 jawAxis = new Vector3(0f, 0f, 1f);

	private bool prevBiting;

	public int randomOpenMouthChange;

	private void Start()
	{
		bitingCage = false;
		hasGeneratedBlood = false;
		lowerJawClosed = lowerJaw.localRotation * Quaternion.Euler(jawAxis * (0f - initialJawOffset));
		lowerJawOpen = lowerJawClosed * Quaternion.Euler(jawAxis * openSize);
		lowerJawBiting = lowerJawClosed * Quaternion.Euler(jawAxis * biteSize);
		upperJawClosed = upperJaw.localRotation * Quaternion.Euler(jawAxis * initialJawOffset);
		upperJawOpen = upperJawClosed * Quaternion.Euler(jawAxis * (0f - openSize));
		upperJawBiting = upperJawClosed * Quaternion.Euler(jawAxis * (0f - biteSize));
		openMouthTimer = 0f;
		player = GameObject.Find("Dummy Player");
	}

	public void setBiting(bool val)
	{
		bBite = val;
	}

	public bool getBiting()
	{
		return bBite;
	}

	private void updateAmbientMouth()
	{
		if (Random.Range(0, randomOpenMouthChange) == 1)
		{
			openMouthTimer = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
		}
		mouthOscillator = Mathf.Sin(chompingTimer * chompingSpeed);
		if (openMouthTimer > 0f)
		{
			if (mouthOscillator > 0f)
			{
				upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawOpen, Time.deltaTime * 5f);
				lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawOpen, Time.deltaTime * 5f);
			}
			else
			{
				upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawClosed, Time.deltaTime * 15f);
				lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawClosed, Time.deltaTime * 15f);
			}
		}
		else
		{
			upperJawTargetRotation = upperJawClosed;
			lowerJawTargetRotation = lowerJawClosed;
			lerpSpeed = 10f;
			bitingCage = false;
			chompingTimer = 0f;
		}
	}

	private void StruckSomething(Vector3 normal)
	{
		if (Random.Range(0, 2) == 1 && openMouthTimer < 0f)
		{
			bitingCage = true;
			openMouthTimer = Random.Range(0.5f, 0.7f);
			chompingSpeed = Random.Range(8, 17);
			UnityEngine.Object.Instantiate(bubblesParticleSystem, lowerJaw.position, lowerJaw.rotation);
		}
	}

	private void LateUpdate()
	{
		setBiting(val: false);
		updateAmbientMouth();
		if (hostile)
		{
			if (bitingDetector.isFoodInSight())
			{
				if (!hasGeneratedBlood)
				{
					hasGeneratedBlood = true;
					if (biteSound != null)
					{
						base.transform.Find("Leader").GetComponent<AudioSource>().PlayOneShot(biteSound);
					}
					if (biteParticleSystem != null)
					{
						UnityEngine.Object.Instantiate(biteParticleSystem, player.transform.position + player.transform.forward * 1f, Quaternion.identity);
					}
					StartCoroutine(ProcessPlayerDeath());
					player.transform.parent.GetComponent<OVRSwimController>().MoveThrottle = new Vector3(0f, 0f, 0.04f);
				}
				upperJawTargetRotation = upperJawClosed;
				lowerJawTargetRotation = lowerJawClosed;
				lerpSpeed = biteSpeed * 4f;
			}
			else if (preyDetector.isFoodInSight())
			{
				upperJawTargetRotation = upperJawBiting;
				lowerJawTargetRotation = lowerJawBiting;
				lerpSpeed = biteSpeed * 1f;
				setBiting(val: true);
			}
		}
		if (eatsFood)
		{
			if (bitingDetector.isFoodInSight())
			{
				upperJawTargetRotation = upperJawClosed;
				lowerJawTargetRotation = lowerJawClosed;
				lerpSpeed = biteSpeed * 4f;
				GameObject detectedObject = bitingDetector.getDetectedObject();
				if (detectedObject != null)
				{
					bitingDetector.destroyFood();
					setBiting(val: false);
				}
			}
			else if (preyDetector.isFoodInSight())
			{
				upperJawTargetRotation = upperJawBiting;
				lowerJawTargetRotation = lowerJawBiting;
				lerpSpeed = biteSpeed * 1f;
				setBiting(val: true);
				GameObject detectedObject2 = bitingDetector.getDetectedObject();
				if (detectedObject2 != null)
				{
					detectedObject2.transform.position = Vector3.Lerp(detectedObject2.transform.position, bitingDetector.transform.position, Time.deltaTime * 2f);
				}
			}
		}
		if (openMouthTimer <= 0f)
		{
			upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawTargetRotation, Time.deltaTime * lerpSpeed);
			lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawTargetRotation, Time.deltaTime * lerpSpeed);
		}
		openMouthTimer -= Time.deltaTime;
		chompingTimer += Time.deltaTime;
		if (prevBiting && !bBite)
		{
			AquaticCreature component = GetComponent<AquaticCreature>();
			if (component != null)
			{
				component.RandomiseParameters();
			}
		}
		prevBiting = bBite;
	}

	private IEnumerator ProcessPlayerDeath()
	{
		GameObject[] infoSpheres = GameObject.FindGameObjectsWithTag("Info Sphere");
		GameObject[] array = infoSpheres;
		foreach (GameObject gameObject in array)
		{
			gameObject.GetComponent<InfoSphere>().Silence();
		}
		GameObject helper = GameObject.Find("_Helper Scripts");
		LightDimmingScript dimScript = helper.GetComponent<LightDimmingScript>();
		if ((bool)dimScript)
		{
			dimScript.setActive(val: false);
		}
		RenderSettings.fogColor = Color.red * 0.1f;
		LAC_VRCameraRig.instance.setBackgroundColor(Color.red * 0.1f);
		RenderSettings.fogDensity = 1f;
		yield return new WaitForSeconds(0.1f);
		LAC_VRCameraRig.instance.setBackgroundColor(Color.black);
		RenderSettings.fogColor = Color.black;
		RenderSettings.fogDensity = 10000f;
		LAC_VRCameraRig.instance.Blackout();
		yield return new WaitForSeconds(1.5f);
		GameObject.Find("UI").GetComponent<TouchUI>().playerHasBeenEaten();
		base.transform.position = new Vector3(0f, 0f, 0f);
		yield return 0;
	}
}
public class CollisionDetector : MonoBehaviour
{
	public AudioClip[] audioClips;

	public GameObject collisionParticleSystem;

	public float collisionParticleTime;

	private float collisionParticleTimer;

	private float repeatTimer;

	private float repeatTime = 1f;

	private void Update()
	{
		collisionParticleTimer += Time.deltaTime;
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject.tag == "Shark Cage")
		{
			if (repeatTimer > repeatTime)
			{
				base.transform.parent.gameObject.SendMessage("StruckSomething", collision.contacts[0].normal);
				repeatTimer = 0f;
				spawnParticle(collision.contacts[0].point, Quaternion.Euler(collision.contacts[0].normal));
			}
			repeatTimer += Time.deltaTime;
		}
	}

	private void spawnParticle(Vector3 pos, Quaternion ori)
	{
		if (collisionParticleTimer > collisionParticleTime)
		{
			GetComponent<AudioSource>().pitch = Random.Range(0.75f, 1f);
			GetComponent<AudioSource>().PlayOneShot(audioClips[Random.Range(0, audioClips.Length)]);
			collisionParticleTimer = 0f;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.tag == "Shark Cage")
		{
			spawnParticle(collision.contacts[0].point, Quaternion.Euler(collision.contacts[0].normal));
			base.transform.parent.gameObject.SendMessage("StruckSomething", collision.contacts[0].normal);
			collision.gameObject.SendMessage("SharkHasHit", collision.contacts[0].normal);
		}
	}
}
public class FinNoise : MonoBehaviour
{
	public Transform leftFin;

	public Transform rightFin;

	private Quaternion leftFinMinRotation;

	private Quaternion leftFinMaxRotation;

	public float maxRotation = 20f;

	public float finSpeed = 1f;

	private float timer;

	private void Start()
	{
	}

	private void Update()
	{
		float num = Mathf.Sin(timer);
		leftFin.Rotate(new Vector3(0f, 1f, 0f) * num * 5f);
		rightFin.Rotate(new Vector3(0f, 1f, 0f) * num * 5f);
		timer += Time.deltaTime * 10f;
	}
}
public class FinsAnimator : MonoBehaviour
{
	public Transform leftFin;

	public Transform rightFin;

	private Quaternion leftFinMinRotation;

	private Quaternion leftFinMaxRotation;

	public float maxRotation = 20f;

	public float finSpeed = 1f;

	private LargeAquaticCreature sharkScript;

	private GreatWhiteShark sharkScript2;

	private void Start()
	{
		leftFinMinRotation = leftFin.localRotation * Quaternion.Euler(0f, maxRotation, 0f);
		sharkScript = GetComponent<LargeAquaticCreature>();
		if (sharkScript == null)
		{
			sharkScript2 = GetComponent<GreatWhiteShark>();
		}
	}

	private void Update()
	{
		float num = 0f;
		num = ((!(sharkScript != null)) ? sharkScript2.getHeadingAngle() : sharkScript.getHeadingAngle());
		float value = num / 90f;
		value = Mathf.Clamp(value, -1f, 1f);
		leftFin.localRotation = Quaternion.Slerp(leftFin.localRotation, Quaternion.Euler(0f, maxRotation * value, 0f), Time.deltaTime);
		rightFin.localRotation = Quaternion.Slerp(rightFin.localRotation, Quaternion.Euler(0f, maxRotation * (0f - value), 0f), Time.deltaTime * finSpeed);
	}
}
public class JawsAnimator : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw;

	public float openSize = 5f;

	public float biteSize = 30f;

	public float openSpeed = 2f;

	public float biteSpeed = 15f;

	public int mouthOpenChance = 300;

	public Vector2 mouthOpenTimeRange = new Vector2(1f, 3f);

	public bool bBite;

	public GameObject biteParticleSystem;

	public float initialJawOffset = 4.5f;

	public bool randomBiting;

	public GameObject player;

	private float biteTimer;

	private Quaternion upperJawClosed;

	private Quaternion upperJawOpen;

	private Quaternion upperJawBiting;

	private Quaternion lowerJawClosed;

	private Quaternion lowerJawOpen;

	private Quaternion lowerJawBiting;

	private float openMouthTimer;

	public bool friendly;

	private Quaternion upperJawTargetRotation;

	private Quaternion lowerJawTargetRotation;

	private float lerpSpeed = 1f;

	private void Start()
	{
		friendly = true;
		lowerJawClosed = lowerJaw.localRotation * Quaternion.Euler(0f, 0f, 0f - initialJawOffset);
		lowerJawOpen = lowerJawClosed * Quaternion.Euler(0f, 0f, openSize);
		lowerJawBiting = lowerJawClosed * Quaternion.Euler(0f, 0f, biteSize);
		upperJawClosed = upperJaw.localRotation * Quaternion.Euler(0f, 0f, initialJawOffset);
		upperJawOpen = upperJawClosed * Quaternion.Euler(0f, 0f, 0f - openSize);
		upperJawBiting = upperJawClosed * Quaternion.Euler(0f, 0f, 0f - biteSize);
		openMouthTimer = 0f;
		biteTimer = 0f;
		player = GameObject.Find("Dummy Player");
	}

	public void setBiting(bool val)
	{
		if (bBite != val)
		{
			biteTimer = Random.Range(0.2f, 0.4f);
		}
		bBite = val;
	}

	public bool getBiting()
	{
		return bBite;
	}

	private void Update()
	{
		if (randomBiting && Random.Range(0, 800) == 1)
		{
			setBiting(val: true);
		}
		float magnitude = (upperJaw.position - (player.transform.position + new Vector3(0f, 1f, 0f))).magnitude;
		if (bBite && !friendly)
		{
			if (upperJawTargetRotation != upperJawClosed)
			{
				UnityEngine.Object.Instantiate(biteParticleSystem, player.transform.position, Quaternion.identity);
				player.transform.parent.Find("UI").GetComponent<UI>().playerHasBeenEaten();
			}
			upperJawTargetRotation = upperJawClosed;
			lowerJawTargetRotation = lowerJawClosed;
			lerpSpeed = biteSpeed * 10f;
		}
		else if (magnitude < 1.1f && !friendly)
		{
			bBite = true;
			biteTimer = 0f;
			Vector3 vector = -(lowerJaw.position - player.transform.position).normalized;
			float num = 0.04f;
		}
		else if (magnitude < 2f && !friendly)
		{
			upperJawTargetRotation = upperJawBiting;
			lowerJawTargetRotation = lowerJawBiting;
			lerpSpeed = biteSpeed;
		}
		else
		{
			if (Random.Range(1, mouthOpenChance) == 1)
			{
				openMouthTimer = Random.Range(mouthOpenTimeRange.x, mouthOpenTimeRange.y);
			}
			if (openMouthTimer > 0f)
			{
				upperJawTargetRotation = upperJawOpen;
				lowerJawTargetRotation = lowerJawOpen;
				lerpSpeed = openSpeed;
			}
			else
			{
				upperJawTargetRotation = upperJawClosed;
				lowerJawTargetRotation = lowerJawClosed;
				lerpSpeed = openSpeed;
			}
		}
		if (biteTimer < -1f)
		{
			bBite = false;
		}
		upperJaw.localRotation = Quaternion.Slerp(upperJaw.localRotation, upperJawTargetRotation, Time.deltaTime * lerpSpeed);
		lowerJaw.localRotation = Quaternion.Slerp(lowerJaw.localRotation, lowerJawTargetRotation, Time.deltaTime * lerpSpeed);
		openMouthTimer -= Time.deltaTime;
		biteTimer -= Time.deltaTime;
	}
}
public class PhysicsShark : MonoBehaviour
{
	public ConfigurableJoint[] backboneJoints;

	public ConfigurableJoint upperJawJoint;

	public ConfigurableJoint lowerJawJoint;

	public Rigidbody headBody;

	public float frequency = 1f;

	public float amplitude = 45f;

	public float jawFrequency = 1f;

	public float jawAmplitude = 1f;

	public float phase;

	private float timer;

	public float stability = 0.3f;

	public float stableSpeed = 2f;

	private void Start()
	{
	}

	private void Update()
	{
		float num = 0f;
		Vector3 lhs = Quaternion.AngleAxis(headBody.angularVelocity.magnitude * 57.29578f * stability / stableSpeed, headBody.angularVelocity) * headBody.transform.right;
		Vector3 vector = Vector3.Cross(lhs, Vector3.right);
		vector = Vector3.Project(vector, base.transform.up);
		headBody.AddTorque(vector * stableSpeed * stableSpeed);
		int num2 = 0;
		ConfigurableJoint[] array = backboneJoints;
		foreach (ConfigurableJoint configurableJoint in array)
		{
			num = Mathf.Sin(timer * frequency + phase * (float)num2) * amplitude;
			configurableJoint.targetRotation = Quaternion.identity * Quaternion.Euler(0f, 0f, num);
			num2++;
		}
		num = Mathf.Sin(timer * jawFrequency) * jawAmplitude;
		timer += Time.deltaTime;
	}
}
public class PreyDetector : MonoBehaviour
{
	public bool detectPlayer = true;

	private bool foodInSight;

	private string foodTag;

	private GameObject food;

	public float chewTime = 0.5f;

	public float shrinkRate = 1f;

	private void Start()
	{
		foodInSight = false;
	}

	private void OnTriggerEnter(Collider other)
	{
		foodTag = other.tag;
		if (other.tag == "Food")
		{
			foodInSight = true;
			food = other.gameObject;
		}
		if (detectPlayer && other.tag == "Player")
		{
			foodInSight = true;
			food = other.gameObject;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == "Food")
		{
			foodInSight = false;
		}
		if (detectPlayer && other.tag == "Food")
		{
			foodInSight = false;
		}
		food = null;
		foodTag = null;
	}

	public void destroyFood()
	{
		Vector3 localScale = food.transform.root.transform.localScale;
		localScale *= shrinkRate;
		food.transform.root.transform.localScale = localScale;
		UnityEngine.Object.Destroy(food.transform.root.gameObject, chewTime);
	}

	public string getFoodTag()
	{
		return foodTag;
	}

	public GameObject getDetectedObject()
	{
		return food;
	}

	public bool isFoodInSight()
	{
		if (food == null)
		{
			foodInSight = false;
		}
		return foodInSight;
	}
}
public class HammerheadJawFix : MonoBehaviour
{
	public Transform jaw;

	public Transform newParent;

	private void Start()
	{
		jaw.parent = newParent;
	}
}
public class DoubleStareScript : MonoBehaviour
{
	public Vector2 microTickMinMax = new Vector2(0f, 0f);

	public float microMax = 0.01f;

	public float verticalBias = 2f;

	private float microTimer;

	private float microTime = float.PositiveInfinity;

	private Vector3 microOffset = new Vector3(0f, 0f, 0f);

	private Quaternion baseRotation;

	private Quaternion baseRotation2;

	public Transform otherEye;

	public Transform player;

	private void Start()
	{
		microTime = Random.Range(microTickMinMax.x, microTickMinMax.y);
		baseRotation = base.transform.localRotation;
		baseRotation2 = otherEye.localRotation;
		player = GameObject.Find("Dummy Player").transform;
	}

	private void Update()
	{
		float magnitude = (player.position - base.transform.position).magnitude;
		if (magnitude > 15f)
		{
			GetComponent<Renderer>().enabled = false;
			otherEye.GetComponent<Renderer>().enabled = false;
		}
		else
		{
			GetComponent<Renderer>().enabled = true;
			otherEye.GetComponent<Renderer>().enabled = true;
		}
		microTimer += Time.deltaTime;
		if (microTimer > microTime)
		{
			microOffset = new Vector3(Random.Range(0f - microMax, microMax), Random.Range(0f - microMax, microMax) * verticalBias, Random.Range(0f - microMax, microMax));
			microTimer = 0f;
			microTime = Random.Range(microTickMinMax.x, microTickMinMax.y);
			base.transform.localRotation = baseRotation * Quaternion.Euler(microOffset);
			otherEye.localRotation = baseRotation2 * Quaternion.Euler(-microOffset);
		}
	}
}
public class StareScript : MonoBehaviour
{
	public Vector2 microTickMinMax = new Vector2(0f, 0f);

	public float microMax = 0.01f;

	public float verticalBias = 2f;

	private float microTimer;

	private float microTime = float.PositiveInfinity;

	private Vector3 microOffset = new Vector3(0f, 0f, 0f);

	private Quaternion baseRotation;

	private void Start()
	{
		microTime = Random.Range(microTickMinMax.x, microTickMinMax.y);
		baseRotation = base.transform.localRotation;
	}

	private void Update()
	{
		microTimer += Time.deltaTime;
		if (microTimer > microTime)
		{
			microOffset = new Vector3(Random.Range(0f - microMax, microMax), Random.Range(0f - microMax, microMax) * verticalBias, Random.Range(0f - microMax, microMax));
			microTimer = 0f;
			microTime = Random.Range(microTickMinMax.x, microTickMinMax.y);
		}
		base.transform.localRotation = baseRotation * Quaternion.Euler(microOffset);
	}
}
public class ManateeChew : MonoBehaviour
{
	public SkinnedMeshRenderer renderer;

	public int morphTargetIndex = 1;

	public Vector2 chewTimeRange = new Vector2(0.2f, 0.5f);

	public int chewChance = 50;

	public float chewLerp = 1f;

	private float blinkBlendVal;

	private float blinkTimer;

	private void Start()
	{
	}

	private void Update()
	{
		if (Random.Range(0, chewChance) == 1)
		{
			blinkTimer = Random.Range(chewTimeRange.x, chewTimeRange.y);
		}
		if (blinkTimer > 0f)
		{
			blinkBlendVal = Mathf.Lerp(blinkBlendVal, 100f, Time.deltaTime * chewLerp);
		}
		else
		{
			blinkBlendVal = Mathf.Lerp(blinkBlendVal, 0f, Time.deltaTime * chewLerp);
		}
		renderer.SetBlendShapeWeight(morphTargetIndex, blinkBlendVal);
		blinkTimer -= Time.deltaTime;
	}
}
public class SlideShowAnimator : MonoBehaviour
{
	[Serializable]
	public struct Anims
	{
		public string triggerName;

		public float time;
	}

	public Anims[] animations;

	private int currentAnimIndex;

	private string lastTrigger;

	private Animator animator;

	private void Start()
	{
		animator = GetComponent<Animator>();
		StartCoroutine(AnimateStuff());
	}

	private IEnumerator AnimateStuff()
	{
		while (true)
		{
			animator.SetTrigger(animations[currentAnimIndex].triggerName);
			Debug.Log("Playing " + animations[currentAnimIndex].triggerName);
			yield return new WaitForSeconds(animations[currentAnimIndex].time);
			currentAnimIndex++;
			if (currentAnimIndex > animations.Length - 1)
			{
				currentAnimIndex = 0;
			}
		}
	}

	private void Update()
	{
	}
}
public class SlideShowController : MonoBehaviour
{
	private const float Native_Width = 1024f;

	private const float Native_Height = 768f;

	public Transform[] assets;

	public float slideSpeed = 5f;

	public float loopSlideSpeed = 10f;

	public GUIStyle slideButtonLeft;

	public GUIStyle slideButtonRight;

	public Texture2D motdLogo;

	private bool inTransition;

	private int currentIndex;

	private float actualSpeed;

	public int CurrentIndex
	{
		get
		{
			return currentIndex;
		}
		set
		{
			if (!inTransition)
			{
				if (value > assets.Length - 1)
				{
					currentIndex = 0;
					actualSpeed = loopSlideSpeed;
				}
				else if (value < 0)
				{
					currentIndex = assets.Length - 1;
					actualSpeed = loopSlideSpeed;
				}
				else
				{
					currentIndex = value;
					actualSpeed = slideSpeed;
				}
				StartCoroutine(UpdateSlide());
			}
		}
	}

	private void OnGUI()
	{
		float x = (float)Screen.width / 1024f;
		float y = (float)Screen.height / 768f;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		if (GUI.Button(new Rect(0f, 256f, 62f, 256f), string.Empty, slideButtonLeft) || Input.GetAxis("Horizontal") < 0f)
		{
			CurrentIndex--;
		}
		if (GUI.Button(new Rect(962f, 256f, 62f, 256f), string.Empty, slideButtonRight) || Input.GetAxis("Horizontal") > 0f)
		{
			CurrentIndex++;
		}
		GUI.Label(new Rect(10f, 10f, 200f, 200f), motdLogo);
	}

	private IEnumerator UpdateSlide()
	{
		if (assets[CurrentIndex] != null)
		{
			inTransition = true;
			yield return StartCoroutine(MoveToPosition(assets[CurrentIndex].position, actualSpeed));
			inTransition = false;
		}
	}

	private IEnumerator MoveToPosition(Vector3 targetPosition, float speed)
	{
		while (base.transform.position != targetPosition)
		{
			base.transform.position = Vector3.MoveTowards(base.transform.position, targetPosition, speed * Time.deltaTime);
			yield return 0;
		}
	}

	private void Start()
	{
		base.transform.position = assets[0].position;
	}

	private void Update()
	{
	}
}
public class TurnTable : MonoBehaviour
{
	public float speed;

	public Vector3 axis = new Vector3(0f, 1f, 0f);

	private void Update()
	{
		base.transform.Rotate(axis * speed * Time.deltaTime);
	}
}
public class VampireSquidController : MonoBehaviour
{
	private const float Native_Width = 1024f;

	private const float Native_Height = 768f;

	public Material squidMaterial;

	public float swimUpForce = 15f;

	public float lateralForce = 5f;

	public float lateralDampening = 1f;

	public float photoforeMaxIntensity = 1f;

	public GameObject squirtParticleSystem;

	public bool swimming;

	public Vector3 inkSquirtPosition;

	public GUIStyle helpText;

	private Vector2 oldDirection;

	private Vector2 newDirection;

	private Vector2 smoothedDirection;

	private bool swimmingUp;

	private bool glowing;

	private Animator anim;

	private void Start()
	{
		anim = GetComponent<Animator>();
	}

	private void Update()
	{
		if (Input.GetButton("Fire1"))
		{
			glowing = true;
		}
		else
		{
			glowing = false;
		}
		if (Input.GetButtonUp("Fire2"))
		{
			Debug.Log("Squirting");
			anim.SetTrigger("Squirt");
		}
	}

	private void FixedUpdate()
	{
		Vector2 vector = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
		if (vector.magnitude > 0.1f)
		{
			swimming = true;
		}
		else
		{
			swimming = false;
		}
		oldDirection = smoothedDirection;
		newDirection = vector;
		smoothedDirection = Vector2.Lerp(oldDirection, newDirection, Time.deltaTime * lateralDampening);
		if (Input.GetKey(KeyCode.Space))
		{
			swimmingUp = true;
			GetComponent<Rigidbody>().AddForce(Vector3.up * swimUpForce);
		}
		else
		{
			swimmingUp = false;
		}
		anim.SetFloat("HorizontalDirection", smoothedDirection.x);
		anim.SetFloat("VerticalDirection", smoothedDirection.y);
		anim.SetBool("SwimmingUp", swimmingUp);
		anim.SetBool("Swimming", swimming);
		anim.SetBool("Glowing", glowing);
		GetComponent<Rigidbody>().AddForce(new Vector3(0f - vector.x, 0f, 0f - vector.y) * lateralForce);
	}

	private void SquirtInk()
	{
		Debug.Log("Imma Squirtin");
		if ((bool)squirtParticleSystem)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(squirtParticleSystem, base.transform.position + inkSquirtPosition, Quaternion.identity);
			gameObject.transform.parent = base.transform;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.green;
		Gizmos.DrawWireSphere(base.transform.position + inkSquirtPosition, 1f);
	}

	private void OnGUI()
	{
		float x = (float)Screen.width / 1024f;
		float y = (float)Screen.height / 768f;
		GUI.matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, new Vector3(x, y, 1f));
		GUI.Label(new Rect(0f, 738f, 1024f, 30f), "[WASD] moves squid Laterally, [SPACE] to swim up, [Fire1] to glow, [Fire2] to squirt", helpText);
	}
}
public class VampireSquidGlowControl : MonoBehaviour
{
	private float timer;

	public AnimationCurve glowCurve;

	public float speed;

	public float strength = 2f;

	private void Start()
	{
	}

	private void Update()
	{
		float num = glowCurve.Evaluate(timer);
		GetComponent<Renderer>().material.SetFloat("_PhotoforeEmission", num * strength);
		timer += Time.deltaTime * speed;
	}
}
public class Orca : MonoBehaviour
{
	public bool playerIsTarget;

	public bool foodIsTarget;

	public Transform head;

	public Rigidbody body;

	public JawsAnimator jawsAnimator;

	public float defaultSpeed;

	public float fastestSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float defaultTurnSpeed = 1.5f;

	public float maxTurnSpeed = 2.5f;

	public float turnSpeedReductionRate = 0.99f;

	private float turnSpeed;

	public float attackingTurnSpeed = 2f;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	private Vector3 fluidTargetPosition;

	public float targetLerpSpeed = 1f;

	public float defaultRotateToTargetSpeed;

	public float attackingRotateToTargetSpeed;

	private float headingAngle;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public float swimAmplitudeMinZ;

	public float swimAmplitudeMaxZ;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int hungryness;

	public int speedChangeChance = 200;

	public int barrelRollChance;

	public Vector2 barrelRollSpeedRange = new Vector2(100f, 500f);

	private bool doBarrelRoll;

	private float barrelRollAngle;

	private float barrelRollSpeed;

	private float angleX;

	private float angleY;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float targetSwimFrequencyX;

	private float swimFrequencyY;

	private float targetSwimFrequencyY;

	private float rotateToTargetSpeed;

	private GameObject player;

	private GameObject food;

	private Vector3 targetPos;

	private Transform waterSurface;

	public Transform[] bones;

	public Transform[] targets;

	private Vector3[] localRotationOrigins;

	public AnimationCurve swimCurve;

	private float swimXTimer;

	private float swimYTimer;

	public Vector3 tailAxis = new Vector3(0f, 0f, 1f);

	public float tailRestAmplitude;

	public float tailMaxAmplitude = 20f;

	public float tailPhase;

	public AnimationCurve tailPowerCurve;

	private float tailAmplitude;

	private float targetTailAmplitude;

	private EatThings eatThings;

	public float tailAmplitudeLerp = 1f;

	public float tailAmplitudeReductionRate = 0.99f;

	private void Start()
	{
		turnSpeed = defaultTurnSpeed;
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		player = GameObject.Find("OVRCameraRig");
		targetPos = target.position;
		fluidTargetPosition = targetPos;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		localRotationOrigins = new Vector3[bones.Length];
		for (int i = 0; i < bones.Length; i++)
		{
			ref Vector3 reference = ref localRotationOrigins[i];
			reference = bones[i].localRotation.eulerAngles;
		}
		eatThings = GetComponent<EatThings>();
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, friendliness) == 1 && base.transform.Find("Target").GetComponent<MovingTarget>().movementZone.bounds.Contains(player.transform.position))
		{
			playerIsTarget = true;
		}
		if (Random.Range(0, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (!doBarrelRoll && Random.Range(0, barrelRollChance) == 1)
		{
			doBarrelRoll = true;
			barrelRollAngle = 0f;
			barrelRollSpeed = Random.Range(barrelRollSpeedRange.x, barrelRollSpeedRange.y);
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			RandomiseParameters();
		}
	}

	public void RandomiseParameters()
	{
		if (eatThings.getCurrentFood() != null)
		{
			setFoodTarget(eatThings.getCurrentFood());
		}
		float num = Random.Range(defaultSpeed, fastestSpeed);
		targetSpeed = num;
		float num2 = Mathf.Clamp((targetSpeed - moveSpeed) / fastestSpeed, 0f, 1f);
		swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
		swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
		swimAmplitudeZ = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxZ);
		targetSwimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
		targetSwimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetTailAmplitude = tailMaxAmplitude;
		turnSpeed = maxTurnSpeed;
	}

	private void Update()
	{
		if ((bool)body && (bool)waterSurface)
		{
			if (head.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if ((targetPos - head.transform.position).magnitude < 5f)
		{
			targetSpeed = defaultSpeed;
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 0.4f, 0f);
			if ((double)(targetPos - head.transform.position).magnitude < 3.0)
			{
				targetSpeed = defaultSpeed * 0.5f;
			}
			if ((targetPos - head.transform.position).magnitude < 1f)
			{
				playerIsTarget = false;
			}
		}
		else if (foodIsTarget)
		{
			rotateToTargetSpeed = attackingRotateToTargetSpeed;
			if (food == null)
			{
				foodIsTarget = false;
			}
			else
			{
				targetPos = food.transform.position;
				targetSpeed = fastestSpeed;
				if ((targetPos - head.transform.position).magnitude < 1f)
				{
					targetSpeed = defaultSpeed;
				}
			}
		}
		else
		{
			targetPos = target.position;
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration / 5f;
		}
		moveDirection = new Vector3(0f, 0f, 1f);
		head.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
		angleX = swimCurve.Evaluate(swimXTimer);
		angleY = swimCurve.Evaluate(swimYTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.forward * Time.deltaTime * swimAmplitudeZ * angleX);
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		targetSpeed = Mathf.Clamp(targetSpeed, 0f, fastestSpeed);
		if (doBarrelRoll)
		{
			float num = 0.1f;
			float num2 = ((!(barrelRollAngle < 180f)) ? Mathf.Clamp01((360f - barrelRollAngle) / 180f * 1f) : Mathf.Clamp01(num + barrelRollAngle / 180f * 1f));
			float num3 = num2 * barrelRollSpeed * Time.deltaTime;
			barrelRollAngle += num3;
			if (barrelRollAngle > 359f)
			{
				barrelRollAngle = 0f;
				doBarrelRoll = false;
			}
			swimComponent *= Quaternion.Euler(Vector3.forward * num3);
		}
		fluidTargetPosition = Vector3.Lerp(fluidTargetPosition, targetPos, Time.deltaTime * targetLerpSpeed);
		targetDir = fluidTargetPosition - head.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(head.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
		head.transform.rotation = rot * swimComponent;
		swimTimer += Time.deltaTime;
		swimFrequencyX = Mathf.Lerp(swimFrequencyX, targetSwimFrequencyX, Time.deltaTime * 1f);
		swimFrequencyY = Mathf.Lerp(swimFrequencyY, targetSwimFrequencyY, Time.deltaTime * 1f);
		swimXTimer += Time.deltaTime * (swimFrequencyX / 7f);
		swimYTimer += Time.deltaTime * (swimFrequencyY / 7f);
		if (turnSpeed > defaultTurnSpeed)
		{
			turnSpeed *= turnSpeedReductionRate;
		}
	}

	private void LateUpdate()
	{
		for (int i = 0; i < bones.Length; i++)
		{
			Transform transform = bones[i];
			Transform transform2 = targets[i];
			transform.LookAt(transform2.position, transform.up);
			transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
			Quaternion localRotation = transform.localRotation;
			localRotation.eulerAngles = new Vector3(localRotationOrigins[i].x, localRotation.eulerAngles.y, localRotation.eulerAngles.z);
			transform.localRotation = localRotation;
		}
		tailAmplitude = Mathf.Lerp(tailAmplitude, targetTailAmplitude, Time.deltaTime * tailAmplitudeLerp);
		targetTailAmplitude *= tailAmplitudeReductionRate;
		if (targetTailAmplitude < 0f)
		{
			targetTailAmplitude = 0f;
		}
		for (int j = 0; j < bones.Length; j++)
		{
			if (j > 1)
			{
				float value = (float)j / (float)bones.Length;
				value = Mathf.Clamp01(value);
				float angle = swimCurve.Evaluate(swimYTimer + (float)j * tailPhase) * (tailAmplitude * tailPowerCurve.Evaluate(value));
				bones[j].Rotate(tailAxis, angle);
			}
		}
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setFoodTarget(GameObject foodTarget)
	{
		food = foodTarget;
		foodIsTarget = true;
	}

	public void setTarget(Transform newTarget)
	{
		target = newTarget;
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}

	public void setSwimAmplitudeZ(float val)
	{
		swimAmplitudeZ = val;
	}

	public void struggle()
	{
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private void StruckSomething(Vector3 normal)
	{
		int num = Random.Range(0, 2);
		if (num == 0)
		{
			target.position = head.position + -head.forward * 5f;
		}
		if (num == 1)
		{
			target.position = head.position + -head.right * 5f;
		}
		playerIsTarget = false;
		target.GetComponent<MovingTarget>().setTimer(0f);
		if (jawsAnimator != null && Random.Range(1, 4) == 3)
		{
			jawsAnimator.setBiting(val: true);
		}
	}
}
[RequireComponent(typeof(CharacterController))]
public class OVRSwimController : MonoBehaviour
{
	protected CharacterController Controller;

	public float Acceleration = 0.1f;

	public float Damping = 0.15f;

	public float BackAndSideDampen = 0.5f;

	public float JumpForce = 0.3f;

	public float RotationAmount = 1.5f;

	public float GravityModifier = 0.379f;

	private float MoveScale = 1f;

	public Vector3 MoveThrottle = Vector3.zero;

	private float FallSpeed;

	private Quaternion OrientationOffset = Quaternion.identity;

	public float YRotation;

	public float XRotation;

	private float MoveScaleMultiplier = 2f;

	private float RotationScaleMultiplier = 1f;

	public static bool AllowMouseRotation = true;

	private bool HaltUpdateMovement;

	private float YfromSensor2;

	public float maxFallSpeed = 1f;

	public float maxStrokePower = 0.012f;

	public float strokeFrequency = 1f;

	private float strokePower;

	private float strokeTimer;

	private float actualGravityModifier;

	private AudioSource feetAudio;

	private bool prevGrounded;

	public AnimationCurve swimUpDownCurve;

	public AnimationCurve swimFastCurve;

	public float swimFastFrequency = 1f;

	public float swimFastMultiplier = 1.4f;

	private float swimFastTimer;

	private int previousStroke;

	private float rotationDampener;

	private bool prevHatLeft;

	private bool prevHatRight;

	private bool prevHatDown;

	public float RotationRatchet = 30f;

	private int RotationRatchetCounter = 1000;

	public int RotationRatchetFrames = 1;

	private int RatchetSign = 1;

	private float touchpadSwimSpeed;

	private float touchpadSwimSpeedUp;

	private Transform centerCamera;

	private Transform forwardDirection;

	private float touchpadSideSwimSpeed;

	private static float sDeltaRotationOld;

	public void Awake()
	{
		Controller = base.gameObject.GetComponent<CharacterController>();
		if (Controller == null)
		{
			Debug.LogWarning("OVRPlayerController: No CharacterController attached.");
		}
	}

	public void Start()
	{
		feetAudio = base.transform.Find("Feet Sound").GetComponent<AudioSource>();
		centerCamera = LAC_VRCameraRig.instance.getCenterCamera().transform;
		forwardDirection = base.transform.Find("Forward Direction");
		InitializeInputs();
		SetCameras();
		actualGravityModifier = 0f;
	}

	public void Update()
	{
		UpdateMovement();
		Vector3 zero = Vector3.zero;
		float num = Damping;
		if (!Controller.isGrounded)
		{
			num = Damping * 0.85f;
		}
		float num2 = 1f + num * Time.deltaTime;
		MoveThrottle.x /= num2;
		MoveThrottle.y /= num2;
		MoveThrottle.z /= num2;
		zero += MoveThrottle * Time.deltaTime;
		float num3 = -3f;
		if (Controller.isGrounded && FallSpeed <= 0f)
		{
			FallSpeed = num3 * (actualGravityModifier * 0.002f);
		}
		else
		{
			FallSpeed += num3 * (actualGravityModifier * 0.002f) * Time.deltaTime;
		}
		if (FallSpeed < 0f - maxFallSpeed)
		{
			FallSpeed = 0f - maxFallSpeed;
		}
		if (Input.GetAxis("Desktop_Button A") > 0.1f)
		{
			FallSpeed *= 0.98f;
		}
		zero.y += FallSpeed * Time.deltaTime;
		float num4 = swimUpDownCurve.Evaluate(strokeTimer) * maxStrokePower;
		if (strokeTimer > 1f)
		{
			strokeTimer = 0f;
		}
		float axis = Input.GetAxis("LeftShoulder");
		float axis2 = Input.GetAxis("RightShoulder");
		if (axis > 0.3f)
		{
			MoveThrottle += new Vector3(0f, -1f, 0f) * num4 * Time.deltaTime;
		}
		else if (axis2 > 0.3f)
		{
			MoveThrottle += new Vector3(0f, 1f, 0f) * num4 * Time.deltaTime;
			FallSpeed *= 0.98f;
		}
		else
		{
			strokePower = 0f;
			strokeTimer = 0f;
		}
		Vector3 vector = Vector3.Scale(Controller.transform.localPosition + zero, new Vector3(1f, 0f, 1f));
		if (UnityEngine.Application.loadedLevelName != "OceanRift_Startup_Void" || UnityEngine.Application.loadedLevelName != "OceanRift_Startup_Void_SantaCruz")
		{
			Controller.Move(zero);
		}
		Vector3 vector2 = Vector3.Scale(Controller.transform.localPosition, new Vector3(1f, 0f, 1f));
		if (vector != vector2)
		{
			MoveThrottle += (vector2 - vector) / Time.deltaTime;
		}
		UpdatePlayerForwardDirTransform();
		if (Controller.isGrounded != prevGrounded && Mathf.Abs(FallSpeed) > 0.4f)
		{
			feetAudio.Play();
		}
		prevGrounded = Controller.isGrounded;
		strokeTimer += Time.deltaTime * strokeFrequency;
		swimFastTimer += Time.deltaTime;
		MoveThrottle = Vector3.ClampMagnitude(MoveThrottle, 1.75f);
	}

	public void TouchpadLeftStroke(float adjust = 1f)
	{
		touchpadSideSwimSpeed = 0.7f * adjust;
	}

	public void TouchpadSwim()
	{
		touchpadSwimSpeed = 1.1f;
	}

	public void TouchpadSwimFast()
	{
		touchpadSwimSpeed = 1.5f;
	}

	public void TouchpadSwimBackwards()
	{
		touchpadSwimSpeed = -1f;
	}

	public void TouchpadRightStroke(float adjust = 1f)
	{
		touchpadSideSwimSpeed = -0.7f * adjust;
	}

	public void TouchpadSwimUp(float adjust = 1f)
	{
		touchpadSwimSpeedUp = 0.8f;
	}

	public void TouchpadSwimDown(float adjust = 1f)
	{
		touchpadSwimSpeedUp = -0.8f * adjust;
	}

	public void AddForce(Vector3 force)
	{
		MoveThrottle += forwardDirection.TransformDirection(force);
	}

	public void RatchetTurnLeft()
	{
		YRotation -= RotationRatchet;
	}

	public void RatchetTurnRight()
	{
		YRotation += RotationRatchet;
	}

	public virtual void UpdateMovement()
	{
		if (!HaltUpdateMovement)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			MoveScale = 1f;
			if (Input.GetKey(KeyCode.W))
			{
				flag = true;
			}
			if (Input.GetKey(KeyCode.A))
			{
				flag2 = true;
			}
			if (Input.GetKey(KeyCode.S))
			{
				flag4 = true;
			}
			if (Input.GetKey(KeyCode.D))
			{
				flag3 = true;
			}
			if (Input.GetKey(KeyCode.UpArrow))
			{
				flag = true;
			}
			if (Input.GetKey(KeyCode.LeftArrow))
			{
				flag2 = true;
			}
			if (Input.GetKey(KeyCode.DownArrow))
			{
				flag4 = true;
			}
			if (Input.GetKey(KeyCode.RightArrow))
			{
				flag3 = true;
			}
			if ((flag && flag2) || (flag && flag3) || (flag4 && flag2) || (flag4 && flag3))
			{
				MoveScale = 0.70710677f;
			}
			MoveScale *= Time.deltaTime;
			float num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			if (Input.GetAxis("Desktop_Button A") > 0.1f)
			{
				Jump();
			}
			if (Input.GetKey(KeyCode.F))
			{
				num += num * swimFastCurve.Evaluate(swimFastTimer * swimFastFrequency) * swimFastMultiplier;
			}
			if (flag)
			{
				MoveThrottle += forwardDirection.TransformDirection(Vector3.forward * num);
			}
			if (flag4)
			{
				MoveThrottle += forwardDirection.TransformDirection(Vector3.back * num) * BackAndSideDampen;
			}
			if (flag2)
			{
				MoveThrottle += forwardDirection.TransformDirection(Vector3.left * num) * BackAndSideDampen;
			}
			if (flag3)
			{
				MoveThrottle += forwardDirection.TransformDirection(Vector3.right * num) * BackAndSideDampen;
			}
			float num2 = 0f;
			bool flag5 = false;
			if (Input.GetAxis("DPad_X_Axis") < -0.2f)
			{
				flag5 = true;
			}
			if (num2 < -0.2f)
			{
				flag5 = true;
			}
			if (Input.GetKeyDown(KeyCode.Q))
			{
				YRotation -= RotationRatchet;
			}
			if (Input.GetKeyDown(KeyCode.E))
			{
				YRotation += RotationRatchet;
			}
			float num3 = Time.deltaTime * RotationAmount * RotationScaleMultiplier;
			if (Input.GetKey(KeyCode.Q))
			{
				YRotation -= num3 * 0.5f;
			}
			if (Input.GetKey(KeyCode.E))
			{
				YRotation += num3 * 0.5f;
			}
			float num4 = 0f;
			if (!AllowMouseRotation)
			{
				num4 = Input.GetAxis("Mouse X") * num3 * 3.25f;
			}
			float num5 = sDeltaRotationOld * 0f + num4 * 1f;
			YRotation += num5;
			sDeltaRotationOld = num5;
			num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			float num6 = 0f;
			float num7 = 0f;
			if (Input.GetAxis("Desktop_Button A") > 0.1f || Input.GetAxis("Button A") > 0.1f)
			{
				num += num * swimFastCurve.Evaluate(swimFastTimer * swimFastFrequency) * swimFastMultiplier;
			}
			MoveThrottle += touchpadSwimSpeed * (Quaternion.AngleAxis(-1f, forwardDirection.right) * forwardDirection.forward) * num;
			MoveThrottle += touchpadSwimSpeedUp * Vector3.up * num;
			MoveThrottle += touchpadSideSwimSpeed * (Quaternion.AngleAxis(-1f, forwardDirection.right) * forwardDirection.right) * num;
			touchpadSwimSpeed *= 0.95f;
			touchpadSwimSpeedUp *= 0.98f;
			touchpadSideSwimSpeed *= 0.98f;
			Vector3 forward = centerCamera.forward;
			forward.y = 0f;
			forward.Normalize();
			Vector3 right = centerCamera.right;
			right.y = 0f;
			right.Normalize();
			if (num6 > 0f)
			{
				MoveThrottle += num6 * forward * num;
			}
			if (num6 < 0f)
			{
				MoveThrottle += Mathf.Abs(num6) * -forward * num * BackAndSideDampen;
			}
			if (num7 < 0f)
			{
				MoveThrottle += Mathf.Abs(num7) * -right * num * BackAndSideDampen;
			}
			if (num7 > 0f)
			{
				MoveThrottle += num7 * right * num * BackAndSideDampen;
			}
			MoveThrottle = Vector3.ClampMagnitude(MoveThrottle, 1.65f);
			SetCameras();
		}
	}

	public void addSwimmingForce(Vector3 force)
	{
		MoveThrottle += force;
	}

	public virtual void UpdatePlayerForwardDirTransform()
	{
		Quaternion identity = Quaternion.identity;
		identity = Quaternion.Euler(0f, YfromSensor2, 0f);
		forwardDirection.rotation = identity * centerCamera.transform.rotation;
	}

	public void setGravity(bool val)
	{
		if (!val)
		{
			actualGravityModifier = 0f;
			FallSpeed = 0f;
		}
		else
		{
			actualGravityModifier = GravityModifier;
		}
	}

	public void ToggleGravity()
	{
		if (actualGravityModifier == 0f)
		{
			setGravity(val: true);
		}
		else
		{
			setGravity(val: false);
		}
	}

	public void PushBack(Vector3 dir, float force)
	{
		MoveThrottle += dir * force;
	}

	public bool Jump()
	{
		if (!Controller.isGrounded)
		{
			return false;
		}
		MoveThrottle += new Vector3(0f, JumpForce, 0f);
		return true;
	}

	public void Stop()
	{
		Controller.Move(Vector3.zero);
		MoveThrottle = Vector3.zero;
		FallSpeed = 0f;
	}

	public void InitializeInputs()
	{
		OrientationOffset = base.transform.rotation;
		YRotation = 0f;
	}

	public void SetCameras()
	{
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		eulerAngles.y += YRotation;
		base.transform.rotation = Quaternion.Euler(eulerAngles);
		YRotation = 0f;
	}

	public void GetMoveScaleMultiplier(ref float moveScaleMultiplier)
	{
		moveScaleMultiplier = MoveScaleMultiplier;
	}

	public void SetMoveScaleMultiplier(float moveScaleMultiplier)
	{
		MoveScaleMultiplier = moveScaleMultiplier;
	}

	public void GetRotationScaleMultiplier(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplier;
	}

	public void SetRotationScaleMultiplier(float rotationScaleMultiplier)
	{
		RotationScaleMultiplier = rotationScaleMultiplier;
	}

	public void GetAllowMouseRotation(ref bool allowMouseRotation)
	{
		allowMouseRotation = AllowMouseRotation;
	}

	public void SetAllowMouseRotation(bool allowMouseRotation)
	{
		AllowMouseRotation = allowMouseRotation;
	}

	public void GetHaltUpdateMovement(ref bool haltUpdateMovement)
	{
		haltUpdateMovement = HaltUpdateMovement;
	}

	public void SetHaltUpdateMovement(bool haltUpdateMovement)
	{
		HaltUpdateMovement = haltUpdateMovement;
	}
}
public class SeaSnake : MonoBehaviour
{
	public bool activeDistance = true;

	public Transform head;

	public float moveSpeed;

	public float turnSpeed;

	private Vector3 moveDirection;

	private float SlitherTimer;

	public Vector2 frequencyRange = new Vector2(4f, 4f);

	public Vector2 amplitudeRange = new Vector2(1f, 1f);

	public Transform target;

	public float rotateToTargetSpeed;

	public Texture2D[] textures;

	public Renderer theRenderer;

	public float changeChance = 300f;

	private float frequency;

	private float amplitude;

	private Transform[] childs;

	public Transform viralLeaderScript;

	private Transform player;

	private void Start()
	{
		theRenderer.material.mainTexture = textures[Random.Range(0, textures.Length)];
		ChangeBehaviour();
		player = GameObject.Find("Dummy Player").transform;
	}

	private void ChangeBehaviour()
	{
		frequency = Random.Range(frequencyRange.x, frequencyRange.y);
		amplitude = Random.Range(amplitudeRange.x, amplitudeRange.y);
	}

	private void FixedUpdate()
	{
		if (Random.Range(0f, changeChance) == 1f)
		{
			ChangeBehaviour();
		}
	}

	private void Update()
	{
		float num = 0f;
		float z = 1f;
		if ((head.position - player.position).magnitude > 10f && activeDistance)
		{
			viralLeaderScript.gameObject.SetActive(value: false);
			return;
		}
		viralLeaderScript.gameObject.SetActive(value: true);
		moveDirection = Vector3.zero;
		moveDirection = new Vector3(0f, 0f, z);
		head.Translate(moveDirection * Time.deltaTime * moveSpeed);
		float num2 = Mathf.Sin(frequency * SlitherTimer) * amplitude;
		Quaternion quaternion = Quaternion.Euler(Vector3.up * Time.deltaTime * num2 * 100f * turnSpeed);
		Vector3 forward = target.position - head.position;
		Quaternion quaternion2 = Quaternion.Slerp(head.rotation, Quaternion.LookRotation(forward), rotateToTargetSpeed * Time.deltaTime);
		head.rotation = quaternion2 * quaternion;
		SlitherTimer += Time.deltaTime;
	}
}
public class SimpleFish : MonoBehaviour
{
	public bool playerIsTarget;

	public Transform theModel;

	public Rigidbody body;

	public float defaultSpeed;

	public float fastestSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float turnSpeed;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	private Vector3 fluidTargetPosition;

	public float defaultRotateToTargetSpeed;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int speedChangeChance = 200;

	private float angleX;

	private float angleY;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float rotateToTargetSpeed;

	private GameObject player;

	private Vector3 targetPos;

	private Transform waterSurface;

	private Animation animation;

	public float maxAnimSpeed = 1f;

	public float minAnimSpeed = 0.1f;

	private float headingAngle;

	private float animSpeed;

	public float targetLerpSpeed = 1f;

	public float activeDistance = 20f;

	private Transform hand;

	private Quaternion grabRotation;

	private Quaternion grabParentRotation;

	private void Start()
	{
		headingAngle = 0f;
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		player = GameObject.Find("Dummy Player");
		targetPos = target.position;
		fluidTargetPosition = targetPos;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		animation = theModel.GetComponent<Animation>();
		if (animation == null)
		{
			animation = theModel.GetChild(0).GetComponent<Animation>();
		}
	}

	private void Update()
	{
		if (hand != null)
		{
			theModel.transform.position = Vector3.Lerp(theModel.transform.position, hand.position, Time.deltaTime * 40f);
			theModel.transform.rotation = hand.rotation * Quaternion.Inverse(grabParentRotation) * grabRotation;
			return;
		}
		float magnitude = (player.transform.position - theModel.transform.position).magnitude;
		if (!(magnitude < activeDistance))
		{
			return;
		}
		if ((bool)body && (bool)waterSurface)
		{
			if (theModel.position.y > waterSurface.position.y)
			{
				body.useGravity = true;
			}
			else
			{
				body.useGravity = false;
			}
		}
		if (Random.Range(1, friendliness) == 1)
		{
			playerIsTarget = !playerIsTarget;
		}
		if (Random.Range(1, faithfulness) == 1)
		{
			playerIsTarget = false;
		}
		if (playerIsTarget)
		{
			targetPos = player.transform.position + new Vector3(0f, 1f, 0f);
			if ((targetPos - theModel.transform.position).magnitude < 5f)
			{
				targetSpeed = defaultSpeed;
			}
		}
		else
		{
			targetPos = target.position;
		}
		if (Random.Range(0, speedChangeChance) == 1)
		{
			float num = Random.Range(defaultSpeed, fastestSpeed);
			if (num > moveSpeed)
			{
				targetSpeed = num;
			}
			swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
			swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
			swimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
			swimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration;
		}
		moveDirection = Vector3.zero;
		moveDirection = new Vector3(0f, 0f, 1f);
		theModel.transform.Translate(moveDirection * Time.smoothDeltaTime * moveSpeed);
		angleX = Mathf.Sin(swimFrequencyX * swimTimer);
		angleY = Mathf.Sin(swimFrequencyY * swimTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
		fluidTargetPosition = Vector3.Lerp(fluidTargetPosition, targetPos, Time.deltaTime * targetLerpSpeed);
		targetDir = fluidTargetPosition - theModel.transform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(theModel.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.smoothDeltaTime));
		theModel.transform.rotation = rot * swimComponent;
		headingAngle = getAngle(theModel.rotation, targetQuat);
		swimTimer += Time.deltaTime;
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
		animSpeed = minAnimSpeed + moveError / fastestSpeed * (maxAnimSpeed - minAnimSpeed) + Mathf.Abs(headingAngle) / 120f;
		animSpeed = Mathf.Clamp(animSpeed, minAnimSpeed, maxAnimSpeed);
		if (animation != null)
		{
			animation["swim"].speed = animSpeed;
		}
	}

	public void SetGrabbed(Transform val)
	{
		if (hand == null && val != null)
		{
			grabRotation = theModel.transform.rotation;
			grabParentRotation = val.rotation;
		}
		hand = val;
		if (hand == null)
		{
			moveSpeed = defaultSpeed / 2f;
			setTargetSpeed(fastestSpeed * 1.5f);
			return;
		}
		if (animation != null)
		{
			animation["swim"].speed = minAnimSpeed;
		}
		setTargetSpeed(defaultSpeed);
	}

	public bool isGrabbing()
	{
		if (hand == null)
		{
			return false;
		}
		return true;
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}
}
public class SimpleFishAfraid : MonoBehaviour
{
	public bool playerIsTarget;

	public Transform theModel;

	public Rigidbody body;

	public GameObject predator;

	public float defaultSpeed;

	public float fastestSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float turnSpeed;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	private Vector3 fluidTargetPosition;

	public float defaultRotateToTargetSpeed;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int speedChangeChance = 200;

	private float angleX;

	private float angleY;

	private float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float rotateToTargetSpeed;

	private GameObject player;

	private Vector3 targetPos;

	private Transform waterSurface;

	private Animation animation;

	public float maxAnimSpeed = 1f;

	public float minAnimSpeed = 0.1f;

	private float headingAngle;

	private float animSpeed;

	public float targetLerpSpeed = 1f;

	public float activeDistance = 20f;

	public float repulsionDuration = 1f;

	public float repulsionForce = 1f;

	private float repulsionTimer;

	private Transform hand;

	private Quaternion grabRotation;

	private Quaternion grabParentRotation;

	private void Start()
	{
		headingAngle = 0f;
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		player = GameObject.Find("Dummy Player");
		targetPos = target.position;
		fluidTargetPosition = targetPos;
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		animation = theModel.GetComponent<Animation>();
		if (animation == null)
		{
			animation = theModel.GetChild(0).GetComponent<Animation>();
		}
		predator = GameObject.Find("Leader");
	}

	private void CollidedTrigger()
	{
		target.position = theModel.position + -theModel.forward * 5f;
	}

	private void CollidedCollision()
	{
		target.position = theModel.position + -theModel.forward * 5f;
		repulsionTimer = repulsionDuration;
		targetSpeed = defaultSpeed;
	}

	private void FixedUpdate()
	{
		if (hand != null)
		{
			theModel.transform.position = Vector3.Lerp(theModel.transform.position, hand.position, Time.deltaTime * 40f);
			theModel.transform.rotation = hand.rotation * Quaternion.Inverse(grabParentRotation) * grabRotation;
			return;
		}
		float magnitude = (player.transform.position - theModel.position).magnitude;
		Vector3 vector = predator.transform.position - theModel.position;
		if (vector.magnitude < 2.5f)
		{
			Vector3 position = theModel.position + -vector.normalized * 5f;
			position.y = theModel.position.y;
			target.position = position;
			targetSpeed = fastestSpeed;
		}
		if (magnitude < activeDistance)
		{
			if ((bool)body && (bool)waterSurface)
			{
				if (theModel.position.y > waterSurface.position.y)
				{
					body.useGravity = true;
				}
				else
				{
					body.useGravity = false;
				}
			}
			if (Random.Range(1, friendliness) == 1)
			{
				playerIsTarget = !playerIsTarget;
			}
			if (Random.Range(1, faithfulness) == 1)
			{
				playerIsTarget = false;
			}
			if (playerIsTarget)
			{
				targetPos = player.transform.position + new Vector3(0f, 1f, 0f);
				if ((targetPos - theModel.transform.position).magnitude < 5f)
				{
					targetSpeed = defaultSpeed;
				}
			}
			else
			{
				targetPos = target.position;
			}
			if (Random.Range(0, speedChangeChance) == 1)
			{
				float num = Random.Range(defaultSpeed, fastestSpeed);
				if (num > moveSpeed)
				{
					targetSpeed = num;
				}
				swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
				swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
				swimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
				swimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
			}
			moveError = targetSpeed - moveSpeed;
			if (moveError > 0.001f)
			{
				moveSpeed += maxAcceleration;
			}
			else
			{
				moveSpeed -= maxAcceleration;
			}
			moveDirection = Vector3.zero;
			moveDirection = new Vector3(0f, 0f, 1f);
			theModel.transform.Translate(moveDirection * Time.deltaTime * moveSpeed);
			angleX = Mathf.Sin(swimFrequencyX * swimTimer);
			angleY = Mathf.Sin(swimFrequencyY * swimTimer);
			swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
			swimComponent *= Quaternion.Euler(Vector3.right * Time.deltaTime * angleY * swimAmplitudeY * turnSpeed);
			fluidTargetPosition = Vector3.Lerp(fluidTargetPosition, targetPos, Time.deltaTime * targetLerpSpeed);
			targetDir = fluidTargetPosition - theModel.transform.position;
			targetQuat = Quaternion.LookRotation(targetDir);
			rot = Quaternion.Slerp(theModel.transform.rotation, targetQuat, Mathf.SmoothStep(0f, 1f, rotateToTargetSpeed * Time.deltaTime));
			theModel.transform.rotation = rot * swimComponent;
			headingAngle = getAngle(theModel.rotation, targetQuat);
			swimTimer += Time.deltaTime;
			if (moveSpeed > defaultSpeed)
			{
				targetSpeed -= speedDecay;
			}
			animSpeed = minAnimSpeed + moveError / fastestSpeed * (maxAnimSpeed - minAnimSpeed) + Mathf.Abs(headingAngle) / 120f;
			animSpeed = Mathf.Clamp(animSpeed, minAnimSpeed, maxAnimSpeed);
			if (animation != null)
			{
				animation["swim"].speed = animSpeed;
			}
		}
		if (repulsionTimer > 0f)
		{
			theModel.GetComponent<Rigidbody>().AddForce((target.position - player.transform.position).normalized * repulsionForce, ForceMode.Impulse);
		}
		repulsionTimer -= Time.deltaTime;
	}

	public void SetGrabbed(Transform val)
	{
		if (hand == null && val != null)
		{
			grabRotation = theModel.transform.rotation;
			grabParentRotation = val.rotation;
		}
		hand = val;
		if (hand == null)
		{
			moveSpeed = defaultSpeed / 2f;
			setTargetSpeed(fastestSpeed * 1.5f);
			return;
		}
		if (animation != null)
		{
			animation["swim"].speed = minAnimSpeed;
		}
		setTargetSpeed(defaultSpeed);
	}

	public bool isGrabbing()
	{
		if (hand == null)
		{
			return false;
		}
		return true;
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}
}
public class SimpleFishCollisionDetector : MonoBehaviour
{
	private void OnCollisionEnter(Collision collision)
	{
		SendMessageUpwards("CollidedCollision");
	}

	private void OnTriggerEnter(Collider other)
	{
		SendMessageUpwards("CollidedTrigger");
	}
}
public class SeaSpider : MonoBehaviour
{
	public Transform target;

	public float turnSpeed = 1f;

	public float moveSpeed = 0.1f;

	public int moveChance = 120;

	public float targetRange = 2f;

	private Vector3 targetDirection;

	private Vector3 targetRotation;

	private Vector3 lerpDirection;

	private Vector3 moveDirection;

	private Animator anim;

	public float minAnimSpeed = 0.5f;

	public float maxAnimSpeed = 1.5f;

	public AnimationCurve walkCurve;

	public float targetLerp = 1f;

	private Vector3 targetPos;

	private void Start()
	{
		anim = base.gameObject.GetComponent<Animator>();
		targetPos = target.localPosition;
	}

	private void Update()
	{
		float magnitude = (target.position - base.transform.position).magnitude;
		moveDirection = lerpDirection;
		if (Random.Range(0, moveChance) == 1)
		{
			MoveTarget();
		}
		targetDirection = target.position - base.transform.position;
		targetDirection.Normalize();
		targetDirection.y = 0f;
		lerpDirection = Vector3.Lerp(lerpDirection, targetDirection, Time.deltaTime * 1f);
		targetRotation = Vector3.RotateTowards(base.transform.forward, lerpDirection, turnSpeed, 1f);
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(targetRotation), Time.deltaTime * turnSpeed);
		float num = Vector3.Angle(targetDirection, base.transform.forward);
		float num2 = walkCurve.Evaluate(1f - Mathf.Clamp01(num / 25f));
		float num3 = walkCurve.Evaluate(Mathf.Clamp01(magnitude / 1f));
		target.localPosition = Vector3.Lerp(target.localPosition, targetPos, Time.deltaTime * targetLerp);
		base.transform.position = Vector3.Lerp(base.transform.position, target.position, Time.deltaTime * moveSpeed * num2);
		anim.speed = num3 * maxAnimSpeed;
	}

	private void MoveTarget()
	{
		targetPos = new Vector3(Random.Range(0f - targetRange, targetRange), 0f, Random.Range(0f - targetRange, targetRange));
	}
}
public class SeaSpiderLegs : MonoBehaviour
{
	public Transform body;

	public Transform[] legJoints;

	private Quaternion[] baseJointRots;

	private Quaternion[] liftedJointRots;

	public float maxRotation = 25f;

	public int legLiftChance = 500;

	public float liftTime = 2f;

	public float moveSpeed = 0.3f;

	public Vector3 axis = new Vector3(1f, 0f, 0f);

	private float[] legOscillators;

	private float[] legTimers;

	private void Start()
	{
		baseJointRots = new Quaternion[8];
		liftedJointRots = new Quaternion[8];
		legTimers = new float[8];
		legOscillators = new float[8];
		for (int i = 0; i < 8; i++)
		{
			ref Quaternion reference = ref baseJointRots[i];
			reference = legJoints[i].localRotation * Quaternion.Euler(axis);
			ref Quaternion reference2 = ref liftedJointRots[i];
			reference2 = legJoints[i].localRotation * Quaternion.Euler(axis * maxRotation);
			legTimers[i] = 0f;
			legOscillators[i] = 0f;
		}
	}

	private void Update()
	{
		for (int i = 0; i < 8; i++)
		{
			legOscillators[i] = Mathf.Sin(legTimers[i] * moveSpeed);
			if (Random.Range(1, legLiftChance) == 1)
			{
				legTimers[i] = liftTime;
			}
			if (legTimers[i] > 0f)
			{
				legJoints[i].localRotation = Quaternion.Slerp(legJoints[i].localRotation, liftedJointRots[i], Time.deltaTime * moveSpeed);
			}
			else
			{
				legJoints[i].localRotation = Quaternion.Slerp(legJoints[i].localRotation, baseJointRots[i], Time.deltaTime * moveSpeed);
			}
			legTimers[i] -= Time.deltaTime;
		}
	}

	private IEnumerator LiftLeg(int i)
	{
		float timer = 0f;
		while (timer < liftTime)
		{
			legJoints[i].localRotation = Quaternion.Slerp(legJoints[i].localRotation, liftedJointRots[i], Time.deltaTime * moveSpeed);
			timer += Time.deltaTime;
			yield return 0;
		}
	}
}
public class TropicalFishScript : MonoBehaviour
{
	private float swimCounter;

	private void Start()
	{
		GetComponent<Animation>()["Motion"].speed = 0.3f;
	}

	private void Update()
	{
		swimCounter += Time.deltaTime;
		if (swimCounter > 1f)
		{
			GetComponent<Rigidbody>().AddRelativeForce(0f, 0f, 0.1f, ForceMode.Force);
			swimCounter = 0f;
		}
	}
}
[ExecuteInEditMode]
public class FogVolume : MonoBehaviour
{
	private GameObject FogVolumeGameObject;

	[HideInInspector]
	public Material FogMaterial;

	[SerializeField]
	private Color InscatteringColor = Color.white;

	[SerializeField]
	private Color FogColor = new Color(0.5f, 0.6f, 0.7f, 1f);

	public float Visibility = 5f;

	public float InscateringExponent = 15f;

	public float InscatteringIntensity = 2f;

	public float InscatteringStartDistance = 400f;

	public float InscatteringTransitionWideness = 1f;

	public float _3DNoiseScale = 300f;

	public float _3DNoiseStepSize = 50f;

	public Texture3D _NoiseVolume;

	[Range(1f, 3f)]
	public int Quality = 1;

	[Range(0f, 10f)]
	public float NoiseIntensity = 1f;

	[Range(0f, 1f)]
	public float NoiseContrast;

	[SerializeField]
	private Light Sun;

	[SerializeField]
	private int DrawOrder;

	[SerializeField]
	private bool EnableInscattering;

	[SerializeField]
	private bool EnableNoise;

	public Vector4 Speed = new Vector4(0f, 0f, 0f, 0f);

	public Vector4 Stretch = new Vector4(0f, 0f, 0f, 0f);

	public float GetVisibility()
	{
		return Visibility;
	}

	private void OnEnable()
	{
		if (!FogMaterial)
		{
			FogMaterial = new Material(Shader.Find("Hidden/FogVolume"));
			FogMaterial.name = "Fog Material";
			FogMaterial.hideFlags = HideFlags.HideAndDontSave;
		}
		FogVolumeGameObject = base.gameObject;
		FogVolumeGameObject.GetComponent<Renderer>().sharedMaterial = FogMaterial;
		ToggleKeyword();
	}

	public static void Wireframe(GameObject obj, bool Enable)
	{
	}

	private void Update()
	{
	}

	private void OnWillRenderObject()
	{
		FogMaterial.SetColor("_Color", FogColor);
		FogMaterial.SetColor("_InscatteringColor", InscatteringColor);
		if ((bool)Sun)
		{
			FogMaterial.SetFloat("_InscatteringIntensity", InscatteringIntensity);
			FogMaterial.SetVector("L", -Sun.transform.forward);
			FogMaterial.SetFloat("_InscateringExponent", InscateringExponent);
			FogMaterial.SetFloat("InscatteringTransitionWideness", InscatteringTransitionWideness);
		}
		if (EnableNoise && (bool)_NoiseVolume)
		{
			Shader.SetGlobalTexture("_NoiseVolume", _NoiseVolume);
			FogMaterial.SetFloat("gain", NoiseIntensity);
			FogMaterial.SetFloat("threshold", NoiseContrast * 0.5f);
			FogMaterial.SetFloat("_3DNoiseScale", _3DNoiseScale * 0.001f);
			FogMaterial.SetFloat("_3DNoiseStepSize", _3DNoiseStepSize * 0.001f / (float)Quality);
			FogMaterial.SetVector("Speed", Speed);
			FogMaterial.SetVector("Stretch", new Vector4(1f, 1f, 1f, 1f) + Stretch * 0.01f);
		}
		FogMaterial.SetFloat("InscatteringStartDistance", InscatteringStartDistance);
		Vector3 localScale = FogVolumeGameObject.transform.localScale;
		base.transform.localScale = new Vector3((float)decimal.Round((decimal)localScale.x, 2), localScale.y, localScale.z);
		FogMaterial.SetVector("_BoxMin", localScale * -0.5f);
		FogMaterial.SetVector("_BoxMax", localScale * 0.5f);
		FogMaterial.SetFloat("_Visibility", Visibility);
		GetComponent<Renderer>().sortingOrder = DrawOrder;
	}

	private void ToggleKeyword()
	{
		if (EnableNoise)
		{
			FogMaterial.EnableKeyword("_FOG_VOLUME_NOISE");
		}
		else
		{
			FogMaterial.DisableKeyword("_FOG_VOLUME_NOISE");
		}
		if (EnableInscattering && (bool)Sun)
		{
			FogMaterial.EnableKeyword("_FOG_VOLUME_INSCATTERING");
		}
		else
		{
			FogMaterial.DisableKeyword("_FOG_VOLUME_INSCATTERING");
		}
		switch (Quality)
		{
		case 1:
			FogMaterial.EnableKeyword("_LQ");
			FogMaterial.DisableKeyword("_MQ");
			FogMaterial.DisableKeyword("_HQ");
			break;
		case 2:
			FogMaterial.EnableKeyword("_MQ");
			FogMaterial.DisableKeyword("_LQ");
			FogMaterial.DisableKeyword("_HQ");
			break;
		case 3:
			FogMaterial.EnableKeyword("_HQ");
			FogMaterial.DisableKeyword("_MQ");
			FogMaterial.DisableKeyword("_LQ");
			break;
		}
	}
}
public class csHeadController : MonoBehaviour
{
	public GameObject target;

	public Transform neckBone;

	public float neckTurnSpeed = 5f;

	public float FOV = 80f;

	public float LookDistanceNeck = 3f;

	public float LookDistanceEyes = 4f;

	public Vector3 CorrectionVector = new Vector3(0f, 0f, 0f);

	public Vector3 LookOffset = Vector3.zero;

	public GameObject Eye_Left;

	public GameObject Eye_Right;

	private Vector3 Eye_Flicker;

	private Quaternion m_originalRot;

	private Quaternion m_newRot;

	private void Start()
	{
	}

	private void Update()
	{
		m_originalRot = neckBone.rotation;
	}

	private void LateUpdate()
	{
		UpdateNeck();
		UpdateEyes();
	}

	private void UpdateNeck()
	{
		Vector3 forward = base.transform.forward;
		forward.Normalize();
		float num = Vector3.Distance(neckBone.position, target.transform.position);
		Vector3 to = target.transform.position - neckBone.position;
		to.Normalize();
		float num2 = Vector3.Angle(forward, to);
		Vector3 eulerAngles = ((!(num2 < FOV) || !(num < LookDistanceNeck)) ? Quaternion.LookRotation(neckBone.forward, Vector3.up) : Quaternion.LookRotation(target.transform.position - (neckBone.position + LookOffset), Vector3.up)).eulerAngles;
		eulerAngles.x += CorrectionVector.x;
		eulerAngles.y += CorrectionVector.y;
		eulerAngles.z += CorrectionVector.z;
		Quaternion b = Quaternion.Euler(eulerAngles);
		m_newRot = Quaternion.Slerp(m_originalRot, b, Time.deltaTime * neckTurnSpeed);
		neckBone.rotation = m_newRot;
	}

	private void UpdateEyes()
	{
		if (!Eye_Left || !Eye_Right)
		{
			return;
		}
		Vector3 forward = base.transform.forward;
		forward.Normalize();
		float num = Vector3.Distance(neckBone.position, target.transform.position);
		Vector3 to = target.transform.position - neckBone.position;
		to.Normalize();
		float num2 = Vector3.Angle(forward, to);
		if (Vector3.Distance(neckBone.position, target.transform.position) < LookDistanceEyes && num2 < FOV)
		{
			if (Random.Range(0f, 1f) > 0.95f)
			{
				Eye_Flicker.x = Random.Range(-2, 2);
				Eye_Flicker.z = Random.Range(-2, 2);
				Eye_Flicker.y = Random.Range(-2, 2);
			}
			Eye_Left.transform.LookAt(target.transform);
			Eye_Right.transform.rotation = Eye_Left.transform.rotation;
		}
		else
		{
			if (Random.Range(0f, 1f) > 0.99f)
			{
				Eye_Flicker.x = Random.Range(-20, 20);
				Eye_Flicker.z = Random.Range(-20, 20);
				Eye_Flicker.y = Random.Range(-20, 20);
			}
			Transform obj = Eye_Left.transform;
			Quaternion rotation = base.transform.rotation;
			Eye_Right.transform.rotation = rotation;
			obj.rotation = rotation;
		}
		Eye_Left.transform.Rotate(Eye_Flicker);
		Eye_Right.transform.Rotate(Eye_Flicker);
	}

	private float GetAngle(Vector3 fwd, Vector3 targetDir, Vector3 upDir)
	{
		float num = Vector3.Angle(fwd, targetDir);
		if (AngleDir(fwd, targetDir, upDir) == -1f)
		{
			return 360f - num;
		}
		return num;
	}

	private float AngleDir(Vector3 fwd, Vector3 targetDir, Vector3 up)
	{
		Vector3 lhs = Vector3.Cross(fwd, targetDir);
		float num = Vector3.Dot(lhs, up);
		if (num > 0f)
		{
			return 1f;
		}
		if (num < 0f)
		{
			return -1f;
		}
		return 0f;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class EnableDepthTexture : MonoBehaviour
{
	public bool EnableInEditor = true;

	private void OnEnable()
	{
		GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
	}

	private void OnDisable()
	{
		GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
	}

	private void Update()
	{
	}
}
[ExecuteInEditMode]
public class Lightbeam : MonoBehaviour
{
	public bool IsModifyingMesh;

	public Material DefaultMaterial;

	public LightbeamSettings Settings;

	public float RadiusTop
	{
		get
		{
			return Settings.RadiusTop;
		}
		set
		{
			Settings.RadiusTop = value;
		}
	}

	public float RadiusBottom
	{
		get
		{
			return Settings.RadiusBottom;
		}
		set
		{
			Settings.RadiusBottom = value;
		}
	}

	public float Length
	{
		get
		{
			return Settings.Length;
		}
		set
		{
			Settings.Length = value;
		}
	}

	public int Subdivisions
	{
		get
		{
			return Settings.Subdivisions;
		}
		set
		{
			Settings.Subdivisions = value;
		}
	}

	public int SubdivisionsHeight
	{
		get
		{
			return Settings.SubdivisionsHeight;
		}
		set
		{
			Settings.SubdivisionsHeight = value;
		}
	}

	public void GenerateBeam()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		CombineInstance[] array = new CombineInstance[2];
		array[0].mesh = GenerateMesh(reverseNormals: false);
		array[0].transform = Matrix4x4.identity;
		array[1].mesh = GenerateMesh(reverseNormals: true);
		array[1].transform = Matrix4x4.identity;
		Mesh mesh = new Mesh();
		mesh.CombineMeshes(array);
		if (component.sharedMesh == null)
		{
			component.sharedMesh = new Mesh();
		}
		component.sharedMesh.Clear();
		component.sharedMesh.vertices = mesh.vertices;
		component.sharedMesh.uv = mesh.uv;
		component.sharedMesh.triangles = mesh.triangles;
		component.sharedMesh.tangents = mesh.tangents;
		component.sharedMesh.normals = mesh.normals;
	}

	private Mesh GenerateMesh(bool reverseNormals)
	{
		int num = Settings.Subdivisions * (Settings.SubdivisionsHeight + 1);
		num += Settings.SubdivisionsHeight + 1;
		Vector3[] array = new Vector3[num];
		Vector2[] array2 = new Vector2[num];
		Vector3[] array3 = new Vector3[num];
		int num2 = Settings.Subdivisions * 2 * Settings.SubdivisionsHeight * 3;
		int[] array4 = new int[num2];
		int num3 = Settings.SubdivisionsHeight + 1;
		float num4 = (float)Math.PI * 2f / (float)Settings.Subdivisions;
		float lengthFrac = Settings.Length / (float)Settings.SubdivisionsHeight;
		float num5 = 1f / (float)Settings.Subdivisions;
		float num6 = 1f / (float)Settings.SubdivisionsHeight;
		for (int i = 0; i < Settings.Subdivisions + 1; i++)
		{
			float xAngle = Mathf.Cos((float)i * num4);
			float yAngle = Mathf.Sin((float)i * num4);
			Vector3 vector = CalculateVertex(lengthFrac, xAngle, yAngle, 0, Settings.RadiusTop);
			Vector3 vector2 = CalculateVertex(lengthFrac, xAngle, yAngle, num3 - 1, Settings.RadiusBottom);
			Vector3 vector3 = vector2 - vector;
			for (int j = 0; j < num3; j++)
			{
				float radius = Mathf.Lerp(Settings.RadiusTop, Settings.RadiusBottom, num6 * (float)j);
				Vector3 vector4 = CalculateVertex(lengthFrac, xAngle, yAngle, j, radius);
				Vector3 vector5 = Vector3.Cross(vector3.normalized, new Vector3(vector4.x, 0f, vector4.z).normalized);
				vector5 = ((!reverseNormals) ? Vector3.Cross(vector5.normalized, vector3.normalized) : Vector3.Cross(vector3.normalized, vector5.normalized));
				int num7 = i * num3 + j;
				array[num7] = vector4;
				ref Vector2 reference = ref array2[num7];
				reference = new Vector2(num5 * (float)i, 1f - num6 * (float)j);
				ref Vector3 reference2 = ref array3[num7];
				reference2 = vector5.normalized;
				ref Vector2 reference3 = ref array2[num7];
				reference3 = new Vector2(num5 * (float)i, 1f - num6 * (float)j);
			}
		}
		int num8 = 0;
		for (int k = 0; k < Settings.Subdivisions; k++)
		{
			for (int l = 0; l < num3 - 1; l++)
			{
				int num9 = k * num3 + l;
				int num10 = num9 + 1;
				int num11 = num9 + num3;
				if (num11 >= num)
				{
					num11 %= num;
				}
				if (reverseNormals)
				{
					array4[num8++] = num9;
					array4[num8++] = num10;
					array4[num8++] = num11;
				}
				else
				{
					array4[num8++] = num10;
					array4[num8++] = num9;
					array4[num8++] = num11;
				}
				int num12 = num9 + 1;
				int num13 = num9 + num3;
				if (num13 >= num)
				{
					num13 %= num;
				}
				int num14 = num13 + 1;
				if (reverseNormals)
				{
					array4[num8++] = num12;
					array4[num8++] = num14;
					array4[num8++] = num13;
				}
				else
				{
					array4[num8++] = num12;
					array4[num8++] = num13;
					array4[num8++] = num14;
				}
			}
		}
		Mesh mesh = new Mesh();
		mesh.Clear();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.triangles = array4;
		mesh.normals = array3;
		mesh.RecalculateBounds();
		CalculateMeshTangents(mesh);
		return mesh;
	}

	private static Vector3 CalculateVertex(float lengthFrac, float xAngle, float yAngle, int j, float radius)
	{
		float x = radius * xAngle;
		float z = radius * yAngle;
		return new Vector3(x, (float)j * (lengthFrac * -1f), z);
	}

	private static void CalculateMeshTangents(Mesh mesh)
	{
		int[] triangles = mesh.triangles;
		Vector3[] vertices = mesh.vertices;
		Vector2[] uv = mesh.uv;
		Vector3[] normals = mesh.normals;
		int num = triangles.Length;
		int num2 = vertices.Length;
		Vector3[] array = new Vector3[num2];
		Vector3[] array2 = new Vector3[num2];
		Vector4[] array3 = new Vector4[num2];
		for (long num3 = 0L; num3 < num; num3 += 3)
		{
			long num4 = triangles[num3];
			long num5 = triangles[num3 + 1];
			long num6 = triangles[num3 + 2];
			Vector3 vector = vertices[num4];
			Vector3 vector2 = vertices[num5];
			Vector3 vector3 = vertices[num6];
			Vector2 vector4 = uv[num4];
			Vector2 vector5 = uv[num5];
			Vector2 vector6 = uv[num6];
			float num7 = vector2.x - vector.x;
			float num8 = vector3.x - vector.x;
			float num9 = vector2.y - vector.y;
			float num10 = vector3.y - vector.y;
			float num11 = vector2.z - vector.z;
			float num12 = vector3.z - vector.z;
			float num13 = vector5.x - vector4.x;
			float num14 = vector6.x - vector4.x;
			float num15 = vector5.y - vector4.y;
			float num16 = vector6.y - vector4.y;
			float num17 = 1f / (num13 * num16 - num14 * num15);
			Vector3 vector7 = new Vector3((num16 * num7 - num15 * num8) * num17, (num16 * num9 - num15 * num10) * num17, (num16 * num11 - num15 * num12) * num17);
			Vector3 vector8 = new Vector3((num13 * num8 - num14 * num7) * num17, (num13 * num10 - num14 * num9) * num17, (num13 * num12 - num14 * num11) * num17);
			array[num4] += vector7;
			array[num5] += vector7;
			array[num6] += vector7;
			array2[num4] += vector8;
			array2[num5] += vector8;
			array2[num6] += vector8;
		}
		for (long num18 = 0L; num18 < num2; num18++)
		{
			Vector3 normal = normals[num18];
			Vector3 tangent = array[num18];
			Vector3.OrthoNormalize(ref normal, ref tangent);
			array3[num18].x = tangent.x;
			array3[num18].y = tangent.y;
			array3[num18].z = tangent.z;
			array3[num18].w = ((!(Vector3.Dot(Vector3.Cross(normal, tangent), array2[num18]) < 0f)) ? 1f : (-1f));
		}
		mesh.tangents = array3;
	}
}
public class LightbeamSettings : ScriptableObject
{
	public float RadiusTop = 1f;

	public float RadiusBottom = 5f;

	public float Length = 10f;

	public int Subdivisions = 25;

	public int SubdivisionsHeight = 6;
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class ImageEffects : MonoBehaviour
{
	private static int screenHeight = -1;

	private static int screenwidth = -1;

	private static Texture2D renderTexture;

	public static Texture2D RenderTexture
	{
		get
		{
			if (renderTexture == null)
			{
				renderTexture = new Texture2D(Screen.width, Screen.height, TextureFormat.RGB24, mipmap: false);
			}
			return renderTexture;
		}
	}

	public static bool IsPro<T>(GameObject go, Type type, Shader s) where T : MonoBehaviour
	{
		return UnityEngine.Application.HasProLicense();
	}

	public static void RenderImageEffect(Material m)
	{
		GL.PushMatrix();
		for (int i = 0; i < m.passCount; i++)
		{
			m.SetPass(i);
			GL.LoadOrtho();
			GL.Begin(7);
			GL.Color(new Color(1f, 1f, 1f, 1f));
			GL.MultiTexCoord(0, new Vector3(0f, 0f, 0f));
			GL.Vertex3(0f, 0f, 0f);
			GL.MultiTexCoord(0, new Vector3(0f, 1f, 0f));
			GL.Vertex3(0f, 1f, 0f);
			GL.MultiTexCoord(0, new Vector3(1f, 1f, 0f));
			GL.Vertex3(1f, 1f, 0f);
			GL.MultiTexCoord(0, new Vector3(1f, 0f, 0f));
			GL.Vertex3(1f, 0f, 0f);
			GL.End();
		}
		GL.PopMatrix();
	}

	public void OnPostRender()
	{
		if (Screen.width != screenwidth || Screen.height != screenHeight)
		{
			RenderTexture.Resize(Screen.width, Screen.height, TextureFormat.RGB24, hasMipMap: false);
			screenwidth = Screen.width;
			screenHeight = Screen.height;
		}
		RenderTexture.ReadPixels(new Rect(0f, 0f, Screen.width, Screen.height), 0, 0);
		RenderTexture.Apply();
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Blackfire Studio/Frost")]
public class Frost : MonoBehaviour
{
	private bool isPro;

	public Shader shader;

	public Color color;

	public Texture2D diffuseTex;

	public Texture2D bumpTex;

	public Texture2D coverageTex;

	public float transparency;

	public float refraction;

	public float coverage;

	public float smooth;

	private Material frostMaterial;

	protected Material material
	{
		get
		{
			if (frostMaterial == null)
			{
				frostMaterial = new Material(shader);
				frostMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return frostMaterial;
		}
	}

	private void Start()
	{
		isPro = ImageEffects.IsPro<Frost>(base.gameObject, typeof(Frost), shader);
	}

	private void Update()
	{
		if (!isPro && shader != null)
		{
			material.SetTexture("_MainTex", ImageEffects.RenderTexture);
			material.SetColor("_Color", color);
			material.SetFloat("_Transparency", transparency);
			material.SetFloat("_Refraction", refraction);
			material.SetFloat("_Coverage", coverage);
			material.SetFloat("_Smooth", smooth);
			if (diffuseTex != null)
			{
				material.SetTexture("_DiffuseTex", diffuseTex);
			}
			else
			{
				material.SetTexture("_DiffuseTex", null);
			}
			if (bumpTex != null)
			{
				material.SetTexture("_BumpTex", bumpTex);
			}
			else
			{
				material.SetTexture("_BumpTex", null);
			}
			if (coverageTex != null)
			{
				material.SetTexture("_CoverageTex", coverageTex);
			}
			else
			{
				material.SetTexture("_CoverageTex", null);
			}
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (shader != null)
		{
			material.SetColor("_Color", color);
			material.SetFloat("_Transparency", transparency);
			material.SetFloat("_Refraction", refraction);
			material.SetFloat("_Coverage", coverage);
			material.SetFloat("_Smooth", smooth);
			if (diffuseTex != null)
			{
				material.SetTexture("_DiffuseTex", diffuseTex);
			}
			else
			{
				material.SetTexture("_DiffuseTex", null);
			}
			if (bumpTex != null)
			{
				material.SetTexture("_BumpTex", bumpTex);
			}
			else
			{
				material.SetTexture("_BumpTex", null);
			}
			if (coverageTex != null)
			{
				material.SetTexture("_CoverageTex", coverageTex);
			}
			else
			{
				material.SetTexture("_CoverageTex", null);
			}
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	public void OnPostRender()
	{
		if (!isPro)
		{
			ImageEffects.RenderImageEffect(material);
		}
	}

	private void OnEnable()
	{
		isPro = ImageEffects.IsPro<Frost>(base.gameObject, typeof(Frost), shader);
	}

	private void OnDisable()
	{
		if (frostMaterial != null)
		{
			UnityEngine.Object.DestroyImmediate(frostMaterial);
		}
	}
}
public class FrameCount : MonoBehaviour
{
	public Light directLight;

	public MirrorReflection mirrorReflection;

	public Material oceanMat;

	private float frameCount;

	private int lastFrameCount;

	private int currenFrameCount;

	private float intevalTime = 1f;

	private Color lightColor;

	private GUIStyle style;

	private float reflectionIntensity = 0.1f;

	private float shoreLineIntensity = 1.5f;

	private void Awake()
	{
		mirrorReflection = UnityEngine.Object.FindObjectOfType(typeof(MirrorReflection)) as MirrorReflection;
	}

	private void Start()
	{
		lightColor = directLight.color;
		style = new GUIStyle();
		style.fontSize = 25;
		style.normal.textColor = Color.white;
		InvokeRepeating("GetFrameCount", 0f, intevalTime);
	}

	private void Update()
	{
		directLight.color = lightColor;
		oceanMat.SetFloat("_ReflectionIntensity", reflectionIntensity);
		oceanMat.SetFloat("_ShoreLineIntensity", shoreLineIntensity);
	}

	private void GetFrameCount()
	{
		currenFrameCount = Time.frameCount;
		frameCount = (float)(currenFrameCount - lastFrameCount) / intevalTime;
		lastFrameCount = currenFrameCount;
	}

	private void OnGUI()
	{
		GUILayout.Label("frame:" + frameCount, style);
		GUILayout.Label("press w,s,a,d to move.");
		GUILayout.Label("press UpArrow,LeftArrow,RightArrow,DownArrow to rotate.");
		GUILayout.Label("light red");
		lightColor.r = GUILayout.HorizontalScrollbar(lightColor.r, 0.1f, 0f, 1f, GUILayout.Width(200f));
		GUILayout.Label("light green");
		lightColor.g = GUILayout.HorizontalScrollbar(lightColor.g, 0.1f, 0f, 1f, GUILayout.Width(200f));
		GUILayout.Label("light blue");
		lightColor.b = GUILayout.HorizontalScrollbar(lightColor.b, 0.1f, 0f, 1f, GUILayout.Width(200f));
		GUILayout.Label("Shore line intensity:");
		shoreLineIntensity = GUILayout.HorizontalScrollbar(shoreLineIntensity, 0.2f, 0f, 5f, GUILayout.Width(200f));
		mirrorReflection.enableMirrorReflection = GUILayout.Toggle(mirrorReflection.enableMirrorReflection, "Mirror reflection");
		if (mirrorReflection.enableMirrorReflection)
		{
			GUILayout.Label("Reflection intensity:");
			reflectionIntensity = GUILayout.HorizontalScrollbar(reflectionIntensity, 0.1f, 0f, 1f, GUILayout.Width(200f));
		}
	}
}
public class MirrorReflection : MonoBehaviour
{
	private int m_TextureSize = 512;

	private float m_ClipPlaneOffset = 0.1f;

	public LayerMask m_ReflectLayers = -1;

	private Camera m_ReflectionCamera;

	public static RenderTexture m_ReflectionTexture;

	private int m_OldReflectionTextureSize;

	public Material oceanMaterial;

	public Camera cam;

	public bool enableMirrorReflection = true;

	public bool enableShoreLine = true;

	public float shoreLineDepth = 50f;

	public LayerMask shoreLineDetectLayer;

	private static MirrorReflection _instance;

	public static MirrorReflection instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType(typeof(MirrorReflection)) as MirrorReflection;
			}
			return _instance;
		}
	}

	private void Awake()
	{
		if (oceanMaterial == null)
		{
			oceanMaterial = GetComponent<Renderer>().sharedMaterial;
		}
	}

	private void LateUpdate()
	{
		if (enableMirrorReflection)
		{
			oceanMaterial.shader.maximumLOD = 200;
		}
		else
		{
			oceanMaterial.shader.maximumLOD = 100;
		}
		if (enableMirrorReflection)
		{
			if (cam == null)
			{
				cam = Camera.main.GetComponent<Camera>();
			}
			if ((bool)oceanMaterial && (bool)cam)
			{
				CreateMirrorObjects(cam, out var reflectionCamera);
				Vector3 position = base.transform.position;
				Vector3 up = base.transform.up;
				UpdateCameraModes(cam, reflectionCamera);
				float w = 0f - Vector3.Dot(up, position) - m_ClipPlaneOffset;
				Vector4 plane = new Vector4(up.x, up.y, up.z, w);
				Matrix4x4 reflectionMat = Matrix4x4.zero;
				CalculateReflectionMatrix(ref reflectionMat, plane);
				Vector3 position2 = cam.transform.position;
				Vector3 position3 = reflectionMat.MultiplyPoint(position2);
				reflectionCamera.worldToCameraMatrix = cam.worldToCameraMatrix * reflectionMat;
				Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
				Matrix4x4 projection = cam.projectionMatrix;
				CalculateObliqueMatrix(ref projection, clipPlane);
				reflectionCamera.projectionMatrix = projection;
				reflectionCamera.cullingMask = -17 & m_ReflectLayers.value;
				GL.SetRevertBackfacing(revertBackFaces: true);
				reflectionCamera.transform.position = position3;
				Vector3 eulerAngles = cam.transform.eulerAngles;
				reflectionCamera.transform.eulerAngles = new Vector3(0f, eulerAngles.y, eulerAngles.z);
				GL.SetRevertBackfacing(revertBackFaces: false);
				oceanMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
				Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0.5f, 0.5f, 0.5f), Quaternion.identity, new Vector3(0.5f, 0.5f, 0.5f));
				Vector3 lossyScale = base.transform.lossyScale;
				Matrix4x4 matrix4x2 = base.transform.localToWorldMatrix * Matrix4x4.Scale(new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z));
				matrix4x2 = matrix4x * cam.projectionMatrix * cam.worldToCameraMatrix * matrix4x2;
				oceanMaterial.SetMatrix("_ProjMatrix", matrix4x2);
			}
		}
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		if ((bool)m_ReflectionCamera)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionCamera.gameObject);
		}
	}

	private void UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		if (src.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = dest.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
			}
		}
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}

	private void CreateMirrorObjects(Camera currentCamera, out Camera reflectionCamera)
	{
		if (!m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize)
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			}
			m_ReflectionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
			m_ReflectionTexture.name = "__MirrorReflection" + GetInstanceID();
			m_ReflectionTexture.isPowerOfTwo = true;
			m_ReflectionTexture.hideFlags = HideFlags.DontSave;
			m_OldReflectionTextureSize = m_TextureSize;
		}
		reflectionCamera = m_ReflectionCamera;
		if (!reflectionCamera)
		{
			GameObject gameObject = new GameObject("Mirror Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflectionCamera = gameObject.GetComponent<Camera>();
			reflectionCamera.enabled = true;
			gameObject.hideFlags = HideFlags.DontSave;
			m_ReflectionCamera = reflectionCamera;
			reflectionCamera.gameObject.AddComponent<ReflectionCameraControl>();
		}
		reflectionCamera.depth = currentCamera.depth - 1f;
		reflectionCamera.fieldOfView = currentCamera.fieldOfView;
		reflectionCamera.transform.position = base.transform.position;
		reflectionCamera.transform.rotation = base.transform.rotation;
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * m_ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateObliqueMatrix(ref Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}
}
public class ReflectionCameraControl : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnPostRender()
	{
		GetComponent<Camera>().targetTexture = MirrorReflection.m_ReflectionTexture;
	}
}
public class ShoreLine : MonoBehaviour
{
	private Mesh mesh;

	private Vector3[] vertices;

	private Color[] colors;

	private Transform myTransform;

	private LayerMask layermask;

	private float detectDistance;

	private void Start()
	{
		if (!MirrorReflection.instance.enableShoreLine)
		{
			return;
		}
		detectDistance = MirrorReflection.instance.shoreLineDepth;
		layermask = MirrorReflection.instance.shoreLineDetectLayer;
		myTransform = base.transform;
		mesh = base.transform.GetComponent<MeshFilter>().mesh;
		vertices = mesh.vertices;
		colors = new Color[vertices.Length];
		Vector3 vector = new Vector3(0f, 20f, 0f);
		for (int i = 0; i < vertices.Length; i++)
		{
			ref Vector3 reference = ref vertices[i];
			reference = myTransform.TransformPoint(vertices[i]);
			ref Color reference2 = ref colors[i];
			reference2 = Color.white;
			float num = 1f;
			if (Physics.Raycast(vertices[i] + vector, Vector3.down, out var hitInfo, detectDistance + vector.y, layermask.value))
			{
				float num2 = hitInfo.distance - vector.y;
				if (num2 < 0f)
				{
					num2 = 0f;
				}
				num = num2 / detectDistance;
				num = Mathf.Clamp01(num);
				num = Mathf.Sqrt(num);
				colors[i] *= num;
			}
		}
		mesh.colors = colors;
	}
}
public class TempCameraMove : MonoBehaviour
{
	public float speed = 200f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey("w"))
		{
			base.transform.Translate(Vector3.forward * speed * Time.deltaTime, Space.Self);
		}
		if (Input.GetKey("s"))
		{
			base.transform.Translate(Vector3.back * speed * Time.deltaTime, Space.Self);
		}
		if (Input.GetKey("a"))
		{
			base.transform.Translate(Vector3.left * speed * Time.deltaTime, Space.Self);
		}
		if (Input.GetKey("d"))
		{
			base.transform.Translate(Vector3.right * speed * Time.deltaTime, Space.Self);
		}
		if (Input.GetKey(KeyCode.UpArrow))
		{
			base.transform.Rotate(Vector3.left * 30f * Time.deltaTime, Space.Self);
		}
		if (Input.GetKey(KeyCode.DownArrow))
		{
			base.transform.Rotate(Vector3.right * 30f * Time.deltaTime, Space.Self);
		}
		if (Input.GetKey(KeyCode.LeftArrow))
		{
			base.transform.Rotate(Vector3.down * 30f * Time.deltaTime, Space.World);
		}
		if (Input.GetKey(KeyCode.RightArrow))
		{
			base.transform.Rotate(Vector3.up * 30f * Time.deltaTime, Space.World);
		}
	}
}
public class ATSMobileWindManager : MonoBehaviour
{
	private Color VertexLitTranslucencyColor;

	private float ShadowStrength = 0.8f;

	public Vector4 Wind;

	public float WindFrequency = 0.75f;

	public float GrassWindFrequency = 1.5f;

	private float TreeDistance = 500f;

	private float MediumDetailsDistance = 5f;

	public static Vector4 windForce;

	public Vector4 getWindForce()
	{
		return windForce;
	}

	private void OnDestroy()
	{
		Shader.SetGlobalColor("_Wind", Color.black);
	}

	private void Start()
	{
		Shader.SetGlobalColor("_Wind", Wind);
		Shader.SetGlobalColor("_GrassWind", Wind);
		float[] array = new float[32];
		array[8] = TreeDistance;
		array[9] = MediumDetailsDistance;
		Shader.SetGlobalFloat("_ShadowStrength;", ShadowStrength);
		Shader.SetGlobalFloat("_ShadowOffsetScale;", 1f);
	}

	private void FixedUpdate()
	{
		Color value = Wind * Mathf.Sin(Time.realtimeSinceStartup * WindFrequency);
		value.a = Wind.w;
		Color value2 = Wind * Mathf.Sin(Time.realtimeSinceStartup * GrassWindFrequency);
		value2.a = Wind.w;
		Shader.SetGlobalColor("_Wind", value);
		Shader.SetGlobalColor("_GrassWind", value2);
	}
}
public class TreasureChest : MonoBehaviour
{
	private Transform player;

	public GameObject top;

	public ParticleSystem coinsPS;

	private bool triggered;

	private void Start()
	{
		player = GameObject.Find("OVRPlayerController").transform;
		triggered = false;
	}

	private void Update()
	{
		if ((player.position - base.transform.position).magnitude < 3.7f)
		{
			top.transform.localRotation = Quaternion.Lerp(top.transform.localRotation, Quaternion.Euler(-120f, 0f, 0f), Time.time * 0.01f);
			if (!triggered)
			{
				UnityEngine.Object.Instantiate(coinsPS, base.transform.position, base.transform.localRotation * Quaternion.Euler(-90f, 0f, 0f));
			}
			triggered = true;
		}
	}
}
public class FlashingLight : MonoBehaviour
{
	public float timeSwitch;

	private float nextTime;

	private float timer;

	private Color targetColor;

	private Color currColor;

	private float brightness;

	private void Start()
	{
		nextTime = 0f;
	}

	private void Update()
	{
		timer += Time.deltaTime;
		if (timer > nextTime)
		{
			timer = 0f;
			nextTime = timeSwitch;
			brightness = Random.Range(0f, 0.5f);
			targetColor = new Color(brightness, brightness, brightness);
		}
		currColor = GetComponent<Renderer>().material.GetColor("_Emission");
		GetComponent<Renderer>().material.SetColor("_Emission", Color.Lerp(currColor, targetColor, Time.deltaTime * 2f));
	}
}
namespace OVR
{
	public class TestScript : MonoBehaviour
	{
		[InspectorNote("Sound Setup", "Press '1' to play testSound1 and '2' to play testSound2")]
		public SoundFXRef testSound1;

		public SoundFXRef testSound2;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				testSound1.PlaySoundAt(base.transform.position);
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				testSound2.PlaySoundAt(new Vector3(5f, 0f, 0f));
			}
		}
	}
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			foreach (Transform transform in array)
			{
				if (transform == null)
				{
					Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length > 0)
			{
				int num = Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			return maxPlayingSounds == 0 || playingSoundCount < maxPlayingSounds;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization => theAudioManager != null && theAudioManager.enableSpatializedAudio;

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[maxSoundEmitters + 1];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < maxSoundEmitters + 1; i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			theAudioManager.soundEmitters[idx].time = time;
			return time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((!(staticListenerPosition != null)) ? Vector3.zero : staticListenerPosition.position, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				Debug.LogError(string.Concat("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = ", priority, " TOO MANY PlaySound* calls!"));
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((!(staticListenerPosition != null)) ? Vector3.zero : staticListenerPosition.position, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = ((!soundFX.ospProps.enableSpatialization) ? 0.8f : 1f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, Action onFinished)
		{
			if (emitterIdx >= 0 && emitterIdx < theAudioManager.maxSoundEmitters)
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (emitterIdx >= 0 && emitterIdx < theAudioManager.maxSoundEmitters)
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			return (!(theAudioManager != null)) ? null : theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length => (!(audioSource.clip != null)) ? 0f : audioSource.clip.length;

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType != 0) ? defaultVolume : 0f);
			float end = ((fadeType != 0) ? 0f : defaultVolume);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid => soundClips.Length != 0 && soundClips[0] != null;

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride => (soundGroup == null) ? 1f : soundGroup.volumeOverride;

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = Random.Range(0, soundClips.Length); num == lastIdx; num = Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				return (!(soundGroup.mixerGroup != null)) ? defaultMixerGroup : soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
namespace Oculus.Platform.Samples.EntitlementCheck
{
	public class EntitlementCheck : MonoBehaviour
	{
		public bool exitAppOnFailure = true;

		[CompilerGenerated]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static Action m_UserFailedEntitlementCheck;

		[CompilerGenerated]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static Action m_UserPassedEntitlementCheck;

		public static event Action UserFailedEntitlementCheck
		{
			add
			{
				Action action = EntitlementCheck.m_UserFailedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserFailedEntitlementCheck, (Action)Delegate.Combine(action2, value), action);
				}
				while (action != action2);
			}
			remove
			{
				Action action = EntitlementCheck.m_UserFailedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserFailedEntitlementCheck, (Action)Delegate.Remove(action2, value), action);
				}
				while (action != action2);
			}
		}

		public static event Action UserPassedEntitlementCheck
		{
			add
			{
				Action action = EntitlementCheck.m_UserPassedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserPassedEntitlementCheck, (Action)Delegate.Combine(action2, value), action);
				}
				while (action != action2);
			}
			remove
			{
				Action action = EntitlementCheck.m_UserPassedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserPassedEntitlementCheck, (Action)Delegate.Remove(action2, value), action);
				}
				while (action != action2);
			}
		}

		private void Start()
		{
			try
			{
				if (!Core.IsInitialized())
				{
					Core.Initialize();
				}
				Entitlements.IsUserEntitledToApplication().OnComplete(EntitlementCheckCallback);
			}
			catch
			{
				HandleEntitlementCheckResult(result: false);
			}
		}

		private void EntitlementCheckCallback(Message msg)
		{
			HandleEntitlementCheckResult(!msg.IsError);
		}

		private void HandleEntitlementCheckResult(bool result)
		{
			if (result)
			{
				Debug.Log("Oculus user entitlement check successful.");
				try
				{
					if (EntitlementCheck.UserPassedEntitlementCheck != null)
					{
						EntitlementCheck.UserPassedEntitlementCheck();
					}
					return;
				}
				catch
				{
					Debug.LogError("Suppressed exception in app-provided UserPassedEntitlementCheck() event handler.");
					return;
				}
			}
			try
			{
				if (EntitlementCheck.UserFailedEntitlementCheck != null)
				{
					EntitlementCheck.UserFailedEntitlementCheck();
				}
			}
			catch
			{
				Debug.LogError("Suppressed exception in app-provided UserFailedEntitlementCheck() event handler.");
			}
			if (exitAppOnFailure)
			{
				Debug.LogError("Oculus user entitlement check failed. Exiting now.");
				UnityEngine.Application.Quit();
			}
			else
			{
				Debug.LogError("Oculus user entitlement check failed.");
			}
		}
	}
}
namespace Oculus.Platform.Samples.NetChat
{
	internal enum states
	{
		NOT_INIT,
		IDLE,
		REQUEST_FIND,
		FINDING_ROOM,
		REQUEST_CREATE,
		REQUEST_JOIN,
		REQUEST_LEAVE,
		IN_EMPTY_ROOM,
		IN_FULL_ROOM
	}
	public static class Constants
	{
		public const int BUFFER_SIZE = 512;

		public const string BOUT_POOL = "bout_pool";

		public const string FILTER_POOL = "filter_pool";
	}
	public class chatPacket
	{
		public int packetID { get; set; }

		public string textString { get; set; }

		public byte[] Serialize()
		{
			using MemoryStream memoryStream = new MemoryStream();
			using (BinaryWriter binaryWriter = new BinaryWriter(memoryStream))
			{
				if (textString.Length > 512)
				{
					textString = textString.Substring(0, 511);
				}
				binaryWriter.Write(packetID);
				binaryWriter.Write(textString.ToCharArray());
				binaryWriter.Write('\0');
			}
			return memoryStream.ToArray();
		}

		public static chatPacket Deserialize(byte[] data)
		{
			chatPacket chatPacket2 = new chatPacket();
			using MemoryStream input = new MemoryStream(data);
			using BinaryReader binaryReader = new BinaryReader(input);
			chatPacket2.packetID = binaryReader.ReadInt32();
			chatPacket2.textString = Encoding.Default.GetString(binaryReader.ReadBytes(512));
			return chatPacket2;
		}
	}
	public class DataEntry : MonoBehaviour
	{
		public Text dataOutput;

		private states currentState;

		private User localUser;

		private User remoteUser;

		private Room currentRoom;

		private int lastPacketID;

		private bool ratedMatchStarted;

		private void Start()
		{
			currentState = states.NOT_INIT;
			localUser = null;
			remoteUser = null;
			currentRoom = null;
			lastPacketID = 0;
			ratedMatchStarted = false;
			Core.Initialize();
			Rooms.SetUpdateNotificationCallback(updateRoom);
			Matchmaking.SetMatchFoundNotificationCallback(foundMatch);
			checkEntitlement();
		}

		private void Update()
		{
			string text = GetComponent<InputField>().text;
			if (Input.GetKey(KeyCode.Return))
			{
				if (text != string.Empty)
				{
					SubmitCommand(text);
				}
				GetComponent<InputField>().text = string.Empty;
			}
			processNetPackets();
			Request.RunCallbacks();
		}

		private void SubmitCommand(string command)
		{
			string[] array = command.Split('!');
			if (array.Length <= 0)
			{
				return;
			}
			switch (array[0])
			{
			case "c":
				requestCreateRoom();
				break;
			case "d":
				requestCreateFilterRoom();
				break;
			case "f":
				requestFindMatch();
				break;
			case "g":
				requestFindRoom();
				break;
			case "i":
				requestFindFilteredRoom();
				break;
			case "s":
				if (array.Length > 1)
				{
					sendChat(array[1]);
				}
				break;
			case "l":
				requestLeaveRoom();
				break;
			case "1":
				requestStartRatedMatch();
				break;
			case "2":
				requestReportResults();
				break;
			default:
				printOutputLine("Invalid Command");
				break;
			}
		}

		private void printOutputLine(string newLine)
		{
			dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
		}

		private void checkEntitlement()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(getEntitlementCallback);
		}

		private void getEntitlementCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("You are entitled to use this app.");
				Users.GetLoggedInUser().OnComplete(init);
			}
			else
			{
				printOutputLine("You are NOT entitled to use this app.");
			}
		}

		private void init(Message<User> msg)
		{
			if (!msg.IsError)
			{
				User data = msg.Data;
				localUser = data;
				currentState = states.IDLE;
			}
			else
			{
				printOutputLine("Received get current user error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
				Users.GetLoggedInUser().OnComplete(init);
				currentState = states.NOT_INIT;
			}
		}

		private void requestCreateRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
				printOutputLine("Trying to create a matchmaking room");
				Matchmaking.CreateAndEnqueueRoom("filter_pool", 8u, subscribeToUpdates: true).OnComplete(createRoomResponse);
				currentState = states.REQUEST_CREATE;
				break;
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void createRoomResponse(Message<MatchmakingEnqueueResultAndRoom> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received create matchmaking room success");
				printOutputLine("RoomID: " + (currentRoom = msg.Data.Room).ID);
				currentState = states.IN_EMPTY_ROOM;
			}
			else
			{
				printOutputLine("Received create matchmaking room Error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
				printOutputLine("You can only create a matchmaking room for pools of mode Room.  Make sure you have an appropriate pool setup on the Developer portal.\n");
				currentState = states.IDLE;
			}
		}

		private void requestCreateFilterRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.\n");
				break;
			case states.IDLE:
			{
				printOutputLine("Trying to create a matchmaking room");
				Matchmaking.CustomQuery customQuery = new Matchmaking.CustomQuery();
				customQuery.criteria = null;
				customQuery.data = new Dictionary<string, object>();
				customQuery.data.Add("game_type_name", "CTF");
				customQuery.data.Add("map_name", "Really_Big_Map");
				Matchmaking.CreateAndEnqueueRoom("filter_pool", 8u, subscribeToUpdates: true, customQuery).OnComplete(createRoomResponse);
				currentState = states.REQUEST_CREATE;
				break;
			}
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.\n");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.\n");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.\n");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.\n");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.\n");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.\n");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.\n");
				break;
			default:
				printOutputLine("You have hit an unknown state.\n");
				break;
			}
		}

		private void requestFindRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
				printOutputLine("\nTrying to find a matchmaking room\n");
				Matchmaking.Enqueue("filter_pool").OnComplete(searchingStarted);
				currentState = states.REQUEST_FIND;
				break;
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void requestFindFilteredRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			{
				printOutputLine("Trying to find a matchmaking room");
				Matchmaking.CustomQuery customQuery = new Matchmaking.CustomQuery();
				Matchmaking.CustomQuery.Criterion[] array = new Matchmaking.CustomQuery.Criterion[2];
				array[0].key = "map";
				array[0].importance = MatchmakingCriterionImportance.Required;
				array[0].parameters = new Dictionary<string, object>();
				array[0].parameters.Add("map_param_1", "Really_Big_Map");
				array[0].parameters.Add("map_param_2", "Big_Map");
				array[1].key = "game_type";
				array[1].importance = MatchmakingCriterionImportance.Required;
				array[1].parameters = new Dictionary<string, object>();
				array[1].parameters.Add("game_type_param", "CTF");
				customQuery.criteria = array;
				customQuery.data = null;
				Matchmaking.Enqueue("filter_pool", customQuery);
				currentState = states.REQUEST_FIND;
				break;
			}
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void foundMatch(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received find match success. We are now going to request to join the room.");
				Room data = msg.Data;
				Rooms.Join(data.ID, subscribeToUpdates: true).OnComplete(joinRoomResponse);
				currentState = states.REQUEST_JOIN;
			}
			else
			{
				printOutputLine("Received find match error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
				currentState = states.IDLE;
			}
		}

		private void joinRoomResponse(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received join room success.");
				currentRoom = msg.Data;
				currentState = states.IN_EMPTY_ROOM;
				if (currentRoom.UsersOptional == null)
				{
					return;
				}
				{
					foreach (User item in currentRoom.UsersOptional)
					{
						if (item.ID != localUser.ID)
						{
							remoteUser = item;
							currentState = states.IN_FULL_ROOM;
						}
					}
					return;
				}
			}
			printOutputLine("Received join room error");
			printOutputLine("It's possible the room filled up before you could join it.");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
			currentState = states.IDLE;
		}

		private void requestFindMatch()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
				printOutputLine("Trying to find a matchmaking room");
				Matchmaking.Enqueue("bout_pool").OnComplete(searchingStarted);
				currentState = states.REQUEST_FIND;
				break;
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void searchingStarted(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Searching for a match successfully started");
				currentState = states.REQUEST_FIND;
			}
			else
			{
				printOutputLine("Searching for a match error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void updateRoom(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received room update notification");
				Room data = msg.Data;
				if (currentState == states.IN_EMPTY_ROOM)
				{
					if (data.UsersOptional == null)
					{
						return;
					}
					{
						foreach (User item in data.UsersOptional)
						{
							if (item.ID != localUser.ID)
							{
								remoteUser = item;
								currentState = states.IN_FULL_ROOM;
							}
						}
						return;
					}
				}
				if (data.UsersOptional != null && data.UsersOptional.Count == 1)
				{
					printOutputLine("User ID: " + remoteUser.ID + "has left");
					remoteUser = null;
					currentState = states.IN_EMPTY_ROOM;
				}
			}
			else
			{
				printOutputLine("Received room update error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void sendChat(string chatMessage)
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
			case states.REQUEST_LEAVE:
			case states.IN_EMPTY_ROOM:
				printOutputLine("You need to be in a room with another player to send a message.");
				break;
			case states.IN_FULL_ROOM:
			{
				chatPacket chatPacket2 = new chatPacket();
				lastPacketID++;
				chatPacket2.packetID = lastPacketID;
				chatPacket2.textString = chatMessage;
				Net.SendPacket(remoteUser.ID, chatPacket2.Serialize(), SendPolicy.Reliable);
				break;
			}
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void processNetPackets()
		{
			for (Packet packet = Net.ReadPacket(); packet != null; packet = Net.ReadPacket())
			{
				byte[] array = new byte[packet.Size];
				packet.ReadBytes(array);
				chatPacket chatPacket2 = chatPacket.Deserialize(array);
				printOutputLine("Chat Text: " + chatPacket2.textString.ToString());
				printOutputLine("Received Packet from UserID: " + packet.SenderID);
				printOutputLine("Received Packet ID: " + chatPacket2.packetID);
			}
		}

		private void requestLeaveRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
				printOutputLine("You are currently not in a room to leave.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.IN_EMPTY_ROOM:
			case states.IN_FULL_ROOM:
				printOutputLine("Trying to leave room.");
				Rooms.Leave(currentRoom.ID).OnComplete(leaveRoomResponse);
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void leaveRoomResponse(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("We were able to leave the room");
				currentRoom = null;
				remoteUser = null;
				currentState = states.IDLE;
			}
			else
			{
				printOutputLine("Leave room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void requestStartRatedMatch()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
			case states.REQUEST_LEAVE:
			case states.IN_EMPTY_ROOM:
				printOutputLine("You need to be in a room with another player to start a rated match.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("Trying to start a rated match.  This call should be made once a rated match begins so we will be able to submit results after the game is done.");
				Matchmaking.StartMatch(currentRoom.ID).OnComplete(startRatedMatchResponse);
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void startRatedMatchResponse(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Started a rated match");
				ratedMatchStarted = true;
			}
			else
			{
				Error error = msg.GetError();
				printOutputLine("Received starting rated match failure: " + error.Message);
				printOutputLine("Your matchmaking pool needs to have a skill pool associated with it to play rated matches");
			}
		}

		private void requestReportResults()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
			case states.REQUEST_LEAVE:
				printOutputLine("You need to be in a room with another player to report results on a rated match.");
				break;
			case states.IN_EMPTY_ROOM:
			case states.IN_FULL_ROOM:
				if (ratedMatchStarted)
				{
					printOutputLine("Submitting rated match results.");
					Dictionary<string, int> dictionary = new Dictionary<string, int>();
					dictionary.Add(localUser.ID.ToString(), 1);
					dictionary.Add(remoteUser.ID.ToString(), 2);
					Matchmaking.ReportResultsInsecure(currentRoom.ID, dictionary).OnComplete(reportResultsResponse);
				}
				else
				{
					printOutputLine("You can't report results unless you've already started a rated match");
				}
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void reportResultsResponse(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Rated match results reported. Now attempting to leave room.");
				ratedMatchStarted = false;
				requestLeaveRoom();
			}
			else
			{
				Error error = msg.GetError();
				printOutputLine("Received reporting rated match failure: " + error.Message);
			}
		}
	}
}
namespace Oculus.Platform.Samples.SimplePlatformSample
{
	public class DataEntry : MonoBehaviour
	{
		public Text dataOutput;

		private void Start()
		{
			Core.Initialize();
			checkEntitlement();
		}

		private void Update()
		{
			string text = GetComponent<InputField>().text;
			if (Input.GetKey(KeyCode.Return))
			{
				if (text != string.Empty)
				{
					SubmitCommand(text);
				}
				GetComponent<InputField>().text = string.Empty;
			}
			Request.RunCallbacks();
		}

		private void SubmitCommand(string command)
		{
			string[] array = command.Split(' ');
			if (array.Length <= 0)
			{
				return;
			}
			switch (array[0])
			{
			case "p":
				if (array.Length > 2)
				{
					createAndJoinPrivateRoom(array[1], array[2]);
				}
				break;
			case "c":
				getCurrentRoom();
				break;
			case "g":
				if (array.Length > 1)
				{
					getRoom(array[1]);
				}
				break;
			case "j":
				if (array.Length > 1)
				{
					joinRoom(array[1]);
				}
				break;
			case "l":
				if (array.Length > 1)
				{
					leaveRoom(array[1]);
				}
				break;
			case "k":
				if (array.Length > 2)
				{
					kickUser(array[1], array[2]);
				}
				break;
			case "m":
				getLoggedInUser();
				break;
			case "u":
				if (array.Length > 1)
				{
					getUser(array[1]);
				}
				break;
			case "d":
				getLoggedInFriends();
				break;
			case "i":
				getInvitableUsers();
				break;
			case "o":
				if (array.Length > 2)
				{
					inviteUser(array[1], array[2]);
				}
				break;
			case "s":
				if (array.Length > 2)
				{
					setRoomDescription(array[1], array[2]);
				}
				break;
			case "w":
				if (array.Length > 3)
				{
					updateRoomDataStore(array[1], array[2], array[3]);
				}
				break;
			case "n":
				getUserNonce();
				break;
			case "e":
				checkEntitlement();
				break;
			case "a":
				if (array.Length > 1)
				{
					getAchievementDefinition(array[1]);
				}
				break;
			case "b":
				if (array.Length > 1)
				{
					getAchievementProgress(array[1]);
				}
				break;
			case "3":
				if (array.Length > 1)
				{
					unlockAchievement(array[1]);
				}
				break;
			case "4":
				if (array.Length > 2)
				{
					addCountAchievement(array[1], array[2]);
				}
				break;
			case "5":
				if (array.Length > 2)
				{
					addFieldsAchievement(array[1], array[2]);
				}
				break;
			case "1":
				if (array.Length > 2)
				{
					writeLeaderboardEntry(array[1], array[2]);
				}
				break;
			case "2":
				if (array.Length > 1)
				{
					getLeaderboardEntries(array[1]);
				}
				break;
			default:
				printOutputLine("Invalid Command");
				break;
			}
		}

		private void getLeaderboardEntries(string leaderboardName)
		{
			Leaderboards.GetEntries(leaderboardName, 10, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(leaderboardGetCallback);
		}

		private void writeLeaderboardEntry(string leaderboardName, string value)
		{
			byte[] extraData = new byte[4] { 84, 101, 115, 116 };
			Leaderboards.WriteEntry(leaderboardName, Convert.ToInt32(value), extraData).OnComplete(leaderboardWriteCallback);
		}

		private void addFieldsAchievement(string achievementName, string fields)
		{
			Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
		}

		private void addCountAchievement(string achievementName, string count)
		{
			Achievements.AddCount(achievementName, Convert.ToUInt64(count)).OnComplete(achievementCountCallback);
		}

		private void unlockAchievement(string achievementName)
		{
			Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
		}

		private void getAchievementProgress(string achievementName)
		{
			Achievements.GetProgressByName(new string[1] { achievementName }).OnComplete(achievementProgressCallback);
		}

		private void getAchievementDefinition(string achievementName)
		{
			Achievements.GetDefinitionsByName(new string[1] { achievementName }).OnComplete(achievementDefinitionCallback);
		}

		private void checkEntitlement()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(getEntitlementCallback);
		}

		private void getUserNonce()
		{
			printOutputLine("Trying to get user nonce");
			Users.GetUserProof().OnComplete(userProofCallback);
		}

		private void createAndJoinPrivateRoom(string joinPolicy, string maxUsers)
		{
			printOutputLine("Trying to create and join private room");
			Rooms.CreateAndJoinPrivate((RoomJoinPolicy)Convert.ToUInt32(joinPolicy), Convert.ToUInt32(maxUsers)).OnComplete(createAndJoinPrivateRoomCallback);
		}

		private void getCurrentRoom()
		{
			printOutputLine("Trying to get current room");
			Rooms.GetCurrent().OnComplete(getCurrentRoomCallback);
		}

		private void getRoom(string roomID)
		{
			printOutputLine("Trying to get room " + roomID);
			Rooms.Get(Convert.ToUInt64(roomID)).OnComplete(getCurrentRoomCallback);
		}

		private void joinRoom(string roomID)
		{
			printOutputLine("Trying to join room " + roomID);
			Rooms.Join(Convert.ToUInt64(roomID), subscribeToUpdates: true).OnComplete(joinRoomCallback);
		}

		private void leaveRoom(string roomID)
		{
			printOutputLine("Trying to leave room " + roomID);
			Rooms.Leave(Convert.ToUInt64(roomID)).OnComplete(leaveRoomCallback);
		}

		private void kickUser(string roomID, string userID)
		{
			printOutputLine("Trying to kick user " + userID + " from room " + roomID);
			Rooms.KickUser(Convert.ToUInt64(roomID), Convert.ToUInt64(userID), 10).OnComplete(getCurrentRoomCallback);
		}

		private void getLoggedInUser()
		{
			printOutputLine("Trying to get currently logged in user");
			Users.GetLoggedInUser().OnComplete(getUserCallback);
		}

		private void getUser(string userID)
		{
			printOutputLine("Trying to get user " + userID);
			Users.Get(Convert.ToUInt64(userID)).OnComplete(getUserCallback);
		}

		private void getLoggedInFriends()
		{
			printOutputLine("Trying to get friends of logged in user");
			Users.GetLoggedInUserFriends().OnComplete(getFriendsCallback);
		}

		private void getInvitableUsers()
		{
			printOutputLine("Trying to get invitable users");
			Rooms.GetInvitableUsers().OnComplete(getInvitableUsersCallback);
		}

		private void inviteUser(string roomID, string inviteToken)
		{
			printOutputLine("Trying to invite token " + inviteToken + " to room " + roomID);
			Rooms.InviteUser(Convert.ToUInt64(roomID), inviteToken).OnComplete(inviteUserCallback);
		}

		private void setRoomDescription(string roomID, string description)
		{
			printOutputLine("Trying to set description " + description + " to room " + roomID);
			Rooms.SetDescription(Convert.ToUInt64(roomID), description).OnComplete(getCurrentRoomCallback);
		}

		private void updateRoomDataStore(string roomID, string key, string value)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary.Add(key, value);
			printOutputLine("Trying to set k=" + key + " v=" + value + " for room " + roomID);
			Rooms.UpdateDataStore(Convert.ToUInt64(roomID), dictionary).OnComplete(getCurrentRoomCallback);
		}

		private void printOutputLine(string newLine)
		{
			dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
		}

		private void outputRoomDetails(Room room)
		{
			printOutputLine("Room ID: " + room.ID + ", AppID: " + room.ApplicationID + ", Description: " + room.Description);
			int num = ((room.UsersOptional != null) ? room.UsersOptional.Count : 0);
			printOutputLine("MaxUsers: " + room.MaxUsers.ToString() + " Users in room: " + num);
			if (room.OwnerOptional != null)
			{
				printOutputLine("Room owner: " + room.OwnerOptional.ID + " " + room.OwnerOptional.OculusID);
			}
			printOutputLine("Join Policy: " + room.JoinPolicy);
			printOutputLine("Room Type: " + room.Type);
			Message.MessageType.Matchmaking_Enqueue.GetHashCode();
		}

		private void outputUserArray(UserList users)
		{
			foreach (User user in users)
			{
				printOutputLine("User: " + user.ID + " " + user.OculusID + " " + user.Presence + " " + user.InviteToken);
			}
		}

		private void userProofCallback(Message<UserProof> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received user nonce generation success");
				UserProof data = msg.Data;
				printOutputLine("Nonce: " + data.Value);
			}
			else
			{
				printOutputLine("Received user nonce generation error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getEntitlementCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("You are entitled to use this app.");
			}
			else
			{
				printOutputLine("You are NOT entitled to use this app.");
			}
		}

		private void leaderboardGetCallback(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Leaderboard entry get success.");
				LeaderboardEntryList data = msg.Data;
				{
					foreach (LeaderboardEntry item in data)
					{
						printOutputLine(item.Rank + ". " + item.User.OculusID + " " + item.Score + " " + item.Timestamp);
					}
					return;
				}
			}
			printOutputLine("Received leaderboard get error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void leaderboardWriteCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Leaderboard entry write success.");
				Message<bool> message = (Message<bool>)msg;
				if (message.Data)
				{
					printOutputLine("Score updated.");
				}
				else
				{
					printOutputLine("Score NOT updated.");
				}
			}
			else
			{
				printOutputLine("Received leaderboard write error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void achievementFieldsCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement fields added.");
				return;
			}
			printOutputLine("Received achievement fields add error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementCountCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement count added.");
				return;
			}
			printOutputLine("Received achievement count add error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementUnlockCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement unlocked");
				return;
			}
			printOutputLine("Received achievement unlock error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementProgressCallback(Message<AchievementProgressList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement progress success");
				AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
				{
					foreach (AchievementProgress item in achievementProgressList)
					{
						if (item.IsUnlocked)
						{
							printOutputLine("Achievement Unlocked");
						}
						else
						{
							printOutputLine("Achievement Locked");
						}
						printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
						printOutputLine("Current Count: " + item.Count);
					}
					return;
				}
			}
			printOutputLine("Received achievement progress error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementDefinitionCallback(Message<AchievementDefinitionList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement definitions success");
				AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
				{
					foreach (AchievementDefinition item in achievementDefinitions)
					{
						switch (item.Type)
						{
						case AchievementType.Simple:
							printOutputLine("Achievement Type: Simple");
							break;
						case AchievementType.Bitfield:
							printOutputLine("Achievement Type: Bitfield");
							printOutputLine("Bitfield Length: " + item.BitfieldLength);
							printOutputLine("Target: " + item.Target);
							break;
						case AchievementType.Count:
							printOutputLine("Achievement Type: Count");
							printOutputLine("Target: " + item.Target);
							break;
						default:
							printOutputLine("Achievement Type: Unknown");
							break;
						}
					}
					return;
				}
			}
			printOutputLine("Received achievement definitions error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void createAndJoinPrivateRoomCallback(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received create and join room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received create and join room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getCurrentRoomCallback(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received get room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void joinRoomCallback(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received join room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received join room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void leaveRoomCallback(Message<Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received leave room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received leave room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getUserCallback(Message<User> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get user success");
				User data = msg.Data;
				printOutputLine("User: " + data.ID + " " + data.OculusID + " " + data.Presence + " " + data.InviteToken);
			}
			else
			{
				printOutputLine("Received get user error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getFriendsCallback(Message<UserList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get friends success");
				UserList data = msg.Data;
				outputUserArray(data);
			}
			else
			{
				printOutputLine("Received get friends error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getInvitableUsersCallback(Message<UserList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get invitable users success");
				UserList data = msg.Data;
				outputUserArray(data);
			}
			else
			{
				printOutputLine("Received get invitable users error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void inviteUserCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received invite user success");
				return;
			}
			printOutputLine("Received invite user error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}
	}
}
namespace Oculus.Platform.Samples.VrBoardGame
{
	public class BoardPosition : MonoBehaviour
	{
		[SerializeField]
		[Range(0f, 2f)]
		public int x;

		[SerializeField]
		[Range(0f, 2f)]
		public int y;
	}
	public class EyeCamera : MonoBehaviour
	{
		[SerializeField]
		private EventSystem m_eventSystem;

		[SerializeField]
		private GameController m_gameController;

		[SerializeField]
		private SphereCollider m_gazeTracker;

		private Button m_currentButton;

		private GamePiece m_currentPiece;

		private BoardPosition m_boardPosition;

		private void Update()
		{
			Button button = null;
			GamePiece gamePiece = null;
			BoardPosition boardPosition = null;
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 50f))
			{
				button = hitInfo.collider.GetComponent<Button>();
				gamePiece = hitInfo.collider.GetComponent<GamePiece>();
				boardPosition = hitInfo.collider.GetComponent<BoardPosition>();
			}
			if (m_currentButton != button)
			{
				if (m_eventSystem != null)
				{
					m_eventSystem.SetSelectedGameObject(null);
				}
				m_currentButton = button;
				if (m_currentButton != null)
				{
					m_currentButton.Select();
				}
			}
			if (m_currentPiece != gamePiece)
			{
				if (m_currentPiece != null)
				{
					m_gameController.StoppedLookingAtPiece();
				}
				m_currentPiece = gamePiece;
				if (m_currentPiece != null)
				{
					m_gameController.StartedLookingAtPiece(m_currentPiece);
				}
			}
			if (m_boardPosition != boardPosition)
			{
				m_boardPosition = boardPosition;
				if (m_boardPosition != null)
				{
					m_gameController.StartedLookingAtPosition(m_boardPosition);
				}
			}
			if (hitInfo.collider == m_gazeTracker)
			{
				m_gameController.ClearProposedMove();
			}
			if (Input.GetButton("Fire2"))
			{
				float axis = Input.GetAxis("Mouse Y");
				float axis2 = Input.GetAxis("Mouse X");
				base.transform.rotation *= Quaternion.AngleAxis(axis2, Vector3.up);
				base.transform.rotation *= Quaternion.AngleAxis(0f - axis, Vector3.right);
				Vector3 eulerAngles = base.transform.eulerAngles;
				eulerAngles.z = 0f;
				base.transform.eulerAngles = eulerAngles;
			}
		}
	}
	public class GameBoard : MonoBehaviour
	{
		private struct PositionInfo
		{
			public GameObject piece;

			public int pieceOwner;

			public int powerPieceOwner;
		}

		public const int LENGTH_X = 3;

		public const int LENGTH_Y = 3;

		public const int MAX_PLAYERS = 2;

		[SerializeField]
		private Color[] m_playerColors = new Color[2];

		[SerializeField]
		private Color m_proposedMoveColor;

		private int[] m_scores = new int[2];

		[SerializeField]
		private BoardPosition[] m_positions = new BoardPosition[9];

		private readonly PositionInfo[,] m_pieces = new PositionInfo[3, 3];

		public void Reset()
		{
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					if (m_pieces[i, j].piece != null)
					{
						UnityEngine.Object.Destroy(m_pieces[i, j].piece);
						m_pieces[i, j].piece = null;
						m_pieces[i, j].pieceOwner = -1;
						m_pieces[i, j].powerPieceOwner = -1;
					}
				}
			}
		}

		public bool IsFull()
		{
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					if (m_pieces[i, j].piece == null)
					{
						return false;
					}
				}
			}
			return true;
		}

		public bool CanPlayerMoveToPostion(int x, int y)
		{
			return m_pieces[x, y].piece == null;
		}

		public bool CanPlayerPowerUpPosition(int x, int y)
		{
			return m_pieces[x, y].piece != null;
		}

		public void AddPiece(int player, GameObject prefab, int x, int y)
		{
			BoardPosition boardPosition = m_positions[x * 3 + y];
			GamePiece gamePiece = Create(prefab, boardPosition.gameObject, boardPosition, Vector3.zero);
			gamePiece.GetComponent<Renderer>().material.color = m_playerColors[player];
			m_pieces[x, y].piece = gamePiece.gameObject;
			m_pieces[x, y].pieceOwner = player;
			m_pieces[x, y].powerPieceOwner = -1;
			UpdateScores();
		}

		public GamePiece AddProposedPiece(GameObject prefab, BoardPosition pos)
		{
			GamePiece gamePiece = Create(prefab, pos.gameObject, pos, Vector3.zero);
			gamePiece.GetComponent<Renderer>().material.color = m_proposedMoveColor;
			return gamePiece;
		}

		public void AddPowerPiece(int player, GameObject prefab, int x, int y)
		{
			GamePiece gamePiece = Create(prefab, m_pieces[x, y].piece, m_positions[x * 3 + y], 0.2f * Vector3.up);
			gamePiece.GetComponent<Renderer>().material.color = m_playerColors[player];
			m_pieces[x, y].powerPieceOwner = player;
			UpdateScores();
		}

		public GamePiece AddProposedPowerPiece(GameObject prefab, BoardPosition pos)
		{
			GamePiece gamePiece = Create(prefab, m_pieces[pos.x, pos.y].piece, pos, 0.2f * Vector3.up);
			gamePiece.GetComponent<Renderer>().material.color = m_proposedMoveColor;
			return gamePiece;
		}

		private GamePiece Create(GameObject prefab, GameObject parent, BoardPosition pos, Vector3 off)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(prefab, parent.transform);
			gameObject.transform.position = parent.transform.position + off;
			gameObject.GetComponent<GamePiece>().Position = pos;
			return gameObject.GetComponent<GamePiece>();
		}

		public int GetPlayerScore(int player)
		{
			return m_scores[player];
		}

		private void UpdateScores()
		{
			for (int i = 0; i < 2; i++)
			{
				m_scores[i] = 0;
			}
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					if (!(m_pieces[j, k].piece != null))
					{
						continue;
					}
					m_scores[m_pieces[j, k].pieceOwner] += 10;
					if (m_pieces[j, k].powerPieceOwner < 0)
					{
						continue;
					}
					for (int l = j - 1; l <= j + 1; l++)
					{
						for (int m = k - 1; m <= k + 1; m++)
						{
							if (l >= 0 && m >= 0 && l < 3 && m < 3)
							{
								int num = ((m_pieces[j, k].pieceOwner != m_pieces[j, k].powerPieceOwner) ? (-10) : 10);
								m_scores[m_pieces[j, k].powerPieceOwner] += num;
							}
						}
					}
				}
			}
		}
	}
	public class GameController : MonoBehaviour
	{
		private enum GameState
		{
			None,
			PracticingMyTurn,
			PracticingAiTurn,
			OnlineMatchMyTurn,
			OnlineMatchRemoteTurn
		}

		[SerializeField]
		private MatchmakingManager m_matchmaking;

		[SerializeField]
		private GameBoard m_board;

		[SerializeField]
		private GamePiece m_pieceA;

		[SerializeField]
		private GamePiece m_pieceB;

		[SerializeField]
		private GamePiece m_powerPiece;

		[SerializeField]
		private Color m_unusableColor;

		[SerializeField]
		private Color m_unselectedColor;

		[SerializeField]
		private Color m_selectedColor;

		[SerializeField]
		private Color m_highlightedColor;

		[SerializeField]
		private Text m_ballCountText;

		[SerializeField]
		private Text m_player0Text;

		[SerializeField]
		private Text m_player1Text;

		private GameState m_state;

		private GamePiece m_interestedPiece;

		private GamePiece m_selectedPiece;

		private GamePiece m_proposedPiece;

		private uint m_powerBallcount;

		private string m_opponentName;

		private void Start()
		{
			TransitionToState(GameState.None);
			UpdateScores();
		}

		private void Update()
		{
			PerFrameStateUpdate();
		}

		private void TransitionToState(GameState state)
		{
			m_state = state;
			UpdateGamePieceColors();
		}

		private void TransitionToNextState()
		{
			if (!m_board.IsFull())
			{
				switch (m_state)
				{
				case GameState.PracticingAiTurn:
					TransitionToState(GameState.PracticingMyTurn);
					break;
				case GameState.PracticingMyTurn:
					TransitionToState(GameState.PracticingAiTurn);
					break;
				case GameState.OnlineMatchRemoteTurn:
					TransitionToState(GameState.OnlineMatchMyTurn);
					break;
				case GameState.OnlineMatchMyTurn:
					TransitionToState(GameState.OnlineMatchRemoteTurn);
					break;
				}
			}
			else
			{
				GameState state = m_state;
				if (state == GameState.OnlineMatchRemoteTurn || state == GameState.OnlineMatchMyTurn)
				{
					m_matchmaking.EndMatch(m_board.GetPlayerScore(0), m_board.GetPlayerScore(1));
				}
				TransitionToState(GameState.None);
			}
		}

		private void PerFrameStateUpdate()
		{
			switch (m_state)
			{
			case GameState.PracticingAiTurn:
				if (Random.Range(1, 100) < 3)
				{
					MakeAIMove(1);
				}
				break;
			case GameState.PracticingMyTurn:
			case GameState.OnlineMatchMyTurn:
				if (Input.GetButton("Fire1"))
				{
					TrySelectPiece();
					TryPlacePiece();
				}
				break;
			}
		}

		public void PracticeButtonPressed()
		{
			m_opponentName = "* AI *";
			GameState state = m_state;
			if (state == GameState.OnlineMatchMyTurn || state == GameState.OnlineMatchRemoteTurn)
			{
				m_matchmaking.EndMatch(m_board.GetPlayerScore(0), m_board.GetPlayerScore(1));
			}
			m_board.Reset();
			if (Random.Range(0, 2) == 1)
			{
				TransitionToState(GameState.PracticingMyTurn);
			}
			else
			{
				TransitionToState(GameState.PracticingAiTurn);
			}
			UpdateScores();
		}

		private void MakeAIMove(int player)
		{
			bool flag = false;
			int num = Random.Range(0, 2);
			int num2 = Random.Range(0, 2);
			for (int i = 0; i < 3; i++)
			{
				if (flag)
				{
					break;
				}
				for (int j = 0; j < 3; j++)
				{
					if (flag)
					{
						break;
					}
					int x = (num + i) % 3;
					int y = (num2 + j) % 3;
					if (m_board.CanPlayerMoveToPostion(x, y))
					{
						GamePiece gamePiece = ((Random.Range(0, 2) != 0) ? m_pieceB : m_pieceA);
						m_board.AddPiece(player, gamePiece.Prefab, x, y);
						flag = true;
					}
					else if (m_board.CanPlayerPowerUpPosition(x, y) && Random.Range(0, 8) < 2)
					{
						m_board.AddPowerPiece(player, m_powerPiece.Prefab, x, y);
						flag = true;
					}
				}
			}
			if (flag)
			{
				UpdateScores();
				TransitionToNextState();
			}
		}

		public void StartOnlineMatch(string opponentName, bool localUserGoesFirst)
		{
			m_board.Reset();
			m_opponentName = opponentName;
			if (localUserGoesFirst)
			{
				TransitionToState(GameState.OnlineMatchMyTurn);
			}
			else
			{
				TransitionToState(GameState.OnlineMatchRemoteTurn);
			}
			UpdateScores();
		}

		public void MakeRemoteMove(GamePiece.Piece piece, int x, int y)
		{
			GameObject prefab = m_pieceA.PrefabFor(piece);
			if (piece == GamePiece.Piece.PowerBall)
			{
				m_board.AddPowerPiece(1, prefab, x, y);
			}
			else
			{
				m_board.AddPiece(1, prefab, x, y);
			}
			UpdateScores();
		}

		public void MarkRemoteTurnComplete()
		{
			if (m_state == GameState.OnlineMatchRemoteTurn)
			{
				TransitionToNextState();
			}
		}

		public void RemoteMatchEnded()
		{
			m_matchmaking.EndMatch(m_board.GetPlayerScore(0), m_board.GetPlayerScore(1));
		}

		public void StartedLookingAtPiece(GamePiece piece)
		{
			m_interestedPiece = piece;
			UpdateGamePieceColors();
		}

		public void StoppedLookingAtPiece()
		{
			m_interestedPiece = null;
			UpdateGamePieceColors();
		}

		public void StartedLookingAtPosition(BoardPosition position)
		{
			if (m_state != GameState.OnlineMatchMyTurn && m_state != GameState.PracticingMyTurn)
			{
				return;
			}
			GamePiece gamePiece = null;
			if ((m_selectedPiece == m_pieceA || m_selectedPiece == m_pieceB) && m_board.CanPlayerMoveToPostion(position.x, position.y))
			{
				gamePiece = m_board.AddProposedPiece(m_selectedPiece.Prefab, position);
			}
			else if (m_selectedPiece == m_powerPiece && m_board.CanPlayerPowerUpPosition(position.x, position.y))
			{
				gamePiece = m_board.AddProposedPowerPiece(m_selectedPiece.Prefab, position);
			}
			if (gamePiece != null)
			{
				if (m_proposedPiece != null)
				{
					UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
				}
				m_proposedPiece = gamePiece;
			}
		}

		public void ClearProposedMove()
		{
			if (m_proposedPiece != null)
			{
				UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
			}
		}

		public void TrySelectPiece()
		{
			if (m_interestedPiece == m_pieceA || m_interestedPiece == m_pieceB)
			{
				m_selectedPiece = m_interestedPiece;
			}
			else if (m_interestedPiece == m_powerPiece && (m_powerBallcount != 0 || m_state == GameState.PracticingMyTurn))
			{
				m_selectedPiece = m_interestedPiece;
			}
			UpdateGamePieceColors();
		}

		public void TryPlacePiece()
		{
			if (!(m_proposedPiece == null))
			{
				BoardPosition position = m_proposedPiece.Position;
				switch (m_proposedPiece.Type)
				{
				case GamePiece.Piece.A:
				case GamePiece.Piece.B:
					m_board.AddPiece(0, m_proposedPiece.Prefab, position.x, position.y);
					break;
				case GamePiece.Piece.PowerBall:
					m_board.AddPowerPiece(0, m_proposedPiece.Prefab, position.x, position.y);
					break;
				}
				UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
				if (m_state == GameState.OnlineMatchMyTurn)
				{
					m_matchmaking.SendLocalMove(m_proposedPiece.Type, position.x, position.y);
				}
				UpdateScores();
				TransitionToNextState();
			}
		}

		public void QuitButtonPressed()
		{
			UnityEngine.Application.Quit();
		}

		public void AddPowerballs(uint count)
		{
			m_powerBallcount += count;
			m_ballCountText.text = "x" + m_powerBallcount;
		}

		private void UpdateScores()
		{
			m_player0Text.text = $"{PlatformManager.MyOculusID}\n\n{m_board.GetPlayerScore(0)}";
			m_player1Text.text = $"{m_opponentName}\n\n{m_board.GetPlayerScore(1)}";
		}

		private void UpdateGamePieceColors()
		{
			switch (m_state)
			{
			case GameState.None:
			case GameState.PracticingAiTurn:
			case GameState.OnlineMatchRemoteTurn:
				m_pieceA.GetComponent<Renderer>().material.color = m_unusableColor;
				m_pieceB.GetComponent<Renderer>().material.color = m_unusableColor;
				m_powerPiece.GetComponent<Renderer>().material.color = m_unusableColor;
				if (m_proposedPiece != null)
				{
					UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
				}
				break;
			case GameState.PracticingMyTurn:
			case GameState.OnlineMatchMyTurn:
				m_pieceA.GetComponent<Renderer>().material.color = m_unselectedColor;
				m_pieceB.GetComponent<Renderer>().material.color = m_unselectedColor;
				m_powerPiece.GetComponent<Renderer>().material.color = m_unselectedColor;
				if (m_interestedPiece == m_pieceA || m_interestedPiece == m_pieceB || m_interestedPiece == m_powerPiece)
				{
					m_interestedPiece.GetComponent<Renderer>().material.color = m_highlightedColor;
				}
				if (m_selectedPiece != null)
				{
					m_selectedPiece.GetComponent<Renderer>().material.color = m_selectedColor;
				}
				break;
			}
		}
	}
	public class GamePiece : MonoBehaviour
	{
		public enum Piece
		{
			A,
			B,
			PowerBall
		}

		[SerializeField]
		private Piece m_type;

		[SerializeField]
		private GameObject m_prefabA;

		[SerializeField]
		private GameObject m_prefabB;

		[SerializeField]
		private GameObject m_prefabPower;

		private BoardPosition m_position;

		public Piece Type => m_type;

		public BoardPosition Position
		{
			get
			{
				return m_position;
			}
			set
			{
				m_position = value;
			}
		}

		public GameObject Prefab => m_type switch
		{
			Piece.A => m_prefabA, 
			Piece.B => m_prefabB, 
			_ => m_prefabPower, 
		};

		public GameObject PrefabFor(Piece p)
		{
			return p switch
			{
				Piece.A => m_prefabA, 
				Piece.B => m_prefabB, 
				_ => m_prefabPower, 
			};
		}
	}
	public class IAPManager : MonoBehaviour
	{
		[SerializeField]
		private GameController m_gameController;

		[SerializeField]
		private Text m_priceText;

		private const string CONSUMABLE_1 = "PowerballPack1";

		private void Start()
		{
			FetchProductPrices();
			FetchPurchasedProducts();
		}

		public void FetchProductPrices()
		{
			string[] skus = new string[1] { "PowerballPack1" };
			IAP.GetProductsBySKU(skus).OnComplete(GetProductsBySKUCallback);
		}

		private void GetProductsBySKUCallback(Message<ProductList> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			foreach (Product product in msg.GetProductList())
			{
				Debug.LogFormat("Product: sku:{0} name:{1} price:{2}", product.Sku, product.Name, product.FormattedPrice);
				if (product.Sku == "PowerballPack1")
				{
					m_priceText.text = product.FormattedPrice;
				}
			}
		}

		public void FetchPurchasedProducts()
		{
			IAP.GetViewerPurchases().OnComplete(GetViewerPurchasesCallback);
		}

		private void GetViewerPurchasesCallback(Message<PurchaseList> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			foreach (Purchase purchase in msg.GetPurchaseList())
			{
				Debug.LogFormat("Purchased: sku:{0} granttime:{1} id:{2}", purchase.Sku, purchase.GrantTime, purchase.ID);
			}
		}

		public void BuyPowerBallsPressed()
		{
			IAP.LaunchCheckoutFlow("PowerballPack1").OnComplete(LaunchCheckoutFlowCallback);
		}

		private void LaunchCheckoutFlowCallback(Message<Purchase> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			Purchase purchase = msg.GetPurchase();
			Debug.Log("purchased " + purchase.Sku);
			m_gameController.AddPowerballs(3u);
		}
	}
	public class MatchmakingManager : MonoBehaviour
	{
		private enum MatchRoomState
		{
			None,
			Queued,
			Configuring,
			MyTurn,
			RemoteTurn
		}

		[SerializeField]
		private GameController m_gameController;

		[SerializeField]
		private Text m_matchButtonText;

		[SerializeField]
		private Text m_infoText;

		private const string POOL = "VR_BOARD_GAME_POOL";

		private ulong m_matchRoom;

		private User m_remotePlayer;

		private float m_lastUpdateTime;

		private const float POLL_FREQUENCY = 30f;

		private MatchRoomState m_state;

		private void Start()
		{
			Matchmaking.SetMatchFoundNotificationCallback(MatchFoundCallback);
			Rooms.SetUpdateNotificationCallback(MatchmakingRoomUpdateCallback);
			TransitionToState(MatchRoomState.None);
		}

		private void Update()
		{
			MatchRoomState state = m_state;
			if ((state == MatchRoomState.Configuring || state == MatchRoomState.MyTurn || state == MatchRoomState.RemoteTurn) && 30f < Time.time - m_lastUpdateTime)
			{
				Debug.Log("Polling Room");
				m_lastUpdateTime = Time.time;
				Rooms.Get(m_matchRoom).OnComplete(MatchmakingRoomUpdateCallback);
			}
		}

		public void MatchButtonPressed()
		{
			if (m_state == MatchRoomState.None)
			{
				TransitionToState(MatchRoomState.Queued);
			}
			else
			{
				TransitionToState(MatchRoomState.None);
			}
		}

		public void EndMatch(int localScore, int remoteScore)
		{
			MatchRoomState state = m_state;
			if (state == MatchRoomState.MyTurn || state == MatchRoomState.RemoteTurn)
			{
				string key = PlatformManager.MyID.ToString();
				string key2 = m_remotePlayer.ID.ToString();
				Dictionary<string, int> dictionary = new Dictionary<string, int>();
				if (localScore > remoteScore)
				{
					dictionary[key] = 1;
					dictionary[key2] = 2;
				}
				else if (localScore < remoteScore)
				{
					dictionary[key] = 2;
					dictionary[key2] = 1;
				}
				else
				{
					dictionary[key] = 1;
					dictionary[key2] = 1;
				}
				Matchmaking.ReportResultsInsecure(m_matchRoom, dictionary).OnComplete(GenericErrorCheckCallback);
			}
			TransitionToState(MatchRoomState.None);
		}

		private void OnApplicationQuit()
		{
			Matchmaking.Cancel();
			if (m_matchRoom != 0)
			{
				Rooms.Leave(m_matchRoom);
			}
		}

		private void TransitionToState(MatchRoomState state)
		{
			MatchRoomState state2 = m_state;
			m_state = state;
			switch (m_state)
			{
			case MatchRoomState.None:
				m_matchButtonText.text = "Find Match";
				m_remotePlayer = null;
				Matchmaking.Cancel();
				if (m_matchRoom != 0)
				{
					Rooms.Leave(m_matchRoom);
					m_matchRoom = 0uL;
				}
				break;
			case MatchRoomState.Queued:
				m_matchButtonText.text = "Leave Queue";
				Matchmaking.Enqueue2("VR_BOARD_GAME_POOL").OnComplete(MatchmakingEnqueueCallback);
				break;
			case MatchRoomState.Configuring:
				m_matchButtonText.text = "Cancel Match";
				break;
			case MatchRoomState.MyTurn:
			case MatchRoomState.RemoteTurn:
				m_matchButtonText.text = "Cancel Match";
				break;
			}
		}

		private void MatchmakingEnqueueCallback(Message untyped_msg)
		{
			if (untyped_msg.IsError)
			{
				Debug.Log(untyped_msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
				return;
			}
			Message<MatchmakingEnqueueResult> message = (Message<MatchmakingEnqueueResult>)untyped_msg;
			MatchmakingEnqueueResult data = message.Data;
			m_infoText.text = $"Avg Wait Time: {data.AverageWait}s\nMax Expected Wait: {data.MaxExpectedWait}s\nIn Last Hour: {data.MatchesInLastHourCount}\nRecent Percentage: {data.RecentMatchPercentage}%";
		}

		private void MatchFoundCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
			}
			else if (m_state == MatchRoomState.Queued)
			{
				Matchmaking.JoinRoom(msg.Data.ID, subscribeToUpdates: true).OnComplete(MatchmakingJoinRoomCallback);
				m_matchRoom = msg.Data.ID;
			}
		}

		private void MatchmakingJoinRoomCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
			}
			else if (m_state == MatchRoomState.Queued)
			{
				int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
				Debug.Log("Match room joined: " + m_matchRoom + " count: " + num);
				TransitionToState(MatchRoomState.Configuring);
				if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 2)
				{
					ProcessRoomData(msg.Data);
				}
			}
		}

		private void MatchmakingRoomUpdateCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
				return;
			}
			string text = ((msg.Data.OwnerOptional == null) ? string.Empty : msg.Data.OwnerOptional.OculusID);
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			Debug.LogFormat("Room Update {0}\n  Owner {1}\n  User Count {2}\n  Datastore Count {3}\n", msg.Data.ID, text, num, msg.Data.DataStore.Count);
			if (msg.Data.ID != m_matchRoom)
			{
				Debug.Log("Unexpected room update from: " + msg.Data.ID);
			}
			else
			{
				ProcessRoomData(msg.Data);
			}
		}

		private void ProcessRoomData(Room room)
		{
			m_lastUpdateTime = Time.time;
			if (m_state == MatchRoomState.Configuring)
			{
				if (room.UsersOptional != null)
				{
					foreach (User item in room.UsersOptional)
					{
						if (PlatformManager.MyID != item.ID)
						{
							Debug.Log("Found remote user: " + item.OculusID);
							m_remotePlayer = item;
							break;
						}
					}
				}
				if (m_remotePlayer == null)
				{
					return;
				}
				bool flag = DoesLocalUserGoFirst();
				TransitionToState((!flag) ? MatchRoomState.RemoteTurn : MatchRoomState.MyTurn);
				Matchmaking.StartMatch(m_matchRoom).OnComplete(GenericErrorCheckCallback);
				m_gameController.StartOnlineMatch(m_remotePlayer.OculusID, flag);
			}
			if (m_state == MatchRoomState.RemoteTurn && room.DataStore.ContainsKey(m_remotePlayer.OculusID) && room.DataStore[m_remotePlayer.OculusID] != string.Empty)
			{
				ProcessRemoteMove(room.DataStore[m_remotePlayer.OculusID]);
				TransitionToState(MatchRoomState.MyTurn);
			}
			if (m_state == MatchRoomState.MyTurn && room.OwnerOptional != null && room.OwnerOptional.ID == PlatformManager.MyID)
			{
				m_gameController.MarkRemoteTurnComplete();
			}
			if (room.UsersOptional == null || (room.UsersOptional != null && room.UsersOptional.Count != 2))
			{
				Debug.Log("Other user quit the room");
				m_gameController.RemoteMatchEnded();
			}
		}

		private void ProcessRemoteMove(string moveString)
		{
			Debug.Log("Processing remote move string: " + moveString);
			string[] array = moveString.Split(':');
			GamePiece.Piece piece = (GamePiece.Piece)Enum.Parse(typeof(GamePiece.Piece), array[0]);
			int num = int.Parse(array[1]);
			int num2 = int.Parse(array[2]);
			num = 2 - num;
			num2 = 2 - num2;
			m_gameController.MakeRemoteMove(piece, num, num2);
		}

		public void SendLocalMove(GamePiece.Piece piece, int boardX, int boardY)
		{
			string text = $"{piece.ToString()}:{boardX}:{boardY}";
			Debug.Log("Sending move: " + text);
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary[PlatformManager.MyOculusID] = text;
			dictionary[m_remotePlayer.OculusID] = string.Empty;
			Rooms.UpdateDataStore(m_matchRoom, dictionary).OnComplete(UpdateDataStoreCallback);
			TransitionToState(MatchRoomState.RemoteTurn);
		}

		private void UpdateDataStoreCallback(Message<Room> msg)
		{
			if (m_state == MatchRoomState.RemoteTurn)
			{
				Rooms.UpdateOwner(m_matchRoom, m_remotePlayer.ID);
			}
		}

		private bool DoesLocalUserGoFirst()
		{
			if (m_matchRoom % 2 == 0)
			{
				return PlatformManager.MyID < m_remotePlayer.ID;
			}
			return PlatformManager.MyID > m_remotePlayer.ID;
		}

		private void GenericErrorCheckCallback(Message msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
			}
		}
	}
	public class PlatformManager : MonoBehaviour
	{
		private static PlatformManager s_instance;

		private ulong m_myID;

		private string m_myOculusID;

		public static ulong MyID
		{
			get
			{
				if (s_instance != null)
				{
					return s_instance.m_myID;
				}
				return 0uL;
			}
		}

		public static string MyOculusID
		{
			get
			{
				if (s_instance != null && s_instance.m_myOculusID != null)
				{
					return s_instance.m_myOculusID;
				}
				return string.Empty;
			}
		}

		private void Awake()
		{
			if (s_instance != null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			s_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			Core.Initialize();
		}

		private void Start()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
		}

		private void IsEntitledCallback(Message msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
			}
			else
			{
				Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
			}
		}

		private void GetLoggedInUserCallback(Message<User> msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
				return;
			}
			m_myID = msg.Data.ID;
			m_myOculusID = msg.Data.OculusID;
			Debug.Log(" I am " + m_myOculusID);
		}

		public static void TerminateWithError(Message msg)
		{
			Debug.Log("Error: " + msg.GetError().Message);
			UnityEngine.Application.Quit();
		}
	}
}
namespace Oculus.Platform.Samples.VrHoops
{
	public class AchievementsManager
	{
		private const string LIKES_TO_WIN = "LIKES_TO_WIN";

		private bool m_likesToWinUnlocked;

		public bool LikesToWin => m_likesToWinUnlocked;

		public void CheckForAchievmentUpdates()
		{
			Achievements.GetProgressByName(new string[1] { "LIKES_TO_WIN" }).OnComplete(delegate(Message<AchievementProgressList> msg)
			{
				foreach (AchievementProgress datum in msg.Data)
				{
					if (datum.Name == "LIKES_TO_WIN")
					{
						m_likesToWinUnlocked = datum.IsUnlocked;
					}
				}
			});
		}

		public void RecordWinForLocalUser()
		{
			Achievements.AddCount("LIKES_TO_WIN", 1uL);
			CheckForAchievmentUpdates();
		}
	}
	public class AIPlayer : Player
	{
		private void FixedUpdate()
		{
			if (base.HasBall)
			{
				if (Random.Range(0f, 1f) < 0.03f)
				{
					ShootBall();
				}
			}
			else
			{
				CheckSpawnBall();
			}
		}
	}
	public class BallEjector : MonoBehaviour
	{
	}
	public class Camera2DController : MonoBehaviour
	{
		private void Update()
		{
			if (Input.GetButton("Fire2"))
			{
				float axis = Input.GetAxis("Mouse Y");
				float axis2 = Input.GetAxis("Mouse X");
				base.transform.rotation *= Quaternion.AngleAxis(axis2, Vector3.up);
				base.transform.rotation *= Quaternion.AngleAxis(0f - axis, Vector3.right);
				Vector3 eulerAngles = base.transform.eulerAngles;
				eulerAngles.z = 0f;
				base.transform.eulerAngles = eulerAngles;
			}
		}
	}
	public class DetectBasket : MonoBehaviour
	{
		private enum BasketPhase
		{
			NONE,
			TOP,
			BOTH,
			BOTTOM
		}

		private BasketPhase m_phase;

		private Player m_owningPlayer;

		public Player Player
		{
			set
			{
				m_owningPlayer = value;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.gameObject.name == "Basket Top" && m_phase == BasketPhase.NONE)
			{
				m_phase = BasketPhase.TOP;
			}
			else if (other.gameObject.name == "Basket Bottom" && m_phase == BasketPhase.TOP)
			{
				m_phase = BasketPhase.BOTH;
			}
			else
			{
				m_phase = BasketPhase.NONE;
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.gameObject.name == "Basket Top" && m_phase == BasketPhase.BOTH)
			{
				m_phase = BasketPhase.BOTTOM;
			}
			else if (other.gameObject.name == "Basket Bottom" && m_phase == BasketPhase.BOTTOM)
			{
				m_phase = BasketPhase.NONE;
				PlatformManager.State currentState = PlatformManager.CurrentState;
				if ((currentState == PlatformManager.State.PLAYING_A_LOCAL_MATCH || currentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH) && (bool)m_owningPlayer)
				{
					m_owningPlayer.Score += 2u;
				}
			}
			else
			{
				m_phase = BasketPhase.NONE;
			}
		}
	}
	public class FlyText : MonoBehaviour
	{
		private const float LIFESPAN = 3f;

		private readonly Vector3 m_movePerFrame = 0.5f * Vector3.up;

		private float m_eol;

		private void Start()
		{
			m_eol = Time.time + 3f;
			GetComponent<Text>().CrossFadeColor(Color.black, 5.1000004f, ignoreTimeScale: false, useAlpha: true);
		}

		private void Update()
		{
			if (Time.time < m_eol)
			{
				base.transform.localPosition += m_movePerFrame;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class GoalMover : MonoBehaviour
	{
		[SerializeField]
		private float MAX_OFFSET = 2f;

		[SerializeField]
		private float m_speed = 0.005f;

		private const float MOVE_TOLERANCE = 0.1f;

		private Vector3 m_expectedPosition;

		private Vector3 m_moveDirection;

		private Vector3 m_nextMoveDirection;

		public Vector3 ExpectedPosition
		{
			get
			{
				return m_expectedPosition;
			}
			set
			{
				m_expectedPosition = value;
			}
		}

		public Vector3 MoveDirection
		{
			get
			{
				return m_moveDirection;
			}
			set
			{
				m_moveDirection = value;
			}
		}

		public Vector3 NextMoveDirection
		{
			get
			{
				return m_nextMoveDirection;
			}
			set
			{
				m_nextMoveDirection = value;
			}
		}

		private void Start()
		{
			ExpectedPosition = base.transform.localPosition;
			m_moveDirection.x = Random.Range(-1f, 1f);
			m_moveDirection.y = Random.Range(-1f, 1f);
			m_moveDirection = Vector3.ClampMagnitude(m_moveDirection, m_speed);
			m_nextMoveDirection.x = (0f - Mathf.Sign(m_moveDirection.x)) * Random.Range(0f, 1f);
			m_nextMoveDirection.y = (0f - Mathf.Sign(m_moveDirection.y)) * Random.Range(0f, 1f);
			m_nextMoveDirection = Vector3.ClampMagnitude(m_nextMoveDirection, m_speed);
		}

		private void FixedUpdate()
		{
			base.transform.localPosition += MoveDirection;
			ExpectedPosition += MoveDirection;
			Vector3 vector = ExpectedPosition - base.transform.localPosition;
			vector = Vector3.ClampMagnitude(vector, 0.1f);
			base.transform.localPosition += vector;
			if (base.transform.localPosition.sqrMagnitude > MAX_OFFSET * MAX_OFFSET)
			{
				base.transform.localPosition = Vector3.ClampMagnitude(base.transform.localPosition, MAX_OFFSET);
				ExpectedPosition = base.transform.localPosition;
				MoveDirection = NextMoveDirection;
				m_nextMoveDirection.x = (0f - Mathf.Sign(m_moveDirection.x)) * Random.Range(0f, 1f);
				m_nextMoveDirection.y = (0f - Mathf.Sign(m_moveDirection.y)) * Random.Range(0f, 1f);
				m_nextMoveDirection = Vector3.ClampMagnitude(m_nextMoveDirection, m_speed);
			}
		}
	}
	public class LeaderboardManager
	{
		public delegate void OnMostWinsLeaderboardUpdated(SortedDictionary<int, LeaderboardEntry> entries);

		public delegate void OnHighScoreLeaderboardUpdated(SortedDictionary<int, LeaderboardEntry> entries);

		private const string MOST_MATCHES_WON = "MOST_MATCHES_WON";

		private const string HIGHEST_MATCH_SCORE = "HIGHEST_MATCH_SCORE";

		private const int TOP_N_COUNT = 5;

		private const float LEADERBOARD_POLL_FREQ = 30f;

		private float m_nextCheckTime;

		private volatile SortedDictionary<int, LeaderboardEntry> m_mostWins;

		private bool m_foundLocalUserMostWinsEntry;

		private long m_numWins;

		private OnMostWinsLeaderboardUpdated m_mostWinsCallback;

		private volatile SortedDictionary<int, LeaderboardEntry> m_highScores;

		private bool m_foundLocalUserHighScore;

		private OnHighScoreLeaderboardUpdated m_highScoreCallback;

		public OnMostWinsLeaderboardUpdated MostWinsLeaderboardUpdatedCallback
		{
			set
			{
				m_mostWinsCallback = value;
			}
		}

		public OnHighScoreLeaderboardUpdated HighScoreLeaderboardUpdatedCallback
		{
			set
			{
				m_highScoreCallback = value;
			}
		}

		public void CheckForUpdates()
		{
			if (Time.time >= m_nextCheckTime && PlatformManager.CurrentState == PlatformManager.State.WAITING_TO_PRACTICE_OR_MATCHMAKE)
			{
				m_nextCheckTime = Time.time + 30f;
				QueryMostWinsLeaderboard();
				QueryHighScoreLeaderboard();
			}
		}

		private void QueryMostWinsLeaderboard()
		{
			if (m_mostWins == null)
			{
				m_mostWins = new SortedDictionary<int, LeaderboardEntry>();
				m_foundLocalUserMostWinsEntry = false;
				Leaderboards.GetEntries("MOST_MATCHES_WON", 5, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(MostWinsGetEntriesCallback);
			}
		}

		private void MostWinsGetEntriesCallback(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				foreach (LeaderboardEntry datum in msg.Data)
				{
					m_mostWins[datum.Rank] = datum;
					if (datum.User.ID == PlatformManager.MyID)
					{
						m_foundLocalUserMostWinsEntry = true;
						m_numWins = datum.Score;
					}
				}
				if (msg.Data.HasNextPage)
				{
					Leaderboards.GetNextEntries(msg.Data).OnComplete(MostWinsGetEntriesCallback);
					return;
				}
				if (!m_foundLocalUserMostWinsEntry)
				{
					Leaderboards.GetEntries("MOST_MATCHES_WON", 1, LeaderboardFilterType.None, LeaderboardStartAt.CenteredOnViewer).OnComplete(MostWinsGetEntriesCallback);
					return;
				}
			}
			if (m_mostWinsCallback != null)
			{
				m_mostWinsCallback(m_mostWins);
			}
			m_mostWins = null;
		}

		private void QueryHighScoreLeaderboard()
		{
			if (m_highScores == null)
			{
				m_highScores = new SortedDictionary<int, LeaderboardEntry>();
				m_foundLocalUserHighScore = false;
				Leaderboards.GetEntries("HIGHEST_MATCH_SCORE", 5, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(HighestScoreGetEntriesCallback);
			}
		}

		private void HighestScoreGetEntriesCallback(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				foreach (LeaderboardEntry datum in msg.Data)
				{
					m_highScores[datum.Rank] = datum;
					if (datum.User.ID == PlatformManager.MyID)
					{
						m_foundLocalUserHighScore = true;
					}
				}
				if (msg.Data.HasNextPage)
				{
					Leaderboards.GetNextEntries(msg.Data).OnComplete(HighestScoreGetEntriesCallback);
					return;
				}
				if (!m_foundLocalUserHighScore)
				{
					Leaderboards.GetEntries("HIGHEST_MATCH_SCORE", 1, LeaderboardFilterType.None, LeaderboardStartAt.CenteredOnViewer).OnComplete(HighestScoreGetEntriesCallback);
					return;
				}
			}
			if (m_highScoreCallback != null)
			{
				m_highScoreCallback(m_highScores);
			}
			m_highScores = null;
		}

		public void SubmitMatchScores(bool wonMatch, uint score)
		{
			if (wonMatch)
			{
				m_numWins++;
				Leaderboards.WriteEntry("MOST_MATCHES_WON", m_numWins);
			}
			if (score != 0)
			{
				Leaderboards.WriteEntry("HIGHEST_MATCH_SCORE", score);
			}
		}
	}
	public class LocalPlayer : Player
	{
		public override uint Score
		{
			set
			{
				base.Score = value;
				if (PlatformManager.CurrentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH)
				{
					PlatformManager.P2P.SendScoreUpdate(base.Score);
				}
			}
		}

		private void Update()
		{
			GameObject gameObject = null;
			if (base.HasBall)
			{
				if (Input.GetButton("Fire1") || Input.GetKey(KeyCode.Space))
				{
					gameObject = ShootBall();
				}
			}
			else
			{
				gameObject = CheckSpawnBall();
			}
			if ((bool)gameObject && PlatformManager.CurrentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH)
			{
				PlatformManager.P2P.AddNetworkBall(gameObject);
			}
		}
	}
	public class MatchController : MonoBehaviour
	{
		private enum State
		{
			UNKNOWN,
			NONE,
			WAITING_TO_START_PRACTICE,
			PRACTICING,
			VIEWING_RESULTS_PRACTICE,
			WAITING_FOR_MATCH,
			WAITING_TO_SETUP_MATCH,
			PLAYING_MATCH,
			VIEWING_MATCH_RESULTS
		}

		[SerializeField]
		private Text m_timerText;

		[SerializeField]
		private Camera m_camera;

		[SerializeField]
		private Transform m_idleCameraTransform;

		[SerializeField]
		private Text m_matchmakeButtonText;

		[SerializeField]
		private PlayerArea[] m_playerAreas = new PlayerArea[3];

		[SerializeField]
		private uint PRACTICE_WARMUP_TIME = 5u;

		[SerializeField]
		private uint MATCH_WARMUP_TIME = 30u;

		[SerializeField]
		private uint MATCH_TIME = 20u;

		[SerializeField]
		private uint MATCH_COOLDOWN_TIME = 10u;

		[SerializeField]
		private GameObject m_mostWinsLeaderboard;

		[SerializeField]
		private GameObject m_highestScoresLeaderboard;

		[SerializeField]
		private GameObject m_leaderboardEntryPrefab;

		[SerializeField]
		private GameObject m_flytext;

		private State m_currentState;

		private float m_nextStateTransitionTime;

		private int m_localSlot;

		public float MatchStartTime
		{
			get
			{
				State currentState = m_currentState;
				if (currentState == State.WAITING_TO_START_PRACTICE || currentState == State.WAITING_TO_SETUP_MATCH)
				{
					return m_nextStateTransitionTime;
				}
				return 0f;
			}
			private set
			{
				m_nextStateTransitionTime = value;
			}
		}

		private void Start()
		{
			PlatformManager.Matchmaking.EnqueueResultCallback = OnMatchFoundCallback;
			PlatformManager.Matchmaking.MatchPlayerAddedCallback = MatchPlayerAddedCallback;
			PlatformManager.P2P.StartTimeOfferCallback = StartTimeOfferCallback;
			PlatformManager.Leaderboards.MostWinsLeaderboardUpdatedCallback = MostWinsLeaderboardCallback;
			PlatformManager.Leaderboards.HighScoreLeaderboardUpdatedCallback = HighestScoreLeaderboardCallback;
			TransitionToState(State.NONE);
		}

		private void Update()
		{
			UpdateCheckForNextTimedTransition();
			UpdateMatchTimer();
		}

		private void TransitionToState(State newState)
		{
			Debug.LogFormat("MatchController State {0} -> {1}", m_currentState, newState);
			if (m_currentState != newState)
			{
				State currentState = m_currentState;
				m_currentState = newState;
				switch (newState)
				{
				case State.NONE:
					SetupForIdle();
					MoveCameraToIdlePosition();
					PlatformManager.TransitionToState(PlatformManager.State.WAITING_TO_PRACTICE_OR_MATCHMAKE);
					m_matchmakeButtonText.text = "Play Online";
					break;
				case State.WAITING_TO_START_PRACTICE:
					SetupForPractice();
					MoveCameraToMatchPosition();
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_nextStateTransitionTime = Time.time + (float)PRACTICE_WARMUP_TIME;
					break;
				case State.PRACTICING:
					PlatformManager.TransitionToState(PlatformManager.State.PLAYING_A_LOCAL_MATCH);
					m_nextStateTransitionTime = Time.time + (float)MATCH_TIME;
					break;
				case State.VIEWING_RESULTS_PRACTICE:
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_nextStateTransitionTime = Time.time + (float)MATCH_COOLDOWN_TIME;
					m_timerText.text = "0:00.00";
					break;
				case State.WAITING_FOR_MATCH:
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_matchmakeButtonText.text = "Cancel";
					break;
				case State.WAITING_TO_SETUP_MATCH:
					m_nextStateTransitionTime = Time.time + (float)MATCH_WARMUP_TIME;
					break;
				case State.PLAYING_MATCH:
					PlatformManager.TransitionToState(PlatformManager.State.PLAYING_A_NETWORKED_MATCH);
					m_nextStateTransitionTime = Time.time + (float)MATCH_TIME;
					break;
				case State.VIEWING_MATCH_RESULTS:
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_nextStateTransitionTime = Time.time + (float)MATCH_COOLDOWN_TIME;
					m_timerText.text = "0:00.00";
					CalculateMatchResults();
					break;
				}
			}
		}

		private void UpdateCheckForNextTimedTransition()
		{
			if (m_currentState != State.NONE && Time.time >= m_nextStateTransitionTime)
			{
				switch (m_currentState)
				{
				case State.WAITING_TO_START_PRACTICE:
					TransitionToState(State.PRACTICING);
					break;
				case State.PRACTICING:
					TransitionToState(State.VIEWING_RESULTS_PRACTICE);
					break;
				case State.VIEWING_RESULTS_PRACTICE:
					TransitionToState(State.NONE);
					break;
				case State.WAITING_TO_SETUP_MATCH:
					TransitionToState(State.PLAYING_MATCH);
					break;
				case State.PLAYING_MATCH:
					TransitionToState(State.VIEWING_MATCH_RESULTS);
					break;
				case State.VIEWING_MATCH_RESULTS:
					PlatformManager.Matchmaking.EndMatch();
					TransitionToState(State.NONE);
					break;
				case State.WAITING_FOR_MATCH:
					break;
				}
			}
		}

		private void UpdateMatchTimer()
		{
			if (Time.time <= m_nextStateTransitionTime)
			{
				switch (m_currentState)
				{
				case State.WAITING_TO_START_PRACTICE:
				case State.WAITING_TO_SETUP_MATCH:
					m_timerText.text = $"{Mathf.Ceil(Time.time - MatchStartTime):0}";
					break;
				case State.PRACTICING:
				case State.PLAYING_MATCH:
				{
					float num = m_nextStateTransitionTime - Time.time;
					m_timerText.text = $"{Mathf.Floor(num / 60f):#0}:{Mathf.Floor(num) % 60f:#00}.{Mathf.Floor(num * 100f) % 100f:00}";
					break;
				}
				case State.VIEWING_RESULTS_PRACTICE:
				case State.WAITING_FOR_MATCH:
					break;
				}
			}
		}

		private void SetupForIdle()
		{
			for (int i = 0; i < m_playerAreas.Length; i++)
			{
				m_playerAreas[i].SetupForPlayer<AIPlayer>("* AI *");
			}
		}

		private void SetupForPractice()
		{
			m_localSlot = Random.Range(0, m_playerAreas.Length - 1);
			for (int i = 0; i < m_playerAreas.Length; i++)
			{
				if (i == m_localSlot)
				{
					m_playerAreas[i].SetupForPlayer<LocalPlayer>(PlatformManager.MyOculusID);
				}
				else
				{
					m_playerAreas[i].SetupForPlayer<AIPlayer>("* AI *");
				}
			}
		}

		private Player MatchPlayerAddedCallback(int slot, User user)
		{
			Player result = null;
			if (m_currentState == State.WAITING_TO_SETUP_MATCH && slot < m_playerAreas.Length)
			{
				if (user.ID == PlatformManager.MyID)
				{
					LocalPlayer localPlayer = m_playerAreas[slot].SetupForPlayer<LocalPlayer>(user.OculusID);
					MoveCameraToMatchPosition();
					result = localPlayer;
					m_localSlot = slot;
				}
				else
				{
					RemotePlayer remotePlayer = m_playerAreas[slot].SetupForPlayer<RemotePlayer>(user.OculusID);
					remotePlayer.User = user;
					result = remotePlayer;
				}
			}
			return result;
		}

		private void MoveCameraToIdlePosition()
		{
			BallEjector componentInChildren = m_camera.gameObject.GetComponentInChildren<BallEjector>();
			if ((bool)componentInChildren)
			{
				componentInChildren.transform.SetParent(m_camera.transform.parent, worldPositionStays: false);
				m_camera.transform.SetParent(m_idleCameraTransform, worldPositionStays: false);
			}
		}

		private void MoveCameraToMatchPosition()
		{
			PlayerArea[] playerAreas = m_playerAreas;
			foreach (PlayerArea playerArea in playerAreas)
			{
				LocalPlayer componentInChildren = playerArea.GetComponentInChildren<LocalPlayer>();
				if ((bool)componentInChildren)
				{
					BallEjector componentInChildren2 = componentInChildren.GetComponentInChildren<BallEjector>();
					m_camera.transform.SetParent(componentInChildren.transform, worldPositionStays: false);
					componentInChildren2.transform.SetParent(m_camera.transform, worldPositionStays: false);
					break;
				}
			}
			DisplayAchievementFlytext();
		}

		public void StartPracticeMatch()
		{
			if (m_currentState == State.NONE)
			{
				TransitionToState(State.WAITING_TO_START_PRACTICE);
			}
		}

		public void PlayOnlineOrCancel()
		{
			Debug.Log("Play online or Cancel");
			if (m_currentState == State.NONE)
			{
				PlatformManager.Matchmaking.QueueForMatch();
				TransitionToState(State.WAITING_FOR_MATCH);
			}
			else if (m_currentState == State.WAITING_FOR_MATCH)
			{
				PlatformManager.Matchmaking.LeaveQueue();
				TransitionToState(State.NONE);
			}
		}

		private void OnMatchFoundCallback(bool success)
		{
			if (success)
			{
				TransitionToState(State.WAITING_TO_SETUP_MATCH);
			}
			else
			{
				TransitionToState(State.NONE);
			}
		}

		private float StartTimeOfferCallback(float remoteTime)
		{
			if (m_currentState == State.WAITING_TO_SETUP_MATCH && remoteTime > MatchStartTime && remoteTime - 60f < MatchStartTime)
			{
				Debug.Log("Moving Start time by " + (remoteTime - MatchStartTime));
				MatchStartTime = remoteTime;
			}
			return MatchStartTime;
		}

		private void MostWinsLeaderboardCallback(SortedDictionary<int, LeaderboardEntry> entries)
		{
			foreach (Transform item in m_mostWinsLeaderboard.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (LeaderboardEntry value in entries.Values)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_leaderboardEntryPrefab);
				gameObject.transform.SetParent(m_mostWinsLeaderboard.transform, worldPositionStays: false);
				gameObject.GetComponent<Text>().text = $"{value.Rank} - {value.User.OculusID} - {value.Score}";
			}
		}

		private void HighestScoreLeaderboardCallback(SortedDictionary<int, LeaderboardEntry> entries)
		{
			foreach (Transform item in m_highestScoresLeaderboard.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (LeaderboardEntry value in entries.Values)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_leaderboardEntryPrefab);
				gameObject.transform.SetParent(m_highestScoresLeaderboard.transform, worldPositionStays: false);
				gameObject.GetComponent<Text>().text = $"{value.Rank} - {value.User.OculusID} - {value.Score}";
			}
		}

		private void CalculateMatchResults()
		{
			LocalPlayer localPlayer = null;
			RemotePlayer remotePlayer = null;
			PlayerArea[] playerAreas = m_playerAreas;
			foreach (PlayerArea playerArea in playerAreas)
			{
				if (playerArea.Player is LocalPlayer)
				{
					localPlayer = playerArea.Player as LocalPlayer;
				}
				else if (playerArea.Player is RemotePlayer && (remotePlayer == null || playerArea.Player.Score > remotePlayer.Score))
				{
					remotePlayer = playerArea.Player as RemotePlayer;
				}
			}
			if ((bool)localPlayer && (bool)remotePlayer)
			{
				bool flag = localPlayer.Score > remotePlayer.Score;
				PlatformManager.Leaderboards.SubmitMatchScores(flag, localPlayer.Score);
				if (flag)
				{
					PlatformManager.Achievements.RecordWinForLocalUser();
				}
			}
		}

		private void DisplayAchievementFlytext()
		{
			if (PlatformManager.Achievements.LikesToWin)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_flytext);
				gameObject.GetComponent<Text>().text = "Likes to Win!";
				gameObject.transform.position = Vector3.up * 40f;
				gameObject.transform.SetParent(m_playerAreas[m_localSlot].NameText.transform, worldPositionStays: false);
			}
		}
	}
	public class MatchmakingManager
	{
		public delegate void OnEnqueueResult(bool successful);

		public delegate Player OnMatchPlayerAdded(int slot, User user);

		private const string NORMAL_POOL = "NORMAL_QUICKMATCH";

		private ulong m_matchRoom;

		private readonly Dictionary<ulong, User> m_remotePlayers;

		private OnEnqueueResult m_enqueueCallback;

		private OnMatchPlayerAdded m_playerCallback;

		public OnEnqueueResult EnqueueResultCallback
		{
			private get
			{
				return m_enqueueCallback;
			}
			set
			{
				m_enqueueCallback = value;
			}
		}

		public OnMatchPlayerAdded MatchPlayerAddedCallback
		{
			private get
			{
				return m_playerCallback;
			}
			set
			{
				m_playerCallback = value;
			}
		}

		public MatchmakingManager()
		{
			m_remotePlayers = new Dictionary<ulong, User>();
			Matchmaking.SetMatchFoundNotificationCallback(MatchFoundCallback);
			Rooms.SetUpdateNotificationCallback(MatchmakingRoomUpdateCallback);
		}

		public void QueueForMatch()
		{
			Matchmaking.Enqueue("NORMAL_QUICKMATCH").OnComplete(MatchmakingEnqueueCallback);
		}

		private void MatchmakingEnqueueCallback(Message msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				EnqueueResultCallback(successful: false);
			}
		}

		private void MatchFoundCallback(Message<Room> msg)
		{
			m_matchRoom = msg.Data.ID;
			Matchmaking.JoinRoom(msg.Data.ID, subscribeToUpdates: true).OnComplete(MatchmakingJoinRoomCallback);
		}

		private void MatchmakingJoinRoomCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				EnqueueResultCallback(successful: false);
				return;
			}
			Debug.Log("Match found and room joined " + m_matchRoom);
			EnqueueResultCallback(successful: true);
			int num = 0;
			if (msg.Data.UsersOptional == null)
			{
				return;
			}
			foreach (User item in msg.Data.UsersOptional)
			{
				Player player = MatchPlayerAddedCallback(num++, item);
				if (PlatformManager.MyID != item.ID)
				{
					m_remotePlayers[item.ID] = item;
					PlatformManager.P2P.AddRemotePlayer(player as RemotePlayer);
				}
			}
		}

		private void MatchmakingRoomUpdateCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
			}
			else
			{
				if (msg.Data.ID != m_matchRoom || msg.Data.UsersOptional == null)
				{
					return;
				}
				foreach (User item in msg.Data.UsersOptional)
				{
					if (PlatformManager.MyID != item.ID && !m_remotePlayers.ContainsKey(item.ID))
					{
						m_remotePlayers[item.ID] = item;
						Player player = MatchPlayerAddedCallback(m_remotePlayers.Count, item);
						PlatformManager.P2P.AddRemotePlayer(player as RemotePlayer);
					}
				}
			}
		}

		public void EndMatch()
		{
			if (m_matchRoom != 0)
			{
				Rooms.Leave(m_matchRoom);
				m_remotePlayers.Clear();
				PlatformManager.P2P.DisconnectAll();
				m_matchRoom = 0uL;
			}
		}

		public void LeaveQueue()
		{
			Matchmaking.Cancel();
			EndMatch();
		}
	}
	public class P2PManager
	{
		private class RemotePlayerData
		{
			public PeerConnectionState state;

			public RemotePlayer player;

			public float remoteTimeOffset;

			public float lastReceivedBallsTime;

			public readonly Dictionary<int, P2PNetworkBall> activeBalls = new Dictionary<int, P2PNetworkBall>();
		}

		public delegate float StartTimeOffer(float remoteTime);

		private readonly Dictionary<ulong, RemotePlayerData> m_remotePlayers = new Dictionary<ulong, RemotePlayerData>();

		private float m_timeForNextBallUpdate;

		private const byte TIME_SYNC_MESSAGE = 1;

		private const uint TIME_SYNC_MESSAGE_SIZE = 5u;

		private const int TIME_SYNC_MESSAGE_COUNT = 7;

		private const byte START_TIME_MESSAGE = 2;

		private const uint START_TIME_MESSAGE_SIZE = 5u;

		private const byte BACKBOARD_UPDATE_MESSAGE = 3;

		private const uint BACKBOARD_UPDATE_MESSAGE_SIZE = 41u;

		private const byte LOCAL_BALLS_UPDATE_MESSAGE = 4;

		private const uint LOCAL_BALLS_UPDATE_MESSATE_SIZE_MAX = 353u;

		private const float LOCAL_BALLS_UPDATE_DELAY = 0.1f;

		private const byte SCORE_UPDATE_MESSAGE = 5;

		private const uint SCORE_UPDATE_MESSAGE_SIZE = 5u;

		private readonly Dictionary<int, P2PNetworkBall> m_localBalls = new Dictionary<int, P2PNetworkBall>();

		private readonly byte[] readBuffer = new byte[353];

		private readonly Dictionary<ulong, List<float>> m_remoteSyncTimeCache = new Dictionary<ulong, List<float>>();

		private readonly Dictionary<ulong, float> m_remoteSentTimeCache = new Dictionary<ulong, float>();

		private StartTimeOffer m_startTimeOfferCallback;

		public StartTimeOffer StartTimeOfferCallback
		{
			private get
			{
				return m_startTimeOfferCallback;
			}
			set
			{
				m_startTimeOfferCallback = value;
			}
		}

		public P2PManager()
		{
			Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
			Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
		}

		public void UpdateNetwork()
		{
			if (m_remotePlayers.Count == 0)
			{
				return;
			}
			Packet packet;
			while ((packet = Net.ReadPacket()) != null)
			{
				if (m_remotePlayers.ContainsKey(packet.SenderID))
				{
					packet.ReadBytes(readBuffer);
					switch (readBuffer[0])
					{
					case 1:
						ReadTimeSyncMessage(packet.SenderID, readBuffer);
						break;
					case 2:
						ReceiveMatchStartTimeOffer(packet.SenderID, readBuffer);
						break;
					case 3:
						ReceiveBackboardUpdate(packet.SenderID, readBuffer);
						break;
					case 4:
						ReceiveBallTransforms(packet.SenderID, readBuffer, packet.Size);
						break;
					case 5:
						ReceiveScoredUpdate(packet.SenderID, readBuffer);
						break;
					}
				}
			}
			if (Time.time >= m_timeForNextBallUpdate && m_localBalls.Count > 0)
			{
				SendLocalBallTransforms();
			}
		}

		public void AddRemotePlayer(RemotePlayer player)
		{
			if (!m_remotePlayers.ContainsKey(player.ID))
			{
				m_remotePlayers[player.ID] = new RemotePlayerData();
				m_remotePlayers[player.ID].state = PeerConnectionState.Unknown;
				m_remotePlayers[player.ID].player = player;
				if (PlatformManager.MyID < player.ID)
				{
					Debug.Log("P2P Try Connect to: " + player.ID);
					Net.Connect(player.ID);
				}
			}
		}

		public void DisconnectAll()
		{
			foreach (ulong key in m_remotePlayers.Keys)
			{
				Net.Close(key);
			}
			m_remotePlayers.Clear();
		}

		private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
		{
			if (m_remotePlayers.ContainsKey(msg.Data.ID))
			{
				Debug.LogFormat("P2P Accepting Connection request from {0}", msg.Data.ID);
				Net.Accept(msg.Data.ID);
			}
			else
			{
				Debug.LogFormat("P2P Ignoring unauthorized Connection request from {0}", msg.Data.ID);
			}
		}

		private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("P2P {0} Connection state changed to {1}", msg.Data.ID, msg.Data.State);
			if (!m_remotePlayers.ContainsKey(msg.Data.ID))
			{
				return;
			}
			m_remotePlayers[msg.Data.ID].state = msg.Data.State;
			switch (msg.Data.State)
			{
			case PeerConnectionState.Connected:
				if (PlatformManager.MyID < msg.Data.ID)
				{
					SendTimeSyncMessage(msg.Data.ID);
				}
				break;
			case PeerConnectionState.Timeout:
				if (PlatformManager.MyID < msg.Data.ID)
				{
					Net.Connect(msg.Data.ID);
				}
				break;
			case PeerConnectionState.Closed:
				m_remotePlayers.Remove(msg.Data.ID);
				break;
			}
		}

		private void SendTimeSyncMessage(ulong remoteID)
		{
			if (!m_remoteSyncTimeCache.ContainsKey(remoteID))
			{
				m_remoteSyncTimeCache[remoteID] = new List<float>();
			}
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			m_remoteSentTimeCache[remoteID] = realtimeSinceStartup;
			byte[] array = new byte[5] { 1, 0, 0, 0, 0 };
			int offset = 1;
			PackFloat(realtimeSinceStartup, array, ref offset);
			Net.SendPacket(remoteID, array, SendPolicy.Reliable);
		}

		private void ReadTimeSyncMessage(ulong remoteID, byte[] msg)
		{
			if (!m_remoteSentTimeCache.ContainsKey(remoteID))
			{
				SendTimeSyncMessage(remoteID);
				return;
			}
			int offset = 1;
			float num = UnpackFloat(msg, ref offset);
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float num2 = (realtimeSinceStartup - m_remoteSentTimeCache[remoteID]) / 2f;
			float item = realtimeSinceStartup - (num + num2);
			m_remoteSyncTimeCache[remoteID].Add(item);
			if (m_remoteSyncTimeCache[remoteID].Count < 7)
			{
				SendTimeSyncMessage(remoteID);
				return;
			}
			if (PlatformManager.MyID < remoteID)
			{
				SendTimeSyncMessage(remoteID);
			}
			m_remoteSyncTimeCache[remoteID].Sort();
			float num3 = m_remoteSyncTimeCache[remoteID][3];
			double num4 = 0.0;
			foreach (float item2 in m_remoteSyncTimeCache[remoteID])
			{
				num4 += (double)item2;
			}
			num4 /= 7.0;
			double num5 = 0.0;
			foreach (float item3 in m_remoteSyncTimeCache[remoteID])
			{
				num5 += (num4 - (double)item3) * (num4 - (double)item3);
			}
			num5 = Math.Sqrt(num5) / 7.0;
			num4 = 0.0;
			int num6 = 0;
			foreach (float item4 in m_remoteSyncTimeCache[remoteID])
			{
				if ((double)Math.Abs(item4 - num3) < num5)
				{
					num4 += (double)item4;
					num6++;
				}
			}
			num4 /= (double)num6;
			Debug.LogFormat("Time offset to {0} is {1}", remoteID, num4);
			m_remoteSyncTimeCache.Remove(remoteID);
			m_remoteSentTimeCache.Remove(remoteID);
			m_remotePlayers[remoteID].remoteTimeOffset = (float)num4;
			OfferMatchStartTime();
		}

		private float ShiftRemoteTime(ulong remoteID, float remoteTime)
		{
			if (m_remotePlayers.ContainsKey(remoteID))
			{
				return remoteTime + m_remotePlayers[remoteID].remoteTimeOffset;
			}
			return remoteTime;
		}

		private void OfferMatchStartTime()
		{
			byte[] array = new byte[5] { 2, 0, 0, 0, 0 };
			int offset = 1;
			PackFloat(StartTimeOfferCallback(0f), array, ref offset);
			foreach (ulong key in m_remotePlayers.Keys)
			{
				if (m_remotePlayers[key].state == PeerConnectionState.Connected)
				{
					Net.SendPacket(key, array, SendPolicy.Reliable);
				}
			}
		}

		private void ReceiveMatchStartTimeOffer(ulong remoteID, byte[] msg)
		{
			int offset = 1;
			float remoteTime = UnpackTime(remoteID, msg, ref offset);
			StartTimeOfferCallback(remoteTime);
		}

		public void SendBackboardUpdate(float time, Vector3 pos, Vector3 moveDir, Vector3 nextMoveDir)
		{
			byte[] array = new byte[41];
			array[0] = 3;
			int offset = 1;
			PackFloat(time, array, ref offset);
			PackVector3(pos, array, ref offset);
			PackVector3(moveDir, array, ref offset);
			PackVector3(nextMoveDir, array, ref offset);
			foreach (KeyValuePair<ulong, RemotePlayerData> remotePlayer in m_remotePlayers)
			{
				if (remotePlayer.Value.state == PeerConnectionState.Connected)
				{
					Net.SendPacket(remotePlayer.Key, array, SendPolicy.Reliable);
				}
			}
		}

		private void ReceiveBackboardUpdate(ulong remoteID, byte[] msg)
		{
			int offset = 1;
			float remoteTime = UnpackTime(remoteID, msg, ref offset);
			Vector3 pos = UnpackVector3(msg, ref offset);
			Vector3 moveDir = UnpackVector3(msg, ref offset);
			Vector3 nextMoveDir = UnpackVector3(msg, ref offset);
			P2PNetworkGoal goal = m_remotePlayers[remoteID].player.Goal;
			goal.RemoteBackboardUpdate(remoteTime, pos, moveDir, nextMoveDir);
		}

		public void AddNetworkBall(GameObject ball)
		{
			m_localBalls[ball.GetInstanceID()] = ball.AddComponent<P2PNetworkBall>();
		}

		public void RemoveNetworkBall(GameObject ball)
		{
			m_localBalls.Remove(ball.GetInstanceID());
		}

		private void SendLocalBallTransforms()
		{
			m_timeForNextBallUpdate = Time.time + 0.1f;
			int num = 5 + m_localBalls.Count * 29;
			byte[] array = new byte[num];
			array[0] = 4;
			int offset = 1;
			PackFloat(Time.realtimeSinceStartup, array, ref offset);
			foreach (P2PNetworkBall value in m_localBalls.Values)
			{
				PackBool(value.IsHeld(), array, ref offset);
				PackInt32(value.gameObject.GetInstanceID(), array, ref offset);
				PackVector3(value.transform.localPosition, array, ref offset);
				PackVector3(value.velocity, array, ref offset);
			}
			foreach (KeyValuePair<ulong, RemotePlayerData> remotePlayer in m_remotePlayers)
			{
				if (remotePlayer.Value.state == PeerConnectionState.Connected)
				{
					Net.SendPacket(remotePlayer.Key, array, SendPolicy.Unreliable);
				}
			}
		}

		private void ReceiveBallTransforms(ulong remoteID, byte[] msg, ulong msgLength)
		{
			int offset = 1;
			float num = UnpackTime(remoteID, msg, ref offset);
			if (num < m_remotePlayers[remoteID].lastReceivedBallsTime)
			{
				return;
			}
			m_remotePlayers[remoteID].lastReceivedBallsTime = num;
			while (offset != (int)msgLength)
			{
				bool isHeld = UnpackBool(msg, ref offset);
				int key = UnpackInt32(msg, ref offset);
				Vector3 pos = UnpackVector3(msg, ref offset);
				Vector3 vel = UnpackVector3(msg, ref offset);
				if (!m_remotePlayers[remoteID].activeBalls.ContainsKey(key))
				{
					P2PNetworkBall p2PNetworkBall = m_remotePlayers[remoteID].player.CreateBall().AddComponent<P2PNetworkBall>();
					p2PNetworkBall.transform.SetParent(m_remotePlayers[remoteID].player.transform.parent);
					m_remotePlayers[remoteID].activeBalls[key] = p2PNetworkBall;
				}
				P2PNetworkBall p2PNetworkBall2 = m_remotePlayers[remoteID].activeBalls[key];
				if ((bool)p2PNetworkBall2)
				{
					p2PNetworkBall2.ProcessRemoteUpdate(num, isHeld, pos, vel);
				}
			}
		}

		public void SendScoreUpdate(uint score)
		{
			byte[] array = new byte[5] { 5, 0, 0, 0, 0 };
			int offset = 1;
			PackUint32(score, array, ref offset);
			foreach (KeyValuePair<ulong, RemotePlayerData> remotePlayer in m_remotePlayers)
			{
				if (remotePlayer.Value.state == PeerConnectionState.Connected)
				{
					Net.SendPacket(remotePlayer.Key, array, SendPolicy.Reliable);
				}
			}
		}

		private void ReceiveScoredUpdate(ulong remoteID, byte[] msg)
		{
			int offset = 1;
			uint score = UnpackUint32(msg, ref offset);
			m_remotePlayers[remoteID].player.ReceiveRemoteScore(score);
		}

		private void PackVector3(Vector3 vec, byte[] buf, ref int offset)
		{
			PackFloat(vec.x, buf, ref offset);
			PackFloat(vec.y, buf, ref offset);
			PackFloat(vec.z, buf, ref offset);
		}

		private Vector3 UnpackVector3(byte[] buf, ref int offset)
		{
			Vector3 result = default(Vector3);
			result.x = UnpackFloat(buf, ref offset);
			result.y = UnpackFloat(buf, ref offset);
			result.z = UnpackFloat(buf, ref offset);
			return result;
		}

		private void PackQuaternion(Quaternion quat, byte[] buf, ref int offset)
		{
			PackFloat(quat.x, buf, ref offset);
			PackFloat(quat.y, buf, ref offset);
			PackFloat(quat.z, buf, ref offset);
			PackFloat(quat.w, buf, ref offset);
		}

		private void PackFloat(float value, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(value), 0, buf, offset, 4);
			offset += 4;
		}

		private float UnpackFloat(byte[] buf, ref int offset)
		{
			float result = BitConverter.ToSingle(buf, offset);
			offset += 4;
			return result;
		}

		private float UnpackTime(ulong remoteID, byte[] buf, ref int offset)
		{
			return ShiftRemoteTime(remoteID, UnpackFloat(buf, ref offset));
		}

		private void PackInt32(int value, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(value), 0, buf, offset, 4);
			offset += 4;
		}

		private int UnpackInt32(byte[] buf, ref int offset)
		{
			int result = BitConverter.ToInt32(buf, offset);
			offset += 4;
			return result;
		}

		private void PackUint32(uint value, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(value), 0, buf, offset, 4);
			offset += 4;
		}

		private uint UnpackUint32(byte[] buf, ref int offset)
		{
			uint result = BitConverter.ToUInt32(buf, offset);
			offset += 4;
			return result;
		}

		private void PackBool(bool value, byte[] buf, ref int offset)
		{
			buf[offset++] = (byte)(value ? 1u : 0u);
		}

		private bool UnpackBool(byte[] buf, ref int offset)
		{
			return buf[offset++] != 0;
		}
	}
	public class P2PNetworkBall : MonoBehaviour
	{
		private float lastCollisionTime;

		private Rigidbody rigidBody;

		public Vector3 velocity => rigidBody.velocity;

		private void Awake()
		{
			rigidBody = base.gameObject.GetComponent<Rigidbody>();
		}

		public bool IsHeld()
		{
			return !rigidBody.useGravity;
		}

		public void ProcessRemoteUpdate(float remoteTime, bool isHeld, Vector3 pos, Vector3 vel)
		{
			if (isHeld)
			{
				base.transform.localPosition = pos;
			}
			else if (lastCollisionTime < remoteTime)
			{
				float time = Time.realtimeSinceStartup - remoteTime;
				base.transform.localPosition = estimatePosition(pos, vel, time);
				rigidBody.velocity = estimateVelocity(vel, time);
				if (IsHeld())
				{
					rigidBody.useGravity = true;
					rigidBody.detectCollisions = true;
				}
			}
		}

		private Vector3 estimatePosition(Vector3 startPosition, Vector3 startVelocty, float time)
		{
			return startPosition + startVelocty * time + 0.5f * Physics.gravity * time * time;
		}

		private Vector3 estimateVelocity(Vector3 startVelocity, float time)
		{
			return startVelocity + Physics.gravity * time * Mathf.Clamp01(1f - rigidBody.drag * time);
		}

		private void OnCollisionEnter(Collision collision)
		{
			lastCollisionTime = Time.realtimeSinceStartup;
		}

		private void OnDestroy()
		{
			PlatformManager.P2P.RemoveNetworkBall(base.gameObject);
		}
	}
	public class P2PNetworkGoal : MonoBehaviour
	{
		private GoalMover m_goal;

		private Vector3 m_lastSentMoveDirection;

		private bool m_sendUpdates;

		public bool SendUpdates
		{
			set
			{
				m_sendUpdates = value;
			}
		}

		private void Awake()
		{
			m_goal = base.gameObject.GetComponent<GoalMover>();
		}

		private void FixedUpdate()
		{
			if (m_sendUpdates && m_goal.MoveDirection != m_lastSentMoveDirection)
			{
				SendBackboardUpdate();
			}
		}

		public void SendBackboardUpdate()
		{
			m_lastSentMoveDirection = m_goal.MoveDirection;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			PlatformManager.P2P.SendBackboardUpdate(realtimeSinceStartup, base.transform.localPosition, m_goal.MoveDirection, m_goal.NextMoveDirection);
		}

		public void RemoteBackboardUpdate(float remoteTime, Vector3 pos, Vector3 moveDir, Vector3 nextMoveDir)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float f = (realtimeSinceStartup - remoteTime) / Time.fixedDeltaTime;
			m_goal.ExpectedPosition = pos + Mathf.Round(f) * moveDir;
			m_goal.MoveDirection = moveDir;
			m_goal.NextMoveDirection = nextMoveDir;
		}
	}
	public class PlatformManager : MonoBehaviour
	{
		public enum State
		{
			INITIALIZING,
			WAITING_TO_PRACTICE_OR_MATCHMAKE,
			MATCH_TRANSITION,
			PLAYING_A_LOCAL_MATCH,
			PLAYING_A_NETWORKED_MATCH
		}

		private static PlatformManager s_instance;

		private MatchmakingManager m_matchmaking;

		private P2PManager m_p2p;

		private LeaderboardManager m_leaderboards;

		private AchievementsManager m_achievements;

		private State m_currentState;

		private ulong m_myID;

		private string m_myOculusID;

		public static MatchmakingManager Matchmaking => s_instance.m_matchmaking;

		public static P2PManager P2P => s_instance.m_p2p;

		public static LeaderboardManager Leaderboards => s_instance.m_leaderboards;

		public static AchievementsManager Achievements => s_instance.m_achievements;

		public static State CurrentState => s_instance.m_currentState;

		public static ulong MyID
		{
			get
			{
				if (s_instance != null)
				{
					return s_instance.m_myID;
				}
				return 0uL;
			}
		}

		public static string MyOculusID
		{
			get
			{
				if (s_instance != null && s_instance.m_myOculusID != null)
				{
					return s_instance.m_myOculusID;
				}
				return string.Empty;
			}
		}

		private void Update()
		{
			m_p2p.UpdateNetwork();
			m_leaderboards.CheckForUpdates();
		}

		private void Awake()
		{
			if (s_instance != null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			s_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			Core.Initialize();
			m_matchmaking = new MatchmakingManager();
			m_p2p = new P2PManager();
			m_leaderboards = new LeaderboardManager();
			m_achievements = new AchievementsManager();
		}

		private void Start()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
		}

		private void IsEntitledCallback(Message msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
			}
			else
			{
				Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
			}
		}

		private void GetLoggedInUserCallback(Message<User> msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
				return;
			}
			m_myID = msg.Data.ID;
			m_myOculusID = msg.Data.OculusID;
			TransitionToState(State.WAITING_TO_PRACTICE_OR_MATCHMAKE);
			Achievements.CheckForAchievmentUpdates();
		}

		public static void TerminateWithError(Message msg)
		{
			Debug.Log("Error: " + msg.GetError().Message);
			UnityEngine.Application.Quit();
		}

		public void QuitButtonPressed()
		{
			UnityEngine.Application.Quit();
		}

		private void OnApplicationQuit()
		{
			Matchmaking.LeaveQueue();
		}

		public static void TransitionToState(State newState)
		{
			if ((bool)s_instance && s_instance.m_currentState != newState)
			{
				s_instance.m_currentState = newState;
			}
		}
	}
	public abstract class Player : MonoBehaviour
	{
		public const uint MAX_BALLS = 6u;

		private const float INITIAL_FORCE = 870f;

		private const float RESPAWN_SECONDS = 2f;

		private uint m_score;

		private Text m_scoreUI;

		private GameObject m_ballPrefab;

		private BallEjector m_ballEjector;

		private Queue<GameObject> m_balls = new Queue<GameObject>();

		private GameObject m_heldBall;

		private float m_nextSpawnTime;

		public virtual uint Score
		{
			get
			{
				return m_score;
			}
			set
			{
				m_score = value;
				if ((bool)m_scoreUI)
				{
					m_scoreUI.text = m_score.ToString();
				}
			}
		}

		public GameObject BallPrefab
		{
			set
			{
				m_ballPrefab = value;
			}
		}

		protected bool HasBall => m_heldBall != null;

		private void Start()
		{
			m_ballEjector = base.transform.GetComponentInChildren<BallEjector>();
			m_scoreUI = base.transform.parent.GetComponentInChildren<Text>();
			m_scoreUI.text = "0";
		}

		public GameObject CreateBall()
		{
			if ((long)m_balls.Count >= 6L)
			{
				UnityEngine.Object.Destroy(m_balls.Dequeue());
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(m_ballPrefab);
			m_balls.Enqueue(gameObject);
			gameObject.transform.position = m_ballEjector.transform.position;
			gameObject.transform.SetParent(m_ballEjector.transform, worldPositionStays: true);
			gameObject.GetComponent<Rigidbody>().useGravity = false;
			gameObject.GetComponent<Rigidbody>().detectCollisions = false;
			gameObject.GetComponent<DetectBasket>().Player = this;
			return gameObject;
		}

		protected GameObject CheckSpawnBall()
		{
			PlatformManager.State currentState = PlatformManager.CurrentState;
			if ((currentState == PlatformManager.State.WAITING_TO_PRACTICE_OR_MATCHMAKE || currentState == PlatformManager.State.PLAYING_A_LOCAL_MATCH || currentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH) && Time.time >= m_nextSpawnTime && !HasBall)
			{
				m_heldBall = CreateBall();
				return m_heldBall;
			}
			return null;
		}

		protected GameObject ShootBall()
		{
			GameObject heldBall = m_heldBall;
			m_heldBall = null;
			heldBall.GetComponent<Rigidbody>().useGravity = true;
			heldBall.GetComponent<Rigidbody>().detectCollisions = true;
			heldBall.GetComponent<Rigidbody>().AddForce(m_ballEjector.transform.forward * 870f, ForceMode.Acceleration);
			heldBall.transform.SetParent(base.transform.parent, worldPositionStays: true);
			m_nextSpawnTime = Time.time + 2f;
			return heldBall;
		}

		private void OnDestroy()
		{
			foreach (GameObject ball in m_balls)
			{
				UnityEngine.Object.Destroy(ball);
			}
		}
	}
	public class PlayerArea : MonoBehaviour
	{
		[SerializeField]
		private GameObject m_ballPrefab;

		private GameObject m_playerHead;

		private Text m_nameText;

		private P2PNetworkGoal m_p2pGoal;

		public Player Player => m_playerHead.GetComponent<Player>();

		public Text NameText => m_nameText;

		private void Awake()
		{
			m_playerHead = base.gameObject.transform.Find("Player Head").gameObject;
			m_nameText = base.gameObject.GetComponentsInChildren<Text>()[1];
			m_p2pGoal = base.gameObject.GetComponentInChildren<P2PNetworkGoal>();
		}

		public T SetupForPlayer<T>(string name) where T : Player
		{
			Player component = m_playerHead.GetComponent<Player>();
			if ((bool)component)
			{
				UnityEngine.Object.Destroy(component);
			}
			T val = m_playerHead.AddComponent<T>();
			val.BallPrefab = m_ballPrefab;
			m_nameText.text = name;
			if (val is RemotePlayer)
			{
				(val as RemotePlayer).Goal = m_p2pGoal;
				m_p2pGoal.SendUpdates = false;
			}
			else if (val is LocalPlayer)
			{
				m_p2pGoal.SendUpdates = true;
			}
			else
			{
				m_p2pGoal.SendUpdates = false;
			}
			return val;
		}
	}
	public class RemotePlayer : Player
	{
		private User m_user;

		private P2PNetworkGoal m_goal;

		public User User
		{
			set
			{
				m_user = value;
			}
		}

		public ulong ID => m_user.ID;

		public P2PNetworkGoal Goal
		{
			get
			{
				return m_goal;
			}
			set
			{
				m_goal = value;
			}
		}

		public override uint Score
		{
			set
			{
			}
		}

		public void ReceiveRemoteScore(uint score)
		{
			base.Score = score;
		}
	}
	public class VREyeRaycaster : MonoBehaviour
	{
		[SerializeField]
		private EventSystem m_eventSystem;

		private Button m_currentButton;

		private void Update()
		{
			Button button = null;
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 50f))
			{
				button = hitInfo.collider.GetComponent<Button>();
			}
			if (button != null)
			{
				if (m_currentButton != button)
				{
					m_currentButton = button;
					m_currentButton.Select();
				}
			}
			else if (m_currentButton != null)
			{
				m_currentButton = null;
				if (m_eventSystem != null)
				{
					m_eventSystem.SetSelectedGameObject(null);
				}
			}
		}
	}
}
namespace Oculus.Platform.Samples.VrVoiceChat
{
	public class P2PManager
	{
		private static readonly float UPDATE_DELAY = 0.1f;

		private ulong m_remoteID;

		private PeerConnectionState m_state;

		private float m_timeForNextUpdate;

		private static readonly byte PACKET_SIZE = 29;

		private static readonly byte PACKET_FORMAT;

		private readonly byte[] sendTransformBuffer = new byte[PACKET_SIZE];

		private readonly byte[] receiveTransformBuffer = new byte[PACKET_SIZE];

		private Vector3 receivedPosition;

		private Vector3 receivedPositionPrior;

		private Quaternion receivedRotation;

		private Quaternion receivedRotationPrior;

		private float receivedTime;

		public bool Connected => m_state == PeerConnectionState.Connected;

		public bool ShouldSendHeadUpdate => Time.time >= m_timeForNextUpdate && m_state == PeerConnectionState.Connected;

		public P2PManager(Transform initialHeadTransform)
		{
			receivedPositionPrior = (receivedPosition = initialHeadTransform.localPosition);
			receivedRotationPrior = (receivedRotation = initialHeadTransform.localRotation);
			Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
			Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
		}

		public void ConnectTo(ulong userID)
		{
			m_remoteID = userID;
			if (PlatformManager.MyID < userID)
			{
				Net.Connect(userID);
			}
		}

		public void Disconnect()
		{
			if (m_remoteID != 0)
			{
				Net.Close(m_remoteID);
				m_remoteID = 0uL;
				m_state = PeerConnectionState.Unknown;
			}
		}

		private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Connection request from {0}, authorized is {1}", msg.Data.ID, m_remoteID);
			if (msg.Data.ID == m_remoteID)
			{
				Net.Accept(msg.Data.ID);
			}
		}

		private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Connection state to {0} changed to {1}", msg.Data.ID, msg.Data.State);
			if (msg.Data.ID == m_remoteID)
			{
				m_state = msg.Data.State;
				if (m_state == PeerConnectionState.Timeout && PlatformManager.MyID < m_remoteID)
				{
					Net.Connect(m_remoteID);
				}
			}
			PlatformManager.SetBackgroundColorForState();
		}

		public void SendHeadTransform(Transform headTransform)
		{
			m_timeForNextUpdate = Time.time + UPDATE_DELAY;
			sendTransformBuffer[0] = PACKET_FORMAT;
			int offset = 1;
			PackFloat(headTransform.localPosition.x, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localPosition.y, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localPosition.z, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.x, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.y, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.z, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.w, sendTransformBuffer, ref offset);
			Net.SendPacket(m_remoteID, sendTransformBuffer, SendPolicy.Unreliable);
		}

		private void PackFloat(float f, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
			offset += 4;
		}

		public void GetRemoteHeadTransform(Transform headTransform)
		{
			bool flag = false;
			Packet packet;
			while ((packet = Net.ReadPacket()) != null)
			{
				if (packet.Size != PACKET_SIZE)
				{
					Debug.Log("Invalid packet size: " + packet.Size);
					continue;
				}
				packet.ReadBytes(receiveTransformBuffer);
				if (receiveTransformBuffer[0] != PACKET_FORMAT)
				{
					Debug.Log("Invalid packet type: " + packet.Size);
				}
				else
				{
					flag = true;
				}
			}
			if (flag)
			{
				receivedPositionPrior = receivedPosition;
				receivedPosition.x = BitConverter.ToSingle(receiveTransformBuffer, 1);
				receivedPosition.y = BitConverter.ToSingle(receiveTransformBuffer, 5);
				receivedPosition.z = BitConverter.ToSingle(receiveTransformBuffer, 9);
				receivedRotationPrior = receivedRotation;
				receivedRotation.x = BitConverter.ToSingle(receiveTransformBuffer, 13);
				receivedRotation.y = BitConverter.ToSingle(receiveTransformBuffer, 17) * -1f;
				receivedRotation.z = BitConverter.ToSingle(receiveTransformBuffer, 21);
				receivedRotation.w = BitConverter.ToSingle(receiveTransformBuffer, 25) * -1f;
				receivedTime = Time.time;
			}
			float t = Math.Min(Time.time - receivedTime, UPDATE_DELAY) / UPDATE_DELAY;
			headTransform.localPosition = Vector3.Lerp(receivedPositionPrior, receivedPosition, t);
			headTransform.localRotation = Quaternion.Slerp(receivedRotationPrior, receivedRotation, t);
		}
	}
	public class PlatformManager : MonoBehaviour
	{
		public enum State
		{
			INITIALIZING,
			WAITING_TO_CALL_OR_ANSWER,
			WAITING_FOR_ANSWER,
			CONNECTED_IN_A_ROOM,
			HANGUP
		}

		[SerializeField]
		private GameObject m_invitesList;

		[SerializeField]
		private GameObject m_invitePrefab;

		[SerializeField]
		private Camera m_camera;

		[SerializeField]
		private GameObject m_remoteHead;

		private State m_currentState;

		private static PlatformManager s_instance;

		private RoomManager m_roomManager;

		private P2PManager m_p2pManager;

		private VoipManager m_voipManager;

		private ulong m_myID;

		private string m_myOculusID;

		public static State CurrentState => s_instance.m_currentState;

		public static ulong MyID
		{
			get
			{
				if (s_instance != null)
				{
					return s_instance.m_myID;
				}
				return 0uL;
			}
		}

		public static string MyOculusID
		{
			get
			{
				if (s_instance != null && s_instance.m_myOculusID != null)
				{
					return s_instance.m_myOculusID;
				}
				return string.Empty;
			}
		}

		private void Update()
		{
			if (m_roomManager.ShouldPollInviteList)
			{
				m_roomManager.UpdateActiveInvitesList();
			}
			if (m_p2pManager.ShouldSendHeadUpdate)
			{
				m_p2pManager.SendHeadTransform(m_camera.transform);
			}
			m_p2pManager.GetRemoteHeadTransform(m_remoteHead.transform);
		}

		private void Awake()
		{
			if (s_instance != null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			s_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			TransitionToState(State.INITIALIZING);
			Core.Initialize();
			m_roomManager = new RoomManager();
			m_p2pManager = new P2PManager(m_remoteHead.transform);
			m_voipManager = new VoipManager(m_remoteHead);
		}

		private void Start()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
		}

		private void IsEntitledCallback(Message msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
			}
			else
			{
				Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
			}
		}

		private void GetLoggedInUserCallback(Message<User> msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
				return;
			}
			m_myID = msg.Data.ID;
			m_myOculusID = msg.Data.OculusID;
			TransitionToState(State.WAITING_TO_CALL_OR_ANSWER);
			m_roomManager.CheckForLaunchInvite();
		}

		private void OnApplicationQuit()
		{
			m_roomManager.LeaveCurrentRoom();
			m_p2pManager.Disconnect();
			m_voipManager.Disconnect();
		}

		public static void TerminateWithError(Message msg)
		{
			Debug.Log("Error: " + msg.GetError().Message);
			UnityEngine.Application.Quit();
		}

		public void CallFriendOnClick()
		{
			if (CurrentState == State.WAITING_TO_CALL_OR_ANSWER)
			{
				m_roomManager.CreateRoomAndLaunchInviteMenu();
			}
		}

		public void HangupOnClick()
		{
			m_roomManager.LeaveCurrentRoom();
		}

		public void QuitOnClick()
		{
			UnityEngine.Application.Quit();
		}

		public static void AnswerCallOnClick(ulong roomID)
		{
			if ((bool)s_instance)
			{
				s_instance.m_roomManager.JoinExistingRoom(roomID);
			}
		}

		public static void TransitionToState(State newState)
		{
			Debug.LogFormat("State {0} -> {1}", s_instance.m_currentState, newState);
			if ((bool)s_instance && s_instance.m_currentState != newState)
			{
				s_instance.m_currentState = newState;
				switch (newState)
				{
				case State.HANGUP:
					s_instance.m_roomManager.LeaveCurrentRoom();
					s_instance.m_p2pManager.Disconnect();
					s_instance.m_voipManager.Disconnect();
					break;
				case State.CONNECTED_IN_A_ROOM:
					s_instance.m_p2pManager.ConnectTo(s_instance.m_roomManager.RemoteUserID);
					s_instance.m_voipManager.ConnectTo(s_instance.m_roomManager.RemoteUserID);
					break;
				}
			}
			SetBackgroundColorForState();
		}

		public static void SetBackgroundColorForState()
		{
			switch (s_instance.m_currentState)
			{
			case State.INITIALIZING:
			case State.HANGUP:
				s_instance.m_camera.backgroundColor = Color.black;
				break;
			case State.WAITING_TO_CALL_OR_ANSWER:
				s_instance.m_camera.backgroundColor = new Color(0f, 0f, 0.3f);
				break;
			case State.WAITING_FOR_ANSWER:
				s_instance.m_camera.backgroundColor = new Color(0f, 0f, 0.6f);
				break;
			case State.CONNECTED_IN_A_ROOM:
			{
				float r = ((!s_instance.m_p2pManager.Connected) ? 0f : 1f);
				float g = ((!s_instance.m_voipManager.Connected) ? 0f : 1f);
				s_instance.m_camera.backgroundColor = new Color(r, g, 1f);
				break;
			}
			}
		}

		public static void SetActiveInvites(List<RoomManager.Invite> invites)
		{
			if (!s_instance || !s_instance.m_invitesList || !s_instance.m_invitePrefab)
			{
				return;
			}
			foreach (Transform item in s_instance.m_invitesList.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (RoomManager.Invite invite in invites)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(s_instance.m_invitePrefab);
				gameObject.GetComponentInChildren<Text>().text = invite.OwnerID;
				gameObject.name = invite.RoomID.ToString();
				gameObject.GetComponent<Button>().onClick.AddListener(delegate
				{
					AnswerCallOnClick(invite.RoomID);
				});
				gameObject.transform.SetParent(s_instance.m_invitesList.transform, worldPositionStays: false);
			}
		}
	}
	public class RoomManager
	{
		public struct Invite
		{
			public readonly ulong RoomID;

			public readonly string OwnerID;

			public Invite(ulong roomID, string owner)
			{
				RoomID = roomID;
				OwnerID = owner;
			}
		}

		private ulong m_roomID;

		private User m_remoteUser;

		private static readonly float INVITE_POLL_FREQ_SECONDS = 5f;

		private float m_nextPollTime;

		private HashSet<ulong> m_pendingRoomRequests;

		private List<Invite> m_invites;

		public ulong RemoteUserID => (m_remoteUser == null) ? 0 : m_remoteUser.ID;

		public string RemoteOculusID => (m_remoteUser == null) ? string.Empty : m_remoteUser.OculusID;

		public bool ShouldPollInviteList => m_pendingRoomRequests == null && Time.time >= m_nextPollTime;

		public RoomManager()
		{
			Rooms.SetRoomInviteAcceptedNotificationCallback(LaunchedFromAcceptingInviteCallback);
			Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
		}

		private void LaunchedFromAcceptingInviteCallback(Message<string> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			Debug.Log("Launched Invite to join Room: " + msg.Data);
			m_roomID = Convert.ToUInt64(msg.GetString());
		}

		public bool CheckForLaunchInvite()
		{
			if (m_roomID != 0)
			{
				JoinExistingRoom(m_roomID);
				return true;
			}
			return false;
		}

		public void CreateRoomAndLaunchInviteMenu()
		{
			Rooms.CreateAndJoinPrivate(RoomJoinPolicy.InvitedUsers, 2u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
		}

		private void CreateAndJoinPrivateRoomCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			m_roomID = msg.Data.ID;
			m_remoteUser = null;
			PlatformManager.TransitionToState(PlatformManager.State.WAITING_FOR_ANSWER);
			Rooms.LaunchInvitableUserFlow(m_roomID).OnComplete(OnLaunchInviteWorkflowComplete);
		}

		private void OnLaunchInviteWorkflowComplete(Message msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
			}
		}

		public void UpdateActiveInvitesList()
		{
			m_nextPollTime = Time.time + INVITE_POLL_FREQ_SECONDS;
			m_pendingRoomRequests = new HashSet<ulong>();
			m_invites = new List<Invite>();
			Notifications.GetRoomInviteNotifications().OnComplete(GetRoomInviteNotificationsCallback);
		}

		private void GetRoomInviteNotificationsCallback(Message msg_untyped)
		{
			Message<RoomInviteNotificationList> message = (Message<RoomInviteNotificationList>)msg_untyped;
			if (message.IsError)
			{
				PlatformManager.TerminateWithError(message);
				return;
			}
			foreach (RoomInviteNotification datum in message.Data)
			{
				m_pendingRoomRequests.Add(datum.RoomID);
				Rooms.Get(datum.RoomID).OnComplete(GetRoomInfoCallback);
			}
			if (message.Data.Count == 0)
			{
				m_pendingRoomRequests = null;
				PlatformManager.SetActiveInvites(m_invites);
			}
		}

		private void GetRoomInfoCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			if (msg.Data.OwnerOptional != null)
			{
				Invite item = new Invite(msg.Data.ID, msg.Data.OwnerOptional.OculusID);
				m_pendingRoomRequests.Remove(item.RoomID);
				if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
				{
					m_invites.Add(item);
				}
			}
			if (m_pendingRoomRequests.Count == 0)
			{
				m_pendingRoomRequests = null;
				PlatformManager.SetActiveInvites(m_invites);
			}
		}

		public void JoinExistingRoom(ulong roomID)
		{
			Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
		}

		private void JoinRoomCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				return;
			}
			string text = ((msg.Data.OwnerOptional == null) ? string.Empty : msg.Data.OwnerOptional.OculusID);
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			Debug.LogFormat("Joined room: {0} owner: {1} count: ", msg.Data.ID, text, num);
			m_roomID = msg.Data.ID;
			if (msg.Data.UsersOptional == null || msg.Data.UsersOptional.Count != 2)
			{
				PlatformManager.TransitionToState(PlatformManager.State.HANGUP);
			}
			else
			{
				foreach (User item in msg.Data.UsersOptional)
				{
					if (item.ID != PlatformManager.MyID)
					{
						m_remoteUser = item;
					}
				}
				PlatformManager.TransitionToState(PlatformManager.State.CONNECTED_IN_A_ROOM);
			}
			m_nextPollTime = Time.time;
		}

		private void RoomUpdateCallback(Message<Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			string text = ((msg.Data.OwnerOptional == null) ? string.Empty : msg.Data.OwnerOptional.OculusID);
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			Debug.LogFormat("Room {0} Update: {1} owner: {2} count: ", msg.Data.ID, text, num);
			if (msg.Data.UsersOptional == null || msg.Data.UsersOptional.Count != 2)
			{
				PlatformManager.TransitionToState(PlatformManager.State.HANGUP);
				return;
			}
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != PlatformManager.MyID)
				{
					m_remoteUser = item;
				}
			}
			PlatformManager.TransitionToState(PlatformManager.State.CONNECTED_IN_A_ROOM);
		}

		public void LeaveCurrentRoom()
		{
			if (m_roomID != 0)
			{
				Rooms.Leave(m_roomID);
				m_roomID = 0uL;
				m_remoteUser = null;
			}
			PlatformManager.TransitionToState(PlatformManager.State.WAITING_TO_CALL_OR_ANSWER);
		}
	}
	public class VoipManager
	{
		private ulong m_remoteID;

		private PeerConnectionState m_state;

		private readonly GameObject m_remoteHead;

		public bool Connected => m_state == PeerConnectionState.Connected;

		public VoipManager(GameObject remoteHead)
		{
			m_remoteHead = remoteHead;
			Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
			Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
		}

		public void ConnectTo(ulong userID)
		{
			m_remoteID = userID;
			VoipAudioSourceHiLevel voipAudioSourceHiLevel = m_remoteHead.AddComponent<VoipAudioSourceHiLevel>();
			voipAudioSourceHiLevel.senderID = userID;
			if (PlatformManager.MyID < m_remoteID)
			{
				Voip.Start(userID);
			}
		}

		public void Disconnect()
		{
			if (m_remoteID != 0)
			{
				Voip.Stop(m_remoteID);
				UnityEngine.Object.Destroy(m_remoteHead.GetComponent<VoipAudioSourceHiLevel>(), 0f);
				m_remoteID = 0uL;
				m_state = PeerConnectionState.Unknown;
			}
		}

		private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Voip request from {0}, authorized is {1}", msg.Data.ID, m_remoteID);
			if (msg.Data.ID == m_remoteID)
			{
				Voip.Accept(msg.Data.ID);
			}
		}

		private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Voip state to {0} changed to {1}", msg.Data.ID, msg.Data.State);
			if (msg.Data.ID == m_remoteID)
			{
				m_state = msg.Data.State;
				if (m_state == PeerConnectionState.Timeout && PlatformManager.MyID < m_remoteID)
				{
					Voip.Start(m_remoteID);
				}
			}
			PlatformManager.SetBackgroundColorForState();
		}
	}
	public class VREyeRaycaster : MonoBehaviour
	{
		[SerializeField]
		private EventSystem m_eventSystem;

		private Button m_currentButton;

		private void Update()
		{
			Button button = null;
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 50f))
			{
				button = hitInfo.collider.GetComponent<Button>();
			}
			if (button != null)
			{
				if (m_currentButton != button)
				{
					m_currentButton = button;
					m_currentButton.Select();
				}
			}
			else if (m_currentButton != null)
			{
				m_currentButton = null;
				if (m_eventSystem != null)
				{
					m_eventSystem.SetSelectedGameObject(null);
				}
			}
		}
	}
}
namespace Oculus.Platform
{
	public class AbuseReportOptions
	{
		private IntPtr Handle;

		public AbuseReportOptions()
		{
			Handle = CAPI.ovr_AbuseReportOptions_Create();
		}

		public void SetPreventPeopleChooser(bool value)
		{
			CAPI.ovr_AbuseReportOptions_SetPreventPeopleChooser(Handle, value);
		}

		public void SetReportType(AbuseReportType value)
		{
			CAPI.ovr_AbuseReportOptions_SetReportType(Handle, value);
		}

		public static explicit operator IntPtr(AbuseReportOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~AbuseReportOptions()
		{
			CAPI.ovr_AbuseReportOptions_Destroy(Handle);
		}
	}
	public enum AbuseReportType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OBJECT")]
		Object,
		[Description("USER")]
		User
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class AndroidPlatform
	{
		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return CAPI.ovr_UnityInitWrapper(appId);
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperAsynchronous(appId));
		}
	}
	public class ApplicationOptions
	{
		private IntPtr Handle;

		public ApplicationOptions()
		{
			Handle = CAPI.ovr_ApplicationOptions_Create();
		}

		public void SetDeeplinkMessage(string value)
		{
			CAPI.ovr_ApplicationOptions_SetDeeplinkMessage(Handle, value);
		}

		public static explicit operator IntPtr(ApplicationOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~ApplicationOptions()
		{
			CAPI.ovr_ApplicationOptions_Destroy(Handle);
		}
	}
}
public class BufferedAudioStream
{
	private const bool VerboseLogging = false;

	private AudioSource audio;

	private float[] audioBuffer;

	private int writePos;

	private const float bufferLengthSeconds = 0.25f;

	private const int sampleRate = 48000;

	private const int bufferSize = 12000;

	private const float playbackDelayTimeSeconds = 0.05f;

	private float playbackDelayRemaining;

	private float remainingBufferTime;

	public BufferedAudioStream(AudioSource audio)
	{
		audioBuffer = new float[12000];
		this.audio = audio;
		audio.loop = true;
		audio.clip = AudioClip.Create(string.Empty, 12000, 1, 48000, stream: false);
		Stop();
	}

	public void Update()
	{
		if (remainingBufferTime > 0f)
		{
			if (!audio.isPlaying && remainingBufferTime > 0.05f)
			{
				playbackDelayRemaining -= Time.deltaTime;
				if (playbackDelayRemaining <= 0f)
				{
					audio.Play();
				}
			}
			if (audio.isPlaying)
			{
				remainingBufferTime -= Time.deltaTime;
				if (remainingBufferTime < 0f)
				{
					remainingBufferTime = 0f;
				}
			}
		}
		if (remainingBufferTime <= 0f)
		{
			if (audio.isPlaying)
			{
				Debug.Log("Buffer empty, stopping " + DateTime.Now);
				Stop();
			}
			else if (writePos != 0)
			{
				Debug.LogError("writePos non zero while not playing, how did this happen?");
			}
		}
	}

	private void Stop()
	{
		audio.Stop();
		audio.time = 0f;
		writePos = 0;
		playbackDelayRemaining = 0.05f;
	}

	public void AddData(float[] samples)
	{
		int num = samples.Length;
		if (writePos > audioBuffer.Length)
		{
			throw new Exception();
		}
		do
		{
			int num2 = num;
			int num3 = audioBuffer.Length - writePos;
			if (num2 > num3)
			{
				num2 = num3;
			}
			Array.Copy(samples, 0, audioBuffer, writePos, num2);
			num -= num2;
			writePos += num2;
			if (writePos > audioBuffer.Length)
			{
				throw new Exception();
			}
			if (writePos == audioBuffer.Length)
			{
				writePos = 0;
			}
		}
		while (num > 0);
		remainingBufferTime += (float)samples.Length / 48000f;
		audio.clip.SetData(audioBuffer, 0);
	}
}
namespace Oculus.Platform
{
	public static class Callback
	{
		private class RequestCallback
		{
			private Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Message<T>.Callback callback;

			public RequestCallback(Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Message msg)
			{
				if (callback != null)
				{
					if (!hasRegisteredRoomInviteNotificationHandler && msg.Type == Message.MessageType.Notification_Room_InviteAccepted)
					{
						pendingRoomInviteNotifications.Add(msg);
					}
					else if (msg is Message<T>)
					{
						callback((Message<T>)msg);
					}
					else
					{
						Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<ulong, RequestCallback> requestIDsToCallbacks = new Dictionary<ulong, RequestCallback>();

		private static Dictionary<Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Message.MessageType, RequestCallback>();

		private static bool hasRegisteredRoomInviteNotificationHandler = false;

		private static List<Message> pendingRoomInviteNotifications = new List<Message>();

		internal static void SetNotificationCallback<T>(Message.MessageType type, Message<T>.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback<T>(callback);
			if (type == Message.MessageType.Notification_Room_InviteAccepted)
			{
				FlushRoomInviteNotificationQueue();
			}
		}

		internal static void SetNotificationCallback(Message.MessageType type, Message.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback(callback);
		}

		internal static void OnComplete<T>(Request<T> request, Message<T>.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback<T>(callback);
		}

		internal static void OnComplete(Request request, Message.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback(callback);
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		private static void FlushRoomInviteNotificationQueue()
		{
			hasRegisteredRoomInviteNotificationHandler = true;
			foreach (Message pendingRoomInviteNotification in pendingRoomInviteNotifications)
			{
				HandleMessage(pendingRoomInviteNotification);
			}
			pendingRoomInviteNotifications.Clear();
		}

		private static void HandleMessage(Message msg)
		{
			if (requestIDsToCallbacks.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToCallbacks.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out value))
			{
				value.HandleMessage(msg);
			}
		}
	}
	public class CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		[DllImport("ovrplatformloader")]
		private static extern void ovr_UnityResetTestPlatform();

		private void Awake()
		{
			CallbackRunner callbackRunner = UnityEngine.Object.FindObjectOfType<CallbackRunner>();
			if (callbackRunner != this)
			{
				Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnDestroy()
		{
		}
	}
	public class CAPI
	{
		public struct ovrKeyValuePair
		{
			public string key_;

			private KeyValuePairType valueType_;

			public string stringValue_;

			public int intValue_;

			public double doubleValue_;

			public ovrKeyValuePair(string key, string value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.String;
				stringValue_ = value;
				intValue_ = 0;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, int value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Int;
				intValue_ = value;
				stringValue_ = null;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, double value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Double;
				doubleValue_ = value;
				stringValue_ = null;
				intValue_ = 0;
			}
		}

		public struct ovrMatchmakingCriterion
		{
			public string key_;

			public MatchmakingCriterionImportance importance_;

			public IntPtr parameterArray;

			public uint parameterArrayCount;

			public ovrMatchmakingCriterion(string key, MatchmakingCriterionImportance importance)
			{
				key_ = key;
				importance_ = importance;
				parameterArray = IntPtr.Zero;
				parameterArrayCount = 0u;
			}
		}

		public struct ovrMatchmakingCustomQueryData
		{
			public IntPtr dataArray;

			public uint dataArrayCount;

			public IntPtr criterionArray;

			public uint criterionArrayCount;
		}

		public struct OculusInitParams
		{
			public int sType;

			public string email;

			public string password;

			public ulong appId;

			public string uriPrefixOverride;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void FilterCallback([In][Out][MarshalAs(UnmanagedType.LPArray, SizeConst = 480)] short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels);

		public const string DLL_NAME = "ovrplatformloader";

		private static UTF8Encoding nativeStringEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public const int VoipFilterBufferSize = 480;

		public static IntPtr ArrayOfStructsToIntPtr(Array ar)
		{
			int num = 0;
			for (int i = 0; i < ar.Length; i++)
			{
				num += Marshal.SizeOf(ar.GetValue(i));
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			IntPtr intPtr2 = intPtr;
			for (int j = 0; j < ar.Length; j++)
			{
				Marshal.StructureToPtr(ar.GetValue(j), intPtr2, fDeleteOld: false);
				intPtr2 = (IntPtr)((long)intPtr2 + Marshal.SizeOf(ar.GetValue(j)));
			}
			return intPtr;
		}

		public static ovrKeyValuePair[] DictionaryToOVRKeyValuePairs(Dictionary<string, object> dict)
		{
			if (dict == null || dict.Count == 0)
			{
				return null;
			}
			ovrKeyValuePair[] array = new ovrKeyValuePair[dict.Count];
			int num = 0;
			foreach (KeyValuePair<string, object> item in dict)
			{
				if (item.Value.GetType() == typeof(int))
				{
					ref ovrKeyValuePair reference = ref array[num];
					reference = new ovrKeyValuePair(item.Key, (int)item.Value);
				}
				else if (item.Value.GetType() == typeof(string))
				{
					ref ovrKeyValuePair reference2 = ref array[num];
					reference2 = new ovrKeyValuePair(item.Key, (string)item.Value);
				}
				else
				{
					if (item.Value.GetType() != typeof(double))
					{
						throw new Exception("Only int, double or string are allowed types in CustomQuery.data");
					}
					ref ovrKeyValuePair reference3 = ref array[num];
					reference3 = new ovrKeyValuePair(item.Key, (double)item.Value);
				}
				num++;
			}
			return array;
		}

		public static byte[] IntPtrToByteArray(IntPtr data, ulong size)
		{
			byte[] array = new byte[size];
			Marshal.Copy(data, array, 0, (int)size);
			return array;
		}

		public static Dictionary<string, string> DataStoreFromNative(IntPtr pointer)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			int num = (int)(uint)ovr_DataStore_GetNumKeys(pointer);
			for (int i = 0; i < num; i++)
			{
				string key = ovr_DataStore_GetKey(pointer, i);
				dictionary[key] = ovr_DataStore_GetValue(pointer, key);
			}
			return dictionary;
		}

		public static string StringFromNative(IntPtr pointer)
		{
			if (pointer == IntPtr.Zero)
			{
				return null;
			}
			int nativeStringLengthNotIncludingNullTerminator = GetNativeStringLengthNotIncludingNullTerminator(pointer);
			byte[] array = new byte[nativeStringLengthNotIncludingNullTerminator];
			Marshal.Copy(pointer, array, 0, nativeStringLengthNotIncludingNullTerminator);
			return nativeStringEncoding.GetString(array);
		}

		public static int GetNativeStringLengthNotIncludingNullTerminator(IntPtr pointer)
		{
			int i;
			for (i = 0; Marshal.ReadByte(pointer, i) != 0; i++)
			{
			}
			return i;
		}

		public static DateTime DateTimeFromNative(ulong seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		public static byte[] BlobFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			for (int i = 0; i < (int)size; i++)
			{
				array[i] = Marshal.ReadByte(pointer, i);
			}
			return array;
		}

		public static byte[] FiledataFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			Marshal.Copy(pointer, array, 0, (int)size);
			return array;
		}

		public static IntPtr StringToNative(string s)
		{
			if (s == null)
			{
				throw new Exception("StringFromNative: null argument");
			}
			int byteCount = nativeStringEncoding.GetByteCount(s);
			byte[] array = new byte[byteCount + 1];
			nativeStringEncoding.GetBytes(s, 0, s.Length, array, 0);
			IntPtr intPtr = Marshal.AllocCoTaskMem(byteCount + 1);
			Marshal.Copy(array, 0, intPtr, byteCount + 1);
			return intPtr;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapper(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityInitGlobals(IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperAsynchronous(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperStandalone(string accessToken, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Platform_InitializeStandaloneOculus(ref OculusInitParams init);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PlatformInitializeWithAccessToken(ulong appId, string accessToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperWindows(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperWindowsAsynchronous(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SetDeveloperAccessToken(string accessToken);

		public static string ovr_GetLoggedInUserLocale()
		{
			return StringFromNative(ovr_GetLoggedInUserLocale_Native());
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GetLoggedInUserLocale")]
		private static extern IntPtr ovr_GetLoggedInUserLocale_Native();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PopMessage();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_FreeMessage(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_NetworkingPeer_GetSendPolicy(IntPtr networkingPeer);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateEncoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyEncoder(IntPtr encoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateDecoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyDecoder(IntPtr decoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, ulong compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Microphone_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Destroy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipPassthrough(bool passthrough);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipMicrophoneMuted(VoipMuteState muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityResetTestPlatform();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HTTP_GetWithMessageType(string url, int messageType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_CrashApplication();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallback(FilterCallback cb);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(FilterCallback cb, UIntPtr bufferSizeElements);

		public static void LogNewEvent(string eventName, Dictionary<string, string> values)
		{
			IntPtr intPtr = StringToNative(eventName);
			int num = values?.Count ?? 0;
			IntPtr[] array = new IntPtr[num * 2];
			if (num > 0)
			{
				int num2 = 0;
				foreach (KeyValuePair<string, string> value in values)
				{
					ref IntPtr reference = ref array[num2 * 2];
					reference = StringToNative(value.Key);
					ref IntPtr reference2 = ref array[num2 * 2 + 1];
					reference2 = StringToNative(value.Value);
					num2++;
				}
			}
			ovr_Log_NewEvent(intPtr, array, (UIntPtr)(ulong)num);
			Marshal.FreeCoTaskMem(intPtr);
			IntPtr[] array2 = array;
			foreach (IntPtr ptr in array2)
			{
				Marshal.FreeCoTaskMem(ptr);
			}
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Log_NewEvent(IntPtr eventName, IntPtr[] values, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationLifecycle_GetLaunchDetails();

		public static ulong ovr_HTTP_StartTransfer(string url, ovrKeyValuePair[] headers)
		{
			IntPtr intPtr = StringToNative(url);
			UIntPtr numItems = (UIntPtr)(ulong)headers.Length;
			ulong result = ovr_HTTP_StartTransfer_Native(intPtr, headers, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_StartTransfer")]
		private static extern ulong ovr_HTTP_StartTransfer_Native(IntPtr url, ovrKeyValuePair[] headers, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HTTP_Write(ulong transferId, byte[] bytes, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_HTTP_WriteEOM(ulong transferId);

		public static string ovr_Message_GetStringForJavascript(IntPtr message)
		{
			return StringFromNative(ovr_Message_GetStringForJavascript_Native(message));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetStringForJavascript")]
		private static extern IntPtr ovr_Message_GetStringForJavascript_Native(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Accept(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_AcceptForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Close(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_CloseForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Connect(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_IsConnected(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Net_Ping(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Net_ReadPacket();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacket(ulong userID, UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacketToCurrentRoom(UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Party_PluginGetSharedMemHandle();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Party_PluginGetVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Party_PluginGetVoipPassthrough();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Party_PluginGetVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Accept(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipDtxState ovr_Voip_GetIsConnectionUsingDtx(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetLocalBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetOutputBufferMaxSize();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCM(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMSize(ulong senderID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestamp(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestampFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetRemoteBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Voip_GetSyncTimestamp(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_Voip_GetSyncTimestampDifference(uint lhs, uint rhs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Voip_GetSystemVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Voip_GetSystemVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneMuted(VoipMuteState state);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetNewConnectionOptions(IntPtr voipOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetOutputSampleRate(VoipSampleRate rate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Start(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Stop(ulong userID);

		public static ulong ovr_Achievements_AddCount(string name, ulong count)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_AddCount_Native(intPtr, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddCount")]
		private static extern ulong ovr_Achievements_AddCount_Native(IntPtr name, ulong count);

		public static ulong ovr_Achievements_AddFields(string name, string fields)
		{
			IntPtr intPtr = StringToNative(name);
			IntPtr intPtr2 = StringToNative(fields);
			ulong result = ovr_Achievements_AddFields_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddFields")]
		private static extern ulong ovr_Achievements_AddFields_Native(IntPtr name, IntPtr fields);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllDefinitions();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllProgress();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetDefinitionsByName(string[] names, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetProgressByName(string[] names, int count);

		public static ulong ovr_Achievements_Unlock(string name)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_Unlock_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_Unlock")]
		private static extern ulong ovr_Achievements_Unlock_Native(IntPtr name);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_ExecuteCoordinatedLaunch(ulong appID, ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetInstalledApplications();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetVersion();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_LaunchOtherApp(ulong appID, IntPtr deeplink_options);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetRegisteredPIDs();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetSessionKey();

		public static ulong ovr_ApplicationLifecycle_RegisterSessionKey(string sessionKey)
		{
			IntPtr intPtr = StringToNative(sessionKey);
			ulong result = ovr_ApplicationLifecycle_RegisterSessionKey_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationLifecycle_RegisterSessionKey")]
		private static extern ulong ovr_ApplicationLifecycle_RegisterSessionKey_Native(IntPtr sessionKey);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Delete(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DeleteById(ulong assetFileID);

		public static ulong ovr_AssetFile_DeleteByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DeleteByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DeleteByName")]
		private static extern ulong ovr_AssetFile_DeleteByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Download(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadByName")]
		private static extern ulong ovr_AssetFile_DownloadByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancel(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancelById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadCancelByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadCancelByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadCancelByName")]
		private static extern ulong ovr_AssetFile_DownloadCancelByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_GetList();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Status(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_StatusById(ulong assetFileID);

		public static ulong ovr_AssetFile_StatusByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_StatusByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_StatusByName")]
		private static extern ulong ovr_AssetFile_StatusByName_Native(IntPtr assetFileName);

		public static ulong ovr_Avatar_UpdateMetaData(string avatarMetaData, string imageFilePath)
		{
			IntPtr intPtr = StringToNative(avatarMetaData);
			IntPtr intPtr2 = StringToNative(imageFilePath);
			ulong result = ovr_Avatar_UpdateMetaData_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Avatar_UpdateMetaData")]
		private static extern ulong ovr_Avatar_UpdateMetaData_Native(IntPtr avatarMetaData, IntPtr imageFilePath);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_FinalizeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong finalized_application_ID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_GetSuggestedApplications(ulong groupingObject, ulong[] userIDs, int numUserIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_ProposeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong proposed_application_ID);

		public static ulong ovr_CloudStorage_Delete(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Delete_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Delete")]
		private static extern ulong ovr_CloudStorage_Delete_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_Load(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Load_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Load")]
		private static extern ulong ovr_CloudStorage_Load_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadBucketMetadata(string bucket)
		{
			IntPtr intPtr = StringToNative(bucket);
			ulong result = ovr_CloudStorage_LoadBucketMetadata_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadBucketMetadata")]
		private static extern ulong ovr_CloudStorage_LoadBucketMetadata_Native(IntPtr bucket);

		public static ulong ovr_CloudStorage_LoadConflictMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadConflictMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadConflictMetadata")]
		private static extern ulong ovr_CloudStorage_LoadConflictMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadHandle(string handle)
		{
			IntPtr intPtr = StringToNative(handle);
			ulong result = ovr_CloudStorage_LoadHandle_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadHandle")]
		private static extern ulong ovr_CloudStorage_LoadHandle_Native(IntPtr handle);

		public static ulong ovr_CloudStorage_LoadMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadMetadata")]
		private static extern ulong ovr_CloudStorage_LoadMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepLocal_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepLocal")]
		private static extern ulong ovr_CloudStorage_ResolveKeepLocal_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepRemote_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepRemote")]
		private static extern ulong ovr_CloudStorage_ResolveKeepRemote_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_Save(string bucket, string key, byte[] data, uint dataSize, long counter, string extraData)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(extraData);
			ulong result = ovr_CloudStorage_Save_Native(intPtr, intPtr2, data, dataSize, counter, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Save")]
		private static extern ulong ovr_CloudStorage_Save_Native(IntPtr bucket, IntPtr key, byte[] data, uint dataSize, long counter, IntPtr extraData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorage2_GetUserDirectoryPath();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Entitlement_GetIsViewerEntitled();

		public static ulong ovr_GraphAPI_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Get")]
		private static extern ulong ovr_GraphAPI_Get_Native(IntPtr url);

		public static ulong ovr_GraphAPI_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Post")]
		private static extern ulong ovr_GraphAPI_Post_Native(IntPtr url);

		public static ulong ovr_HTTP_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Get")]
		private static extern ulong ovr_HTTP_Get_Native(IntPtr url);

		public static ulong ovr_HTTP_GetToFile(string url, string diskFile)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(diskFile);
			ulong result = ovr_HTTP_GetToFile_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_GetToFile")]
		private static extern ulong ovr_HTTP_GetToFile_Native(IntPtr url, IntPtr diskFile);

		public static ulong ovr_HTTP_MultiPartPost(string url, string filepath_param_name, string filepath, string access_token, ovrKeyValuePair[] post_params)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(filepath_param_name);
			IntPtr intPtr3 = StringToNative(filepath);
			IntPtr intPtr4 = StringToNative(access_token);
			UIntPtr numItems = (UIntPtr)(ulong)post_params.Length;
			ulong result = ovr_HTTP_MultiPartPost_Native(intPtr, intPtr2, intPtr3, intPtr4, post_params, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			Marshal.FreeCoTaskMem(intPtr4);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_MultiPartPost")]
		private static extern ulong ovr_HTTP_MultiPartPost_Native(IntPtr url, IntPtr filepath_param_name, IntPtr filepath, IntPtr access_token, ovrKeyValuePair[] post_params, UIntPtr numItems);

		public static ulong ovr_HTTP_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Post")]
		private static extern ulong ovr_HTTP_Post_Native(IntPtr url);

		public static ulong ovr_IAP_ConsumePurchase(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_ConsumePurchase_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_ConsumePurchase")]
		private static extern ulong ovr_IAP_ConsumePurchase_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetProductsBySKU(string[] skus, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchases();

		public static ulong ovr_IAP_LaunchCheckoutFlow(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_LaunchCheckoutFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_LaunchCheckoutFlow")]
		private static extern ulong ovr_IAP_LaunchCheckoutFlow_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LanguagePack_GetCurrent();

		public static ulong ovr_LanguagePack_SetCurrent(string tag)
		{
			IntPtr intPtr = StringToNative(tag);
			ulong result = ovr_LanguagePack_SetCurrent_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePack_SetCurrent")]
		private static extern ulong ovr_LanguagePack_SetCurrent_Native(IntPtr tag);

		public static ulong ovr_Leaderboard_GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntries_Native(intPtr, limit, filter, startAt);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntries")]
		private static extern ulong ovr_Leaderboard_GetEntries_Native(IntPtr leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt);

		public static ulong ovr_Leaderboard_GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntriesAfterRank_Native(intPtr, limit, afterRank);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntriesAfterRank")]
		private static extern ulong ovr_Leaderboard_GetEntriesAfterRank_Native(IntPtr leaderboardName, int limit, ulong afterRank);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetNextEntries(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetPreviousEntries(IntPtr handle);

		public static ulong ovr_Leaderboard_WriteEntry(string leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_WriteEntry_Native(intPtr, score, extraData, extraDataLength, forceUpdate);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_WriteEntry")]
		private static extern ulong ovr_Leaderboard_WriteEntry_Native(IntPtr leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_GetStatus();

		public static ulong ovr_Livestreaming_IsAllowedForApplication(string packageName)
		{
			IntPtr intPtr = StringToNative(packageName);
			ulong result = ovr_Livestreaming_IsAllowedForApplication_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Livestreaming_IsAllowedForApplication")]
		private static extern ulong ovr_Livestreaming_IsAllowedForApplication_Native(IntPtr packageName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_PauseStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_ResumeStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartStream(LivestreamingAudience audience, LivestreamingMicrophoneStatus micStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateCommentsOverlayVisibility(bool isVisible);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateMicStatus(LivestreamingMicrophoneStatus micStatus);

		public static ulong ovr_Matchmaking_Browse(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse")]
		private static extern ulong ovr_Matchmaking_Browse_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Browse2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse2")]
		private static extern ulong ovr_Matchmaking_Browse2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Cancel(string pool, string requestHash)
		{
			IntPtr intPtr = StringToNative(pool);
			IntPtr intPtr2 = StringToNative(requestHash);
			ulong result = ovr_Matchmaking_Cancel_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Cancel")]
		private static extern ulong ovr_Matchmaking_Cancel_Native(IntPtr pool, IntPtr requestHash);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_Cancel2();

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom_Native(intPtr, maxUsers, subscribeToUpdates, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom2")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom_Native(intPtr, maxUsers, subscribeToUpdates);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom")]
		private static extern ulong ovr_Matchmaking_CreateRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_CreateRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom2")]
		private static extern ulong ovr_Matchmaking_CreateRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Enqueue(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue")]
		private static extern ulong ovr_Matchmaking_Enqueue_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Enqueue2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue2")]
		private static extern ulong ovr_Matchmaking_Enqueue2_Native(IntPtr pool, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom(ulong roomID, IntPtr customQueryData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom2(ulong roomID, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_GetAdminSnapshot();

		public static ulong ovr_Matchmaking_GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_GetStats_Native(intPtr, maxLevel, approach);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_GetStats")]
		private static extern ulong ovr_Matchmaking_GetStats_Native(IntPtr pool, uint maxLevel, MatchmakingStatApproach approach);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_JoinRoom(ulong roomID, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_ReportResultInsecure(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Matchmaking_ReportResultInsecure_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_ReportResultInsecure")]
		private static extern ulong ovr_Matchmaking_ReportResultInsecure_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_StartMatch(ulong roomID);

		public static ulong ovr_Media_ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			IntPtr intPtr = StringToNative(postTextSuggestion);
			IntPtr intPtr2 = StringToNative(filePath);
			ulong result = ovr_Media_ShareToFacebook_Native(intPtr, intPtr2, contentType);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Media_ShareToFacebook")]
		private static extern ulong ovr_Media_ShareToFacebook_Native(IntPtr postTextSuggestion, IntPtr filePath, MediaContentType contentType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_GetRoomInvites();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_MarkAsRead(ulong notificationID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GatherInApplication(ulong partyID, ulong appID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Get(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Invite(ulong partyID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Join(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Leave(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Get(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers2(IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetModeratedRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetSocialRooms(ulong appID);

		public static ulong ovr_Room_InviteUser(ulong roomID, string inviteToken)
		{
			IntPtr intPtr = StringToNative(inviteToken);
			ulong result = ovr_Room_InviteUser_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_InviteUser")]
		private static extern ulong ovr_Room_InviteUser_Native(ulong roomID, IntPtr inviteToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join2(ulong roomID, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_KickUser(ulong roomID, ulong userID, int kickDurationSeconds);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_LaunchInvitableUserFlow(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Leave(ulong roomID);

		public static ulong ovr_Room_SetDescription(ulong roomID, string description)
		{
			IntPtr intPtr = StringToNative(description);
			ulong result = ovr_Room_SetDescription_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_SetDescription")]
		private static extern ulong ovr_Room_SetDescription_Native(ulong roomID, IntPtr description);

		public static ulong ovr_Room_UpdateDataStore(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Room_UpdateDataStore_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_UpdateDataStore")]
		private static extern ulong ovr_Room_UpdateDataStore_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateOwner(ulong roomID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_GetStatus(PermissionType permType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_LaunchDeeplink(PermissionType permType);

		public static ulong ovr_User_CancelRecordingForReportFlow(string recordingUUID)
		{
			IntPtr intPtr = StringToNative(recordingUUID);
			ulong result = ovr_User_CancelRecordingForReportFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_CancelRecordingForReportFlow")]
		private static extern ulong ovr_User_CancelRecordingForReportFlow_Native(IntPtr recordingUUID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_Get(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetAccessToken();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLinkedAccounts(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriendsAndRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetOrgScopedID(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetSdkAccounts();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetUserProof();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchBlockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchFriendRequestFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchProfile(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow2(ulong optionalUserID, IntPtr abuseReportOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchUnblockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewEntitledTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_StartRecordingForReportFlow();

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow(ulong optionalUserID, string optionalRecordingUUID)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow_Native(optionalUserID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow_Native(ulong optionalUserID, IntPtr optionalRecordingUUID);

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow2(ulong optionalUserID, string optionalRecordingUUID, IntPtr abuseReportOptions)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow2_Native(optionalUserID, intPtr, abuseReportOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow2")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow2_Native(ulong optionalUserID, IntPtr optionalRecordingUUID, IntPtr abuseReportOptions);

		public static ulong ovr_User_TestUserCreateDeviceManifest(string deviceID, ulong[] appIDs, int numAppIDs)
		{
			IntPtr intPtr = StringToNative(deviceID);
			ulong result = ovr_User_TestUserCreateDeviceManifest_Native(intPtr, appIDs, numAppIDs);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_TestUserCreateDeviceManifest")]
		private static extern ulong ovr_User_TestUserCreateDeviceManifest_Native(IntPtr deviceID, ulong[] appIDs, int numAppIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Voip_SetSystemVoipSuppressed(bool suppressed);

		public static string ovr_AbuseReportRecording_GetRecordingUuid(IntPtr obj)
		{
			return StringFromNative(ovr_AbuseReportRecording_GetRecordingUuid_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AbuseReportRecording_GetRecordingUuid")]
		private static extern IntPtr ovr_AbuseReportRecording_GetRecordingUuid_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AchievementDefinition_GetBitfieldLength(IntPtr obj);

		public static string ovr_AchievementDefinition_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinition_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinition_GetName")]
		private static extern IntPtr ovr_AchievementDefinition_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementDefinition_GetTarget(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern AchievementType ovr_AchievementDefinition_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementDefinitionArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementDefinitionArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinitionArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinitionArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementDefinitionArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementDefinitionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementDefinitionArray_HasNextPage(IntPtr obj);

		public static string ovr_AchievementProgress_GetBitfield(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetBitfield_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetBitfield")]
		private static extern IntPtr ovr_AchievementProgress_GetBitfield_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementProgress_GetCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgress_GetIsUnlocked(IntPtr obj);

		public static string ovr_AchievementProgress_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetName")]
		private static extern IntPtr ovr_AchievementProgress_GetName_Native(IntPtr obj);

		public static DateTime ovr_AchievementProgress_GetUnlockTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_AchievementProgress_GetUnlockTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetUnlockTime")]
		private static extern ulong ovr_AchievementProgress_GetUnlockTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementProgressArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementProgressArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgressArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgressArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementProgressArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementProgressArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgressArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementUpdate_GetJustUnlocked(IntPtr obj);

		public static string ovr_AchievementUpdate_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementUpdate_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementUpdate_GetName")]
		private static extern IntPtr ovr_AchievementUpdate_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetCurrentCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetCurrentName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetCurrentName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetCurrentName")]
		private static extern IntPtr ovr_ApplicationVersion_GetCurrentName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetLatestCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetLatestName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetLatestName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetLatestName")]
		private static extern IntPtr ovr_ApplicationVersion_GetLatestName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetDetails_GetAssetId(IntPtr obj);

		public static string ovr_AssetDetails_GetAssetType(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetAssetType_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetAssetType")]
		private static extern IntPtr ovr_AssetDetails_GetAssetType_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetDownloadStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetDownloadStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetDownloadStatus")]
		private static extern IntPtr ovr_AssetDetails_GetDownloadStatus_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetFilepath")]
		private static extern IntPtr ovr_AssetDetails_GetFilepath_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetIapStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetIapStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetIapStatus")]
		private static extern IntPtr ovr_AssetDetails_GetIapStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetails_GetLanguage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetailsArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AssetDetailsArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDeleteResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDeleteResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDeleteResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDeleteResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDeleteResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadCancelResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadCancelResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadCancelResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadCancelResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadCancelResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AssetFileDownloadUpdate_GetBytesTotal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_AssetFileDownloadUpdate_GetBytesTransferred(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadUpdate_GetCompleted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_CalApplicationFinalized_GetCountdownMS(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationFinalized_GetID(IntPtr obj);

		public static string ovr_CalApplicationFinalized_GetLaunchDetails(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationFinalized_GetLaunchDetails_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationFinalized_GetLaunchDetails")]
		private static extern IntPtr ovr_CalApplicationFinalized_GetLaunchDetails_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationProposed_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationSuggestion_GetID(IntPtr obj);

		public static string ovr_CalApplicationSuggestion_GetSocialContext(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationSuggestion_GetSocialContext_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationSuggestion_GetSocialContext")]
		private static extern IntPtr ovr_CalApplicationSuggestion_GetSocialContext_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CalApplicationSuggestionArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CalApplicationSuggestionArray_GetSize(IntPtr obj);

		public static string ovr_CloudStorage2UserDirectoryPathResponse_GetPath(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage2UserDirectoryPathResponse_GetPath")]
		private static extern IntPtr ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetLocal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetRemote(IntPtr obj);

		public static string ovr_CloudStorageData_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetBucket")]
		private static extern IntPtr ovr_CloudStorageData_GetBucket_Native(IntPtr obj);

		public static byte[] ovr_CloudStorageData_GetData(IntPtr obj)
		{
			return FiledataFromNative(ovr_CloudStorageData_GetDataSize(obj), ovr_CloudStorageData_GetData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetData")]
		private static extern IntPtr ovr_CloudStorageData_GetData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageData_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageData_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetKey")]
		private static extern IntPtr ovr_CloudStorageData_GetKey_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetBucket")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetBucket_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_CloudStorageMetadata_GetCounter(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageMetadata_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetExtraData(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetExtraData")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetExtraData_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetKey")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorageMetadata_GetSaveTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageDataStatus ovr_CloudStorageMetadata_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetVersionHandle_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageMetadataArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_CloudStorageMetadataArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadataArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadataArray_GetNextUrl")]
		private static extern IntPtr ovr_CloudStorageMetadataArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CloudStorageMetadataArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_CloudStorageMetadataArray_HasNextPage(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetBucket")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetBucket_Native(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetKey")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageUpdateStatus ovr_CloudStorageUpdateResponse_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(IntPtr obj);

		public static uint ovr_DataStore_Contains(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			uint result = ovr_DataStore_Contains_Native(obj, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_Contains")]
		private static extern uint ovr_DataStore_Contains_Native(IntPtr obj, IntPtr key);

		public static string ovr_DataStore_GetKey(IntPtr obj, int index)
		{
			return StringFromNative(ovr_DataStore_GetKey_Native(obj, index));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetKey")]
		private static extern IntPtr ovr_DataStore_GetKey_Native(IntPtr obj, int index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DataStore_GetNumKeys(IntPtr obj);

		public static string ovr_DataStore_GetValue(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			string result = StringFromNative(ovr_DataStore_GetValue_Native(obj, intPtr));
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetValue")]
		private static extern IntPtr ovr_DataStore_GetValue_Native(IntPtr obj, IntPtr key);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetCode(IntPtr obj);

		public static string ovr_Error_GetDisplayableMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetDisplayableMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetDisplayableMessage")]
		private static extern IntPtr ovr_Error_GetDisplayableMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetHttpCode(IntPtr obj);

		public static string ovr_Error_GetMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetMessage")]
		private static extern IntPtr ovr_Error_GetMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_HttpTransferUpdate_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HttpTransferUpdate_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_HttpTransferUpdate_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HttpTransferUpdate_IsCompleted(IntPtr obj);

		public static string ovr_InstalledApplication_GetApplicationId(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetApplicationId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetApplicationId")]
		private static extern IntPtr ovr_InstalledApplication_GetApplicationId_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetPackageName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetPackageName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetPackageName")]
		private static extern IntPtr ovr_InstalledApplication_GetPackageName_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetStatus(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetStatus")]
		private static extern IntPtr ovr_InstalledApplication_GetStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_InstalledApplication_GetVersionCode(IntPtr obj);

		public static string ovr_InstalledApplication_GetVersionName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetVersionName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetVersionName")]
		private static extern IntPtr ovr_InstalledApplication_GetVersionName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_InstalledApplicationArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_InstalledApplicationArray_GetSize(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetEnglishName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetEnglishName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetEnglishName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetEnglishName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetNativeName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetNativeName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetNativeName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetNativeName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetTag(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetTag_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetTag")]
		private static extern IntPtr ovr_LanguagePackInfo_GetTag_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidBlock(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidCancel(IntPtr obj);

		public static string ovr_LaunchDetails_GetDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetDeeplinkMessage")]
		private static extern IntPtr ovr_LaunchDetails_GetDeeplinkMessage_Native(IntPtr obj);

		public static string ovr_LaunchDetails_GetLaunchSource(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetLaunchSource_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetLaunchSource")]
		private static extern IntPtr ovr_LaunchDetails_GetLaunchSource_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LaunchType ovr_LaunchDetails_GetLaunchType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchDetails_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LaunchDetails_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchReportFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchReportFlowResult_GetUserReportId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidUnblock(IntPtr obj);

		public static byte[] ovr_LeaderboardEntry_GetExtraData(IntPtr obj)
		{
			return BlobFromNative(ovr_LeaderboardEntry_GetExtraDataLength(obj), ovr_LeaderboardEntry_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetExtraData")]
		private static extern IntPtr ovr_LeaderboardEntry_GetExtraData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_LeaderboardEntry_GetExtraDataLength(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LeaderboardEntry_GetRank(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_LeaderboardEntry_GetScore(IntPtr obj);

		public static DateTime ovr_LeaderboardEntry_GetTimestamp(IntPtr obj)
		{
			return DateTimeFromNative(ovr_LeaderboardEntry_GetTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetTimestamp")]
		private static extern ulong ovr_LeaderboardEntry_GetTimestamp_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntry_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntryArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_LeaderboardEntryArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetNextUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetNextUrl_Native(IntPtr obj);

		public static string ovr_LeaderboardEntryArray_GetPreviousUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetPreviousUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetPreviousUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetPreviousUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LeaderboardEntryArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LeaderboardEntryArray_GetTotalCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasPreviousPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardUpdateStatus_GetDidUpdate(IntPtr obj);

		public static string ovr_LinkedAccount_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetAccessToken")]
		private static extern IntPtr ovr_LinkedAccount_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ServiceProvider ovr_LinkedAccount_GetServiceProvider(IntPtr obj);

		public static string ovr_LinkedAccount_GetUserId(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetUserId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetUserId")]
		private static extern IntPtr ovr_LinkedAccount_GetUserId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LinkedAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LinkedAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingApplicationStatus_GetStreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LivestreamingStartStatus ovr_LivestreamingStartResult_GetStreamingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetCommentsVisible(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetIsPaused(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetLivestreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingStatus_GetLivestreamingType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetMicEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetCommentCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetReactionCount(IntPtr obj);

		public static string ovr_LivestreamingVideoStats_GetTotalViews(IntPtr obj)
		{
			return StringFromNative(ovr_LivestreamingVideoStats_GetTotalViews_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LivestreamingVideoStats_GetTotalViews")]
		private static extern IntPtr ovr_LivestreamingVideoStats_GetTotalViews_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshot_GetCandidates(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(IntPtr obj);

		public static string ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingAdminSnapshotCandidate_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetRooms(IntPtr obj);

		public static string ovr_MatchmakingCandidate_GetEntryHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidate_GetEntryHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidate_GetEntryHash")]
		private static extern IntPtr ovr_MatchmakingCandidate_GetEntryHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingCandidate_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_MatchmakingCandidateArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidateArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidateArray_GetNextUrl")]
		private static extern IntPtr ovr_MatchmakingCandidateArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingCandidateArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResult_GetAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetAverageWait(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetPool(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetPool_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetPool")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetPool_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetRequestHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetRequestHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetRequestHash")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetRequestHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingEnqueuedUser_GetAdditionalUserID(IntPtr obj, uint index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueuedUser_GetAdditionalUserIDsSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetCustomData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUserArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingEnqueuedUserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingNotification_GetAddedByUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingNotification_GetRoom(IntPtr obj);

		public static string ovr_MatchmakingNotification_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingNotification_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingNotification_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingNotification_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingRoom_GetPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingRoom_HasPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoomArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetDrawCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetLossCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetSkillLevel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetWinCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAbuseReportRecording(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementDefinitionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementProgressArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetApplicationVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetails(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetailsArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDeleteResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadCancelResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationFinalized(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationProposed(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationSuggestionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageConflictMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadataArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageUpdateResponse(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetHttpTransferUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetInstalledApplicationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchBlockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchFriendRequestFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchReportFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchUnblockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardEntryArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardUpdateStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLinkedAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingApplicationStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStartResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingVideoStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingBrowseResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResultAndRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNativeMessage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetworkingPeer(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetOrgScopedID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetParty(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPartyID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPidArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPlatformInitialize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetProductArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchase(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchaseArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Message_GetRequestID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotification(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotificationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSdkAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetShareMediaResult(IntPtr obj);

		public static string ovr_Message_GetString(IntPtr obj)
		{
			return StringFromNative(ovr_Message_GetString_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetString")]
		private static extern IntPtr ovr_Message_GetString_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemVoipState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern Message.MessageType ovr_Message_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserAndRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserProof(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserReportID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Message_IsError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetNumSamplesAvailable(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetOutputBufferMaxSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCM(IntPtr obj, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCMFloat(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_ReadData(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_SetAcceptableRecordingDelayHint(IntPtr obj, UIntPtr delayMs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Start(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Stop(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetworkingPeer_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PeerConnectionState ovr_NetworkingPeer_GetState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_OrgScopedID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Packet_Free(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Packet_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SendPolicy ovr_Packet_GetSendPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Packet_GetSenderID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Packet_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetLeader(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyID_GetID(IntPtr obj);

		public static string ovr_Pid_GetId(IntPtr obj)
		{
			return StringFromNative(ovr_Pid_GetId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Pid_GetId")]
		private static extern IntPtr ovr_Pid_GetId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PidArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PidArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetPingTimeUsec(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PingResult_IsTimeout(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PlatformInitializeResult ovr_PlatformInitialize_GetResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Price_GetAmountInHundredths(IntPtr obj);

		public static string ovr_Price_GetCurrency(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetCurrency_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetCurrency")]
		private static extern IntPtr ovr_Price_GetCurrency_Native(IntPtr obj);

		public static string ovr_Price_GetFormatted(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetFormatted_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetFormatted")]
		private static extern IntPtr ovr_Price_GetFormatted_Native(IntPtr obj);

		public static string ovr_Product_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetDescription")]
		private static extern IntPtr ovr_Product_GetDescription_Native(IntPtr obj);

		public static string ovr_Product_GetFormattedPrice(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetFormattedPrice_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetFormattedPrice")]
		private static extern IntPtr ovr_Product_GetFormattedPrice_Native(IntPtr obj);

		public static string ovr_Product_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetName")]
		private static extern IntPtr ovr_Product_GetName_Native(IntPtr obj);

		public static string ovr_Product_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetSKU")]
		private static extern IntPtr ovr_Product_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ProductArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_ProductArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_ProductArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ProductArray_GetNextUrl")]
		private static extern IntPtr ovr_ProductArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_ProductArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_ProductArray_HasNextPage(IntPtr obj);

		public static DateTime ovr_Purchase_GetExpirationTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetExpirationTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetExpirationTime")]
		private static extern ulong ovr_Purchase_GetExpirationTime_Native(IntPtr obj);

		public static DateTime ovr_Purchase_GetGrantTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetGrantTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetGrantTime")]
		private static extern ulong ovr_Purchase_GetGrantTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Purchase_GetPurchaseID(IntPtr obj);

		public static string ovr_Purchase_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Purchase_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetSKU")]
		private static extern IntPtr ovr_Purchase_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PurchaseArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_PurchaseArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_PurchaseArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PurchaseArray_GetNextUrl")]
		private static extern IntPtr ovr_PurchaseArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PurchaseArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PurchaseArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetApplicationID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetDataStore(IntPtr obj);

		public static string ovr_Room_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetDescription")]
		private static extern IntPtr ovr_Room_GetDescription_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Room_GetIsMembershipLocked(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinPolicy ovr_Room_GetJoinPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinability ovr_Room_GetJoinability(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetMatchedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetMaxUsers(IntPtr obj);

		public static string ovr_Room_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetName")]
		private static extern IntPtr ovr_Room_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetOwner(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomType ovr_Room_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetSenderID(IntPtr obj);

		public static DateTime ovr_RoomInviteNotification_GetSentTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_RoomInviteNotification_GetSentTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotification_GetSentTime")]
		private static extern ulong ovr_RoomInviteNotification_GetSentTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomInviteNotificationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomInviteNotificationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomInviteNotificationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotificationArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomInviteNotificationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomInviteNotificationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomInviteNotificationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SdkAccountType ovr_SdkAccount_GetAccountType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SdkAccount_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_SdkAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_SdkAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ShareMediaStatus ovr_ShareMediaResult_GetStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SystemPermission_GetHasPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PermissionGrantStatus ovr_SystemPermission_GetPermissionGrantStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_SystemVoipState_GetMicrophoneMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_SystemVoipState_GetStatus(IntPtr obj);

		public static string ovr_TestUser_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetAccessToken")]
		private static extern IntPtr ovr_TestUser_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetAppAccessArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFbAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetFriendAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetFriendAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetFriendAccessToken")]
		private static extern IntPtr ovr_TestUser_GetFriendAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFriendAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetUserAlias")]
		private static extern IntPtr ovr_TestUser_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserFbid(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserId(IntPtr obj);

		public static string ovr_TestUserAppAccess_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUserAppAccess_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUserAppAccess_GetAccessToken")]
		private static extern IntPtr ovr_TestUserAppAccess_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetAppId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUserAppAccessArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_TestUserAppAccessArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetID(IntPtr obj);

		public static string ovr_User_GetImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetImageUrl")]
		private static extern IntPtr ovr_User_GetImageUrl_Native(IntPtr obj);

		public static string ovr_User_GetInviteToken(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetInviteToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetInviteToken")]
		private static extern IntPtr ovr_User_GetInviteToken_Native(IntPtr obj);

		public static string ovr_User_GetOculusID(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetOculusID_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetOculusID")]
		private static extern IntPtr ovr_User_GetOculusID_Native(IntPtr obj);

		public static string ovr_User_GetPresence(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresence_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresence")]
		private static extern IntPtr ovr_User_GetPresence_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UserPresenceStatus ovr_User_GetPresenceStatus(IntPtr obj);

		public static string ovr_User_GetSmallImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetSmallImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetSmallImageUrl")]
		private static extern IntPtr ovr_User_GetSmallImageUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserAndRoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserAndRoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserAndRoomArray_GetNextUrl")]
		private static extern IntPtr ovr_UserAndRoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserAndRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserAndRoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserArray_GetNextUrl")]
		private static extern IntPtr ovr_UserArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserArray_HasNextPage(IntPtr obj);

		public static string ovr_UserProof_GetNonce(IntPtr obj)
		{
			return StringFromNative(ovr_UserProof_GetNonce_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserProof_GetNonce")]
		private static extern IntPtr ovr_UserProof_GetNonce_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserReportID_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UserReportID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, UIntPtr compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipDecoder_GetDecodedPCM(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipEncoder_AddPCM(IntPtr obj, float[] inputData, uint inputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedData(IntPtr obj, byte[] outputBuffer, UIntPtr intputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedDataSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AbuseReportOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetPreventPeopleChooser(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetReportType(IntPtr handle, AbuseReportType value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_ApplicationOptions_Destroy(IntPtr handle);

		public static void ovr_ApplicationOptions_SetDeeplinkMessage(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_ApplicationOptions_SetDeeplinkMessage_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationOptions_SetDeeplinkMessage")]
		private static extern void ovr_ApplicationOptions_SetDeeplinkMessage_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_Destroy(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetCreateRoomDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetCreateRoomDataStoreString")]
		private static extern void ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearCreateRoomDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(IntPtr handle, RoomJoinPolicy value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_AddEnqueueAdditionalUser(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(IntPtr handle, string key, int value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsInt")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(IntPtr handle, IntPtr key, int value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(IntPtr handle, string key, double value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(IntPtr handle, IntPtr key, double value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsString")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueDataSettings(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetEnqueueIsDebug(IntPtr handle, bool value);

		public static void ovr_MatchmakingOptions_SetEnqueueQueryKey(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueQueryKey")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_Destroy(IntPtr handle);

		public static void ovr_RoomOptions_SetDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_RoomOptions_SetDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomOptions_SetDataStoreString")]
		private static extern void ovr_RoomOptions_SetDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_ClearDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetExcludeRecentlyMet(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetMaxUserResults(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetOrdering(IntPtr handle, UserOrdering value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRecentlyMetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRoomId(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetTurnOffUpdates(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_AddServiceProvider(IntPtr handle, ServiceProvider value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_ClearServiceProviders(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_VoipOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetBitrateForNewConnections(IntPtr handle, VoipBitrate value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetCreateNewConnectionUseDtx(IntPtr handle, VoipDtxState value);
	}
	public enum CloudStorageDataStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("IN_SYNC")]
		InSync,
		[Description("NEEDS_DOWNLOAD")]
		NeedsDownload,
		[Description("REMOTE_DOWNLOADING")]
		RemoteDownloading,
		[Description("NEEDS_UPLOAD")]
		NeedsUpload,
		[Description("LOCAL_UPLOADING")]
		LocalUploading,
		[Description("IN_CONFLICT")]
		InConflict
	}
	public enum CloudStorageUpdateStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OK")]
		Ok,
		[Description("BETTER_VERSION_STORED")]
		BetterVersionStored,
		[Description("MANUAL_MERGE_REQUIRED")]
		ManualMergeRequired
	}
	public interface IMicrophone
	{
		void Start();

		void Stop();

		float[] Update();
	}
	public interface IVoipPCMSource
	{
		int GetPCM(float[] dest, int length);

		void SetSenderID(ulong senderID);

		void Update();

		int PeekSizeElements();
	}
	public enum KeyValuePairType
	{
		[Description("STRING")]
		String,
		[Description("INTEGER")]
		Int,
		[Description("DOUBLE")]
		Double,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LaunchType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NORMAL")]
		Normal,
		[Description("INVITE")]
		Invite,
		[Description("COORDINATED")]
		Coordinated,
		[Description("DEEPLINK")]
		Deeplink
	}
	public enum LeaderboardFilterType
	{
		[Description("NONE")]
		None,
		[Description("FRIENDS")]
		Friends,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LeaderboardStartAt
	{
		[Description("TOP")]
		Top,
		[Description("CENTERED_ON_VIEWER")]
		CenteredOnViewer,
		[Description("CENTERED_ON_VIEWER_OR_TOP")]
		CenteredOnViewerOrTop,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LivestreamingAudience
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PUBLIC")]
		Public,
		[Description("FRIENDS")]
		Friends,
		[Description("ONLY_ME")]
		OnlyMe
	}
	public enum LivestreamingMicrophoneStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE_ON")]
		MicrophoneOn,
		[Description("MICROPHONE_OFF")]
		MicrophoneOff
	}
	public enum LivestreamingStartStatus
	{
		[Description("SUCCESS")]
		Success = 1,
		[Description("UNKNOWN")]
		Unknown = 0,
		[Description("NO_PACKAGE_SET")]
		NoPackageSet = -1,
		[Description("NO_FB_CONNECT")]
		NoFbConnect = -2,
		[Description("NO_SESSION_ID")]
		NoSessionId = -3,
		[Description("MISSING_PARAMETERS")]
		MissingParameters = -4
	}
	public enum MatchmakingCriterionImportance
	{
		[Description("REQUIRED")]
		Required,
		[Description("HIGH")]
		High,
		[Description("MEDIUM")]
		Medium,
		[Description("LOW")]
		Low,
		[Description("UNKNOWN")]
		Unknown
	}
	public class MatchmakingOptions
	{
		private IntPtr Handle;

		public MatchmakingOptions()
		{
			Handle = CAPI.ovr_MatchmakingOptions_Create();
		}

		public void SetCreateRoomDataStore(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomDataStoreString(Handle, key, value);
		}

		public void ClearCreateRoomDataStore()
		{
			CAPI.ovr_MatchmakingOptions_ClearCreateRoomDataStore(Handle);
		}

		public void SetCreateRoomJoinPolicy(RoomJoinPolicy value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(Handle, value);
		}

		public void SetCreateRoomMaxUsers(uint value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomMaxUsers(Handle, value);
		}

		public void AddEnqueueAdditionalUser(ulong userID)
		{
			CAPI.ovr_MatchmakingOptions_AddEnqueueAdditionalUser(Handle, userID);
		}

		public void ClearEnqueueAdditionalUsers()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(Handle);
		}

		public void SetEnqueueDataSettings(string key, int value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, double value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsString(Handle, key, value);
		}

		public void ClearEnqueueDataSettings()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueDataSettings(Handle);
		}

		public void SetEnqueueIsDebug(bool value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueIsDebug(Handle, value);
		}

		public void SetEnqueueQueryKey(string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueQueryKey(Handle, value);
		}

		public static explicit operator IntPtr(MatchmakingOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~MatchmakingOptions()
		{
			CAPI.ovr_MatchmakingOptions_Destroy(Handle);
		}
	}
	public enum MatchmakingStatApproach
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("TRAILING")]
		Trailing,
		[Description("SWINGY")]
		Swingy
	}
	public enum MediaContentType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PHOTO")]
		Photo
	}
	public abstract class Message<T> : Message
	{
		public new delegate void Callback(Message<T> message);

		private T data;

		public T Data => data;

		public Message(IntPtr c_message)
			: base(c_message)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(c_message);
			}
		}

		protected abstract T GetDataFromMessage(IntPtr c_message);
	}
	public class Message
	{
		public delegate void Callback(Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			ApplicationLifecycle_GetRegisteredPIDs = 82169698u,
			ApplicationLifecycle_GetSessionKey = 984570141u,
			ApplicationLifecycle_RegisterSessionKey = 1303818232u,
			Application_GetVersion = 1751583246u,
			Application_LaunchOtherApp = 1424151032u,
			AssetFile_Delete = 1834842246u,
			AssetFile_DeleteById = 1525206354u,
			AssetFile_DeleteByName = 1108001231u,
			AssetFile_Download = 289710021u,
			AssetFile_DownloadById = 755009938u,
			AssetFile_DownloadByName = 1664536314u,
			AssetFile_DownloadCancel = 134927303u,
			AssetFile_DownloadCancelById = 1365611796u,
			AssetFile_DownloadCancelByName = 1147858170u,
			AssetFile_GetList = 1258057588u,
			AssetFile_Status = 47394656u,
			AssetFile_StatusById = 1570069816u,
			AssetFile_StatusByName = 1104140880u,
			CloudStorage_Delete = 685393261u,
			CloudStorage_GetNextCloudStorageMetadataArrayPage = 1544004335u,
			CloudStorage_Load = 1082420033u,
			CloudStorage_LoadBucketMetadata = 1931977997u,
			CloudStorage_LoadConflictMetadata = 1146770162u,
			CloudStorage_LoadHandle = 845863478u,
			CloudStorage_LoadMetadata = 65446546u,
			CloudStorage_ResolveKeepLocal = 811109637u,
			CloudStorage_ResolveKeepRemote = 1965400838u,
			CloudStorage_Save = 1270570030u,
			Entitlement_GetIsViewerEntitled = 409688241u,
			IAP_ConsumePurchase = 532378329u,
			IAP_GetNextProductArrayPage = 467225263u,
			IAP_GetNextPurchaseArrayPage = 1196886677u,
			IAP_GetProductsBySKU = 2124073717u,
			IAP_GetViewerPurchases = 974095385u,
			IAP_LaunchCheckoutFlow = 1067126029u,
			LanguagePack_GetCurrent = 529592533u,
			LanguagePack_SetCurrent = 1531952096u,
			Leaderboard_GetEntries = 1572030284u,
			Leaderboard_GetEntriesAfterRank = 406293487u,
			Leaderboard_GetNextEntries = 1310751961u,
			Leaderboard_GetPreviousEntries = 1224858304u,
			Leaderboard_WriteEntry = 293587198u,
			Livestreaming_GetStatus = 1218079125u,
			Livestreaming_PauseStream = 916223619u,
			Livestreaming_ResumeStream = 575827343u,
			Matchmaking_Browse = 509948616u,
			Matchmaking_Browse2 = 1715641947u,
			Matchmaking_Cancel = 543705519u,
			Matchmaking_Cancel2 = 285117908u,
			Matchmaking_CreateAndEnqueueRoom = 1615617480u,
			Matchmaking_CreateAndEnqueueRoom2 = 693889755u,
			Matchmaking_CreateRoom = 54203178u,
			Matchmaking_CreateRoom2 = 1231922052u,
			Matchmaking_Enqueue = 1086418033u,
			Matchmaking_Enqueue2 = 303174325u,
			Matchmaking_EnqueueRoom = 1888108644u,
			Matchmaking_EnqueueRoom2 = 1428741028u,
			Matchmaking_GetAdminSnapshot = 1008820116u,
			Matchmaking_GetStats = 1123849272u,
			Matchmaking_JoinRoom = 1295177725u,
			Matchmaking_ReportResultInsecure = 439800205u,
			Matchmaking_StartMatch = 1154746693u,
			Media_ShareToFacebook = 14912239u,
			Notification_GetNextRoomInviteNotificationArrayPage = 102890359u,
			Notification_GetRoomInvites = 1871801234u,
			Notification_MarkAsRead = 1903319523u,
			Party_GetCurrent = 1200830304u,
			Room_CreateAndJoinPrivate = 1977017207u,
			Room_CreateAndJoinPrivate2 = 1513775683u,
			Room_Get = 1704628152u,
			Room_GetCurrent = 161916164u,
			Room_GetCurrentForUser = 234887141u,
			Room_GetInvitableUsers = 506615698u,
			Room_GetInvitableUsers2 = 1330899120u,
			Room_GetModeratedRooms = 159645047u,
			Room_GetNextRoomArrayPage = 1317239238u,
			Room_InviteUser = 1093266451u,
			Room_Join = 382373641u,
			Room_Join2 = 1303059522u,
			Room_KickUser = 1233344310u,
			Room_LaunchInvitableUserFlow = 843047539u,
			Room_Leave = 1916281973u,
			Room_SetDescription = 809796911u,
			Room_UpdateDataStore = 40779816u,
			Room_UpdateMembershipLockStatus = 923514796u,
			Room_UpdateOwner = 850803997u,
			Room_UpdatePrivateRoomJoinPolicy = 289473179u,
			User_Get = 1808768583u,
			User_GetAccessToken = 111696574u,
			User_GetLoggedInUser = 1131361373u,
			User_GetLoggedInUserFriends = 1484532365u,
			User_GetLoggedInUserFriendsAndRooms = 1585908615u,
			User_GetLoggedInUserRecentlyMetUsersAndRooms = 694139440u,
			User_GetNextUserAndRoomArrayPage = 2143146719u,
			User_GetNextUserArrayPage = 645723971u,
			User_GetOrgScopedID = 418426907u,
			User_GetSdkAccounts = 1733454467u,
			User_GetUserProof = 578880643u,
			User_LaunchFriendRequestFlow = 151303576u,
			User_LaunchProfile = 171537047u,
			Voip_SetSystemVoipSuppressed = 1161808298u,
			Notification_ApplicationLifecycle_LaunchIntentChanged = 78859427u,
			Notification_AssetFile_DownloadUpdate = 803015885u,
			Notification_Cal_FinalizeApplication = 1963741337u,
			Notification_Cal_ProposeApplication = 779375093u,
			Notification_HTTP_Transfer = 2111073839u,
			Notification_Livestreaming_StatusChange = 575101294u,
			Notification_Matchmaking_MatchFound = 197393623u,
			Notification_Networking_ConnectionStateChange = 1577243802u,
			Notification_Networking_PeerConnectRequest = 1295114959u,
			Notification_Networking_PingResult = 1360343058u,
			Notification_Room_InviteAccepted = 1829794225u,
			Notification_Room_InviteReceived = 1783209300u,
			Notification_Room_RoomUpdate = 1626094639u,
			Notification_Voip_ConnectRequest = 908343318u,
			Notification_Voip_StateChange = 888120928u,
			Notification_Voip_SystemVoipState = 1490179237u,
			Platform_InitializeWithAccessToken = 896085803u,
			Platform_InitializeStandaloneOculus = 1375260172u,
			Platform_InitializeAndroidAsynchronous = 450037684u,
			Platform_InitializeWindowsAsynchronous = 1839708815u
		}

		internal delegate Message ExtraMessageTypesHandler(IntPtr messageHandle, MessageType message_type);

		private MessageType type;

		private ulong requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public ulong RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Message(IntPtr c_message)
		{
			type = CAPI.ovr_Message_GetType(c_message);
			bool flag = CAPI.ovr_Message_IsError(c_message);
			requestID = CAPI.ovr_Message_GetRequestID(c_message);
			if (flag)
			{
				IntPtr obj = CAPI.ovr_Message_GetError(c_message);
				error = new Error(CAPI.ovr_Error_GetCode(obj), CAPI.ovr_Error_GetMessage(obj), CAPI.ovr_Error_GetHttpCode(obj));
			}
			else if (Core.LogMessages)
			{
				string text = CAPI.ovr_Message_GetString(c_message);
				if (text != null)
				{
					Debug.Log(text);
				}
				else
				{
					Debug.Log($"null message string {c_message}");
				}
			}
		}

		~Message()
		{
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual PingResult GetPingResult()
		{
			return null;
		}

		public virtual NetworkingPeer GetNetworkingPeer()
		{
			return null;
		}

		public virtual HttpTransferUpdate GetHttpTransferUpdate()
		{
			return null;
		}

		public virtual PlatformInitialize GetPlatformInitialize()
		{
			return null;
		}

		public virtual AbuseReportRecording GetAbuseReportRecording()
		{
			return null;
		}

		public virtual AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual ApplicationVersion GetApplicationVersion()
		{
			return null;
		}

		public virtual AssetDetails GetAssetDetails()
		{
			return null;
		}

		public virtual AssetDetailsList GetAssetDetailsList()
		{
			return null;
		}

		public virtual AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return null;
		}

		public virtual AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return null;
		}

		public virtual AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return null;
		}

		public virtual AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return null;
		}

		public virtual CalApplicationFinalized GetCalApplicationFinalized()
		{
			return null;
		}

		public virtual CalApplicationProposed GetCalApplicationProposed()
		{
			return null;
		}

		public virtual CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return null;
		}

		public virtual CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return null;
		}

		public virtual CloudStorageData GetCloudStorageData()
		{
			return null;
		}

		public virtual CloudStorageMetadata GetCloudStorageMetadata()
		{
			return null;
		}

		public virtual CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return null;
		}

		public virtual CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return null;
		}

		public virtual InstalledApplicationList GetInstalledApplicationList()
		{
			return null;
		}

		public virtual LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return null;
		}

		public virtual LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return null;
		}

		public virtual LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return null;
		}

		public virtual LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return null;
		}

		public virtual bool GetLeaderboardDidUpdate()
		{
			return false;
		}

		public virtual LeaderboardEntryList GetLeaderboardEntryList()
		{
			return null;
		}

		public virtual LinkedAccountList GetLinkedAccountList()
		{
			return null;
		}

		public virtual LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return null;
		}

		public virtual LivestreamingStartResult GetLivestreamingStartResult()
		{
			return null;
		}

		public virtual LivestreamingStatus GetLivestreamingStatus()
		{
			return null;
		}

		public virtual LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return null;
		}

		public virtual MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return null;
		}

		public virtual MatchmakingBrowseResult GetMatchmakingBrowseResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return null;
		}

		public virtual MatchmakingStats GetMatchmakingStats()
		{
			return null;
		}

		public virtual OrgScopedID GetOrgScopedID()
		{
			return null;
		}

		public virtual Party GetParty()
		{
			return null;
		}

		public virtual PartyID GetPartyID()
		{
			return null;
		}

		public virtual PidList GetPidList()
		{
			return null;
		}

		public virtual ProductList GetProductList()
		{
			return null;
		}

		public virtual Purchase GetPurchase()
		{
			return null;
		}

		public virtual PurchaseList GetPurchaseList()
		{
			return null;
		}

		public virtual Room GetRoom()
		{
			return null;
		}

		public virtual RoomInviteNotification GetRoomInviteNotification()
		{
			return null;
		}

		public virtual RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return null;
		}

		public virtual RoomList GetRoomList()
		{
			return null;
		}

		public virtual SdkAccountList GetSdkAccountList()
		{
			return null;
		}

		public virtual ShareMediaResult GetShareMediaResult()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		public virtual SystemPermission GetSystemPermission()
		{
			return null;
		}

		public virtual SystemVoipState GetSystemVoipState()
		{
			return null;
		}

		public virtual User GetUser()
		{
			return null;
		}

		public virtual UserAndRoomList GetUserAndRoomList()
		{
			return null;
		}

		public virtual UserList GetUserList()
		{
			return null;
		}

		public virtual UserProof GetUserProof()
		{
			return null;
		}

		public virtual UserReportID GetUserReportID()
		{
			return null;
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle)
		{
			if (messageHandle.ToInt64() == 0)
			{
				return null;
			}
			Message message = null;
			MessageType messageType = CAPI.ovr_Message_GetType(messageHandle);
			switch (messageType)
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				message = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				message = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				message = new MessageWithAchievementUpdate(messageHandle);
				break;
			case MessageType.Application_GetVersion:
				message = new MessageWithApplicationVersion(messageHandle);
				break;
			case MessageType.AssetFile_Status:
			case MessageType.LanguagePack_GetCurrent:
			case MessageType.AssetFile_StatusByName:
			case MessageType.AssetFile_StatusById:
				message = new MessageWithAssetDetails(messageHandle);
				break;
			case MessageType.AssetFile_GetList:
				message = new MessageWithAssetDetailsList(messageHandle);
				break;
			case MessageType.AssetFile_DeleteByName:
			case MessageType.AssetFile_DeleteById:
			case MessageType.AssetFile_Delete:
				message = new MessageWithAssetFileDeleteResult(messageHandle);
				break;
			case MessageType.AssetFile_DownloadCancel:
			case MessageType.AssetFile_DownloadCancelByName:
			case MessageType.AssetFile_DownloadCancelById:
				message = new MessageWithAssetFileDownloadCancelResult(messageHandle);
				break;
			case MessageType.AssetFile_Download:
			case MessageType.AssetFile_DownloadById:
			case MessageType.LanguagePack_SetCurrent:
			case MessageType.AssetFile_DownloadByName:
				message = new MessageWithAssetFileDownloadResult(messageHandle);
				break;
			case MessageType.Notification_AssetFile_DownloadUpdate:
				message = new MessageWithAssetFileDownloadUpdate(messageHandle);
				break;
			case MessageType.Notification_Cal_FinalizeApplication:
				message = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageType.Notification_Cal_ProposeApplication:
				message = new MessageWithCalApplicationProposed(messageHandle);
				break;
			case MessageType.CloudStorage_LoadConflictMetadata:
				message = new MessageWithCloudStorageConflictMetadata(messageHandle);
				break;
			case MessageType.CloudStorage_LoadHandle:
			case MessageType.CloudStorage_Load:
				message = new MessageWithCloudStorageData(messageHandle);
				break;
			case MessageType.CloudStorage_LoadMetadata:
				message = new MessageWithCloudStorageMetadataUnderLocal(messageHandle);
				break;
			case MessageType.CloudStorage_GetNextCloudStorageMetadataArrayPage:
			case MessageType.CloudStorage_LoadBucketMetadata:
				message = new MessageWithCloudStorageMetadataList(messageHandle);
				break;
			case MessageType.CloudStorage_Delete:
			case MessageType.CloudStorage_ResolveKeepLocal:
			case MessageType.CloudStorage_Save:
			case MessageType.CloudStorage_ResolveKeepRemote:
				message = new MessageWithCloudStorageUpdateResponse(messageHandle);
				break;
			case MessageType.User_LaunchProfile:
			case MessageType.Matchmaking_Cancel2:
			case MessageType.Entitlement_GetIsViewerEntitled:
			case MessageType.Matchmaking_ReportResultInsecure:
			case MessageType.IAP_ConsumePurchase:
			case MessageType.Matchmaking_Cancel:
			case MessageType.Room_LaunchInvitableUserFlow:
			case MessageType.Room_UpdateOwner:
			case MessageType.Matchmaking_StartMatch:
			case MessageType.ApplicationLifecycle_RegisterSessionKey:
			case MessageType.Notification_MarkAsRead:
				message = new Message(messageHandle);
				break;
			case MessageType.User_LaunchFriendRequestFlow:
				message = new MessageWithLaunchFriendRequestFlowResult(messageHandle);
				break;
			case MessageType.Leaderboard_GetEntriesAfterRank:
			case MessageType.Leaderboard_GetPreviousEntries:
			case MessageType.Leaderboard_GetNextEntries:
			case MessageType.Leaderboard_GetEntries:
				message = new MessageWithLeaderboardEntryList(messageHandle);
				break;
			case MessageType.Leaderboard_WriteEntry:
				message = new MessageWithLeaderboardDidUpdate(messageHandle);
				break;
			case MessageType.Notification_Livestreaming_StatusChange:
			case MessageType.Livestreaming_ResumeStream:
			case MessageType.Livestreaming_PauseStream:
			case MessageType.Livestreaming_GetStatus:
				message = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageType.Matchmaking_GetAdminSnapshot:
				message = new MessageWithMatchmakingAdminSnapshot(messageHandle);
				break;
			case MessageType.Matchmaking_Browse:
			case MessageType.Matchmaking_Browse2:
				message = new MessageWithMatchmakingBrowseResult(messageHandle);
				break;
			case MessageType.Matchmaking_Enqueue2:
			case MessageType.Matchmaking_Enqueue:
			case MessageType.Matchmaking_EnqueueRoom2:
			case MessageType.Matchmaking_EnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResult(messageHandle);
				break;
			case MessageType.Matchmaking_CreateAndEnqueueRoom2:
			case MessageType.Matchmaking_CreateAndEnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResultAndRoom(messageHandle);
				break;
			case MessageType.Matchmaking_GetStats:
				message = new MessageWithMatchmakingStatsUnderMatchmakingStats(messageHandle);
				break;
			case MessageType.User_GetOrgScopedID:
				message = new MessageWithOrgScopedID(messageHandle);
				break;
			case MessageType.Party_GetCurrent:
				message = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageType.ApplicationLifecycle_GetRegisteredPIDs:
				message = new MessageWithPidList(messageHandle);
				break;
			case MessageType.IAP_GetNextProductArrayPage:
			case MessageType.IAP_GetProductsBySKU:
				message = new MessageWithProductList(messageHandle);
				break;
			case MessageType.IAP_LaunchCheckoutFlow:
				message = new MessageWithPurchase(messageHandle);
				break;
			case MessageType.IAP_GetViewerPurchases:
			case MessageType.IAP_GetNextPurchaseArrayPage:
				message = new MessageWithPurchaseList(messageHandle);
				break;
			case MessageType.Room_Get:
				message = new MessageWithRoom(messageHandle);
				break;
			case MessageType.Room_GetCurrent:
			case MessageType.Room_GetCurrentForUser:
				message = new MessageWithRoomUnderCurrentRoom(messageHandle);
				break;
			case MessageType.Room_UpdateDataStore:
			case MessageType.Matchmaking_CreateRoom:
			case MessageType.Room_UpdatePrivateRoomJoinPolicy:
			case MessageType.Room_Join:
			case MessageType.Room_SetDescription:
			case MessageType.Room_UpdateMembershipLockStatus:
			case MessageType.Room_InviteUser:
			case MessageType.Matchmaking_CreateRoom2:
			case MessageType.Room_KickUser:
			case MessageType.Matchmaking_JoinRoom:
			case MessageType.Room_Join2:
			case MessageType.Room_CreateAndJoinPrivate2:
			case MessageType.Notification_Room_RoomUpdate:
			case MessageType.Room_Leave:
			case MessageType.Room_CreateAndJoinPrivate:
				message = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageType.Room_GetModeratedRooms:
			case MessageType.Room_GetNextRoomArrayPage:
				message = new MessageWithRoomList(messageHandle);
				break;
			case MessageType.Notification_Room_InviteReceived:
				message = new MessageWithRoomInviteNotification(messageHandle);
				break;
			case MessageType.Notification_GetNextRoomInviteNotificationArrayPage:
			case MessageType.Notification_GetRoomInvites:
				message = new MessageWithRoomInviteNotificationList(messageHandle);
				break;
			case MessageType.User_GetSdkAccounts:
				message = new MessageWithSdkAccountList(messageHandle);
				break;
			case MessageType.Media_ShareToFacebook:
				message = new MessageWithShareMediaResult(messageHandle);
				break;
			case MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged:
			case MessageType.User_GetAccessToken:
			case MessageType.ApplicationLifecycle_GetSessionKey:
			case MessageType.Application_LaunchOtherApp:
			case MessageType.Notification_Room_InviteAccepted:
				message = new MessageWithString(messageHandle);
				break;
			case MessageType.Voip_SetSystemVoipSuppressed:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.User_GetLoggedInUser:
			case MessageType.User_Get:
				message = new MessageWithUser(messageHandle);
				break;
			case MessageType.User_GetLoggedInUserRecentlyMetUsersAndRooms:
			case MessageType.User_GetLoggedInUserFriendsAndRooms:
			case MessageType.User_GetNextUserAndRoomArrayPage:
				message = new MessageWithUserAndRoomList(messageHandle);
				break;
			case MessageType.Room_GetInvitableUsers:
			case MessageType.User_GetNextUserArrayPage:
			case MessageType.Room_GetInvitableUsers2:
			case MessageType.User_GetLoggedInUserFriends:
				message = new MessageWithUserList(messageHandle);
				break;
			case MessageType.User_GetUserProof:
				message = new MessageWithUserProof(messageHandle);
				break;
			case MessageType.Notification_Networking_PeerConnectRequest:
			case MessageType.Notification_Networking_ConnectionStateChange:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Networking_PingResult:
				message = new MessageWithPingResult(messageHandle);
				break;
			case MessageType.Notification_Matchmaking_MatchFound:
				message = new MessageWithMatchmakingNotification(messageHandle);
				break;
			case MessageType.Notification_Voip_StateChange:
			case MessageType.Notification_Voip_ConnectRequest:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Voip_SystemVoipState:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.Notification_HTTP_Transfer:
				message = new MessageWithHttpTransferUpdate(messageHandle);
				break;
			case MessageType.Platform_InitializeAndroidAsynchronous:
			case MessageType.Platform_InitializeWithAccessToken:
			case MessageType.Platform_InitializeStandaloneOculus:
			case MessageType.Platform_InitializeWindowsAsynchronous:
				message = new MessageWithPlatformInitialize(messageHandle);
				break;
			default:
				message = PlatformInternal.ParseMessageHandle(messageHandle, messageType);
				if (message == null)
				{
					Debug.LogError($"Unrecognized message type {messageType}\n");
				}
				break;
			}
			return message;
		}

		public static Message PopMessage()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_PopMessage();
			Message result = ParseMessageHandle(intPtr);
			CAPI.ovr_FreeMessage(intPtr);
			return result;
		}
	}
	public class MessageWithAbuseReportRecording : Message<AbuseReportRecording>
	{
		public MessageWithAbuseReportRecording(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AbuseReportRecording GetAbuseReportRecording()
		{
			return base.Data;
		}

		protected override AbuseReportRecording GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAbuseReportRecording(obj);
			return new AbuseReportRecording(o);
		}
	}
	public class MessageWithAchievementDefinitions : Message<AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override AchievementDefinitionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementDefinitionArray(obj);
			return new AchievementDefinitionList(a);
		}
	}
	public class MessageWithAchievementProgressList : Message<AchievementProgressList>
	{
		public MessageWithAchievementProgressList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override AchievementProgressList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementProgressArray(obj);
			return new AchievementProgressList(a);
		}
	}
	public class MessageWithAchievementUpdate : Message<AchievementUpdate>
	{
		public MessageWithAchievementUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override AchievementUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAchievementUpdate(obj);
			return new AchievementUpdate(o);
		}
	}
	public class MessageWithApplicationVersion : Message<ApplicationVersion>
	{
		public MessageWithApplicationVersion(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ApplicationVersion GetApplicationVersion()
		{
			return base.Data;
		}

		protected override ApplicationVersion GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetApplicationVersion(obj);
			return new ApplicationVersion(o);
		}
	}
	public class MessageWithAssetDetails : Message<AssetDetails>
	{
		public MessageWithAssetDetails(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetails GetAssetDetails()
		{
			return base.Data;
		}

		protected override AssetDetails GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetDetails(obj);
			return new AssetDetails(o);
		}
	}
	public class MessageWithAssetDetailsList : Message<AssetDetailsList>
	{
		public MessageWithAssetDetailsList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetailsList GetAssetDetailsList()
		{
			return base.Data;
		}

		protected override AssetDetailsList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAssetDetailsArray(obj);
			return new AssetDetailsList(a);
		}
	}
	public class MessageWithAssetFileDeleteResult : Message<AssetFileDeleteResult>
	{
		public MessageWithAssetFileDeleteResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return base.Data;
		}

		protected override AssetFileDeleteResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDeleteResult(obj);
			return new AssetFileDeleteResult(o);
		}
	}
	public class MessageWithAssetFileDownloadCancelResult : Message<AssetFileDownloadCancelResult>
	{
		public MessageWithAssetFileDownloadCancelResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadCancelResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadCancelResult(obj);
			return new AssetFileDownloadCancelResult(o);
		}
	}
	public class MessageWithAssetFileDownloadResult : Message<AssetFileDownloadResult>
	{
		public MessageWithAssetFileDownloadResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadResult(obj);
			return new AssetFileDownloadResult(o);
		}
	}
	public class MessageWithAssetFileDownloadUpdate : Message<AssetFileDownloadUpdate>
	{
		public MessageWithAssetFileDownloadUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return base.Data;
		}

		protected override AssetFileDownloadUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadUpdate(obj);
			return new AssetFileDownloadUpdate(o);
		}
	}
	public class MessageWithCalApplicationFinalized : Message<CalApplicationFinalized>
	{
		public MessageWithCalApplicationFinalized(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationFinalized GetCalApplicationFinalized()
		{
			return base.Data;
		}

		protected override CalApplicationFinalized GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCalApplicationFinalized(obj);
			return new CalApplicationFinalized(o);
		}
	}
	public class MessageWithCalApplicationProposed : Message<CalApplicationProposed>
	{
		public MessageWithCalApplicationProposed(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationProposed GetCalApplicationProposed()
		{
			return base.Data;
		}

		protected override CalApplicationProposed GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCalApplicationProposed(obj);
			return new CalApplicationProposed(o);
		}
	}
	public class MessageWithCalApplicationSuggestionList : Message<CalApplicationSuggestionList>
	{
		public MessageWithCalApplicationSuggestionList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return base.Data;
		}

		protected override CalApplicationSuggestionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCalApplicationSuggestionArray(obj);
			return new CalApplicationSuggestionList(a);
		}
	}
	public class MessageWithCloudStorageConflictMetadata : Message<CloudStorageConflictMetadata>
	{
		public MessageWithCloudStorageConflictMetadata(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageConflictMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageConflictMetadata(obj);
			return new CloudStorageConflictMetadata(o);
		}
	}
	public class MessageWithCloudStorageData : Message<CloudStorageData>
	{
		public MessageWithCloudStorageData(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageData GetCloudStorageData()
		{
			return base.Data;
		}

		protected override CloudStorageData GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageData(obj);
			return new CloudStorageData(o);
		}
	}
	public class MessageWithCloudStorageMetadataUnderLocal : Message<CloudStorageMetadata>
	{
		public MessageWithCloudStorageMetadataUnderLocal(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadata GetCloudStorageMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageMetadata(obj);
			return new CloudStorageMetadata(o);
		}
	}
	public class MessageWithCloudStorageMetadataList : Message<CloudStorageMetadataList>
	{
		public MessageWithCloudStorageMetadataList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return base.Data;
		}

		protected override CloudStorageMetadataList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCloudStorageMetadataArray(obj);
			return new CloudStorageMetadataList(a);
		}
	}
	public class MessageWithCloudStorageUpdateResponse : Message<CloudStorageUpdateResponse>
	{
		public MessageWithCloudStorageUpdateResponse(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return base.Data;
		}

		protected override CloudStorageUpdateResponse GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageUpdateResponse(obj);
			return new CloudStorageUpdateResponse(o);
		}
	}
	public class MessageWithInstalledApplicationList : Message<InstalledApplicationList>
	{
		public MessageWithInstalledApplicationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override InstalledApplicationList GetInstalledApplicationList()
		{
			return base.Data;
		}

		protected override InstalledApplicationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetInstalledApplicationArray(obj);
			return new InstalledApplicationList(a);
		}
	}
	public class MessageWithLaunchBlockFlowResult : Message<LaunchBlockFlowResult>
	{
		public MessageWithLaunchBlockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchBlockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchBlockFlowResult(obj);
			return new LaunchBlockFlowResult(o);
		}
	}
	public class MessageWithLaunchFriendRequestFlowResult : Message<LaunchFriendRequestFlowResult>
	{
		public MessageWithLaunchFriendRequestFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return base.Data;
		}

		protected override LaunchFriendRequestFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchFriendRequestFlowResult(obj);
			return new LaunchFriendRequestFlowResult(o);
		}
	}
	public class MessageWithLaunchReportFlowResult : Message<LaunchReportFlowResult>
	{
		public MessageWithLaunchReportFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return base.Data;
		}

		protected override LaunchReportFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchReportFlowResult(obj);
			return new LaunchReportFlowResult(o);
		}
	}
	public class MessageWithLaunchUnblockFlowResult : Message<LaunchUnblockFlowResult>
	{
		public MessageWithLaunchUnblockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchUnblockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchUnblockFlowResult(obj);
			return new LaunchUnblockFlowResult(o);
		}
	}
	public class MessageWithLeaderboardEntryList : Message<LeaderboardEntryList>
	{
		public MessageWithLeaderboardEntryList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LeaderboardEntryList GetLeaderboardEntryList()
		{
			return base.Data;
		}

		protected override LeaderboardEntryList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLeaderboardEntryArray(obj);
			return new LeaderboardEntryList(a);
		}
	}
	public class MessageWithLinkedAccountList : Message<LinkedAccountList>
	{
		public MessageWithLinkedAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LinkedAccountList GetLinkedAccountList()
		{
			return base.Data;
		}

		protected override LinkedAccountList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLinkedAccountArray(obj);
			return new LinkedAccountList(a);
		}
	}
	public class MessageWithLivestreamingApplicationStatus : Message<LivestreamingApplicationStatus>
	{
		public MessageWithLivestreamingApplicationStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return base.Data;
		}

		protected override LivestreamingApplicationStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingApplicationStatus(obj);
			return new LivestreamingApplicationStatus(o);
		}
	}
	public class MessageWithLivestreamingStartResult : Message<LivestreamingStartResult>
	{
		public MessageWithLivestreamingStartResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStartResult GetLivestreamingStartResult()
		{
			return base.Data;
		}

		protected override LivestreamingStartResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStartResult(obj);
			return new LivestreamingStartResult(o);
		}
	}
	public class MessageWithLivestreamingStatus : Message<LivestreamingStatus>
	{
		public MessageWithLivestreamingStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStatus GetLivestreamingStatus()
		{
			return base.Data;
		}

		protected override LivestreamingStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStatus(obj);
			return new LivestreamingStatus(o);
		}
	}
	public class MessageWithLivestreamingVideoStats : Message<LivestreamingVideoStats>
	{
		public MessageWithLivestreamingVideoStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return base.Data;
		}

		protected override LivestreamingVideoStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingVideoStats(obj);
			return new LivestreamingVideoStats(o);
		}
	}
	public class MessageWithMatchmakingAdminSnapshot : Message<MatchmakingAdminSnapshot>
	{
		public MessageWithMatchmakingAdminSnapshot(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return base.Data;
		}

		protected override MatchmakingAdminSnapshot GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingAdminSnapshot(obj);
			return new MatchmakingAdminSnapshot(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResult : Message<MatchmakingEnqueueResult>
	{
		public MessageWithMatchmakingEnqueueResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResult(obj);
			return new MatchmakingEnqueueResult(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResultAndRoom : Message<MatchmakingEnqueueResultAndRoom>
	{
		public MessageWithMatchmakingEnqueueResultAndRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResultAndRoom GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResultAndRoom(obj);
			return new MatchmakingEnqueueResultAndRoom(o);
		}
	}
	public class MessageWithMatchmakingStatsUnderMatchmakingStats : Message<MatchmakingStats>
	{
		public MessageWithMatchmakingStatsUnderMatchmakingStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingStats GetMatchmakingStats()
		{
			return base.Data;
		}

		protected override MatchmakingStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingStats(obj);
			return new MatchmakingStats(o);
		}
	}
	public class MessageWithOrgScopedID : Message<OrgScopedID>
	{
		public MessageWithOrgScopedID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override OrgScopedID GetOrgScopedID()
		{
			return base.Data;
		}

		protected override OrgScopedID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetOrgScopedID(obj);
			return new OrgScopedID(o);
		}
	}
	public class MessageWithParty : Message<Party>
	{
		public MessageWithParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPartyUnderCurrentParty : Message<Party>
	{
		public MessageWithPartyUnderCurrentParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPartyID : Message<PartyID>
	{
		public MessageWithPartyID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PartyID GetPartyID()
		{
			return base.Data;
		}

		protected override PartyID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPartyID(obj);
			return new PartyID(o);
		}
	}
	public class MessageWithPidList : Message<PidList>
	{
		public MessageWithPidList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PidList GetPidList()
		{
			return base.Data;
		}

		protected override PidList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPidArray(obj);
			return new PidList(a);
		}
	}
	public class MessageWithProductList : Message<ProductList>
	{
		public MessageWithProductList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ProductList GetProductList()
		{
			return base.Data;
		}

		protected override ProductList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetProductArray(obj);
			return new ProductList(a);
		}
	}
	public class MessageWithPurchase : Message<Purchase>
	{
		public MessageWithPurchase(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Purchase GetPurchase()
		{
			return base.Data;
		}

		protected override Purchase GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPurchase(obj);
			return new Purchase(o);
		}
	}
	public class MessageWithPurchaseList : Message<PurchaseList>
	{
		public MessageWithPurchaseList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PurchaseList GetPurchaseList()
		{
			return base.Data;
		}

		protected override PurchaseList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPurchaseArray(obj);
			return new PurchaseList(a);
		}
	}
	public class MessageWithRoom : Message<Room>
	{
		public MessageWithRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomUnderCurrentRoom : Message<Room>
	{
		public MessageWithRoomUnderCurrentRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomUnderViewerRoom : Message<Room>
	{
		public MessageWithRoomUnderViewerRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomList : Message<RoomList>
	{
		public MessageWithRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomList GetRoomList()
		{
			return base.Data;
		}

		protected override RoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomArray(obj);
			return new RoomList(a);
		}
	}
	public class MessageWithRoomInviteNotification : Message<RoomInviteNotification>
	{
		public MessageWithRoomInviteNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotification GetRoomInviteNotification()
		{
			return base.Data;
		}

		protected override RoomInviteNotification GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoomInviteNotification(obj);
			return new RoomInviteNotification(o);
		}
	}
	public class MessageWithRoomInviteNotificationList : Message<RoomInviteNotificationList>
	{
		public MessageWithRoomInviteNotificationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return base.Data;
		}

		protected override RoomInviteNotificationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomInviteNotificationArray(obj);
			return new RoomInviteNotificationList(a);
		}
	}
	public class MessageWithSdkAccountList : Message<SdkAccountList>
	{
		public MessageWithSdkAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SdkAccountList GetSdkAccountList()
		{
			return base.Data;
		}

		protected override SdkAccountList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetSdkAccountArray(obj);
			return new SdkAccountList(a);
		}
	}
	public class MessageWithShareMediaResult : Message<ShareMediaResult>
	{
		public MessageWithShareMediaResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ShareMediaResult GetShareMediaResult()
		{
			return base.Data;
		}

		protected override ShareMediaResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetShareMediaResult(obj);
			return new ShareMediaResult(o);
		}
	}
	public class MessageWithString : Message<string>
	{
		public MessageWithString(IntPtr c_message)
			: base(c_message)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_Message_GetString(c_message);
		}
	}
	public class MessageWithSystemPermission : Message<SystemPermission>
	{
		public MessageWithSystemPermission(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemPermission GetSystemPermission()
		{
			return base.Data;
		}

		protected override SystemPermission GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemPermission(obj);
			return new SystemPermission(o);
		}
	}
	public class MessageWithSystemVoipState : Message<SystemVoipState>
	{
		public MessageWithSystemVoipState(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemVoipState GetSystemVoipState()
		{
			return base.Data;
		}

		protected override SystemVoipState GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemVoipState(obj);
			return new SystemVoipState(o);
		}
	}
	public class MessageWithUser : Message<User>
	{
		public MessageWithUser(IntPtr c_message)
			: base(c_message)
		{
		}

		public override User GetUser()
		{
			return base.Data;
		}

		protected override User GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUser(obj);
			return new User(o);
		}
	}
	public class MessageWithUserAndRoomList : Message<UserAndRoomList>
	{
		public MessageWithUserAndRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserAndRoomList GetUserAndRoomList()
		{
			return base.Data;
		}

		protected override UserAndRoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserAndRoomArray(obj);
			return new UserAndRoomList(a);
		}
	}
	public class MessageWithUserList : Message<UserList>
	{
		public MessageWithUserList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserList GetUserList()
		{
			return base.Data;
		}

		protected override UserList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserArray(obj);
			return new UserList(a);
		}
	}
	public class MessageWithUserProof : Message<UserProof>
	{
		public MessageWithUserProof(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserProof GetUserProof()
		{
			return base.Data;
		}

		protected override UserProof GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserProof(obj);
			return new UserProof(o);
		}
	}
	public class MessageWithUserReportID : Message<UserReportID>
	{
		public MessageWithUserReportID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserReportID GetUserReportID()
		{
			return base.Data;
		}

		protected override UserReportID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserReportID(obj);
			return new UserReportID(o);
		}
	}
	public class MessageWithNetworkingPeer : Message<NetworkingPeer>
	{
		public MessageWithNetworkingPeer(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetworkingPeer GetNetworkingPeer()
		{
			return base.Data;
		}

		protected override NetworkingPeer GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNetworkingPeer(c_message);
			return new NetworkingPeer(CAPI.ovr_NetworkingPeer_GetID(obj), CAPI.ovr_NetworkingPeer_GetState(obj));
		}
	}
	public class MessageWithPingResult : Message<PingResult>
	{
		public MessageWithPingResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PingResult GetPingResult()
		{
			return base.Data;
		}

		protected override PingResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetPingResult(c_message);
			bool flag = CAPI.ovr_PingResult_IsTimeout(obj);
			return new PingResult(CAPI.ovr_PingResult_GetID(obj), (!flag) ? new ulong?(CAPI.ovr_PingResult_GetPingTimeUsec(obj)) : null);
		}
	}
	public class MessageWithLeaderboardDidUpdate : Message<bool>
	{
		public MessageWithLeaderboardDidUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override bool GetLeaderboardDidUpdate()
		{
			return base.Data;
		}

		protected override bool GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr obj2 = CAPI.ovr_Message_GetLeaderboardUpdateStatus(obj);
			return CAPI.ovr_LeaderboardUpdateStatus_GetDidUpdate(obj2);
		}
	}
	public class MessageWithMatchmakingNotification : Message<Room>
	{
		public MessageWithMatchmakingNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithMatchmakingBrowseResult : Message<MatchmakingBrowseResult>
	{
		public MessageWithMatchmakingBrowseResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data.EnqueueResult;
		}

		public override RoomList GetRoomList()
		{
			return base.Data.Rooms;
		}

		protected override MatchmakingBrowseResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingBrowseResult(obj);
			return new MatchmakingBrowseResult(o);
		}
	}
	public class MessageWithHttpTransferUpdate : Message<HttpTransferUpdate>
	{
		public MessageWithHttpTransferUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override HttpTransferUpdate GetHttpTransferUpdate()
		{
			return base.Data;
		}

		protected override HttpTransferUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetHttpTransferUpdate(obj);
			return new HttpTransferUpdate(o);
		}
	}
	public class MessageWithPlatformInitialize : Message<PlatformInitialize>
	{
		public MessageWithPlatformInitialize(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PlatformInitialize GetPlatformInitialize()
		{
			return base.Data;
		}

		protected override PlatformInitialize GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPlatformInitialize(obj);
			return new PlatformInitialize(o);
		}
	}
}
namespace Oculus.Platform.Models
{
	public class AbuseReportRecording
	{
		public readonly string RecordingUuid;

		public AbuseReportRecording(IntPtr o)
		{
			RecordingUuid = CAPI.ovr_AbuseReportRecording_GetRecordingUuid(o);
		}
	}
	public class AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly uint BitfieldLength;

		public readonly ulong Target;

		public AchievementDefinition(IntPtr o)
		{
			Type = CAPI.ovr_AchievementDefinition_GetType(o);
			Name = CAPI.ovr_AchievementDefinition_GetName(o);
			BitfieldLength = CAPI.ovr_AchievementDefinition_GetBitfieldLength(o);
			Target = CAPI.ovr_AchievementDefinition_GetTarget(o);
		}
	}
	public class AchievementDefinitionList : DeserializableList<AchievementDefinition>
	{
		public AchievementDefinitionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementDefinitionArray_GetSize(a);
			_Data = new List<AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementDefinition(CAPI.ovr_AchievementDefinitionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementDefinitionArray_GetNextUrl(a);
		}
	}
	public class AchievementProgress
	{
		public readonly string Bitfield;

		public readonly ulong Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public AchievementProgress(IntPtr o)
		{
			Bitfield = CAPI.ovr_AchievementProgress_GetBitfield(o);
			Count = CAPI.ovr_AchievementProgress_GetCount(o);
			IsUnlocked = CAPI.ovr_AchievementProgress_GetIsUnlocked(o);
			Name = CAPI.ovr_AchievementProgress_GetName(o);
			UnlockTime = CAPI.ovr_AchievementProgress_GetUnlockTime(o);
		}
	}
	public class AchievementProgressList : DeserializableList<AchievementProgress>
	{
		public AchievementProgressList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementProgressArray_GetSize(a);
			_Data = new List<AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementProgress(CAPI.ovr_AchievementProgressArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementProgressArray_GetNextUrl(a);
		}
	}
	public class AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public AchievementUpdate(IntPtr o)
		{
			JustUnlocked = CAPI.ovr_AchievementUpdate_GetJustUnlocked(o);
			Name = CAPI.ovr_AchievementUpdate_GetName(o);
		}
	}
	public class ApplicationVersion
	{
		public readonly int CurrentCode;

		public readonly string CurrentName;

		public readonly int LatestCode;

		public readonly string LatestName;

		public ApplicationVersion(IntPtr o)
		{
			CurrentCode = CAPI.ovr_ApplicationVersion_GetCurrentCode(o);
			CurrentName = CAPI.ovr_ApplicationVersion_GetCurrentName(o);
			LatestCode = CAPI.ovr_ApplicationVersion_GetLatestCode(o);
			LatestName = CAPI.ovr_ApplicationVersion_GetLatestName(o);
		}
	}
	public class AssetDetails
	{
		public readonly ulong AssetId;

		public readonly string AssetType;

		public readonly string DownloadStatus;

		public readonly string Filepath;

		public readonly string IapStatus;

		public readonly LanguagePackInfo LanguageOptional;

		[Obsolete("Deprecated in favor of LanguageOptional")]
		public readonly LanguagePackInfo Language;

		public AssetDetails(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetDetails_GetAssetId(o);
			AssetType = CAPI.ovr_AssetDetails_GetAssetType(o);
			DownloadStatus = CAPI.ovr_AssetDetails_GetDownloadStatus(o);
			Filepath = CAPI.ovr_AssetDetails_GetFilepath(o);
			IapStatus = CAPI.ovr_AssetDetails_GetIapStatus(o);
			IntPtr intPtr = CAPI.ovr_AssetDetails_GetLanguage(o);
			Language = new LanguagePackInfo(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				LanguageOptional = null;
			}
			else
			{
				LanguageOptional = Language;
			}
		}
	}
	public class AssetDetailsList : DeserializableList<AssetDetails>
	{
		public AssetDetailsList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AssetDetailsArray_GetSize(a);
			_Data = new List<AssetDetails>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AssetDetails(CAPI.ovr_AssetDetailsArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class AssetFileDeleteResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDeleteResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDeleteResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDeleteResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDeleteResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDeleteResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadCancelResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDownloadCancelResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadCancelResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDownloadCancelResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadResult
	{
		public readonly ulong AssetId;

		public readonly string Filepath;

		public AssetFileDownloadResult(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetFileDownloadResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadResult_GetFilepath(o);
		}
	}
	public class AssetFileDownloadUpdate
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly uint BytesTotal;

		public readonly int BytesTransferred;

		public readonly bool Completed;

		public AssetFileDownloadUpdate(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetId(o);
			BytesTotal = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTotal(o);
			BytesTransferred = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTransferred(o);
			Completed = CAPI.ovr_AssetFileDownloadUpdate_GetCompleted(o);
		}
	}
	public class CalApplicationFinalized
	{
		public readonly int CountdownMS;

		public readonly ulong ID;

		public readonly string LaunchDetails;

		public CalApplicationFinalized(IntPtr o)
		{
			CountdownMS = CAPI.ovr_CalApplicationFinalized_GetCountdownMS(o);
			ID = CAPI.ovr_CalApplicationFinalized_GetID(o);
			LaunchDetails = CAPI.ovr_CalApplicationFinalized_GetLaunchDetails(o);
		}
	}
	public class CalApplicationProposed
	{
		public readonly ulong ID;

		public CalApplicationProposed(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationProposed_GetID(o);
		}
	}
	public class CalApplicationSuggestion
	{
		public readonly ulong ID;

		public readonly string SocialContext;

		public CalApplicationSuggestion(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationSuggestion_GetID(o);
			SocialContext = CAPI.ovr_CalApplicationSuggestion_GetSocialContext(o);
		}
	}
	public class CalApplicationSuggestionList : DeserializableList<CalApplicationSuggestion>
	{
		public CalApplicationSuggestionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CalApplicationSuggestionArray_GetSize(a);
			_Data = new List<CalApplicationSuggestion>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CalApplicationSuggestion(CAPI.ovr_CalApplicationSuggestionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class CloudStorageConflictMetadata
	{
		public readonly CloudStorageMetadata Local;

		public readonly CloudStorageMetadata Remote;

		public CloudStorageConflictMetadata(IntPtr o)
		{
			Local = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetLocal(o));
			Remote = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetRemote(o));
		}
	}
	public class CloudStorageData
	{
		public readonly string Bucket;

		public readonly byte[] Data;

		public readonly uint DataSize;

		public readonly string Key;

		public CloudStorageData(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageData_GetBucket(o);
			Data = CAPI.ovr_CloudStorageData_GetData(o);
			DataSize = CAPI.ovr_CloudStorageData_GetDataSize(o);
			Key = CAPI.ovr_CloudStorageData_GetKey(o);
		}
	}
	public class CloudStorageMetadata
	{
		public readonly string Bucket;

		public readonly long Counter;

		public readonly uint DataSize;

		public readonly string ExtraData;

		public readonly string Key;

		public readonly ulong SaveTime;

		public readonly CloudStorageDataStatus Status;

		public readonly string VersionHandle;

		public CloudStorageMetadata(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageMetadata_GetBucket(o);
			Counter = CAPI.ovr_CloudStorageMetadata_GetCounter(o);
			DataSize = CAPI.ovr_CloudStorageMetadata_GetDataSize(o);
			ExtraData = CAPI.ovr_CloudStorageMetadata_GetExtraData(o);
			Key = CAPI.ovr_CloudStorageMetadata_GetKey(o);
			SaveTime = CAPI.ovr_CloudStorageMetadata_GetSaveTime(o);
			Status = CAPI.ovr_CloudStorageMetadata_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageMetadata_GetVersionHandle(o);
		}
	}
	public class CloudStorageMetadataList : DeserializableList<CloudStorageMetadata>
	{
		public CloudStorageMetadataList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CloudStorageMetadataArray_GetSize(a);
			_Data = new List<CloudStorageMetadata>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CloudStorageMetadata(CAPI.ovr_CloudStorageMetadataArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_CloudStorageMetadataArray_GetNextUrl(a);
		}
	}
	public class CloudStorageUpdateResponse
	{
		public readonly string Bucket;

		public readonly string Key;

		public readonly CloudStorageUpdateStatus Status;

		public readonly string VersionHandle;

		public CloudStorageUpdateResponse(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageUpdateResponse_GetBucket(o);
			Key = CAPI.ovr_CloudStorageUpdateResponse_GetKey(o);
			Status = CAPI.ovr_CloudStorageUpdateResponse_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageUpdateResponse_GetVersionHandle(o);
		}
	}
	public class DeserializableList<T> : IList<T>, IEnumerable, ICollection<T>, IEnumerable<T>
	{
		protected List<T> _Data;

		protected string _NextUrl;

		protected string _PreviousUrl;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)_Data).IsReadOnly;

		public int Count => _Data.Count;

		public T this[int index]
		{
			get
			{
				return _Data[index];
			}
			set
			{
				_Data[index] = value;
			}
		}

		[Obsolete("Use IList interface on the DeserializableList object instead.", false)]
		public List<T> Data => _Data;

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => _NextUrl;

		public string PreviousUrl => _PreviousUrl;

		public int IndexOf(T obj)
		{
			return _Data.IndexOf(obj);
		}

		public void Add(T item)
		{
			_Data.Add(item);
		}

		public void Clear()
		{
			_Data.Clear();
		}

		public bool Contains(T item)
		{
			return _Data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			_Data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _Data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			_Data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return _Data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			_Data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public class HttpTransferUpdate
	{
		public readonly ulong ID;

		public readonly byte[] Payload;

		public readonly bool IsCompleted;

		public HttpTransferUpdate(IntPtr o)
		{
			ID = CAPI.ovr_HttpTransferUpdate_GetID(o);
			IsCompleted = CAPI.ovr_HttpTransferUpdate_IsCompleted(o);
			long num = (long)(ulong)CAPI.ovr_HttpTransferUpdate_GetSize(o);
			Payload = new byte[num];
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(o), Payload, 0, (int)num);
		}
	}
	public class InstalledApplication
	{
		public readonly string ApplicationId;

		public readonly string PackageName;

		public readonly string Status;

		public readonly int VersionCode;

		public readonly string VersionName;

		public InstalledApplication(IntPtr o)
		{
			ApplicationId = CAPI.ovr_InstalledApplication_GetApplicationId(o);
			PackageName = CAPI.ovr_InstalledApplication_GetPackageName(o);
			Status = CAPI.ovr_InstalledApplication_GetStatus(o);
			VersionCode = CAPI.ovr_InstalledApplication_GetVersionCode(o);
			VersionName = CAPI.ovr_InstalledApplication_GetVersionName(o);
		}
	}
	public class InstalledApplicationList : DeserializableList<InstalledApplication>
	{
		public InstalledApplicationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_InstalledApplicationArray_GetSize(a);
			_Data = new List<InstalledApplication>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new InstalledApplication(CAPI.ovr_InstalledApplicationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LanguagePackInfo
	{
		public readonly string EnglishName;

		public readonly string NativeName;

		public readonly string Tag;

		public LanguagePackInfo(IntPtr o)
		{
			EnglishName = CAPI.ovr_LanguagePackInfo_GetEnglishName(o);
			NativeName = CAPI.ovr_LanguagePackInfo_GetNativeName(o);
			Tag = CAPI.ovr_LanguagePackInfo_GetTag(o);
		}
	}
	public class LaunchBlockFlowResult
	{
		public readonly bool DidBlock;

		public readonly bool DidCancel;

		public LaunchBlockFlowResult(IntPtr o)
		{
			DidBlock = CAPI.ovr_LaunchBlockFlowResult_GetDidBlock(o);
			DidCancel = CAPI.ovr_LaunchBlockFlowResult_GetDidCancel(o);
		}
	}
	public class LaunchDetails
	{
		public readonly string DeeplinkMessage;

		public readonly string LaunchSource;

		public readonly LaunchType LaunchType;

		public readonly ulong RoomID;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public LaunchDetails(IntPtr o)
		{
			DeeplinkMessage = CAPI.ovr_LaunchDetails_GetDeeplinkMessage(o);
			LaunchSource = CAPI.ovr_LaunchDetails_GetLaunchSource(o);
			LaunchType = CAPI.ovr_LaunchDetails_GetLaunchType(o);
			RoomID = CAPI.ovr_LaunchDetails_GetRoomID(o);
			IntPtr intPtr = CAPI.ovr_LaunchDetails_GetUsers(o);
			Users = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class LaunchFriendRequestFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidSendRequest;

		public LaunchFriendRequestFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidCancel(o);
			DidSendRequest = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(o);
		}
	}
	public class LaunchReportFlowResult
	{
		public readonly bool DidCancel;

		public readonly ulong UserReportId;

		public LaunchReportFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchReportFlowResult_GetDidCancel(o);
			UserReportId = CAPI.ovr_LaunchReportFlowResult_GetUserReportId(o);
		}
	}
	public class LaunchUnblockFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidUnblock;

		public LaunchUnblockFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchUnblockFlowResult_GetDidCancel(o);
			DidUnblock = CAPI.ovr_LaunchUnblockFlowResult_GetDidUnblock(o);
		}
	}
	public class LeaderboardEntry
	{
		public readonly byte[] ExtraData;

		public readonly int Rank;

		public readonly long Score;

		public readonly DateTime Timestamp;

		public readonly User User;

		public LeaderboardEntry(IntPtr o)
		{
			ExtraData = CAPI.ovr_LeaderboardEntry_GetExtraData(o);
			Rank = CAPI.ovr_LeaderboardEntry_GetRank(o);
			Score = CAPI.ovr_LeaderboardEntry_GetScore(o);
			Timestamp = CAPI.ovr_LeaderboardEntry_GetTimestamp(o);
			User = new User(CAPI.ovr_LeaderboardEntry_GetUser(o));
		}
	}
	public class LeaderboardEntryList : DeserializableList<LeaderboardEntry>
	{
		public readonly ulong TotalCount;

		public LeaderboardEntryList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LeaderboardEntryArray_GetSize(a);
			_Data = new List<LeaderboardEntry>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LeaderboardEntry(CAPI.ovr_LeaderboardEntryArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			TotalCount = CAPI.ovr_LeaderboardEntryArray_GetTotalCount(a);
			_PreviousUrl = CAPI.ovr_LeaderboardEntryArray_GetPreviousUrl(a);
			_NextUrl = CAPI.ovr_LeaderboardEntryArray_GetNextUrl(a);
		}
	}
	public class LinkedAccount
	{
		public readonly string AccessToken;

		public readonly ServiceProvider ServiceProvider;

		public readonly string UserId;

		public LinkedAccount(IntPtr o)
		{
			AccessToken = CAPI.ovr_LinkedAccount_GetAccessToken(o);
			ServiceProvider = CAPI.ovr_LinkedAccount_GetServiceProvider(o);
			UserId = CAPI.ovr_LinkedAccount_GetUserId(o);
		}
	}
	public class LinkedAccountList : DeserializableList<LinkedAccount>
	{
		public LinkedAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LinkedAccountArray_GetSize(a);
			_Data = new List<LinkedAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LinkedAccount(CAPI.ovr_LinkedAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LivestreamingApplicationStatus
	{
		public readonly bool StreamingEnabled;

		public LivestreamingApplicationStatus(IntPtr o)
		{
			StreamingEnabled = CAPI.ovr_LivestreamingApplicationStatus_GetStreamingEnabled(o);
		}
	}
	public class LivestreamingStartResult
	{
		public readonly LivestreamingStartStatus StreamingResult;

		public LivestreamingStartResult(IntPtr o)
		{
			StreamingResult = CAPI.ovr_LivestreamingStartResult_GetStreamingResult(o);
		}
	}
	public class LivestreamingStatus
	{
		public readonly bool CommentsVisible;

		public readonly bool IsPaused;

		public readonly bool LivestreamingEnabled;

		public readonly int LivestreamingType;

		public readonly bool MicEnabled;

		public LivestreamingStatus(IntPtr o)
		{
			CommentsVisible = CAPI.ovr_LivestreamingStatus_GetCommentsVisible(o);
			IsPaused = CAPI.ovr_LivestreamingStatus_GetIsPaused(o);
			LivestreamingEnabled = CAPI.ovr_LivestreamingStatus_GetLivestreamingEnabled(o);
			LivestreamingType = CAPI.ovr_LivestreamingStatus_GetLivestreamingType(o);
			MicEnabled = CAPI.ovr_LivestreamingStatus_GetMicEnabled(o);
		}
	}
	public class LivestreamingVideoStats
	{
		public readonly int CommentCount;

		public readonly int ReactionCount;

		public readonly string TotalViews;

		public LivestreamingVideoStats(IntPtr o)
		{
			CommentCount = CAPI.ovr_LivestreamingVideoStats_GetCommentCount(o);
			ReactionCount = CAPI.ovr_LivestreamingVideoStats_GetReactionCount(o);
			TotalViews = CAPI.ovr_LivestreamingVideoStats_GetTotalViews(o);
		}
	}
	public class MatchmakingAdminSnapshot
	{
		public readonly MatchmakingAdminSnapshotCandidateList Candidates;

		public readonly double MyCurrentThreshold;

		public MatchmakingAdminSnapshot(IntPtr o)
		{
			Candidates = new MatchmakingAdminSnapshotCandidateList(CAPI.ovr_MatchmakingAdminSnapshot_GetCandidates(o));
			MyCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidate
	{
		public readonly bool CanMatch;

		public readonly double MyTotalScore;

		public readonly double TheirCurrentThreshold;

		public readonly double TheirTotalScore;

		public readonly string TraceId;

		public MatchmakingAdminSnapshotCandidate(IntPtr o)
		{
			CanMatch = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(o);
			MyTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(o);
			TheirCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(o);
			TheirTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(o);
			TraceId = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidateList : DeserializableList<MatchmakingAdminSnapshotCandidate>
	{
		public MatchmakingAdminSnapshotCandidateList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(a);
			_Data = new List<MatchmakingAdminSnapshotCandidate>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingAdminSnapshotCandidate(CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingBrowseResult
	{
		public readonly MatchmakingEnqueueResult EnqueueResult;

		public readonly RoomList Rooms;

		public MatchmakingBrowseResult(IntPtr o)
		{
			EnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingBrowseResult_GetEnqueueResult(o));
			Rooms = new RoomList(CAPI.ovr_MatchmakingBrowseResult_GetRooms(o));
		}
	}
	public class MatchmakingEnqueuedUser
	{
		public readonly Dictionary<string, string> CustomData;

		public readonly User UserOptional;

		[Obsolete("Deprecated in favor of UserOptional")]
		public readonly User User;

		public MatchmakingEnqueuedUser(IntPtr o)
		{
			CustomData = CAPI.DataStoreFromNative(CAPI.ovr_MatchmakingEnqueuedUser_GetCustomData(o));
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueuedUser_GetUser(o);
			User = new User(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UserOptional = null;
			}
			else
			{
				UserOptional = User;
			}
		}
	}
	public class MatchmakingEnqueuedUserList : DeserializableList<MatchmakingEnqueuedUser>
	{
		public MatchmakingEnqueuedUserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingEnqueuedUserArray_GetSize(a);
			_Data = new List<MatchmakingEnqueuedUser>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingEnqueuedUser(CAPI.ovr_MatchmakingEnqueuedUserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingEnqueueResult
	{
		public readonly MatchmakingAdminSnapshot AdminSnapshotOptional;

		[Obsolete("Deprecated in favor of AdminSnapshotOptional")]
		public readonly MatchmakingAdminSnapshot AdminSnapshot;

		public readonly uint AverageWait;

		public readonly uint MatchesInLastHourCount;

		public readonly uint MaxExpectedWait;

		public readonly string Pool;

		public readonly uint RecentMatchPercentage;

		public readonly string RequestHash;

		public MatchmakingEnqueueResult(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueueResult_GetAdminSnapshot(o);
			AdminSnapshot = new MatchmakingAdminSnapshot(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				AdminSnapshotOptional = null;
			}
			else
			{
				AdminSnapshotOptional = AdminSnapshot;
			}
			AverageWait = CAPI.ovr_MatchmakingEnqueueResult_GetAverageWait(o);
			MatchesInLastHourCount = CAPI.ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(o);
			MaxExpectedWait = CAPI.ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(o);
			Pool = CAPI.ovr_MatchmakingEnqueueResult_GetPool(o);
			RecentMatchPercentage = CAPI.ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(o);
			RequestHash = CAPI.ovr_MatchmakingEnqueueResult_GetRequestHash(o);
		}
	}
	public class MatchmakingEnqueueResultAndRoom
	{
		public readonly MatchmakingEnqueueResult MatchmakingEnqueueResult;

		public readonly Room Room;

		public MatchmakingEnqueueResultAndRoom(IntPtr o)
		{
			MatchmakingEnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(o));
			Room = new Room(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetRoom(o));
		}
	}
	public class MatchmakingStats
	{
		public readonly uint DrawCount;

		public readonly uint LossCount;

		public readonly uint SkillLevel;

		public readonly uint WinCount;

		public MatchmakingStats(IntPtr o)
		{
			DrawCount = CAPI.ovr_MatchmakingStats_GetDrawCount(o);
			LossCount = CAPI.ovr_MatchmakingStats_GetLossCount(o);
			SkillLevel = CAPI.ovr_MatchmakingStats_GetSkillLevel(o);
			WinCount = CAPI.ovr_MatchmakingStats_GetWinCount(o);
		}
	}
	public class NetworkingPeer
	{
		public ulong ID { get; private set; }

		public PeerConnectionState State { get; private set; }

		public NetworkingPeer(ulong id, PeerConnectionState state)
		{
			ID = id;
			State = state;
		}
	}
	public class OrgScopedID
	{
		public readonly ulong ID;

		public OrgScopedID(IntPtr o)
		{
			ID = CAPI.ovr_OrgScopedID_GetID(o);
		}
	}
	public class Party
	{
		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly User LeaderOptional;

		[Obsolete("Deprecated in favor of LeaderOptional")]
		public readonly User Leader;

		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public Party(IntPtr o)
		{
			ID = CAPI.ovr_Party_GetID(o);
			IntPtr intPtr = CAPI.ovr_Party_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IntPtr intPtr2 = CAPI.ovr_Party_GetLeader(o);
			Leader = new User(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				LeaderOptional = null;
			}
			else
			{
				LeaderOptional = Leader;
			}
			IntPtr intPtr3 = CAPI.ovr_Party_GetRoom(o);
			Room = new Room(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			IntPtr intPtr4 = CAPI.ovr_Party_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class PartyID
	{
		public readonly ulong ID;

		public PartyID(IntPtr o)
		{
			ID = CAPI.ovr_PartyID_GetID(o);
		}
	}
	public class Pid
	{
		public readonly string Id;

		public Pid(IntPtr o)
		{
			Id = CAPI.ovr_Pid_GetId(o);
		}
	}
	public class PidList : DeserializableList<Pid>
	{
		public PidList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PidArray_GetSize(a);
			_Data = new List<Pid>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Pid(CAPI.ovr_PidArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class PingResult
	{
		private ulong? pingTimeUsec;

		public ulong ID { get; private set; }

		public ulong PingTimeUsec => (!pingTimeUsec.HasValue) ? 0 : pingTimeUsec.Value;

		public bool IsTimeout => !pingTimeUsec.HasValue;

		public PingResult(ulong id, ulong? pingTimeUsec)
		{
			ID = id;
			this.pingTimeUsec = pingTimeUsec;
		}
	}
	public class PlatformInitialize
	{
		public readonly PlatformInitializeResult Result;

		public PlatformInitialize(IntPtr o)
		{
			Result = CAPI.ovr_PlatformInitialize_GetResult(o);
		}
	}
	public class Product
	{
		public readonly string Description;

		public readonly string FormattedPrice;

		public readonly string Name;

		public readonly string Sku;

		public Product(IntPtr o)
		{
			Description = CAPI.ovr_Product_GetDescription(o);
			FormattedPrice = CAPI.ovr_Product_GetFormattedPrice(o);
			Name = CAPI.ovr_Product_GetName(o);
			Sku = CAPI.ovr_Product_GetSKU(o);
		}
	}
	public class ProductList : DeserializableList<Product>
	{
		public ProductList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_ProductArray_GetSize(a);
			_Data = new List<Product>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Product(CAPI.ovr_ProductArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_ProductArray_GetNextUrl(a);
		}
	}
	public class Purchase
	{
		public readonly DateTime ExpirationTime;

		public readonly DateTime GrantTime;

		public readonly ulong ID;

		public readonly string Sku;

		public Purchase(IntPtr o)
		{
			ExpirationTime = CAPI.ovr_Purchase_GetExpirationTime(o);
			GrantTime = CAPI.ovr_Purchase_GetGrantTime(o);
			ID = CAPI.ovr_Purchase_GetPurchaseID(o);
			Sku = CAPI.ovr_Purchase_GetSKU(o);
		}
	}
	public class PurchaseList : DeserializableList<Purchase>
	{
		public PurchaseList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PurchaseArray_GetSize(a);
			_Data = new List<Purchase>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Purchase(CAPI.ovr_PurchaseArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_PurchaseArray_GetNextUrl(a);
		}
	}
	public class Room
	{
		public readonly ulong ApplicationID;

		public readonly Dictionary<string, string> DataStore;

		public readonly string Description;

		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly bool IsMembershipLocked;

		public readonly RoomJoinPolicy JoinPolicy;

		public readonly RoomJoinability Joinability;

		public readonly MatchmakingEnqueuedUserList MatchedUsersOptional;

		[Obsolete("Deprecated in favor of MatchedUsersOptional")]
		public readonly MatchmakingEnqueuedUserList MatchedUsers;

		public readonly uint MaxUsers;

		public readonly string Name;

		public readonly User OwnerOptional;

		[Obsolete("Deprecated in favor of OwnerOptional")]
		public readonly User Owner;

		public readonly RoomType Type;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public readonly uint Version;

		public Room(IntPtr o)
		{
			ApplicationID = CAPI.ovr_Room_GetApplicationID(o);
			DataStore = CAPI.DataStoreFromNative(CAPI.ovr_Room_GetDataStore(o));
			Description = CAPI.ovr_Room_GetDescription(o);
			ID = CAPI.ovr_Room_GetID(o);
			IntPtr intPtr = CAPI.ovr_Room_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IsMembershipLocked = CAPI.ovr_Room_GetIsMembershipLocked(o);
			JoinPolicy = CAPI.ovr_Room_GetJoinPolicy(o);
			Joinability = CAPI.ovr_Room_GetJoinability(o);
			IntPtr intPtr2 = CAPI.ovr_Room_GetMatchedUsers(o);
			MatchedUsers = new MatchmakingEnqueuedUserList(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				MatchedUsersOptional = null;
			}
			else
			{
				MatchedUsersOptional = MatchedUsers;
			}
			MaxUsers = CAPI.ovr_Room_GetMaxUsers(o);
			Name = CAPI.ovr_Room_GetName(o);
			IntPtr intPtr3 = CAPI.ovr_Room_GetOwner(o);
			Owner = new User(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				OwnerOptional = null;
			}
			else
			{
				OwnerOptional = Owner;
			}
			Type = CAPI.ovr_Room_GetType(o);
			IntPtr intPtr4 = CAPI.ovr_Room_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
			Version = CAPI.ovr_Room_GetVersion(o);
		}
	}
	public class RoomList : DeserializableList<Room>
	{
		public RoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomArray_GetSize(a);
			_Data = new List<Room>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Room(CAPI.ovr_RoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomArray_GetNextUrl(a);
		}
	}
	public class RoomInviteNotification
	{
		public readonly ulong ID;

		public readonly ulong RoomID;

		public readonly ulong SenderID;

		public readonly DateTime SentTime;

		public RoomInviteNotification(IntPtr o)
		{
			ID = CAPI.ovr_RoomInviteNotification_GetID(o);
			RoomID = CAPI.ovr_RoomInviteNotification_GetRoomID(o);
			SenderID = CAPI.ovr_RoomInviteNotification_GetSenderID(o);
			SentTime = CAPI.ovr_RoomInviteNotification_GetSentTime(o);
		}
	}
	public class RoomInviteNotificationList : DeserializableList<RoomInviteNotification>
	{
		public RoomInviteNotificationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomInviteNotificationArray_GetSize(a);
			_Data = new List<RoomInviteNotification>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new RoomInviteNotification(CAPI.ovr_RoomInviteNotificationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomInviteNotificationArray_GetNextUrl(a);
		}
	}
	public class SdkAccount
	{
		public readonly SdkAccountType AccountType;

		public readonly ulong UserId;

		public SdkAccount(IntPtr o)
		{
			AccountType = CAPI.ovr_SdkAccount_GetAccountType(o);
			UserId = CAPI.ovr_SdkAccount_GetUserId(o);
		}
	}
	public class SdkAccountList : DeserializableList<SdkAccount>
	{
		public SdkAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_SdkAccountArray_GetSize(a);
			_Data = new List<SdkAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new SdkAccount(CAPI.ovr_SdkAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class ShareMediaResult
	{
		public readonly ShareMediaStatus Status;

		public ShareMediaResult(IntPtr o)
		{
			Status = CAPI.ovr_ShareMediaResult_GetStatus(o);
		}
	}
	public class SystemPermission
	{
		public readonly bool HasPermission;

		public readonly PermissionGrantStatus PermissionGrantStatus;

		public SystemPermission(IntPtr o)
		{
			HasPermission = CAPI.ovr_SystemPermission_GetHasPermission(o);
			PermissionGrantStatus = CAPI.ovr_SystemPermission_GetPermissionGrantStatus(o);
		}
	}
	public class SystemVoipState
	{
		public readonly VoipMuteState MicrophoneMuted;

		public readonly SystemVoipStatus Status;

		public SystemVoipState(IntPtr o)
		{
			MicrophoneMuted = CAPI.ovr_SystemVoipState_GetMicrophoneMuted(o);
			Status = CAPI.ovr_SystemVoipState_GetStatus(o);
		}
	}
	public class User
	{
		public readonly ulong ID;

		public readonly string ImageURL;

		public readonly string InviteToken;

		public readonly string OculusID;

		public readonly string Presence;

		public readonly UserPresenceStatus PresenceStatus;

		public readonly string SmallImageUrl;

		public User(IntPtr o)
		{
			ID = CAPI.ovr_User_GetID(o);
			ImageURL = CAPI.ovr_User_GetImageUrl(o);
			InviteToken = CAPI.ovr_User_GetInviteToken(o);
			OculusID = CAPI.ovr_User_GetOculusID(o);
			Presence = CAPI.ovr_User_GetPresence(o);
			PresenceStatus = CAPI.ovr_User_GetPresenceStatus(o);
			SmallImageUrl = CAPI.ovr_User_GetSmallImageUrl(o);
		}
	}
	public class UserList : DeserializableList<User>
	{
		public UserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserArray_GetSize(a);
			_Data = new List<User>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new User(CAPI.ovr_UserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserArray_GetNextUrl(a);
		}
	}
	public class UserAndRoom
	{
		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly User User;

		public UserAndRoom(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_UserAndRoom_GetRoom(o);
			Room = new Room(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			User = new User(CAPI.ovr_UserAndRoom_GetUser(o));
		}
	}
	public class UserAndRoomList : DeserializableList<UserAndRoom>
	{
		public UserAndRoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserAndRoomArray_GetSize(a);
			_Data = new List<UserAndRoom>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new UserAndRoom(CAPI.ovr_UserAndRoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserAndRoomArray_GetNextUrl(a);
		}
	}
	public class UserProof
	{
		public readonly string Value;

		public UserProof(IntPtr o)
		{
			Value = CAPI.ovr_UserProof_GetNonce(o);
		}
	}
	public class UserReportID
	{
		public readonly bool DidCancel;

		public readonly ulong ID;

		public UserReportID(IntPtr o)
		{
			DidCancel = CAPI.ovr_UserReportID_GetDidCancel(o);
			ID = CAPI.ovr_UserReportID_GetID(o);
		}
	}
}
namespace Oculus.Platform
{
	public sealed class Packet : IDisposable
	{
		private readonly ulong size;

		private readonly IntPtr packetHandle;

		public ulong SenderID => CAPI.ovr_Packet_GetSenderID(packetHandle);

		public ulong Size => size;

		public SendPolicy Policy => CAPI.ovr_Packet_GetSendPolicy(packetHandle);

		public Packet(IntPtr packetHandle)
		{
			this.packetHandle = packetHandle;
			size = (ulong)CAPI.ovr_Packet_GetSize(packetHandle);
		}

		public ulong ReadBytes(byte[] destination)
		{
			if ((ulong)destination.LongLength < size)
			{
				throw new ArgumentException($"Destination array was not big enough to hold {size} bytes");
			}
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(packetHandle), destination, 0, (int)size);
			return size;
		}

		~Packet()
		{
			Dispose();
		}

		public void Dispose()
		{
			CAPI.ovr_Packet_Free(packetHandle);
			GC.SuppressFinalize(this);
		}
	}
	public enum PeerConnectionState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTED")]
		Connected,
		[Description("TIMEOUT")]
		Timeout,
		[Description("CLOSED")]
		Closed
	}
	public enum PermissionGrantStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("GRANTED")]
		Granted,
		[Description("DENIED")]
		Denied,
		[Description("BLOCKED")]
		Blocked
	}
	public enum PermissionType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE")]
		Microphone,
		[Description("WRITE_EXTERNAL_STORAGE")]
		WriteExternalStorage
	}
	public sealed class Core
	{
		private static bool IsPlatformInitialized;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		internal static void ForceInitialized()
		{
			IsPlatformInitialized = true;
		}

		private static string getAppID(string appId = null)
		{
			string appIDFromConfig = GetAppIDFromConfig();
			if (string.IsNullOrEmpty(appId))
			{
				if (string.IsNullOrEmpty(appIDFromConfig))
				{
					throw new UnityException("Update your app id by selecting 'Oculus Platform' -> 'Edit Settings'");
				}
				appId = appIDFromConfig;
			}
			else if (!string.IsNullOrEmpty(appIDFromConfig))
			{
				Debug.LogWarningFormat("The 'Oculus App Id ({0})' field in 'Oculus Platform/Edit Settings' is being overridden by the App Id ({1}) that you passed in to Platform.Core.Initialize.  You should only specify this in one place.  We recommend the menu location.", appIDFromConfig, appId);
			}
			return appId;
		}

		public static Request<PlatformInitialize> AsyncInitialize(string appId = null)
		{
			appId = getAppID(appId);
			Request<PlatformInitialize> request;
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				request = standalonePlatform.InitializeInEditor();
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				request = windowsPlatform.AsyncInitialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				AndroidPlatform androidPlatform = new AndroidPlatform();
				request = androidPlatform.AsyncInitialize(appId);
			}
			IsPlatformInitialized = request != null;
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
			return request;
		}

		public static void Initialize(string appId = null)
		{
			appId = getAppID(appId);
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				IsPlatformInitialized = standalonePlatform.InitializeInEditor() != null;
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				IsPlatformInitialized = windowsPlatform.Initialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				AndroidPlatform androidPlatform = new AndroidPlatform();
				IsPlatformInitialized = androidPlatform.Initialize(appId);
			}
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
		}

		private static string GetAppIDFromConfig()
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return PlatformSettings.MobileAppID;
			}
			return PlatformSettings.AppID;
		}
	}
	public static class ApplicationLifecycle
	{
		public static LaunchDetails GetLaunchDetails()
		{
			return new LaunchDetails(CAPI.ovr_ApplicationLifecycle_GetLaunchDetails());
		}
	}
	public static class Rooms
	{
		public static Request<Room> UpdateDataStore(ulong roomID, Dictionary<string, string> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, string> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request<Room>(CAPI.ovr_Room_UpdateDataStore(roomID, array));
			}
			return null;
		}

		[Obsolete("Deprecated in favor of SetRoomInviteAcceptedNotificationCallback")]
		public static void SetRoomInviteNotificationCallback(Message<string>.Callback callback)
		{
			SetRoomInviteAcceptedNotificationCallback(callback);
		}

		public static Request<Room> CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_CreateAndJoinPrivate(joinPolicy, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_CreateAndJoinPrivate2(joinPolicy, maxUsers, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Room> Get(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Get(roomID));
			}
			return null;
		}

		public static Request<Room> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrent());
			}
			return null;
		}

		public static Request<Room> GetCurrentForUser(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrentForUser(userID));
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers());
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers2(RoomOptions roomOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers2((IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<RoomList> GetModeratedRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_Room_GetModeratedRooms());
			}
			return null;
		}

		public static Request<Room> InviteUser(ulong roomID, string inviteToken)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_InviteUser(roomID, inviteToken));
			}
			return null;
		}

		public static Request<Room> Join(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Join(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> Join2(ulong roomID, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Join2(roomID, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Room> KickUser(ulong roomID, ulong userID, int kickDurationSeconds)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_KickUser(roomID, userID, kickDurationSeconds));
			}
			return null;
		}

		public static Request LaunchInvitableUserFlow(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_LaunchInvitableUserFlow(roomID));
			}
			return null;
		}

		public static Request<Room> Leave(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Leave(roomID));
			}
			return null;
		}

		public static Request<Room> SetDescription(ulong roomID, string description)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_SetDescription(roomID, description));
			}
			return null;
		}

		public static Request<Room> UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdateMembershipLockStatus(roomID, membershipLockStatus));
			}
			return null;
		}

		public static Request UpdateOwner(ulong roomID, ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_UpdateOwner(roomID, userID));
			}
			return null;
		}

		public static Request<Room> UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdatePrivateRoomJoinPolicy(roomID, newJoinPolicy));
			}
			return null;
		}

		public static void SetRoomInviteAcceptedNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteAccepted, callback);
		}

		public static void SetRoomInviteReceivedNotificationCallback(Message<RoomInviteNotification>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteReceived, callback);
		}

		public static void SetUpdateNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_RoomUpdate, callback);
		}

		public static Request<RoomList> GetNextRoomListPage(RoomList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1317239238));
			}
			return null;
		}
	}
	public static class Matchmaking
	{
		public class CustomQuery
		{
			public struct Criterion
			{
				public string key;

				public MatchmakingCriterionImportance importance;

				public Dictionary<string, object> parameters;

				public Criterion(string key_, MatchmakingCriterionImportance importance_)
				{
					key = key_;
					importance = importance_;
					parameters = null;
				}
			}

			public Dictionary<string, object> data;

			public Criterion[] criteria;

			public IntPtr ToUnmanaged()
			{
				CAPI.ovrMatchmakingCustomQueryData ovrMatchmakingCustomQueryData = default(CAPI.ovrMatchmakingCustomQueryData);
				if (criteria != null && criteria.Length > 0)
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = (uint)criteria.Length;
					CAPI.ovrMatchmakingCriterion[] array = new CAPI.ovrMatchmakingCriterion[criteria.Length];
					for (int i = 0; i < criteria.Length; i++)
					{
						array[i].importance_ = criteria[i].importance;
						array[i].key_ = criteria[i].key;
						if (criteria[i].parameters != null && criteria[i].parameters.Count > 0)
						{
							array[i].parameterArrayCount = (uint)criteria[i].parameters.Count;
							array[i].parameterArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(criteria[i].parameters));
						}
						else
						{
							array[i].parameterArrayCount = 0u;
							array[i].parameterArray = IntPtr.Zero;
						}
					}
					ovrMatchmakingCustomQueryData.criterionArray = CAPI.ArrayOfStructsToIntPtr(array);
				}
				else
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = 0u;
					ovrMatchmakingCustomQueryData.criterionArray = IntPtr.Zero;
				}
				if (data != null && data.Count > 0)
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = (uint)data.Count;
					ovrMatchmakingCustomQueryData.dataArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(data));
				}
				else
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = 0u;
					ovrMatchmakingCustomQueryData.dataArray = IntPtr.Zero;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ovrMatchmakingCustomQueryData));
				Marshal.StructureToPtr(ovrMatchmakingCustomQueryData, intPtr, fDeleteOld: true);
				return intPtr;
			}
		}

		public static Request ReportResultsInsecure(ulong roomID, Dictionary<string, int> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, int> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request(CAPI.ovr_Matchmaking_ReportResultInsecure(roomID, array));
			}
			return null;
		}

		public static Request<MatchmakingStats> GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach = MatchmakingStatApproach.Trailing)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingStats>(CAPI.ovr_Matchmaking_GetStats(pool, maxLevel, approach));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request Cancel(string pool, string requestHash)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel(pool, requestHash));
			}
			return null;
		}

		public static Request Cancel()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel2());
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates = false, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom(pool, maxUsers, subscribeToUpdates, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<Room> CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom(pool, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> CreateRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom(ulong roomID, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom(roomID, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom2(ulong roomID, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom2(roomID, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingAdminSnapshot> GetAdminSnapshot()
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingAdminSnapshot>(CAPI.ovr_Matchmaking_GetAdminSnapshot());
			}
			return null;
		}

		public static Request<Room> JoinRoom(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_JoinRoom(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request StartMatch(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_StartMatch(roomID));
			}
			return null;
		}

		public static void SetMatchFoundNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Matchmaking_MatchFound, callback);
		}
	}
	public static class Net
	{
		public static Packet ReadPacket()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_Net_ReadPacket();
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return new Packet(intPtr);
		}

		public static bool SendPacket(ulong userID, byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacket(userID, (UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static void Connect(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Connect(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Accept(userID);
			}
		}

		public static void Close(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Close(userID);
			}
		}

		public static bool IsConnected(ulong userID)
		{
			return Core.IsInitialized() && CAPI.ovr_Net_IsConnected(userID);
		}

		public static bool SendPacketToCurrentRoom(byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacketToCurrentRoom((UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static bool AcceptForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_AcceptForCurrentRoom();
			}
			return false;
		}

		public static void CloseForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_CloseForCurrentRoom();
			}
		}

		public static Request<PingResult> Ping(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<PingResult>(CAPI.ovr_Net_Ping(userID));
			}
			return null;
		}

		public static void SetConnectionStateChangedCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_ConnectionStateChange, callback);
		}

		public static void SetPeerConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PeerConnectRequest, callback);
		}

		public static void SetPingResultNotificationCallback(Message<PingResult>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PingResult, callback);
		}
	}
	public static class Leaderboards
	{
		public static Request<LeaderboardEntryList> GetNextEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1310751961));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetPreviousEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.PreviousUrl, 1224858304));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntries(leaderboardName, limit, filter, startAt));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntriesAfterRank(leaderboardName, limit, afterRank));
			}
			return null;
		}

		public static Request<bool> WriteEntry(string leaderboardName, long score, byte[] extraData = null, bool forceUpdate = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<bool>(CAPI.ovr_Leaderboard_WriteEntry(leaderboardName, score, extraData, (extraData != null) ? ((uint)extraData.Length) : 0u, forceUpdate));
			}
			return null;
		}
	}
	public static class Voip
	{
		public static void Start(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Start(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Accept(userID);
			}
		}

		public static void Stop(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Stop(userID);
			}
		}

		public static void SetMicrophoneFilterCallback(CAPI.FilterCallback callback)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(callback, (UIntPtr)480uL);
			}
		}

		public static void SetMicrophoneMuted(VoipMuteState state)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneMuted(state);
			}
		}

		public static VoipMuteState GetSystemVoipMicrophoneMuted()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipMicrophoneMuted();
			}
			return VoipMuteState.Unknown;
		}

		public static SystemVoipStatus GetSystemVoipStatus()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipStatus();
			}
			return SystemVoipStatus.Unknown;
		}

		public static VoipDtxState GetIsConnectionUsingDtx(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetIsConnectionUsingDtx(peerID);
			}
			return VoipDtxState.Unknown;
		}

		public static VoipBitrate GetLocalBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetLocalBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static VoipBitrate GetRemoteBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetRemoteBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static void SetNewConnectionOptions(VoipOptions voipOptions)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetNewConnectionOptions((IntPtr)voipOptions);
			}
		}

		public static Request<SystemVoipState> SetSystemVoipSuppressed(bool suppressed)
		{
			if (Core.IsInitialized())
			{
				return new Request<SystemVoipState>(CAPI.ovr_Voip_SetSystemVoipSuppressed(suppressed));
			}
			return null;
		}

		public static void SetVoipConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_ConnectRequest, callback);
		}

		public static void SetVoipStateChangeCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_StateChange, callback);
		}

		public static void SetSystemVoipStateNotificationCallback(Message<SystemVoipState>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_SystemVoipState, callback);
		}
	}
	public static class Achievements
	{
		public static Request<AchievementUpdate> AddCount(string name, ulong count)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Request<AchievementUpdate> AddFields(string name, string fields)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetAllDefinitions()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Request<AchievementProgressList> GetAllProgress()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetProgressByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementUpdate> Unlock(string name)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetNextAchievementDefinitionListPage(AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 712888917));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetNextAchievementProgressListPage(AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 792913703));
			}
			return null;
		}
	}
	public static class Application
	{
		public static Request<ApplicationVersion> GetVersion()
		{
			if (Core.IsInitialized())
			{
				return new Request<ApplicationVersion>(CAPI.ovr_Application_GetVersion());
			}
			return null;
		}

		public static Request<string> LaunchOtherApp(ulong appID, ApplicationOptions deeplink_options = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_Application_LaunchOtherApp(appID, (IntPtr)deeplink_options));
			}
			return null;
		}
	}
	public static class AssetFile
	{
		public static Request<AssetFileDeleteResult> Delete(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_Delete(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> Download(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_Download(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancel(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancel(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetDetailsList> GetList()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetailsList>(CAPI.ovr_AssetFile_GetList());
			}
			return null;
		}

		public static Request<AssetDetails> Status(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_Status(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusById(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusByName(assetFileName));
			}
			return null;
		}

		public static void SetDownloadUpdateNotificationCallback(Message<AssetFileDownloadUpdate>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_AssetFile_DownloadUpdate, callback);
		}
	}
	public static class Avatar
	{
	}
	public static class Cal
	{
	}
	public static class CloudStorage
	{
		public static Request<CloudStorageUpdateResponse> Delete(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Delete(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> Load(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_Load(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> LoadBucketMetadata(string bucket)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_CloudStorage_LoadBucketMetadata(bucket));
			}
			return null;
		}

		public static Request<CloudStorageConflictMetadata> LoadConflictMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageConflictMetadata>(CAPI.ovr_CloudStorage_LoadConflictMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> LoadHandle(string handle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_LoadHandle(handle));
			}
			return null;
		}

		public static Request<CloudStorageMetadata> LoadMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadata>(CAPI.ovr_CloudStorage_LoadMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepLocal(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepRemote(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> Save(string bucket, string key, byte[] data, long counter, string extraData)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Save(bucket, key, data, (data != null) ? ((uint)data.Length) : 0u, counter, extraData));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> GetNextCloudStorageMetadataListPage(CloudStorageMetadataList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextCloudStorageMetadataListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1544004335));
			}
			return null;
		}
	}
	public static class CloudStorage2
	{
	}
	public static class Entitlements
	{
		public static Request IsUserEntitledToApplication()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Entitlement_GetIsViewerEntitled());
			}
			return null;
		}
	}
	public static class GraphAPI
	{
	}
	public static class HTTP
	{
	}
	public static class IAP
	{
		public static Request ConsumePurchase(string sku)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_IAP_ConsumePurchase(sku));
			}
			return null;
		}

		public static Request<ProductList> GetProductsBySKU(string[] skus)
		{
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_IAP_GetProductsBySKU(skus, (skus != null) ? skus.Length : 0));
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchases()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchases());
			}
			return null;
		}

		public static Request<Purchase> LaunchCheckoutFlow(string sku)
		{
			if (Core.IsInitialized())
			{
				if (UnityEngine.Application.isEditor)
				{
					throw new NotImplementedException("LaunchCheckoutFlow() is not implemented in the editor yet.");
				}
				return new Request<Purchase>(CAPI.ovr_IAP_LaunchCheckoutFlow(sku));
			}
			return null;
		}

		public static Request<ProductList> GetNextProductListPage(ProductList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextProductListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 467225263));
			}
			return null;
		}

		public static Request<PurchaseList> GetNextPurchaseListPage(PurchaseList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextPurchaseListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1196886677));
			}
			return null;
		}
	}
	public static class LanguagePack
	{
		public static Request<AssetDetails> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_LanguagePack_GetCurrent());
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> SetCurrent(string tag)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_LanguagePack_SetCurrent(tag));
			}
			return null;
		}
	}
	public static class Livestreaming
	{
		public static Request<LivestreamingStatus> GetStatus()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_GetStatus());
			}
			return null;
		}

		public static Request<LivestreamingStatus> PauseStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_PauseStream());
			}
			return null;
		}

		public static Request<LivestreamingStatus> ResumeStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_ResumeStream());
			}
			return null;
		}

		public static void SetStatusUpdateNotificationCallback(Message<LivestreamingStatus>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Livestreaming_StatusChange, callback);
		}
	}
	public static class Media
	{
		public static Request<ShareMediaResult> ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			if (Core.IsInitialized())
			{
				return new Request<ShareMediaResult>(CAPI.ovr_Media_ShareToFacebook(postTextSuggestion, filePath, contentType));
			}
			return null;
		}
	}
	public static class Notifications
	{
		public static Request<RoomInviteNotificationList> GetRoomInviteNotifications()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_Notification_GetRoomInvites());
			}
			return null;
		}

		public static Request MarkAsRead(ulong notificationID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Notification_MarkAsRead(notificationID));
			}
			return null;
		}

		public static Request<RoomInviteNotificationList> GetNextRoomInviteNotificationListPage(RoomInviteNotificationList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextRoomInviteNotificationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 102890359));
			}
			return null;
		}
	}
	public static class Parties
	{
		public static Request<Party> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Party>(CAPI.ovr_Party_GetCurrent());
			}
			return null;
		}
	}
	public static class Users
	{
		public static Request<User> Get(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_Get(userID));
			}
			return null;
		}

		public static Request<string> GetAccessToken()
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_User_GetAccessToken());
			}
			return null;
		}

		public static Request<User> GetLoggedInUser()
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_GetLoggedInUser());
			}
			return null;
		}

		public static Request<UserList> GetLoggedInUserFriends()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_User_GetLoggedInUserFriends());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserFriendsAndRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserFriendsAndRooms());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserRecentlyMetUsersAndRooms(UserOptions userOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms((IntPtr)userOptions));
			}
			return null;
		}

		public static Request<OrgScopedID> GetOrgScopedID(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<OrgScopedID>(CAPI.ovr_User_GetOrgScopedID(userID));
			}
			return null;
		}

		public static Request<SdkAccountList> GetSdkAccounts()
		{
			if (Core.IsInitialized())
			{
				return new Request<SdkAccountList>(CAPI.ovr_User_GetSdkAccounts());
			}
			return null;
		}

		public static Request<UserProof> GetUserProof()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserProof>(CAPI.ovr_User_GetUserProof());
			}
			return null;
		}

		public static Request<LaunchFriendRequestFlowResult> LaunchFriendRequestFlow(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<LaunchFriendRequestFlowResult>(CAPI.ovr_User_LaunchFriendRequestFlow(userID));
			}
			return null;
		}

		public static Request LaunchProfile(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_User_LaunchProfile(userID));
			}
			return null;
		}

		public static Request<UserAndRoomList> GetNextUserAndRoomListPage(UserAndRoomList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextUserAndRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 2143146719));
			}
			return null;
		}

		public static Request<UserList> GetNextUserListPage(UserList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextUserListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 645723971));
			}
			return null;
		}
	}
	public enum PlatformInitializeResult
	{
		[Description("SUCCESS")]
		Success = 0,
		[Description("UNINITIALIZED")]
		Uninitialized = -1,
		[Description("PRE_LOADED")]
		PreLoaded = -2,
		[Description("FILE_INVALID")]
		FileInvalid = -3,
		[Description("SIGNATURE_INVALID")]
		SignatureInvalid = -4,
		[Description("UNABLE_TO_VERIFY")]
		UnableToVerify = -5,
		[Description("VERSION_MISMATCH")]
		VersionMismatch = -6,
		[Description("UNKNOWN")]
		Unknown = -7,
		[Description("INVALID_CREDENTIALS")]
		InvalidCredentials = -8,
		[Description("NOT_ENTITLED")]
		NotEntitled = -9
	}
	public static class PlatformInternal
	{
		public enum MessageTypeInternal : uint
		{
			Application_ExecuteCoordinatedLaunch = 645772532u,
			Application_GetInstalledApplications = 1376744524u,
			Avatar_UpdateMetaData = 2077219214u,
			Cal_FinalizeApplication = 497667029u,
			Cal_GetSuggestedApplications = 1450209301u,
			Cal_ProposeApplication = 1317270237u,
			CloudStorage2_GetUserDirectoryPath = 1990471406u,
			GraphAPI_Get = 822018158u,
			GraphAPI_Post = 1990567876u,
			HTTP_Get = 1874211363u,
			HTTP_GetToFile = 1317133401u,
			HTTP_MultiPartPost = 1480774160u,
			HTTP_Post = 1798743375u,
			Livestreaming_IsAllowedForApplication = 191729014u,
			Livestreaming_StartPartyStream = 2066701532u,
			Livestreaming_StartStream = 1343932350u,
			Livestreaming_StopPartyStream = 661065560u,
			Livestreaming_StopStream = 1155796426u,
			Livestreaming_UpdateCommentsOverlayVisibility = 528318516u,
			Livestreaming_UpdateMicStatus = 475495815u,
			Party_Create = 450042703u,
			Party_GatherInApplication = 1921499523u,
			Party_Get = 1586058173u,
			Party_GetCurrentForUser = 1489764138u,
			Party_Invite = 901104867u,
			Party_Join = 1744993395u,
			Party_Leave = 848430801u,
			Room_CreateOrUpdateAndJoinNamed = 2089683601u,
			Room_GetNamedRooms = 125660812u,
			Room_GetSocialRooms = 1636310390u,
			SystemPermissions_GetStatus = 493497353u,
			SystemPermissions_LaunchDeeplink = 442139697u,
			User_CancelRecordingForReportFlow = 65065289u,
			User_GetLinkedAccounts = 1469314134u,
			User_LaunchBlockFlow = 1876305192u,
			User_LaunchReportFlow = 1449304081u,
			User_LaunchReportFlow2 = 2139314275u,
			User_LaunchUnblockFlow = 346172055u,
			User_NewEntitledTestUser = 292822787u,
			User_NewTestUser = 921194380u,
			User_NewTestUserFriends = 517416647u,
			User_StartRecordingForReportFlow = 1819161571u,
			User_StopRecordingAndLaunchReportFlow = 1618513035u,
			User_StopRecordingAndLaunchReportFlow2 = 432190251u,
			User_TestUserCreateDeviceManifest = 1701884605u
		}

		public static class HTTP
		{
			public static void SetHttpTransferUpdateCallback(Message<HttpTransferUpdate>.Callback callback)
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_HTTP_Transfer, callback);
			}
		}

		public static void CrashApplication()
		{
			CAPI.ovr_CrashApplication();
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle, Message.MessageType messageType)
		{
			Message result = null;
			switch ((MessageTypeInternal)messageType)
			{
			case MessageTypeInternal.User_StartRecordingForReportFlow:
				result = new MessageWithAbuseReportRecording(messageHandle);
				break;
			case MessageTypeInternal.Cal_FinalizeApplication:
				result = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageTypeInternal.Cal_GetSuggestedApplications:
				result = new MessageWithCalApplicationSuggestionList(messageHandle);
				break;
			case MessageTypeInternal.User_CancelRecordingForReportFlow:
			case MessageTypeInternal.Livestreaming_UpdateMicStatus:
			case MessageTypeInternal.Application_ExecuteCoordinatedLaunch:
			case MessageTypeInternal.Livestreaming_StopPartyStream:
			case MessageTypeInternal.Party_Leave:
			case MessageTypeInternal.Cal_ProposeApplication:
			case MessageTypeInternal.User_TestUserCreateDeviceManifest:
				result = new Message(messageHandle);
				break;
			case MessageTypeInternal.Application_GetInstalledApplications:
				result = new MessageWithInstalledApplicationList(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchBlockFlow:
				result = new MessageWithLaunchBlockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchReportFlow2:
				result = new MessageWithLaunchReportFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchUnblockFlow:
				result = new MessageWithLaunchUnblockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_GetLinkedAccounts:
				result = new MessageWithLinkedAccountList(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_IsAllowedForApplication:
				result = new MessageWithLivestreamingApplicationStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StartStream:
			case MessageTypeInternal.Livestreaming_StartPartyStream:
				result = new MessageWithLivestreamingStartResult(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_UpdateCommentsOverlayVisibility:
				result = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StopStream:
				result = new MessageWithLivestreamingVideoStats(messageHandle);
				break;
			case MessageTypeInternal.Party_Get:
				result = new MessageWithParty(messageHandle);
				break;
			case MessageTypeInternal.Party_GetCurrentForUser:
				result = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageTypeInternal.Party_Create:
			case MessageTypeInternal.Party_Invite:
			case MessageTypeInternal.Party_Join:
			case MessageTypeInternal.Party_GatherInApplication:
				result = new MessageWithPartyID(messageHandle);
				break;
			case MessageTypeInternal.Room_CreateOrUpdateAndJoinNamed:
				result = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageTypeInternal.Room_GetNamedRooms:
			case MessageTypeInternal.Room_GetSocialRooms:
				result = new MessageWithRoomList(messageHandle);
				break;
			case MessageTypeInternal.User_NewEntitledTestUser:
			case MessageTypeInternal.User_NewTestUserFriends:
			case MessageTypeInternal.GraphAPI_Get:
			case MessageTypeInternal.User_NewTestUser:
			case MessageTypeInternal.HTTP_GetToFile:
			case MessageTypeInternal.HTTP_MultiPartPost:
			case MessageTypeInternal.HTTP_Post:
			case MessageTypeInternal.HTTP_Get:
			case MessageTypeInternal.CloudStorage2_GetUserDirectoryPath:
			case MessageTypeInternal.GraphAPI_Post:
			case MessageTypeInternal.Avatar_UpdateMetaData:
				result = new MessageWithString(messageHandle);
				break;
			case MessageTypeInternal.SystemPermissions_LaunchDeeplink:
			case MessageTypeInternal.SystemPermissions_GetStatus:
				result = new MessageWithSystemPermission(messageHandle);
				break;
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow2:
			case MessageTypeInternal.User_LaunchReportFlow:
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow:
				result = new MessageWithUserReportID(messageHandle);
				break;
			}
			return result;
		}
	}
	public sealed class PlatformSettings : ScriptableObject
	{
		[SerializeField]
		private string ovrAppID = string.Empty;

		[SerializeField]
		private string ovrMobileAppID = string.Empty;

		[SerializeField]
		private bool ovrUseStandalonePlatform = true;

		[SerializeField]
		private bool ovrEnableARM64Support;

		private static PlatformSettings instance;

		public static string AppID
		{
			get
			{
				return Instance.ovrAppID;
			}
			set
			{
				Instance.ovrAppID = value;
			}
		}

		public static string MobileAppID
		{
			get
			{
				return Instance.ovrMobileAppID;
			}
			set
			{
				Instance.ovrMobileAppID = value;
			}
		}

		public static bool UseStandalonePlatform
		{
			get
			{
				return Instance.ovrUseStandalonePlatform;
			}
			set
			{
				Instance.ovrUseStandalonePlatform = value;
			}
		}

		public static bool EnableARM64Support
		{
			get
			{
				return Instance.ovrEnableARM64Support;
			}
			set
			{
				Instance.ovrEnableARM64Support = value;
			}
		}

		public static PlatformSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<PlatformSettings>("OculusPlatformSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<PlatformSettings>();
					}
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public sealed class Request<T> : Request
	{
		public Request(ulong requestID)
			: base(requestID)
		{
		}

		public Request<T> OnComplete(Message<T>.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}
	}
	public class Request
	{
		public ulong RequestID { get; set; }

		public Request(ulong requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Message.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Callback.RunCallbacks();
			}
			else
			{
				Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum RoomJoinability
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ARE_IN")]
		AreIn,
		[Description("ARE_KICKED")]
		AreKicked,
		[Description("CAN_JOIN")]
		CanJoin,
		[Description("IS_FULL")]
		IsFull,
		[Description("NO_VIEWER")]
		NoViewer,
		[Description("POLICY_PREVENTS")]
		PolicyPrevents
	}
	public enum RoomJoinPolicy
	{
		[Description("NONE")]
		None,
		[Description("EVERYONE")]
		Everyone,
		[Description("FRIENDS_OF_MEMBERS")]
		FriendsOfMembers,
		[Description("FRIENDS_OF_OWNER")]
		FriendsOfOwner,
		[Description("INVITED_USERS")]
		InvitedUsers,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum RoomMembershipLockStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCK")]
		Lock,
		[Description("UNLOCK")]
		Unlock
	}
	public class RoomOptions
	{
		private IntPtr Handle;

		public RoomOptions()
		{
			Handle = CAPI.ovr_RoomOptions_Create();
		}

		public void SetDataStore(string key, string value)
		{
			CAPI.ovr_RoomOptions_SetDataStoreString(Handle, key, value);
		}

		public void ClearDataStore()
		{
			CAPI.ovr_RoomOptions_ClearDataStore(Handle);
		}

		public void SetExcludeRecentlyMet(bool value)
		{
			CAPI.ovr_RoomOptions_SetExcludeRecentlyMet(Handle, value);
		}

		public void SetMaxUserResults(uint value)
		{
			CAPI.ovr_RoomOptions_SetMaxUserResults(Handle, value);
		}

		public void SetOrdering(UserOrdering value)
		{
			CAPI.ovr_RoomOptions_SetOrdering(Handle, value);
		}

		public void SetRecentlyMetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_RoomOptions_SetRecentlyMetTimeWindow(Handle, value);
		}

		public void SetRoomId(ulong value)
		{
			CAPI.ovr_RoomOptions_SetRoomId(Handle, value);
		}

		public void SetTurnOffUpdates(bool value)
		{
			CAPI.ovr_RoomOptions_SetTurnOffUpdates(Handle, value);
		}

		public static explicit operator IntPtr(RoomOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RoomOptions()
		{
			CAPI.ovr_RoomOptions_Destroy(Handle);
		}
	}
	public enum RoomType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MATCHMAKING")]
		Matchmaking,
		[Description("MODERATED")]
		Moderated,
		[Description("PRIVATE")]
		Private,
		[Description("SOLO")]
		Solo
	}
	public enum SdkAccountType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OCULUS")]
		Oculus,
		[Description("FACEBOOK_GAMEROOM")]
		FacebookGameroom
	}
	public enum SendPolicy
	{
		[Description("UNRELIABLE")]
		Unreliable,
		[Description("RELIABLE")]
		Reliable,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum ServiceProvider
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("DROPBOX")]
		Dropbox,
		[Description("FACEBOOK")]
		Facebook,
		[Description("GOOGLE")]
		Google,
		[Description("INSTAGRAM")]
		Instagram,
		[Description("REMOTE_MEDIA")]
		RemoteMedia
	}
	public enum ShareMediaStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SHARED")]
		Shared,
		[Description("CANCELED")]
		Canceled
	}
	public sealed class StandalonePlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		public Request<PlatformInitialize> InitializeInEditor()
		{
			if (string.IsNullOrEmpty(PlatformSettings.MobileAppID))
			{
				throw new UnityException("Update your App ID by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string mobileAppID = PlatformSettings.MobileAppID;
			if (string.IsNullOrEmpty(StandalonePlatformSettings.OculusPlatformTestUserAccessToken))
			{
				throw new UnityException("Update your standalone credentials by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string oculusPlatformTestUserAccessToken = StandalonePlatformSettings.OculusPlatformTestUserAccessToken;
			CAPI.ovr_UnityResetTestPlatform();
			CAPI.ovr_UnityInitGlobals(IntPtr.Zero);
			return new Request<PlatformInitialize>(CAPI.ovr_PlatformInitializeWithAccessToken(ulong.Parse(mobileAppID), oculusPlatformTestUserAccessToken));
		}
	}
	public sealed class StandalonePlatformSettings
	{
		public static string OculusPlatformTestUserEmail
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserPassword
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserAccessToken
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}
	}
	public enum SystemVoipStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("UNAVAILABLE")]
		Unavailable,
		[Description("SUPPRESSED")]
		Suppressed,
		[Description("ACTIVE")]
		Active
	}
	public enum TimeWindow
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONE_HOUR")]
		OneHour,
		[Description("ONE_DAY")]
		OneDay,
		[Description("ONE_WEEK")]
		OneWeek,
		[Description("THIRTY_DAYS")]
		ThirtyDays,
		[Description("NINETY_DAYS")]
		NinetyDays
	}
	public class UserOptions
	{
		private IntPtr Handle;

		public UserOptions()
		{
			Handle = CAPI.ovr_UserOptions_Create();
		}

		public void SetMaxUsers(uint value)
		{
			CAPI.ovr_UserOptions_SetMaxUsers(Handle, value);
		}

		public void AddServiceProvider(ServiceProvider value)
		{
			CAPI.ovr_UserOptions_AddServiceProvider(Handle, value);
		}

		public void ClearServiceProviders()
		{
			CAPI.ovr_UserOptions_ClearServiceProviders(Handle);
		}

		public void SetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_UserOptions_SetTimeWindow(Handle, value);
		}

		public static explicit operator IntPtr(UserOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~UserOptions()
		{
			CAPI.ovr_UserOptions_Destroy(Handle);
		}
	}
	public enum UserOrdering
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("PRESENCE_ALPHABETICAL")]
		PresenceAlphabetical
	}
	public enum UserPresenceStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONLINE")]
		Online,
		[Description("OFFLINE")]
		Offline
	}
	public class VoipAudioSourceHiLevel : MonoBehaviour
	{
		public class FilterReadDelegate : MonoBehaviour
		{
			public VoipAudioSourceHiLevel parent;

			private float[] scratchBuffer;

			private void Awake()
			{
				int num = (int)(uint)CAPI.ovr_Voip_GetOutputBufferMaxSize();
				scratchBuffer = new float[num];
			}

			private void OnAudioFilterRead(float[] data, int channels)
			{
				int num = data.Length / channels;
				int num2 = num;
				if (num2 > scratchBuffer.Length)
				{
					Array.Clear(data, 0, data.Length);
					throw new Exception($"Audio system tried to pull {num} bytes, max voip internal ring buffer size {scratchBuffer.Length}");
				}
				int num3 = parent.pcmSource.PeekSizeElements();
				if (num3 < num2)
				{
					if (verboseLogging)
					{
						Debug.LogFormat("Voip starved! Want {0}, but only have {1} available", num2, num3);
					}
					return;
				}
				int pCM = parent.pcmSource.GetPCM(scratchBuffer, num2);
				if (pCM < num2)
				{
					Debug.LogWarningFormat("GetPCM() returned {0} samples, expected {1}", pCM, num2);
					return;
				}
				int num4 = 0;
				float num5 = -1f;
				for (int i = 0; i < num; i++)
				{
					float num6 = scratchBuffer[i];
					for (int j = 0; j < channels; j++)
					{
						data[num4++] = num6;
						if (num6 > num5)
						{
							num5 = num6;
						}
					}
				}
				parent.peakAmplitude = num5;
			}
		}

		private int initialPlaybackDelayMS;

		public AudioSource audioSource;

		public float peakAmplitude;

		protected IVoipPCMSource pcmSource;

		private static int audioSystemPlaybackFrequency;

		private static bool verboseLogging;

		public ulong senderID
		{
			set
			{
				pcmSource.SetSenderID(value);
			}
		}

		protected void Stop()
		{
		}

		private VoipSampleRate SampleRateToEnum(int rate)
		{
			return rate switch
			{
				48000 => VoipSampleRate.HZ48000, 
				44100 => VoipSampleRate.HZ44100, 
				24000 => VoipSampleRate.HZ24000, 
				_ => VoipSampleRate.Unknown, 
			};
		}

		protected void Awake()
		{
			CreatePCMSource();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.gameObject.AddComponent<FilterReadDelegate>();
			FilterReadDelegate component = audioSource.gameObject.GetComponent<FilterReadDelegate>();
			component.parent = this;
			initialPlaybackDelayMS = 40;
			audioSystemPlaybackFrequency = AudioSettings.outputSampleRate;
			CAPI.ovr_Voip_SetOutputSampleRate(SampleRateToEnum(audioSystemPlaybackFrequency));
			if (verboseLogging)
			{
				Debug.LogFormat("freq {0}", audioSystemPlaybackFrequency);
			}
		}

		private void Start()
		{
			audioSource.Stop();
		}

		protected virtual void CreatePCMSource()
		{
			pcmSource = new VoipPCMSourceNative();
		}

		protected static int MSToElements(int ms)
		{
			return ms * audioSystemPlaybackFrequency / 1000;
		}

		private void Update()
		{
			pcmSource.Update();
			if (!audioSource.isPlaying && pcmSource.PeekSizeElements() >= MSToElements(initialPlaybackDelayMS))
			{
				if (verboseLogging)
				{
					Debug.LogFormat("buffered {0} elements, starting playback", pcmSource.PeekSizeElements());
				}
				audioSource.Play();
			}
		}
	}
	public enum VoipBitrate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("B16000")]
		B16000,
		[Description("B24000")]
		B24000,
		[Description("B32000")]
		B32000,
		[Description("B64000")]
		B64000,
		[Description("B96000")]
		B96000,
		[Description("B128000")]
		B128000
	}
	public enum VoipDtxState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ENABLED")]
		Enabled,
		[Description("DISABLED")]
		Disabled
	}
	public enum VoipMuteState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MUTED")]
		Muted,
		[Description("UNMUTED")]
		Unmuted
	}
	public class VoipOptions
	{
		private IntPtr Handle;

		public VoipOptions()
		{
			Handle = CAPI.ovr_VoipOptions_Create();
		}

		public void SetBitrateForNewConnections(VoipBitrate value)
		{
			CAPI.ovr_VoipOptions_SetBitrateForNewConnections(Handle, value);
		}

		public void SetCreateNewConnectionUseDtx(VoipDtxState value)
		{
			CAPI.ovr_VoipOptions_SetCreateNewConnectionUseDtx(Handle, value);
		}

		public static explicit operator IntPtr(VoipOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~VoipOptions()
		{
			CAPI.ovr_VoipOptions_Destroy(Handle);
		}
	}
	public class VoipPCMSourceNative : IVoipPCMSource
	{
		private ulong senderID;

		public int GetPCM(float[] dest, int length)
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMFloat(senderID, dest, (UIntPtr)(ulong)length);
		}

		public void SetSenderID(ulong senderID)
		{
			this.senderID = senderID;
		}

		public int PeekSizeElements()
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMSize(senderID);
		}

		public void Update()
		{
		}
	}
	public enum VoipSampleRate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("HZ24000")]
		HZ24000,
		[Description("HZ44100")]
		HZ44100,
		[Description("HZ48000")]
		HZ48000
	}
	public class WindowsPlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		private IntPtr getCallbackPointer()
		{
			return IntPtr.Zero;
		}

		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			CAPI.ovr_UnityInitWrapperWindows(appId, getCallbackPointer());
			return true;
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperWindowsAsynchronous(appId, getCallbackPointer()));
		}
	}
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		AudioListener componentInChildren = gameObject.GetComponentInChildren<AudioListener>();
		if (componentInChildren != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot t = currentSnapshot;
		snapshotList.Push(t);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private AudioRaycastCallback _raycastCallback;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		_raycastCallback = AudioRaycast;
		OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((!(num3 < 32f)) ? 0f : Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)));
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject gameObject2 = new GameObject("Wall_" + n);
			gameObject2.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = gameObject2.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			gameObject2.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(MulticastDelegate callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		AudioSource component = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (component == null)
		{
			Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (component.spatialize)
		{
			Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			component.spatialize = false;
		}
		if (component.clip == null)
		{
			Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (component.clip.channels != numFOAChannels)
		{
			Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		AudioSource component = GetComponent<AudioSource>();
		if (component == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		component.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 1f;

	[SerializeField]
	private float far = 10f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;
	}

	public string filePathRelative;

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess;

	private static int terrainDecimation = 4;

	public string filePath => UnityEngine.Application.streamingAssetsPath + "/" + filePathRelative;

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		AudioConfiguration configuration = AudioSettings.GetConfiguration();
		if (PropIFace.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				Debug.Log("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			PropIFace.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && PropIFace.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length > 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					Debug.Log("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.");
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic);
		int num = 0;
		uint num2 = 0u;
		int num3 = 0;
		int num4 = 0;
		foreach (MeshMaterial item in list)
		{
			Mesh sharedMesh = item.meshFilter.sharedMesh;
			num4 += sharedMesh.subMeshCount;
			num += sharedMesh.vertexCount;
			for (int i = 0; i < sharedMesh.subMeshCount; i++)
			{
				MeshTopology topology = sharedMesh.GetTopology(i);
				if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
				{
					uint indexCount = sharedMesh.GetIndexCount(i);
					num2 += indexCount;
					switch (topology)
					{
					case MeshTopology.Triangles:
						num3 += (int)indexCount / 3;
						break;
					case MeshTopology.Quads:
						num3 += (int)indexCount / 4;
						break;
					}
				}
			}
		}
		foreach (TerrainMaterial item2 in list2)
		{
			TerrainData terrainData = item2.terrain.terrainData;
			int heightmapWidth = terrainData.heightmapWidth;
			int heightmapHeight = terrainData.heightmapHeight;
			int num5 = (heightmapWidth - 1) / terrainDecimation + 1;
			int num6 = (heightmapHeight - 1) / terrainDecimation + 1;
			int num7 = num5 * num6;
			int num8 = (num5 - 1) * (num6 - 1) * 6;
			num4++;
			num += num7;
			num2 += (uint)num8;
			num3 += num8 / 3;
		}
		List<Vector3> list3 = new List<Vector3>();
		List<int> list4 = new List<int>();
		MeshGroup[] array = new MeshGroup[num4];
		float[] array2 = new float[num * 3];
		int[] array3 = new int[num2];
		int num9 = 0;
		int num10 = 0;
		int num11 = 0;
		foreach (MeshMaterial item3 in list)
		{
			MeshFilter meshFilter = item3.meshFilter;
			Mesh sharedMesh2 = meshFilter.sharedMesh;
			Matrix4x4 matrix4x = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			list3.Clear();
			sharedMesh2.GetVertices(list3);
			int count = list3.Count;
			for (int j = 0; j < count; j++)
			{
				Vector3 vector = matrix4x.MultiplyPoint3x4(list3[j]);
				int num12 = (num9 + j) * 3;
				array2[num12] = vector.x;
				array2[num12 + 1] = vector.y;
				array2[num12 + 2] = vector.z;
			}
			for (int k = 0; k < sharedMesh2.subMeshCount; k++)
			{
				MeshTopology topology2 = sharedMesh2.GetTopology(k);
				if (topology2 != 0 && topology2 != MeshTopology.Quads)
				{
					continue;
				}
				list4.Clear();
				sharedMesh2.GetIndices(list4, k);
				int count2 = list4.Count;
				for (int l = 0; l < count2; l++)
				{
					array3[num10 + l] = list4[l] + num9;
				}
				switch (topology2)
				{
				case MeshTopology.Triangles:
					array[num11 + k].faceType = FaceType.TRIANGLES;
					array[num11 + k].faceCount = (UIntPtr)(ulong)(count2 / 3);
					break;
				case MeshTopology.Quads:
					array[num11 + k].faceType = FaceType.QUADS;
					array[num11 + k].faceCount = (UIntPtr)(ulong)(count2 / 4);
					break;
				}
				array[num11 + k].indexOffset = (UIntPtr)(ulong)num10;
				if (item3.materials != null && item3.materials.Length != 0)
				{
					int num13 = k;
					if (num13 >= item3.materials.Length)
					{
						num13 = item3.materials.Length - 1;
					}
					item3.materials[num13].StartInternal();
					array[num11 + k].material = item3.materials[num13].materialHandle;
				}
				else
				{
					array[num11 + k].material = IntPtr.Zero;
				}
				num10 += count2;
			}
			num9 += count;
			num11 += sharedMesh2.subMeshCount;
		}
		foreach (TerrainMaterial item4 in list2)
		{
			TerrainData terrainData2 = item4.terrain.terrainData;
			Matrix4x4 matrix4x2 = worldToLocal * item4.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapWidth2 = terrainData2.heightmapWidth;
			int heightmapHeight2 = terrainData2.heightmapHeight;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapWidth2, heightmapHeight2);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapWidth2 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapHeight2 - 1) * (float)terrainDecimation);
			int num14 = (heightmapWidth2 - 1) / terrainDecimation + 1;
			int num15 = (heightmapHeight2 - 1) / terrainDecimation + 1;
			int num16 = num14 * num15;
			int num17 = (num14 - 1) * (num15 - 1) * 2;
			array[num11].faceType = FaceType.TRIANGLES;
			array[num11].faceCount = (UIntPtr)(ulong)num17;
			array[num11].indexOffset = (UIntPtr)(ulong)num10;
			if (item4.materials != null && 0 < item4.materials.Length)
			{
				item4.materials[0].StartInternal();
				array[num11].material = item4.materials[0].materialHandle;
			}
			else
			{
				array[num11].material = IntPtr.Zero;
			}
			for (int m = 0; m < num15; m++)
			{
				for (int n = 0; n < num14; n++)
				{
					int num18 = (num9 + m * num14 + n) * 3;
					Vector3 vector2 = matrix4x2.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array2[num18] = vector2.x;
					array2[num18 + 1] = vector2.y;
					array2[num18 + 2] = vector2.z;
				}
			}
			for (int num19 = 0; num19 < num15 - 1; num19++)
			{
				for (int num20 = 0; num20 < num14 - 1; num20++)
				{
					array3[num10] = num9 + num19 * num14 + num20;
					array3[num10 + 1] = num9 + (num19 + 1) * num14 + num20;
					array3[num10 + 2] = num9 + num19 * num14 + num20 + 1;
					array3[num10 + 3] = num9 + (num19 + 1) * num14 + num20;
					array3[num10 + 4] = num9 + (num19 + 1) * num14 + num20 + 1;
					array3[num10 + 5] = num9 + num19 * num14 + num20 + 1;
					num10 += 6;
				}
			}
			num9 += num16;
			num11++;
		}
		return PropIFace.AudioGeometryUploadMeshArrays(geometryHandle, array2, num, array3, array3.Length, array, array.Length);
	}

	public void UploadGeometry()
	{
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			Debug.Log("Invalid mesh file path");
			return false;
		}
		if (PropIFace.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			Debug.Log("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}
}
namespace ONSPPropagationInterface
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(0, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}
}
namespace ONSPPropagationInterface.Unity_Native
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "AudioPluginOculusSpatializer";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context);

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
namespace ONSPPropagationInterface.Wwise
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "OculusSpatializerWwise";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context);

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
namespace ONSPPropagationInterface.FMOD
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "OculusSpatializerFMOD";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context);

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (PropIFace.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			PropIFace.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		string message = $"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}";
		Debug.Log(message);
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
namespace OvrTouch.Controllers
{
	public class TouchController : MonoBehaviour
	{
		private enum AnimParamId
		{
			Button1,
			Button2,
			Trigger,
			Grip,
			JoyX,
			JoyY,
			Count
		}

		private static class Const
		{
			public static readonly string[] AnimParamNames = new string[6] { "Button 1", "Button 2", "Trigger", "Grip", "Joy X", "Joy Y" };
		}

		[SerializeField]
		private HandednessId m_handedness;

		[SerializeField]
		private Animator m_animator;

		[SerializeField]
		private Transform m_meshRoot;

		private TrackedController m_trackedController;

		private int[] m_animParamIndices = new int[6];

		public void SetVisible(bool visible)
		{
			m_meshRoot.gameObject.SetActive(visible);
		}

		private void Start()
		{
			for (int i = 0; i < m_animParamIndices.Length; i++)
			{
				m_animParamIndices[i] = Animator.StringToHash(Const.AnimParamNames[i]);
			}
			m_trackedController = TrackedController.FindOrCreate(m_handedness);
		}

		private void LateUpdate()
		{
			if (!(m_trackedController == null))
			{
				base.transform.position = m_trackedController.transform.position;
				base.transform.rotation = m_trackedController.transform.rotation;
				float paramValue = ((!m_trackedController.Button1) ? 0f : 1f);
				SetAnimParam(AnimParamId.Button1, paramValue);
				float paramValue2 = ((!m_trackedController.Button2) ? 0f : 1f);
				SetAnimParam(AnimParamId.Button2, paramValue2);
				Vector2 joystick = m_trackedController.Joystick;
				SetAnimParam(AnimParamId.JoyX, joystick.x);
				SetAnimParam(AnimParamId.JoyY, joystick.y);
				SetAnimParam(AnimParamId.Grip, m_trackedController.GripTrigger);
				SetAnimParam(AnimParamId.Trigger, m_trackedController.Trigger);
			}
		}

		private void SetAnimParam(AnimParamId paramId, float paramValue)
		{
			m_animator.SetFloat(m_animParamIndices[(int)paramId], paramValue);
		}
	}
	public enum HandednessId
	{
		Left,
		Right
	}
	public class TrackedController : MonoBehaviour
	{
		private static class Const
		{
			public const float TriggerDebounceTime = 0.05f;

			public const float ThumbDebounceTime = 0.15f;
		}

		[SerializeField]
		private HandednessId m_handedness;

		[SerializeField]
		private Transform m_trackedTransform;

		private bool m_initialized;

		private OVRInput.Controller m_controllerType;

		private bool m_point;

		private bool m_thumbsUp;

		private float m_lastPoint = -1f;

		private float m_lastNonPoint = -1f;

		private float m_lastThumb = -1f;

		private float m_lastNonThumb = -1f;

		private float m_hapticDuration = -1f;

		private float m_hapticStartTime = -1f;

		public HandednessId Handedness => m_handedness;

		public bool IsLeft => m_handedness == HandednessId.Left;

		public bool IsPoint => m_point;

		public bool IsThumbsUp => m_thumbsUp;

		public bool Button1 => OVRInput.Get(OVRInput.Button.One, m_controllerType);

		public bool Button2 => OVRInput.Get(OVRInput.Button.Two, m_controllerType);

		public bool ButtonJoystick => OVRInput.Get(OVRInput.Button.PrimaryThumbstick, m_controllerType);

		public float Trigger => OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controllerType);

		public float GripTrigger => OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controllerType);

		public Vector2 Joystick => OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controllerType);

		public static TrackedController FindOrCreate(HandednessId handedness)
		{
			TrackedController[] array = UnityEngine.Object.FindObjectsOfType<TrackedController>();
			TrackedController[] array2 = array;
			foreach (TrackedController trackedController in array2)
			{
				if (trackedController.Handedness == handedness)
				{
					return trackedController;
				}
			}
			GameObject gameObject = new GameObject("TrackedController");
			TrackedController trackedController2 = gameObject.AddComponent<TrackedController>();
			Transform trackedTransform = null;
			OVRCameraRig oVRCameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			if (oVRCameraRig != null)
			{
				trackedTransform = ((handedness != 0) ? oVRCameraRig.rightHandAnchor : oVRCameraRig.leftHandAnchor);
			}
			trackedController2.Initialize(handedness, trackedTransform);
			return trackedController2;
		}

		public void PlayHapticEvent(float frequency, float amplitude, float duration)
		{
			m_hapticStartTime = Time.time;
			m_hapticDuration = duration;
			OVRInput.SetControllerVibration(frequency, amplitude, m_controllerType);
		}

		private void Awake()
		{
			if (m_trackedTransform != null)
			{
				Initialize(m_handedness, m_trackedTransform);
			}
		}

		private void LateUpdate()
		{
			if (m_trackedTransform != null)
			{
				base.transform.position = m_trackedTransform.position;
				base.transform.rotation = m_trackedTransform.rotation;
			}
			float num = Time.time - m_hapticStartTime;
			if (num >= m_hapticDuration)
			{
				OVRInput.SetControllerVibration(0f, 0f, m_controllerType);
			}
			float time = Time.time;
			bool flag = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controllerType);
			if (flag)
			{
				m_lastPoint = time;
			}
			else
			{
				m_lastNonPoint = time;
			}
			bool flag2 = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controllerType);
			if (flag2)
			{
				m_lastThumb = time;
			}
			else
			{
				m_lastNonThumb = time;
			}
			if (flag != IsPoint && ((flag && time - m_lastNonPoint > 0.05f) || (!flag && time - m_lastPoint > 0.05f)))
			{
				m_point = flag;
			}
			if (flag2 != IsThumbsUp && ((flag2 && time - m_lastNonThumb > 0.15f) || (!flag2 && time - m_lastThumb > 0.15f)))
			{
				m_thumbsUp = flag2;
			}
		}

		private void Initialize(HandednessId handedness, Transform trackedTransform)
		{
			if (!m_initialized)
			{
				m_handedness = handedness;
				m_controllerType = ((m_handedness == HandednessId.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
				if (trackedTransform != null)
				{
					m_trackedTransform = trackedTransform;
					base.transform.position = m_trackedTransform.position;
					base.transform.rotation = m_trackedTransform.rotation;
				}
				m_initialized = true;
			}
		}
	}
}
public class CustomWindParticles : MonoBehaviour
{
	private ParticleSystem ps;

	private ParticleSystem.Particle[] cloud;

	public void Start()
	{
		ps = GetComponent<ParticleSystem>();
		cloud = new ParticleSystem.Particle[ps.maxParticles];
	}

	private void LateUpdate()
	{
		Vector3 vector = ATSMobileWindManager.windForce;
		ps.GetParticles(cloud);
		int i = 0;
		int num = 0;
		for (num = ps.GetParticles(cloud); i < num; i++)
		{
			cloud[i].velocity = new Vector3(vector.x, -0.1f, 0f) * 0.1f;
		}
		ps.SetParticles(cloud, num);
	}
}
public class GodRays : MonoBehaviour
{
	public Transform waterSurface;

	public float yOffset;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position = new Vector3(base.transform.position.x, waterSurface.position.y + yOffset, base.transform.position.z);
	}
}
public class LightBeamManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class LightBeamSpawner : MonoBehaviour
{
	public GameObject lightBeamPrefab;

	public Transform waterSurface;

	public int howMany = 20;

	public float radius = 5f;

	public float minDistance = 3f;

	public float offsetFromWaterSurface;

	private GameObject[] beams;

	private Vector3 temp;

	private Transform player;

	private void Start()
	{
		player = GameObject.Find("Dummy Player").transform;
		Array.Resize(ref beams, howMany);
		for (int i = 0; i < howMany; i++)
		{
			float num = Random.Range(0f - radius, radius);
			float num2 = Random.Range(0f - radius, radius);
			temp = player.position + new Vector3(Random.Range(0f - radius, radius), 0f, Random.Range(0f - radius, radius));
			temp.y = waterSurface.position.y + offsetFromWaterSurface;
			beams[i] = UnityEngine.Object.Instantiate(lightBeamPrefab, temp, Quaternion.identity);
			if (CalcDistanceToPlayer(beams[i]) < minDistance)
			{
				beams[i].SetActive(value: false);
			}
		}
	}

	private void Update()
	{
		GameObject[] array = beams;
		foreach (GameObject gameObject in array)
		{
			if (!gameObject.activeInHierarchy)
			{
				temp = player.position + new Vector3(Random.Range(0f - radius, radius), 0f, Random.Range(0f - radius, radius));
				temp.y = waterSurface.position.y + offsetFromWaterSurface;
				gameObject.transform.position = temp;
				if (CalcDistanceToPlayer(gameObject) > minDistance)
				{
					gameObject.SetActive(value: true);
				}
			}
		}
	}

	private float CalcDistanceToPlayer(GameObject beam)
	{
		Vector3 vector = new Vector3(player.position.x, waterSurface.position.y, player.position.z);
		return (beam.transform.position - vector).magnitude;
	}
}
public class ScubaBubblesGenerator : MonoBehaviour
{
	public float emitRate = 9f;

	public float emitTime = 1f;

	public float initialTime = 6f;

	private float emitTimer;

	private float bubblesTimer;

	private float prevAudioTime;

	public ParticleSystem[] particleSystems;

	public ParticleSystem.EmissionModule[] emissionModules;

	private int i;

	private AudioSource audio;

	private void Start()
	{
		audio = GetComponent<AudioSource>();
		emissionModules = new ParticleSystem.EmissionModule[2];
		for (i = 0; i < particleSystems.Length; i++)
		{
			ref ParticleSystem.EmissionModule reference = ref emissionModules[i];
			reference = particleSystems[i].emission;
			emissionModules[i].enabled = false;
		}
		emitTimer = initialTime;
	}

	private void Update()
	{
		if (Mathf.Abs(audio.time - prevAudioTime) > 10f)
		{
			emitTimer = initialTime;
		}
		if (emitTimer > emitRate)
		{
			emitTimer = 0f;
			bubblesTimer = emitTime;
		}
		for (i = 0; i < particleSystems.Length; i++)
		{
			if (bubblesTimer > 0f)
			{
				if (!emissionModules[i].enabled)
				{
					emissionModules[i].enabled = true;
				}
			}
			else if (emissionModules[i].enabled)
			{
				emissionModules[i].enabled = false;
			}
		}
		emitTimer += Time.deltaTime;
		bubblesTimer -= Time.deltaTime;
		prevAudioTime = audio.time;
	}
}
public class AnimatedCaustics : MonoBehaviour
{
	public float fps = 30f;

	public Texture2D[] frames;

	private int frameIndex;

	private Projector projector;

	private void Start()
	{
		NextFrame();
		InvokeRepeating("NextFrame", 1f / fps, 1f / fps);
	}

	private void NextFrame()
	{
		GetComponent<Renderer>().material.SetTexture("_Caustics", frames[frameIndex]);
		frameIndex = (frameIndex + 1) % frames.Length;
	}
}
public class AnimatedProjector : MonoBehaviour
{
	public float fps = 30f;

	public Texture2D[] frames;

	private int frameIndex;

	private Projector projector;

	private void Start()
	{
		projector = GetComponent<Projector>();
		NextFrame();
		InvokeRepeating("NextFrame", 1f / fps, 1f / fps);
	}

	private void NextFrame()
	{
		projector.material.SetTexture("_ShadowTex", frames[frameIndex]);
		frameIndex = (frameIndex + 1) % frames.Length;
	}
}
public class AnimationSpeed : MonoBehaviour
{
	public string clipName;

	public float speed = 1f;

	private void Start()
	{
	}
}
public class AutoDestroy : MonoBehaviour
{
	public float timer;

	public float loopingOffAfter;

	private float loopTimer;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject, timer);
	}

	private void Update()
	{
		loopTimer += Time.deltaTime;
		if (loopTimer > loopingOffAfter && GetComponent<ParticleSystem>() != null)
		{
			GetComponent<ParticleSystem>().loop = false;
		}
	}
}
public class Billboard : MonoBehaviour
{
	private Camera camera;

	private void Start()
	{
		camera = LAC_VRCameraRig.instance.getCenterCamera();
	}

	private void Update()
	{
		base.transform.rotation = camera.transform.rotation;
	}
}
public class BlueWhale : MonoBehaviour
{
	public float speed = 0.0025f;

	private SplineController splineController;

	public Animator animator;

	private void Start()
	{
		splineController = GetComponent<SplineController>();
		splineController.Speed = speed;
	}

	private void Update()
	{
		animator.SetFloat("Speed", 0.5f);
		splineController.Speed = speed;
	}
}
public class BlueWhaleEyes : MonoBehaviour
{
	public Renderer renderer;

	public float maxEyeOffset = 0.02f;

	private Material eyeMaterial;

	private Vector2 currentTargetOffset;

	private Vector2 offset;

	private float timer;

	public float changeRate = 1f;

	public float lerpRate = 0.5f;

	public float horizontalWeight = 2f;

	private Vector2 initalOffset;

	private void Start()
	{
		eyeMaterial = renderer.materials[1];
		initalOffset = eyeMaterial.GetTextureOffset("_MainTex");
	}

	private void Update()
	{
		offset = Vector2.Lerp(offset, currentTargetOffset, Time.deltaTime * lerpRate);
		eyeMaterial.SetTextureOffset("_MainTex", new Vector2(offset.x + initalOffset.x, offset.y + initalOffset.y));
		timer += Time.deltaTime;
		if (timer > changeRate)
		{
			timer = Random.Range(-2f, 0f);
			currentTargetOffset = new Vector2(Random.Range(0f - maxEyeOffset, maxEyeOffset), Random.Range(0f - maxEyeOffset, maxEyeOffset) * horizontalWeight);
		}
	}
}
public class Bobbing : MonoBehaviour
{
	private float timer;

	private float waveslice;

	private Vector3 transformPos;

	public float bobbingSpeed = 0.01f;

	public Vector3 bobbingAmount;

	private Vector3 originalPos;

	private void Start()
	{
		originalPos = base.transform.localPosition;
	}

	private void Update()
	{
		waveslice = Mathf.Sin(timer);
		timer += bobbingSpeed;
		if (timer > (float)Math.PI * 2f)
		{
			timer -= (float)Math.PI * 2f;
		}
		transformPos = base.transform.localPosition;
		transformPos.x = originalPos.x + waveslice * bobbingAmount.x;
		transformPos.y = originalPos.y + waveslice * bobbingAmount.y;
		transformPos.z = originalPos.z + waveslice * bobbingAmount.z;
		base.transform.localPosition = transformPos;
	}
}
public class Buyoancy : MonoBehaviour
{
	public float entryForce = 50f;

	public GameObject waterSplashPS;

	public AudioClip splashSound;

	private Transform waterSurface;

	private bool inWater;

	private bool previousInWater;

	public float restDrag = 0.3f;

	public float timeUntilRest = 0.5f;

	private float splashTimer;

	private bool rest;

	private void Start()
	{
		if ((bool)GameObject.Find("Water Surface"))
		{
			waterSurface = GameObject.Find("Water Surface").transform;
		}
		GetComponent<Rigidbody>().AddForce(new Vector3(0f, 0f - entryForce, 0f), ForceMode.Impulse);
	}

	private void Update()
	{
		if (base.transform.position.y - 0.5f > waterSurface.position.y)
		{
			GetComponent<Rigidbody>().useGravity = true;
		}
		else
		{
			GetComponent<Rigidbody>().useGravity = false;
			inWater = true;
		}
		if (inWater != previousInWater)
		{
			UnityEngine.Object.Instantiate(waterSplashPS, base.transform.position - new Vector3(0f, 0.5f, 0f), Quaternion.identity);
			GetComponent<AudioSource>().PlayOneShot(splashSound);
		}
		if (!rest && splashTimer > timeUntilRest)
		{
			rest = true;
			GetComponent<Rigidbody>().drag = restDrag;
		}
		splashTimer += Time.deltaTime;
		previousInWater = inWater;
	}
}
public class CameraDepthTexture : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ChangeFOV : MonoBehaviour
{
	public float FOV = 75f;

	private void Start()
	{
	}

	private void Update()
	{
		GetComponent<Camera>().fieldOfView = FOV;
	}
}
public class CheckOculusEntitlements : MonoBehaviour
{
	private void Awake()
	{
		try
		{
			Core.AsyncInitialize("2134272053250863");
			Entitlements.IsUserEntitledToApplication().OnComplete(GetEntitlementCallback);
		}
		catch (UnityException exception)
		{
			Debug.LogError("Platform failed to init due to exception");
			Debug.LogException(exception);
			UnityEngine.Application.Quit();
		}
	}

	private void GetEntitlementCallback(Message msg)
	{
		if (msg.IsError)
		{
			Debug.Log("You are not entitled to use this app, buster!");
			UnityEngine.Application.Quit();
		}
		else
		{
			Debug.Log("Entitlement check passed");
		}
	}
}
public class ConstantActiveDistance : MonoBehaviour
{
	public float activeDistance = 100f;

	private Transform player;

	public Transform body;

	private void Start()
	{
		player = GameObject.Find("Dummy Player").transform;
		if (body == null)
		{
			body = base.transform;
		}
	}

	private void Update()
	{
		float magnitude = (player.position - body.transform.position).magnitude;
		if (magnitude > activeDistance)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
		else
		{
			base.transform.GetChild(0).gameObject.SetActive(value: true);
		}
	}
}
public class ControlInstructionsSetup : MonoBehaviour
{
	public GameObject daydreamControlsRoot;

	public GameObject gearVRControlsRoot;

	private void Start()
	{
		if (LAC_HMDInfo.instance.getHMDType() == LAC_HMDInfo.HMDType.Daydream)
		{
			daydreamControlsRoot.SetActive(value: true);
		}
		if (LAC_HMDInfo.instance.getHMDType() == LAC_HMDInfo.HMDType.GearVR)
		{
			gearVRControlsRoot.SetActive(value: true);
		}
	}
}
public class CoralColours : MonoBehaviour
{
	public Color[] colors;

	public int currentIndex;

	private int nextIndex;

	public float changeColourTime = 2f;

	public bool randomise;

	private float lastChange;

	private float timer;

	private bool cycleColours = true;

	public Color[] coloursToPickFrom;

	public float maxAlpha = 0.2f;

	public Vector2 changeColorTimeRange = new Vector2(0.1f, 4f);

	private void Start()
	{
		if (colors == null || colors.Length < 2)
		{
			Debug.Log("Need to setup colors array in inspector");
		}
		nextIndex = (currentIndex + 1) % colors.Length;
		if (randomise)
		{
			for (int i = 0; i < colors.Length; i++)
			{
				ref Color reference = ref colors[i];
				reference = coloursToPickFrom[Random.Range(0, coloursToPickFrom.Length)];
				colors[i].a = Random.Range(0.01f, maxAlpha);
			}
			if (Random.Range(0, 2) == 1)
			{
				cycleColours = false;
			}
			changeColourTime = Random.Range(changeColorTimeRange.x, changeColorTimeRange.y);
			GetComponent<Renderer>().material.SetColor("_Color", new Color(Random.Range(0f, 1f), Random.Range(0f, 1f), Random.Range(0f, 1f)));
			float num = Random.Range(0.1f, 5f);
			GetComponent<Renderer>().material.SetTextureScale("_MainTex", new Vector2(num, num));
			num = Random.Range(0.3f, 5f);
			GetComponent<Renderer>().material.SetTextureScale("_DetailTex", new Vector2(num, num));
			GetComponent<Renderer>().material.SetFloat("_ScrollX", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_ScrollY", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_Scroll2X", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_Scroll2Y", Random.Range(0f, 1f));
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown("f"))
		{
			Start();
		}
		if (cycleColours)
		{
			timer += Time.deltaTime;
		}
		if (timer > changeColourTime)
		{
			currentIndex = (currentIndex + 1) % colors.Length;
			nextIndex = (currentIndex + 1) % colors.Length;
			timer = 0f;
		}
		GetComponent<Renderer>().materials[0].SetColor("_TintColor", Color.Lerp(colors[currentIndex], colors[nextIndex], timer / changeColourTime));
	}
}
public class CrabSpawner : MonoBehaviour
{
	public GameObject[] theObjects;

	public float spawnNumber = 1f;

	public BoxCollider movementZone;

	private void Start()
	{
		for (int i = 0; (float)i < spawnNumber; i++)
		{
			Vector3 size = movementZone.bounds.size;
			Vector3 vector = movementZone.transform.position - movementZone.bounds.size / 2f;
			GameObject gameObject = UnityEngine.Object.Instantiate(position: new Vector3(vector.x + Random.value * size.x, vector.y + Random.value * size.y, vector.z + Random.value * size.z), original: theObjects[Random.Range(0, theObjects.Length)], rotation: Quaternion.identity);
			gameObject.GetComponentInChildren<MovingTarget>().movementZone = movementZone;
		}
	}

	private void Update()
	{
	}
}
public class CreatureSpawner : MonoBehaviour
{
	public GameObject[] theObjects;

	public float spawnNumber = 1f;

	public BoxCollider movementZone;

	private void Start()
	{
		for (int i = 0; (float)i < spawnNumber; i++)
		{
			Vector3 size = movementZone.bounds.size;
			Vector3 vector = movementZone.transform.position - movementZone.bounds.size / 2f;
			GameObject gameObject = UnityEngine.Object.Instantiate(position: new Vector3(vector.x + Random.value * size.x, vector.y + Random.value * size.y, vector.z + Random.value * size.z), original: theObjects[Random.Range(0, theObjects.Length)], rotation: Quaternion.identity);
			Transform transform = gameObject.transform.Find("Target");
			if (transform == null)
			{
				transform = gameObject.transform.GetChild(0).Find("Target");
			}
			transform.GetComponent<MovingTarget>().movementZone = movementZone;
		}
	}

	private void Update()
	{
	}
}
public class DaydreamControl : MonoBehaviour
{
	public enum DaydreamControlsMode
	{
		Swipe,
		Touchpad,
		TouchpadClick
	}

	private UI ui;

	private OVRSwimController swimController;

	public DaydreamControlsMode controlMode;

	private Text touchpadText;

	private Text swipepadText;

	private Text appButtonText;

	private Text menuButtonText;

	private int enumCount;

	private int currControlModeIndex;

	private bool motionLock;

	private float startRoll;

	private float startPitch;

	private float startYaw;

	private float endRoll;

	private float endPitch;

	private float endYaw;

	private float clickTimer;

	private float touchTimer;

	private float swipeTime = 0.3f;

	private Vector2 startTouch;

	private float cumulativeTouch;

	private bool staticTouch;

	private Vector2 startDrag;

	private Vector2 endDrag;

	private void Awake()
	{
		UnityEngine.Object.Destroy(this);
	}

	private void Start()
	{
		enumCount = Enum.GetValues(typeof(DaydreamControlsMode)).Length;
		if (!PlayerPrefs.HasKey("DaydreamControlsMode"))
		{
			PlayerPrefs.SetInt("DaydreamControlsMode", 2);
		}
		currControlModeIndex = PlayerPrefs.GetInt("DaydreamControlsMode");
		controlMode = (DaydreamControlsMode)currControlModeIndex;
		ui = base.transform.Find("UI").GetComponent<UI>();
		swimController = GetComponent<OVRSwimController>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}

	private Vector2 clamp01(Vector2 vec)
	{
		if (vec.x < 0f)
		{
			vec.x = 0f;
		}
		if (vec.x > 1f)
		{
			vec.x = 1f;
		}
		if (vec.y < 0f)
		{
			vec.y = 0f;
		}
		if (vec.y > 1f)
		{
			vec.y = 1f;
		}
		return vec;
	}

	public void incrementControlsMode()
	{
		currControlModeIndex++;
		if (currControlModeIndex >= enumCount)
		{
			currControlModeIndex = 0;
		}
		controlMode = (DaydreamControlsMode)currControlModeIndex;
		PlayerPrefs.SetInt("DaydreamControlsMode", currControlModeIndex);
	}

	public string getControlModeString()
	{
		if (controlMode == DaydreamControlsMode.Swipe)
		{
			return "Swipe";
		}
		if (controlMode == DaydreamControlsMode.Touchpad)
		{
			return "Touchpad";
		}
		if (controlMode == DaydreamControlsMode.TouchpadClick)
		{
			return "Touchpad Click";
		}
		return "blank";
	}

	private float getControllerRoll()
	{
		return 0f;
	}

	private float getControllerPitch()
	{
		return 0f;
	}

	private float getControllerYaw()
	{
		return 0f;
	}

	private void ProcessDragging()
	{
	}

	private void KeyboardTest()
	{
		if (Input.GetKeyDown(KeyCode.U))
		{
			ui.ToggleOnOff();
		}
	}
}
public class DeltaTimeTest : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		Debug.Log("Time.deltaTime : " + Time.deltaTime);
	}
}
public class Detritus : MonoBehaviour
{
	private OVRSwimController controller;

	private Vector3 origin;

	public float throttleInfluence = 1f;

	public float heightOffset = 3f;

	private void Start()
	{
		controller = base.transform.parent.GetComponent<OVRSwimController>();
		origin = new Vector3(0f, heightOffset, 0f);
	}

	private void Update()
	{
		if ((bool)controller)
		{
			base.transform.position = origin + controller.transform.position + controller.MoveThrottle * throttleInfluence;
		}
	}
}
public class DisplayDebug : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ElectricSeaSnakeColours : MonoBehaviour
{
	public Color[] colors;

	public int currentIndex;

	private int nextIndex;

	public float changeColourTime = 2f;

	public bool randomise;

	private float lastChange;

	private float timer;

	private bool cycleColours = true;

	public Texture2D[] lightFlashTextures;

	public Color[] coloursToPickFrom;

	private void Start()
	{
		if (colors == null || colors.Length < 2)
		{
			Debug.Log("Need to setup colors array in inspector");
		}
		nextIndex = (currentIndex + 1) % colors.Length;
		if (randomise)
		{
			for (int i = 0; i < colors.Length; i++)
			{
				ref Color reference = ref colors[i];
				reference = coloursToPickFrom[Random.Range(0, coloursToPickFrom.Length)];
				colors[i].a = Random.Range(0.01f, 0.1f);
			}
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown("f"))
		{
			Start();
		}
		if (cycleColours)
		{
			timer += Time.deltaTime;
		}
		if (timer > changeColourTime)
		{
			currentIndex = (currentIndex + 1) % colors.Length;
			nextIndex = (currentIndex + 1) % colors.Length;
			timer = 0f;
		}
		GetComponent<Renderer>().materials[1].SetColor("_TintColor", Color.Lerp(colors[currentIndex], colors[nextIndex], timer / changeColourTime));
	}
}
public class FadeQuad : MonoBehaviour
{
	private float targetAlpha;

	private Color fadeColor;

	private Material material;

	private float currAlpha;

	public float defaultFadeSpeed = 0.5f;

	private Renderer meshRenderer;

	private void Start()
	{
		fadeColor = Color.black;
		currAlpha = 1f;
		material = GetComponent<Renderer>().material;
		meshRenderer = GetComponent<Renderer>();
		material.SetColor("_TintColor", fadeColor);
	}

	private void Update()
	{
		currAlpha = Mathf.Lerp(currAlpha, targetAlpha, Time.deltaTime * defaultFadeSpeed);
		fadeColor.a = currAlpha;
		material.SetColor("_TintColor", fadeColor);
		if (currAlpha < 0.01f)
		{
			meshRenderer.enabled = false;
		}
		else
		{
			meshRenderer.enabled = true;
		}
	}

	public void FadeIn()
	{
		targetAlpha = 0f;
	}

	public void FadeOut()
	{
		targetAlpha = 1f;
	}

	public void Blackout()
	{
		currAlpha = 1f;
		targetAlpha = 1f;
	}
}
public class FireworkObject : MonoBehaviour
{
	public GameObject[] fireworks;

	private bool triggered;

	private void Start()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!(other.GetComponent<Collider>().tag == "Dolphin"))
		{
			return;
		}
		base.transform.parent.tag = "Untagged";
		if (!triggered)
		{
			Spinner component = base.transform.parent.GetComponent<Spinner>();
			if ((bool)component)
			{
				component.startSpinning();
			}
			StartCoroutine(destroyAndFirework());
		}
		triggered = true;
	}

	private IEnumerator destroyAndFirework()
	{
		yield return new WaitForSeconds(2.4f);
		GameObject firework = UnityEngine.Object.Instantiate(fireworks[Random.Range(0, fireworks.Length)], base.transform.position, Quaternion.identity);
		UnityEngine.Object.Instantiate(fireworks[Random.Range(0, fireworks.Length)], base.transform.position, Quaternion.identity);
		firework.GetComponent<AudioSource>().Play();
		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
		yield return null;
	}
}
public class FlashingAlpha : MonoBehaviour
{
	private Color defaultColor;

	private float timer;

	private float alpha;

	public float frequency = 0.5f;

	private Renderer renderer;

	private void Start()
	{
		defaultColor = GetComponent<Renderer>().material.GetColor("_TintColor");
		timer = Random.Range(0f, 2f);
		renderer = GetComponent<Renderer>();
	}

	private void Update()
	{
		alpha = 0.1f + 0.5f * (1f + Mathf.Sin(timer));
		defaultColor.a = alpha;
		renderer.material.SetColor("_TintColor", defaultColor);
		timer += Time.deltaTime * frequency;
	}
}
public class FlashText : MonoBehaviour
{
	public float flashRate;

	public AnimationCurve flashCurve;

	public Vector2 minMaxAlpha = new Vector3(0f, 1f);

	private float flashTimer;

	private Color textColour;

	private void OnEnable()
	{
		flashTimer = 0f;
		textColour = base.transform.GetComponent<Renderer>().material.GetColor("_TintColor");
		textColour.a = minMaxAlpha.x + flashCurve.Evaluate(flashTimer * flashRate) * (minMaxAlpha.y - minMaxAlpha.x);
		base.transform.GetComponent<Renderer>().material.SetColor("_TintColor", textColour);
	}

	private void Start()
	{
		textColour = base.transform.GetComponent<Renderer>().material.GetColor("_TintColor");
		textColour.a = minMaxAlpha.x + flashCurve.Evaluate(flashTimer * flashRate) * (minMaxAlpha.y - minMaxAlpha.x);
		base.transform.GetComponent<Renderer>().material.SetColor("_TintColor", textColour);
	}

	private void Update()
	{
		textColour.a = minMaxAlpha.x + flashCurve.Evaluate(flashTimer * flashRate) * (minMaxAlpha.y - minMaxAlpha.x);
		base.transform.GetComponent<Renderer>().material.SetColor("_TintColor", textColour);
		flashTimer += Time.deltaTime;
	}

	public void Reset()
	{
		flashTimer = 0f;
	}
}
public class FlickCameraOffOn : MonoBehaviour
{
	public GameObject cam;

	public Camera ScreenshotCam;

	public float FOV = 70f;

	private void Start()
	{
		cam.SetActive(value: false);
		cam.SetActive(value: true);
	}

	private void Update()
	{
		ScreenshotCam.fieldOfView = FOV;
	}
}
public class FlickeringLightBeam : MonoBehaviour
{
	public float swingFactor = 0.3f;

	public float swingFrequency = 3f;

	public float swingAmplitude = 20f;

	public float rotationLerpSpeed = 1f;

	public float noiseBaseline = 0.15f;

	public float noiseTurbulence = 1f;

	public Vector3 axis = new Vector3(1f, 0f, 0f);

	public int changeChance = 30;

	public Vector2 durationRange = new Vector2(1f, 2f);

	public AnimationCurve lightbeamCurve;

	public float fadeDistanceStart = 3f;

	private float targetAngle;

	private Quaternion originalAngle;

	private float random;

	private float intensity = 1f;

	private float duration;

	private float alpha;

	private float value;

	private float noise;

	private Transform player;

	public LineRenderer lineRenderer;

	private Color theColour;

	private float timer;

	public AnimationCurve proximityFadeCurve;

	public float DistanceToLine(Ray ray, Vector3 point)
	{
		return Vector3.Cross(ray.direction, point - ray.origin).magnitude;
	}

	private void Start()
	{
		lineRenderer = base.transform.GetComponent<LineRenderer>();
		originalAngle = base.transform.rotation;
		player = GameObject.Find("Dummy Player").transform;
	}

	private void OnEnable()
	{
		random = Random.Range(0f, 65535f);
		theColour = GetComponent<Renderer>().material.GetColor("_TintColor");
		base.transform.rotation = Quaternion.identity;
		duration = Random.Range(durationRange.x, durationRange.y);
		timer = 0f;
	}

	private void Update()
	{
		value = lightbeamCurve.Evaluate(timer / duration) * intensity;
		noise = noiseBaseline + Mathf.PerlinNoise(random, Time.time * noiseTurbulence);
		float num = 1f;
		Ray ray = new Ray(base.transform.position, -base.transform.up);
		float num2 = DistanceToLine(ray, player.position + player.forward);
		if (num2 < fadeDistanceStart)
		{
			num = proximityFadeCurve.Evaluate(1f - num2 / fadeDistanceStart);
		}
		float a = noise * value * num;
		theColour.a = a;
		GetComponent<Renderer>().material.SetColor("_TintColor", theColour);
		targetAngle = -0.5f * Mathf.Sin(Time.time * swingFrequency) * swingAmplitude;
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, originalAngle * Quaternion.Euler(axis * targetAngle), rotationLerpSpeed * Time.deltaTime);
		timer += Time.deltaTime;
		if (timer > duration)
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class FlickerLight : MonoBehaviour
{
	public float maxLightIntensity;

	public float minLightIntensity;

	public int changeChance;

	public float lerpSpeed;

	private float targetIntensity;

	private Color originalColor;

	private float originalIntensity;

	private Light light;

	private void Start()
	{
		originalColor = GetComponent<Light>().color;
		originalIntensity = GetComponent<Light>().intensity;
		light = GetComponent<Light>();
		targetIntensity = Random.Range(minLightIntensity, maxLightIntensity);
	}

	private void Update()
	{
		light.intensity = Mathf.Lerp(light.intensity, targetIntensity, Time.deltaTime * lerpSpeed);
		if (Random.Range(0, changeChance) == 1)
		{
			targetIntensity = Random.Range(minLightIntensity, maxLightIntensity);
		}
	}
}
public class FlipperAnimator : MonoBehaviour
{
	private float frontMaxVerticalLimit = 3f;

	private float frontMinVerticalLimit = -3f;

	private float frontMaxHorizontalLimit = 6.5f;

	private float frontMinHorizontalLimit = -4f;

	private float rearMinHorizontalLimit = -5f;

	private float rearMaxHorizontalLimit = -6f;

	private float rearMinVerticalLimit = 5f;

	private float rearMaxVerticalLimit = -1f;

	public Transform leftFlipperJoint;

	public Transform rightFlipperJoint;

	public Transform frontLeft;

	public Transform frontRight;

	public Transform backLeft;

	public Transform backRight;

	public Transform swimNode;

	public Transform target;

	public Transform leftFlipperTarget;

	public Transform rightFlipperTarget;

	public Transform turtleBody;

	private float targetXAngleR;

	private float targetXAngleL;

	public float lerpSpeed = 5f;

	public float reactionTime = 1.5f;

	public AnimationCurve flipperCurve;

	private float flipperTime;

	private bool drawStroke;

	public float forwardStrokeSpeed = 1f;

	public float backwardStrokeSpeed = 1f;

	public float strokeSpeedMultiplier = 1f;

	private float adjustedStrokeSpeed;

	private float speedStrokeModifier;

	private float rotationalDampener;

	private float speedTurnModifier;

	private float flipperDifference;

	private float flipperDifferenceTurnSpeedModifier;

	private float rotationalAccelerator;

	public float drag = 0.01f;

	public float turningAgility = 1f;

	public AnimationCurve motionCurve;

	private float motionCurveTimer;

	private SeaTurtle seaTurtle;

	public float frontFlipperOffset = 4f;

	public float rearFlipperOffset = -4f;

	private void Start()
	{
		seaTurtle = base.transform.GetComponent<SeaTurtle>();
	}

	public bool isPerformingDrawstroke()
	{
		return drawStroke;
	}

	public float getStrokeSpeedWeight()
	{
		return speedStrokeModifier;
	}

	public float getRotationalDampener()
	{
		return rotationalDampener;
	}

	public float getRotationalAccelerator()
	{
		return rotationalAccelerator;
	}

	public float getSpeedTurnModifier()
	{
		return speedTurnModifier;
	}

	private void Update()
	{
		rotationalAccelerator = 1f + Mathf.Abs(flipperDifference) / distanceVal(frontMaxHorizontalLimit, frontMinHorizontalLimit) * turningAgility;
		UpdateFlipperTargets();
		UpdateStrokeDirection();
		RotateFlipper();
		modifySpeed();
		UpdateFlipper(leftFlipperJoint, leftFlipperTarget, bRightSide: false);
		UpdateFlipper(rightFlipperJoint, rightFlipperTarget, bRightSide: true);
	}

	private void UpdateFlipper(Transform flipper, Transform targetPoint, bool bRightSide)
	{
		Quaternion rotation = flipper.rotation;
		flipper.LookAt(targetPoint, turtleBody.up);
		flipper.rotation *= Quaternion.Euler(0f, 90f, 0f);
		if (!bRightSide)
		{
			flipper.rotation *= Quaternion.Euler(targetXAngleL, 0f, 0f);
		}
		else
		{
			flipper.rotation *= Quaternion.Euler(180f - targetXAngleR, 0f, 0f);
		}
		Quaternion rotation2 = flipper.rotation;
		flipper.rotation = Quaternion.Slerp(rotation, rotation2, Time.deltaTime * lerpSpeed);
	}

	private void UpdateFlipperTargets()
	{
		UpdateStrokeTargets();
		float num = flipperCurve.Evaluate(flipperTime);
		leftFlipperTarget.position = backLeft.position * (1f - num) + frontLeft.position * num;
		rightFlipperTarget.position = backRight.position * (1f - num) + frontRight.position * num;
		flipperTime += Time.deltaTime * (adjustedStrokeSpeed * seaTurtle.targetSpeed);
	}

	public float getStrokeTimer()
	{
		return flipperTime;
	}

	private void UpdateStrokeTargets()
	{
		UpdateSwimNode();
		float y = swimNode.localPosition.y;
		float x = swimNode.localPosition.x;
		float z = swimNode.localPosition.z;
		float num = 1f;
		if (z < 0f)
		{
			num = z * -1f;
		}
		float num2 = distanceVal(frontMinVerticalLimit, frontMaxVerticalLimit);
		float num3 = distanceVal(rearMinVerticalLimit, rearMaxVerticalLimit);
		float num4 = (frontLeft.localPosition.z + frontMinHorizontalLimit * -1f) / num2;
		float num5 = (frontRight.localPosition.z + frontMinHorizontalLimit * -1f) / num2;
		float num6 = (backLeft.localPosition.z - rearMinHorizontalLimit) / num3;
		float num7 = (backRight.localPosition.z - rearMinHorizontalLimit) / num3;
		float y2 = Mathf.Clamp(y / 1.5f * num5, frontMinVerticalLimit, frontMaxVerticalLimit);
		float y3 = Mathf.Clamp(y / 1.5f * num4, frontMinVerticalLimit, frontMaxVerticalLimit);
		float z2 = Mathf.Clamp(frontFlipperOffset - x / 8.2f * num, frontMinHorizontalLimit, frontMaxHorizontalLimit);
		float z3 = Mathf.Clamp(frontFlipperOffset + x / 8.2f * num, frontMinHorizontalLimit, frontMaxHorizontalLimit);
		float y4 = Mathf.Clamp(y / 2f * num7, rearMaxVerticalLimit, rearMinVerticalLimit);
		float y5 = Mathf.Clamp(y / 2f * num6, rearMaxVerticalLimit, rearMinVerticalLimit);
		float z4 = Mathf.Clamp(rearFlipperOffset + x / 8f * num, rearMaxHorizontalLimit, rearMinHorizontalLimit);
		float z5 = Mathf.Clamp(rearFlipperOffset - x / 8f * num, rearMaxHorizontalLimit, rearMinHorizontalLimit);
		Vector3 b = new Vector3(frontLeft.localPosition.x, y3, z3);
		Vector3 b2 = new Vector3(frontRight.localPosition.x, y2, z2);
		Vector3 b3 = new Vector3(backLeft.localPosition.x, y5, z5);
		Vector3 b4 = new Vector3(backRight.localPosition.x, y4, z4);
		frontLeft.localPosition = Vector3.Lerp(frontLeft.localPosition, b, Time.deltaTime * drag);
		frontRight.localPosition = Vector3.Lerp(frontRight.localPosition, b2, Time.deltaTime * drag);
		backLeft.localPosition = Vector3.Lerp(backLeft.localPosition, b3, Time.deltaTime * drag);
		backRight.localPosition = Vector3.Lerp(backRight.localPosition, b4, Time.deltaTime * drag);
	}

	private void UpdateSwimNode()
	{
		swimNode.position = Vector3.Lerp(swimNode.position, target.position, Time.deltaTime * reactionTime);
	}

	private float distanceVal(float a, float b)
	{
		return Mathf.Abs(a - b);
	}

	private void RotateFlipper()
	{
		float num = Vector3.Angle(backLeft.localPosition, frontLeft.localPosition);
		float num2 = Vector3.Angle(backRight.localPosition, frontRight.localPosition);
		float num3 = Vector3.Distance(backLeft.localPosition, frontLeft.localPosition);
		float num4 = Vector3.Distance(backRight.localPosition, frontRight.localPosition);
		float num5 = Mathf.Clamp01(num3 / frontMaxHorizontalLimit);
		float num6 = Mathf.Clamp01(num4 / frontMaxHorizontalLimit);
		float b = -90f + num * num5;
		float b2 = -90f + num2 * num6;
		float b3 = (-180f + num) * num5;
		float b4 = (-180f + num2) * num6;
		if (drawStroke)
		{
			targetXAngleL = Mathf.Lerp(targetXAngleL, b, Time.deltaTime * 1.2f);
			targetXAngleR = Mathf.Lerp(targetXAngleR, b2, Time.deltaTime * 1.2f);
		}
		else
		{
			targetXAngleL = Mathf.Lerp(targetXAngleL, b3, Time.deltaTime * 1.2f);
			targetXAngleR = Mathf.Lerp(targetXAngleR, b4, Time.deltaTime * 1.2f);
		}
	}

	private void modifySpeed()
	{
		float num = Vector3.Distance(frontLeft.localPosition, backLeft.localPosition);
		float num2 = Vector3.Distance(frontRight.localPosition, backRight.localPosition);
		flipperDifference = num - num2;
		speedTurnModifier = Mathf.Clamp01(1f - Mathf.Abs(flipperDifference) / (frontMaxHorizontalLimit - frontMinHorizontalLimit) + seaTurtle.minDriftSpeed);
	}

	private void UpdateStrokeDirection()
	{
		if (Mathf.Floor(flipperTime % 2f) == 0f)
		{
			drawStroke = false;
			speedStrokeModifier = Mathf.Lerp(speedStrokeModifier, seaTurtle.minDriftSpeed, Time.deltaTime * drag);
			rotationalDampener = Mathf.Lerp(rotationalDampener, 0.3f, Time.deltaTime * drag);
			adjustedStrokeSpeed = forwardStrokeSpeed;
			motionCurveTimer = 0f;
		}
		else
		{
			drawStroke = true;
			float num = motionCurve.Evaluate(motionCurveTimer);
			speedStrokeModifier = num * seaTurtle.fastestSpeed + (1f - num) * seaTurtle.minDriftSpeed;
			rotationalDampener = Mathf.Lerp(rotationalDampener, 1f, Time.deltaTime * 1f);
			adjustedStrokeSpeed = backwardStrokeSpeed;
			motionCurveTimer += Time.deltaTime * 1f;
		}
	}
}
public class FloatingPhysics : MonoBehaviour
{
	private float sine;

	private int sw;

	private float timer;

	private float xMovement;

	private float xtorque;

	private float ytorque;

	private float ztorque;

	public float verticalSpeed = 1f;

	public float verticalDistance = 1f;

	public float horizontalSpeed = 1f;

	public float spinSpeed = 1f;

	private void Start()
	{
		xMovement = Random.Range(-0.5f, 0.5f) * horizontalSpeed;
		xtorque = Random.Range(-5f, 5f) * spinSpeed;
		ytorque = Random.Range(-5f, 5f) * spinSpeed;
		ztorque = Random.Range(-5f, 5f) * spinSpeed;
		GetComponent<Rigidbody>().AddRelativeTorque(new Vector3(xtorque, ytorque, ztorque));
	}

	private void FixedUpdate()
	{
		if (sine < (float)Math.PI && sw == 0)
		{
			sine += Time.deltaTime;
		}
		if (sine >= (float)Math.PI)
		{
			sw = 1;
		}
		if (sine <= 0f)
		{
			sw = 0;
		}
		if (sine >= 0f && sw == 1)
		{
			sine = 0f;
		}
		GetComponent<Rigidbody>().velocity = new Vector3(xMovement, Mathf.Sin(2f * sine * verticalSpeed) * verticalDistance, 0f);
		if (timer < 10f)
		{
			timer += Time.deltaTime;
		}
		if (timer >= 10f)
		{
			timer = 0f;
			GetComponent<Rigidbody>().AddRelativeTorque(new Vector3(xtorque, ytorque, ztorque));
		}
	}
}
public class FollowAtWaterSurface : MonoBehaviour
{
	private Transform waterSurface;

	private Transform player;

	private void Start()
	{
		waterSurface = GameObject.Find("Water Surface").transform;
		player = GameObject.Find("Dummy Player").transform;
	}

	private void Update()
	{
		Vector3 position = player.position;
		position.y = waterSurface.position.y;
		base.transform.position = position;
	}
}
public class ForceField : MonoBehaviour
{
	public GameObject repelParticles;

	private OVRPlayerController playerController;

	private void Start()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponent<Collider>().tag == "Player")
		{
			UnityEngine.Object.Instantiate(repelParticles, other.transform.position, Quaternion.identity);
		}
	}
}
public class GearVRControl : MonoBehaviour
{
	public enum GearVRControlsMode
	{
		Swipe,
		Click
	}

	public GearVRControlsMode controlMode;

	public float singleClickTime = 0.25f;

	private UI ui;

	private OVRSwimController swimController;

	private bool isDragging;

	private float oldDragPosition;

	private bool touchpadDown;

	private bool triggerDown;

	private float touchSwimTimer;

	private float touchTimer;

	private float backButtonTimer;

	private float systemTimer;

	private float prevXButton;

	private float prevYButton;

	private float prevBButton;

	private int currControlModeIndex;

	private int enumCount;

	private float triggerSwimTimer;

	private float deadzone = 0.35f;

	private void Awake()
	{
		UnityEngine.Object.Destroy(this);
	}

	private void Start()
	{
		if (!PlayerPrefs.HasKey("GearVRControlsMode"))
		{
			PlayerPrefs.SetInt("GearVRControlsMode", 0);
		}
		currControlModeIndex = PlayerPrefs.GetInt("GearVRControlsMode");
		enumCount = Enum.GetValues(typeof(GearVRControlsMode)).Length;
		ui = base.transform.Find("UI").GetComponent<UI>();
		swimController = GetComponent<OVRSwimController>();
	}

	private void UpdateGamepadInput()
	{
		if (OVRInput.GetDown(OVRInput.Button.Four, OVRInput.Controller.Gamepad))
		{
			ui.processSingleTap();
		}
		if (OVRInput.GetDown(OVRInput.Button.Two, OVRInput.Controller.Gamepad))
		{
			ui.processDownSwipe();
		}
		if (OVRInput.GetDown(OVRInput.Button.Three, OVRInput.Controller.Gamepad))
		{
			swimController.ToggleGravity();
		}
	}

	private void Update()
	{
		if (LAC_GearVRRemote.instance.isControllerConnected())
		{
			if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger))
			{
				triggerSwimTimer += Time.deltaTime;
			}
			if (OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger))
			{
				if (triggerSwimTimer < singleClickTime && !ui.isShowingSomething() && !ui.isLoading())
				{
					DropObjectIntoWater();
				}
				triggerSwimTimer = 0f;
			}
			if (OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad))
			{
				TouchUp();
			}
			if (OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad))
			{
				TouchDown();
			}
			if (OVRInput.Get(OVRInput.Button.Back))
			{
				backButtonTimer += Time.deltaTime;
			}
			if (OVRInput.GetUp(OVRInput.Button.Back))
			{
				if (!ui.isLoading() && backButtonTimer < 0.5f)
				{
					if (!ui.isSwichedOn() && !ui.isShowingSomething())
					{
						ui.SwitchUIOn();
					}
					else if (ui.isShowingInfo())
					{
						ui.processDownSwipe();
					}
					else
					{
						OVRManager.PlatformUIConfirmQuit();
					}
				}
				backButtonTimer = 0f;
			}
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			bool flag7 = false;
			bool flag8 = false;
			if (flag7)
			{
				ui.switchOffInfoSpheres();
			}
			if (OVRInput.Get(OVRInput.Button.PrimaryTouchpad))
			{
				Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
				if (vector.x < 0f - deadzone)
				{
					flag2 = true;
				}
				if (vector.x > deadzone)
				{
					flag = true;
				}
				if (!flag2 && !flag)
				{
					if (vector.y < 0f - deadzone)
					{
						flag4 = true;
					}
					if (vector.y > deadzone)
					{
						flag3 = true;
					}
				}
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				Vector2 vector2 = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
				if (vector2.x < 0f - deadzone)
				{
					flag6 = true;
				}
				else if (vector2.x > deadzone)
				{
					flag5 = true;
				}
				else if (vector2.y < 0f - deadzone)
				{
					flag7 = true;
				}
				else
				{
					flag8 = true;
				}
			}
			if (!ui.isSwitchedOn() && !ui.isShowingSomething())
			{
				if (flag)
				{
					swimController.TouchpadLeftStroke(0.9f);
				}
				if (flag2)
				{
					swimController.TouchpadRightStroke(0.9f);
				}
				if (flag3)
				{
					swimController.TouchpadSwimUp(0.7f);
				}
				if (flag4)
				{
					swimController.TouchpadSwimDown(0.7f);
				}
				if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) && triggerSwimTimer > singleClickTime)
				{
					swimController.TouchpadSwim();
				}
			}
			else
			{
				if (flag5)
				{
					ui.swipeIconsLeft();
				}
				if (flag6)
				{
					ui.swipeIconsRight();
				}
				if (flag7)
				{
					ui.processDownSwipe();
				}
				if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
				{
					ui.processSingleTap();
				}
			}
		}
		else
		{
			UpdateGamepadInput();
			if (OVRInput.Get(OVRInput.Button.Back))
			{
				backButtonTimer += Time.deltaTime;
			}
			if (OVRInput.GetUp(OVRInput.Button.Back))
			{
				if (!ui.isLoading() && backButtonTimer < 0.5f)
				{
					if (!ui.isSwichedOn() && !ui.isShowingSomething())
					{
						ui.SwitchUIOn();
					}
					else if (ui.isShowingInfo())
					{
						ui.processDownSwipe();
					}
					else
					{
						OVRManager.PlatformUIConfirmQuit();
					}
				}
				backButtonTimer = 0f;
			}
			if (OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad))
			{
				TouchDown();
			}
			if (OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad))
			{
				TouchUp();
			}
			if (touchpadDown)
			{
				touchSwimTimer += Time.deltaTime;
			}
			else
			{
				touchSwimTimer = 0f;
			}
			if (!ui.isSwitchedOn() && !ui.isShowingSomething() && touchSwimTimer > singleClickTime)
			{
				swimController.TouchpadSwim();
			}
		}
		UpdateTouchpad();
		systemTimer += Time.deltaTime;
	}

	private void DropObjectIntoWater()
	{
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Dolphins" || UnityEngine.Application.loadedLevelName == "OceanRift_SeaLions")
		{
			ui.DropRingIntoWater();
		}
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Orcas")
		{
			ui.DropOrcaFoodIntoWater();
		}
	}

	private void preprocessDownSwipe()
	{
		if (!ui.isShowingSomething())
		{
			if (touchTimer < 0.25f)
			{
				if (!ui.switchOffInfoSpheres())
				{
					DropObjectIntoWater();
				}
			}
			else
			{
				swimController.TouchpadSwimDown();
			}
		}
		else
		{
			ui.processDownSwipe();
		}
	}

	private void UpdateTouchpad()
	{
		if (OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad) && !LAC_GearVRRemote.instance.isControllerConnected() && touchTimer < singleClickTime)
		{
			ui.processSingleTap();
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadLeft, OVRInput.Controller.Touchpad) || OVRInput.GetDown(OVRInput.Button.DpadLeft, OVRInput.Controller.RTrackedRemote) || OVRInput.GetDown(OVRInput.Button.DpadLeft, OVRInput.Controller.LTrackedRemote))
		{
			if (ui.isSwichedOn())
			{
				ui.swipeIconsRight();
			}
			else
			{
				ui.processRightSwipe();
			}
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadRight, OVRInput.Controller.Touchpad) || OVRInput.GetDown(OVRInput.Button.DpadRight, OVRInput.Controller.RTrackedRemote) || OVRInput.GetDown(OVRInput.Button.DpadRight, OVRInput.Controller.LTrackedRemote))
		{
			if (ui.isSwichedOn())
			{
				ui.swipeIconsLeft();
			}
			else
			{
				ui.processLeftSwipe();
			}
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadUp, OVRInput.Controller.Touchpad) || OVRInput.GetDown(OVRInput.Button.DpadUp, OVRInput.Controller.RTrackedRemote) || OVRInput.GetDown(OVRInput.Button.DpadUp, OVRInput.Controller.LTrackedRemote))
		{
			ui.processUpSwipe();
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadDown, OVRInput.Controller.Touchpad) || OVRInput.GetDown(OVRInput.Button.DpadDown, OVRInput.Controller.RTrackedRemote) || OVRInput.GetDown(OVRInput.Button.DpadDown, OVRInput.Controller.LTrackedRemote))
		{
			preprocessDownSwipe();
		}
	}

	public void incrementControlsMode()
	{
		currControlModeIndex++;
		if (currControlModeIndex >= enumCount)
		{
			currControlModeIndex = 0;
		}
		controlMode = (GearVRControlsMode)currControlModeIndex;
	}

	private void TouchDown()
	{
		touchTimer = systemTimer;
		touchpadDown = true;
	}

	private void TouchUp()
	{
		touchTimer = systemTimer - touchTimer;
		touchpadDown = false;
	}

	public string getControlModeString()
	{
		if (controlMode == GearVRControlsMode.Swipe)
		{
			return "Swipe";
		}
		if (controlMode == GearVRControlsMode.Click)
		{
			return "Click";
		}
		return "blank";
	}
}
public class ArmatureRotator : MonoBehaviour
{
	public float trackingSpeed = 5f;

	private Camera camera;

	public AnimationCurve headtrackCurve;

	private Vector3 camForward;

	private void Start()
	{
		camera = LAC_VRCameraRig.instance.getCenterCamera();
	}

	private void Update()
	{
		camForward = camera.transform.forward;
		float y = Mathf.LerpAngle(base.transform.eulerAngles.y, camera.transform.eulerAngles.y, Time.deltaTime * trackingSpeed);
		base.transform.position = camera.transform.position;
		base.transform.eulerAngles = new Vector3(0f, y, 0f);
	}
}
public class GearVRLaserPointer : MonoBehaviour
{
	public Color laserColor;

	public GameObject debugDrawTo;

	private Camera camera;

	private LineRenderer lineRenderer;

	public LayerMask layerMask;

	private Quaternion controllerRotation;

	private void Awake()
	{
		lineRenderer = base.gameObject.GetComponent<LineRenderer>();
		camera = LAC_VRCameraRig.instance.getCenterCamera();
	}

	private void Start()
	{
		base.transform.localPosition += new Vector3(0f, 0f, 0.1f);
	}

	private void LateUpdate()
	{
		controllerRotation = LAC_GearVRRemote.instance.getRotation();
		base.transform.parent.rotation = controllerRotation;
		DebugDrawLine();
	}

	private void DebugDrawLine()
	{
		lineRenderer.SetPosition(0, base.transform.position);
		lineRenderer.SetPosition(1, base.transform.position + base.transform.forward * 0.7f);
		lineRenderer.SetColors(laserColor, Color.clear);
	}

	private void UpdateReticle()
	{
	}
}
public class LAC_GearVRRemote : MonoBehaviour
{
	private enum Hand
	{
		Left,
		Right
	}

	private Hand handed = Hand.Right;

	public static LAC_GearVRRemote instance;

	private bool m_prevControllerConnected;

	private bool m_prevControllerConnectedCached;

	private Vector3 controllerPosition = Vector3.zero;

	private Quaternion controllerRotation = Quaternion.identity;

	private Vector3 handedMultiplier;

	private bool controllerConnected;

	private Transform wrist;

	private Vector3 leftWristLocalPos;

	private Vector3 rightWristLocalPos;

	public Transform model;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		wrist = base.transform.GetChild(0);
		rightWristLocalPos = wrist.localPosition;
		Vector3 localPosition = wrist.localPosition;
		localPosition.x *= -1f;
		leftWristLocalPos = localPosition;
	}

	public bool isControllerConnected()
	{
		return controllerConnected;
	}

	private void Start()
	{
	}

	public Vector3 getPosition()
	{
		return controllerPosition;
	}

	public Quaternion getRotation()
	{
		return controllerRotation;
	}

	private void UpdateHandedness()
	{
		if (OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote))
		{
			handed = Hand.Left;
		}
		else
		{
			handed = Hand.Right;
		}
		if (handed == Hand.Right)
		{
			wrist.localPosition = rightWristLocalPos;
		}
		if (handed == Hand.Left)
		{
			wrist.localPosition = leftWristLocalPos;
		}
	}

	private void Update()
	{
		controllerConnected = OVRInput.GetActiveController() == OVRInput.Controller.LTrackedRemote || OVRInput.GetActiveController() == OVRInput.Controller.RTrackedRemote;
		if (controllerConnected != m_prevControllerConnected || !m_prevControllerConnectedCached)
		{
			m_prevControllerConnected = controllerConnected;
			m_prevControllerConnectedCached = true;
		}
		if (controllerConnected)
		{
			if (controllerConnected)
			{
				controllerPosition = OVRInput.GetLocalControllerPosition(OVRInput.GetActiveController());
				controllerRotation = OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController());
			}
			else
			{
				controllerPosition = Vector3.zero;
				controllerRotation = Quaternion.identity;
			}
			UpdateHandedness();
			Vector3 eulerAngles = model.eulerAngles;
			eulerAngles.z = getRotation().eulerAngles.z;
			model.eulerAngles = eulerAngles;
		}
	}
}
public class LAC_HMDInfo : MonoBehaviour
{
	public enum HMDType
	{
		GearVR,
		Daydream
	}

	private HMDType hmd;

	public static LAC_HMDInfo instance;

	private static float drawDistanceMultiplier = 1f;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		InitializeHMDSettings();
	}

	public static float getDrawDistanceMultiplier()
	{
		return drawDistanceMultiplier;
	}

	public void InitializeHMDSettings()
	{
		Debug.Log("Initializing HMD Settings");
		Time.fixedDeltaTime = 1f / 72f;
		Time.maximumDeltaTime = 1f / 72f;
		Time.maximumParticleDeltaTime = 1f / 72f;
		QualitySettings.antiAliasing = 4;
	}

	public void setHMD(HMDType h)
	{
		hmd = h;
	}

	public HMDType getHMDType()
	{
		return hmd;
	}

	private IEnumerator HighFrameRateSwapper_72()
	{
		while (true)
		{
			yield return new WaitForSeconds(3f);
			OVRManager.display.displayFrequency = 72f;
			GetComponent<AudioSource>().Play();
			yield return new WaitForSeconds(3f);
			OVRManager.display.displayFrequency = 60f;
			GetComponent<AudioSource>().Play();
		}
	}

	private IEnumerator FoveatedRenderingSwapper()
	{
		OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSHigh;
		while (true)
		{
			yield return new WaitForSeconds(5f);
			XRSettings.eyeTextureResolutionScale = 1f;
			yield return new WaitForSeconds(5f);
			XRSettings.eyeTextureResolutionScale = 1.4f;
		}
	}
}
public class LAC_VRCameraRig : MonoBehaviour
{
	public static LAC_VRCameraRig instance;

	private GameObject leftEye;

	private GameObject rightEye;

	private GameObject centerEye;

	private GameObject cameraObject;

	private GameObject trackingObject;

	private Camera centerCamera;

	private Camera leftCamera;

	private Camera rightCamera;

	private Camera controlCamera;

	[Header("Global Settings")]
	public Vector3 cameraScale = new Vector3(1f, 1f, 1f);

	public bool usePositionTracking = true;

	public CameraClearFlags clearFlags;

	public LayerMask cullingMask;

	public float nearClippingPlane = 0.01f;

	public float farClippingPlane = 1500f;

	public Color backgroundColor;

	public bool occlusionCulling = true;

	[Header("Calibration Settings")]
	public bool isStandingExperience;

	public float uncalibratedPlayerHight = 1.75f;

	[SerializeField]
	private bool recenterOnLoad;

	[Header("Camera Prefabs")]
	public GameObject OculusCamera;

	public GameObject OculusCameraWithHands;

	public GameObject fadeQuadPrefab;

	public GameObject bubbleGeneratorPrefab;

	public GameObject gearVRArmature;

	public GameObject daydreamArmature;

	private GameObject bubbleGenerator;

	private FadeQuad fadeQuad;

	private void Awake()
	{
		instance = this;
		GameObject obj = GameObject.Find("Camera");
		UnityEngine.Object.Destroy(obj);
		ChooseCamera();
		cameraObject.transform.parent = base.transform;
		cameraObject.transform.localPosition = new Vector3(0f, 0.8f, 0f);
		cameraObject.transform.localRotation = Quaternion.identity;
		cameraObject.transform.localScale = cameraScale;
		centerCamera = centerEye.GetComponent<Camera>();
		centerCamera.clearFlags = clearFlags;
		centerCamera.cullingMask = cullingMask;
		centerCamera.nearClipPlane = nearClippingPlane;
		centerCamera.farClipPlane = farClippingPlane;
		centerCamera.backgroundColor = backgroundColor;
		centerCamera.useOcclusionCulling = occlusionCulling;
		centerCamera.clearFlags = CameraClearFlags.Color;
		GameObject gameObject = new GameObject("Dummy Camera");
		gameObject.transform.parent = base.transform;
		if (recenterOnLoad)
		{
			CalibrateCameraPosition();
		}
		fadeQuad = UnityEngine.Object.Instantiate(fadeQuadPrefab, centerCamera.transform.position + centerCamera.transform.forward * (centerCamera.nearClipPlane + 0.01f), Quaternion.identity).GetComponent<FadeQuad>();
		fadeQuad.transform.parent = centerCamera.transform;
		fadeQuad.FadeIn();
		bubbleGenerator = UnityEngine.Object.Instantiate(bubbleGeneratorPrefab, base.transform.position, Quaternion.identity);
		bubbleGenerator.transform.parent = centerCamera.transform;
		bubbleGenerator.transform.rotation = centerCamera.transform.rotation;
		bubbleGenerator.transform.position = centerCamera.transform.position;
		bubbleGenerator.transform.localPosition += new Vector3(0f, -0.29f, 0.234f);
	}

	private void OnApplicationPause(bool isPaused)
	{
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void FadeIn()
	{
		fadeQuad.FadeIn();
	}

	public void FadeOut()
	{
		fadeQuad.FadeOut();
	}

	public void Blackout()
	{
		fadeQuad.Blackout();
	}

	private void ChooseCamera()
	{
		Debug.Log("Initializing Cameras...");
		Debug.Log("Creating Oculus VR Camera...");
		cameraObject = UnityEngine.Object.Instantiate(OculusCameraWithHands, base.transform.position, Quaternion.identity);
		OculusCamera.gameObject.GetComponent<OVRManager>().usePositionTracking = usePositionTracking;
		trackingObject = cameraObject.transform.Find("TrackingSpace").gameObject;
		leftEye = trackingObject.transform.Find("LeftEyeAnchor").gameObject;
		centerEye = trackingObject.transform.Find("CenterEyeAnchor").gameObject;
		rightEye = trackingObject.transform.Find("RightEyeAnchor").gameObject;
		leftCamera = leftEye.GetComponent<Camera>();
		rightCamera = rightEye.GetComponent<Camera>();
		InitCameraSettings();
		if (isStandingExperience)
		{
			base.transform.position += new Vector3(0f, uncalibratedPlayerHight, 0f);
		}
	}

	public Camera getCenterCamera()
	{
		return centerCamera;
	}

	public void setBackgroundColor(Color col)
	{
		leftCamera.backgroundColor = col;
		centerCamera.backgroundColor = col;
		rightCamera.backgroundColor = col;
	}

	public void setNearClip(float val)
	{
		leftCamera.nearClipPlane = val;
		centerCamera.nearClipPlane = val;
		rightCamera.nearClipPlane = val;
		Vector3 localPosition = fadeQuad.transform.localPosition;
		localPosition.z = val + 0.05f;
		fadeQuad.transform.localPosition = localPosition;
	}

	public void setFarClip(float val)
	{
		leftCamera.farClipPlane = val;
		centerCamera.farClipPlane = val;
		rightCamera.farClipPlane = val;
	}

	public void setSpecialCull(float[] distances)
	{
		leftCamera.layerCullDistances = distances;
		centerCamera.layerCullDistances = distances;
		rightCamera.layerCullDistances = distances;
	}

	private void InitCameraSettings()
	{
		leftCamera.clearFlags = clearFlags;
		leftCamera.nearClipPlane = nearClippingPlane;
		leftCamera.farClipPlane = farClippingPlane;
		leftCamera.backgroundColor = backgroundColor;
		leftCamera.useOcclusionCulling = occlusionCulling;
		leftCamera.clearFlags = CameraClearFlags.Color;
		rightCamera.clearFlags = CameraClearFlags.Color;
		rightCamera.nearClipPlane = nearClippingPlane;
		rightCamera.farClipPlane = farClippingPlane;
		rightCamera.backgroundColor = backgroundColor;
		rightCamera.useOcclusionCulling = occlusionCulling;
	}

	private IEnumerator SyncCameraSettings()
	{
		yield return new WaitForEndOfFrame();
		rightCamera.clearFlags = leftCamera.clearFlags;
		rightCamera.nearClipPlane = leftCamera.nearClipPlane;
		rightCamera.farClipPlane = leftCamera.farClipPlane;
		rightCamera.backgroundColor = leftCamera.backgroundColor;
		rightCamera.useOcclusionCulling = leftCamera.useOcclusionCulling;
	}

	public static void Flash(Color colour, float duration = 1f)
	{
	}

	public void CalibrateCameraPosition()
	{
		Debug.Log("Recentering Camera Position...");
		OVRManager.display.RecenterPose();
	}
}
public class LAC_VRInputWrapper : MonoBehaviour
{
	public delegate void OnTouchDownEvent();

	public delegate void OnTouchUpEvent();

	public delegate void OnClickButtonDownEvent();

	public delegate void OnClickButtonUpEvent();

	public delegate void OnAppButtonDownEvent();

	public delegate void OnAppButtonUpEvent();

	public delegate void OnAppButtonLongPressEvent();

	public delegate void OnAppButtonShortPressEvent();

	public delegate void OnSwipeLeftEvent();

	public delegate void OnSwipeRightEvent();

	public delegate void OnSwipeDownEvent();

	public delegate void OnSwipeUpEvent();

	public static LAC_VRInputWrapper instance;

	public bool RemoteAiming;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private OnClickButtonDownEvent m_OnClickDown;

	[CompilerGenerated]
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private OnClickButtonUpEvent m_OnClickUp;

	private Quaternion RemoteRotation;

	private bool clickButtonDown;

	private bool clickButtonUp;

	public event OnClickButtonDownEvent OnClickDown
	{
		add
		{
			OnClickButtonDownEvent onClickButtonDownEvent = this.m_OnClickDown;
			OnClickButtonDownEvent onClickButtonDownEvent2;
			do
			{
				onClickButtonDownEvent2 = onClickButtonDownEvent;
				onClickButtonDownEvent = Interlocked.CompareExchange(ref this.m_OnClickDown, (OnClickButtonDownEvent)Delegate.Combine(onClickButtonDownEvent2, value), onClickButtonDownEvent);
			}
			while (onClickButtonDownEvent != onClickButtonDownEvent2);
		}
		remove
		{
			OnClickButtonDownEvent onClickButtonDownEvent = this.m_OnClickDown;
			OnClickButtonDownEvent onClickButtonDownEvent2;
			do
			{
				onClickButtonDownEvent2 = onClickButtonDownEvent;
				onClickButtonDownEvent = Interlocked.CompareExchange(ref this.m_OnClickDown, (OnClickButtonDownEvent)Delegate.Remove(onClickButtonDownEvent2, value), onClickButtonDownEvent);
			}
			while (onClickButtonDownEvent != onClickButtonDownEvent2);
		}
	}

	public event OnClickButtonUpEvent OnClickUp
	{
		add
		{
			OnClickButtonUpEvent onClickButtonUpEvent = this.m_OnClickUp;
			OnClickButtonUpEvent onClickButtonUpEvent2;
			do
			{
				onClickButtonUpEvent2 = onClickButtonUpEvent;
				onClickButtonUpEvent = Interlocked.CompareExchange(ref this.m_OnClickUp, (OnClickButtonUpEvent)Delegate.Combine(onClickButtonUpEvent2, value), onClickButtonUpEvent);
			}
			while (onClickButtonUpEvent != onClickButtonUpEvent2);
		}
		remove
		{
			OnClickButtonUpEvent onClickButtonUpEvent = this.m_OnClickUp;
			OnClickButtonUpEvent onClickButtonUpEvent2;
			do
			{
				onClickButtonUpEvent2 = onClickButtonUpEvent;
				onClickButtonUpEvent = Interlocked.CompareExchange(ref this.m_OnClickUp, (OnClickButtonUpEvent)Delegate.Remove(onClickButtonUpEvent2, value), onClickButtonUpEvent);
			}
			while (onClickButtonUpEvent != onClickButtonUpEvent2);
		}
	}

	private void Awake()
	{
		instance = this;
		UnityEngine.Object.DontDestroyOnLoad(this);
	}

	public Quaternion getRemoteRotation()
	{
		return RemoteRotation;
	}

	private void Update()
	{
	}
}
public class CSVReader
{
	private static string SPLIT_RE = ",(?=(?:[^\"]*\"[^\"]*\")*(?![^\"]*\"))";

	private static string LINE_SPLIT_RE = "\\r\\n|\\n\\r|\\n|\\r";

	private static char[] TRIM_CHARS = new char[1] { '"' };

	public static CSVObject Read(string content)
	{
		List<Dictionary<string, object>> list = new List<Dictionary<string, object>>();
		CSVObject cSVObject = new CSVObject();
		string[] array = Regex.Split(content, LINE_SPLIT_RE);
		if (array.Length <= 1)
		{
			cSVObject.SetDictionary(list);
			return cSVObject;
		}
		string[] array2 = Regex.Split(array[0], SPLIT_RE);
		for (int i = 1; i < array.Length; i++)
		{
			string[] array3 = Regex.Split(array[i], SPLIT_RE);
			if (array3.Length == 0 || array3[0] == string.Empty)
			{
				continue;
			}
			Dictionary<string, object> dictionary = new Dictionary<string, object>();
			for (int j = 0; j < array2.Length && j < array3.Length; j++)
			{
				string text = array3[j];
				text = text.TrimStart(TRIM_CHARS).TrimEnd(TRIM_CHARS).Replace("\\", string.Empty);
				object value = text;
				float result2;
				if (int.TryParse(text, out var result))
				{
					value = result;
				}
				else if (float.TryParse(text, out result2))
				{
					value = result2;
				}
				dictionary[array2[j]] = value;
			}
			list.Add(dictionary);
		}
		cSVObject.SetDictionary(list);
		return cSVObject;
	}
}
public class CSVObject
{
	private List<Dictionary<string, object>> dict;

	public void SetDictionary(List<Dictionary<string, object>> dict)
	{
		this.dict = dict;
	}

	public Dictionary<string, object> GetDataByCode(string code)
	{
		for (int i = 0; i < dict.Count; i++)
		{
			if (dict[i]["CODE"].Equals(code))
			{
				return dict[i];
			}
		}
		return null;
	}

	public void Test()
	{
	}
}
public class LocalisationData
{
	private CSVObject csv;

	public LocalisationData()
	{
		Init();
	}

	private void Init()
	{
		csv = CSVReader.Read(Resources.Load<TextAsset>("Localisation/OceanRift").text);
	}

	public string GetValueByCode(string code, string columnName)
	{
		Dictionary<string, object> dataByCode = csv.GetDataByCode(code);
		if (dataByCode != null && dataByCode[columnName] != null)
		{
			return dataByCode[columnName].ToString();
		}
		Debug.LogWarning("There is localization error. CODE :" + code);
		return "error";
	}
}
public class LocalisationManager : MonoBehaviour
{
	public enum Language
	{
		English,
		French,
		German,
		Spanish,
		Korean,
		Japanese,
		Cymraeg
	}

	public Language selectedLanguage;

	public static LocalisationManager instance;

	private LocalisationData data;

	public Texture2D[] flags;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		if (PlayerPrefs.HasKey("Language"))
		{
			selectedLanguage = (Language)PlayerPrefs.GetInt("Language");
			return;
		}
		PlayerPrefs.SetInt("Language", 0);
		selectedLanguage = Language.English;
		if (UnityEngine.Application.systemLanguage == SystemLanguage.French)
		{
			PlayerPrefs.SetInt("Language", 1);
			selectedLanguage = Language.French;
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.German)
		{
			PlayerPrefs.SetInt("Language", 2);
			selectedLanguage = Language.German;
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.Spanish)
		{
			PlayerPrefs.SetInt("Language", 3);
			selectedLanguage = Language.Spanish;
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.Korean)
		{
			PlayerPrefs.SetInt("Language", 4);
			selectedLanguage = Language.Korean;
		}
		if (UnityEngine.Application.systemLanguage == SystemLanguage.Japanese)
		{
			PlayerPrefs.SetInt("Language", 5);
			selectedLanguage = Language.Japanese;
		}
	}

	private static string GetLocaleCode()
	{
		string text = "en";
		using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("java.util.Locale"))
		{
			if (androidJavaClass != null)
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.CallStatic<AndroidJavaObject>("getDefault", new object[0]);
				if (androidJavaObject != null)
				{
					text = androidJavaObject.Call<string>("getLanguage", new object[0]);
					Debug.Log("Android lang: " + text);
				}
				else
				{
					Debug.Log("locale null");
				}
			}
			else
			{
				Debug.Log("cls null");
			}
		}
		Debug.Log("Locale: " + text);
		return text;
	}

	private void Start()
	{
		data = new LocalisationData();
	}

	public int getNumberOfLanguages()
	{
		return 6;
	}

	public string getText(string id)
	{
		return data.GetValueByCode(id, selectedLanguage.ToString());
	}

	public void nextLanguage()
	{
		selectedLanguage++;
		if ((int)selectedLanguage >= getNumberOfLanguages())
		{
			selectedLanguage = Language.English;
		}
		PlayerPrefs.SetInt("Language", (int)selectedLanguage);
	}

	public void OnDestroy()
	{
		PlayerPrefs.SetInt("Language", (int)selectedLanguage);
	}

	public Texture2D getFlag()
	{
		return flags[(int)selectedLanguage];
	}
}
public class HideWithDistance : MonoBehaviour
{
	public Renderer[] renderers;

	public Transform origin;

	public float hideDistance = 8f;

	private bool hidden;

	private Transform camera;

	private void Start()
	{
		camera = LAC_VRCameraRig.instance.getCenterCamera().transform;
	}

	private void Update()
	{
		float magnitude = (camera.position - origin.position).magnitude;
		if (magnitude > hideDistance)
		{
			if (!hidden)
			{
				hidden = true;
				HideRenderers();
			}
		}
		else if (hidden)
		{
			hidden = false;
			ShowRenderers();
		}
	}

	private void HideRenderers()
	{
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			renderer.enabled = false;
		}
	}

	private void ShowRenderers()
	{
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			renderer.enabled = true;
		}
	}
}
public class InfoQuad : MonoBehaviour
{
	public AnimationCurve fadeCurve;

	private float flashTimer;

	private Color textColour;

	private float baseAlpha;

	private TouchUI ui;

	private Transform camera;

	public Texture gearVRTexture;

	public Texture gearVRTexture_Chinese;

	public Texture daydreamTexture;

	public Texture santaCruzTexture;

	private float fadeRate = 0.055f;

	private Material material;

	[Space(10f)]
	public Texture questMessage_English;

	public Texture questMessage_French;

	public Texture questMessage_German;

	public Texture questMessage_Spanish;

	public Texture questMessage_Korean;

	public Texture questMessage_Japanese;

	public Texture questMessage_Cymraeg;

	private void Awake()
	{
		material = base.transform.GetComponent<Renderer>().material;
		UpdateTexture();
	}

	private void Start()
	{
		camera = LAC_VRCameraRig.instance.getCenterCamera().transform;
		ui = TouchUI.instance;
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Dolphins")
		{
			if (ui.dolphinMessageShown)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				ui.dolphinMessageShown = true;
			}
		}
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Orcas")
		{
			if (ui.orcaMessageShown)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				ui.orcaMessageShown = true;
			}
		}
		if (UnityEngine.Application.loadedLevelName == "OceanRift_SeaLions")
		{
			if (ui.sealionMessageShown)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				ui.sealionMessageShown = true;
			}
		}
		textColour = base.transform.GetComponent<Renderer>().material.GetColor("_TintColor");
		baseAlpha = textColour.a;
		Vector3 forward = camera.forward;
		forward.y = 0f;
		forward.Normalize();
		base.transform.position = camera.position + forward * 1.7f - new Vector3(0f, 0.25f, 0f);
		base.transform.LookAt(camera);
		base.transform.rotation *= Quaternion.Euler(0f, 180f, 0f);
	}

	private void Update()
	{
		textColour.a = baseAlpha * fadeCurve.Evaluate(flashTimer * fadeRate);
		base.transform.GetComponent<Renderer>().material.SetColor("_TintColor", textColour);
		flashTimer += Time.deltaTime;
		if (flashTimer * fadeRate > 1f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void OnEnable()
	{
		UpdateTexture();
	}

	private void UpdateTexture()
	{
		switch (LocalisationManager.instance.selectedLanguage)
		{
		case LocalisationManager.Language.English:
			material.mainTexture = questMessage_English;
			break;
		case LocalisationManager.Language.French:
			material.mainTexture = questMessage_French;
			break;
		case LocalisationManager.Language.German:
			material.mainTexture = questMessage_German;
			break;
		case LocalisationManager.Language.Spanish:
			material.mainTexture = questMessage_Spanish;
			break;
		case LocalisationManager.Language.Korean:
			material.mainTexture = questMessage_Korean;
			break;
		case LocalisationManager.Language.Japanese:
			material.mainTexture = questMessage_Japanese;
			break;
		case LocalisationManager.Language.Cymraeg:
			material.mainTexture = questMessage_Cymraeg;
			break;
		}
	}
}
public class InfoSphere : MonoBehaviour
{
	private Transform player;

	private Transform sphere;

	private Transform holoPanel;

	private float activateDistance = 1.75f;

	private float textDistance = 2.75f;

	private bool switchedOn;

	private bool switching;

	private float defaultSphereScale;

	private Vector3 targetSphereScale;

	private Transform holoPanelBackground;

	private Transform holoPanelForeground;

	private Vector3 defaultHoloPanelScale;

	private Vector3 inactiveHoloPanelScale;

	private float targetSphereAlpha;

	private float targetGlowAlpha;

	private float targetIconAlpha;

	private float targetHoloPanelBackgroundAlpha;

	private float targetHoloPanelForegroundAlpha;

	private Color defaultSphereColor;

	private Color defaultGlowColor;

	private Color defaultIconColor;

	private Material iconMaterial;

	private Material sphereMaterial;

	private Material glowMaterial;

	private Material holoPanelBackgroundMaterial;

	private Material holoPanelForegroundMaterial;

	private Color holoPanelBackgroundDefaultColor;

	private Color holoPanelForegroundDefaultColor;

	public Texture iconTexture;

	public Texture infoTexture;

	private float holoPanelDistance = 1.75f;

	private string text;

	private TextMesh textMesh;

	private Material textMaterial;

	private OVRSwimController playerController;

	private TouchUI ui;

	private bool okToShowHoloPanel;

	private AudioSource audio;

	private bool hasPlayedNarration;

	private float textAlpha;

	public AudioClip narration;

	public AudioClip activateSound;

	public bool audioRangeBoost;

	private Vector3 defaultHoloPanelLocalPosition;

	public string[] scannerSearchTerms;

	public string idName;

	public string animalName;

	public string latinName;

	public string scannerTrackableName;

	public bool hideDetailsFromScanner;

	private Vector3 playerForwardSnapshot;

	private float holoPanelRightOffset = 0.15f;

	private float updateStep = 0.02f;

	private int sampleDataLength = 16;

	private float clipLoudness;

	private float[] clipSampleData;

	private Material material;

	private float targetPulseAlpha;

	private float weight = 10f;

	private Vector2 pulseAlphaRange = new Vector2(0.08f, 0.3f);

	private float pulseUpdateTimer;

	private Color iconPulseColor;

	private float playerThrottle;

	private float distanceToPlayer;

	private float prevPlayerThrottle;

	private float playerAcceleration;

	private float scaleMagnifier = 1.5f;

	private float alphaFadeSpeed = 5f;

	private float holoPanelFadeSpeed = 3f;

	private void Start()
	{
		player = LAC_VRCameraRig.instance.getCenterCamera().transform;
		ui = TouchUI.instance;
		playerController = player.root.GetComponent<OVRSwimController>();
		audio = GetComponent<AudioSource>();
		if ((bool)narration)
		{
			audio.clip = narration;
		}
		sphere = base.transform.Find("Sphere");
		holoPanel = base.transform.Find("Holo Panel");
		holoPanel.gameObject.SetActive(value: false);
		textMesh = sphere.Find("Description").GetComponent<TextMesh>();
		textMesh.text = text;
		textMaterial = textMesh.GetComponent<Renderer>().material;
		textMaterial.SetColor("_Color", new Color(1f, 1f, 1f, 0f));
		sphereMaterial = sphere.GetComponent<Renderer>().material;
		iconMaterial = sphere.Find("Icon").GetComponent<Renderer>().material;
		glowMaterial = sphere.Find("Glow").GetComponent<Renderer>().material;
		iconMaterial.mainTexture = iconTexture;
		holoPanelForeground = holoPanel.Find("Foreground");
		holoPanelBackground = holoPanel.Find("Background");
		defaultHoloPanelScale = holoPanelForeground.localScale;
		inactiveHoloPanelScale = new Vector3(defaultHoloPanelScale.x / 2f, defaultHoloPanelScale.y / 2f, defaultHoloPanelScale.z);
		holoPanelForeground.localScale = inactiveHoloPanelScale;
		holoPanelBackground.localScale = inactiveHoloPanelScale;
		holoPanelBackgroundMaterial = holoPanel.Find("Background").GetComponent<Renderer>().material;
		holoPanelForegroundMaterial = holoPanel.Find("Foreground").GetComponent<Renderer>().material;
		defaultSphereColor = sphereMaterial.GetColor("_Color");
		defaultGlowColor = glowMaterial.GetColor("_TintColor");
		defaultGlowColor = RenderSettings.fogColor * 0.4f;
		defaultIconColor = iconMaterial.GetColor("_TintColor");
		holoPanelForegroundDefaultColor = holoPanelForegroundMaterial.GetColor("_TintColor");
		holoPanelBackgroundDefaultColor = holoPanelBackgroundMaterial.GetColor("_TintColor");
		defaultSphereScale = sphere.transform.localScale.x;
		targetSphereScale = sphere.transform.localScale;
		targetSphereAlpha = defaultSphereColor.a;
		targetIconAlpha = defaultIconColor.a;
		targetGlowAlpha = defaultGlowColor.a;
		holoPanelBackgroundMaterial.SetColor("_TintColor", new Color(holoPanelBackgroundDefaultColor.r, holoPanelBackgroundDefaultColor.g, holoPanelBackgroundDefaultColor.b, 0f));
		holoPanelForegroundMaterial.SetColor("_TintColor", new Color(holoPanelForegroundDefaultColor.r, holoPanelForegroundDefaultColor.g, holoPanelForegroundDefaultColor.b, 0f));
		holoPanelForegroundMaterial.mainTexture = infoTexture;
		StartCoroutine(TrackPlayerAcceleration());
		clipSampleData = new float[sampleDataLength];
		if (audioRangeBoost)
		{
			audio.minDistance *= 2f;
			audio.maxDistance *= 3f;
		}
		holoPanel.gameObject.SetActive(value: false);
		defaultHoloPanelLocalPosition = holoPanel.localPosition;
	}

	private void Hide()
	{
		sphere.gameObject.SetActive(value: false);
		holoPanel.gameObject.SetActive(value: false);
		audio.Stop();
	}

	private void Show()
	{
		sphere.gameObject.SetActive(value: true);
		if (ui.getEducationLayerType() >= 2)
		{
			holoPanel.gameObject.SetActive(value: true);
		}
		else
		{
			holoPanel.gameObject.SetActive(value: false);
		}
	}

	public void sayHello()
	{
		MonoBehaviour.print("Hello from Info Sphere!");
	}

	private void RotateHoloPanelToPlayer()
	{
		holoPanel.LookAt(player.position, Vector3.up);
		Vector3 eulerAngles = base.transform.eulerAngles;
		eulerAngles.x = 0f;
		base.transform.eulerAngles = eulerAngles;
	}

	private void StopAllInfoSphereAudio()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("Info Sphere");
		GameObject[] array2 = array;
		foreach (GameObject gameObject in array2)
		{
			AudioSource component = gameObject.transform.root.GetComponent<AudioSource>();
			component.Stop();
		}
	}

	private Vector3 getIdealHolopanelPos()
	{
		Vector3 position = player.position;
		Vector3 vector = playerForwardSnapshot;
		Vector3 vector2 = Vector3.Cross(playerForwardSnapshot, Vector3.up);
		vector.y = 0f;
		vector.Normalize();
		Vector3 vector3 = -vector2 * 0.07f;
		return position + vector3 + vector * holoPanelDistance - new Vector3(0f, 0.2f, 0f);
	}

	private void UpdateHoloPanelDistanceFromPlayer()
	{
		Vector3 position = player.position;
		float num = 1f;
		holoPanel.position = Vector3.Lerp(holoPanel.position, getIdealHolopanelPos(), num * Time.deltaTime);
	}

	private void UpdateSpherePulse()
	{
		pulseUpdateTimer += Time.deltaTime;
		if (pulseUpdateTimer >= updateStep)
		{
			pulseUpdateTimer = 0f;
			audio.clip.GetData(clipSampleData, audio.timeSamples);
			clipLoudness = 0f;
			float[] array = clipSampleData;
			foreach (float f in array)
			{
				clipLoudness += Mathf.Abs(f);
			}
			clipLoudness /= sampleDataLength;
		}
		float b = Mathf.Clamp(clipLoudness * weight, pulseAlphaRange.x, pulseAlphaRange.y);
		targetPulseAlpha = Mathf.Lerp(targetPulseAlpha, b, Time.deltaTime * 10f);
	}

	public bool isSwitchedOn()
	{
		return switchedOn;
	}

	public void downSwipeOff()
	{
		if (switchedOn && !switching)
		{
			StartCoroutine(SwitchOff());
		}
	}

	private IEnumerator TrackPlayerAcceleration()
	{
		while (true)
		{
			playerAcceleration = playerThrottle - prevPlayerThrottle;
			prevPlayerThrottle = playerThrottle;
			yield return new WaitForSeconds(0.25f);
		}
	}

	public void Silence()
	{
		audio.Stop();
	}

	private void UpdateNormal()
	{
		distanceToPlayer = (player.position - base.transform.position).magnitude;
		if (ui.isShowingSomething())
		{
			Hide();
		}
		else if (!ui.isEducationLayerActive())
		{
			Hide();
		}
		else
		{
			Show();
		}
		if (!(distanceToPlayer < 20f) || !ui.isEducationLayerActive())
		{
			return;
		}
		if ((bool)narration && audio.isPlaying)
		{
			UpdateSpherePulse();
		}
		playerThrottle = playerController.MoveThrottle.magnitude;
		sphere.transform.LookAt(player.position, Vector3.up);
		if (!ui.isShowingSomething())
		{
			if (distanceToPlayer > activateDistance || playerThrottle > 0.6f)
			{
				if (switchedOn && !switching)
				{
					StartCoroutine(SwitchOff());
				}
			}
			else if (distanceToPlayer < activateDistance && playerThrottle < 0.75f && !switchedOn && !switching && okToShowHoloPanel)
			{
				StartCoroutine(SwitchOn());
			}
		}
		else if (switchedOn && !switching)
		{
			StartCoroutine(SwitchOff());
		}
		if (distanceToPlayer < activateDistance)
		{
			if (playerAcceleration < -0.05f)
			{
				playerController.MoveThrottle *= 0.975f;
			}
			targetSphereScale = new Vector3(defaultSphereScale * scaleMagnifier, defaultSphereScale * scaleMagnifier, defaultSphereScale * scaleMagnifier);
			targetSphereAlpha = Mathf.Lerp(targetSphereAlpha, 0f, Time.deltaTime * alphaFadeSpeed);
			targetIconAlpha = Mathf.Lerp(targetIconAlpha, 0f, Time.deltaTime * alphaFadeSpeed);
		}
		else
		{
			if (audio.isPlaying && !switchedOn)
			{
				targetSphereAlpha = Mathf.Lerp(targetSphereAlpha, targetPulseAlpha, Time.deltaTime * alphaFadeSpeed);
				targetIconAlpha = Mathf.Lerp(targetIconAlpha, targetPulseAlpha, Time.deltaTime * alphaFadeSpeed);
			}
			else
			{
				targetSphereAlpha = Mathf.Lerp(targetSphereAlpha, defaultSphereColor.a, Time.deltaTime * alphaFadeSpeed);
				targetIconAlpha = Mathf.Lerp(targetIconAlpha, defaultIconColor.a, Time.deltaTime * alphaFadeSpeed);
			}
			targetSphereScale = new Vector3(defaultSphereScale, defaultSphereScale, defaultSphereScale);
			okToShowHoloPanel = true;
		}
		Color color = textMaterial.GetColor("_Color");
		color = ((!(distanceToPlayer < textDistance)) ? Color.Lerp(color, new Color(1f, 1f, 1f, 0f), Time.deltaTime * 3f) : Color.Lerp(color, new Color(1f, 1f, 1f, 1f), Time.deltaTime * 1.5f));
		textMaterial.SetColor("_Color", color);
		if (switchedOn)
		{
			targetHoloPanelForegroundAlpha = Mathf.Lerp(targetHoloPanelForegroundAlpha, holoPanelForegroundDefaultColor.a, Time.deltaTime * holoPanelFadeSpeed);
			targetHoloPanelBackgroundAlpha = Mathf.Lerp(targetHoloPanelBackgroundAlpha, holoPanelBackgroundDefaultColor.a, Time.deltaTime * holoPanelFadeSpeed);
			holoPanelForeground.localScale = Vector3.Lerp(holoPanelForeground.localScale, defaultHoloPanelScale, Time.deltaTime * 3.5f);
			holoPanelBackground.localScale = Vector3.Lerp(holoPanelBackground.localScale, defaultHoloPanelScale, Time.deltaTime * 3.5f);
		}
		else
		{
			targetHoloPanelForegroundAlpha = Mathf.Lerp(targetHoloPanelForegroundAlpha, 0f, Time.deltaTime * holoPanelFadeSpeed * 4f);
			targetHoloPanelBackgroundAlpha = Mathf.Lerp(targetHoloPanelBackgroundAlpha, 0f, Time.deltaTime * holoPanelFadeSpeed * 4f);
		}
		sphere.transform.localScale = Vector3.Lerp(sphere.transform.localScale, targetSphereScale, Time.deltaTime * 2f);
		sphereMaterial.SetColor("_Color", new Color(defaultSphereColor.r, defaultSphereColor.g, defaultSphereColor.b, targetSphereAlpha));
		iconMaterial.SetColor("_TintColor", new Color(defaultIconColor.r, defaultIconColor.g, defaultIconColor.b, targetIconAlpha));
		glowMaterial.SetColor("_TintColor", new Color(defaultGlowColor.r, defaultGlowColor.g, defaultGlowColor.b, targetSphereAlpha));
		holoPanelBackgroundMaterial.SetColor("_TintColor", new Color(holoPanelBackgroundDefaultColor.r, holoPanelBackgroundDefaultColor.g, holoPanelBackgroundDefaultColor.b, targetHoloPanelBackgroundAlpha));
		holoPanelForegroundMaterial.SetColor("_TintColor", new Color(holoPanelForegroundDefaultColor.r, holoPanelForegroundDefaultColor.g, holoPanelForegroundDefaultColor.b, targetHoloPanelForegroundAlpha));
	}

	private void UpdateTouch()
	{
		distanceToPlayer = (player.position - base.transform.position).magnitude;
		if (ui.isShowingSomething())
		{
			Hide();
		}
		else if (!ui.isEducationLayerActive() || LocalisationManager.instance.selectedLanguage != 0)
		{
			Hide();
		}
		else
		{
			Show();
		}
		if (ui.isEducationLayerActive())
		{
			if ((bool)narration && audio.isPlaying)
			{
				UpdateSpherePulse();
			}
			playerThrottle = playerController.MoveThrottle.magnitude;
			sphere.transform.LookAt(player.position, Vector3.up);
			sphere.transform.localScale = Vector3.Lerp(sphere.transform.localScale, targetSphereScale, Time.deltaTime * 2f);
			sphereMaterial.SetColor("_Color", new Color(defaultSphereColor.r, defaultSphereColor.g, defaultSphereColor.b, targetSphereAlpha));
			glowMaterial.SetColor("_TintColor", new Color(defaultGlowColor.r, defaultGlowColor.g, defaultGlowColor.b, targetGlowAlpha));
			iconMaterial.SetColor("_TintColor", new Color(defaultIconColor.r, defaultIconColor.g, defaultIconColor.b, targetIconAlpha));
			holoPanelBackgroundMaterial.SetColor("_TintColor", new Color(holoPanelBackgroundDefaultColor.r, holoPanelBackgroundDefaultColor.g, holoPanelBackgroundDefaultColor.b, targetHoloPanelBackgroundAlpha));
			holoPanelForegroundMaterial.SetColor("_TintColor", new Color(holoPanelForegroundDefaultColor.r, holoPanelForegroundDefaultColor.g, holoPanelForegroundDefaultColor.b, targetHoloPanelForegroundAlpha));
			if (playerThrottle > 0.4f && switchedOn && !switching)
			{
				StartCoroutine(SwitchOff_Touch());
			}
			if (!switching)
			{
				if (audio.isPlaying && !switchedOn)
				{
					targetIconAlpha = Mathf.Lerp(targetIconAlpha, defaultIconColor.a + targetPulseAlpha, Time.deltaTime * alphaFadeSpeed);
					targetGlowAlpha = Mathf.Lerp(targetGlowAlpha, defaultGlowColor.a + targetPulseAlpha * 0.5f, Time.deltaTime * alphaFadeSpeed);
				}
				else
				{
					targetIconAlpha = Mathf.Lerp(targetIconAlpha, defaultIconColor.a, Time.deltaTime * alphaFadeSpeed);
					targetGlowAlpha = Mathf.Lerp(targetGlowAlpha, defaultGlowColor.a, Time.deltaTime * alphaFadeSpeed);
				}
				targetSphereAlpha = Mathf.Lerp(targetSphereAlpha, defaultSphereColor.a, Time.deltaTime * alphaFadeSpeed);
			}
			if (distanceToPlayer < activateDistance && !switching && targetHoloPanelForegroundAlpha > 0f && switchedOn)
			{
				targetIconAlpha = 0f;
				targetGlowAlpha = 0f;
				targetSphereAlpha = 0f;
			}
		}
		else if (switchedOn && !switching)
		{
			StartCoroutine(SwitchOff_Touch());
		}
		if (distanceToPlayer < 1f)
		{
			if (switchedOn)
			{
				UpdateHoloPanelDistanceFromPlayer();
			}
		}
		else if (switchedOn && switchedOn && !switching)
		{
			StartCoroutine(SwitchOff_Touch());
		}
	}

	public void SwitchOnTouch()
	{
		if (!switching && !switchedOn)
		{
			StartCoroutine(SwitchOn_Touch());
		}
	}

	private IEnumerator SwitchOn_Touch()
	{
		switching = true;
		int educationType = ui.getEducationLayerType();
		if ((educationType == 1 || educationType == 3) && !hasPlayedNarration && !audio.isPlaying && narration != null)
		{
			StopAllInfoSphereAudio();
			audio.Play();
		}
		if (educationType >= 2)
		{
			audio.PlayOneShot(activateSound);
		}
		playerForwardSnapshot = (base.transform.position - player.position).normalized;
		float fadeTime = 3f;
		Vector3 idealPos = getIdealHolopanelPos();
		holoPanel.position = idealPos;
		UpdateHoloPanelDistanceFromPlayer();
		RotateHoloPanelToPlayer();
		sphere.transform.LookAt(player.position, Vector3.up);
		switchedOn = true;
		okToShowHoloPanel = false;
		holoPanel.gameObject.SetActive(value: true);
		targetSphereScale = new Vector3(defaultSphereScale * scaleMagnifier, defaultSphereScale * scaleMagnifier, defaultSphereScale * scaleMagnifier);
		for (float t = 0f; t < fadeTime; t += Time.deltaTime)
		{
			holoPanelForeground.localScale = Vector3.Lerp(holoPanelForeground.localScale, defaultHoloPanelScale, t / fadeTime);
			holoPanelBackground.localScale = Vector3.Lerp(holoPanelBackground.localScale, defaultHoloPanelScale, t / fadeTime);
			targetHoloPanelForegroundAlpha = Mathf.Lerp(targetHoloPanelForegroundAlpha, holoPanelForegroundDefaultColor.a, t / fadeTime);
			targetHoloPanelBackgroundAlpha = Mathf.Lerp(targetHoloPanelBackgroundAlpha, holoPanelBackgroundDefaultColor.a, t / fadeTime);
			targetSphereAlpha = Mathf.Lerp(targetSphereAlpha, 0f, t / fadeTime);
			targetIconAlpha = Mathf.Lerp(targetIconAlpha, 0f, t / fadeTime);
			targetGlowAlpha = Mathf.Lerp(targetGlowAlpha, 0f, t / fadeTime);
			sphere.transform.localScale = Vector3.Lerp(sphere.transform.localScale, targetSphereScale, t / fadeTime);
			yield return 1;
		}
		okToShowHoloPanel = true;
		yield return new WaitForSeconds(0.1f);
		switching = false;
	}

	private IEnumerator SwitchOff_Touch()
	{
		float fadeTime = 1f;
		switching = true;
		int educationType = ui.getEducationLayerType();
		if (educationType >= 2)
		{
			audio.PlayOneShot(activateSound);
		}
		yield return new WaitForSeconds(0.01f);
		targetSphereScale = new Vector3(defaultSphereScale, defaultSphereScale, defaultSphereScale);
		for (float t2 = 0f; t2 < fadeTime; t2 += Time.deltaTime)
		{
			targetHoloPanelForegroundAlpha = Mathf.Lerp(targetHoloPanelForegroundAlpha, 0f, t2 / fadeTime);
			targetHoloPanelBackgroundAlpha = Mathf.Lerp(targetHoloPanelBackgroundAlpha, 0f, t2 / fadeTime);
			yield return 1;
		}
		while (distanceToPlayer < activateDistance)
		{
			yield return 0;
		}
		for (float t = 0f; t < fadeTime; t += Time.deltaTime)
		{
			targetSphereAlpha = Mathf.Lerp(targetSphereAlpha, defaultSphereColor.a, t / fadeTime);
			targetIconAlpha = Mathf.Lerp(targetIconAlpha, defaultIconColor.a, t / fadeTime);
			targetGlowAlpha = Mathf.Lerp(targetGlowAlpha, defaultGlowColor.a, t / fadeTime);
			yield return 1;
		}
		targetSphereAlpha = defaultSphereColor.a;
		targetIconAlpha = defaultIconColor.a;
		holoPanelForeground.localScale = inactiveHoloPanelScale;
		holoPanelBackground.localScale = inactiveHoloPanelScale;
		holoPanel.gameObject.SetActive(value: false);
		switchedOn = false;
		switching = false;
	}

	private void Update()
	{
		UpdateTouch();
	}

	public void Toggle()
	{
		if (!switchedOn)
		{
			if (switchedOn && !switching)
			{
				StartCoroutine(SwitchOn_Touch());
			}
		}
		else if (switchedOn && !switching)
		{
			StartCoroutine(SwitchOff_Touch());
		}
	}

	private IEnumerator SwitchOn()
	{
		holoPanel.localPosition = defaultHoloPanelLocalPosition;
		switching = true;
		int educationType = ui.getEducationLayerType();
		if ((educationType == 1 || educationType == 3) && !hasPlayedNarration && !audio.isPlaying && narration != null)
		{
			StopAllInfoSphereAudio();
			audio.Play();
		}
		playerForwardSnapshot = (base.transform.position - player.position).normalized;
		if (educationType >= 2)
		{
			audio.PlayOneShot(activateSound);
		}
		RotateHoloPanelToPlayer();
		sphere.transform.LookAt(player.position, Vector3.up);
		switchedOn = true;
		okToShowHoloPanel = false;
		Show();
		yield return new WaitForSeconds(1f);
		switching = false;
	}

	private IEnumerator SwitchOff()
	{
		MonoBehaviour.print("Switching off");
		switching = true;
		int educationType = ui.getEducationLayerType();
		if (educationType >= 2)
		{
			audio.PlayOneShot(activateSound);
		}
		yield return new WaitForSeconds(0.01f);
		switchedOn = false;
		yield return new WaitForSeconds(1f);
		holoPanelForeground.localScale = inactiveHoloPanelScale;
		holoPanelBackground.localScale = inactiveHoloPanelScale;
		holoPanel.gameObject.SetActive(value: false);
		switching = false;
	}
}
public class IntroMessagePicker : MonoBehaviour
{
	public Texture daydreamMessage;

	public Texture gearVRMessageHMDOnly;

	public Texture gearVRMessageHMDRemote;

	[Space(10f)]
	public Texture questMessage_English;

	public Texture questMessage_French;

	public Texture questMessage_German;

	public Texture questMessage_Spanish;

	public Texture questMessage_Korean;

	public Texture questMessage_Japanese;

	public Texture questMessage_Cymraeg;

	private Material material;

	private void Awake()
	{
		material = GetComponent<Renderer>().material;
		UpdateTexture();
	}

	private void OnEnable()
	{
		UpdateTexture();
	}

	private void UpdateTexture()
	{
		switch (LocalisationManager.instance.selectedLanguage)
		{
		case LocalisationManager.Language.English:
			material.mainTexture = questMessage_English;
			break;
		case LocalisationManager.Language.French:
			material.mainTexture = questMessage_French;
			break;
		case LocalisationManager.Language.German:
			material.mainTexture = questMessage_German;
			break;
		case LocalisationManager.Language.Spanish:
			material.mainTexture = questMessage_Spanish;
			break;
		case LocalisationManager.Language.Korean:
			material.mainTexture = questMessage_Korean;
			break;
		case LocalisationManager.Language.Japanese:
			material.mainTexture = questMessage_Japanese;
			break;
		case LocalisationManager.Language.Cymraeg:
			material.mainTexture = questMessage_Cymraeg;
			break;
		}
	}
}
public class isVisible : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		bool flag = GetComponent<Renderer>().isVisible;
		MonoBehaviour.print("Object is in view : " + flag);
	}
}
public class JellyfishColours : MonoBehaviour
{
	public Color[] colors;

	public int currentIndex;

	private int nextIndex;

	public float changeColourTime = 2f;

	public bool randomise;

	private float lastChange;

	private float timer;

	private bool cycleColours = true;

	public Texture2D[] lightFlashTextures;

	public Color[] coloursToPickFrom;

	public float maxAlpha = 0.2f;

	public Vector2 changeColorTimeRange = new Vector2(0.1f, 4f);

	private void Start()
	{
		if (colors == null || colors.Length < 2)
		{
			Debug.Log("Need to setup colors array in inspector");
		}
		nextIndex = (currentIndex + 1) % colors.Length;
		if (randomise)
		{
			for (int i = 0; i < colors.Length; i++)
			{
				ref Color reference = ref colors[i];
				reference = coloursToPickFrom[Random.Range(0, coloursToPickFrom.Length)];
				colors[i].a = Random.Range(0.01f, maxAlpha);
			}
			if (Random.Range(0, 2) == 1)
			{
				cycleColours = false;
			}
			changeColourTime = Random.Range(changeColorTimeRange.x, changeColorTimeRange.y);
			GetComponent<Renderer>().material.SetFloat("_MMultiplier", Random.Range(2f, 4f));
			GetComponent<Renderer>().material.SetColor("_Color", new Color(Random.Range(0f, 1f), Random.Range(0f, 1f), Random.Range(0f, 1f)));
			GetComponent<Renderer>().material.SetTexture("_DetailTex", lightFlashTextures[Random.Range(0, lightFlashTextures.Length)]);
			float num = Random.Range(0.1f, 5f);
			GetComponent<Renderer>().material.SetTextureScale("_MainTex", new Vector2(num, num));
			num = Random.Range(0.3f, 5f);
			GetComponent<Renderer>().material.SetTextureScale("_DetailTex", new Vector2(num, num));
			GetComponent<Renderer>().material.SetFloat("_ScrollX", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_ScrollY", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_Scroll2X", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_Scroll2Y", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineFreqX2", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineFreqY2", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineFreqX", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineFreqY", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineAmplX", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineAmplY", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineAmplX2", Random.Range(0f, 1f));
			GetComponent<Renderer>().material.SetFloat("_SineAmplY2", Random.Range(0f, 1f));
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown("f"))
		{
			Start();
		}
		if (cycleColours)
		{
			timer += Time.deltaTime;
		}
		if (timer > changeColourTime)
		{
			currentIndex = (currentIndex + 1) % colors.Length;
			nextIndex = (currentIndex + 1) % colors.Length;
			timer = 0f;
		}
		GetComponent<Renderer>().materials[1].SetColor("_TintColor", Color.Lerp(colors[currentIndex], colors[nextIndex], timer / changeColourTime));
	}
}
public class KeyboardMouseControl : MonoBehaviour
{
	public float singleClickTime = 0.25f;

	private UI ui;

	private OVRSwimController swimController;

	private bool isDragging;

	private float oldDragPosition;

	private float touchpadPressedTimer;

	private bool mouseDown;

	private float mouseSwimTimer;

	private float clickTimer;

	private float systemTimer;

	private float prevXButton;

	private float prevYButton;

	private float prevBButton;

	private void Awake()
	{
		UnityEngine.Object.Destroy(this);
	}

	private void Start()
	{
		ui = base.transform.Find("UI").GetComponent<UI>();
		swimController = GetComponent<OVRSwimController>();
	}

	private void LateUpdate()
	{
		UpdateTouchpad();
		if (Input.GetMouseButtonDown(0))
		{
			MouseDown();
		}
		if (Input.GetMouseButtonUp(0))
		{
			MouseUp();
		}
		if (mouseDown)
		{
			mouseSwimTimer += Time.deltaTime;
		}
		else
		{
			mouseSwimTimer = 0f;
		}
		if (!ui.isSwitchedOn() && !ui.isShowingSomething() && mouseSwimTimer > singleClickTime)
		{
			swimController.TouchpadSwim();
		}
		systemTimer += Time.deltaTime;
	}

	private void preprocessDownSwipe()
	{
		if (!(clickTimer < singleClickTime))
		{
			return;
		}
		if (!ui.isShowingSomething())
		{
			ui.switchOffInfoSpheres();
			if (clickTimer < singleClickTime / 1.5f)
			{
				if (UnityEngine.Application.loadedLevelName == "OceanRift_Dolphins" || UnityEngine.Application.loadedLevelName == "OceanRift_SeaLions")
				{
					ui.DropRingIntoWater();
				}
				if (UnityEngine.Application.loadedLevelName == "OceanRift_Orcas")
				{
					ui.DropOrcaFoodIntoWater();
				}
			}
			else
			{
				swimController.TouchpadSwimDown();
			}
		}
		else
		{
			ui.processDownSwipe();
		}
	}

	private void UpdateTouchpad()
	{
		if (OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.Touchpad) && !LAC_GearVRRemote.instance.isControllerConnected() && clickTimer < singleClickTime)
		{
			ui.processSingleTap();
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadLeft, OVRInput.Controller.Touchpad))
		{
			if (ui.isSwichedOn())
			{
				ui.swipeIconsLeft();
			}
			else
			{
				ui.processLeftSwipe();
			}
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadRight, OVRInput.Controller.Touchpad))
		{
			if (ui.isSwichedOn())
			{
				ui.swipeIconsRight();
			}
			else
			{
				ui.processRightSwipe();
			}
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadUp, OVRInput.Controller.Touchpad))
		{
			ui.processUpSwipe();
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadDown, OVRInput.Controller.Touchpad))
		{
			preprocessDownSwipe();
		}
	}

	private void MouseDown()
	{
		clickTimer = systemTimer;
		mouseDown = true;
	}

	private void MouseUp()
	{
		clickTimer = systemTimer - clickTimer;
		mouseDown = false;
	}
}
public class LightBeam : MonoBehaviour
{
	public float minIntensity = 0.25f;

	public float maxIntensity = 0.5f;

	public float minDuration;

	public float maxDuration = 1f;

	public float swingFactor = 0.3f;

	public float swingTurbulence = 1f;

	public AnimationCurve lightbeamCurve;

	public AnimationCurve proximityFadeCurve;

	private float random;

	private float intensity;

	private float duration;

	private float alpha;

	private float value;

	private float noise;

	public LineRenderer lineRenderer;

	private Color theColour;

	private float timer;

	public float fadeDistanceStart = 3f;

	private Transform player;

	private void Start()
	{
		lineRenderer = base.transform.GetComponent<LineRenderer>();
		player = GameObject.Find("Dummy Player").transform;
	}

	public float DistanceToLine(Ray ray, Vector3 point)
	{
		return Vector3.Cross(ray.direction, point - ray.origin).magnitude;
	}

	private void OnEnable()
	{
		random = Random.Range(0f, 65535f);
		intensity = Random.Range(minIntensity, maxIntensity);
		duration = Random.Range(minDuration, maxDuration);
		theColour = GetComponent<Renderer>().material.GetColor("_TintColor");
		theColour.a = 0f;
		GetComponent<Renderer>().material.SetColor("_TintColor", theColour);
		timer = 0f;
		base.transform.rotation = Quaternion.identity;
	}

	private void Update()
	{
		noise = -0.5f + Mathf.PerlinNoise(random, Time.time * swingTurbulence);
		value = lightbeamCurve.Evaluate(timer / duration) * intensity;
		float num = 1f;
		Ray ray = new Ray(base.transform.position, -base.transform.up);
		float num2 = DistanceToLine(ray, player.position + player.forward);
		if (num2 < fadeDistanceStart)
		{
			num = proximityFadeCurve.Evaluate(1f - num2 / fadeDistanceStart);
		}
		float a = value * num;
		theColour.a = a;
		GetComponent<Renderer>().material.SetColor("_TintColor", theColour);
		base.transform.Rotate(new Vector3(0f, 0f, swingFactor * noise));
		timer += Time.deltaTime;
		if (timer > duration)
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class LightDimmingScript : MonoBehaviour
{
	public float highest_height;

	public float lowest_height;

	public float dimFactor;

	private float base_intensity;

	private GameObject player;

	private GameObject megalodon;

	private Color baseFogColor;

	private Color baseAmbientLight;

	private float baseFogDensity;

	public Color deepsFogColor;

	public bool useAbsolutePlayerDepth = true;

	private Camera camera;

	private float playerDepth;

	private bool active = true;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		baseFogColor = RenderSettings.fogColor;
		baseFogDensity = RenderSettings.fogDensity;
		baseAmbientLight = RenderSettings.ambientLight;
		camera = LAC_VRCameraRig.instance.getCenterCamera();
	}

	private void Update()
	{
		if (active)
		{
			if (useAbsolutePlayerDepth)
			{
				playerDepth = Mathf.Abs(player.transform.position.y);
			}
			else
			{
				playerDepth = player.transform.position.y;
			}
			float num = 1f - MapInterval(playerDepth, lowest_height, highest_height, 0f, 1f);
			RenderSettings.fogColor = baseFogColor * (1f - num) + deepsFogColor * num;
			RenderSettings.fogDensity = baseFogDensity + dimFactor * num;
			LAC_VRCameraRig.instance.setBackgroundColor(RenderSettings.fogColor);
		}
	}

	public void setActive(bool val)
	{
		active = val;
	}

	private float MapInterval(float val, float srcMin, float srcMax, float dstMin, float dstMax)
	{
		if (val >= srcMax)
		{
			return dstMax;
		}
		if (val <= srcMin)
		{
			return dstMin;
		}
		return dstMin + (val - srcMin) / (srcMax - srcMin) * (dstMax - dstMin);
	}
}
public class Mathfx
{
	public static float Hermite(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value * value * (3f - 2f * value));
	}

	public static float Sinerp(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, Mathf.Sin(value * (float)Math.PI * 0.5f));
	}

	public static float Coserp(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, 1f - Mathf.Cos(value * (float)Math.PI * 0.5f));
	}

	public static float Berp(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	public static float SmoothStep(float x, float min, float max)
	{
		x = Mathf.Clamp(x, min, max);
		float num = (x - min) / (max - min);
		float num2 = (x - min) / (max - min);
		return -2f * num * num * num + 3f * num2 * num2;
	}

	public static float Lerp(float start, float end, float value)
	{
		return (1f - value) * start + value * end;
	}

	public static Vector3 NearestPoint(Vector3 lineStart, Vector3 lineEnd, Vector3 point)
	{
		Vector3 vector = Vector3.Normalize(lineEnd - lineStart);
		float num = Vector3.Dot(point - lineStart, vector) / Vector3.Dot(vector, vector);
		return lineStart + num * vector;
	}

	public static Vector3 NearestPointStrict(Vector3 lineStart, Vector3 lineEnd, Vector3 point)
	{
		Vector3 vector = lineEnd - lineStart;
		Vector3 vector2 = Vector3.Normalize(vector);
		float value = Vector3.Dot(point - lineStart, vector2) / Vector3.Dot(vector2, vector2);
		return lineStart + Mathf.Clamp(value, 0f, Vector3.Magnitude(vector)) * vector2;
	}

	public static float Bounce(float x)
	{
		return Mathf.Abs(Mathf.Sin(6.28f * (x + 1f) * (x + 1f)) * (1f - x));
	}

	public static bool Approx(float val, float about, float range)
	{
		return Mathf.Abs(val - about) < range;
	}

	public static bool Approx(Vector3 val, Vector3 about, float range)
	{
		return (val - about).sqrMagnitude < range * range;
	}

	public static float Clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) / 2f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}
}
public class ModifyTerrain : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class MoveTest : MonoBehaviour
{
	public AnimationCurve curvy;

	private Vector3 defaultPosition;

	private float timer;

	public float speed = 0.5f;

	public float distance = 5f;

	private static string Llyr = "Llyr";

	private void Start()
	{
		defaultPosition = base.transform.position;
		UnityEngine.Application.targetFrameRate = 60;
	}

	private void Update()
	{
		base.transform.position = defaultPosition + Vector3.right * (curvy.Evaluate(timer) * distance);
		timer += Time.deltaTime * speed;
	}
}
public class MovingTarget : MonoBehaviour
{
	public BoxCollider movementZone;

	public float changeTime = 10f;

	private float timer;

	public int potentialTargetsToConsider = 5;

	private void Start()
	{
		timer = 1000f;
	}

	public void change()
	{
		timer = 1000f;
	}

	public void setTimer(float val)
	{
		timer = val;
	}

	private void Update()
	{
		timer += Time.deltaTime;
		if (!(timer > changeTime))
		{
			return;
		}
		Vector3 vector = new Vector3(0f, 0f, 0f);
		float num = float.PositiveInfinity;
		for (int i = 0; i < potentialTargetsToConsider; i++)
		{
			Vector3 size = movementZone.bounds.size;
			Vector3 vector2 = movementZone.transform.position - movementZone.bounds.size / 2f;
			vector = new Vector3(vector2.x + Random.value * size.x, vector2.y + Random.value * size.y, vector2.z + Random.value * size.z);
			Vector3 from = vector - base.transform.position;
			float magnitude = from.magnitude;
			float num2 = Vector3.Angle(from, base.transform.right);
			if (num2 < num)
			{
				num = num2;
				base.transform.position = vector;
			}
		}
		timer = 0f;
	}
}
public class OpenDayControls : MonoBehaviour
{
	public GameObject fireworkRingPrefab;

	private GameObject dolphinRing;

	private float touchTimer;

	private float systemTimer;

	private float singleClickTime = 0.25f;

	private GameObject player;

	private AsyncOperation async;

	private void Start()
	{
		player = GameObject.Find("Player");
		UnityEngine.Object.DontDestroyOnLoad(player);
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			TouchDown();
		}
		if (Input.GetMouseButtonUp(0))
		{
			TouchUp();
		}
		systemTimer += Time.deltaTime;
	}

	private void UpdateTouchpad()
	{
		if (OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.Touchpad) && UnityEngine.Application.loadedLevelName == "OpenDaySeaLions")
		{
			dropRingIntoWater();
		}
		if (OVRInput.GetDown(OVRInput.Button.DpadDown, OVRInput.Controller.Touchpad) && UnityEngine.Application.loadedLevelName == "OpenDaySeaLions")
		{
			dropRingIntoWater();
		}
	}

	private void SwapLevels()
	{
		string levelName = "OpenDaySeaLions";
		if (UnityEngine.Application.loadedLevelName == "OpenDaySeaLions")
		{
			levelName = "OpenDayDinosaurs";
		}
		if (UnityEngine.Application.CanStreamedLevelBeLoaded(levelName) && !UnityEngine.Application.isLoadingLevel)
		{
			StartCoroutine(loadCoroutine(levelName));
		}
	}

	private void dropRingIntoWater()
	{
		Vector3 forward = LAC_VRCameraRig.instance.getCenterCamera().transform.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 position = LAC_VRCameraRig.instance.getCenterCamera().transform.position;
		position.y = GameObject.Find("Water Surface").transform.position.y + 1f;
		Vector3 position2 = position + forward * 4f;
		if (dolphinRing != null)
		{
			Transform transform = dolphinRing.transform.Find("Ring Splash Bubbles");
			if (transform != null)
			{
				transform.parent = null;
			}
			UnityEngine.Object.Destroy(dolphinRing);
		}
		float num = 3f;
		dolphinRing = UnityEngine.Object.Instantiate(fireworkRingPrefab, position2, Quaternion.identity);
		dolphinRing.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
		dolphinRing.GetComponent<Rigidbody>().AddTorque(new Vector3(Random.Range(0f - num, num), Random.Range(0f - num, num), Random.Range(0f - num, num)), ForceMode.Impulse);
	}

	private void TouchDown()
	{
		touchTimer = systemTimer;
	}

	private void TouchUp()
	{
		touchTimer = systemTimer - touchTimer;
	}

	private IEnumerator loadCoroutine(string levelName, bool teleportEffects = true)
	{
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		async = UnityEngine.Application.LoadLevelAsync(levelName);
		async.allowSceneActivation = false;
		while (!async.isDone)
		{
			if (UnityEngine.Application.loadedLevelName == levelName)
			{
				if (async.progress >= 0.9f)
				{
					yield return new WaitForSeconds(0.3f);
					async.allowSceneActivation = true;
					GC.Collect();
				}
			}
			else if (async.progress == 0.9f)
			{
				LAC_VRCameraRig.instance.FadeOut();
				yield return new WaitForSeconds(0.3f);
				LAC_VRCameraRig.instance.FadeIn();
				async.allowSceneActivation = true;
			}
			yield return 0;
		}
	}
}
public class PerlinNoiseMouth : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw;

	private Quaternion upperJawDefaultRotation;

	private Quaternion lowerJawDefaultRotation;

	public float jawOpenSize = 35f;

	public AnimationCurve mouthActivityCurve;

	private float mouthActivityTimer;

	public float mouthActivityRate = 1f;

	private float timer;

	private void Start()
	{
		timer = Random.Range(0f, 10f);
		mouthActivityTimer = Random.Range(0f, 10f);
		upperJawDefaultRotation = upperJaw.localRotation;
		lowerJawDefaultRotation = lowerJaw.localRotation;
	}

	private void Update()
	{
		float num = 1f;
		float num2 = mouthActivityCurve.Evaluate(mouthActivityTimer);
		Vector3 vector = new Vector3(0f, 0f, (0f - Mathf.PerlinNoise(0f, timer * num)) * jawOpenSize) * num2;
		Quaternion b = upperJawDefaultRotation * Quaternion.Euler(vector * 1f);
		Quaternion b2 = lowerJawDefaultRotation * Quaternion.Euler(vector * -1f);
		upperJaw.localRotation = Quaternion.Lerp(upperJaw.localRotation, b, Time.deltaTime * 5f);
		lowerJaw.localRotation = Quaternion.Lerp(lowerJaw.localRotation, b2, Time.deltaTime * 5f);
		timer += Time.deltaTime * Mathf.PerlinNoise(0f, timer) * 1.5f;
		mouthActivityTimer += Time.deltaTime * mouthActivityRate;
	}
}
public class PlayerGenesis : MonoBehaviour
{
	private LAC_HMDInfo.HMDType platform;

	public bool vsync;

	private float defaultGravity;

	public float specialCullDistance = 15f;

	public float nearClip = 0.1f;

	public float farClip = 25f;

	public float skinRadius = 1f;

	public float creatureInteractionRadius = 1f;

	private GameObject player;

	private int currentTeleportIndex;

	public Transform[] teleportPositions;

	public GameObject causticsProjector;

	public GameObject teleportParticles;

	private Transform waterSurface;

	public int customAALevel = 2;

	public float customRenderScale = 1.4f;

	private void Start()
	{
		GameObject gameObject = GameObject.Find("Water Surface");
		if (gameObject != null)
		{
			waterSurface = gameObject.transform;
			WaterSurfaceFader waterSurfaceFader = UnityEngine.Object.FindObjectOfType<WaterSurfaceFader>();
			if (waterSurfaceFader != null)
			{
				waterSurfaceFader.SetWaterSurface(waterSurface);
			}
		}
	}

	private void Awake()
	{
		Camera centerCamera = LAC_VRCameraRig.instance.getCenterCamera();
		GameObject gameObject = GameObject.Find("HMDInfo");
		if (gameObject == null)
		{
			gameObject = UnityEngine.Object.Instantiate(Resources.Load("General/HMDInfo"), base.transform.position, Quaternion.identity) as GameObject;
			gameObject.name = "HMDInfo";
		}
		platform = LAC_HMDInfo.instance.getHMDType();
		currentTeleportIndex = 0;
		player = GameObject.Find("Player");
		if (player == null)
		{
			MonoBehaviour.print("WARNING WARNING WARNINING!");
		}
		if (player == null)
		{
			player = GameObject.Find("Player(Clone)");
		}
		if (player == null)
		{
			player = GameObject.Find("NeoPlayer");
		}
		if (player == null)
		{
			player = GameObject.Find("NeoPlayer(Clone)");
		}
		if (player == null)
		{
			player = UnityEngine.Object.Instantiate(Resources.Load("General/Player"), base.transform.position, Quaternion.identity) as GameObject;
		}
		if (player != null)
		{
			player.transform.position = teleportPositions[0].position;
		}
		UnityEngine.Object.DontDestroyOnLoad(player);
		UnityEngine.Object.DontDestroyOnLoad(gameObject);
		Transform transform = player.transform.Find("UI");
		if (transform.GetComponent<UI>() != null)
		{
			transform.GetComponent<UI>().genesisScript = this;
		}
		else if (transform.GetComponent<TouchUI>() != null)
		{
			transform.GetComponent<TouchUI>().genesisScript = this;
		}
		if (skinRadius != 1f)
		{
			player.GetComponent<CharacterController>().radius = skinRadius;
		}
		if (creatureInteractionRadius != 1f)
		{
			player.transform.Find("Interaction Collider").GetComponent<CapsuleCollider>().radius = creatureInteractionRadius;
		}
		if (teleportParticles != null)
		{
			UnityEngine.Object.Instantiate(teleportParticles, player.transform.position, teleportParticles.transform.rotation);
		}
		LAC_VRCameraRig.instance.setBackgroundColor(RenderSettings.fogColor);
		LAC_VRCameraRig.instance.setNearClip(0.05f);
		LAC_VRCameraRig.instance.setFarClip(farClip * LAC_HMDInfo.getDrawDistanceMultiplier());
		RenderSettings.fogDensity /= LAC_HMDInfo.getDrawDistanceMultiplier();
		centerCamera.opaqueSortMode = OpaqueSortMode.NoDistanceSort;
		float[] array = new float[32];
		array[LayerMask.NameToLayer("Special Cull")] = specialCullDistance * LAC_HMDInfo.getDrawDistanceMultiplier();
		LAC_VRCameraRig.instance.setSpecialCull(array);
		GameObject obj = GameObject.Find("Caustics Projector(Clone)");
		UnityEngine.Object.Destroy(obj);
		obj = GameObject.Find("Dolphin Caustics Projector(Clone)");
		UnityEngine.Object.Destroy(obj);
		obj = GameObject.Find("Shark Cage Caustics Projector(Clone)");
		UnityEngine.Object.Destroy(obj);
		obj = GameObject.Find("Manatees Caustics Projector(Clone)");
		UnityEngine.Object.Destroy(obj);
		obj = GameObject.Find("Humpback Whale Caustics Projector(Clone)");
		UnityEngine.Object.Destroy(obj);
		obj = GameObject.Find("Atlantis Caustics Projector(Clone)");
		UnityEngine.Object.Destroy(obj);
		if (causticsProjector != null)
		{
			float y = player.transform.position.y + 5f;
			Vector3 position = new Vector3(player.transform.position.x, y, player.transform.position.z);
			GameObject gameObject2 = UnityEngine.Object.Instantiate(causticsProjector, position, Quaternion.identity);
			gameObject2.transform.parent = player.gameObject.transform;
			gameObject2.transform.rotation *= Quaternion.Euler(90f, 0f, 0f);
		}
		OVRPlugin.tiledMultiResLevel = OVRPlugin.TiledMultiResLevel.LMSMedium;
		XRSettings.eyeTextureResolutionScale = customRenderScale;
		TreasureScanner treasureScanner = UnityEngine.Object.FindObjectOfType<TreasureScanner>();
		if (treasureScanner != null)
		{
			treasureScanner.RebuildLibrary();
		}
	}

	private void Update()
	{
	}

	public float getWaterSurfaceY()
	{
		if (waterSurface != null)
		{
			return waterSurface.position.y;
		}
		return 100000f;
	}

	public Transform getNextTeleportTransform()
	{
		currentTeleportIndex++;
		if (currentTeleportIndex > teleportPositions.Length - 1)
		{
			currentTeleportIndex = 0;
		}
		OVRSwimController component = player.GetComponent<OVRSwimController>();
		if ((bool)component)
		{
			component.setGravity(val: false);
		}
		return teleportPositions[currentTeleportIndex];
	}
}
public class PlayfullFlippers : MonoBehaviour
{
	private float frontMaxHorizontalLimit = 0.6f;

	private float frontMinHorizontalLimit = 0.15f;

	private float rearMinHorizontalLimit;

	private float rearMaxHorizontalLimit = -0.6f;

	private Manatee aq;

	public AnimationCurve nodeCurve;

	public AnimationCurve behaviourStrokeGraph;

	public AnimationCurve behaviourClapGraph;

	public AnimationCurve behaviourSlapGraph;

	public AnimationCurve behaviourShakeGraph;

	public AnimationCurve behaviourMoveDriftGraph;

	public AnimationCurve behaviourDickArroundGraph;

	private int behaviour;

	private int behaviourQueue;

	private int behaviourTimer;

	private float strokeWeight;

	private float clapWeight;

	private float slapLeftWeight;

	private float slapRightWeight;

	private float shakeWeight;

	private float moveDriftWeight;

	private float dickWeight;

	public bool swimming;

	public bool drawStroke;

	public float strokeTime;

	public float clapTime;

	public float strokeSpeed = 1f;

	public float clapSpeed = 1f;

	private float leftlerpSpeed;

	private float leftTargetLerpSpeed;

	private float rightlerpSpeed;

	private float rightTargetLerpSpeed;

	public float reactionTime = 1.5f;

	public float drawModifier;

	public Transform leftStrokeNode;

	public Transform rightStrokeNode;

	public Transform leftClapNode;

	public Transform rightClapNode;

	public Transform leftFlipperNode;

	public Transform rightFlipperNode;

	private Transform leftCurrentNode;

	private Transform rightCurrentNode;

	public Transform swimNode;

	public Transform FLStrokeTarget;

	public Transform BLStrokeTarget;

	public Transform FRStrokeTarget;

	public Transform BRStrokeTarget;

	public Transform CClapTarget;

	public Transform LClapTarget;

	public Transform RClapTarget;

	public Transform FClapTarget;

	public Transform BClapTarget;

	private Transform[] left = new Transform[5];

	private Transform[] right = new Transform[5];

	public Transform body;

	public Transform leftFlipperJoint;

	public Transform rightFlipperJoint;

	public float targetAngleL;

	public float targetAngleR;

	private float flipperNoiseFrequencyL;

	private float flipperNoiseFrequencyR;

	public Vector2 flipperNoiseFrequencyRange = new Vector2(1f, 3f);

	public float flipperNoiseAmplitude = 5f;

	private float flipperNoiseTimerL;

	private float flipperNoiseTimerR;

	private void Start()
	{
		left[0] = FLStrokeTarget;
		left[1] = BLStrokeTarget;
		left[2] = LClapTarget;
		left[3] = leftStrokeNode;
		left[4] = leftClapNode;
		right[0] = FRStrokeTarget;
		right[1] = BRStrokeTarget;
		right[2] = RClapTarget;
		right[3] = rightStrokeNode;
		right[4] = rightClapNode;
		aq = base.transform.GetComponent<Manatee>();
		leftCurrentNode = leftStrokeNode;
		rightCurrentNode = rightStrokeNode;
		behaviourTimer = 0;
		behaviour = 1;
	}

	private void FixedUpdate()
	{
		UpdateTargets();
		UpdateNodes();
		CheckBehaviour();
		MoveFlippers();
	}

	private void UpdateTargets()
	{
		UpdateStrokeTargets();
	}

	private void UpdateClapTargets()
	{
		CClapTarget.localPosition = 0.5f * (leftStrokeNode.transform.localPosition + rightStrokeNode.transform.localPosition);
		Vector3 localPosition = new Vector3(CClapTarget.localPosition.x - 1f, CClapTarget.localPosition.y, CClapTarget.localPosition.z);
		Vector3 localPosition2 = new Vector3(CClapTarget.localPosition.x + 1f, CClapTarget.localPosition.y, CClapTarget.localPosition.z);
		LClapTarget.localPosition = localPosition;
		RClapTarget.localPosition = localPosition2;
	}

	private void UpdateStrokeTargets()
	{
		UpdateSwimNode();
		float x = swimNode.localPosition.x;
		float z = swimNode.localPosition.z;
		float z2 = Mathf.Clamp(1.1f - x / 10f, frontMinHorizontalLimit, frontMaxHorizontalLimit);
		float z3 = Mathf.Clamp(1.1f + x / 10f, frontMinHorizontalLimit, frontMaxHorizontalLimit);
		float z4 = Mathf.Clamp(-0.1f - x / 14f, rearMinHorizontalLimit, rearMaxHorizontalLimit);
		float z5 = Mathf.Clamp(-0.1f + x / 14f, rearMinHorizontalLimit, rearMaxHorizontalLimit);
		Vector3 b = new Vector3(FLStrokeTarget.localPosition.x, FLStrokeTarget.localPosition.y, z3);
		Vector3 b2 = new Vector3(FRStrokeTarget.localPosition.x, FRStrokeTarget.localPosition.y, z2);
		Vector3 b3 = new Vector3(BLStrokeTarget.localPosition.x, BLStrokeTarget.localPosition.y, z5);
		Vector3 b4 = new Vector3(BRStrokeTarget.localPosition.x, BRStrokeTarget.localPosition.y, z4);
		FLStrokeTarget.localPosition = Vector3.Lerp(FLStrokeTarget.localPosition, b, Time.deltaTime * 1f);
		FRStrokeTarget.localPosition = Vector3.Lerp(FRStrokeTarget.localPosition, b2, Time.deltaTime * 1f);
		BLStrokeTarget.localPosition = Vector3.Lerp(BLStrokeTarget.localPosition, b3, Time.deltaTime * 1f);
		BRStrokeTarget.localPosition = Vector3.Lerp(BRStrokeTarget.localPosition, b4, Time.deltaTime * 1f);
	}

	private void UpdateNodes()
	{
		UpdateClapNodes();
		UpdateStrokeNodes();
	}

	private void UpdateClapNodes()
	{
		float num = nodeCurve.Evaluate(clapTime);
		leftClapNode.position = CClapTarget.position * (1f - num) + LClapTarget.position * num;
		rightClapNode.position = CClapTarget.position * (1f - num) + RClapTarget.position * num;
		clapTime += Time.deltaTime * (aq.getMoveSpeed() + clapSpeed);
	}

	private void UpdateStrokeNodes()
	{
		float num = nodeCurve.Evaluate(strokeTime);
		leftStrokeNode.position = BLStrokeTarget.position * (1f - num) + FLStrokeTarget.position * num;
		rightStrokeNode.position = BRStrokeTarget.position * (1f - num) + FRStrokeTarget.position * num;
		strokeTime += Time.deltaTime * (aq.getMoveSpeed() * drawModifier * strokeSpeed);
		UpdateStrokeDirection();
	}

	private void UpdateStrokeDirection()
	{
		if (Mathf.Floor(strokeTime % 2f) == 0f)
		{
			drawStroke = false;
			drawModifier = 0.8f;
		}
		else
		{
			drawStroke = true;
			drawModifier = 1.5f;
		}
	}

	private void UpdateSwimNode()
	{
		swimNode.position = Vector3.Lerp(swimNode.position, aq.target.position, Time.deltaTime * 60f);
	}

	private void CheckBehaviour()
	{
		if (Random.Range(0, 250) < 1)
		{
			generateBehaviourWeights();
			behaviourQueue = BehaviourEngine();
			if (behaviour != behaviourQueue)
			{
				behaviourTimer = 70;
				leftTargetLerpSpeed = 0f;
				rightTargetLerpSpeed = 0f;
			}
		}
		if (behaviourTimer == 0)
		{
			behaviour = behaviourQueue;
			randomiseLerp(0.15f);
			clapSpeed = Random.Range(0.1f, 2.4f);
		}
		checkLerp();
		if (behaviour == 1)
		{
			behaviourStroke();
		}
		if (behaviour == 2)
		{
			behaviourClap();
		}
		if (behaviour == 3)
		{
			behaviourSlapLeft();
		}
		if (behaviour == 4)
		{
			behaviourSlapRight();
		}
		if (behaviour == 5)
		{
			behaviourShake();
		}
		if (behaviour == 6)
		{
			behaviourMoveDrift();
		}
		if (behaviour == 7)
		{
			if (behaviourTimer == 0)
			{
				behaviourDick(newDick: true);
			}
			else
			{
				behaviourDick(newDick: false);
			}
		}
		if (behaviourTimer >= 0)
		{
			behaviourTimer--;
		}
	}

	private int BehaviourEngine()
	{
		float num = strokeWeight;
		float num2 = num + clapWeight;
		float num3 = num2 + slapLeftWeight;
		float num4 = num3 + slapRightWeight;
		float num5 = num4 + shakeWeight;
		float num6 = num5 + moveDriftWeight;
		float num7 = num6 + dickWeight;
		float num8 = Random.Range(0f, num5);
		if (num8 < num)
		{
			return 1;
		}
		if (num8 >= num && num8 < num2)
		{
			return 2;
		}
		if (num8 >= num2 && num8 < num3)
		{
			return 3;
		}
		if (num8 >= num3 && num8 < num4)
		{
			return 4;
		}
		if (num8 >= num4 && num8 < num6)
		{
			return 5;
		}
		if (num8 >= num6 && num8 < num7)
		{
			return 6;
		}
		return 7;
	}

	private void generateBehaviourWeights()
	{
		float time = aq.getMoveSpeed() / aq.getMaxMoveSpeed();
		strokeWeight = behaviourStrokeGraph.Evaluate(time);
		clapWeight = behaviourClapGraph.Evaluate(time);
		slapRightWeight = behaviourSlapGraph.Evaluate(time);
		slapLeftWeight = behaviourSlapGraph.Evaluate(time);
		shakeWeight = behaviourShakeGraph.Evaluate(time);
		moveDriftWeight = behaviourMoveDriftGraph.Evaluate(time);
		dickWeight = behaviourDickArroundGraph.Evaluate(time);
		if (behaviour == 1 || behaviour == 5 || behaviour == 6)
		{
			shakeWeight += 0.9f;
			strokeWeight += 3.5f;
			slapRightWeight += 0.3f;
			slapLeftWeight += 0.3f;
			moveDriftWeight += 1.3f;
		}
		if (behaviour == 2)
		{
			clapWeight += 0.4f;
			slapRightWeight += 0.9f;
			slapLeftWeight += 0.9f;
		}
		if (behaviour == 3 || behaviour == 4)
		{
			shakeWeight += 0.9f;
			strokeWeight += 2.5f;
			moveDriftWeight += 5.7f;
		}
	}

	private void behaviourStroke()
	{
		leftCurrentNode = leftStrokeNode;
		rightCurrentNode = rightStrokeNode;
		UpdateClapTargets();
		RotateFlipper(1);
	}

	private void behaviourShake()
	{
		leftCurrentNode = leftStrokeNode;
		rightCurrentNode = rightStrokeNode;
		RotateFlipper(2);
		if (Random.Range(0, 40) < 1)
		{
			randomiseLerp(0.7f);
		}
		UpdateClapTargets();
	}

	private void behaviourClap()
	{
		leftCurrentNode = leftClapNode;
		rightCurrentNode = rightClapNode;
		RotateFlipper(2);
	}

	private void behaviourSlapRight()
	{
		leftCurrentNode = leftStrokeNode;
		rightCurrentNode = rightClapNode;
		RotateFlipper(2);
	}

	private void behaviourSlapLeft()
	{
		leftCurrentNode = leftClapNode;
		rightCurrentNode = rightStrokeNode;
		RotateFlipper(2);
	}

	private void behaviourMoveDrift()
	{
		leftCurrentNode = BLStrokeTarget;
		rightCurrentNode = BRStrokeTarget;
	}

	private void behaviourDick(bool newDick)
	{
		MonoBehaviour.print("Im a dick");
		if (newDick)
		{
			clapSpeed = Random.Range(0.81f, 2.5f);
			randomiseLerp(0.7f);
			leftCurrentNode = left[Random.Range(0, 4)];
			rightCurrentNode = right[Random.Range(0, 4)];
		}
	}

	private void checkLerp()
	{
		if (leftlerpSpeed <= leftTargetLerpSpeed)
		{
			leftlerpSpeed += 0.0001f;
		}
		else
		{
			leftlerpSpeed -= 0.001f;
		}
		if (rightlerpSpeed <= rightTargetLerpSpeed)
		{
			rightlerpSpeed += 0.0001f;
		}
		else
		{
			rightlerpSpeed -= 0.001f;
		}
	}

	private void randomiseLerp(float maxLerp)
	{
		leftTargetLerpSpeed = Random.Range(0.01f, maxLerp);
		rightTargetLerpSpeed = Random.Range(0.01f, maxLerp);
	}

	private void MoveFlippers()
	{
		UpdateFlipper(leftFlipperJoint, leftFlipperNode, bRightSide: false);
		UpdateFlipper(rightFlipperJoint, rightFlipperNode, bRightSide: true);
		leftFlipperNode.position = Vector3.Lerp(leftFlipperNode.position, leftCurrentNode.position, leftlerpSpeed);
		rightFlipperNode.position = Vector3.Lerp(rightFlipperNode.position, rightCurrentNode.position, rightlerpSpeed);
	}

	private void UpdateFlipper(Transform flipper, Transform targetPoint, bool bRightSide)
	{
		Quaternion rotation = flipper.rotation;
		flipper.LookAt(targetPoint, body.right);
		flipper.rotation *= Quaternion.Euler(0f, 90f, 0f);
		if (!bRightSide)
		{
			flipper.rotation *= Quaternion.Euler(targetAngleL, 0f, 0f);
		}
		else
		{
			flipper.rotation *= Quaternion.Euler(targetAngleR, 0f, 0f);
		}
		Quaternion rotation2 = flipper.rotation;
		flipper.rotation = Quaternion.Slerp(rotation, rotation2, Time.deltaTime * 10f);
		if (Random.Range(0, 100) < 1)
		{
			flipperNoiseFrequencyR = Random.Range(flipperNoiseFrequencyRange.x, flipperNoiseFrequencyRange.y);
			flipperNoiseFrequencyL = Random.Range(flipperNoiseFrequencyRange.x, flipperNoiseFrequencyRange.y);
		}
		Quaternion quaternion;
		if (bRightSide)
		{
			quaternion = Quaternion.Euler(Vector3.up * Mathf.Sin(flipperNoiseTimerR) * flipperNoiseAmplitude);
			flipperNoiseTimerR += Time.deltaTime * flipperNoiseFrequencyR;
		}
		else
		{
			quaternion = Quaternion.Euler(Vector3.up * Mathf.Sin(flipperNoiseTimerL) * flipperNoiseAmplitude);
			flipperNoiseTimerL += Time.deltaTime * flipperNoiseFrequencyL;
		}
		flipper.rotation *= quaternion;
	}

	private void RotateFlipper(int flipperRotationType)
	{
		float num = Vector3.Angle(BLStrokeTarget.localPosition, FLStrokeTarget.localPosition);
		float num2 = Vector3.Angle(BRStrokeTarget.localPosition, FRStrokeTarget.localPosition);
		num -= 30f;
		num2 -= 30f;
		float b;
		float b2;
		if (flipperRotationType == 1)
		{
			b = num + 50f;
			b2 = num2 - 50f;
		}
		else
		{
			b = num;
			b2 = num2;
		}
		float b3 = num;
		float b4 = num2;
		if (drawStroke)
		{
			targetAngleL = Mathf.Lerp(targetAngleL, b, Time.deltaTime * 0.7f);
			targetAngleR = Mathf.Lerp(targetAngleR, b2, Time.deltaTime * 0.7f);
		}
		else
		{
			targetAngleL = Mathf.Lerp(targetAngleL, b3, Time.deltaTime * 0.7f);
			targetAngleR = Mathf.Lerp(targetAngleR, b4, Time.deltaTime * 0.7f);
		}
	}
}
public class PlayMovie : MonoBehaviour
{
	private void Start()
	{
		Refresh();
	}

	public void Refresh()
	{
	}
}
public class PrintTemperature : MonoBehaviour
{
	public float readingEvery;

	private float readingTimer;

	private void Start()
	{
		readingTimer = float.PositiveInfinity;
	}

	private void Update()
	{
	}
}
public class ProceduralLimb : MonoBehaviour
{
	public bool showDebug;

	private SpiderCrab spider;

	private Transform targetNode;

	private Transform foot;

	private IK ik;

	private Vector3 offset;

	private Vector3 defaultFootPosition;

	private float parentScale;

	private RaycastHit hit;

	private float footHeight;

	private float stepProgress = 1f;

	private float lastStepTime;

	private Vector3 prediction;

	private Vector3 groundPosition;

	private Vector3 groundNormal;

	private Vector3 lastImpactPosition;

	private float velocityPrediction = 0.2f;

	private float raycastFocus = 0.1f;

	private float minDelay = 0.05f;

	public bool isStepping => stepProgress < 1f;

	private void Start()
	{
		offset = new Vector3(0f, 0f, 1f);
		spider = base.transform.parent.parent.GetComponent<SpiderCrab>();
		parentScale = spider.getScale();
		ik = GetComponent<IK>();
		hit = default(RaycastHit);
		createTargetNode();
		defaultFootPosition = spider.hips.transform.InverseTransformPoint(foot.position + offset * parentScale) + -spider.transform.forward;
		UpdateGroundPosition();
		targetNode.position = groundPosition;
		hit.point = spider.transform.TransformPoint(defaultFootPosition);
		stepProgress = 1f;
	}

	private void OnDrawGizmos()
	{
	}

	public Vector3 getLastImpactPosition()
	{
		return lastImpactPosition;
	}

	public Vector3 GetFootPosition()
	{
		return foot.position;
	}

	public float GetFootHeight()
	{
		return (foot.position - defaultFootPosition).y;
	}

	private void UpdateGroundPosition()
	{
		Vector3 vector = (groundPosition = spider.hips.transform.TransformPoint(defaultFootPosition));
		groundNormal = Vector3.up;
		if (Physics.Raycast(vector + new Vector3(0f, 20f, 0f), Vector3.down, out hit, 100f, spider.raycastLayers))
		{
			Debug.DrawLine(vector, hit.point, Color.yellow);
			groundPosition = hit.point;
			groundNormal = hit.normal;
		}
	}

	public Vector3 getGroundNormal()
	{
		return groundNormal;
	}

	public float GetGroundHeight()
	{
		return groundPosition.y;
	}

	public float getDistanceToComfort()
	{
		return (groundPosition + spider.getVelocity() - foot.position).magnitude;
	}

	private void Update()
	{
		UpdateGroundPosition();
		ik.GetIKSolver().SetIKPosition(targetNode.transform.position);
	}

	private void createTargetNode()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.name.Contains("End"))
			{
				foot = transform;
				MonoBehaviour.print("creating");
				targetNode = (UnityEngine.Object.Instantiate(Resources.Load("Prefabs/Target Node")) as GameObject).transform;
				targetNode.position = transform.position;
				targetNode.localScale *= parentScale;
				targetNode.gameObject.name = "Limb Target Node";
			}
		}
	}

	private Vector3 GetStepTarget(out bool stepFound, float focus, float distance)
	{
		stepFound = false;
		Vector3 vector = groundPosition;
		Vector3 normalized = (vector - foot.position).normalized;
		vector += spider.getVelocity() * 1.5f;
		prediction = vector;
		Vector3 up = spider.transform.up;
		Vector3 rhs = spider.transform.position - targetNode.position;
		Vector3 axis = Vector3.Cross(up, rhs);
		up = Quaternion.AngleAxis(focus, axis) * up;
		if (Physics.Raycast(vector + up * spider.raycastHeight * parentScale, -up, out hit, spider.raycastHeight * parentScale + distance, spider.raycastLayers))
		{
			stepFound = true;
		}
		return hit.point + spider.transform.up * footHeight * parentScale;
	}

	public Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Vector3 angles)
	{
		return Quaternion.Euler(angles) * (point - pivot) + pivot;
	}

	public void checkComfort()
	{
		if (!isStepping && !(Time.time < lastStepTime + minDelay))
		{
			bool stepFound = false;
			Vector3 stepTarget = GetStepTarget(out stepFound, raycastFocus, 8f * parentScale);
			if (!stepFound)
			{
				stepTarget = GetStepTarget(out stepFound, raycastFocus, -8f * parentScale);
			}
			if (stepFound && !(Vector3.Distance(targetNode.position, stepTarget) < spider.footComfortDistance * parentScale))
			{
				StopAllCoroutines();
				StartCoroutine(Step(targetNode.position, stepTarget));
			}
		}
	}

	public void forceTakeStep()
	{
		if (!isStepping && !(Time.time < lastStepTime + minDelay))
		{
			bool stepFound = false;
			Vector3 stepTarget = GetStepTarget(out stepFound, raycastFocus, 8f * parentScale);
			if (!stepFound)
			{
				stepTarget = GetStepTarget(out stepFound, raycastFocus, -8f * parentScale);
			}
			if (stepFound)
			{
				StopAllCoroutines();
				StartCoroutine(Step(targetNode.position, stepTarget));
			}
		}
	}

	private IEnumerator Step(Vector3 stepStartPosition, Vector3 targetPosition)
	{
		stepProgress = 0f;
		while (stepProgress < 1f)
		{
			stepProgress += Time.deltaTime * spider.stepSpeed;
			targetNode.position = Vector3.Lerp(stepStartPosition, targetPosition, stepProgress);
			targetNode.position += spider.transform.up * spider.stepYOffset.Evaluate(stepProgress) * spider.stepHeight * parentScale;
			yield return null;
		}
		targetNode.position = targetPosition;
		lastImpactPosition = targetPosition;
		lastStepTime = Time.time;
	}
}
public class PushByCreatures : MonoBehaviour
{
	private float strength = 0.00035f;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnCollisionStay(Collision collisionInfo)
	{
		MonoBehaviour.print("test");
	}

	public void OnTriggerStay(Collider col)
	{
		if (col.name == "Leader")
		{
			Vector3 vector = base.transform.position - col.transform.position;
			GetComponent<OVRSwimController>().MoveThrottle += vector * strength;
			MonoBehaviour.print("push!!!!");
		}
	}
}
public class PushCollider : MonoBehaviour
{
	private OVRPlayerController playerController;

	private void Start()
	{
		playerController = GameObject.Find("Player").GetComponent<OVRPlayerController>();
	}

	private void OnCollisionStay(Collision col)
	{
	}
}
public class QuitOnBackButton : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class RandomOnCircle : MonoBehaviour
{
	public float maxRadius = 15f;

	public float minRadius = 10f;

	private Vector3 candidatePos;

	private GameObject player;

	private void Start()
	{
		player = GameObject.Find("Dummy Player");
		Vector3 position = player.transform.position;
		Vector3 vector;
		do
		{
			vector = new Vector3(Random.Range(0f - maxRadius, maxRadius), 0f, Random.Range(0f - maxRadius, maxRadius));
		}
		while (!((position - (position + vector)).magnitude > minRadius));
		candidatePos = player.transform.position + vector;
		base.transform.position = candidatePos;
		base.transform.LookAt(position);
		base.transform.rotation *= Quaternion.Euler(0f, -90f, 0f);
	}
}
public class RandomTorque : MonoBehaviour
{
	private Vector3 randomTorque;

	private void Start()
	{
		randomTorque = Random.rotation * Vector3.forward;
	}

	private void Update()
	{
		GetComponent<Rigidbody>().AddTorque(randomTorque * 0.1f * Time.deltaTime, ForceMode.Force);
	}
}
public class RenderingOrder : MonoBehaviour
{
	private void Start()
	{
		GetComponent<Renderer>().material.renderQueue = -2;
	}

	private void Update()
	{
	}
}
[RequireComponent(typeof(MeshFilter))]
public class ReverseNormals : MonoBehaviour
{
	private void Start()
	{
		MeshFilter meshFilter = GetComponent(typeof(MeshFilter)) as MeshFilter;
		if (meshFilter != null)
		{
			Mesh mesh = meshFilter.mesh;
			Vector3[] normals = mesh.normals;
			for (int i = 0; i < normals.Length; i++)
			{
				ref Vector3 reference = ref normals[i];
				reference = -normals[i];
			}
			mesh.normals = normals;
			for (int j = 0; j < mesh.subMeshCount; j++)
			{
				int[] triangles = mesh.GetTriangles(j);
				for (int k = 0; k < triangles.Length; k += 3)
				{
					int num = triangles[k];
					triangles[k] = triangles[k + 1];
					triangles[k + 1] = num;
				}
				mesh.SetTriangles(triangles, j);
			}
		}
		GetComponent<MeshCollider>().sharedMesh = meshFilter.mesh;
	}
}
public class Rotator : MonoBehaviour
{
	public Vector3 axis = new Vector3(0f, 1f, 0f);

	public float speed = 1f;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(axis * speed);
	}
}
public class Blip : MonoBehaviour
{
	public AnimationCurve alphaCurve;

	public float timeAlive;

	private float timer;

	private Color temp;

	private float maxAlpha = 1f;

	private Material scannerScreenMaterial;

	private Renderer renderer;

	private float alphaMultiplier = 1f;

	private void Start()
	{
		temp = GetComponent<Renderer>().material.GetColor("_TintColor");
		temp.a = 0f;
		GetComponent<Renderer>().material.SetColor("_TintColor", temp);
		scannerScreenMaterial = base.transform.parent.GetComponent<Renderer>().material;
		UnityEngine.Object.Destroy(base.gameObject, timeAlive + 0.1f);
		renderer = GetComponent<Renderer>();
	}

	private void Update()
	{
		temp.a = Mathf.Clamp(alphaCurve.Evaluate(Mathf.Clamp01(timer / timeAlive)), 0f, scannerScreenMaterial.GetColor("_TintColor").a * alphaMultiplier);
		timer += Time.deltaTime;
		renderer.material.SetColor("_TintColor", temp);
	}

	public void SetMultiplyAlpha(float mult)
	{
		alphaMultiplier = mult;
	}
}
public class FollowPlayerHead : MonoBehaviour
{
	public bool update;

	private Transform head;

	public float distance = 1.5f;

	public float lerpSpeed = 1f;

	private Vector3 targetPoint;

	private void Start()
	{
		head = LAC_VRCameraRig.instance.getCenterCamera().transform;
		StartCoroutine(UpdatePosition());
	}

	private void Update()
	{
		if (update)
		{
			base.transform.position = Vector3.Lerp(base.transform.position, targetPoint, Time.deltaTime * lerpSpeed);
		}
	}

	private IEnumerator UpdatePosition()
	{
		while (true)
		{
			yield return new WaitForSeconds(0.1f);
			Vector3 dir = Vector3.forward;
			targetPoint = head.position + dir * distance + new Vector3(0f, 0f, 0f);
		}
	}
}
public class Grabbable : MonoBehaviour
{
	public bool collisionsWhenGrabbed = true;

	public bool forceRotationInHand;

	public bool lerpTracking;

	private bool grabbed;

	private Transform handTransform;

	private Rigidbody body;

	private Vector3 grabStartPosition;

	private Quaternion grabStartLocalRotation;

	private Quaternion grabStartWorldRotation;

	public Vector3 targetOffset = new Vector3(0f, 0f, 0f);

	public Vector3 rotationInHand = new Vector3(0f, 0f, 0f);

	private float grabFlyTime = 0.1f;

	private float grabStartTime;

	private Quaternion targetRotation;

	private void Start()
	{
		body = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (grabbed)
		{
			float num = (Time.time - grabStartTime) / grabFlyTime;
			Quaternion rotation = handTransform.rotation;
			if (forceRotationInHand)
			{
				targetRotation = rotation * Quaternion.Euler(rotationInHand);
			}
			else
			{
				targetRotation = rotation * grabStartLocalRotation;
			}
			if ((double)num < 1.0)
			{
				base.transform.position = Vector3.Lerp(grabStartPosition, handTransform.position + targetOffset, num);
				base.transform.rotation = Quaternion.Lerp(grabStartWorldRotation, targetRotation, num);
			}
			else if (lerpTracking)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, handTransform.position, Time.deltaTime * 25f);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, targetRotation, Time.deltaTime * 25f);
			}
			else
			{
				base.transform.position = handTransform.position;
				base.transform.rotation = targetRotation;
			}
		}
	}

	public void grab(Transform hand)
	{
		grabbed = true;
		handTransform = hand;
		body.isKinematic = true;
		grabStartTime = Time.time;
		grabStartPosition = base.gameObject.transform.position;
		grabStartWorldRotation = base.transform.rotation;
		grabStartLocalRotation = Quaternion.Inverse(hand.rotation) * grabStartWorldRotation;
		if (!collisionsWhenGrabbed)
		{
			GetComponent<Collider>().isTrigger = true;
		}
	}

	public void release(Vector3 releaseVelocity, Vector3 releaseAngularVelocity)
	{
		grabbed = false;
		handTransform = null;
		body.isKinematic = false;
		body.velocity = releaseVelocity;
		body.angularVelocity = releaseAngularVelocity;
		if (!collisionsWhenGrabbed)
		{
			GetComponent<Collider>().isTrigger = false;
		}
	}

	public void instantTeleportToHand()
	{
		base.transform.position = handTransform.position;
		base.transform.rotation = targetRotation;
	}
}
namespace OVRTouchSample
{
	[RequireComponent(typeof(OVRGrabberCustom))]
	public class Hand : MonoBehaviour
	{
		public const string ANIM_LAYER_NAME_POINT = "Point Layer";

		public const string ANIM_LAYER_NAME_THUMB = "Thumb Layer";

		public const string ANIM_PARAM_NAME_FLEX = "Flex";

		public const string ANIM_PARAM_NAME_POSE = "Pose";

		public const float THRESH_COLLISION_FLEX = 0.9f;

		public const float INPUT_RATE_CHANGE = 20f;

		public const float COLLIDER_SCALE_MIN = 0.01f;

		public const float COLLIDER_SCALE_MAX = 1f;

		public const float COLLIDER_SCALE_PER_SECOND = 1f;

		public const float TRIGGER_DEBOUNCE_TIME = 0.05f;

		public const float THUMB_DEBOUNCE_TIME = 0.15f;

		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		[SerializeField]
		private HandPose m_defaultGrabPose;

		private Collider[] m_colliders;

		private bool m_collisionEnabled = true;

		private OVRGrabberCustom m_grabber;

		private List<Renderer> m_showAfterInputFocusAcquired;

		private int m_animLayerIndexThumb = -1;

		private int m_animLayerIndexPoint = -1;

		private int m_animParamIndexFlex = -1;

		private int m_animParamIndexPose = -1;

		private bool m_isPointing;

		private bool m_isGivingThumbsUp;

		private float m_pointBlend;

		private float m_thumbsUpBlend;

		private bool m_restoreOnInputAcquired;

		public GameObject propeller;

		public Renderer handRenderer;

		private Material propellerMaterial;

		private Color defaultPropellerColor;

		private Color offPropellerColor;

		private Color currentPropellerColor;

		private Color targetPropellerColor;

		private Material handMaterial;

		private Color defaultHandColor;

		private Color glowingHandColor;

		private Color currentHandColor;

		private Color targetHandColor;

		private OVRSwimController swimController;

		public AnimationCurve strokeCurve;

		public float swimForce = 28f;

		public float maxStrokeSpeed = 3f;

		public float propellerForce = 0.85f;

		private OVRGrabberCustom grabber;

		private TouchUI ui;

		private float m_collisionScaleCurrent;

		public OVRInput.Controller getController()
		{
			return m_controller;
		}

		private void Awake()
		{
			m_grabber = GetComponent<OVRGrabberCustom>();
		}

		private void Start()
		{
			ui = GameObject.Find("UI").GetComponent<TouchUI>();
			grabber = GetComponent<OVRGrabberCustom>();
			swimController = base.transform.root.GetComponent<OVRSwimController>();
			propellerMaterial = propeller.GetComponent<Renderer>().material;
			defaultPropellerColor = propellerMaterial.GetColor("_TintColor");
			offPropellerColor = defaultPropellerColor;
			offPropellerColor.a = 0f;
			currentPropellerColor = offPropellerColor;
			handMaterial = handRenderer.material;
			defaultHandColor = handMaterial.GetColor("_Color");
			glowingHandColor = defaultHandColor * 1.2f;
			m_showAfterInputFocusAcquired = new List<Renderer>();
			m_colliders = (from childCollider in GetComponentsInChildren<Collider>()
				where !childCollider.isTrigger
				select childCollider).ToArray();
			CollisionEnable(enabled: false);
			m_animLayerIndexPoint = m_animator.GetLayerIndex("Point Layer");
			m_animLayerIndexThumb = m_animator.GetLayerIndex("Thumb Layer");
			m_animParamIndexFlex = Animator.StringToHash("Flex");
			m_animParamIndexPose = Animator.StringToHash("Pose");
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void Update()
		{
			currentPropellerColor = Color.Lerp(currentPropellerColor, targetPropellerColor, Time.deltaTime * 15f);
			propellerMaterial.SetColor("_TintColor", currentPropellerColor);
			currentHandColor = Color.Lerp(currentHandColor, targetHandColor, Time.deltaTime * 15f);
			handMaterial.SetColor("_Color", currentHandColor);
			UpdateCapTouchStates();
			m_pointBlend = InputValueRateChange(m_isPointing, m_pointBlend);
			m_thumbsUpBlend = InputValueRateChange(m_isGivingThumbsUp, m_thumbsUpBlend);
			float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			bool flag = m_grabber.grabbedObject == null && num >= 0.9f;
			CollisionEnable(flag);
			UpdateAnimStates();
		}

		private void UpdateCapTouchStates()
		{
			m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);
			m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);
		}

		private void LateUpdate()
		{
			if (m_collisionEnabled && m_collisionScaleCurrent + Mathf.Epsilon < 1f)
			{
				m_collisionScaleCurrent = Mathf.Min(1f, m_collisionScaleCurrent + Time.deltaTime * 1f);
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider collider = m_colliders[i];
					collider.transform.localScale = new Vector3(m_collisionScaleCurrent, m_collisionScaleCurrent, m_collisionScaleCurrent);
				}
			}
		}

		private void OnInputFocusLost()
		{
		}

		private void OnInputFocusAcquired()
		{
			if (!m_restoreOnInputAcquired)
			{
				return;
			}
			for (int i = 0; i < m_showAfterInputFocusAcquired.Count; i++)
			{
				if ((bool)m_showAfterInputFocusAcquired[i])
				{
					m_showAfterInputFocusAcquired[i].enabled = true;
				}
			}
			m_showAfterInputFocusAcquired.Clear();
			m_restoreOnInputAcquired = false;
		}

		private float InputValueRateChange(bool isDown, float value)
		{
			float num = Time.deltaTime * 20f;
			float num2 = ((!isDown) ? (-1f) : 1f);
			return Mathf.Clamp01(value + num * num2);
		}

		private void UpdateAnimStates()
		{
			bool flag = m_grabber.grabbedObject != null;
			HandPose handPose = m_defaultGrabPose;
			if (flag)
			{
				HandPose component = m_grabber.grabbedObject.GetComponent<HandPose>();
				if (component != null)
				{
					handPose = component;
				}
			}
			HandPoseId poseId = handPose.PoseId;
			m_animator.SetInteger(m_animParamIndexPose, (int)poseId);
			float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			m_animator.SetFloat("Flex", num);
			if (num > 0.6f && !grabber.isGrabbingSomething())
			{
				Quaternion quaternion = base.transform.rotation * Quaternion.Euler(10f, 0f, 0f);
				if (UnityEngine.Application.loadedLevelName != "OceanRift_Startup_Void_SantaCruz")
				{
					AddPropellerForce(quaternion * Vector3.forward);
				}
				targetPropellerColor = defaultPropellerColor;
			}
			else
			{
				targetPropellerColor = offPropellerColor;
			}
			float num2 = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller);
			if (num > 0.1f)
			{
				num2 = 0f;
			}
			m_animator.SetFloat("Swimming", num2);
			if (num2 > 0.4f && !grabber.isGrabbingSomething())
			{
				if (UnityEngine.Application.loadedLevelName != "OceanRift_Startup_Void_SantaCruz")
				{
					AddStrokeForce(OVRInput.GetLocalControllerVelocity(m_controller));
				}
				targetHandColor = glowingHandColor;
			}
			else
			{
				targetHandColor = defaultHandColor;
			}
		}

		public void AddPropellerForce(Vector3 dir)
		{
			swimController.addSwimmingForce(dir * propellerForce * 0.01f);
		}

		public void AddStrokeForce(Vector3 velocity)
		{
			Vector3 vector = base.transform.root.rotation * -velocity;
			vector *= strokeCurve.Evaluate(velocity.magnitude / maxStrokeSpeed) * swimForce;
			vector = Vector3.ClampMagnitude(vector, maxStrokeSpeed);
			if (PlayerPrefs.GetInt("FlipControls") == 0)
			{
				vector *= -1f;
			}
			if (ui.isSwimControlsInverted())
			{
				vector *= -1f;
			}
			swimController.addSwimmingForce(vector * 0.01f);
		}

		private void CollisionEnable(bool enabled)
		{
			if (m_collisionEnabled == enabled)
			{
				return;
			}
			m_collisionEnabled = enabled;
			if (enabled)
			{
				m_collisionScaleCurrent = 0.01f;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider collider = m_colliders[i];
					collider.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
					collider.enabled = true;
				}
			}
			else
			{
				m_collisionScaleCurrent = 1f;
				for (int j = 0; j < m_colliders.Length; j++)
				{
					Collider collider2 = m_colliders[j];
					collider2.enabled = false;
					collider2.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
				}
			}
		}
	}
}
public class HandManager : MonoBehaviour
{
	public static HandManager instance;

	public Transform camera;

	public Transform leftHand;

	public Transform rightHand;

	public HandSensor leftHandSensor;

	public HandSensor rightHandSensor;

	private bool leftGrip;

	private bool rightGrip;

	private bool prevLeftGrip;

	private bool prevRightGrip;

	private bool leftHandGripping;

	private bool rightHandGripping;

	private float boost = 1.2f;

	private Grabbable leftGrabbedObject;

	private Grabbable rightGrabbedObject;

	private float prevCameraY;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		leftGrip = false;
		rightGrip = false;
		if (OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, OVRInput.Controller.Touch) > 0.75f)
		{
			leftGrip = true;
		}
		if (OVRInput.Get(OVRInput.Axis1D.SecondaryHandTrigger, OVRInput.Controller.Touch) > 0.75f)
		{
			rightGrip = true;
		}
		if (rightGrip && !prevRightGrip && !rightHandGripping)
		{
			if (rightHandSensor.getSensedObject() != null)
			{
				Grabbable component = rightHandSensor.getSensedObject().GetComponent<Grabbable>();
				component.grab(rightHand);
				rightHandGripping = true;
			}
		}
		else if (!rightGrip && prevRightGrip && rightHandGripping && rightHandSensor.getSensedObject() != null)
		{
			OVRPose oVRPose = default(OVRPose);
			oVRPose.position = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch);
			oVRPose.orientation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch);
			OVRPose oVRPose2 = oVRPose;
			OVRPose oVRPose3 = base.transform.ToOVRPose() * oVRPose2.Inverse();
			Transform root = camera.root;
			MonoBehaviour.print(root.localEulerAngles);
			Grabbable component2 = rightHandSensor.getSensedObject().GetComponent<Grabbable>();
			Vector3 localControllerVelocity = OVRInput.GetLocalControllerVelocity(OVRInput.Controller.RTouch);
			component2.release(oVRPose3.orientation * localControllerVelocity * boost, oVRPose3.orientation * OVRInput.GetLocalControllerAngularVelocity(OVRInput.Controller.RTouch) * boost);
			rightHandGripping = false;
		}
		CheckForRatchetOrTeleport();
		prevLeftGrip = leftGrip;
		prevRightGrip = rightGrip;
	}

	private void CheckForRatchetOrTeleport()
	{
		if (Mathf.Abs(Mathf.DeltaAngle(prevCameraY, camera.eulerAngles.y)) > 5f && rightHandSensor.getSensedObject() != null)
		{
			rightHandSensor.getSensedObject().GetComponent<Grabbable>().instantTeleportToHand();
		}
		prevCameraY = camera.eulerAngles.y;
	}
}
namespace OVRTouchSample
{
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall,
		Controller
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;
	}
}
public class HandSensor : MonoBehaviour
{
	private GameObject sensedObject;

	private void Start()
	{
	}

	private void LateUpdate()
	{
	}

	public GameObject getSensedObject()
	{
		return sensedObject;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Grabbable")
		{
			sensedObject = other.gameObject;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == "Grabbable")
		{
			sensedObject = null;
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.tag == "Grabbable")
		{
			sensedObject = other.gameObject;
		}
	}
}
public class LocalizeImage : MonoBehaviour
{
	public Texture questMessage_English;

	public Texture questMessage_French;

	public Texture questMessage_German;

	public Texture questMessage_Spanish;

	public Texture questMessage_Korean;

	public Texture questMessage_Japanese;

	public Texture questMessage_Cymraeg;

	private LocalisationManager.Language prevLanguage;

	private LocalisationManager.Language currLanguage;

	private Material material;

	private void Start()
	{
		material = GetComponent<Renderer>().material;
	}

	private void Update()
	{
		currLanguage = LocalisationManager.instance.selectedLanguage;
		if (currLanguage != prevLanguage)
		{
			SwapImages();
		}
		prevLanguage = currLanguage;
	}

	private void SwapImages()
	{
		switch (currLanguage)
		{
		case LocalisationManager.Language.English:
			material.mainTexture = questMessage_English;
			break;
		case LocalisationManager.Language.French:
			material.mainTexture = questMessage_French;
			break;
		case LocalisationManager.Language.German:
			material.mainTexture = questMessage_German;
			break;
		case LocalisationManager.Language.Spanish:
			material.mainTexture = questMessage_Spanish;
			break;
		case LocalisationManager.Language.Korean:
			material.mainTexture = questMessage_Korean;
			break;
		case LocalisationManager.Language.Japanese:
			material.mainTexture = questMessage_Japanese;
			break;
		case LocalisationManager.Language.Cymraeg:
			material.mainTexture = questMessage_Cymraeg;
			break;
		}
	}
}
public class LocalizeText : MonoBehaviour
{
	public string stringID;

	private TextMesh text;

	private void Start()
	{
		text = GetComponent<TextMesh>();
	}

	private void Update()
	{
		text.text = LocalisationManager.instance.getText(stringID);
	}
}
public class OVRGrabbableCustom : MonoBehaviour
{
	[SerializeField]
	public bool isSimpleFish = true;

	[SerializeField]
	protected bool m_kinematicWhenGrabbed = true;

	[SerializeField]
	protected bool m_allowOffhandGrab = true;

	[SerializeField]
	protected bool m_snapPosition;

	[SerializeField]
	protected bool m_snapOrientation;

	[SerializeField]
	public bool instantSnap;

	[SerializeField]
	public bool disableCollidersWhenGrabbed;

	[SerializeField]
	protected float m_MassDamper = 0.4f;

	[SerializeField]
	protected Transform m_snapOffset;

	[SerializeField]
	protected Collider[] m_grabPoints;

	protected bool m_grabbedKinematic;

	protected Collider m_grabbedCollider;

	protected OVRGrabberCustom m_grabbedBy;

	private Rigidbody[] rigidBodies;

	public float massDamper => m_MassDamper;

	public bool allowOffhandGrab => m_allowOffhandGrab;

	public bool isGrabbed => m_grabbedBy != null;

	public bool kinematicWhenGrabbed => m_kinematicWhenGrabbed;

	public bool snapPosition => m_snapPosition;

	public bool snapOrientation => m_snapOrientation;

	public Transform snapOffset => m_snapOffset;

	public OVRGrabberCustom grabbedBy => m_grabbedBy;

	public Transform grabbedTransform => m_grabbedCollider.transform;

	public Rigidbody grabbedRigidbody => m_grabbedCollider.attachedRigidbody;

	public Collider[] grabPoints => m_grabPoints;

	public virtual void GrabBegin(OVRGrabberCustom hand, Collider grabPoint)
	{
		m_grabbedBy = hand;
		m_grabbedCollider = grabPoint;
		if (isSimpleFish)
		{
			if (disableCollidersWhenGrabbed)
			{
				Collider component = GetComponent<Collider>();
				component.enabled = false;
			}
			SchoolChild component2 = base.transform.parent.GetComponent<SchoolChild>();
			SimpleFish component3 = base.transform.parent.GetComponent<SimpleFish>();
			SimpleFishAfraid component4 = base.transform.parent.GetComponent<SimpleFishAfraid>();
			if (component2 != null)
			{
				component2.SetGrabbed(hand.transform);
			}
			if (component3 != null)
			{
				component3.SetGrabbed(hand.transform);
			}
			if (component4 != null)
			{
				component4.SetGrabbed(hand.transform);
			}
		}
		else if (kinematicWhenGrabbed)
		{
			base.gameObject.GetComponent<Rigidbody>().isKinematic = true;
			SetKinematic();
		}
	}

	private IEnumerator TriggerHaptics(float freq = 1f, float amp = 0.1f)
	{
		yield return 0;
	}

	public virtual void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		if (isSimpleFish)
		{
			if (disableCollidersWhenGrabbed)
			{
				Collider component = GetComponent<Collider>();
				component.enabled = true;
			}
			SchoolChild component2 = base.transform.parent.GetComponent<SchoolChild>();
			SimpleFish component3 = base.transform.parent.GetComponent<SimpleFish>();
			SimpleFishAfraid component4 = base.transform.parent.GetComponent<SimpleFishAfraid>();
			if (component2 != null)
			{
				component2.SetGrabbed(null);
			}
			if (component3 != null)
			{
				component3.SetGrabbed(null);
			}
			if (component4 != null)
			{
				component4.SetGrabbed(null);
			}
		}
		else
		{
			Rigidbody component5 = base.gameObject.GetComponent<Rigidbody>();
			if (kinematicWhenGrabbed)
			{
				component5.isKinematic = m_grabbedKinematic;
				SetDynamic();
			}
			component5.velocity = linearVelocity;
			component5.angularVelocity = angularVelocity;
		}
		m_grabbedBy = null;
		m_grabbedCollider = null;
	}

	private void Awake()
	{
		if (m_grabPoints.Length == 0)
		{
			Collider component = GetComponent<Collider>();
			if (component == null)
			{
				throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
			}
			m_grabPoints = new Collider[1] { component };
		}
	}

	protected virtual void Start()
	{
		if (!isSimpleFish)
		{
			m_grabbedKinematic = GetComponent<Rigidbody>().isKinematic;
			rigidBodies = GetComponentsInChildren<Rigidbody>();
			Rigidbody[] array = rigidBodies;
			foreach (Rigidbody rigidbody in array)
			{
				rigidbody.maxAngularVelocity = float.PositiveInfinity;
			}
		}
	}

	private void SetDynamic()
	{
		Rigidbody[] array = rigidBodies;
		foreach (Rigidbody rigidbody in array)
		{
			rigidbody.isKinematic = false;
		}
	}

	private void SetKinematic()
	{
		Rigidbody[] array = rigidBodies;
		foreach (Rigidbody rigidbody in array)
		{
			rigidbody.isKinematic = true;
		}
	}

	public void SetAngularVelocity(Vector3 angularVelocity)
	{
		Rigidbody[] array = rigidBodies;
		foreach (Rigidbody rigidbody in array)
		{
			rigidbody.angularVelocity = angularVelocity;
		}
	}

	private void OnDestroy()
	{
		if (m_grabbedBy != null)
		{
			m_grabbedBy.ForceRelease(this);
		}
	}
}
[RequireComponent(typeof(Rigidbody))]
public class OVRGrabberCustom : MonoBehaviour
{
	public bool invisibleWhenGrabbing = true;

	public float grabBegin = 0.55f;

	public float grabEnd = 0.35f;

	[SerializeField]
	protected bool m_parentHeldObject;

	[SerializeField]
	protected Transform m_gripTransform;

	[SerializeField]
	protected Collider[] m_grabVolumes;

	[SerializeField]
	protected OVRInput.Controller m_controller;

	[SerializeField]
	protected Transform m_parentTransform;

	protected bool m_grabVolumeEnabled = true;

	protected Vector3 m_lastPos;

	protected Quaternion m_lastRot;

	protected Quaternion m_anchorOffsetRotation;

	protected Vector3 m_anchorOffsetPosition;

	protected float m_prevFlex;

	protected OVRGrabbableCustom m_grabbedObj;

	protected Vector3 m_grabbedObjectPosOff;

	protected Quaternion m_grabbedObjectRotOff;

	protected Dictionary<OVRGrabbableCustom, int> m_grabCandidates = new Dictionary<OVRGrabbableCustom, int>();

	protected bool operatingWithoutOVRCameraRig = true;

	private Vector3 startGrabPosition;

	private Quaternion startGrabRotation;

	private float grabStartTime;

	private float grabFlyTime = 0.15f;

	public float throwBoost = 1.5f;

	public Renderer handRenderer;

	private Vector3 lerpedAngularTarget;

	public OVRGrabbableCustom grabbedObject => m_grabbedObj;

	public void ForceRelease(OVRGrabbableCustom grabbable)
	{
		if (m_grabbedObj != null && m_grabbedObj == grabbable)
		{
			GrabEnd();
		}
	}

	protected virtual void Awake()
	{
		m_anchorOffsetPosition = base.transform.localPosition;
		m_anchorOffsetRotation = base.transform.localRotation;
		OVRCameraRig oVRCameraRig = null;
		if (base.transform.parent != null && base.transform.parent.parent != null)
		{
			oVRCameraRig = base.transform.parent.parent.GetComponent<OVRCameraRig>();
		}
		if (oVRCameraRig != null)
		{
			oVRCameraRig.UpdatedAnchors += delegate
			{
				OnUpdatedAnchors();
			};
			operatingWithoutOVRCameraRig = false;
		}
	}

	protected virtual void Start()
	{
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_parentTransform == null)
		{
			if (base.gameObject.transform.parent != null)
			{
				m_parentTransform = base.gameObject.transform.parent.transform;
				return;
			}
			m_parentTransform = new GameObject().transform;
			m_parentTransform.position = Vector3.zero;
			m_parentTransform.rotation = Quaternion.identity;
		}
	}

	private void FixedUpdate()
	{
		if (operatingWithoutOVRCameraRig)
		{
			OnUpdatedAnchors();
		}
		if (invisibleWhenGrabbing)
		{
			handRenderer.enabled = false;
		}
		if (m_grabbedObj == null && invisibleWhenGrabbing)
		{
			handRenderer.enabled = true;
		}
	}

	public OVRInput.Controller getController()
	{
		return m_controller;
	}

	private void OnUpdatedAnchors()
	{
		Vector3 localControllerPosition = OVRInput.GetLocalControllerPosition(m_controller);
		Quaternion localControllerRotation = OVRInput.GetLocalControllerRotation(m_controller);
		Vector3 position = m_parentTransform.TransformPoint(m_anchorOffsetPosition + localControllerPosition);
		Quaternion rot = m_parentTransform.rotation * localControllerRotation * m_anchorOffsetRotation;
		GetComponent<Rigidbody>().MovePosition(position);
		GetComponent<Rigidbody>().MoveRotation(rot);
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		float prevFlex = m_prevFlex;
		m_prevFlex = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
		CheckForGrabOrRelease(prevFlex);
	}

	private void OnDestroy()
	{
		if (m_grabbedObj != null)
		{
			GrabEnd();
		}
	}

	public bool isGrabbingSomething()
	{
		return m_grabbedObj != null;
	}

	private void OnTriggerStay(Collider otherCollider)
	{
		if (otherCollider.tag == "UIElement")
		{
			TouchUI.instance.setTouchedElement(otherCollider.gameObject);
		}
	}

	private void OnTriggerEnter(Collider otherCollider)
	{
		if (otherCollider.tag == "UIElement")
		{
			StartCoroutine(TriggerHaptics());
			return;
		}
		if (otherCollider.transform.parent != null && otherCollider.transform.parent.tag == "Info Sphere")
		{
			otherCollider.transform.parent.GetComponent<InfoSphere>().SwitchOnTouch();
			StartCoroutine(TriggerHaptics());
			return;
		}
		OVRGrabbableCustom oVRGrabbableCustom = otherCollider.GetComponent<OVRGrabbableCustom>() ?? otherCollider.GetComponentInParent<OVRGrabbableCustom>();
		if (!(oVRGrabbableCustom == null))
		{
			int value = 0;
			m_grabCandidates.TryGetValue(oVRGrabbableCustom, out value);
			m_grabCandidates[oVRGrabbableCustom] = value + 1;
			StartCoroutine(TriggerHaptics());
		}
	}

	private void OnTriggerExit(Collider otherCollider)
	{
		OVRGrabbableCustom oVRGrabbableCustom = otherCollider.GetComponent<OVRGrabbableCustom>() ?? otherCollider.GetComponentInParent<OVRGrabbableCustom>();
		if (oVRGrabbableCustom == null)
		{
			return;
		}
		int value = 0;
		if (m_grabCandidates.TryGetValue(oVRGrabbableCustom, out value))
		{
			if (value > 1)
			{
				m_grabCandidates[oVRGrabbableCustom] = value - 1;
			}
			else
			{
				m_grabCandidates.Remove(oVRGrabbableCustom);
			}
		}
	}

	protected void CheckForGrabOrRelease(float prevFlex)
	{
		if (m_prevFlex >= grabBegin && prevFlex < grabBegin)
		{
			GrabBegin();
		}
		else if (m_prevFlex <= grabEnd && prevFlex > grabEnd)
		{
			GrabEnd();
		}
	}

	protected virtual void GrabBegin()
	{
		grabStartTime = Time.time;
		float num = float.MaxValue;
		OVRGrabbableCustom oVRGrabbableCustom = null;
		Collider grabPoint = null;
		foreach (OVRGrabbableCustom key in m_grabCandidates.Keys)
		{
			if (key.isGrabbed && !key.allowOffhandGrab)
			{
				continue;
			}
			for (int i = 0; i < key.grabPoints.Length; i++)
			{
				Collider collider = key.grabPoints[i];
				Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
				float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					oVRGrabbableCustom = key;
					grabPoint = collider;
				}
			}
		}
		GrabVolumeEnable(enabled: false);
		if (!(oVRGrabbableCustom != null))
		{
			return;
		}
		if (oVRGrabbableCustom.isGrabbed)
		{
			oVRGrabbableCustom.grabbedBy.OffhandGrabbed(oVRGrabbableCustom);
		}
		m_grabbedObj = oVRGrabbableCustom;
		m_grabbedObj.GrabBegin(this, grabPoint);
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_grabbedObj.snapPosition)
		{
			m_grabbedObjectPosOff = new Vector3(0f, 0f, 0f);
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 vector2 = m_grabbedObj.snapOffset.localRotation * (m_grabbedObj.snapOffset.localPosition * m_grabbedObj.transform.localScale.z);
				m_grabbedObjectPosOff = -vector2;
			}
			if (m_grabbedObj.snapPosition)
			{
				startGrabPosition = m_grabbedObj.transform.position;
			}
		}
		else
		{
			Vector3 vector3 = m_grabbedObj.transform.position - base.transform.position;
			vector3 = Quaternion.Inverse(base.transform.rotation) * vector3;
			m_grabbedObjectPosOff = vector3;
		}
		if (m_grabbedObj.snapOrientation)
		{
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.localRotation;
			}
			else
			{
				m_grabbedObjectRotOff = Quaternion.identity;
			}
			startGrabRotation = m_grabbedObj.transform.rotation;
		}
		else
		{
			Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
			m_grabbedObjectRotOff = grabbedObjectRotOff;
		}
		MoveGrabbedObject(m_lastPos, m_lastRot, forceTeleport: true);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = base.transform;
		}
	}

	private IEnumerator TriggerHaptics(float freq = 0.1f, float amp = 0.2f, float duration = 0.03f)
	{
		OVRInput.Controller handedness = OVRInput.Controller.RTouch;
		OVRInput.SetControllerVibration(freq, amp, m_controller);
		yield return new WaitForSeconds(duration);
		OVRInput.SetControllerVibration(0f, 0f, m_controller);
		yield return 0;
	}

	protected virtual void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
	{
		if (m_grabbedObj.isSimpleFish)
		{
			return;
		}
		Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
		Vector3 vector = pos + rot * m_grabbedObjectPosOff;
		Quaternion quaternion = rot * m_grabbedObjectRotOff;
		Quaternion quaternion2 = quaternion;
		Vector3 vector2 = vector;
		if (!m_grabbedObj.instantSnap)
		{
			float num = (Time.time - grabStartTime) / grabFlyTime;
			if ((double)num < 1.0)
			{
				if (m_grabbedObj.snapPosition)
				{
					vector2 = Vector3.Lerp(startGrabPosition, vector, num);
				}
				if (m_grabbedObj.snapOrientation)
				{
					quaternion2 = Quaternion.Lerp(startGrabRotation, quaternion, num);
				}
			}
		}
		if (forceTeleport)
		{
			grabbedRigidbody.transform.position = vector2;
			grabbedRigidbody.transform.rotation = quaternion2;
			return;
		}
		if (m_grabbedObj.kinematicWhenGrabbed)
		{
			grabbedRigidbody.MovePosition(vector2);
			grabbedRigidbody.MoveRotation(quaternion2);
			return;
		}
		float maxDistanceDelta = 2f;
		float num2 = float.PositiveInfinity;
		Vector3 vector3 = vector2 - m_grabbedObj.transform.position;
		Vector3 vector4 = vector3 / Time.fixedDeltaTime;
		Vector3 velocity = Vector3.MoveTowards(grabbedRigidbody.velocity, vector4 * m_grabbedObj.massDamper, maxDistanceDelta);
		grabbedRigidbody.velocity = velocity;
		(quaternion2 * Quaternion.Inverse(m_grabbedObj.transform.rotation)).ToAngleAxis(out var angle, out var axis);
		angle = ((!(angle > 180f)) ? angle : (angle -= 360f));
		float num3 = 20f;
		if (angle != 0f)
		{
			Vector3 target = angle * axis * num3;
			target *= Time.fixedDeltaTime;
			Vector3 angularVelocity = Vector3.MoveTowards(grabbedRigidbody.angularVelocity, target, 10f);
			if (num2 == float.PositiveInfinity || angularVelocity.sqrMagnitude < num2)
			{
				m_grabbedObj.SetAngularVelocity(angularVelocity);
			}
		}
	}

	protected void GrabEnd()
	{
		if (m_grabbedObj != null)
		{
			OVRPose oVRPose = default(OVRPose);
			oVRPose.position = OVRInput.GetLocalControllerPosition(m_controller);
			oVRPose.orientation = OVRInput.GetLocalControllerRotation(m_controller);
			OVRPose oVRPose2 = oVRPose;
			oVRPose = default(OVRPose);
			oVRPose.position = m_anchorOffsetPosition;
			oVRPose.orientation = m_anchorOffsetRotation;
			OVRPose oVRPose3 = oVRPose;
			oVRPose2 *= oVRPose3;
			OVRPose oVRPose4 = base.transform.ToOVRPose() * oVRPose2.Inverse();
			Vector3 vector = oVRPose4.orientation * OVRInput.GetLocalControllerVelocity(m_controller);
			Vector3 angularVelocity = oVRPose4.orientation * OVRInput.GetLocalControllerAngularVelocity(m_controller);
			GrabbableRelease(vector * throwBoost, angularVelocity);
		}
		GrabVolumeEnable(enabled: true);
	}

	protected void GrabbableRelease(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		m_grabbedObj.GrabEnd(linearVelocity, angularVelocity);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = null;
		}
		m_grabbedObj = null;
	}

	protected virtual void GrabVolumeEnable(bool enabled)
	{
		if (m_grabVolumeEnabled != enabled)
		{
			m_grabVolumeEnabled = enabled;
			for (int i = 0; i < m_grabVolumes.Length; i++)
			{
				Collider collider = m_grabVolumes[i];
				collider.enabled = m_grabVolumeEnabled;
			}
			if (!m_grabVolumeEnabled)
			{
				m_grabCandidates.Clear();
			}
		}
	}

	protected virtual void OffhandGrabbed(OVRGrabbableCustom grabbable)
	{
		if (m_grabbedObj == grabbable)
		{
			GrabbableRelease(Vector3.zero, Vector3.zero);
		}
	}
}
public class SantaCruzControl : MonoBehaviour
{
	private TouchUI ui;

	private TreasureScanner scanner;

	private OVRSwimController swimController;

	private Transform camera;

	private Vector2 prevSecondaryTHumbstick;

	private bool ratchetLock;

	private void Start()
	{
		ui = TouchUI.instance;
		scanner = GetComponentInChildren<TreasureScanner>();
		swimController = GetComponent<OVRSwimController>();
		camera = LAC_VRCameraRig.instance.getCenterCamera().transform;
	}

	private void DropObjectIntoWater()
	{
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Dolphins" || UnityEngine.Application.loadedLevelName == "OceanRift_SeaLions")
		{
			ui.DropRingIntoWater();
		}
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Orcas")
		{
			ui.DropOrcaFoodIntoWater();
		}
	}

	private void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.LTouch) || OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.RTouch))
		{
			ui.ToggleOnOff();
		}
		if (OVRInput.GetDown(OVRInput.Button.Start, OVRInput.Controller.LTouch) || OVRInput.GetDown(OVRInput.Button.Start, OVRInput.Controller.RTouch))
		{
			ui.ToggleOnOff();
		}
		if (OVRInput.GetDown(OVRInput.Button.Two, OVRInput.Controller.LTouch) || OVRInput.GetDown(OVRInput.Button.Two, OVRInput.Controller.RTouch))
		{
			if (scanner.isBeingLookedAt())
			{
				scanner.nextTarget();
			}
			else
			{
				DropObjectIntoWater();
			}
		}
		if (OVRInput.GetDown(OVRInput.Button.SecondaryThumbstickLeft))
		{
			RatchetRotateLeft();
		}
		if (OVRInput.GetDown(OVRInput.Button.SecondaryThumbstickRight))
		{
			RatchetRotateRight();
		}
		float num = 0.1f;
		float num2 = 1.5f;
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
		Vector3 forward = camera.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 right = camera.right;
		right.y = 0f;
		right.Normalize();
		if (UnityEngine.Application.loadedLevelName != "OceanRift_Startup_Void_SantaCruz")
		{
			if (Mathf.Abs(vector.x) > num)
			{
				swimController.addSwimmingForce(right * vector.x * Time.deltaTime * num2 * 0.8f);
			}
			if (Mathf.Abs(vector.y) > num)
			{
				swimController.addSwimmingForce(forward * vector.y * Time.deltaTime * num2);
			}
		}
	}

	public void RatchetRotateLeft()
	{
		if (!ui.isSwichedOn() && !ui.isShowingSomething())
		{
			ui.RefreshPlayerColliderPosition();
			base.transform.RotateAround(camera.position, new Vector3(0f, 1f, 0f), -45f);
		}
		else
		{
			ui.RatchetRotateLeft();
		}
	}

	public void RatchetRotateRight()
	{
		if (!ui.isSwichedOn() && !ui.isShowingSomething())
		{
			ui.RefreshPlayerColliderPosition();
			base.transform.RotateAround(camera.position, new Vector3(0f, 1f, 0f), 45f);
		}
		else
		{
			ui.RatchetRotateRight();
		}
	}
}
public class SantaCruzControllerOptions : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class SharkCageReposition : MonoBehaviour
{
	private Transform player;

	private void Start()
	{
		player = LAC_VRCameraRig.instance.getCenterCamera().transform;
		base.transform.position = player.position;
	}
}
public class ScannerAnimalInfo
{
	public Texture texture;

	public string text;

	public List<Transform> transformList = new List<Transform>();

	public ScannerAnimalInfo()
	{
		transformList = new List<Transform>();
	}
}
public class TreasureScanner : MonoBehaviour
{
	private float closestBogey;

	public float updateRate = 1f;

	public float mapScale = 10f;

	public float blipYOffset;

	public float headTrackSpeed = 1f;

	public GameObject alienBlipPrefab;

	public GameObject powerupBlipPrefab;

	private GameObject camera;

	private float updateTimer;

	private GameObject player;

	public Transform screenTransform;

	public float minFadeAngle = 10f;

	public float maxFadeAngle = 30f;

	private Material screenMaterial;

	public AnimationCurve headTrackCurve;

	private float currentAlpha;

	private float targetAlpha;

	private float baseAlpha;

	public AudioClip radarClick;

	public AudioClip radarPing;

	public Transform pulseRing;

	private Material pulseRingMaterial;

	private Color pulseRingColor;

	public Vector2 radarPulseRingMinMax = new Vector2(0f, 1f);

	public float radarPulseTime = 0.5f;

	public AnimationCurve radarPulseAlphaCurve;

	private AudioSource audioSource;

	public float inViewVolume = 0.5f;

	public float outsideViewVolume = 0.2f;

	public Vector2 scannerPitchRange = new Vector2(1f, 1f);

	public float maxSonarDopplerDistance = 10f;

	private float targetVolume;

	private bool active;

	public float maxDistance = 30f;

	public AnimationCurve scannerFadeAngleCurve;

	public Texture infoSpheresIcon;

	public Renderer targetIconRenderer;

	public TextMesh targetDetails;

	private Material targetIconMaterial;

	private List<ScannerAnimalInfo> scannerAnimalInfos = new List<ScannerAnimalInfo>();

	private TouchUI ui;

	private int currTargetIndex;

	public Renderer textRenderer;

	public Renderer iconRenderer;

	private Material textMaterial;

	private Material iconMaterial;

	private Color textDefaultColor;

	private Color iconDefaultColor;

	private bool switchedOn = true;

	private bool noInfoSpheres;

	private LocalisationManager.Language prevLanguage;

	private LocalisationManager.Language currLanguage;

	private void Start()
	{
		player = GameObject.Find("Player");
		camera = LAC_VRCameraRig.instance.getCenterCamera().gameObject;
		screenMaterial = screenTransform.GetComponent<Renderer>().material;
		pulseRingMaterial = pulseRing.GetComponent<Renderer>().material;
		currentAlpha = 0f;
		baseAlpha = screenMaterial.GetColor("_TintColor").a;
		pulseRingColor = pulseRingMaterial.GetColor("_TintColor");
		audioSource = GetComponent<AudioSource>().GetComponent<AudioSource>();
		ui = base.transform.root.GetComponentInChildren<TouchUI>();
		targetIconMaterial = targetIconRenderer.material;
		textMaterial = textRenderer.material;
		iconMaterial = iconRenderer.material;
		textDefaultColor = textMaterial.GetColor("_Color");
		iconDefaultColor = iconMaterial.GetColor("_TintColor");
		RebuildLibrary();
		StartCoroutine(checkEducationMode());
	}

	private IEnumerator checkEducationMode()
	{
		bool prevEduMode = ui.isEducationLayerActive();
		while (true)
		{
			yield return new WaitForSeconds(1f);
			if (prevEduMode != ui.isEducationLayerActive() && currTargetIndex == 0 && !ui.isEducationLayerActive() && !noInfoSpheres)
			{
				nextTarget();
			}
			prevEduMode = ui.isEducationLayerActive();
		}
	}

	public void nextTarget()
	{
		if (!noInfoSpheres)
		{
			currTargetIndex++;
			if (currTargetIndex > scannerAnimalInfos.Count - 1)
			{
				currTargetIndex = 0;
			}
			if (!ui.isEducationLayerActive() && LocalisationManager.instance.selectedLanguage == LocalisationManager.Language.English)
			{
				currTargetIndex = Mathf.Clamp(currTargetIndex, 1, scannerAnimalInfos.Count - 1);
			}
			targetIconMaterial.mainTexture = scannerAnimalInfos[currTargetIndex].texture;
			targetDetails.text = scannerAnimalInfos[currTargetIndex].text;
		}
	}

	public void RebuildLibrary()
	{
		StartCoroutine(RebuildLibraryDelayed());
	}

	private IEnumerator RebuildLibraryDelayed()
	{
		yield return 0;
		Rebuild();
	}

	public bool isBeingLookedAt()
	{
		if (currentAlpha > 0.05f)
		{
			return true;
		}
		return false;
	}

	private void Rebuild()
	{
		currTargetIndex = 0;
		scannerAnimalInfos.Clear();
		InfoSphere[] array = (from m in UnityEngine.Object.FindObjectsOfType<InfoSphere>()
			orderby (m.transform.position - camera.transform.position).magnitude
			select m).ToArray();
		if (array.Length == 0)
		{
			noInfoSpheres = true;
		}
		else
		{
			noInfoSpheres = false;
		}
		if (noInfoSpheres)
		{
			targetDetails.gameObject.SetActive(value: false);
			targetIconRenderer.gameObject.SetActive(value: false);
		}
		else
		{
			targetDetails.gameObject.SetActive(value: true);
			targetIconRenderer.gameObject.SetActive(value: true);
		}
		if (array.Length > 0)
		{
			if (LocalisationManager.instance.selectedLanguage == LocalisationManager.Language.English)
			{
				ScannerAnimalInfo scannerAnimalInfo = new ScannerAnimalInfo();
				scannerAnimalInfo.texture = infoSpheresIcon;
				scannerAnimalInfo.text = "Animal Info Points\n(" + array.Length + " in habitat)";
				InfoSphere[] array2 = array;
				foreach (InfoSphere infoSphere in array2)
				{
					scannerAnimalInfo.transformList.Add(infoSphere.transform);
				}
				scannerAnimalInfos.Add(scannerAnimalInfo);
			}
			InfoSphere[] array3 = array;
			foreach (InfoSphere infoSphere2 in array3)
			{
				ScannerAnimalInfo scannerAnimalInfo2 = new ScannerAnimalInfo();
				scannerAnimalInfo2.texture = infoSphere2.iconTexture;
				string text = LocalisationManager.instance.getText(infoSphere2.idName);
				string text2 = infoSphere2.latinName;
				if (infoSphere2.idName == "ANIMAL_34")
				{
					text2 = LocalisationManager.instance.getText("MISC_1");
				}
				scannerAnimalInfo2.text = text + "\n(" + text2 + ")";
				GameObject[] array4 = GameObject.FindGameObjectsWithTag("Creature");
				GameObject[] array5 = array4;
				foreach (GameObject gameObject in array5)
				{
					string[] scannerSearchTerms = infoSphere2.scannerSearchTerms;
					foreach (string value in scannerSearchTerms)
					{
						if (gameObject.name.Contains(value))
						{
							Transform transform = null;
							if (infoSphere2.scannerTrackableName != string.Empty)
							{
								transform = GetChildGameObject(gameObject.gameObject, infoSphere2.scannerTrackableName).transform;
							}
							if (transform != null)
							{
								scannerAnimalInfo2.transformList.Add(transform);
							}
							else if (infoSphere2.scannerTrackableName == string.Empty)
							{
								scannerAnimalInfo2.transformList.Add(gameObject.transform);
							}
						}
					}
				}
				if (!infoSphere2.hideDetailsFromScanner)
				{
					scannerAnimalInfos.Add(scannerAnimalInfo2);
				}
			}
			if (scannerAnimalInfos.Count > 0)
			{
			}
			targetIconMaterial.mainTexture = scannerAnimalInfos[0].texture;
			targetDetails.text = scannerAnimalInfos[0].text;
		}
		if (!ui.isEducationLayerActive())
		{
			nextTarget();
		}
	}

	public static GameObject GetChildGameObject(GameObject fromGameObject, string withName)
	{
		int childCount = fromGameObject.transform.GetChildCount();
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < childCount; i++)
		{
			list.Add(fromGameObject.transform.GetChild(i));
		}
		foreach (Transform item in list)
		{
			if (item.gameObject.name == withName)
			{
				return item.gameObject;
			}
			GameObject childGameObject = GetChildGameObject(item.gameObject, withName);
			if (childGameObject != null)
			{
				return childGameObject;
			}
		}
		return null;
	}

	private void Update()
	{
		currLanguage = LocalisationManager.instance.selectedLanguage;
		if (currLanguage != prevLanguage)
		{
			Rebuild();
		}
		if (ui.isScannerActive())
		{
			switchedOn = true;
		}
		else
		{
			switchedOn = false;
		}
		if (switchedOn)
		{
			screenTransform.gameObject.SetActive(value: true);
			pulseRing.gameObject.SetActive(value: true);
			updateTimer += Time.deltaTime;
			targetAlpha = 0.6f;
			audioSource.volume = Mathf.Lerp(audioSource.volume, targetVolume, Time.deltaTime * 3f);
			if (updateTimer > updateRate)
			{
				CreateBlipsForEnemies();
				updateTimer = 0f;
			}
			Vector3 to = screenTransform.rotation * Quaternion.Euler(-20f, 0f, 0f) * Vector3.forward;
			float num = Vector3.Angle(camera.transform.forward, to);
			float num2 = Vector3.Angle(camera.transform.right, screenTransform.right);
			float num3 = num / 20f;
			float num4 = num2 / 20f;
			num3 *= num4;
			Vector3 localEulerAngles = screenTransform.localEulerAngles;
			float num5 = scannerFadeAngleCurve.Evaluate(num3);
			targetAlpha *= num5;
			Color color = screenMaterial.GetColor("_TintColor");
			currentAlpha = Mathf.Lerp(currentAlpha, targetAlpha, Time.deltaTime * 10f);
			color.a = currentAlpha;
			screenMaterial.SetColor("_TintColor", color);
			num3 = Mathf.Clamp01(updateTimer / radarPulseTime);
			float num6 = Mathf.Lerp(radarPulseRingMinMax.x, radarPulseRingMinMax.y, num3);
			pulseRing.transform.localScale = new Vector3(num6, num6, num6);
			pulseRingColor.a = radarPulseAlphaCurve.Evaluate(num3) * currentAlpha;
			pulseRingMaterial.SetColor("_TintColor", pulseRingColor);
			active = false;
			if (currentAlpha > 0.15f)
			{
				targetVolume = Mathf.Lerp(targetVolume, inViewVolume, Time.deltaTime * 5f);
			}
			else
			{
				targetVolume = Mathf.Lerp(targetVolume, outsideViewVolume, Time.deltaTime * 5f);
			}
			Color value = textDefaultColor;
			value.a = currentAlpha * 3f;
			textMaterial.SetColor("_Color", value);
			value = iconDefaultColor;
			value.a = currentAlpha * 3f;
			iconMaterial.SetColor("_TintColor", value);
		}
		else
		{
			active = false;
			targetAlpha = 0f;
			Color value2 = new Color(1f, 1f, 1f, 0f);
			textMaterial.SetColor("_Color", value2);
			iconMaterial.SetColor("_TintColor", value2);
			screenTransform.gameObject.SetActive(value: false);
			pulseRing.gameObject.SetActive(value: false);
		}
		prevLanguage = currLanguage;
	}

	public float getUpdateTimer()
	{
		return updateTimer;
	}

	public void Activate()
	{
		active = true;
	}

	private void PlaySonarSound()
	{
		float pitch = Mathf.Lerp(scannerPitchRange.y, scannerPitchRange.x, closestBogey / maxSonarDopplerDistance);
		audioSource.pitch = pitch;
		audioSource.PlayOneShot(radarPing);
	}

	private void CreateBlipsForEnemies()
	{
		closestBogey = float.PositiveInfinity;
		if (scannerAnimalInfos.Count <= 0)
		{
			return;
		}
		List<Transform> transformList = scannerAnimalInfos[currTargetIndex].transformList;
		foreach (Transform item in transformList)
		{
			DrawBlip(item.gameObject);
		}
		if (transformList.Count == 0)
		{
			audioSource.PlayOneShot(radarClick);
		}
		else
		{
			PlaySonarSound();
		}
	}

	private void DrawBlip(GameObject thing)
	{
		Vector3 position = screenTransform.position;
		Vector3 position2 = thing.transform.position;
		Vector3 vector = position;
		Vector3 vector2 = position2;
		vector.y = 0f;
		vector2.y = 0f;
		float magnitude = (vector - vector2).magnitude;
		bool flag = false;
		if (currTargetIndex == 0 && magnitude > maxDistance)
		{
			magnitude = maxDistance;
			flag = true;
		}
		float y = position.x - position2.x;
		float x = position.z - position2.z;
		float num = Mathf.Atan2(y, x) * 57.29578f - 270f - camera.transform.eulerAngles.y;
		float num2 = magnitude * Mathf.Cos(num * ((float)Math.PI / 180f));
		float num3 = magnitude * Mathf.Sin(num * ((float)Math.PI / 180f));
		num2 = (0f - num2) * (mapScale / maxDistance);
		num3 *= mapScale / maxDistance;
		if (magnitude <= maxDistance)
		{
			if (magnitude < closestBogey)
			{
				closestBogey = magnitude;
			}
			Vector3 vector3 = new Vector3(position.x, position.y, position.z);
			Vector3 vector4 = screenTransform.rotation * new Vector3(num2, num3, 0f);
			GameObject gameObject = UnityEngine.Object.Instantiate(alienBlipPrefab, vector3 - vector4, screenTransform.rotation);
			if (flag)
			{
				gameObject.GetComponent<Blip>().SetMultiplyAlpha(0.25f);
			}
			gameObject.transform.parent = screenTransform;
		}
	}
}
public class VersionNumber : MonoBehaviour
{
	private TextMesh textMesh;

	private void Start()
	{
		textMesh = GetComponent<TextMesh>();
		textMesh.text = "v" + UnityEngine.Application.version;
	}
}
public class Screenshotter : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.K))
		{
			ScreenCapture.CaptureScreenshot(Time.time.ToString(), 4);
		}
	}
}
public class ScriptableWindzoneInterface : MonoBehaviour
{
	private Component m_WindzoneComponent;

	private Type m_WindzoneType;

	private object[] m_WindZoneArgs = new object[1];

	public float Radius
	{
		get
		{
			return (float)GetWindZoneValue("get_radius");
		}
		set
		{
			m_WindZoneArgs[0] = value;
			SetWindZoneValue("set_radius", m_WindZoneArgs);
		}
	}

	public float WindMain
	{
		get
		{
			return (float)GetWindZoneValue("get_windMain");
		}
		set
		{
			m_WindZoneArgs[0] = value;
			SetWindZoneValue("set_windMain", m_WindZoneArgs);
		}
	}

	public float WindTurbulence
	{
		get
		{
			return (float)GetWindZoneValue("get_windTurbulence");
		}
		set
		{
			m_WindZoneArgs[0] = value;
			SetWindZoneValue("set_windTurbulence", m_WindZoneArgs);
		}
	}

	public float WindPulseMagnitude
	{
		get
		{
			return (float)GetWindZoneValue("get_windPulseMagnitude");
		}
		set
		{
			m_WindZoneArgs[0] = value;
			SetWindZoneValue("set_windPulseMagnitude", m_WindZoneArgs);
		}
	}

	public float WindPulseFrequency
	{
		get
		{
			return (float)GetWindZoneValue("get_windPulseFrequency");
		}
		set
		{
			m_WindZoneArgs[0] = value;
			SetWindZoneValue("set_windPulseFrequency", m_WindZoneArgs);
		}
	}

	public void Init()
	{
		m_WindzoneComponent = GetComponent("WindZone");
		if (m_WindzoneComponent == null)
		{
			Debug.LogError("Could not find a wind zone to link to: " + this);
			base.enabled = false;
		}
		else
		{
			m_WindzoneType = m_WindzoneComponent.GetType();
		}
	}

	private void SetWindZoneValue(string MemberName, object[] args)
	{
		m_WindzoneType.InvokeMember(MemberName, BindingFlags.Instance | BindingFlags.InvokeMethod, null, m_WindzoneComponent, args);
	}

	private object GetWindZoneValue(string MemberName)
	{
		return m_WindzoneType.InvokeMember(MemberName, BindingFlags.Instance | BindingFlags.InvokeMethod, null, m_WindzoneComponent, null);
	}
}
public class ScrollTexture : MonoBehaviour
{
	public float scrollSpeed;

	private void Start()
	{
	}

	private void Update()
	{
		float y = Time.time * scrollSpeed;
		GetComponent<Renderer>().material.SetTextureOffset("_BumpMap", new Vector2(0f, y));
	}
}
public class SeaTurtle : MonoBehaviour
{
	public Transform theModel;

	public Rigidbody body;

	public float defaultSpeed;

	public float minDriftSpeed;

	public float fastestSpeed;

	public float maxAcceleration = 0.1f;

	public float speedDecay = 0.0001f;

	public float turnSpeed;

	private Vector3 moveDirection;

	private float swimTimer;

	public Transform target;

	public Transform possibleTarget;

	public float defaultRotateToTargetSpeed;

	public float swimAmplitudeMinX;

	public float swimAmplitudeMaxX = 100f;

	public float swimAmplitudeMinY;

	public float swimAmplitudeMaxY = 30f;

	public Vector2 swimFreqRangeX = new Vector2(0f, 1f);

	public Vector2 swimFreqRangeY = new Vector2(0f, 2f);

	public int friendliness = 3000;

	public int faithfulness = 300;

	public int speedChangeChance = 200;

	public bool bob;

	public float bobAmount;

	private float angleX;

	private float angleY;

	public float targetSpeed;

	private float moveSpeed;

	private float moveError;

	private Quaternion swimComponent;

	private Vector3 targetDir;

	private Quaternion targetQuat;

	private Quaternion rot;

	private float swimAmplitudeX;

	private float swimAmplitudeY;

	private float swimAmplitudeZ;

	private float swimFrequencyX;

	private float swimFrequencyY;

	private float rotateToTargetSpeed;

	private Vector3 targetPos;

	private Transform waterSurface;

	public float maxAnimSpeed = 1f;

	public float minAnimSpeed = 0.1f;

	private float headingAngle;

	private float animSpeed;

	private SkinnedMeshRenderer meshRenderer;

	private Transform myTransform;

	private int sampleAngleEvery = 10;

	private int headingSamplerCounter;

	private bool prevWasDrawStroke;

	private FlipperAnimator FlipperAnimator;

	private float bobbingPitch;

	public float maxBobbingPitch = 45f;

	public AnimationCurve bobbingCurve;

	private void Start()
	{
		FlipperAnimator = base.transform.GetComponent<FlipperAnimator>();
		SkinnedMeshRenderer[] componentsInChildren = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren)
		{
			meshRenderer = skinnedMeshRenderer;
		}
		headingAngle = 0f;
		swimTimer = 0f;
		targetSpeed = defaultSpeed;
		rotateToTargetSpeed = defaultRotateToTargetSpeed;
		targetPos = target.position;
		myTransform = theModel.transform;
		headingSamplerCounter = 0;
	}

	private void FixedUpdate()
	{
		if (Random.Range(0, speedChangeChance) == 1)
		{
			float num = Random.Range(defaultSpeed, fastestSpeed);
			if (num > moveSpeed)
			{
				targetSpeed = num;
			}
			swimAmplitudeX = Random.Range(swimAmplitudeMinX, swimAmplitudeMaxX);
			swimAmplitudeY = Random.Range(swimAmplitudeMinY, swimAmplitudeMaxY);
			swimFrequencyX = Random.Range(swimFreqRangeX.x, swimFreqRangeX.y);
			swimFrequencyY = Random.Range(swimFreqRangeY.x, swimFreqRangeY.y);
		}
	}

	private void Update()
	{
		float magnitude = (theModel.position - target.position).magnitude;
		if (magnitude < 1.5f)
		{
			target.GetComponent<MovingTarget>().change();
		}
		if (FlipperAnimator.isPerformingDrawstroke())
		{
			targetPos = Vector3.Lerp(targetPos, target.position, Time.deltaTime * 0.1f);
		}
		moveError = targetSpeed - moveSpeed;
		if (moveError > 0.001f)
		{
			moveSpeed += maxAcceleration;
		}
		else
		{
			moveSpeed -= maxAcceleration;
		}
		moveSpeed = Mathf.Clamp(moveSpeed * FlipperAnimator.getSpeedTurnModifier(), minDriftSpeed, fastestSpeed);
		moveDirection = new Vector3(0f, 0f, 1f);
		myTransform.Translate(moveDirection * Time.deltaTime * (moveSpeed * FlipperAnimator.getStrokeSpeedWeight()));
		angleX = Mathf.Sin(swimFrequencyX * swimTimer);
		angleY = Mathf.Sin(swimFrequencyY * swimTimer);
		swimComponent = Quaternion.Euler(Vector3.up * Time.deltaTime * angleX * swimAmplitudeX * turnSpeed);
		float num = bobbingCurve.Evaluate(FlipperAnimator.getStrokeTimer());
		float num2 = (1f - num) * (0f - maxBobbingPitch) + num * maxBobbingPitch;
		swimComponent *= Quaternion.Euler(Vector3.right * num2);
		float num3 = 45f;
		float num4 = 0.25f;
		float z = myTransform.localEulerAngles.z;
		float num5 = Mathf.Clamp(Mathf.Abs(headingAngle), 0f, 40f) / 90f;
		float num6 = 1f;
		if (headingAngle < 0f)
		{
			num6 = -1f;
		}
		swimComponent *= Quaternion.Euler(Vector3.forward * num5 * (0f - num4) * num6);
		targetDir = targetPos - myTransform.position;
		targetQuat = Quaternion.LookRotation(targetDir);
		rot = Quaternion.Slerp(myTransform.rotation, targetQuat, rotateToTargetSpeed * FlipperAnimator.getRotationalDampener() * FlipperAnimator.getRotationalAccelerator() * 0.1f * Time.deltaTime);
		myTransform.rotation = rot * swimComponent;
		Vector3 localEulerAngles = myTransform.localEulerAngles;
		if (headingSamplerCounter > sampleAngleEvery)
		{
			headingAngle = getAngle(theModel.rotation, targetQuat);
			headingSamplerCounter = 0;
		}
		headingSamplerCounter++;
		swimTimer += Time.deltaTime;
		if (moveSpeed > defaultSpeed)
		{
			targetSpeed -= speedDecay;
		}
	}

	public float getHeadingAngle()
	{
		return headingAngle;
	}

	private float getAngle(Quaternion q1, Quaternion q2)
	{
		Vector3 vector = q1 * Vector3.forward;
		Vector3 vector2 = q2 * Vector3.forward;
		float current = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
		float num = Mathf.Atan2(vector2.x, vector2.z) * 57.29578f;
		return Mathf.DeltaAngle(current, num);
	}

	public void setTargetSpeed(float val)
	{
		targetSpeed = val;
	}

	public void setSwimFrequencyX(float val)
	{
		swimFrequencyX = val;
	}

	public void setSwimFrequencyY(float val)
	{
		swimFrequencyY = val;
	}

	public void setSwimAmplitudeX(float val)
	{
		swimAmplitudeX = val;
	}

	public void setSwimAmplitudeY(float val)
	{
		swimAmplitudeY = val;
	}
}
public class SetGravity : MonoBehaviour
{
	public Vector3 gravity = new Vector3(0f, -9.8f, 0f);

	private void Start()
	{
		Physics.gravity = gravity;
	}

	private void Update()
	{
	}
}
public class ShaderPreloader : MonoBehaviour
{
	public Shader[] ShadersToPreload = new Shader[0];

	private bool _firstUpdate = true;

	private void Start()
	{
		_firstUpdate = true;
	}

	private void Update()
	{
		if (_firstUpdate)
		{
			Shader.WarmupAllShaders();
			for (int i = 0; i < ShadersToPreload.Length; i++)
			{
				UnityEngine.Object.DontDestroyOnLoad(ShadersToPreload[i]);
			}
			_firstUpdate = false;
		}
	}
}
public class SharkCage : MonoBehaviour
{
	private float timer;

	private float waveslice;

	private Vector3 transformPos;

	public float bobbingSpeed = 0.01f;

	public Vector3 bobbingAmount;

	private Vector3 originalPos;

	public float shakeCageTime = 1f;

	private float shakeCageTimer;

	private Vector3 sharkNormal;

	private Vector3 shakeTargetPos;

	public float shakeDistance = 0.5f;

	private void Start()
	{
		originalPos = base.transform.localPosition;
	}

	private void FixedUpdate()
	{
		if (shakeCageTimer > 0f)
		{
			base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, shakeTargetPos, Time.deltaTime);
		}
		else
		{
			waveslice = Mathf.Sin(timer);
			timer += bobbingSpeed;
			if (timer > (float)Math.PI * 2f)
			{
				timer -= (float)Math.PI * 2f;
			}
			transformPos.x = originalPos.x + waveslice * bobbingAmount.x;
			transformPos.y = originalPos.y + waveslice * bobbingAmount.y;
			transformPos.z = originalPos.z + waveslice * bobbingAmount.z;
			base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, transformPos, Time.deltaTime * 1f);
		}
		shakeCageTimer -= Time.deltaTime;
	}

	private void SharkHasHit(Vector3 normal)
	{
		sharkNormal = normal;
		shakeCageTimer = shakeCageTime;
		shakeTargetPos = originalPos + -sharkNormal * shakeDistance;
	}
}
public class SpiderCrab : MonoBehaviour
{
	public float speed = 1f;

	public float speedPercentNoise = 0.2f;

	public Vector3 moveDir;

	public float rotateSpeed;

	public LayerMask raycastLayers;

	public float raycastHeight = 5f;

	public float stepHeight = 1f;

	public float stepSpeed = 2f;

	public float footComfortDistance = 1f;

	public AnimationCurve stepYOffset;

	private Quaternion lastRotation;

	private float rotationMagnitude;

	private Vector3 rotationAxis;

	public ProceduralLimb[] limbs;

	public Transform hips;

	public Vector3 defaultHipPosition;

	private float stepTimer;

	private float speedNoise;

	private int[] legIndices;

	private Vector3 actualTargetPos;

	private float actualTargetYaw;

	public int changeDirectionChance = 500;

	private float targetYaw;

	public MovingTarget target;

	private float speedNoiseTimer;

	public float speedNoiseFrequency = 0.5f;

	public float stepFrequency = 2f;

	private bool stepped1;

	private bool stepped2;

	private bool stepped3;

	private bool stepped4;

	private bool stepped5;

	private bool stepped6;

	private bool stepped7;

	private bool stepped8;

	private int prevIndex = -1;

	private int currIndex;

	private bool firstTripodStepped;

	private bool secondTripodStepped;

	public float targetHipHeight = 3f;

	public float bobFrequency = 0.5f;

	public float bobAmplitude = 1f;

	private float bobTimer;

	private float targetHeight;

	private Quaternion targetRotation;

	public Vector3 angularVelocity => rotationAxis * rotationMagnitude / Time.deltaTime;

	private void Start()
	{
		lastRotation = base.transform.rotation;
		defaultHipPosition = hips.position;
		legIndices = new int[8];
		for (int i = 0; i < 8; i++)
		{
			legIndices[i] = i;
		}
		shuffle(legIndices);
	}

	public Vector3 getVelocity()
	{
		return hips.rotation * moveDir * (0f - speed);
	}

	public float getScale()
	{
		return base.transform.lossyScale.x;
	}

	private void shuffle(int[] array)
	{
		for (int i = 0; i < array.Length; i++)
		{
			int num = array[i];
			int num2 = Random.Range(i, array.Length);
			array[i] = array[num2];
			array[num2] = num;
		}
	}

	private void Update()
	{
		if (Random.Range(0, changeDirectionChance) == 1)
		{
			targetYaw = Random.Range(-180, 180);
		}
		actualTargetYaw = Mathf.Lerp(actualTargetYaw, targetYaw, Time.deltaTime * rotateSpeed);
		MoveToTargetPoint();
		UpdateLegsRandom();
		UpdateElevation();
	}

	private void MoveToTargetPoint()
	{
		actualTargetPos = Vector3.Lerp(actualTargetPos, target.transform.position, Time.deltaTime * 0.2f);
		Vector3 vector = hips.transform.position - actualTargetPos;
		float magnitude = vector.magnitude;
		Vector3 normalized = vector.normalized;
		normalized.Normalize();
		hips.transform.Translate(normalized * (0f - (speed + speedNoise)) * Time.deltaTime, Space.World);
	}

	private void AddSpeedNoise()
	{
		float num = Mathf.PerlinNoise(speedNoiseTimer, 0f);
		speedNoise = speed * speedPercentNoise * num;
		speedNoiseTimer += Time.deltaTime * speedNoiseFrequency;
	}

	private void UpdateLegsRandom()
	{
		currIndex = Mathf.FloorToInt(stepTimer);
		if (currIndex > 7)
		{
			stepTimer = 0f;
			currIndex = 7;
			shuffle(legIndices);
		}
		if (prevIndex != currIndex)
		{
			int num = legIndices[currIndex];
			limbs[num].checkComfort();
		}
		prevIndex = currIndex;
		stepTimer += Time.deltaTime * stepFrequency;
	}

	private void UpdateLegsStideMode()
	{
		int num = 0;
		float num2 = 0f;
		for (int i = 0; i < limbs.Length; i++)
		{
			if (limbs[i].getDistanceToComfort() > num2)
			{
				num = i;
				num2 = limbs[i].getDistanceToComfort();
			}
		}
		limbs[num].forceTakeStep();
		stepTimer = 0f;
		stepTimer += Time.deltaTime;
	}

	private void UpdateLegsAlternatingTetrapod()
	{
		if (!firstTripodStepped && stepTimer > 0f * stepFrequency)
		{
			limbs[0].forceTakeStep();
			limbs[3].forceTakeStep();
			limbs[5].forceTakeStep();
			limbs[7].forceTakeStep();
			firstTripodStepped = true;
		}
		if (!secondTripodStepped && stepTimer > 0.5f * stepFrequency)
		{
			limbs[1].forceTakeStep();
			limbs[2].forceTakeStep();
			limbs[4].forceTakeStep();
			limbs[6].forceTakeStep();
			secondTripodStepped = true;
		}
		if (stepTimer > 1f * stepFrequency)
		{
			stepTimer = 0f;
			firstTripodStepped = false;
			secondTripodStepped = false;
		}
		stepTimer += Time.deltaTime;
	}

	private void UpdateLegs()
	{
		if (stepTimer > 0f * stepFrequency && !stepped1)
		{
			limbs[0].forceTakeStep();
			stepped1 = true;
		}
		if (stepTimer > 0.25f * stepFrequency && !stepped2)
		{
			limbs[1].forceTakeStep();
			stepped2 = true;
		}
		if (stepTimer > 0.5f * stepFrequency && !stepped3)
		{
			limbs[2].forceTakeStep();
			stepped3 = true;
		}
		if (stepTimer > 0.75f * stepFrequency && !stepped4)
		{
			limbs[3].forceTakeStep();
			stepped4 = true;
		}
		if (stepTimer > 1f * stepFrequency)
		{
			stepped1 = false;
			stepped2 = false;
			stepped3 = false;
			stepped4 = false;
			stepTimer = 0f;
		}
		stepTimer += Time.deltaTime;
	}

	private void UpdateElevation()
	{
		float num = 0f;
		Vector3 toDirection = new Vector3(0f, 0f, 0f);
		ProceduralLimb[] array = limbs;
		foreach (ProceduralLimb proceduralLimb in array)
		{
			num += proceduralLimb.GetFootPosition().y;
			toDirection += proceduralLimb.getGroundNormal();
		}
		toDirection /= (float)limbs.Length;
		targetRotation = Quaternion.FromToRotation(-Vector3.right, toDirection) * Quaternion.Euler(actualTargetYaw, 0f, 0f);
		targetHeight = num / 8f + targetHipHeight * getScale();
		hips.position = Vector3.Lerp(hips.position, new Vector3(hips.position.x, targetHeight, hips.position.z), Time.deltaTime * 1f);
		hips.rotation = Quaternion.Lerp(hips.rotation, targetRotation, Time.deltaTime * 0.5f);
	}
}
public class SpiderCrabArms : MonoBehaviour
{
	public Transform leftJoint1;

	public Transform leftJoint2;

	public Transform rightJoint1;

	public Transform rightJoint2;

	private Quaternion leftJoint1_defaultRotation;

	private Quaternion leftJoint2_defaultRotation;

	private Quaternion rightJoint1_defaultRotation;

	private Quaternion rightJoint2_defaultRotation;

	public float noiseAmplitude;

	public float noiseFrequency;

	public Vector3 axis1 = new Vector3(0f, 0f, 1f);

	public Vector3 axis2 = new Vector3(0f, 0f, 1f);

	private float timer1;

	private float timer2 = 2f;

	private void Start()
	{
		leftJoint1_defaultRotation = leftJoint1.localRotation;
		rightJoint1_defaultRotation = rightJoint1.localRotation;
		leftJoint2_defaultRotation = leftJoint2.localRotation;
		rightJoint2_defaultRotation = rightJoint2.localRotation;
	}

	private void Update()
	{
		float num = Mathf.PerlinNoise(timer1, 0f) * noiseAmplitude;
		float num2 = Mathf.PerlinNoise(timer2, 0f) * noiseAmplitude;
		leftJoint1.localRotation = leftJoint1_defaultRotation * Quaternion.Euler(axis1 * num);
		rightJoint1.localRotation = rightJoint1_defaultRotation * Quaternion.Euler(axis1 * num2);
		leftJoint2.localRotation = leftJoint2_defaultRotation * Quaternion.Euler(axis2 * num);
		rightJoint2.localRotation = rightJoint2_defaultRotation * Quaternion.Euler(axis2 * num2);
		timer1 += Time.deltaTime * noiseFrequency;
		timer2 += Time.deltaTime * noiseFrequency;
	}
}
public class SpinLight : MonoBehaviour
{
	public Vector3 axis;

	public float rotateSpeed;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(axis * rotateSpeed);
	}
}
public class Spinner : MonoBehaviour
{
	public float spinSpeed;

	public Vector3 spinAxis = new Vector3(1f, 0f, 0f);

	public GameObject glowObject;

	public float glowScaleRate = 1f;

	public float glowAlphaRate = 1f;

	private Material glowMaterial;

	private Color glowColor;

	private float actualSpinSpeed;

	private void Start()
	{
		GetComponent<Rigidbody>().AddTorque(new Vector3(0.2f, 0f, 0f), ForceMode.Impulse);
		glowMaterial = glowObject.GetComponent<Renderer>().material;
		glowColor = glowMaterial.GetColor("_TintColor");
	}

	private void Update()
	{
		if (actualSpinSpeed > 0f && glowObject != null)
		{
			glowColor.a = glowMaterial.GetColor("_TintColor").a + glowAlphaRate * Time.deltaTime;
			glowMaterial.SetColor("_TintColor", glowColor);
			glowObject.transform.localScale += new Vector3(glowScaleRate, glowScaleRate, glowScaleRate) * Time.deltaTime;
		}
	}

	public void startSpinning()
	{
		actualSpinSpeed = spinSpeed;
	}
}
public class Startup : MonoBehaviour
{
	private void Start()
	{
		SceneManager.LoadScene("OceanRift_Startup_Void");
	}
}
public class StartupOceanRift : MonoBehaviour
{
	public float delayBeforeLoad;

	public string sceneToLoad = "MainScene";

	private AsyncOperation async;

	private void Start()
	{
		UnityEngine.Application.targetFrameRate = 60;
		StartCoroutine(loadCoroutine(sceneToLoad));
	}

	private IEnumerator loadCoroutine(string levelName)
	{
		yield return new WaitForSeconds(delayBeforeLoad);
		GameObject player = GameObject.Find("Player(Clone)");
		if (player != null)
		{
			player.transform.Find("UI").GetComponent<UI>().TransitionToTitle();
		}
		yield return 0;
	}
}
public class StreamImageSequence : MonoBehaviour
{
	private int numImages = 1;

	private UnityEngine.Object[] textures;

	private Texture2D[] typedTextures;

	private int index;

	private Renderer renderer;

	private Material material;

	private void Start()
	{
	}

	private IEnumerator RefreshASync(string name)
	{
		int max = (numImages = 250);
		textures = new Texture2D[max];
		typedTextures = new Texture2D[max];
		material = GetComponent<Renderer>().material;
		renderer = GetComponent<Renderer>();
		string fileName = "Manatee";
		MonoBehaviour.print(name);
		if (name == "Manatees")
		{
			fileName = "Manatee";
		}
		if (name == "Great White Shark")
		{
			fileName = "Great White Shark ";
		}
		if (name == "Orcas")
		{
			fileName = "Orcas";
		}
		if (name == "Plesiosaur")
		{
			fileName = "Plesiosaur";
		}
		if (name == "Pliosaur")
		{
			fileName = "Pliosaur";
		}
		if (name == "The Deep")
		{
			fileName = "The Deep";
		}
		if (name == "Sea Lions")
		{
			fileName = "Sea Lions";
		}
		if (name == "Humpback Whales")
		{
			fileName = "Humpback Whales";
		}
		int i = 0;
		if (name == "Great White Shark")
		{
			typedTextures[0] = Resources.Load("Videos/" + name + "/" + fileName + "1" + i.ToString("000"), typeof(Texture2D)) as Texture2D;
		}
		else
		{
			typedTextures[0] = Resources.Load("Videos/" + name + "/" + fileName + i.ToString("000"), typeof(Texture2D)) as Texture2D;
		}
		material.mainTexture = typedTextures[0];
		while (true)
		{
			string path = ((!(name == "Great White Shark")) ? ("Videos/" + name + "/" + fileName + i.ToString("000")) : ("Videos/" + name + "/" + fileName + "1" + i.ToString("000")));
			Texture2D img = Resources.Load(path, typeof(Texture2D)) as Texture2D;
			if (img != null)
			{
				typedTextures[i] = img;
				i++;
				yield return 0;
				continue;
			}
			break;
		}
		numImages = i;
		yield return 0;
	}

	public void Refresh(string name = "Manatees")
	{
		index = 0;
		StartCoroutine(RefreshASync(name));
		CancelInvoke();
		InvokeRepeating("ChangeImage", 0f, 1f / 30f);
	}

	private void ChangeImage()
	{
		if (!renderer.isVisible)
		{
			return;
		}
		if (typedTextures != null || typedTextures.Length > 0)
		{
			index++;
			if (index >= numImages)
			{
				index = 0;
			}
		}
		material.mainTexture = typedTextures[index];
	}
}
[ExecuteInEditMode]
public class SurfaceReflection : MonoBehaviour
{
	public bool m_DisablePixelLights = true;

	public int m_TextureSize = 256;

	public float m_clipPlaneOffset = 0.07f;

	private float m_finalClipPlaneOffset;

	public bool m_NormalsFromMesh;

	public bool m_BaseClipOffsetFromMesh;

	public bool m_BaseClipOffsetFromMeshInverted;

	private Vector3 m_calculatedNormal = Vector3.zero;

	public LayerMask m_ReflectLayers = -1;

	private Hashtable m_ReflectionCameras = new Hashtable();

	private RenderTexture m_ReflectionTexture;

	private int m_OldReflectionTextureSize;

	private static bool s_InsideRendering;

	public void OnWillRenderObject()
	{
		if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
		{
			return;
		}
		Camera current = Camera.current;
		if (!current)
		{
			return;
		}
		if (m_NormalsFromMesh && GetComponent<MeshFilter>() != null)
		{
			m_calculatedNormal = base.transform.TransformDirection(GetComponent<MeshFilter>().sharedMesh.normals[0]);
		}
		if (m_BaseClipOffsetFromMesh && GetComponent<MeshFilter>() != null)
		{
			m_finalClipPlaneOffset = (base.transform.position - base.transform.TransformPoint(GetComponent<MeshFilter>().sharedMesh.vertices[0])).magnitude + m_clipPlaneOffset;
		}
		else if (m_BaseClipOffsetFromMeshInverted && GetComponent<MeshFilter>() != null)
		{
			m_finalClipPlaneOffset = 0f - (base.transform.position - base.transform.TransformPoint(GetComponent<MeshFilter>().sharedMesh.vertices[0])).magnitude + m_clipPlaneOffset;
		}
		else
		{
			m_finalClipPlaneOffset = m_clipPlaneOffset;
		}
		if (s_InsideRendering)
		{
			return;
		}
		s_InsideRendering = true;
		CreateSurfaceObjects(current, out var reflectionCamera);
		Vector3 position = base.transform.position;
		Vector3 vector = ((!m_NormalsFromMesh || !(GetComponent<MeshFilter>() != null)) ? base.transform.up : m_calculatedNormal);
		int pixelLightCount = QualitySettings.pixelLightCount;
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = 0;
		}
		UpdateCameraModes(current, reflectionCamera);
		float w = 0f - Vector3.Dot(vector, position) - m_finalClipPlaneOffset;
		Vector4 plane = new Vector4(vector.x, vector.y, vector.z, w);
		Matrix4x4 reflectionMat = Matrix4x4.zero;
		CalculateReflectionMatrix(ref reflectionMat, plane);
		Vector3 position2 = current.transform.position;
		Vector3 position3 = reflectionMat.MultiplyPoint(position2);
		reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
		Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, vector, 1f);
		Matrix4x4 projection = current.projectionMatrix;
		CalculateObliqueMatrix(ref projection, clipPlane);
		reflectionCamera.projectionMatrix = projection;
		reflectionCamera.cullingMask = -17 & m_ReflectLayers.value;
		reflectionCamera.targetTexture = m_ReflectionTexture;
		GL.SetRevertBackfacing(revertBackFaces: true);
		reflectionCamera.transform.position = position3;
		Vector3 eulerAngles = current.transform.eulerAngles;
		reflectionCamera.transform.eulerAngles = new Vector3(0f, eulerAngles.y, eulerAngles.z);
		reflectionCamera.Render();
		reflectionCamera.transform.position = position2;
		GL.SetRevertBackfacing(revertBackFaces: false);
		Material[] sharedMaterials = GetComponent<Renderer>().sharedMaterials;
		Material[] array = sharedMaterials;
		foreach (Material material in array)
		{
			if (material.HasProperty("_ReflectionTex"))
			{
				material.SetTexture("_ReflectionTex", m_ReflectionTexture);
			}
		}
		Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0.5f, 0.5f, 0.5f), Quaternion.identity, new Vector3(0.5f, 0.5f, 0.5f));
		Vector3 lossyScale = base.transform.lossyScale;
		Matrix4x4 matrix4x2 = base.transform.localToWorldMatrix * Matrix4x4.Scale(new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z));
		matrix4x2 = matrix4x * current.projectionMatrix * current.worldToCameraMatrix * matrix4x2;
		Material[] array2 = sharedMaterials;
		foreach (Material material2 in array2)
		{
			material2.SetMatrix("_ProjMatrix", matrix4x2);
		}
		if (m_DisablePixelLights)
		{
			QualitySettings.pixelLightCount = pixelLightCount;
		}
		s_InsideRendering = false;
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		foreach (DictionaryEntry reflectionCamera in m_ReflectionCameras)
		{
			UnityEngine.Object.DestroyImmediate(((Camera)reflectionCamera.Value).gameObject);
		}
		m_ReflectionCameras.Clear();
	}

	private void UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		if (src.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox skybox = src.GetComponent(typeof(Skybox)) as Skybox;
			Skybox skybox2 = dest.GetComponent(typeof(Skybox)) as Skybox;
			if (!skybox || !skybox.material)
			{
				skybox2.enabled = false;
			}
			else
			{
				skybox2.enabled = true;
				skybox2.material = skybox.material;
			}
		}
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
	}

	private void CreateSurfaceObjects(Camera currentCamera, out Camera reflectionCamera)
	{
		reflectionCamera = null;
		if (!m_ReflectionTexture || m_OldReflectionTextureSize != m_TextureSize)
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			}
			m_ReflectionTexture = new RenderTexture(m_TextureSize, m_TextureSize, 16);
			m_ReflectionTexture.name = "__SurfaceReflection" + GetInstanceID();
			m_ReflectionTexture.isPowerOfTwo = true;
			m_ReflectionTexture.hideFlags = HideFlags.DontSave;
			m_OldReflectionTextureSize = m_TextureSize;
		}
		reflectionCamera = m_ReflectionCameras[currentCamera] as Camera;
		if (!reflectionCamera)
		{
			GameObject gameObject = new GameObject("Surface Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflectionCamera = gameObject.GetComponent<Camera>();
			reflectionCamera.enabled = false;
			reflectionCamera.transform.position = base.transform.position;
			reflectionCamera.transform.rotation = base.transform.rotation;
			reflectionCamera.gameObject.AddComponent<FlareLayer>();
			gameObject.hideFlags = HideFlags.HideAndDontSave;
			m_ReflectionCameras[currentCamera] = reflectionCamera;
		}
	}

	private static float sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * m_finalClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateObliqueMatrix(ref Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(sgn(clipPlane.x), sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}
}
public class SwingLight : MonoBehaviour
{
	public float maxAngle;

	public float minAngle;

	public int changeChance;

	public float lerpSpeed;

	public Vector3 axis;

	private float targetAngle;

	private Quaternion originalAngle;

	private void Start()
	{
		targetAngle = Random.Range(minAngle, maxAngle);
		originalAngle = base.transform.rotation;
	}

	private void Update()
	{
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, originalAngle * Quaternion.Euler(axis * targetAngle), lerpSpeed * Time.deltaTime);
		if (Random.Range(0, changeChance) == 1)
		{
			targetAngle = Random.Range(minAngle, maxAngle);
		}
	}
}
public class Test : MonoBehaviour
{
	public GameObject test;

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class TractorBeam : MonoBehaviour
{
	private OVRSwimController playerController;

	private GameObject player;

	private Vector3 centerOfWorld;

	public float maxDistance = 20f;

	public float strength = 1f;

	public GameObject hitParticleSystem;

	private float nextParticleTime;

	private void Start()
	{
		centerOfWorld = new Vector3(0f, 0f, 0f);
		player = GameObject.Find("Player(Clone)");
		if (player == null)
		{
			player = GameObject.Find("Player");
		}
		playerController = player.GetComponent<OVRSwimController>();
		nextParticleTime = 0f;
	}

	private void FixedUpdate()
	{
		Vector3 vector = centerOfWorld - player.transform.position;
		float magnitude = vector.magnitude;
		if (magnitude > maxDistance)
		{
			playerController.MoveThrottle += vector * strength;
			if (nextParticleTime <= 0f)
			{
				UnityEngine.Object.Instantiate(hitParticleSystem, player.transform.position + -vector.normalized * 0.5f + new Vector3(0f, 0.8f, 0f), Quaternion.LookRotation(vector.normalized));
				nextParticleTime = 0.5f;
			}
		}
		nextParticleTime -= Time.deltaTime;
	}
}
public class twinFlippers : MonoBehaviour
{
	private float offset = 100f;

	private float rearOffset = 30f;

	private float frontMaxHorizontalLimit = 0.9f;

	private float frontMinHorizontalLimit = 0.5f;

	private float rearMinHorizontalLimit = -1.5f;

	private float rearMaxHorizontalLimit = -2.2f;

	private Pliosaur ps;

	public AnimationCurve nodeCurve;

	public bool swimming;

	public bool drawStroke;

	private float strokeTime;

	private float rearstrokeTime;

	public float frontlerpspeed = 0.7f;

	public float rearlerpspeed = 0.7f;

	public float strokeSpeed = 1f;

	private float leftlerpSpeed;

	private float rightlerpSpeed;

	private float rearleftlerpSpeed;

	private float rearrightlerpSpeed;

	public float reactionTime = 1.5f;

	public float slowSpeed;

	public float flipperRotateLerp = 1f;

	private float drawModifier;

	private float reardrawModifier;

	public float drawStrokeSpeedModifier = 0.7f;

	public float returnStrokeSpeedModifier = 1.3f;

	public float turnEffector = 10f;

	public Transform leftStrokeNode;

	public Transform rightStrokeNode;

	public Transform leftFlipperNode;

	public Transform rightFlipperNode;

	public Transform backLeftStrokeNode;

	public Transform backRightStrokeNode;

	public Transform backLeftFlipperNode;

	public Transform backRightFlipperNode;

	private Transform leftCurrentNode;

	private Transform rightCurrentNode;

	private Transform rearLeftCurrentNode;

	private Transform rearRightCurrentNode;

	public Transform swimNode;

	public Transform FLStrokeTarget;

	public Transform BLStrokeTarget;

	public Transform FRStrokeTarget;

	public Transform BRStrokeTarget;

	public Transform FLRearFlipTarget;

	public Transform BLRearFlipTarget;

	public Transform FRRearFlipTarget;

	public Transform BRRearFlipTarget;

	public Transform body;

	public Transform leftFlipperJoint;

	public Transform rightFlipperJoint;

	public Transform rearleftFlipperJoint;

	public Transform rearrightFlipperJoint;

	private float targetAngleL;

	private float targetAngleR;

	private float reartargetAngleL;

	private float reartargetAngleR;

	public float drawAngle;

	public float reardrawAngle;

	private Vector3 flNoise;

	private Vector3 frNoise;

	private Vector3 blNoise;

	private Vector3 brNoise;

	private void Start()
	{
		ps = base.transform.GetComponent<Pliosaur>();
		leftCurrentNode = leftStrokeNode;
		rightCurrentNode = rightStrokeNode;
		rearLeftCurrentNode = backLeftStrokeNode;
		rearRightCurrentNode = backRightStrokeNode;
	}

	private void Update()
	{
		UpdateTargets();
		UpdateNodes();
		CheckBehaviour();
		MoveFlippers();
	}

	private void UpdateTargets()
	{
		UpdateStrokeTargets();
	}

	private void UpdateStrokeTargets()
	{
		UpdateSwimNode();
		float x = swimNode.localPosition.x;
		float z = swimNode.localPosition.z;
		float z2 = Mathf.Clamp(1.1f - x / turnEffector, frontMinHorizontalLimit, frontMaxHorizontalLimit);
		float z3 = Mathf.Clamp(1.1f + x / turnEffector, frontMinHorizontalLimit, frontMaxHorizontalLimit);
		float z4 = Mathf.Clamp(-0.1f - x / turnEffector, rearMinHorizontalLimit, rearMaxHorizontalLimit);
		float z5 = Mathf.Clamp(-0.1f + x / turnEffector, rearMinHorizontalLimit, rearMaxHorizontalLimit);
		Vector3 b = new Vector3(FLStrokeTarget.localPosition.x, FLStrokeTarget.localPosition.y, z3);
		Vector3 b2 = new Vector3(FRStrokeTarget.localPosition.x, FRStrokeTarget.localPosition.y, z2);
		Vector3 b3 = new Vector3(BLStrokeTarget.localPosition.x, BLStrokeTarget.localPosition.y, z5);
		Vector3 b4 = new Vector3(BRStrokeTarget.localPosition.x, BRStrokeTarget.localPosition.y, z4);
		FLStrokeTarget.localPosition = Vector3.Lerp(FLStrokeTarget.localPosition, b, Time.deltaTime * 1f);
		FRStrokeTarget.localPosition = Vector3.Lerp(FRStrokeTarget.localPosition, b2, Time.deltaTime * 1f);
		BLStrokeTarget.localPosition = Vector3.Lerp(BLStrokeTarget.localPosition, b3, Time.deltaTime * 1f);
		BRStrokeTarget.localPosition = Vector3.Lerp(BRStrokeTarget.localPosition, b4, Time.deltaTime * 1f);
	}

	private void UpdateNodes()
	{
		UpdateStrokeNodes();
	}

	public float getStrokeTime()
	{
		return nodeCurve.Evaluate(strokeTime);
	}

	private void UpdateStrokeNodes()
	{
		float num = nodeCurve.Evaluate(strokeTime);
		leftStrokeNode.position = BLStrokeTarget.position * (1f - num) + FLStrokeTarget.position * num;
		rightStrokeNode.position = BRStrokeTarget.position * (1f - num) + FRStrokeTarget.position * num;
		num = nodeCurve.Evaluate(rearstrokeTime);
		backLeftStrokeNode.position = BLStrokeTarget.position * (1f - num) + BLRearFlipTarget.position * num;
		backRightStrokeNode.position = BRStrokeTarget.position * (1f - num) + BRRearFlipTarget.position * num;
		strokeTime += Time.deltaTime * (ps.getMoveSpeed() * drawModifier * strokeSpeed);
		rearstrokeTime += Time.deltaTime * (ps.getMoveSpeed() * reardrawModifier * strokeSpeed);
		UpdateStrokeDirection();
	}

	private void UpdateStrokeDirection()
	{
		if (Mathf.Floor(strokeTime % 2f) == 0f)
		{
			drawStroke = false;
			drawModifier = returnStrokeSpeedModifier;
			reardrawModifier = drawStrokeSpeedModifier;
		}
		else
		{
			drawStroke = true;
			drawModifier = drawStrokeSpeedModifier;
			reardrawModifier = returnStrokeSpeedModifier;
		}
	}

	private void UpdateSwimNode()
	{
		swimNode.position = Vector3.Lerp(swimNode.position, ps.target.position, Time.deltaTime * 60f);
	}

	private void CheckBehaviour()
	{
		if (ps.getMoveSpeed() < slowSpeed)
		{
			RotateFlipper(2);
			if (Vector3.Distance(rearLeftCurrentNode.position, BLRearFlipTarget.position) < 0.5f)
			{
				rearLeftCurrentNode = BLRearFlipTarget;
			}
			if (Vector3.Distance(rearRightCurrentNode.position, BRRearFlipTarget.position) < 0.5f)
			{
				rearRightCurrentNode = BRRearFlipTarget;
			}
		}
		else
		{
			RotateFlipper(1);
			if (Vector3.Distance(rearLeftCurrentNode.position, backLeftStrokeNode.position) < 0.5f)
			{
				rearLeftCurrentNode = backLeftStrokeNode;
			}
			if (Vector3.Distance(rearRightCurrentNode.position, backRightStrokeNode.position) < 0.5f)
			{
				rearRightCurrentNode = backRightStrokeNode;
			}
		}
	}

	private void MoveFlippers()
	{
		leftFlipperNode.position = Vector3.Lerp(leftFlipperNode.position, leftCurrentNode.position, frontlerpspeed);
		rightFlipperNode.position = Vector3.Lerp(rightFlipperNode.position, rightCurrentNode.position, frontlerpspeed);
		backLeftFlipperNode.position = Vector3.Lerp(backLeftFlipperNode.position, rearLeftCurrentNode.position, rearlerpspeed);
		backRightFlipperNode.position = Vector3.Lerp(backRightFlipperNode.position, rearRightCurrentNode.position, rearlerpspeed);
		UpdateFlipper(leftFlipperJoint, leftFlipperNode, bRightSide: false, front: true);
		UpdateFlipper(rightFlipperJoint, rightFlipperNode, bRightSide: true, front: true);
		UpdateFlipper(rearleftFlipperJoint, backLeftFlipperNode, bRightSide: false, front: false);
		UpdateFlipper(rearrightFlipperJoint, backRightFlipperNode, bRightSide: true, front: false);
	}

	private void UpdateFlipper(Transform flipper, Transform targetPoint, bool bRightSide, bool front)
	{
		Quaternion rotation = flipper.rotation;
		flipper.LookAt(targetPoint, body.up);
		flipper.rotation *= Quaternion.Euler(0f, 90f, 0f);
		if (!bRightSide)
		{
			if (front)
			{
				flipper.rotation *= Quaternion.Euler(targetAngleL + 180f, 0f, 0f);
			}
			else
			{
				flipper.rotation *= Quaternion.Euler(reartargetAngleL + 180f, 0f, 0f);
			}
		}
		else if (front)
		{
			flipper.rotation *= Quaternion.Euler(targetAngleR, 0f, 0f);
		}
		else
		{
			flipper.rotation *= Quaternion.Euler(reartargetAngleR, 0f, 0f);
		}
	}

	private void RotateFlipper(int flipperRotationType)
	{
		float num = Vector3.Angle(BLStrokeTarget.localPosition, FLStrokeTarget.localPosition);
		float num2 = Vector3.Angle(BRStrokeTarget.localPosition, FRStrokeTarget.localPosition);
		num += offset;
		num2 += offset;
		float num3 = num;
		float num4 = num2;
		float b = num + drawAngle;
		float b2 = num2 - drawAngle;
		float b3 = num;
		float b4 = num2;
		float b5;
		float b6;
		if (flipperRotationType == 1)
		{
			b5 = num3;
			b6 = num4;
		}
		else
		{
			b5 = num3 - reardrawAngle;
			b6 = num4 + reardrawAngle;
		}
		float b7 = num3 - reardrawAngle;
		float b8 = num4 + reardrawAngle;
		if (drawStroke)
		{
			targetAngleL = Mathf.Lerp(targetAngleL, b, Time.deltaTime * flipperRotateLerp);
			targetAngleR = Mathf.Lerp(targetAngleR, b2, Time.deltaTime * flipperRotateLerp);
			reartargetAngleL = Mathf.Lerp(reartargetAngleL, b5, Time.deltaTime * flipperRotateLerp);
			reartargetAngleR = Mathf.Lerp(reartargetAngleR, b6, Time.deltaTime * flipperRotateLerp);
		}
		else
		{
			targetAngleL = Mathf.Lerp(targetAngleL, b3, Time.deltaTime * flipperRotateLerp);
			targetAngleR = Mathf.Lerp(targetAngleR, b4, Time.deltaTime * flipperRotateLerp);
			reartargetAngleL = Mathf.Lerp(reartargetAngleL, b7, Time.deltaTime * flipperRotateLerp);
			reartargetAngleR = Mathf.Lerp(reartargetAngleR, b8, Time.deltaTime * flipperRotateLerp);
		}
	}
}
public class UILight : MonoBehaviour
{
	private UI ui;

	private TouchUI touchUI;

	private GameObject player;

	private float defaultIntensity;

	public float maxIntensity = 1f;

	private void Start()
	{
		touchUI = UnityEngine.Object.FindObjectOfType<TouchUI>();
		player = GameObject.Find("Dummy Player");
		defaultIntensity = GetComponent<Light>().intensity;
	}

	private void Update()
	{
		base.transform.position = player.transform.position;
		if (touchUI.isSwichedOn())
		{
			GetComponent<Light>().intensity = maxIntensity;
		}
		else
		{
			GetComponent<Light>().intensity = defaultIntensity;
		}
	}
}
public class Underclock : MonoBehaviour
{
	private void Start()
	{
	}
}
public class WaterSurfaceFader : MonoBehaviour
{
	private Transform waterSurface;

	private Transform camera;

	private void Start()
	{
		camera = LAC_VRCameraRig.instance.getCenterCamera().transform;
	}

	private void Update()
	{
		if (waterSurface != null)
		{
			float y = waterSurface.position.y;
		}
	}

	public void SetWaterSurface(Transform surf)
	{
		waterSurface = surf;
	}
}
public class WhaleSharkMouth : MonoBehaviour
{
	public Transform upperJaw;

	public Transform lowerJaw;

	public Vector3 axis;

	private float timer;

	public float noiseFrequency = 1f;

	public float noiseAmplitude = 10f;

	private Quaternion defaultUpperJawRotation;

	private Quaternion defaultLowerJawRotation;

	public float lerp = 1f;

	public float upperJawOffset;

	public float lowerJawOffset;

	public AnimationCurve weightCurve;

	private float weightCurveTimer;

	public float weightCurveRate = 1f;

	private void Start()
	{
		defaultUpperJawRotation = upperJaw.localRotation * Quaternion.Euler(axis * upperJawOffset);
		defaultLowerJawRotation = lowerJaw.localRotation * Quaternion.Euler(axis * lowerJawOffset);
	}

	private void Update()
	{
		float num = Mathf.PerlinNoise(timer, 0f) * weightCurve.Evaluate(weightCurveTimer) * noiseAmplitude;
		upperJaw.localRotation = Quaternion.Lerp(upperJaw.localRotation, defaultUpperJawRotation * Quaternion.Euler(axis * num), Time.deltaTime * lerp);
		lowerJaw.localRotation = Quaternion.Lerp(lowerJaw.localRotation, defaultLowerJawRotation * Quaternion.Euler(-axis * num), Time.deltaTime * lerp);
		timer += Time.deltaTime * noiseFrequency;
		weightCurveTimer += Time.deltaTime * weightCurveRate;
	}
}
public class WindzoneController : ScriptableWindzoneInterface
{
	private void Start()
	{
		Init();
		Debug.Log("The Starting Settings Of The Windzone Are: Main=" + base.WindMain + ", Turbulence=" + base.WindTurbulence + ", Pulse Magnitude=" + base.WindPulseMagnitude + ", Pulse Frequency=" + base.WindPulseFrequency);
	}

	private void Update()
	{
		MonoBehaviour.print("wind speed : " + base.WindMain);
	}
}
public class T4MBillBObjSC : MonoBehaviour
{
	[HideInInspector]
	public Renderer Render;

	[HideInInspector]
	public Transform Transf;
}
public class T4MLodObjSC : MonoBehaviour
{
	[HideInInspector]
	public Renderer LOD1;

	[HideInInspector]
	public Renderer LOD2;

	[HideInInspector]
	public Renderer LOD3;

	[HideInInspector]
	public float Interval = 0.5f;

	[HideInInspector]
	public Transform PlayerCamera;

	[HideInInspector]
	public int Mode;

	private Vector3 OldPlayerPos;

	[HideInInspector]
	public int ObjLodStatus;

	[HideInInspector]
	public float MaxViewDistance = 60f;

	[HideInInspector]
	public float LOD2Start = 20f;

	[HideInInspector]
	public float LOD3Start = 40f;

	public void ActivateLODScrpt()
	{
		if (Mode == 2)
		{
			if (PlayerCamera == null)
			{
				PlayerCamera = Camera.main.transform;
			}
			InvokeRepeating("AFLODScrpt", Random.Range(0f, Interval), Interval);
		}
	}

	public void ActivateLODLay()
	{
		if (Mode == 2)
		{
			if (PlayerCamera == null)
			{
				PlayerCamera = Camera.main.transform;
			}
			InvokeRepeating("AFLODLay", Random.Range(0f, Interval), Interval);
		}
	}

	public void AFLODLay()
	{
		if (OldPlayerPos == PlayerCamera.position)
		{
			return;
		}
		OldPlayerPos = PlayerCamera.position;
		float num = Vector3.Distance(new Vector3(base.transform.position.x, PlayerCamera.position.y, base.transform.position.z), PlayerCamera.position);
		int layer = base.gameObject.layer;
		if (num <= PlayerCamera.GetComponent<Camera>().layerCullDistances[layer] + 5f)
		{
			if (num < LOD2Start && ObjLodStatus != 1)
			{
				Renderer lOD = LOD3;
				bool flag = false;
				LOD2.enabled = flag;
				lOD.enabled = flag;
				LOD1.enabled = true;
				ObjLodStatus = 1;
			}
			else if (num >= LOD2Start && num < LOD3Start && ObjLodStatus != 2)
			{
				Renderer lOD2 = LOD1;
				bool flag = false;
				LOD3.enabled = flag;
				lOD2.enabled = flag;
				LOD2.enabled = true;
				ObjLodStatus = 2;
			}
			else if (num >= LOD3Start && ObjLodStatus != 3)
			{
				Renderer lOD3 = LOD1;
				bool flag = false;
				LOD2.enabled = flag;
				lOD3.enabled = flag;
				LOD3.enabled = true;
				ObjLodStatus = 3;
			}
		}
	}

	public void AFLODScrpt()
	{
		if (OldPlayerPos == PlayerCamera.position)
		{
			return;
		}
		OldPlayerPos = PlayerCamera.position;
		float num = Vector3.Distance(new Vector3(base.transform.position.x, PlayerCamera.position.y, base.transform.position.z), PlayerCamera.position);
		if (num <= MaxViewDistance)
		{
			if (num < LOD2Start && ObjLodStatus != 1)
			{
				Renderer lOD = LOD3;
				bool flag = false;
				LOD2.enabled = flag;
				lOD.enabled = flag;
				LOD1.enabled = true;
				ObjLodStatus = 1;
			}
			else if (num >= LOD2Start && num < LOD3Start && ObjLodStatus != 2)
			{
				Renderer lOD2 = LOD1;
				bool flag = false;
				LOD3.enabled = flag;
				lOD2.enabled = flag;
				LOD2.enabled = true;
				ObjLodStatus = 2;
			}
			else if (num >= LOD3Start && ObjLodStatus != 3)
			{
				Renderer lOD3 = LOD1;
				bool flag = false;
				LOD2.enabled = flag;
				lOD3.enabled = flag;
				LOD3.enabled = true;
				ObjLodStatus = 3;
			}
		}
		else if (ObjLodStatus != 0)
		{
			Renderer lOD4 = LOD1;
			bool flag = false;
			LOD3.enabled = flag;
			flag = flag;
			LOD2.enabled = flag;
			lOD4.enabled = flag;
			ObjLodStatus = 0;
		}
	}
}
[ExecuteInEditMode]
public class T4MObjSC : MonoBehaviour
{
	[HideInInspector]
	public string ConvertType = string.Empty;

	[HideInInspector]
	public bool EnabledLODSystem = true;

	[HideInInspector]
	public Vector3[] ObjPosition;

	[HideInInspector]
	public T4MLodObjSC[] ObjLodScript;

	[HideInInspector]
	public int[] ObjLodStatus;

	[HideInInspector]
	public float MaxViewDistance = 60f;

	[HideInInspector]
	public float LOD2Start = 20f;

	[HideInInspector]
	public float LOD3Start = 40f;

	[HideInInspector]
	public float Interval = 0.5f;

	[HideInInspector]
	public Transform PlayerCamera;

	private Vector3 OldPlayerPos;

	[HideInInspector]
	public int Mode = 1;

	[HideInInspector]
	public int Master;

	[HideInInspector]
	public bool enabledBillboard = true;

	[HideInInspector]
	public Vector3[] BillboardPosition;

	[HideInInspector]
	public float BillInterval = 0.05f;

	[HideInInspector]
	public int[] BillStatus;

	[HideInInspector]
	public float BillMaxViewDistance = 30f;

	[HideInInspector]
	public T4MBillBObjSC[] BillScript;

	[HideInInspector]
	public bool enabledLayerCul = true;

	[HideInInspector]
	public float BackGroundView = 1000f;

	[HideInInspector]
	public float FarView = 200f;

	[HideInInspector]
	public float NormalView = 60f;

	[HideInInspector]
	public float CloseView = 30f;

	private float[] distances = new float[32];

	[HideInInspector]
	public int Axis;

	[HideInInspector]
	public bool LODbasedOnScript = true;

	[HideInInspector]
	public bool BilBbasedOnScript = true;

	public Material T4MMaterial;

	public MeshFilter T4MMesh;

	[HideInInspector]
	public Color TranslucencyColor = new Color(0.73f, 0.85f, 0.4f, 1f);

	[HideInInspector]
	public Vector4 Wind = new Vector4(0.85f, 0.075f, 0.4f, 0.5f);

	[HideInInspector]
	public float WindFrequency = 0.75f;

	[HideInInspector]
	public float GrassWindFrequency = 1.5f;

	[HideInInspector]
	public bool ActiveWind;

	public bool LayerCullPreview;

	public bool LODPreview;

	public bool BillboardPreview;

	public Texture2D T4MMaskTex2d;

	public Texture2D T4MMaskTexd;

	public void Awake()
	{
		if (Master != 1)
		{
			return;
		}
		if (PlayerCamera == null && (bool)Camera.main)
		{
			PlayerCamera = Camera.main.transform;
		}
		else if (PlayerCamera == null && !Camera.main)
		{
			Camera[] array = UnityEngine.Object.FindObjectsOfType(typeof(Camera)) as Camera[];
			for (int i = 0; i < array.Length; i++)
			{
				if ((bool)array[i].GetComponent<AudioListener>())
				{
					PlayerCamera = array[i].transform;
				}
			}
		}
		if (enabledLayerCul)
		{
			distances[26] = CloseView;
			distances[27] = NormalView;
			distances[28] = FarView;
			distances[29] = BackGroundView;
		}
		if (EnabledLODSystem && ObjPosition.Length > 0 && Mode == 1)
		{
			if (ObjLodScript[0].gameObject != null)
			{
				if (LODbasedOnScript)
				{
					InvokeRepeating("LODScript", Random.Range(0f, Interval), Interval);
				}
				else
				{
					InvokeRepeating("LODLay", Random.Range(0f, Interval), Interval);
				}
			}
		}
		else if (EnabledLODSystem && ObjPosition.Length > 0 && Mode == 2 && ObjLodScript[0] != null)
		{
			for (int j = 0; j < ObjPosition.Length; j++)
			{
				if (ObjLodScript[j] != null)
				{
					if (LODbasedOnScript)
					{
						ObjLodScript[j].ActivateLODScrpt();
					}
					else
					{
						ObjLodScript[j].ActivateLODLay();
					}
				}
			}
		}
		if (enabledBillboard && BillboardPosition.Length > 0 && BillScript[0] != null)
		{
			if (BilBbasedOnScript)
			{
				InvokeRepeating("BillScrpt", Random.Range(0f, BillInterval), BillInterval);
			}
			else
			{
				InvokeRepeating("BillLay", Random.Range(0f, BillInterval), BillInterval);
			}
		}
	}

	private void OnGUI()
	{
		if (!UnityEngine.Application.isPlaying && Master == 1)
		{
			if (LayerCullPreview && enabledLayerCul)
			{
				GUI.color = Color.green;
				GUI.Label(new Rect(0f, 0f, 200f, 200f), "LayerCull Preview ON");
			}
			else
			{
				GUI.color = Color.red;
				GUI.Label(new Rect(0f, 0f, 200f, 200f), "LayerCull Preview OFF");
			}
			if (LODPreview && ObjPosition.Length > 0)
			{
				GUI.color = Color.green;
				GUI.Label(new Rect(0f, 20f, 200f, 200f), "LOD Preview ON");
			}
			else if (LODPreview && ObjPosition.Length == 0)
			{
				GUI.color = Color.red;
				GUI.Label(new Rect(0f, 20f, 200f, 200f), "Activate the LOD First");
			}
			else
			{
				GUI.color = Color.red;
				GUI.Label(new Rect(0f, 20f, 200f, 200f), "LOD Preview OFF");
			}
			if (BillboardPreview && BillboardPosition.Length > 0)
			{
				GUI.color = Color.green;
				GUI.Label(new Rect(0f, 40f, 200f, 200f), "Billboard Preview ON");
			}
			else if (BillboardPreview && BillboardPosition.Length == 0)
			{
				GUI.color = Color.red;
				GUI.Label(new Rect(0f, 40f, 200f, 200f), "Activate the Billboard First");
			}
			else
			{
				GUI.color = Color.red;
				GUI.Label(new Rect(0f, 40f, 200f, 200f), "Billboard Preview OFF");
			}
		}
	}

	private void LateUpdate()
	{
		if (ActiveWind)
		{
			Color value = Wind * Mathf.Sin(Time.realtimeSinceStartup * WindFrequency);
			value.a = Wind.w;
			Color value2 = Wind * Mathf.Sin(Time.realtimeSinceStartup * GrassWindFrequency);
			value2.a = Wind.w;
			Shader.SetGlobalColor("_Wind", value);
			Shader.SetGlobalColor("_GrassWind", value2);
			Shader.SetGlobalColor("_TranslucencyColor", TranslucencyColor);
			Shader.SetGlobalFloat("_TranslucencyViewDependency;", 0.65f);
		}
		if (!PlayerCamera || UnityEngine.Application.isPlaying || Master != 1)
		{
			return;
		}
		if (LayerCullPreview && enabledLayerCul)
		{
			distances[26] = CloseView;
			distances[27] = NormalView;
			distances[28] = FarView;
			distances[29] = BackGroundView;
			PlayerCamera.GetComponent<Camera>().layerCullDistances = distances;
		}
		else
		{
			distances[26] = PlayerCamera.GetComponent<Camera>().farClipPlane;
			distances[27] = PlayerCamera.GetComponent<Camera>().farClipPlane;
			distances[28] = PlayerCamera.GetComponent<Camera>().farClipPlane;
			distances[29] = PlayerCamera.GetComponent<Camera>().farClipPlane;
			PlayerCamera.GetComponent<Camera>().layerCullDistances = distances;
		}
		if (LODPreview)
		{
			if (EnabledLODSystem && ObjPosition.Length > 0 && Mode == 1)
			{
				if (ObjLodScript[0].gameObject != null)
				{
					if (LODbasedOnScript)
					{
						LODScript();
					}
					else
					{
						LODLay();
					}
				}
			}
			else if (EnabledLODSystem && ObjPosition.Length > 0 && Mode == 2 && ObjLodScript[0] != null)
			{
				for (int i = 0; i < ObjPosition.Length; i++)
				{
					if (ObjLodScript[i] != null)
					{
						if (LODbasedOnScript)
						{
							ObjLodScript[i].AFLODScrpt();
						}
						else
						{
							ObjLodScript[i].AFLODLay();
						}
					}
				}
			}
		}
		if (BillboardPreview && enabledBillboard && BillboardPosition.Length > 0 && BillScript[0] != null)
		{
			if (BilBbasedOnScript)
			{
				BillScrpt();
			}
			else
			{
				BillLay();
			}
		}
	}

	private void BillScrpt()
	{
		for (int i = 0; i < BillboardPosition.Length; i++)
		{
			if (Vector3.Distance(BillboardPosition[i], PlayerCamera.position) <= BillMaxViewDistance)
			{
				if (BillStatus[i] != 1)
				{
					BillScript[i].Render.enabled = true;
					BillStatus[i] = 1;
				}
				if (Axis == 0)
				{
					BillScript[i].Transf.LookAt(new Vector3(PlayerCamera.position.x, BillScript[i].Transf.position.y, PlayerCamera.position.z), Vector3.up);
				}
				else
				{
					BillScript[i].Transf.LookAt(PlayerCamera.position, Vector3.up);
				}
			}
			else if (BillStatus[i] != 0 && !BillScript[i].Render.enabled)
			{
				BillScript[i].Render.enabled = false;
				BillStatus[i] = 0;
			}
		}
	}

	private void BillLay()
	{
		for (int i = 0; i < BillboardPosition.Length; i++)
		{
			int layer = BillScript[i].gameObject.layer;
			if (Vector3.Distance(BillboardPosition[i], PlayerCamera.position) <= distances[layer])
			{
				if (Axis == 0)
				{
					BillScript[i].Transf.LookAt(new Vector3(PlayerCamera.position.x, BillScript[i].Transf.position.y, PlayerCamera.position.z), Vector3.up);
				}
				else
				{
					BillScript[i].Transf.LookAt(PlayerCamera.position, Vector3.up);
				}
			}
		}
	}

	private void LODScript()
	{
		if (OldPlayerPos == PlayerCamera.position)
		{
			return;
		}
		OldPlayerPos = PlayerCamera.position;
		for (int i = 0; i < ObjPosition.Length; i++)
		{
			float num = Vector3.Distance(new Vector3(ObjPosition[i].x, PlayerCamera.position.y, ObjPosition[i].z), PlayerCamera.position);
			if (num <= MaxViewDistance)
			{
				if (num < LOD2Start && ObjLodStatus[i] != 1)
				{
					Renderer lOD = ObjLodScript[i].LOD2;
					bool flag = false;
					ObjLodScript[i].LOD3.enabled = flag;
					lOD.enabled = flag;
					ObjLodScript[i].LOD1.enabled = true;
					ObjLodStatus[i] = 1;
				}
				else if (num >= LOD2Start && num < LOD3Start && ObjLodStatus[i] != 2)
				{
					Renderer lOD2 = ObjLodScript[i].LOD1;
					bool flag = false;
					ObjLodScript[i].LOD3.enabled = flag;
					lOD2.enabled = flag;
					ObjLodScript[i].LOD2.enabled = true;
					ObjLodStatus[i] = 2;
				}
				else if (num >= LOD3Start && ObjLodStatus[i] != 3)
				{
					Renderer lOD3 = ObjLodScript[i].LOD2;
					bool flag = false;
					ObjLodScript[i].LOD1.enabled = flag;
					lOD3.enabled = flag;
					ObjLodScript[i].LOD3.enabled = true;
					ObjLodStatus[i] = 3;
				}
			}
			else if (ObjLodStatus[i] != 0)
			{
				Renderer lOD4 = ObjLodScript[i].LOD1;
				bool flag = false;
				ObjLodScript[i].LOD3.enabled = flag;
				flag = flag;
				ObjLodScript[i].LOD2.enabled = flag;
				lOD4.enabled = flag;
				ObjLodStatus[i] = 0;
			}
		}
	}

	private void LODLay()
	{
		if (OldPlayerPos == PlayerCamera.position)
		{
			return;
		}
		OldPlayerPos = PlayerCamera.position;
		for (int i = 0; i < ObjPosition.Length; i++)
		{
			float num = Vector3.Distance(new Vector3(ObjPosition[i].x, PlayerCamera.position.y, ObjPosition[i].z), PlayerCamera.position);
			int layer = ObjLodScript[i].gameObject.layer;
			if (num <= distances[layer] + 5f)
			{
				if (num < LOD2Start && ObjLodStatus[i] != 1)
				{
					Renderer lOD = ObjLodScript[i].LOD2;
					bool flag = false;
					ObjLodScript[i].LOD3.enabled = flag;
					lOD.enabled = flag;
					ObjLodScript[i].LOD1.enabled = true;
					ObjLodStatus[i] = 1;
				}
				else if (num >= LOD2Start && num < LOD3Start && ObjLodStatus[i] != 2)
				{
					Renderer lOD2 = ObjLodScript[i].LOD1;
					bool flag = false;
					ObjLodScript[i].LOD3.enabled = flag;
					lOD2.enabled = flag;
					ObjLodScript[i].LOD2.enabled = true;
					ObjLodStatus[i] = 2;
				}
				else if (num >= LOD3Start && ObjLodStatus[i] != 3)
				{
					Renderer lOD3 = ObjLodScript[i].LOD2;
					bool flag = false;
					ObjLodScript[i].LOD1.enabled = flag;
					lOD3.enabled = flag;
					ObjLodScript[i].LOD3.enabled = true;
					ObjLodStatus[i] = 3;
				}
			}
		}
	}
}
public class T4MPartSC : MonoBehaviour
{
}
public class T4MPlantObjSC : MonoBehaviour
{
}
public class FlyCam : MonoBehaviour
{
	private int currentWaypoint;

	public float rotateSpeed = 1f;

	public float moveSpeed = 10f;

	public float magnitudeMax = 10f;

	private void Update()
	{
		if (WaypointCam.waypoints.Length <= 0)
		{
			return;
		}
		Vector3 vector = base.transform.InverseTransformPoint(new Vector3(WaypointCam.waypoints[currentWaypoint].position.x, WaypointCam.waypoints[currentWaypoint].position.y, WaypointCam.waypoints[currentWaypoint].position.z));
		Vector3 vector2 = new Vector3(WaypointCam.waypoints[currentWaypoint].position.x, WaypointCam.waypoints[currentWaypoint].position.y, WaypointCam.waypoints[currentWaypoint].position.z);
		Quaternion b = Quaternion.LookRotation(vector2 - base.transform.position);
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, Time.deltaTime * rotateSpeed);
		Vector3 vector3 = base.transform.TransformDirection(Vector3.forward);
		base.transform.position += vector3 * moveSpeed * Time.deltaTime;
		if (vector.magnitude < magnitudeMax)
		{
			currentWaypoint++;
			if (currentWaypoint >= WaypointCam.waypoints.Length)
			{
				currentWaypoint = 0;
			}
		}
	}
}
public class WaypointCam : MonoBehaviour
{
	public Color WaypointsColor = new Color(1f, 0f, 0f, 1f);

	public bool draw = true;

	public static Transform[] waypoints;

	private void Awake()
	{
		waypoints = base.gameObject.GetComponentsInChildren<Transform>();
	}

	private void OnDrawGizmos()
	{
		if (draw)
		{
			waypoints = base.gameObject.GetComponentsInChildren<Transform>();
			Transform[] array = waypoints;
			foreach (Transform transform in array)
			{
				Gizmos.color = WaypointsColor;
				Gizmos.DrawSphere(transform.position, 1f);
				Gizmos.color = WaypointsColor;
				Gizmos.DrawWireSphere(transform.position, 6f);
			}
		}
	}
}
namespace TMPro.Examples
{
	public class Benchmark01 : MonoBehaviour
	{
		public int BenchmarkType;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshPro m_textMeshPro;

		private TextContainer m_textContainer;

		private TextMesh m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>{0}";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
				m_textMeshPro.autoSizeTextContainer = true;
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_textMeshPro.enableWordWrapping = false;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load("Fonts & Materials/LiberationSans SDF - Drop Shadow", typeof(Material)) as Material;
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<TextMesh>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				else
				{
					m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.anchor = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.SetText("The <#0050FF>count is: </color>{0}", i % 1000);
					if (i % 1000 == 999)
					{
						TextMeshPro textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (m_textMeshPro.fontSharedMaterial == m_material01)
						{
							Material material = m_material02;
							m_textMeshPro.fontSharedMaterial = material;
							fontSharedMaterial = material;
						}
						else
						{
							Material material = m_material01;
							m_textMeshPro.fontSharedMaterial = material;
							fontSharedMaterial = material;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark01_UGUI : MonoBehaviour
	{
		public int BenchmarkType;

		public Canvas canvas;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshProUGUI m_textMeshPro;

		private Text m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshProUGUI>();
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load("Fonts & Materials/LiberationSans SDF - BEVEL", typeof(Material)) as Material;
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<Text>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.alignment = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.text = "The <#0050FF>count is: </color>" + i % 1000;
					if (i % 1000 == 999)
					{
						TextMeshProUGUI textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (m_textMeshPro.fontSharedMaterial == m_material01)
						{
							Material material = m_material02;
							m_textMeshPro.fontSharedMaterial = material;
							fontSharedMaterial = material;
						}
						else
						{
							Material material = m_material01;
							m_textMeshPro.fontSharedMaterial = material;
							fontSharedMaterial = material;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark02 : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		private TextMeshProFloatingText floatingText_Script;

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.autoSizeTextContainer = true;
					textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0f);
					textMeshPro.alignment = TextAlignmentOptions.Bottom;
					textMeshPro.fontSize = 96f;
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshPro.text = "!";
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else if (SpawnType == 1)
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
					textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
				else if (SpawnType == 2)
				{
					GameObject gameObject3 = new GameObject();
					Canvas canvas = gameObject3.AddComponent<Canvas>();
					canvas.worldCamera = Camera.main;
					gameObject3.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
					gameObject3.transform.position = new Vector3(Random.Range(-95f, 95f), 5f, Random.Range(-95f, 95f));
					TextMeshProUGUI textMeshProUGUI = new GameObject().AddComponent<TextMeshProUGUI>();
					textMeshProUGUI.rectTransform.SetParent(gameObject3.transform, worldPositionStays: false);
					textMeshProUGUI.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshProUGUI.alignment = TextAlignmentOptions.Bottom;
					textMeshProUGUI.fontSize = 96f;
					textMeshProUGUI.text = "!";
					floatingText_Script = gameObject3.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
			}
		}
	}
	public class Benchmark03 : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		public Font TheFont;

		private void Awake()
		{
		}

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(0f, 0f, 0f);
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.alignment = TextAlignmentOptions.Center;
					textMeshPro.fontSize = 96f;
					textMeshPro.text = "@";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
				}
				else
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(0f, 0f, 0f);
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
					textMesh.font = TheFont;
					textMesh.anchor = TextAnchor.MiddleCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "@";
				}
			}
		}
	}
	public class Benchmark04 : MonoBehaviour
	{
		public int SpawnType;

		public int MinPointSize = 12;

		public int MaxPointSize = 64;

		public int Steps = 4;

		private Transform m_Transform;

		private void Start()
		{
			m_Transform = base.transform;
			float num = 0f;
			float num2 = Screen.height / 2;
			Camera.main.orthographicSize = num2;
			float num3 = num2;
			float num4 = (float)Screen.width / (float)Screen.height;
			for (int i = MinPointSize; i <= MaxPointSize; i += Steps)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject("Text - " + i + " Pts");
					if (num > num3 * 2f)
					{
						break;
					}
					gameObject.transform.position = m_Transform.position + new Vector3(num4 * (0f - num3) * 0.975f, num3 * 0.975f - num, 0f);
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.rectTransform.pivot = new Vector2(0f, 0.5f);
					textMeshPro.enableWordWrapping = false;
					textMeshPro.extraPadding = true;
					textMeshPro.isOrthographic = true;
					textMeshPro.fontSize = i;
					textMeshPro.text = i + " pts - Lorem ipsum dolor sit...";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
					num += (float)i;
				}
			}
		}
	}
	public class CameraController : MonoBehaviour
	{
		public enum CameraModes
		{
			Follow,
			Isometric,
			Free
		}

		private Transform cameraTransform;

		private Transform dummyTarget;

		public Transform CameraTarget;

		public float FollowDistance = 30f;

		public float MaxFollowDistance = 100f;

		public float MinFollowDistance = 2f;

		public float ElevationAngle = 30f;

		public float MaxElevationAngle = 85f;

		public float MinElevationAngle;

		public float OrbitalAngle;

		public CameraModes CameraMode;

		public bool MovementSmoothing = true;

		public bool RotationSmoothing;

		private bool previousSmoothing;

		public float MovementSmoothingValue = 25f;

		public float RotationSmoothingValue = 5f;

		public float MoveSensitivity = 2f;

		private Vector3 currentVelocity = Vector3.zero;

		private Vector3 desiredPosition;

		private float mouseX;

		private float mouseY;

		private Vector3 moveVector;

		private float mouseWheel;

		private const string event_SmoothingValue = "Slider - Smoothing Value";

		private const string event_FollowDistance = "Slider - Camera Zoom";

		private void Awake()
		{
			if (QualitySettings.vSyncCount > 0)
			{
				UnityEngine.Application.targetFrameRate = 60;
			}
			else
			{
				UnityEngine.Application.targetFrameRate = -1;
			}
			if (UnityEngine.Application.platform == RuntimePlatform.IPhonePlayer || UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				Input.simulateMouseWithTouches = false;
			}
			cameraTransform = base.transform;
			previousSmoothing = MovementSmoothing;
		}

		private void Start()
		{
			if (CameraTarget == null)
			{
				dummyTarget = new GameObject("Camera Target").transform;
				CameraTarget = dummyTarget;
			}
		}

		private void LateUpdate()
		{
			GetPlayerInput();
			if (CameraTarget != null)
			{
				if (CameraMode == CameraModes.Isometric)
				{
					desiredPosition = CameraTarget.position + Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance);
				}
				else if (CameraMode == CameraModes.Follow)
				{
					desiredPosition = CameraTarget.position + CameraTarget.TransformDirection(Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance));
				}
				if (MovementSmoothing)
				{
					cameraTransform.position = Vector3.SmoothDamp(cameraTransform.position, desiredPosition, ref currentVelocity, MovementSmoothingValue * Time.fixedDeltaTime);
				}
				else
				{
					cameraTransform.position = desiredPosition;
				}
				if (RotationSmoothing)
				{
					cameraTransform.rotation = Quaternion.Lerp(cameraTransform.rotation, Quaternion.LookRotation(CameraTarget.position - cameraTransform.position), RotationSmoothingValue * Time.deltaTime);
				}
				else
				{
					cameraTransform.LookAt(CameraTarget);
				}
			}
		}

		private void GetPlayerInput()
		{
			moveVector = Vector3.zero;
			mouseWheel = Input.GetAxis("Mouse ScrollWheel");
			float num = Input.touchCount;
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || num > 0f)
			{
				mouseWheel *= 10f;
				if (Input.GetKeyDown(KeyCode.I))
				{
					CameraMode = CameraModes.Isometric;
				}
				if (Input.GetKeyDown(KeyCode.F))
				{
					CameraMode = CameraModes.Follow;
				}
				if (Input.GetKeyDown(KeyCode.S))
				{
					MovementSmoothing = !MovementSmoothing;
				}
				if (Input.GetMouseButton(1))
				{
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					if (mouseY > 0.01f || mouseY < -0.01f)
					{
						ElevationAngle -= mouseY * MoveSensitivity;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (mouseX > 0.01f || mouseX < -0.01f)
					{
						OrbitalAngle += mouseX * MoveSensitivity;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (num == 1f && Input.GetTouch(0).phase == TouchPhase.Moved)
				{
					Vector2 deltaPosition = Input.GetTouch(0).deltaPosition;
					if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f)
					{
						ElevationAngle -= deltaPosition.y * 0.1f;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f)
					{
						OrbitalAngle += deltaPosition.x * 0.1f;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (Input.GetMouseButton(0))
				{
					Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
					if (Physics.Raycast(ray, out var hitInfo, 300f, 23552))
					{
						if (hitInfo.transform == CameraTarget)
						{
							OrbitalAngle = 0f;
						}
						else
						{
							CameraTarget = hitInfo.transform;
							OrbitalAngle = 0f;
							MovementSmoothing = previousSmoothing;
						}
					}
				}
				if (Input.GetMouseButton(2))
				{
					if (dummyTarget == null)
					{
						dummyTarget = new GameObject("Camera Target").transform;
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					else if (dummyTarget != CameraTarget)
					{
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					moveVector = cameraTransform.TransformDirection(mouseX, mouseY, 0f);
					dummyTarget.Translate(-moveVector, Space.World);
				}
			}
			if (num == 2f)
			{
				Touch touch = Input.GetTouch(0);
				Touch touch2 = Input.GetTouch(1);
				Vector2 vector = touch.position - touch.deltaPosition;
				Vector2 vector2 = touch2.position - touch2.deltaPosition;
				float magnitude = (vector - vector2).magnitude;
				float magnitude2 = (touch.position - touch2.position).magnitude;
				float num2 = magnitude - magnitude2;
				if (num2 > 0.01f || num2 < -0.01f)
				{
					FollowDistance += num2 * 0.25f;
					FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
				}
			}
			if (mouseWheel < -0.01f || mouseWheel > 0.01f)
			{
				FollowDistance -= mouseWheel * 5f;
				FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
			}
		}
	}
}
public class ChatController : MonoBehaviour
{
	public TMP_InputField TMP_ChatInput;

	public TMP_Text TMP_ChatOutput;

	public Scrollbar ChatScrollbar;

	private void OnEnable()
	{
		TMP_ChatInput.onSubmit.AddListener(AddToChatOutput);
	}

	private void OnDisable()
	{
		TMP_ChatInput.onSubmit.RemoveListener(AddToChatOutput);
	}

	private void AddToChatOutput(string newText)
	{
		TMP_ChatInput.text = string.Empty;
		DateTime now = DateTime.Now;
		TMP_Text tMP_ChatOutput = TMP_ChatOutput;
		string text = tMP_ChatOutput.text;
		tMP_ChatOutput.text = text + "[<#FFFF80>" + now.Hour.ToString("d2") + ":" + now.Minute.ToString("d2") + ":" + now.Second.ToString("d2") + "</color>] " + newText + "\n";
		TMP_ChatInput.ActivateInputField();
		ChatScrollbar.value = 0f;
	}
}
namespace TMPro.Examples
{
	public class ObjectSpin : MonoBehaviour
	{
		public enum MotionType
		{
			Rotation,
			BackAndForth,
			Translation
		}

		public float SpinSpeed = 5f;

		public int RotationRange = 15;

		private Transform m_transform;

		private float m_time;

		private Vector3 m_prevPOS;

		private Vector3 m_initial_Rotation;

		private Vector3 m_initial_Position;

		private Color32 m_lightColor;

		private int frames;

		public MotionType Motion;

		private void Awake()
		{
			m_transform = base.transform;
			m_initial_Rotation = m_transform.rotation.eulerAngles;
			m_initial_Position = m_transform.position;
			Light component = GetComponent<Light>();
			m_lightColor = ((!(component != null)) ? Color.black : component.color);
		}

		private void Update()
		{
			if (Motion == MotionType.Rotation)
			{
				m_transform.Rotate(0f, SpinSpeed * Time.deltaTime, 0f);
				return;
			}
			if (Motion == MotionType.BackAndForth)
			{
				m_time += SpinSpeed * Time.deltaTime;
				m_transform.rotation = Quaternion.Euler(m_initial_Rotation.x, Mathf.Sin(m_time) * (float)RotationRange + m_initial_Rotation.y, m_initial_Rotation.z);
				return;
			}
			m_time += SpinSpeed * Time.deltaTime;
			float x = 15f * Mathf.Cos(m_time * 0.95f);
			float z = 10f;
			float y = 0f;
			m_transform.position = m_initial_Position + new Vector3(x, y, z);
			m_prevPOS = m_transform.position;
			frames++;
		}
	}
	public class ShaderPropAnimator : MonoBehaviour
	{
		private Renderer m_Renderer;

		private Material m_Material;

		public AnimationCurve GlowCurve;

		public float m_frame;

		private void Awake()
		{
			m_Renderer = GetComponent<Renderer>();
			m_Material = m_Renderer.material;
		}

		private void Start()
		{
			StartCoroutine(AnimateProperties());
		}

		private IEnumerator AnimateProperties()
		{
			m_frame = Random.Range(0f, 1f);
			while (true)
			{
				float glowPower = GlowCurve.Evaluate(m_frame);
				m_Material.SetFloat(ShaderUtilities.ID_GlowPower, glowPower);
				m_frame += Time.deltaTime * Random.Range(0.2f, 0.3f);
				yield return new WaitForEndOfFrame();
			}
		}
	}
	public class SimpleScript : MonoBehaviour
	{
		private TextMeshPro m_textMeshPro;

		private const string label = "The <#0050FF>count is: </color>{0:2}";

		private float m_frame;

		private void Start()
		{
			m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
			m_textMeshPro.autoSizeTextContainer = true;
			m_textMeshPro.fontSize = 48f;
			m_textMeshPro.alignment = TextAlignmentOptions.Center;
			m_textMeshPro.enableWordWrapping = false;
		}

		private void Update()
		{
			m_textMeshPro.SetText("The <#0050FF>count is: </color>{0:2}", m_frame % 1000f);
			m_frame += 1f * Time.deltaTime;
		}
	}
	public class SkewTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float CurveScale = 1f;

		public float ShearAmount = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			AnimationCurve animationCurve = new AnimationCurve();
			animationCurve.keys = curve.keys;
			return animationCurve;
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			float old_ShearValue = ShearAmount;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value && old_ShearValue == ShearAmount)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				old_ShearValue = ShearAmount;
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float boundsMinX = m_TextComponent.bounds.min.x;
				float boundsMaxX = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = ShearAmount * 0.01f;
						Vector3 vector2 = new Vector3(num * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0f, 0f);
						Vector3 vector3 = new Vector3(num * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0f, 0f);
						vertices[vertexIndex] += -vector3;
						vertices[vertexIndex + 1] += vector2;
						vertices[vertexIndex + 2] += vector2;
						vertices[vertexIndex + 3] += -vector3;
						float num2 = (vector.x - boundsMinX) / (boundsMaxX - boundsMinX);
						float num3 = num2 + 0.0001f;
						float y = VertexCurve.Evaluate(num2) * CurveScale;
						float y2 = VertexCurve.Evaluate(num3) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num3 * (boundsMaxX - boundsMinX) + boundsMinX, y2) - new Vector3(vector.x, y);
						float num4 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((!(Vector3.Cross(lhs, rhs).z > 0f)) ? (360f - num4) : num4);
						Matrix4x4 matrix = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						ref Vector3 reference = ref vertices[vertexIndex];
						reference = matrix.MultiplyPoint3x4(vertices[vertexIndex]);
						ref Vector3 reference2 = ref vertices[vertexIndex + 1];
						reference2 = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						ref Vector3 reference3 = ref vertices[vertexIndex + 2];
						reference3 = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						ref Vector3 reference4 = ref vertices[vertexIndex + 3];
						reference4 = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return null;
			}
		}
	}
	public class TeleType : MonoBehaviour
	{
		private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>";

		private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>";

		private TMP_Text m_textMeshPro;

		private void Awake()
		{
			m_textMeshPro = GetComponent<TMP_Text>();
			m_textMeshPro.text = label01;
			m_textMeshPro.enableWordWrapping = true;
			m_textMeshPro.alignment = TextAlignmentOptions.Top;
		}

		private IEnumerator Start()
		{
			m_textMeshPro.ForceMeshUpdate();
			int totalVisibleCharacters = m_textMeshPro.textInfo.characterCount;
			int counter = 0;
			int visibleCount2 = 0;
			while (true)
			{
				visibleCount2 = counter % (totalVisibleCharacters + 1);
				m_textMeshPro.maxVisibleCharacters = visibleCount2;
				if (visibleCount2 >= totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
					m_textMeshPro.text = label02;
					yield return new WaitForSeconds(1f);
					m_textMeshPro.text = label01;
					yield return new WaitForSeconds(1f);
				}
				counter++;
				yield return new WaitForSeconds(0.05f);
			}
		}
	}
	public class TextConsoleSimulator : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(RevealCharacters(m_TextComponent));
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			hasTextChanged = true;
		}

		private IEnumerator RevealCharacters(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = textComponent.textInfo;
			int totalVisibleCharacters = textInfo.characterCount;
			int visibleCount = 0;
			while (true)
			{
				if (hasTextChanged)
				{
					totalVisibleCharacters = textInfo.characterCount;
					hasTextChanged = false;
				}
				if (visibleCount > totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
					visibleCount = 0;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				visibleCount++;
				yield return new WaitForSeconds(0f);
			}
		}

		private IEnumerator RevealWords(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			int totalWordCount = textComponent.textInfo.wordCount;
			int totalVisibleCharacters = textComponent.textInfo.characterCount;
			int counter = 0;
			int currentWord2 = 0;
			int visibleCount = 0;
			while (true)
			{
				currentWord2 = counter % (totalWordCount + 1);
				if (currentWord2 == 0)
				{
					visibleCount = 0;
				}
				else if (currentWord2 < totalWordCount)
				{
					visibleCount = textComponent.textInfo.wordInfo[currentWord2 - 1].lastCharacterIndex + 1;
				}
				else if (currentWord2 == totalWordCount)
				{
					visibleCount = totalVisibleCharacters;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				if (visibleCount >= totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
				}
				counter++;
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class TextMeshProFloatingText : MonoBehaviour
	{
		public Font TheFont;

		private GameObject m_floatingText;

		private TextMeshPro m_textMeshPro;

		private TextMesh m_textMesh;

		private Transform m_transform;

		private Transform m_floatingText_Transform;

		private Transform m_cameraTransform;

		private Vector3 lastPOS = Vector3.zero;

		private Quaternion lastRotation = Quaternion.identity;

		public int SpawnType;

		private void Awake()
		{
			m_transform = base.transform;
			m_floatingText = new GameObject(base.name + " floating text");
			m_cameraTransform = Camera.main.transform;
		}

		private void Start()
		{
			if (SpawnType == 0)
			{
				m_textMeshPro = m_floatingText.AddComponent<TextMeshPro>();
				m_textMeshPro.rectTransform.sizeDelta = new Vector2(3f, 3f);
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);
				m_textMeshPro.fontSize = 24f;
				m_textMeshPro.text = string.Empty;
				StartCoroutine(DisplayTextMeshProFloatingText());
			}
			else if (SpawnType == 1)
			{
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMesh = m_floatingText.AddComponent<TextMesh>();
				m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
				m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				m_textMesh.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);
				m_textMesh.anchor = TextAnchor.LowerCenter;
				m_textMesh.fontSize = 24;
				StartCoroutine(DisplayTextMeshFloatingText());
			}
			else if (SpawnType != 2)
			{
			}
		}

		public IEnumerator DisplayTextMeshProFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMeshPro.color;
			float alpha = 255f;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMeshPro.SetText("{0}", (int)current_Count);
				m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return new WaitForEndOfFrame();
			}
			yield return new WaitForSeconds(Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshProFloatingText());
		}

		public IEnumerator DisplayTextMeshFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMesh.color;
			float alpha = 255f;
			int int_counter = 0;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMesh.text = ((int)current_Count).ToString();
				m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return new WaitForEndOfFrame();
			}
			yield return new WaitForSeconds(Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshFloatingText());
		}
	}
	public class TextMeshSpawner : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		public Font TheFont;

		private TextMeshProFloatingText floatingText_Script;

		private void Awake()
		{
		}

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.fontSize = 96f;
					textMeshPro.text = "!";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
					textMesh.font = TheFont;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
			}
		}
	}
}
namespace TMPro
{
	[Serializable]
	public class TMP_DigitValidator : TMP_InputValidator
	{
		public override char Validate(ref string text, ref int pos, char ch)
		{
			if (ch >= '0' && ch <= '9')
			{
				pos++;
				return ch;
			}
			return '\0';
		}
	}
}
namespace TMPro.Examples
{
	public class TMP_ExampleScript_01 : MonoBehaviour
	{
		public enum objectType
		{
			TextMeshPro,
			TextMeshProUGUI
		}

		public objectType ObjectType;

		public bool isStatic;

		private TMP_Text m_text;

		private const string k_label = "The count is <#0080ff>{0}</color>";

		private int count;

		private void Awake()
		{
			if (ObjectType == objectType.TextMeshPro)
			{
				m_text = GetComponent<TextMeshPro>() ?? base.gameObject.AddComponent<TextMeshPro>();
			}
			else
			{
				m_text = GetComponent<TextMeshProUGUI>() ?? base.gameObject.AddComponent<TextMeshProUGUI>();
			}
			m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF");
			m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow");
			m_text.fontSize = 120f;
			m_text.text = "A <#0080ff>simple</color> line of text.";
			Vector2 preferredValues = m_text.GetPreferredValues(float.PositiveInfinity, float.PositiveInfinity);
			m_text.rectTransform.sizeDelta = new Vector2(preferredValues.x, preferredValues.y);
		}

		private void Update()
		{
			if (!isStatic)
			{
				m_text.SetText("The count is <#0080ff>{0}</color>", count % 1000);
				count++;
			}
		}
	}
	public class TMP_FrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> FPS \n{1:2} <#8080ff>MS";

		private TextMeshPro m_TextMeshPro;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				UnityEngine.Application.targetFrameRate = -1;
				GameObject gameObject = new GameObject("Frame Counter");
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
				m_TextMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Overlay", typeof(Material)) as Material;
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.SetParent(m_camera.transform);
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 24f;
				m_TextMeshPro.isOverlay = true;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> FPS \n{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f);
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class TMP_TextEventCheck : MonoBehaviour
	{
		public TMP_TextEventHandler TextEventHandler;

		private void OnEnable()
		{
			if (TextEventHandler != null)
			{
				TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection);
				TextEventHandler.onWordSelection.AddListener(OnWordSelection);
				TextEventHandler.onLinkSelection.AddListener(OnLinkSelection);
			}
		}

		private void OnDisable()
		{
			if (TextEventHandler != null)
			{
				TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection);
				TextEventHandler.onWordSelection.RemoveListener(OnWordSelection);
				TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection);
			}
		}

		private void OnCharacterSelection(char c, int index)
		{
			Debug.Log("Character [" + c + "] at Index: " + index + " has been selected.");
		}

		private void OnWordSelection(string word, int firstCharacterIndex, int length)
		{
			Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
		}

		private void OnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \"" + linkText + "\" has been selected.");
		}
	}
}
namespace TMPro
{
	public class TMP_TextEventHandler : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IEventSystemHandler
	{
		[Serializable]
		public class CharacterSelectionEvent : UnityEvent<char, int>
		{
		}

		[Serializable]
		public class WordSelectionEvent : UnityEvent<string, int, int>
		{
		}

		[Serializable]
		public class LinkSelectionEvent : UnityEvent<string, string, int>
		{
		}

		[SerializeField]
		private CharacterSelectionEvent m_OnCharacterSelection = new CharacterSelectionEvent();

		[SerializeField]
		private WordSelectionEvent m_OnWordSelection = new WordSelectionEvent();

		[SerializeField]
		private LinkSelectionEvent m_OnLinkSelection = new LinkSelectionEvent();

		private TMP_Text m_TextComponent;

		private Camera m_Camera;

		private Canvas m_Canvas;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		public CharacterSelectionEvent onCharacterSelection
		{
			get
			{
				return m_OnCharacterSelection;
			}
			set
			{
				m_OnCharacterSelection = value;
			}
		}

		public WordSelectionEvent onWordSelection
		{
			get
			{
				return m_OnWordSelection;
			}
			set
			{
				m_OnWordSelection = value;
			}
		}

		public LinkSelectionEvent onLinkSelection
		{
			get
			{
				return m_OnLinkSelection;
			}
			set
			{
				m_OnLinkSelection = value;
			}
		}

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
			if (m_TextComponent.GetType() == typeof(TextMeshProUGUI))
			{
				m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
				if (m_Canvas != null)
				{
					if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
					{
						m_Camera = null;
					}
					else
					{
						m_Camera = m_Canvas.worldCamera;
					}
				}
			}
			else
			{
				m_Camera = Camera.main;
			}
		}

		private void LateUpdate()
		{
			if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextComponent.rectTransform, Input.mousePosition, m_Camera))
			{
				int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextComponent, Input.mousePosition, m_Camera, visibleOnly: true);
				if (num != -1 && num != m_lastCharIndex)
				{
					m_lastCharIndex = num;
					SendOnCharacterSelection(m_TextComponent.textInfo.characterInfo[num].character, num);
				}
				int num2 = TMP_TextUtilities.FindIntersectingWord(m_TextComponent, Input.mousePosition, m_Camera);
				if (num2 != -1 && num2 != m_lastWordIndex)
				{
					m_lastWordIndex = num2;
					TMP_WordInfo tMP_WordInfo = m_TextComponent.textInfo.wordInfo[num2];
					SendOnWordSelection(tMP_WordInfo.GetWord(), tMP_WordInfo.firstCharacterIndex, tMP_WordInfo.characterCount);
				}
				int num3 = TMP_TextUtilities.FindIntersectingLink(m_TextComponent, Input.mousePosition, m_Camera);
				if (num3 != -1 && num3 != m_selectedLink)
				{
					m_selectedLink = num3;
					TMP_LinkInfo tMP_LinkInfo = m_TextComponent.textInfo.linkInfo[num3];
					SendOnLinkSelection(tMP_LinkInfo.GetLinkID(), tMP_LinkInfo.GetLinkText(), num3);
				}
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
		}

		public void OnPointerExit(PointerEventData eventData)
		{
		}

		private void SendOnCharacterSelection(char character, int characterIndex)
		{
			if (onCharacterSelection != null)
			{
				onCharacterSelection.Invoke(character, characterIndex);
			}
		}

		private void SendOnWordSelection(string word, int charIndex, int length)
		{
			if (onWordSelection != null)
			{
				onWordSelection.Invoke(word, charIndex, length);
			}
		}

		private void SendOnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			if (onLinkSelection != null)
			{
				onLinkSelection.Invoke(linkID, linkText, linkIndex);
			}
		}
	}
}
namespace TMPro.Examples
{
	[ExecuteInEditMode]
	public class TMP_TextInfoDebugTool : MonoBehaviour
	{
		public bool ShowCharacters;

		public bool ShowWords;

		public bool ShowLinks;

		public bool ShowLines;

		public bool ShowMeshBounds;

		public bool ShowTextBounds;

		[Space(10f)]
		[TextArea(2, 2)]
		public string ObjectStats;

		private TMP_Text m_TextComponent;

		private Transform m_Transform;
	}
	public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IEventSystemHandler
	{
		private TextMeshPro m_TextMeshPro;

		private Camera m_Camera;

		private bool m_isHoveringObject;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshPro>();
			m_Camera = Camera.main;
			m_TextMeshPro.ForceMeshUpdate();
		}

		private void LateUpdate()
		{
			m_isHoveringObject = false;
			if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main))
			{
				m_isHoveringObject = true;
			}
			if (!m_isHoveringObject)
			{
				return;
			}
			int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, Camera.main, visibleOnly: true);
			if (num != -1 && num != m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
			{
				m_lastCharIndex = num;
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
				Color32 color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				colors[vertexIndex] = color;
				colors[vertexIndex + 1] = color;
				colors[vertexIndex + 2] = color;
				colors[vertexIndex + 3] = color;
				m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].mesh.colors32 = colors;
			}
			int num2 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
			if ((num2 == -1 && m_selectedLink != -1) || num2 != m_selectedLink)
			{
				m_selectedLink = -1;
			}
			if (num2 != -1 && num2 != m_selectedLink)
			{
				m_selectedLink = num2;
				TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num2];
				Debug.Log("Link ID: \"" + tMP_LinkInfo.GetLinkID() + "\"   Link Text: \"" + tMP_LinkInfo.GetLinkText() + "\"");
				Vector3 worldPoint = Vector3.zero;
				RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPoint);
				switch (tMP_LinkInfo.GetLinkID())
				{
				}
			}
			int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, Camera.main);
			if (num3 != -1 && num3 != m_lastWordIndex)
			{
				m_lastWordIndex = num3;
				TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[num3];
				Vector3 position = m_TextMeshPro.transform.TransformPoint(m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex].bottomLeft);
				position = Camera.main.WorldToScreenPoint(position);
				Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[0].colors32;
				Color32 color2 = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);
				for (int i = 0; i < tMP_WordInfo.characterCount; i++)
				{
					int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex + i].vertexIndex;
					colors2[vertexIndex2] = color2;
					colors2[vertexIndex2 + 1] = color2;
					colors2[vertexIndex2 + 2] = color2;
					colors2[vertexIndex2 + 3] = color2;
				}
				m_TextMeshPro.mesh.colors32 = colors2;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			Debug.Log("OnPointerEnter()");
			m_isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			Debug.Log("OnPointerExit()");
			m_isHoveringObject = false;
		}
	}
	public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler, IEventSystemHandler
	{
		public RectTransform TextPopup_Prefab_01;

		private RectTransform m_TextPopup_RectTransform;

		private TextMeshProUGUI m_TextPopup_TMPComponent;

		private const string k_LinkText = "You have selected link <#ffff00>";

		private const string k_WordText = "Word Index: <#ffff00>";

		private TextMeshProUGUI m_TextMeshPro;

		private Canvas m_Canvas;

		private Camera m_Camera;

		private bool isHoveringObject;

		private int m_selectedWord = -1;

		private int m_selectedLink = -1;

		private int m_lastIndex = -1;

		private Matrix4x4 m_matrix;

		private TMP_MeshInfo[] m_cachedMeshInfoVertexData;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshProUGUI>();
			m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
			if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
			{
				m_Camera = null;
			}
			else
			{
				m_Camera = m_Canvas.worldCamera;
			}
			m_TextPopup_RectTransform = UnityEngine.Object.Instantiate(TextPopup_Prefab_01);
			m_TextPopup_RectTransform.SetParent(m_Canvas.transform, worldPositionStays: false);
			m_TextPopup_TMPComponent = m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>();
			m_TextPopup_RectTransform.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextMeshPro)
			{
				m_cachedMeshInfoVertexData = m_TextMeshPro.textInfo.CopyMeshInfoVertexData();
			}
		}

		private void LateUpdate()
		{
			if (isHoveringObject)
			{
				int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, visibleOnly: true);
				if (num == -1 || num != m_lastIndex)
				{
					RestoreCachedVertexAttributes(m_lastIndex);
					m_lastIndex = -1;
				}
				if (num != -1 && num != m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
				{
					m_lastIndex = num;
					int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
					int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
					Vector3[] vertices = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
					Vector2 vector = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;
					Vector3 vector2 = vector;
					ref Vector3 reference = ref vertices[vertexIndex];
					reference = vertices[vertexIndex] - vector2;
					ref Vector3 reference2 = ref vertices[vertexIndex + 1];
					reference2 = vertices[vertexIndex + 1] - vector2;
					ref Vector3 reference3 = ref vertices[vertexIndex + 2];
					reference3 = vertices[vertexIndex + 2] - vector2;
					ref Vector3 reference4 = ref vertices[vertexIndex + 3];
					reference4 = vertices[vertexIndex + 3] - vector2;
					float num2 = 1.5f;
					m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * num2);
					ref Vector3 reference5 = ref vertices[vertexIndex];
					reference5 = m_matrix.MultiplyPoint3x4(vertices[vertexIndex]);
					ref Vector3 reference6 = ref vertices[vertexIndex + 1];
					reference6 = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
					ref Vector3 reference7 = ref vertices[vertexIndex + 2];
					reference7 = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
					ref Vector3 reference8 = ref vertices[vertexIndex + 3];
					reference8 = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);
					ref Vector3 reference9 = ref vertices[vertexIndex];
					reference9 = vertices[vertexIndex] + vector2;
					ref Vector3 reference10 = ref vertices[vertexIndex + 1];
					reference10 = vertices[vertexIndex + 1] + vector2;
					ref Vector3 reference11 = ref vertices[vertexIndex + 2];
					reference11 = vertices[vertexIndex + 2] + vector2;
					ref Vector3 reference12 = ref vertices[vertexIndex + 3];
					reference12 = vertices[vertexIndex + 3] + vector2;
					Color32 color = new Color32(byte.MaxValue, byte.MaxValue, 192, byte.MaxValue);
					Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
					colors[vertexIndex] = color;
					colors[vertexIndex + 1] = color;
					colors[vertexIndex + 2] = color;
					colors[vertexIndex + 3] = color;
					TMP_MeshInfo tMP_MeshInfo = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex];
					int dst = vertices.Length - 4;
					tMP_MeshInfo.SwapVertexData(vertexIndex, dst);
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);
				if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (num3 == -1 || num3 != m_selectedWord))
				{
					TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];
					for (int i = 0; i < tMP_WordInfo.characterCount; i++)
					{
						int num4 = tMP_WordInfo.firstCharacterIndex + i;
						int materialReferenceIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].materialReferenceIndex;
						int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].vertexIndex;
						Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex2].colors32;
						Color32 color2 = colors2[vertexIndex2].Tint(1.33333f);
						colors2[vertexIndex2] = color2;
						colors2[vertexIndex2 + 1] = color2;
						colors2[vertexIndex2 + 2] = color2;
						colors2[vertexIndex2 + 3] = color2;
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
					m_selectedWord = -1;
				}
				if (num3 != -1 && num3 != m_selectedWord && !Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift))
				{
					m_selectedWord = num3;
					TMP_WordInfo tMP_WordInfo2 = m_TextMeshPro.textInfo.wordInfo[num3];
					for (int j = 0; j < tMP_WordInfo2.characterCount; j++)
					{
						int num5 = tMP_WordInfo2.firstCharacterIndex + j;
						int materialReferenceIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].materialReferenceIndex;
						int vertexIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].vertexIndex;
						Color32[] colors3 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex3].colors32;
						Color32 color3 = colors3[vertexIndex3].Tint(0.75f);
						colors3[vertexIndex3] = color3;
						colors3[vertexIndex3 + 1] = color3;
						colors3[vertexIndex3 + 2] = color3;
						colors3[vertexIndex3 + 3] = color3;
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num6 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
				if ((num6 == -1 && m_selectedLink != -1) || num6 != m_selectedLink)
				{
					m_TextPopup_RectTransform.gameObject.SetActive(value: false);
					m_selectedLink = -1;
				}
				if (num6 != -1 && num6 != m_selectedLink)
				{
					m_selectedLink = num6;
					TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num6];
					Vector3 worldPoint = Vector3.zero;
					RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPoint);
					switch (tMP_LinkInfo.GetLinkID())
					{
					case "id_01":
						m_TextPopup_RectTransform.position = worldPoint;
						m_TextPopup_RectTransform.gameObject.SetActive(value: true);
						m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 01";
						break;
					case "id_02":
						m_TextPopup_RectTransform.position = worldPoint;
						m_TextPopup_RectTransform.gameObject.SetActive(value: true);
						m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 02";
						break;
					}
				}
			}
			else if (m_lastIndex != -1)
			{
				RestoreCachedVertexAttributes(m_lastIndex);
				m_lastIndex = -1;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHoveringObject = false;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
		}

		public void OnPointerUp(PointerEventData eventData)
		{
		}

		private void RestoreCachedVertexAttributes(int index)
		{
			if (index != -1 && index <= m_TextMeshPro.textInfo.characterCount - 1)
			{
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[index].vertexIndex;
				Vector3[] vertices = m_cachedMeshInfoVertexData[materialReferenceIndex].vertices;
				Vector3[] vertices2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
				ref Vector3 reference = ref vertices2[vertexIndex];
				reference = vertices[vertexIndex];
				ref Vector3 reference2 = ref vertices2[vertexIndex + 1];
				reference2 = vertices[vertexIndex + 1];
				ref Vector3 reference3 = ref vertices2[vertexIndex + 2];
				reference3 = vertices[vertexIndex + 2];
				ref Vector3 reference4 = ref vertices2[vertexIndex + 3];
				reference4 = vertices[vertexIndex + 3];
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				Color32[] colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				ref Color32 reference5 = ref colors[vertexIndex];
				reference5 = colors2[vertexIndex];
				ref Color32 reference6 = ref colors[vertexIndex + 1];
				reference6 = colors2[vertexIndex + 1];
				ref Color32 reference7 = ref colors[vertexIndex + 2];
				reference7 = colors2[vertexIndex + 2];
				ref Color32 reference8 = ref colors[vertexIndex + 3];
				reference8 = colors2[vertexIndex + 3];
				Vector2[] uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				Vector2[] uvs2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				ref Vector2 reference9 = ref uvs2[vertexIndex];
				reference9 = uvs[vertexIndex];
				ref Vector2 reference10 = ref uvs2[vertexIndex + 1];
				reference10 = uvs[vertexIndex + 1];
				ref Vector2 reference11 = ref uvs2[vertexIndex + 2];
				reference11 = uvs[vertexIndex + 2];
				ref Vector2 reference12 = ref uvs2[vertexIndex + 3];
				reference12 = uvs[vertexIndex + 3];
				Vector2[] uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				Vector2[] uvs4 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				ref Vector2 reference13 = ref uvs4[vertexIndex];
				reference13 = uvs3[vertexIndex];
				ref Vector2 reference14 = ref uvs4[vertexIndex + 1];
				reference14 = uvs3[vertexIndex + 1];
				ref Vector2 reference15 = ref uvs4[vertexIndex + 2];
				reference15 = uvs3[vertexIndex + 2];
				ref Vector2 reference16 = ref uvs4[vertexIndex + 3];
				reference16 = uvs3[vertexIndex + 3];
				int num = (vertices.Length / 4 - 1) * 4;
				ref Vector3 reference17 = ref vertices2[num];
				reference17 = vertices[num];
				ref Vector3 reference18 = ref vertices2[num + 1];
				reference18 = vertices[num + 1];
				ref Vector3 reference19 = ref vertices2[num + 2];
				reference19 = vertices[num + 2];
				ref Vector3 reference20 = ref vertices2[num + 3];
				reference20 = vertices[num + 3];
				colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				ref Color32 reference21 = ref colors[num];
				reference21 = colors2[num];
				ref Color32 reference22 = ref colors[num + 1];
				reference22 = colors2[num + 1];
				ref Color32 reference23 = ref colors[num + 2];
				reference23 = colors2[num + 2];
				ref Color32 reference24 = ref colors[num + 3];
				reference24 = colors2[num + 3];
				uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				uvs2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				ref Vector2 reference25 = ref uvs2[num];
				reference25 = uvs[num];
				ref Vector2 reference26 = ref uvs2[num + 1];
				reference26 = uvs[num + 1];
				ref Vector2 reference27 = ref uvs2[num + 2];
				reference27 = uvs[num + 2];
				ref Vector2 reference28 = ref uvs2[num + 3];
				reference28 = uvs[num + 3];
				uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				uvs4 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				ref Vector2 reference29 = ref uvs4[num];
				reference29 = uvs3[num];
				ref Vector2 reference30 = ref uvs4[num + 1];
				reference30 = uvs3[num + 1];
				ref Vector2 reference31 = ref uvs4[num + 2];
				reference31 = uvs3[num + 2];
				ref Vector2 reference32 = ref uvs4[num + 3];
				reference32 = uvs3[num + 3];
				m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
			}
		}
	}
	public class TMP_UiFrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> FPS \n{1:2} <#8080ff>MS";

		private TextMeshProUGUI m_TextMeshPro;

		private RectTransform m_frameCounter_transform;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				UnityEngine.Application.targetFrameRate = 120;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.AddComponent<RectTransform>();
				m_frameCounter_transform.SetParent(base.transform, worldPositionStays: false);
				m_TextMeshPro = gameObject.AddComponent<TextMeshProUGUI>();
				m_TextMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
				m_TextMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Overlay", typeof(Material)) as Material;
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 36f;
				m_TextMeshPro.isOverlay = true;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> FPS \n{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 0f);
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 0f);
				break;
			}
		}
	}
	public class TMPro_InstructionOverlay : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.BottomLeft;

		private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";

		private TextMeshPro m_TextMeshPro;

		private TextContainer m_textContainer;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.parent = m_camera.transform;
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset;
				m_TextMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Overlay", typeof(Material)) as Material;
				m_TextMeshPro.fontSize = 30f;
				m_TextMeshPro.isOverlay = true;
				m_textContainer = gameObject.GetComponent<TextContainer>();
				Set_FrameCounter_Position(AnchorPosition);
				m_TextMeshPro.text = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.TopLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_textContainer.anchorPosition = TextContainerAnchors.TopRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class VertexColorCycler : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private IEnumerator AnimateVertexColors()
		{
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int currentCharacter = 0;
			Color32 c = m_TextComponent.color;
			while (true)
			{
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int materialIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex;
				Color32[] newVertexColors = textInfo.meshInfo[materialIndex].colors32;
				int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex;
				if (textInfo.characterInfo[currentCharacter].isVisible)
				{
					c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), byte.MaxValue);
					newVertexColors[vertexIndex] = c;
					newVertexColors[vertexIndex + 1] = c;
					newVertexColors[vertexIndex + 2] = c;
					newVertexColors[vertexIndex + 3] = c;
					m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
				}
				currentCharacter = (currentCharacter + 1) % characterCount;
				yield return new WaitForSeconds(0.05f);
			}
		}
	}
	public class VertexJitter : MonoBehaviour
	{
		private struct VertexAnim
		{
			public float angleRange;

			public float angle;

			public float speed;
		}

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int loopCount = 0;
			hasTextChanged = true;
			VertexAnim[] vertexAnim = new VertexAnim[1024];
			for (int i = 0; i < 1024; i++)
			{
				vertexAnim[i].angleRange = Random.Range(10f, 25f);
				vertexAnim[i].speed = Random.Range(1f, 3f);
			}
			TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				for (int j = 0; j < characterCount; j++)
				{
					TMP_CharacterInfo tMP_CharacterInfo = textInfo.characterInfo[j];
					if (tMP_CharacterInfo.isVisible)
					{
						VertexAnim vertexAnim2 = vertexAnim[j];
						int materialReferenceIndex = textInfo.characterInfo[j].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[j].vertexIndex;
						Vector3[] vertices = cachedMeshInfo[materialReferenceIndex].vertices;
						Vector2 vector = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;
						Vector3 vector2 = vector;
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						ref Vector3 reference = ref vertices2[vertexIndex];
						reference = vertices[vertexIndex] - vector2;
						ref Vector3 reference2 = ref vertices2[vertexIndex + 1];
						reference2 = vertices[vertexIndex + 1] - vector2;
						ref Vector3 reference3 = ref vertices2[vertexIndex + 2];
						reference3 = vertices[vertexIndex + 2] - vector2;
						ref Vector3 reference4 = ref vertices2[vertexIndex + 3];
						reference4 = vertices[vertexIndex + 3] - vector2;
						vertexAnim2.angle = Mathf.SmoothStep(0f - vertexAnim2.angleRange, vertexAnim2.angleRange, Mathf.PingPong((float)loopCount / 25f * vertexAnim2.speed, 1f));
						Vector3 vector3 = new Vector3(Random.Range(-0.25f, 0.25f), Random.Range(-0.25f, 0.25f), 0f);
						Matrix4x4 matrix = Matrix4x4.TRS(vector3 * CurveScale, Quaternion.Euler(0f, 0f, Random.Range(-5f, 5f) * AngleMultiplier), Vector3.one);
						ref Vector3 reference5 = ref vertices2[vertexIndex];
						reference5 = matrix.MultiplyPoint3x4(vertices2[vertexIndex]);
						ref Vector3 reference6 = ref vertices2[vertexIndex + 1];
						reference6 = matrix.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						ref Vector3 reference7 = ref vertices2[vertexIndex + 2];
						reference7 = matrix.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						ref Vector3 reference8 = ref vertices2[vertexIndex + 3];
						reference8 = matrix.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector2;
						vertices2[vertexIndex + 1] += vector2;
						vertices2[vertexIndex + 2] += vector2;
						vertices2[vertexIndex + 3] += vector2;
						vertexAnim[j] = vertexAnim2;
					}
				}
				for (int k = 0; k < textInfo.meshInfo.Length; k++)
				{
					textInfo.meshInfo[k].mesh.vertices = textInfo.meshInfo[k].vertices;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[k].mesh, k);
				}
				loopCount++;
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexShakeA : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float ScaleMultiplier = 1f;

		public float RotationMultiplier = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, Random.Range(-0.25f, 0.25f) * RotationMultiplier);
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							ref Vector3 reference = ref copyOfVertices[materialReferenceIndex][vertexIndex];
							reference = vertices[vertexIndex] - vector;
							ref Vector3 reference2 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 1];
							reference2 = vertices[vertexIndex + 1] - vector;
							ref Vector3 reference3 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 2];
							reference3 = vertices[vertexIndex + 2] - vector;
							ref Vector3 reference4 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 3];
							reference4 = vertices[vertexIndex + 3] - vector;
							float num2 = Random.Range(0.995f - 0.001f * ScaleMultiplier, 1.005f + 0.001f * ScaleMultiplier);
							Matrix4x4 matrix = Matrix4x4.TRS(Vector3.one, q, Vector3.one * num2);
							ref Vector3 reference5 = ref copyOfVertices[materialReferenceIndex][vertexIndex];
							reference5 = matrix.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							ref Vector3 reference6 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 1];
							reference6 = matrix.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							ref Vector3 reference7 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 2];
							reference7 = matrix.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							ref Vector3 reference8 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 3];
							reference8 = matrix.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexShakeB : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, Random.Range(-0.25f, 0.25f));
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							Vector3 vector2 = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;
							ref Vector3 reference = ref copyOfVertices[materialReferenceIndex][vertexIndex];
							reference = vertices[vertexIndex] - vector2;
							ref Vector3 reference2 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 1];
							reference2 = vertices[vertexIndex + 1] - vector2;
							ref Vector3 reference3 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 2];
							reference3 = vertices[vertexIndex + 2] - vector2;
							ref Vector3 reference4 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 3];
							reference4 = vertices[vertexIndex + 3] - vector2;
							float num2 = Random.Range(0.95f, 1.05f);
							Matrix4x4 matrix2 = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * num2);
							ref Vector3 reference5 = ref copyOfVertices[materialReferenceIndex][vertexIndex];
							reference5 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							ref Vector3 reference6 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 1];
							reference6 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							ref Vector3 reference7 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 2];
							reference7 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							ref Vector3 reference8 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 3];
							reference8 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] -= vector;
							matrix2 = Matrix4x4.TRS(Vector3.one, q, Vector3.one);
							ref Vector3 reference9 = ref copyOfVertices[materialReferenceIndex][vertexIndex];
							reference9 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							ref Vector3 reference10 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 1];
							reference10 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							ref Vector3 reference11 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 2];
							reference11 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							ref Vector3 reference12 = ref copyOfVertices[materialReferenceIndex][vertexIndex + 3];
							reference12 = matrix2.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexZoom : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
			List<float> modifiedCharScale = new List<float>();
			List<int> scaleSortingOrder = new List<int>();
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				modifiedCharScale.Clear();
				scaleSortingOrder.Clear();
				for (int i = 0; i < characterCount; i++)
				{
					TMP_CharacterInfo tMP_CharacterInfo = textInfo.characterInfo[i];
					if (tMP_CharacterInfo.isVisible)
					{
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						Vector3[] vertices = cachedMeshInfoVertexData[materialReferenceIndex].vertices;
						Vector2 vector = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;
						Vector3 vector2 = vector;
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						ref Vector3 reference = ref vertices2[vertexIndex];
						reference = vertices[vertexIndex] - vector2;
						ref Vector3 reference2 = ref vertices2[vertexIndex + 1];
						reference2 = vertices[vertexIndex + 1] - vector2;
						ref Vector3 reference3 = ref vertices2[vertexIndex + 2];
						reference3 = vertices[vertexIndex + 2] - vector2;
						ref Vector3 reference4 = ref vertices2[vertexIndex + 3];
						reference4 = vertices[vertexIndex + 3] - vector2;
						float num = Random.Range(1f, 1.5f);
						modifiedCharScale.Add(num);
						scaleSortingOrder.Add(modifiedCharScale.Count - 1);
						Matrix4x4 matrix = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, Vector3.one * num);
						ref Vector3 reference5 = ref vertices2[vertexIndex];
						reference5 = matrix.MultiplyPoint3x4(vertices2[vertexIndex]);
						ref Vector3 reference6 = ref vertices2[vertexIndex + 1];
						reference6 = matrix.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						ref Vector3 reference7 = ref vertices2[vertexIndex + 2];
						reference7 = matrix.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						ref Vector3 reference8 = ref vertices2[vertexIndex + 3];
						reference8 = matrix.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector2;
						vertices2[vertexIndex + 1] += vector2;
						vertices2[vertexIndex + 2] += vector2;
						vertices2[vertexIndex + 3] += vector2;
						Vector2[] uvs = cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
						Vector2[] uvs2 = textInfo.meshInfo[materialReferenceIndex].uvs0;
						ref Vector2 reference9 = ref uvs2[vertexIndex];
						reference9 = uvs[vertexIndex];
						ref Vector2 reference10 = ref uvs2[vertexIndex + 1];
						reference10 = uvs[vertexIndex + 1];
						ref Vector2 reference11 = ref uvs2[vertexIndex + 2];
						reference11 = uvs[vertexIndex + 2];
						ref Vector2 reference12 = ref uvs2[vertexIndex + 3];
						reference12 = uvs[vertexIndex + 3];
						Color32[] colors = cachedMeshInfoVertexData[materialReferenceIndex].colors32;
						Color32[] colors2 = textInfo.meshInfo[materialReferenceIndex].colors32;
						ref Color32 reference13 = ref colors2[vertexIndex];
						reference13 = colors[vertexIndex];
						ref Color32 reference14 = ref colors2[vertexIndex + 1];
						reference14 = colors[vertexIndex + 1];
						ref Color32 reference15 = ref colors2[vertexIndex + 2];
						reference15 = colors[vertexIndex + 2];
						ref Color32 reference16 = ref colors2[vertexIndex + 3];
						reference16 = colors[vertexIndex + 3];
					}
				}
				for (int j = 0; j < textInfo.meshInfo.Length; j++)
				{
					scaleSortingOrder.Sort((int a, int b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b]));
					textInfo.meshInfo[j].SortGeometry(scaleSortingOrder);
					textInfo.meshInfo[j].mesh.vertices = textInfo.meshInfo[j].vertices;
					textInfo.meshInfo[j].mesh.uv = textInfo.meshInfo[j].uvs0;
					textInfo.meshInfo[j].mesh.colors32 = textInfo.meshInfo[j].colors32;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[j].mesh, j);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class WarpTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			AnimationCurve animationCurve = new AnimationCurve();
			animationCurve.keys = curve.keys;
			return animationCurve;
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float boundsMinX = m_TextComponent.bounds.min.x;
				float boundsMaxX = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = (vector.x - boundsMinX) / (boundsMaxX - boundsMinX);
						float num2 = num + 0.0001f;
						float y = VertexCurve.Evaluate(num) * CurveScale;
						float y2 = VertexCurve.Evaluate(num2) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num2 * (boundsMaxX - boundsMinX) + boundsMinX, y2) - new Vector3(vector.x, y);
						float num3 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((!(Vector3.Cross(lhs, rhs).z > 0f)) ? (360f - num3) : num3);
						Matrix4x4 matrix = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						ref Vector3 reference = ref vertices[vertexIndex];
						reference = matrix.MultiplyPoint3x4(vertices[vertexIndex]);
						ref Vector3 reference2 = ref vertices[vertexIndex + 1];
						reference2 = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						ref Vector3 reference3 = ref vertices[vertexIndex + 2];
						reference3 = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						ref Vector3 reference4 = ref vertices[vertexIndex + 3];
						reference4 = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return new WaitForSeconds(0.025f);
			}
		}
	}
}
public class PurchaseHologram : MonoBehaviour
{
	public AnimationCurve switchOnCurve;

	private bool locked;

	private Vector3 defaultScale;

	private Color holoScreenDefaultColor;

	private float holoScreenDefaultAlpha;

	private float currHoloScreenAlpha;

	private Material holoScreenMaterial;

	private Vector3 switchedOffScale;

	private Transform holoScreen;

	public float switchOnSpeed = 1f;

	private Transform child;

	private void Start()
	{
		child.gameObject.SetActive(value: true);
		holoScreen = child.Find("Holo Screen");
		holoScreenMaterial = holoScreen.GetComponent<Renderer>().material;
		holoScreenDefaultColor = holoScreenMaterial.GetColor("_TintColor");
		holoScreenDefaultAlpha = holoScreenDefaultColor.a;
		defaultScale = holoScreen.localScale;
		switchedOffScale = new Vector3(defaultScale.x, 0f, defaultScale.z);
	}

	private void Update()
	{
	}

	private IEnumerator SwitchOn()
	{
		if (!locked)
		{
			locked = true;
			currHoloScreenAlpha = 0f;
			for (float t = 0f; t < switchOnSpeed; t += Time.deltaTime)
			{
				float perc = switchOnCurve.Evaluate(t / switchOnSpeed);
				currHoloScreenAlpha = holoScreenDefaultAlpha * perc;
				holoScreenMaterial.SetColor("_TintColor", new Color(holoScreenDefaultColor.r, holoScreenDefaultColor.g, holoScreenDefaultColor.b, currHoloScreenAlpha));
				holoScreen.localScale = Vector3.Lerp(switchedOffScale, defaultScale, perc);
				yield return 0;
			}
			locked = false;
		}
	}

	private IEnumerator SwitchOff()
	{
		if (!locked)
		{
			currHoloScreenAlpha = holoScreenDefaultAlpha;
			locked = true;
			for (float t = 0f; t < switchOnSpeed; t += Time.deltaTime)
			{
				float perc = switchOnCurve.Evaluate(t / switchOnSpeed);
				currHoloScreenAlpha = holoScreenDefaultAlpha * (1f - perc);
				holoScreenMaterial.SetColor("_TintColor", new Color(holoScreenDefaultColor.r, holoScreenDefaultColor.g, holoScreenDefaultColor.b, currHoloScreenAlpha));
				holoScreen.localScale = Vector3.Lerp(defaultScale, switchedOffScale, perc);
				yield return 0;
			}
			holoScreenMaterial.SetColor("_TintColor", new Color(holoScreenDefaultColor.r, holoScreenDefaultColor.g, holoScreenDefaultColor.b, 0f));
			locked = false;
		}
	}

	public void Refresh(string animal)
	{
		holoScreen.GetComponent<StreamImageSequence>().Refresh(animal);
	}
}
public class Reticle : MonoBehaviour
{
	public float maxDistance = 2.5f;

	private float distanceToTarget;

	public const float RETICLE_SIZE = 0.0085f;

	private MeshRenderer renderer;

	private void Start()
	{
		renderer = GetComponent<MeshRenderer>();
		renderer.enabled = true;
	}

	private void LateUpdate()
	{
		float num = 0.0085f * distanceToTarget;
		base.transform.localScale = new Vector3(num, num, num);
	}

	public void setPosition(Vector3 val)
	{
		base.transform.position = val;
	}

	public void SetDistanceToTarget(float val)
	{
		if (val <= maxDistance)
		{
			distanceToTarget = val;
		}
		else
		{
			distanceToTarget = maxDistance;
		}
	}
}
public class TeleportCapsule : MonoBehaviour
{
	public Color[] colors;

	public float colorPulseFrequency;

	public Vector2 alphaPulseMagnitude;

	public float alphaPulseFrequency;

	public float fadeUpTime = 1f;

	private int currentIndex;

	private int nextIndex;

	private float colorPulseTimer;

	private float alphaPulseTimer;

	private float fader;

	public float awakeFadeOutTime = 2f;

	private bool fadingOut;

	private float awakeFadeOutTimer;

	private GameObject innerCapsule;

	public float cameraOffset = 1.5f;

	private Transform camera;

	private void Start()
	{
		nextIndex = (currentIndex + 1) % colors.Length;
		innerCapsule = base.transform.Find("Inner Capsule").gameObject;
		camera = LAC_VRCameraRig.instance.getCenterCamera().gameObject.transform;
	}

	public void switchOff()
	{
		fadingOut = true;
		awakeFadeOutTimer = awakeFadeOutTime;
	}

	public void switchOn()
	{
		fadingOut = false;
		fader = 0f;
		base.gameObject.SetActive(value: true);
	}

	public void ResetPosition()
	{
		camera = LAC_VRCameraRig.instance.getCenterCamera().gameObject.transform;
		base.transform.position = camera.position - new Vector3(0f, cameraOffset, 0f);
	}

	private void Awake()
	{
		fader = 0f;
		if (fadingOut)
		{
			awakeFadeOutTimer = awakeFadeOutTime;
		}
	}

	private void Update()
	{
		if (!base.enabled)
		{
			return;
		}
		if (fadingOut)
		{
			if (awakeFadeOutTimer > 0f)
			{
				awakeFadeOutTimer -= Time.deltaTime;
			}
			else if (awakeFadeOutTimer <= 0f)
			{
				fadingOut = false;
				fader = 0f;
				base.gameObject.SetActive(value: false);
			}
		}
		if (fader / fadeUpTime < 1f)
		{
			fader += Time.deltaTime;
		}
		colorPulseTimer += Time.deltaTime;
		alphaPulseTimer += Time.deltaTime;
		if (colorPulseTimer > colorPulseFrequency)
		{
			currentIndex = (currentIndex + 1) % colors.Length;
			nextIndex = (currentIndex + 1) % colors.Length;
			colorPulseTimer = 0f;
		}
		float num = 0.5f * (1f + Mathf.Sin((float)Math.PI * 2f * alphaPulseFrequency * Time.time));
		float num2 = (alphaPulseMagnitude.x + num * alphaPulseMagnitude.y) * (fader / fadeUpTime);
		if (fadingOut)
		{
			num2 *= awakeFadeOutTimer / awakeFadeOutTime;
		}
		innerCapsule.GetComponent<Renderer>().materials[0].SetFloat("_MMultiplier", num2);
		innerCapsule.GetComponent<Renderer>().materials[0].SetColor("_Color", Color.Lerp(colors[currentIndex], colors[nextIndex], colorPulseTimer / colorPulseFrequency));
	}
}
public class TouchUI : MonoBehaviour
{
	public GameObject UIElementTemplate;

	private List<GameObject> UIElementList;

	public float radius = 6.5f;

	public string[] sceneNames;

	public string[] MenuOptionStrings;

	public string[] sceneDescriptors;

	public Texture[] sceneUIElementTextures;

	private Vector3[] localUIElementPositions;

	public AudioClip switchOn;

	public AudioClip switchOff;

	public AudioClip swipe;

	public AudioClip teleportWithinScene;

	private bool switchedOn;

	private string selectedElementName = "none";

	private string prevSelectedElementName = "none";

	private string currentLevelName = string.Empty;

	private GameObject touchedElement;

	private GameObject prevTouchedElement;

	private Vector3 targetEulerRotation = new Vector3(0f, 0f, 0f);

	private float angleBetweenElements;

	private Vector3 defaultLocalScale;

	private int currentSceneIndex = 3;

	private Transform camera;

	private Transform UIRing;

	private bool infoHologramActive;

	private bool controlsHologramActive;

	private bool loading;

	private Vector3 UIRingDefaultLocalScale;

	public float UIRingOnOffSpeed = 0.15f;

	public float UIElementScaleModifier = 0.6f;

	public float touchScaleIncrease = 1.1f;

	public Color defaultUIIconColor;

	public Color defaultUIElementColor;

	public Color highlightedUIElementColor;

	public Color disabledUIElementColor;

	public static TouchUI instance;

	public TeleportCapsule teleportCapsule;

	private AsyncOperation async;

	public PlayerGenesis genesisScript;

	private int educationLayerActive;

	[HideInInspector]
	public bool dolphinMessageShown;

	[HideInInspector]
	public bool orcaMessageShown;

	[HideInInspector]
	public bool sealionMessageShown;

	public GameObject infoHologram;

	public GameObject controlsHologram;

	private AudioSource audio;

	private Transform player;

	public GameObject[] UIElementControlOptionsList;

	private bool invertSwimControls;

	private bool scannerActive = true;

	public GameObject dolphinRingPrefab;

	public GameObject orcaFoodPrefab;

	public GameObject startMessage;

	private LocalisationManager.Language prevLanguage;

	public TextMesh animalFactsTextMesh;

	private int ringIndex;

	private GameObject dolphinRing;

	private GameObject orcaFood;

	private int maxNumberOfRings = 16;

	private GameObject[] rings;

	private int maxNumberOfFood = 16;

	private GameObject[] food;

	private int foodIndex;

	private bool flag;

	public bool isScannerActive()
	{
		return scannerActive;
	}

	public bool isSwimControlsInverted()
	{
		return invertSwimControls;
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		rings = new GameObject[maxNumberOfRings];
		food = new GameObject[maxNumberOfFood];
		audio = GetComponent<AudioSource>();
		if (!PlayerPrefs.HasKey("Education Layer"))
		{
			PlayerPrefs.SetInt("Education Layer", 1);
		}
		educationLayerActive = PlayerPrefs.GetInt("Education Layer");
		if (!PlayerPrefs.HasKey("Invert Swim Controls"))
		{
			PlayerPrefs.SetInt("Invert Swim Controls", 0);
		}
		if (!PlayerPrefs.HasKey("Scanner"))
		{
			PlayerPrefs.SetInt("Scanner", 1);
		}
		if (PlayerPrefs.GetInt("Invert Swim Controls") == 1)
		{
			invertSwimControls = true;
		}
		else
		{
			invertSwimControls = false;
		}
		if (PlayerPrefs.GetInt("Scanner") == 1)
		{
			scannerActive = true;
		}
		else
		{
			scannerActive = false;
		}
		camera = LAC_VRCameraRig.instance.getCenterCamera().transform;
		player = camera.root;
		UIRing = base.transform.Find("UIRing");
		angleBetweenElements = 360f / (float)MenuOptionStrings.Length;
		UIElementList = new List<GameObject>();
		UIRingDefaultLocalScale = UIRing.transform.localScale;
		for (int i = 0; i < sceneNames.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(UIElementTemplate, base.transform.position + base.transform.forward * radius, Quaternion.identity);
			gameObject.transform.RotateAround(base.transform.position, Vector3.up, angleBetweenElements * (float)i);
			gameObject.transform.rotation *= Quaternion.Euler(0f, 180f, 0f);
			gameObject.GetComponent<Renderer>().material.mainTexture = sceneUIElementTextures[i];
			gameObject.transform.parent = base.transform;
			gameObject.transform.GetChild(3).GetComponent<TextMesh>().text = LocalisationManager.instance.getText(MenuOptionStrings[i]);
			gameObject.transform.localScale = gameObject.transform.localScale * UIElementScaleModifier;
			UIElementList.Add(gameObject);
			gameObject.SetActive(value: false);
			if (i > 3 && !UnityEngine.Application.CanStreamedLevelBeLoaded(sceneNames[i]))
			{
				gameObject.transform.GetChild(2).gameObject.SetActive(value: true);
			}
			gameObject.transform.GetComponent<Renderer>().material.SetColor("_TintColor", defaultUIIconColor);
		}
		defaultLocalScale = UIElementList[0].transform.localScale;
		UpdateEducationIconText();
		RotateUIToCamera();
		SwitchUIOff(playSound: false);
	}

	public void RefreshPlayerColliderPosition()
	{
		CharacterController component = base.transform.root.GetComponent<CharacterController>();
		if (component != null)
		{
			component.center = camera.transform.localPosition + new Vector3(0f, 0.7f, 0f);
			if (UnityEngine.Application.loadedLevelName == "OceanRift_SharkCage")
			{
				component.center = new Vector3(0f, 0.7f, 0f);
			}
		}
	}

	private void ResetUIForward()
	{
		Vector3 eulerAngles = camera.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		targetEulerRotation = eulerAngles;
		base.transform.rotation = Quaternion.Euler(targetEulerRotation);
	}

	private void RotateUIToCamera()
	{
		Vector3 eulerAngles = camera.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.y += angleBetweenElements * (float)(-currentSceneIndex);
		eulerAngles.z = 0f;
		targetEulerRotation = eulerAngles;
		base.transform.rotation = Quaternion.Euler(targetEulerRotation);
		Vector3 forward = camera.forward;
		forward.y = 0f;
		if (startMessage != null)
		{
			startMessage.transform.LookAt(camera);
			startMessage.transform.position = base.transform.position + forward * 0.6f + Vector3.up * -0.25f;
			startMessage.transform.rotation *= Quaternion.Euler(0f, 180f, 0f);
		}
	}

	private IEnumerator localTeleportEffect()
	{
		teleportCapsule.ResetPosition();
		teleportCapsule.switchOn();
		yield return new WaitForSeconds(0.25f);
		teleportCapsule.switchOff();
		yield return 0;
	}

	public void setTouchedElement(GameObject elem)
	{
		touchedElement = elem;
	}

	public bool isShowingSomething()
	{
		if (!infoHologramActive && !controlsHologramActive && !switchedOn)
		{
			return false;
		}
		return true;
	}

	public bool isLoading()
	{
		return loading;
	}

	public bool isSwitchedOn()
	{
		return switchedOn;
	}

	public void ToggleOnOff()
	{
		if (switchedOn)
		{
			SwitchUIOff();
		}
		else
		{
			SwitchUIOn();
		}
	}

	public bool isSwichedOn()
	{
		return switchedOn;
	}

	public void RatchetRotateLeft()
	{
		if (!infoHologramActive && !controlsHologramActive)
		{
			targetEulerRotation += new Vector3(0f, angleBetweenElements, 0f);
			audio.PlayOneShot(swipe);
		}
	}

	public void RatchetRotateRight()
	{
		if (!infoHologramActive && !controlsHologramActive)
		{
			targetEulerRotation -= new Vector3(0f, angleBetweenElements, 0f);
			audio.PlayOneShot(swipe);
		}
	}

	public void SwitchUIOn(bool playSound = true)
	{
		Vector3 position = camera.transform.position;
		base.transform.position = new Vector3(position.x, position.y - 0.25f, position.z);
		if (!isShowingSomething())
		{
			RotateUIToCamera();
		}
		if (playSound)
		{
			audio.PlayOneShot(switchOn);
		}
		infoHologramActive = false;
		controlsHologramActive = false;
		foreach (GameObject uIElement in UIElementList)
		{
			uIElement.SetActive(value: true);
			switchedOn = true;
		}
		StartCoroutine(scaleOn(UIRing, UIRingDefaultLocalScale, UIRingOnOffSpeed));
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Startup_Void_SantaCruz")
		{
			startMessage.SetActive(value: true);
		}
	}

	public void SwitchUIOff(bool playSound = true)
	{
		if (playSound)
		{
			audio.PlayOneShot(switchOff);
		}
		foreach (GameObject uIElement in UIElementList)
		{
			uIElement.SetActive(value: false);
			switchedOn = false;
		}
		StartCoroutine(scaleOff(UIRing, new Vector3(UIRingDefaultLocalScale.x, UIRingDefaultLocalScale.y, 0f), UIRingOnOffSpeed));
		if (UnityEngine.Application.loadedLevelName == "OceanRift_Startup_Void_SantaCruz")
		{
			startMessage.GetComponent<FlashText>().Reset();
			startMessage.SetActive(value: false);
		}
	}

	private IEnumerator scaleOn(Transform element, Vector3 targetScale, float time)
	{
		element.gameObject.SetActive(value: true);
		float elapsedTime = 0f;
		while (elapsedTime < time)
		{
			element.localScale = Vector3.Lerp(element.localScale, targetScale, elapsedTime / time);
			elapsedTime += Time.deltaTime;
			yield return 0;
		}
	}

	private IEnumerator scaleOff(Transform element, Vector3 targetScale, float time)
	{
		float elapsedTime = 0f;
		while (elapsedTime < time)
		{
			element.localScale = Vector3.Lerp(element.localScale, targetScale, elapsedTime / time);
			elapsedTime += Time.deltaTime;
			yield return 0;
		}
		element.gameObject.SetActive(value: false);
	}

	private int findLevelIndex(GameObject obj)
	{
		int num = 0;
		foreach (GameObject uIElement in UIElementList)
		{
			if (uIElement == obj)
			{
				return num;
			}
			num++;
		}
		return -1;
	}

	private int findLevelIndex()
	{
		int num = 0;
		for (int i = 0; i < sceneNames.Length; i++)
		{
			if (sceneNames[i] == selectedElementName)
			{
				return i;
			}
		}
		return 0;
	}

	public bool isEducationLayerActive()
	{
		if (educationLayerActive > 0)
		{
			return true;
		}
		return false;
	}

	public int getEducationLayerType()
	{
		return educationLayerActive;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			SwitchUIOn();
		}
		if (Input.GetKeyDown(KeyCode.LeftControl))
		{
			SwitchUIOff();
		}
		if (infoHologramActive)
		{
			infoHologram.gameObject.SetActive(value: true);
		}
		else
		{
			infoHologram.gameObject.SetActive(value: false);
		}
		if (controlsHologramActive)
		{
			controlsHologram.gameObject.SetActive(value: true);
		}
		else
		{
			controlsHologram.gameObject.SetActive(value: false);
		}
		foreach (GameObject uIElement in UIElementList)
		{
			GameObject gameObject = uIElement.transform.GetChild(1).gameObject;
			if (isCurrentLevelsButton(uIElement))
			{
				gameObject.SetActive(value: true);
				gameObject.transform.localRotation *= Quaternion.Euler(0f, 0f, 75f * Time.deltaTime);
			}
			else
			{
				gameObject.SetActive(value: false);
			}
			if (uIElement == touchedElement)
			{
				uIElement.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", highlightedUIElementColor);
				uIElement.transform.localScale = Vector3.Lerp(uIElement.transform.localScale, defaultLocalScale * touchScaleIncrease, Time.deltaTime * 10f);
			}
			else
			{
				uIElement.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", defaultUIElementColor);
				uIElement.transform.localScale = Vector3.Lerp(uIElement.transform.localScale, defaultLocalScale, Time.deltaTime * 10f);
			}
			if (infoHologramActive || controlsHologramActive)
			{
				uIElement.SetActive(value: false);
			}
			else if (isSwitchedOn())
			{
				uIElement.SetActive(value: true);
			}
		}
		int num = findLevelIndex(touchedElement);
		if (num >= 0)
		{
			selectedElementName = sceneNames[num];
		}
		else
		{
			selectedElementName = "none";
		}
		if (selectedElementName != prevSelectedElementName)
		{
			if (selectedElementName == "about")
			{
				infoHologramActive = true;
				Vector3 eulerAngles = camera.rotation.eulerAngles;
				eulerAngles.x = 0f;
				eulerAngles.z = 0f;
				infoHologram.transform.rotation = Quaternion.Euler(eulerAngles) * Quaternion.Euler(0f, 180f, 0f);
				infoHologram.transform.position = base.transform.position + infoHologram.transform.rotation * new Vector3(0f, 0f, -1.3f);
				growUIRing();
			}
			else if (selectedElementName == "controls")
			{
				controlsHologramActive = true;
				Vector3 eulerAngles2 = camera.rotation.eulerAngles;
				eulerAngles2.x = 0f;
				eulerAngles2.z = 0f;
				controlsHologram.transform.rotation = Quaternion.Euler(eulerAngles2) * Quaternion.Euler(0f, 180f, 0f);
				controlsHologram.transform.position = base.transform.position + controlsHologram.transform.rotation * new Vector3(0f, 0f, -1.3f);
				growUIRing();
			}
			else if (selectedElementName == UnityEngine.Application.loadedLevelName)
			{
				GetComponent<AudioSource>().PlayOneShot(teleportWithinScene);
				if (genesisScript != null)
				{
					Transform nextTeleportTransform = genesisScript.getNextTeleportTransform();
					player.position = nextTeleportTransform.position;
					StartCoroutine(localTeleportEffect());
					RefreshPlayerColliderPosition();
				}
			}
			else
			{
				StartLevelLoadProcess();
				RefreshPlayerColliderPosition();
			}
		}
		if (touchedElement != prevTouchedElement && touchedElement != null)
		{
			if (touchedElement.name.Equals("Scanner Toggle"))
			{
				if (PlayerPrefs.GetInt("Scanner") == 0)
				{
					PlayerPrefs.SetInt("Scanner", 1);
					scannerActive = true;
				}
				else if (PlayerPrefs.GetInt("Scanner") == 1)
				{
					PlayerPrefs.SetInt("Scanner", 0);
					scannerActive = false;
				}
			}
			if (touchedElement.name.Equals("Invert Swim Controls Toggle"))
			{
				if (PlayerPrefs.GetInt("Invert Swim Controls") == 0)
				{
					PlayerPrefs.SetInt("Invert Swim Controls", 1);
					invertSwimControls = true;
				}
				else if (PlayerPrefs.GetInt("Invert Swim Controls") == 1)
				{
					PlayerPrefs.SetInt("Invert Swim Controls", 0);
					invertSwimControls = false;
				}
			}
			if (touchedElement.name.Equals("Language Select"))
			{
				LocalisationManager.instance.nextLanguage();
			}
			if (touchedElement.name.Equals("Animal Facts") && LocalisationManager.instance.selectedLanguage == LocalisationManager.Language.English)
			{
				educationLayerActive = PlayerPrefs.GetInt("Education Layer");
				if (educationLayerActive == 0)
				{
					PlayerPrefs.SetInt("Education Layer", 1);
				}
				if (educationLayerActive == 1)
				{
					PlayerPrefs.SetInt("Education Layer", 2);
				}
				if (educationLayerActive == 2)
				{
					PlayerPrefs.SetInt("Education Layer", 3);
				}
				if (educationLayerActive == 3)
				{
					PlayerPrefs.SetInt("Education Layer", 0);
				}
			}
		}
		GameObject[] uIElementControlOptionsList = UIElementControlOptionsList;
		foreach (GameObject gameObject2 in uIElementControlOptionsList)
		{
			if (gameObject2 == touchedElement)
			{
				gameObject2.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", highlightedUIElementColor);
				gameObject2.transform.localScale = Vector3.Lerp(gameObject2.transform.localScale, 0.7f * defaultLocalScale * touchScaleIncrease, Time.deltaTime * 10f);
			}
			else
			{
				gameObject2.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", defaultUIElementColor);
				gameObject2.transform.localScale = Vector3.Lerp(gameObject2.transform.localScale, 0.7f * defaultLocalScale, Time.deltaTime * 10f);
			}
			if (gameObject2.name.Equals("Scanner Toggle"))
			{
				TextMesh componentInChildren = gameObject2.GetComponentInChildren<TextMesh>();
				if (scannerActive)
				{
					componentInChildren.text = LocalisationManager.instance.getText("CONTROLS_QUEST_13");
				}
				else
				{
					componentInChildren.text = LocalisationManager.instance.getText("CONTROLS_QUEST_14");
				}
			}
			if (gameObject2.name.Equals("Invert Swim Controls Toggle"))
			{
				TextMesh componentInChildren2 = gameObject2.GetComponentInChildren<TextMesh>();
				if (invertSwimControls)
				{
					componentInChildren2.text = LocalisationManager.instance.getText("CONTROLS_QUEST_15");
				}
				else
				{
					componentInChildren2.text = LocalisationManager.instance.getText("CONTROLS_QUEST_16");
				}
			}
			if (gameObject2.name.Equals("Language Select"))
			{
				TextMesh componentInChildren3 = gameObject2.GetComponentInChildren<TextMesh>();
				componentInChildren3.text = LocalisationManager.instance.getText("BUTTON_LANGUAGE_2");
				gameObject2.transform.Find("Flag").GetComponent<Renderer>().material.mainTexture = LocalisationManager.instance.getFlag();
			}
			UpdateEducationIconText();
			if (gameObject2.name.Equals("Animal Facts"))
			{
				if (LocalisationManager.instance.selectedLanguage != 0)
				{
					gameObject2.SetActive(value: false);
				}
				else
				{
					gameObject2.SetActive(value: true);
				}
			}
		}
		if (prevLanguage != LocalisationManager.instance.selectedLanguage)
		{
			for (int j = 0; j < UIElementList.Count; j++)
			{
				UIElementList[j].transform.GetChild(3).GetComponent<TextMesh>().text = LocalisationManager.instance.getText(MenuOptionStrings[j]);
			}
		}
		prevLanguage = LocalisationManager.instance.selectedLanguage;
		prevTouchedElement = touchedElement;
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.Euler(targetEulerRotation), Time.deltaTime * 18f);
		prevSelectedElementName = selectedElementName;
	}

	private void UpdateEducationIconText()
	{
		educationLayerActive = PlayerPrefs.GetInt("Education Layer");
		if (animalFactsTextMesh != null)
		{
			if (educationLayerActive == 0)
			{
				animalFactsTextMesh.text = "Animal Facts\n(Off)";
			}
			if (educationLayerActive == 1)
			{
				animalFactsTextMesh.text = "Animal Facts\n(Audio)";
			}
			if (educationLayerActive == 2)
			{
				animalFactsTextMesh.text = "Animal Facts\n(Text)";
			}
			if (educationLayerActive == 3)
			{
				animalFactsTextMesh.text = "Animal Facts\n(Text + Audio)";
			}
		}
	}

	private bool isCurrentLevelsButton(GameObject elem)
	{
		int num = findLevelIndex(elem);
		if (num >= 0 && UnityEngine.Application.loadedLevelName == sceneNames[num])
		{
			return true;
		}
		return false;
	}

	public void DropRingIntoWater()
	{
		if (UnityEngine.Application.loadedLevelName == "OceanRift_SeaLions")
		{
			maxNumberOfRings = 8;
		}
		else
		{
			maxNumberOfRings = 16;
		}
		Vector3 forward = camera.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 position = camera.transform.position;
		position.y = genesisScript.getWaterSurfaceY() + 1f;
		Vector3 position2 = position + forward * 4f;
		float num = 3f;
		dolphinRing = UnityEngine.Object.Instantiate(dolphinRingPrefab, position2, Quaternion.identity);
		dolphinRing.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
		dolphinRing.GetComponent<Rigidbody>().AddTorque(new Vector3(Random.Range(0f - num, num), Random.Range(0f - num, num), Random.Range(0f - num, num)), ForceMode.Impulse);
		if (rings[ringIndex] != null)
		{
			UnityEngine.Object.Destroy(rings[ringIndex]);
		}
		rings[ringIndex] = dolphinRing;
		ringIndex++;
		if (ringIndex > maxNumberOfRings - 1)
		{
			ringIndex = 0;
		}
	}

	public void DropOrcaFoodIntoWater()
	{
		Vector3 forward = camera.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 position = camera.transform.position;
		position.y = genesisScript.getWaterSurfaceY() + 0.5f;
		Vector3 position2 = position + forward * 4f;
		if (orcaFood != null)
		{
			Transform transform = orcaFood.transform.Find("Ring Splash Bubbles");
			if (transform != null)
			{
				transform.parent = null;
			}
		}
		float num = 0.05f;
		orcaFood = UnityEngine.Object.Instantiate(orcaFoodPrefab, position2, Quaternion.identity);
		orcaFood.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
		orcaFood.GetComponent<Rigidbody>().AddTorque(new Vector3(Random.Range(0f - num, num), Random.Range(0f - num, num), Random.Range(0f - num, num)), ForceMode.Impulse);
		if (orcaFood != null)
		{
			Transform transform2 = orcaFood.transform.Find("Ring Splash Bubbles");
			if (transform2 != null)
			{
				transform2.rotation = Quaternion.Euler(90f, 0f, 0f);
				transform2.parent = null;
			}
		}
		if (food[foodIndex] != null)
		{
			UnityEngine.Object.Destroy(food[foodIndex]);
		}
		food[foodIndex] = orcaFood;
		foodIndex++;
		if (foodIndex > maxNumberOfFood - 1)
		{
			foodIndex = 0;
		}
	}

	private void growUIRing()
	{
		foreach (GameObject uIElement in UIElementList)
		{
			uIElement.SetActive(value: false);
			switchedOn = false;
		}
		audio.PlayOneShot(switchOff);
		StartCoroutine(scaleOn(UIRing, new Vector3(defaultLocalScale.x * 3f, defaultLocalScale.y * 3f, defaultLocalScale.z * 2f), UIRingOnOffSpeed));
	}

	private void StartLevelLoadProcess()
	{
		if (UnityEngine.Application.CanStreamedLevelBeLoaded(selectedElementName) && !UnityEngine.Application.isLoadingLevel && !loading)
		{
			StartCoroutine(loadCoroutineNew(selectedElementName));
			currentSceneIndex = findLevelIndex();
		}
	}

	private IEnumerator loadCoroutineBlackScreen(string levelName, bool teleportEffects = true, bool blackout = false)
	{
		if (blackout)
		{
			LAC_VRCameraRig.instance.Blackout();
		}
		MonoBehaviour.print("Level name is : " + levelName);
		loading = true;
		if (teleportEffects)
		{
			teleportCapsule.switchOn();
		}
		teleportCapsule.ResetPosition();
		yield return new WaitForSeconds(1.5f);
		SwitchUIOff(playSound: false);
		if (!blackout)
		{
			LAC_VRCameraRig.instance.FadeOut();
		}
		teleportCapsule.switchOff();
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		async = UnityEngine.Application.LoadLevelAsync(levelName);
		async.allowSceneActivation = false;
		while (!async.isDone)
		{
			Debug.Log("Loading Progress : " + async.progress);
			if (UnityEngine.Application.loadedLevelName == levelName)
			{
				if (async.progress >= 0.9f)
				{
					async.allowSceneActivation = true;
					GC.Collect();
					LAC_VRCameraRig.instance.FadeIn();
				}
			}
			else if (async.progress == 0.9f)
			{
				yield return new WaitForSeconds(0.75f);
				async.allowSceneActivation = true;
				teleportCapsule.switchOn();
				RefreshPlayerColliderPosition();
				LAC_VRCameraRig.instance.FadeIn();
			}
			yield return new WaitForSeconds(0.4f);
			teleportCapsule.switchOff();
			yield return 0;
		}
		loading = false;
	}

	private IEnumerator loadCoroutine(string levelName, bool teleportEffects = true)
	{
		float fadeAtPercentage = 0.3f;
		loading = true;
		if (teleportEffects)
		{
			teleportCapsule.switchOn();
		}
		teleportCapsule.ResetPosition();
		yield return new WaitForSeconds(1.5f);
		SwitchUIOff(playSound: false);
		teleportCapsule.switchOff();
		OVRManager.cpuLevel = 4;
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		async = UnityEngine.Application.LoadLevelAsync(levelName);
		async.allowSceneActivation = false;
		bool fadedOut = false;
		while (!async.isDone)
		{
			if (UnityEngine.Application.loadedLevelName == levelName)
			{
				if (async.progress >= 0.9f)
				{
					async.allowSceneActivation = true;
					GC.Collect();
					LAC_VRCameraRig.instance.FadeIn();
				}
			}
			else
			{
				if (async.progress > fadeAtPercentage && !fadedOut)
				{
					LAC_VRCameraRig.instance.FadeOut();
					fadedOut = true;
					if (currentSceneIndex < 2)
					{
					}
				}
				if (async.progress == 0.9f)
				{
					yield return new WaitForSeconds(1f);
					async.allowSceneActivation = true;
					teleportCapsule.switchOn();
					RefreshPlayerColliderPosition();
					LAC_VRCameraRig.instance.FadeIn();
				}
			}
			OVRManager.cpuLevel = 2;
			teleportCapsule.ResetPosition();
			yield return new WaitForSeconds(0.4f);
			teleportCapsule.switchOff();
			currentLevelName = UnityEngine.Application.loadedLevelName;
			yield return 0;
		}
		loading = false;
	}

	private IEnumerator loadCoroutineNew(string levelName, bool teleportEffects = true)
	{
		float fadeAtPercentage = 0.05f;
		loading = true;
		if (teleportEffects)
		{
			teleportCapsule.switchOn();
		}
		teleportCapsule.ResetPosition();
		yield return new WaitForSeconds(1.5f);
		OVRManager.cpuLevel = 4;
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		async = UnityEngine.Application.LoadLevelAsync(levelName);
		async.allowSceneActivation = false;
		SwitchUIOff(playSound: false);
		bool fadedOut = false;
		while (!async.isDone)
		{
			if (UnityEngine.Application.loadedLevelName == levelName)
			{
				if (async.progress >= 0.9f)
				{
					async.allowSceneActivation = true;
					GC.Collect();
					LAC_VRCameraRig.instance.FadeIn();
				}
			}
			else
			{
				if (async.progress > fadeAtPercentage && !fadedOut)
				{
					LAC_VRCameraRig.instance.FadeOut();
					yield return new WaitForSeconds(0.5f);
					fadedOut = true;
				}
				if (async.progress == 0.9f)
				{
					async.allowSceneActivation = true;
					teleportCapsule.switchOn();
				}
			}
			yield return 0;
		}
		LAC_VRCameraRig.instance.FadeIn();
		OVRManager.cpuLevel = 2;
		yield return new WaitForSeconds(0.4f);
		teleportCapsule.switchOff();
		currentLevelName = UnityEngine.Application.loadedLevelName;
		loading = false;
	}

	public void playerHasBeenEaten()
	{
		if (!UnityEngine.Application.isLoadingLevel)
		{
			StartCoroutine(loadCoroutineBlackScreen(UnityEngine.Application.loadedLevelName, teleportEffects: false, blackout: true));
		}
		SwitchUIOff(playSound: false);
	}

	private void FixedUpdate()
	{
		touchedElement = null;
	}
}
public class TouchUIListener : MonoBehaviour
{
	private TouchUI ui;

	public Renderer[] renderers;

	public Texture demoTitleTexture;

	private void Start()
	{
		ui = GameObject.Find("UI").GetComponent<TouchUI>();
	}

	private void Update()
	{
		if (!(ui != null))
		{
			return;
		}
		if (ui.isShowingSomething() || UnityEngine.Application.isLoadingLevel || ui.isLoading())
		{
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				renderer.enabled = false;
			}
		}
		else
		{
			Renderer[] array2 = renderers;
			foreach (Renderer renderer2 in array2)
			{
				renderer2.enabled = true;
			}
		}
	}
}
public class UI : MonoBehaviour
{
	public enum Language
	{
		English,
		Chinese
	}

	public Language language;

	public bool swipeDiscreteSteps;

	public bool alignWithHead = true;

	public float yHeadOffset;

	public bool stopAtEnds = true;

	public string[] sceneNames;

	public string[] sceneDescriptors;

	public Texture[] sceneUIElementTextures;

	private Vector3[] localUIElementPositions;

	public Transform InfoHologram;

	public Transform ControlsHologram;

	public AudioClip switchOn;

	public AudioClip switchOff;

	public AudioClip swipeLeft;

	public AudioClip swipeRight;

	public AudioClip teleportWithinScene;

	public AudioClip[] teleportAudioClips;

	public AudioClip teleportBaseAudioClip;

	public GameObject shortTeleportParticles;

	public GameObject longTeleportParticles;

	public Color selectedCubeColor;

	public Color unselectedCubeColor;

	public Color muteCubeColor;

	public Color informationCubeColor;

	public GameObject UIElementTemplate;

	private List<GameObject> UIElementList;

	public float angleBetweenElements;

	private GameObject player;

	public float radius;

	public float topBottomSeperation = 0.5f;

	public float swipeSpeed = 1f;

	private GameObject camera;

	private Color defaultUIElementColor;

	private Color highlightedUIElementColor;

	private Vector3 targetEulerRotation;

	private string selectedElementName;

	private string currentSceneName;

	private Transform selectedUIElement;

	private Transform prevSelectedUIElement;

	private Vector3 defaultLocalScale;

	private bool switchedOn;

	public bool scaleOnHighlighted;

	public bool moveOnHighlighted;

	public float highlightedScale = 2f;

	public float highlightedScaleSpeed = 5f;

	public float highlightedZoomSpeed = 5f;

	public float highlightedZoomAmount = 0.1f;

	public float UIRingOnOffSpeed = 1f;

	public bool showLaserDot;

	public GameObject laserDotPrefab;

	private GameObject laserDot;

	private Transform UIRing;

	private Vector3 UIDefaultLocalScale;

	private bool bRollercoaster;

	private OVRSwimController playerController;

	private GameObject rollercoasterMeshPath;

	public PlayerGenesis genesisScript;

	private int currentSceneIndex;

	private Transform fadeSphere;

	private AsyncOperation async;

	private bool infoHologramActive;

	private bool controlsHologramActive;

	private bool purchaseHologramActive;

	private bool isFading;

	public TeleportCapsule teleportCapsule;

	private GameObject dolphinRing;

	public GameObject dolphinRingPrefab;

	private GameObject orcaFood;

	public GameObject orcaFoodPrefab;

	private GameObject laserPointer;

	public GameObject[] UIOptionsElements;

	public DaydreamControl daydreamControl;

	public TextMesh daydreamControlsText;

	public GearVRControl gearVRControl;

	public TextMesh gearVRControlsText;

	public GameObject PurchaseHologram;

	private const int demoIndexEnd = 7;

	private const int fullIndexEnd = 16;

	private int lockIndex;

	public Texture[] movieTextures;

	private int maxNumberOfRings = 16;

	private GameObject[] rings;

	private int maxNumberOfFood = 16;

	private GameObject[] food;

	[HideInInspector]
	public bool dolphinMessageShown;

	[HideInInspector]
	public bool orcaMessageShown;

	[HideInInspector]
	public bool sealionMessageShown;

	private bool loading;

	public GameObject gearVRLaserPointer;

	public GameObject daydreamLaserPointer;

	private TextMesh educationLayerTextMesh;

	private int educationLayerActive;

	private bool prevShowingInfo;

	public Vector3 educationTextOffset = new Vector3(-0.01f, 0.05f, 0.1f);

	public Vector3 controlsTextOffset = new Vector3(-0.01f, 0.05f, 0.1f);

	public Vector3 aboutTextOffset = new Vector3(-0.005f, 0.05f, 0.1f);

	private int ringIndex;

	private int foodIndex;

	private Vector3 rayOrigin;

	private Vector3 rayDirection;

	private bool IsOculusGo => OVRPlugin.productName == "Oculus Go";

	private void Awake()
	{
	}

	public bool isEducationLayerActive()
	{
		if (educationLayerActive > 0)
		{
			return true;
		}
		return false;
	}

	public int getEducationLayerType()
	{
		return educationLayerActive;
	}

	public GameObject getLaserPointer()
	{
		return laserPointer;
	}

	private void Start()
	{
		if (!PlayerPrefs.HasKey("Education Layer"))
		{
			PlayerPrefs.SetInt("Education Layer", 0);
		}
		educationLayerActive = PlayerPrefs.GetInt("Education Layer");
		rings = new GameObject[maxNumberOfRings];
		food = new GameObject[maxNumberOfFood];
		lockIndex = 7;
		infoHologramActive = false;
		controlsHologramActive = false;
		if (language == Language.English)
		{
			currentSceneIndex = 3;
		}
		else
		{
			currentSceneIndex = 2;
		}
		playerController = base.transform.parent.gameObject.GetComponent<OVRSwimController>();
		bRollercoaster = false;
		switchedOn = false;
		selectedElementName = "none";
		targetEulerRotation = new Vector3(0f, 0f, 0f);
		player = base.transform.parent.gameObject;
		camera = LAC_VRCameraRig.instance.getCenterCamera().gameObject;
		UIRing = base.transform.Find("UIRing");
		UIDefaultLocalScale = UIRing.transform.localScale;
		UIElementList = new List<GameObject>();
		localUIElementPositions = new Vector3[sceneUIElementTextures.Length];
		Vector3 vector = new Vector3(0f, 0f, 0f);
		for (int i = 0; i < sceneNames.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(UIElementTemplate, base.transform.position + base.transform.forward * radius, Quaternion.identity);
			gameObject.transform.GetChild(0).gameObject.SetActive(value: false);
			gameObject.transform.GetChild(1).gameObject.SetActive(value: false);
			gameObject.transform.GetChild(3).gameObject.SetActive(value: false);
			gameObject.SetActive(value: false);
			if (i == 0)
			{
				defaultUIElementColor = gameObject.GetComponent<Renderer>().material.GetColor("_TintColor");
				highlightedUIElementColor = defaultUIElementColor;
				highlightedUIElementColor.a = 0.6f;
			}
			if (sceneNames[i] == "education")
			{
				educationLayerTextMesh = gameObject.transform.GetChild(3).GetComponent<TextMesh>();
			}
			gameObject.transform.RotateAround(base.transform.position, Vector3.up, angleBetweenElements * (float)i);
			gameObject.GetComponent<Renderer>().material.mainTexture = sceneUIElementTextures[i];
			gameObject.transform.parent = base.transform;
			gameObject.transform.GetChild(3).GetComponent<TextMesh>().text = sceneDescriptors[i];
			if (sceneNames[i] == "education")
			{
				gameObject.transform.GetChild(3).transform.Translate(educationTextOffset);
			}
			if (sceneNames[i] == "controls")
			{
				gameObject.transform.GetChild(3).transform.Translate(controlsTextOffset);
			}
			if (sceneNames[i] == "about")
			{
				gameObject.transform.GetChild(3).transform.Translate(aboutTextOffset);
			}
			UIElementList.Add(gameObject);
			ref Vector3 reference = ref localUIElementPositions[i];
			reference = gameObject.transform.localPosition;
			if (i > 2)
			{
				if (!UnityEngine.Application.CanStreamedLevelBeLoaded(sceneNames[i]))
				{
					gameObject.transform.GetChild(2).gameObject.SetActive(value: true);
				}
				gameObject.transform.GetChild(2).gameObject.SetActive(value: true);
			}
		}
		defaultLocalScale = UIElementList[0].transform.localScale;
		RotateUIToCamera();
		laserDot = UnityEngine.Object.Instantiate(laserDotPrefab, base.transform.position, Quaternion.identity);
		if (!showLaserDot)
		{
			laserDot.SetActive(value: false);
		}
		if (alignWithHead)
		{
			base.transform.localPosition += new Vector3(0f, yHeadOffset, 0f);
		}
		if ((bool)laserPointer)
		{
			laserPointer.transform.parent.gameObject.SetActive(value: false);
		}
		if (LAC_HMDInfo.instance.getHMDType() == LAC_HMDInfo.HMDType.Daydream)
		{
			GameObject[] uIOptionsElements = UIOptionsElements;
			foreach (GameObject gameObject2 in uIOptionsElements)
			{
				if (gameObject2.name == "Controls Mode")
				{
					gameObject2.transform.GetChild(3).GetComponent<TextMesh>().text = "Swipe";
				}
			}
		}
		Transform transform = ControlsHologram.Find("Daydream");
		Transform transform2 = ControlsHologram.Find("GearVR");
		Transform transform3 = ControlsHologram.Find("OculusGo");
	}

	private void setRenderQueue(GameObject theObject, int val)
	{
		theObject.GetComponent<Renderer>().material.renderQueue = val;
	}

	public void processSingleTap()
	{
		if (switchedOn && selectedElementName == "none")
		{
			SwitchUIOff();
		}
		if (!switchedOn && !controlsHologramActive && !purchaseHologramActive && !loading)
		{
			if (OVRInput.GetDown(OVRInput.Button.Four, OVRInput.Controller.Gamepad))
			{
				squashElements();
				SwitchUIOn();
				RotateUIToCamera();
			}
		}
		else
		{
			if (!switchedOn || !(selectedElementName != "none"))
			{
				return;
			}
			if (selectedElementName == "education")
			{
				educationLayerActive = PlayerPrefs.GetInt("Education Layer");
				if (educationLayerActive == 0)
				{
					PlayerPrefs.SetInt("Education Layer", 1);
				}
				if (educationLayerActive == 1)
				{
					PlayerPrefs.SetInt("Education Layer", 2);
				}
				if (educationLayerActive == 2)
				{
					PlayerPrefs.SetInt("Education Layer", 3);
				}
				if (educationLayerActive == 3)
				{
					PlayerPrefs.SetInt("Education Layer", 0);
				}
			}
			else if (selectedElementName == "about")
			{
				infoHologramActive = true;
				controlsHologramActive = false;
				InfoHologram.position = selectedUIElement.position + new Vector3(0f, -0.1f, 0f);
				InfoHologram.rotation = selectedUIElement.rotation;
				if (infoHologramActive)
				{
					growUIRing();
				}
			}
			else if (selectedElementName == "controls")
			{
				controlsHologramActive = true;
				infoHologramActive = false;
				ControlsHologram.position = selectedUIElement.position + new Vector3(0f, 0.07f, 0f);
				ControlsHologram.rotation = selectedUIElement.rotation;
				if (controlsHologramActive)
				{
					growUIRing();
				}
			}
			else if (selectedElementName == UnityEngine.Application.loadedLevelName)
			{
				MonoBehaviour.print("refresh!");
				GetComponent<AudioSource>().PlayOneShot(teleportWithinScene);
				if (genesisScript != null)
				{
					Transform nextTeleportTransform = genesisScript.getNextTeleportTransform();
					player.transform.position = nextTeleportTransform.position;
					StartCoroutine(localTeleportEffect());
				}
			}
			else if (loadHabitatOrVideo())
			{
				StartLevelLoadProcess();
			}
			else
			{
				ShowPurchaseHologram();
			}
		}
	}

	private bool loadHabitatOrVideo()
	{
		int num = findLevelIndex();
		if (num > lockIndex)
		{
			return false;
		}
		return true;
	}

	private void ShowPurchaseHologram()
	{
		purchaseHologramActive = true;
		PurchaseHologram.transform.position = selectedUIElement.position + new Vector3(0f, 0.1f, 0f);
		PurchaseHologram.transform.rotation = selectedUIElement.rotation * Quaternion.Euler(0f, 180f, 0f);
		PurchaseHologram.SetActive(value: true);
		growUIRing();
		int num = findLevelIndex() - 7;
		string animal = "Manatees";
		if (num == 0)
		{
			animal = "Great White Shark";
		}
		if (num == 1)
		{
			animal = "Humpback Whales";
		}
		if (num == 2)
		{
			animal = "Manatees";
		}
		if (num == 3)
		{
			animal = "Orcas";
		}
		if (num == 4)
		{
			animal = "The Deep";
		}
		if (num == 5)
		{
			animal = "Sea Lions";
		}
		if (num == 6)
		{
			animal = "Pliosaur";
		}
		if (num == 7)
		{
			animal = "Plesiosaur";
		}
		PurchaseHologram.GetComponent<PurchaseHologram>().Refresh(animal);
	}

	private void StartLevelLoadProcess()
	{
		if (UnityEngine.Application.CanStreamedLevelBeLoaded(selectedElementName) && !UnityEngine.Application.isLoadingLevel)
		{
			StartCoroutine(loadCoroutineBlackScreen(selectedElementName));
			currentSceneIndex = findLevelIndex();
		}
	}

	public void TransitionToTitle()
	{
		selectedElementName = "OceanRift_Title";
		if (UnityEngine.Application.CanStreamedLevelBeLoaded(selectedElementName) && !UnityEngine.Application.isLoadingLevel)
		{
			StartCoroutine(loadCoroutine(selectedElementName, teleportEffects: false));
			currentSceneIndex = findLevelIndex();
		}
	}

	public void playerHasBeenEaten()
	{
		if (!UnityEngine.Application.isLoadingLevel)
		{
			StartCoroutine(loadCoroutineBlackScreen(UnityEngine.Application.loadedLevelName));
		}
		SwitchUIOff(playSound: false);
	}

	public void DropRingIntoWater()
	{
		if (UnityEngine.Application.loadedLevelName == "OceanRift_SeaLions")
		{
			maxNumberOfRings = 8;
		}
		else
		{
			maxNumberOfRings = 16;
		}
		Vector3 forward = camera.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 position = camera.transform.position;
		position.y = genesisScript.getWaterSurfaceY() + 1f;
		Vector3 position2 = position + forward * 4f;
		float num = 3f;
		dolphinRing = UnityEngine.Object.Instantiate(dolphinRingPrefab, position2, Quaternion.identity);
		dolphinRing.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
		dolphinRing.GetComponent<Rigidbody>().AddTorque(new Vector3(Random.Range(0f - num, num), Random.Range(0f - num, num), Random.Range(0f - num, num)), ForceMode.Impulse);
		if (rings[ringIndex] != null)
		{
			UnityEngine.Object.Destroy(rings[ringIndex]);
		}
		rings[ringIndex] = dolphinRing;
		ringIndex++;
		if (ringIndex > maxNumberOfRings - 1)
		{
			ringIndex = 0;
		}
	}

	public void DropOrcaFoodIntoWater()
	{
		Vector3 forward = camera.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 position = camera.transform.position;
		position.y = genesisScript.getWaterSurfaceY() + 0.5f;
		Vector3 position2 = position + forward * 4f;
		if (orcaFood != null)
		{
			Transform transform = orcaFood.transform.Find("Ring Splash Bubbles");
			if (transform != null)
			{
				transform.parent = null;
			}
		}
		float num = 0.05f;
		orcaFood = UnityEngine.Object.Instantiate(orcaFoodPrefab, position2, Quaternion.identity);
		orcaFood.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
		orcaFood.GetComponent<Rigidbody>().AddTorque(new Vector3(Random.Range(0f - num, num), Random.Range(0f - num, num), Random.Range(0f - num, num)), ForceMode.Impulse);
		if (orcaFood != null)
		{
			Transform transform2 = orcaFood.transform.Find("Ring Splash Bubbles");
			if (transform2 != null)
			{
				transform2.rotation = Quaternion.Euler(90f, 0f, 0f);
				transform2.parent = null;
			}
		}
		if (food[foodIndex] != null)
		{
			UnityEngine.Object.Destroy(food[foodIndex]);
		}
		food[foodIndex] = orcaFood;
		foodIndex++;
		if (foodIndex > maxNumberOfFood - 1)
		{
			foodIndex = 0;
		}
	}

	public bool isShowingInfo()
	{
		return infoHologramActive || controlsHologramActive || purchaseHologramActive;
	}

	public bool isShowingInfoHologram()
	{
		return infoHologramActive;
	}

	public void swipeIconsLeft()
	{
		if (!infoHologramActive && !controlsHologramActive && !purchaseHologramActive)
		{
			targetEulerRotation += new Vector3(0f, 0f - angleBetweenElements, 0f);
			GetComponent<AudioSource>().PlayOneShot(swipeLeft);
		}
	}

	public void swipeIconsRight()
	{
		if (!infoHologramActive && !controlsHologramActive && !purchaseHologramActive)
		{
			targetEulerRotation += new Vector3(0f, angleBetweenElements, 0f);
			GetComponent<AudioSource>().PlayOneShot(swipeLeft);
		}
	}

	public void processUpSwipe()
	{
		if (!isShowingSomething())
		{
			playerController.TouchpadSwimUp();
		}
	}

	public void processLeftSwipe()
	{
		if (!isShowingSomething())
		{
			playerController.TouchpadLeftStroke();
		}
	}

	public void processRightSwipe()
	{
		if (!isShowingSomething())
		{
			playerController.TouchpadRightStroke();
		}
	}

	public void processDownSwipe()
	{
		if (switchedOn)
		{
			SwitchUIOff();
		}
		if (isShowingSomething())
		{
			GetComponent<AudioSource>().PlayOneShot(switchOff);
			SwitchUIOn(playSound: false);
		}
		infoHologramActive = false;
		controlsHologramActive = false;
		purchaseHologramActive = false;
	}

	public bool switchOffInfoSpheres()
	{
		bool result = false;
		GameObject[] array = GameObject.FindGameObjectsWithTag("Info Sphere");
		GameObject[] array2 = array;
		foreach (GameObject gameObject in array2)
		{
			if (gameObject.GetComponent<InfoSphere>().isSwitchedOn())
			{
				result = true;
			}
			gameObject.GetComponent<InfoSphere>().downSwipeOff();
		}
		return result;
	}

	private void processControllerInput()
	{
	}

	private IEnumerator fakeLoadLevel()
	{
		teleportCapsule.switchOn();
		SwitchUIOff();
		yield return new WaitForSeconds(1f);
		teleportCapsule.switchOff();
		yield return 0;
	}

	private IEnumerator localTeleportEffect()
	{
		teleportCapsule.switchOn();
		yield return new WaitForSeconds(0.25f);
		teleportCapsule.switchOff();
		yield return 0;
	}

	public bool isSwitchedOn()
	{
		return switchedOn;
	}

	public void ToggleOnOff()
	{
		if (switchedOn)
		{
			SwitchUIOff();
		}
		else
		{
			SwitchUIOn();
		}
	}

	private IEnumerator loadCoroutine(string levelName, bool teleportEffects = true)
	{
		float fadeAtPercentage = 0.3f;
		loading = true;
		if (teleportEffects)
		{
			teleportCapsule.switchOn();
		}
		SwitchUIOff(playSound: false);
		yield return new WaitForSeconds(1.5f);
		SwitchUIOff(playSound: false);
		teleportCapsule.switchOff();
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		async = UnityEngine.Application.LoadLevelAsync(levelName);
		async.allowSceneActivation = false;
		bool fadedOut = false;
		while (!async.isDone)
		{
			if (UnityEngine.Application.loadedLevelName == levelName)
			{
				if (async.progress >= 0.9f)
				{
					async.allowSceneActivation = true;
					GC.Collect();
					LAC_VRCameraRig.instance.FadeIn();
				}
			}
			else
			{
				if (async.progress > fadeAtPercentage && !fadedOut)
				{
					LAC_VRCameraRig.instance.FadeOut();
					fadedOut = true;
					if (currentSceneIndex >= 2)
					{
						if (language == Language.English)
						{
							GetComponent<AudioSource>().PlayOneShot(teleportAudioClips[findLevelIndex() - 3]);
						}
						else
						{
							GetComponent<AudioSource>().PlayOneShot(teleportAudioClips[findLevelIndex() - 2]);
						}
					}
				}
				if (async.progress == 0.9f)
				{
					yield return new WaitForSeconds(0.75f);
					async.allowSceneActivation = true;
					teleportCapsule.switchOn();
					LAC_VRCameraRig.instance.FadeIn();
				}
			}
			yield return new WaitForSeconds(0.4f);
			teleportCapsule.switchOff();
			yield return 0;
		}
		loading = false;
	}

	private IEnumerator loadCoroutineBlackScreen(string levelName, bool teleportEffects = true)
	{
		loading = true;
		if (teleportEffects)
		{
			teleportCapsule.switchOn();
		}
		SwitchUIOff(playSound: false);
		yield return new WaitForSeconds(1.5f);
		SwitchUIOff(playSound: false);
		LAC_VRCameraRig.instance.FadeOut();
		teleportCapsule.switchOff();
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		async = UnityEngine.Application.LoadLevelAsync(levelName);
		async.allowSceneActivation = false;
		while (!async.isDone)
		{
			if (UnityEngine.Application.loadedLevelName == levelName)
			{
				if (async.progress >= 0.9f)
				{
					async.allowSceneActivation = true;
					GC.Collect();
					LAC_VRCameraRig.instance.FadeIn();
				}
			}
			else if (async.progress == 0.9f)
			{
				yield return new WaitForSeconds(0.75f);
				if (currentSceneIndex >= 2)
				{
					GetComponent<AudioSource>().PlayOneShot(teleportAudioClips[findLevelIndex() - 3]);
				}
				async.allowSceneActivation = true;
				teleportCapsule.switchOn();
				LAC_VRCameraRig.instance.FadeIn();
			}
			yield return new WaitForSeconds(0.4f);
			teleportCapsule.switchOff();
			yield return 0;
		}
		loading = false;
	}

	private IEnumerator Fade(Transform theObj, float aTime, float aValue)
	{
		isFading = true;
		float alpha = theObj.GetComponent<Renderer>().material.color.a;
		Color fogColor = Color.black;
		for (float t = 0f; t < 1f; t += Time.deltaTime / aTime)
		{
			Color newColor = new Color(fogColor.r, fogColor.g, fogColor.b, Mathf.Lerp(alpha, aValue, t));
			theObj.GetComponent<Renderer>().material.color = newColor;
			yield return null;
		}
		if (aValue == 0f)
		{
			theObj.gameObject.SetActive(value: false);
			isFading = false;
		}
	}

	private IEnumerator FadeUsingColor(Transform theObj, float aTime, float aValue, Color theColor)
	{
		isFading = true;
		float alpha = theObj.GetComponent<Renderer>().material.color.a;
		for (float t = 0f; t < 1f; t += Time.deltaTime / aTime)
		{
			Color newColor = new Color(theColor.r, theColor.g, theColor.b, Mathf.Lerp(alpha, aValue, t));
			theObj.GetComponent<Renderer>().material.color = newColor;
			yield return null;
		}
		if (aValue == 0f)
		{
			theObj.gameObject.SetActive(value: false);
			isFading = false;
		}
	}

	private int findLevelIndex()
	{
		int num = 0;
		for (int i = 0; i < sceneNames.Length; i++)
		{
			if (sceneNames[i] == selectedElementName)
			{
				return i;
			}
		}
		return 0;
	}

	private void RotateUIToCamera()
	{
		Vector3 eulerAngles = camera.transform.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.y += angleBetweenElements * (float)(-currentSceneIndex);
		eulerAngles.z = 0f;
		base.transform.rotation = Quaternion.Euler(targetEulerRotation);
		targetEulerRotation = eulerAngles;
	}

	public void SwitchUIOn(bool playSound = true)
	{
		Vector3 position = camera.transform.position;
		base.transform.position = new Vector3(position.x, base.transform.position.y, position.z);
		if (!isShowingSomething())
		{
			RotateUIToCamera();
		}
		if ((bool)laserPointer)
		{
			laserPointer.transform.parent.gameObject.SetActive(value: true);
		}
		if (playSound)
		{
			GetComponent<AudioSource>().PlayOneShot(switchOn);
		}
		infoHologramActive = false;
		controlsHologramActive = false;
		purchaseHologramActive = false;
		foreach (GameObject uIElement in UIElementList)
		{
			uIElement.SetActive(value: true);
			switchedOn = true;
		}
		StartCoroutine(scaleOn(UIRing, UIDefaultLocalScale, UIRingOnOffSpeed));
	}

	public void SwitchUIOff(bool playSound = true)
	{
		if (playSound)
		{
			GetComponent<AudioSource>().PlayOneShot(switchOff);
		}
		if ((bool)laserPointer)
		{
			laserPointer.transform.parent.gameObject.SetActive(value: false);
		}
		foreach (GameObject uIElement in UIElementList)
		{
			uIElement.SetActive(value: false);
			switchedOn = false;
		}
		StartCoroutine(scaleOff(UIRing, new Vector3(UIDefaultLocalScale.x, UIDefaultLocalScale.y, 0f), UIRingOnOffSpeed));
	}

	private void growUIRing()
	{
		foreach (GameObject uIElement in UIElementList)
		{
			uIElement.SetActive(value: false);
			switchedOn = false;
		}
		GetComponent<AudioSource>().PlayOneShot(switchOff);
		StartCoroutine(scaleOn(UIRing, new Vector3(UIDefaultLocalScale.x, UIDefaultLocalScale.y, UIDefaultLocalScale.z * 2f), UIRingOnOffSpeed));
	}

	public bool isSwichedOn()
	{
		return switchedOn;
	}

	public bool isShowingSomething()
	{
		if (!infoHologramActive && !controlsHologramActive && !switchedOn && !purchaseHologramActive)
		{
			return false;
		}
		return true;
	}

	public bool wasPrevShowingInfo()
	{
		return prevShowingInfo;
	}

	private void squashElements()
	{
		foreach (GameObject uIElement in UIElementList)
		{
			uIElement.transform.localScale = new Vector3(0f, 0f, 0f);
		}
	}

	private IEnumerator scaleOn(Transform element, Vector3 targetScale, float time)
	{
		element.gameObject.SetActive(value: true);
		float elapsedTime = 0f;
		while (elapsedTime < time)
		{
			element.localScale = Vector3.Lerp(element.localScale, targetScale, elapsedTime / time);
			elapsedTime += Time.deltaTime;
			yield return 0;
		}
	}

	private IEnumerator scaleOff(Transform element, Vector3 targetScale, float time)
	{
		float elapsedTime = 0f;
		while (elapsedTime < time)
		{
			element.localScale = Vector3.Lerp(element.localScale, targetScale, elapsedTime / time);
			elapsedTime += Time.deltaTime;
			yield return 0;
		}
		element.gameObject.SetActive(value: false);
	}

	public void Fanfare()
	{
	}

	private void LateUpdate()
	{
		UpdateLockOrUnlock();
	}

	public void UpdateLockOrUnlock()
	{
	}

	public bool isLoading()
	{
		return loading;
	}

	private void Update()
	{
		if (!isShowingSomething())
		{
			laserPointer.transform.parent.gameObject.SetActive(value: false);
		}
		int layerMask = 32;
		processControllerInput();
		GameObject[] uIOptionsElements = UIOptionsElements;
		foreach (GameObject gameObject in uIOptionsElements)
		{
			gameObject.GetComponent<Renderer>().material.SetColor("_TintColor", defaultUIElementColor);
		}
		int num = 0;
		if (infoHologramActive)
		{
			InfoHologram.gameObject.SetActive(value: true);
		}
		else
		{
			InfoHologram.gameObject.SetActive(value: false);
		}
		if (controlsHologramActive)
		{
			ControlsHologram.gameObject.SetActive(value: true);
		}
		else
		{
			ControlsHologram.gameObject.SetActive(value: false);
		}
		if (purchaseHologramActive)
		{
			PurchaseHologram.SetActive(value: true);
		}
		else
		{
			PurchaseHologram.SetActive(value: false);
		}
		if (isShowingSomething())
		{
			educationLayerActive = PlayerPrefs.GetInt("Education Layer");
			if (educationLayerTextMesh != null)
			{
				if (educationLayerActive == 0)
				{
					educationLayerTextMesh.text = "Animal Facts (Off)";
				}
				if (educationLayerActive == 1)
				{
					educationLayerTextMesh.text = "Animal Facts (Audio)";
				}
				if (educationLayerActive == 2)
				{
					educationLayerTextMesh.text = "Animal Facts (Text)";
				}
				if (educationLayerActive == 3)
				{
					educationLayerTextMesh.text = "Animal Facts (Text + Audio)";
				}
			}
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.Euler(targetEulerRotation), Time.deltaTime * 18f);
			foreach (GameObject uIElement in UIElementList)
			{
				if (selectedElementName == UnityEngine.Application.loadedLevelName)
				{
					GameObject gameObject2 = uIElement.transform.GetChild(1).gameObject;
					gameObject2.transform.localRotation *= Quaternion.Euler(0f, 0f, 75f * Time.deltaTime);
				}
				if (infoHologramActive || controlsHologramActive || purchaseHologramActive)
				{
					uIElement.SetActive(value: false);
				}
				else
				{
					uIElement.SetActive(value: true);
				}
				uIElement.transform.LookAt(camera.transform.position, Vector3.up);
				if (uIElement.transform == selectedUIElement)
				{
					uIElement.transform.localScale = Vector3.Lerp(uIElement.transform.localScale, defaultLocalScale + new Vector3(highlightedScale, highlightedScale, highlightedScale), Time.deltaTime * highlightedScaleSpeed);
					uIElement.transform.localPosition = Vector3.Lerp(uIElement.transform.localPosition, localUIElementPositions[num] + base.transform.InverseTransformDirection(uIElement.transform.forward) * highlightedZoomAmount, Time.deltaTime * highlightedZoomSpeed);
				}
				else
				{
					uIElement.transform.localScale = Vector3.Lerp(uIElement.transform.localScale, defaultLocalScale, Time.deltaTime * highlightedScaleSpeed);
					uIElement.transform.localPosition = Vector3.Lerp(uIElement.transform.localPosition, localUIElementPositions[num], Time.deltaTime * highlightedZoomSpeed);
				}
				num++;
			}
			selectedElementName = "none";
			if (Physics.Raycast(rayOrigin, rayDirection, out var hitInfo, 2f, layerMask))
			{
				int num2 = 0;
				foreach (GameObject uIElement2 in UIElementList)
				{
					if (hitInfo.collider.transform.gameObject == uIElement2)
					{
						uIElement2.GetComponent<Renderer>().material.SetColor("_TintColor", highlightedUIElementColor);
						prevSelectedUIElement = selectedUIElement;
						selectedElementName = sceneNames[num2];
						selectedUIElement = hitInfo.collider.transform;
						if (selectedElementName == "about")
						{
							uIElement2.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", informationCubeColor);
						}
						else if (selectedElementName == "controls")
						{
							uIElement2.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", informationCubeColor);
						}
						else if (selectedElementName == "education")
						{
							uIElement2.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", informationCubeColor);
						}
						else
						{
							uIElement2.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", selectedCubeColor);
						}
						uIElement2.transform.GetChild(0).gameObject.SetActive(value: true);
						uIElement2.transform.GetChild(3).gameObject.SetActive(value: true);
						if (selectedElementName == UnityEngine.Application.loadedLevelName)
						{
							GameObject gameObject3 = uIElement2.transform.GetChild(1).gameObject;
							gameObject3.SetActive(value: true);
							gameObject3.transform.localRotation *= Quaternion.Euler(0f, 0f, 150f * Time.deltaTime);
						}
						if (!(prevSelectedUIElement != selectedUIElement))
						{
						}
					}
					else
					{
						uIElement2.GetComponent<Renderer>().material.SetColor("_TintColor", defaultUIElementColor);
						uIElement2.transform.GetChild(0).GetComponent<Renderer>().material.SetColor("_TintColor", unselectedCubeColor);
						uIElement2.transform.GetChild(0).gameObject.SetActive(value: false);
						uIElement2.transform.GetChild(1).gameObject.SetActive(value: false);
						uIElement2.transform.GetChild(3).gameObject.SetActive(value: false);
					}
					num2++;
				}
				GameObject[] uIOptionsElements2 = UIOptionsElements;
				foreach (GameObject gameObject4 in uIOptionsElements2)
				{
					if (hitInfo.collider.transform.gameObject == gameObject4)
					{
						gameObject4.GetComponent<Renderer>().material.SetColor("_TintColor", highlightedUIElementColor);
						selectedElementName = gameObject4.name;
					}
				}
			}
		}
		prevShowingInfo = isShowingInfoHologram();
	}
}
public class UIListener : MonoBehaviour
{
	private UI ui;

	public Renderer[] renderers;

	public Texture demoTitleTexture;

	private void Start()
	{
		ui = GameObject.Find("UI").GetComponent<UI>();
	}

	private void Update()
	{
		if (!(ui != null))
		{
			return;
		}
		if (ui.isShowingSomething() || UnityEngine.Application.isLoadingLevel || ui.isLoading())
		{
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				renderer.enabled = false;
			}
		}
		else
		{
			Renderer[] array2 = renderers;
			foreach (Renderer renderer2 in array2)
			{
				renderer2.enabled = true;
			}
		}
	}
}
public class FlowmapAnimator : MonoBehaviour
{
	public float flowSpeed;

	private Material currentMaterial;

	private float cycle;

	private float halfCycle;

	private float flowMapOffset0;

	private float flowMapOffset1;

	private bool hasTide;

	private void Reset()
	{
		flowSpeed = 0.25f;
	}

	private void Start()
	{
		currentMaterial = GetComponent<Renderer>().material;
		cycle = 6f;
		halfCycle = cycle * 0.5f;
		flowMapOffset0 = 0f;
		flowMapOffset1 = halfCycle;
		currentMaterial.SetFloat("halfCycle", halfCycle);
	}

	private void Update()
	{
		flowMapOffset0 += flowSpeed * Time.deltaTime;
		flowMapOffset1 += flowSpeed * Time.deltaTime;
		while (flowMapOffset0 >= cycle)
		{
			flowMapOffset0 -= cycle;
		}
		while (flowMapOffset1 >= cycle)
		{
			flowMapOffset1 -= cycle;
		}
		currentMaterial.SetFloat("flowMapOffset0", flowMapOffset0);
		currentMaterial.SetFloat("flowMapOffset1", flowMapOffset1);
	}
}
public enum WaterMovementType
{
	directional,
	island,
	flowmap,
	still
}
public class WaterPlusScript : MonoBehaviour
{
	public WaterMovementType movementType;

	public Vector2 velocity;

	public float speed;

	public Transform target;

	private float animationValue;

	private Vector3 waterCenter;

	private Material waterMaterial;

	private Vector3 projectedLightDir;

	private Vector2 anisoDirAnimationOffset;

	private int causticsAnimationFrame;

	private float causticsAnimationTime;

	private void Reset()
	{
		speed = 3f;
		velocity = new Vector2(0.7f, 0f);
	}

	private Light FindTheBrightestDirectionalLight()
	{
		Light light = null;
		Light[] array = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		List<Light> list = new List<Light>();
		Light[] array2 = array;
		foreach (Light light2 in array2)
		{
			if (light2.type == LightType.Directional)
			{
				list.Add(light2);
			}
		}
		if (list.Count <= 0)
		{
			return null;
		}
		light = list[0];
		foreach (Light item in list)
		{
			if (item.intensity > light.intensity)
			{
				light = item;
			}
		}
		return light;
	}

	private void Start()
	{
		waterCenter = GetComponent<Renderer>().bounds.center;
		if (movementType == WaterMovementType.directional)
		{
			speed = velocity.magnitude;
		}
		float num = GetComponent<Renderer>().bounds.size.x / base.gameObject.GetComponent<Renderer>().material.GetTextureScale("_MainTex").x;
		speed /= num;
		waterMaterial = GetComponent<Renderer>().material;
		Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
		Shader.EnableKeyword("WATER_EDGEBLEND_ON");
		if (movementType == WaterMovementType.flowmap)
		{
			Shader.DisableKeyword("FLOWMAP_ANIMATION_OFF");
			Shader.EnableKeyword("FLOWMAP_ANIMATION_ON");
			FlowmapAnimator flowmapAnimator = base.gameObject.AddComponent<FlowmapAnimator>();
			flowmapAnimator.flowSpeed = speed;
		}
		else
		{
			Shader.DisableKeyword("FLOWMAP_ANIMATION_ON");
			Shader.EnableKeyword("FLOWMAP_ANIMATION_OFF");
		}
		Light light = FindTheBrightestDirectionalLight();
		projectedLightDir = light.transform.forward - base.transform.up * Vector3.Dot(base.transform.up, light.transform.forward);
		projectedLightDir.Normalize();
		anisoDirAnimationOffset = Vector2.zero;
	}

	private void OnDestroy()
	{
		Shader.DisableKeyword("WATER_EDGEBLEND_ON");
		Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
	}

	private void Update()
	{
		switch (movementType)
		{
		case WaterMovementType.island:
		{
			Vector3 vector = waterCenter - target.position;
			velocity.x = vector.x;
			velocity.y = vector.z;
			velocity = velocity.normalized * speed;
			break;
		}
		case WaterMovementType.still:
			velocity = Vector3.zero;
			break;
		}
		if ((movementType == WaterMovementType.directional) | (movementType == WaterMovementType.island))
		{
			Vector2 textureOffset = waterMaterial.GetTextureOffset("_MainTex");
			Vector2 value = textureOffset + velocity * Time.deltaTime;
			if ((velocity * Time.deltaTime).sqrMagnitude > 1f)
			{
				Vector2 vector2 = velocity * Time.deltaTime;
				Vector2 normalized = vector2.normalized;
				while (vector2.sqrMagnitude > 1f)
				{
					vector2 -= normalized;
				}
				value = textureOffset + vector2;
			}
			waterMaterial.SetTextureOffset("_MainTex", value);
			waterMaterial.SetTextureOffset("_Normalmap", value);
		}
		anisoDirAnimationOffset += new Vector2(projectedLightDir.x, projectedLightDir.z) * Time.deltaTime * 0.01f;
		Vector4 value2 = new Vector4(anisoDirAnimationOffset.x, anisoDirAnimationOffset.y, 0f, 0f);
		waterMaterial.SetVector("anisoDirAnimationOffset", value2);
		int num = causticsAnimationFrame / 16;
		float y = (float)(causticsAnimationFrame % 16 / 4) * 0.25f;
		float x = (float)(causticsAnimationFrame % 16 % 4) * 0.25f;
		Vector4 value3 = new Vector4(x, y, 0.25f, 0.25f);
		Vector4 value4 = num switch
		{
			1 => new Vector4(0f, 1f, 0f, 0f), 
			2 => new Vector4(0f, 0f, 1f, 0f), 
			_ => new Vector4(1f, 0f, 0f, 0f), 
		};
		waterMaterial.SetVector("causticsOffsetAndScale", value3);
		waterMaterial.SetVector("causticsAnimationColorChannel", value4);
		causticsAnimationTime += Time.deltaTime;
		if (causticsAnimationTime >= 0.04f)
		{
			causticsAnimationFrame++;
			causticsAnimationTime = 0f;
			if (causticsAnimationFrame >= 48)
			{
				causticsAnimationFrame = 0;
			}
		}
	}
}
