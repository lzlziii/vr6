#define DEBUG_LOCOMOTION_PANEL
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using AOT;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using HTC.UnityPlugin.StereoRendering;
using Oculus.Avatar;
using Oculus.Platform;
using Oculus.Platform.Models;
using Oculus.Spatializer.Propagation;
using Sirenix.OdinInspector;
using UltimateGameTools.MeshSimplifier;
using UniRx;
using UniRx.Triggers;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Analytics;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;
using UnityEngine.Serialization;
using UnityEngine.U2D;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using Valve.VR;
using Valve.VR.InteractionSystem;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
public class OvrAvatarTestDriver : OvrAvatarDriver
{
	private Vector3 headPos = new Vector3(0f, 1.6f, 0f);

	private Quaternion headRot = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = headPos,
			headRotation = headRot,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class PoseEditHelper : MonoBehaviour
{
	public Transform poseRoot;

	private void OnDrawGizmos()
	{
		if (poseRoot != null)
		{
			DrawJoints(poseRoot);
		}
	}

	private void DrawJoints(Transform joint)
	{
		Gizmos.DrawWireSphere(joint.position, 0.005f);
		for (int i = 0; i < joint.childCount; i++)
		{
			Transform child = joint.GetChild(i);
			if (!child.name.EndsWith("_grip") && !child.name.EndsWith("hand_ignore"))
			{
				Gizmos.DrawLine(joint.position, child.position);
				DrawJoints(child);
			}
		}
	}
}
public class GazeTargetSpawner : MonoBehaviour
{
	public GameObject GazeTargetPrefab;

	public int NumberOfDummyTargets = 100;

	public int RadiusMultiplier = 3;

	[SerializeField]
	private bool isVisible;

	public bool IsVisible
	{
		get
		{
			return isVisible;
		}
		set
		{
			isVisible = value;
			GazeTarget[] componentsInChildren = base.gameObject.GetComponentsInChildren<GazeTarget>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				MeshRenderer component = componentsInChildren[i].GetComponent<MeshRenderer>();
				if (component != null)
				{
					component.enabled = isVisible;
				}
			}
		}
	}

	private void Start()
	{
		for (int i = 0; i < NumberOfDummyTargets; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(GazeTargetPrefab, base.transform);
			obj.name = obj.name + "_" + i;
			obj.transform.localPosition = UnityEngine.Random.insideUnitSphere * RadiusMultiplier;
			obj.transform.rotation = Quaternion.identity;
			obj.GetComponent<MeshRenderer>().enabled = IsVisible;
		}
	}

	private void OnValidate()
	{
		IsVisible = isVisible;
	}
}
public class RemoteLoopbackManager : MonoBehaviour
{
	private class PacketLatencyPair
	{
		public byte[] PacketData;

		public float FakeLatency;
	}

	[Serializable]
	public class SimulatedLatencySettings
	{
		[Range(0f, 0.5f)]
		public float FakeLatencyMax = 0.25f;

		[Range(0f, 0.5f)]
		public float FakeLatencyMin = 0.002f;

		[Range(0f, 1f)]
		public float LatencyWeight = 0.25f;

		[Range(0f, 10f)]
		public int MaxSamples = 4;

		internal float AverageWindow;

		internal float LatencySum;

		internal LinkedList<float> LatencyValues = new LinkedList<float>();

		public float NextValue()
		{
			AverageWindow = LatencySum / (float)LatencyValues.Count;
			float num = UnityEngine.Random.Range(FakeLatencyMin, FakeLatencyMax);
			float num2 = AverageWindow * (1f - LatencyWeight) + LatencyWeight * num;
			if (LatencyValues.Count >= MaxSamples)
			{
				LatencySum -= LatencyValues.First.Value;
				LatencyValues.RemoveFirst();
			}
			LatencySum += num2;
			LatencyValues.AddLast(num2);
			return num2;
		}
	}

	public OvrAvatar LocalAvatar;

	public OvrAvatar LoopbackAvatar;

	public SimulatedLatencySettings LatencySettings = new SimulatedLatencySettings();

	private int PacketSequence;

	private LinkedList<PacketLatencyPair> packetQueue = new LinkedList<PacketLatencyPair>();

	private void Start()
	{
		LocalAvatar.RecordPackets = true;
		OvrAvatar localAvatar = LocalAvatar;
		localAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(localAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		float num = UnityEngine.Random.Range(LatencySettings.FakeLatencyMin, LatencySettings.FakeLatencyMax);
		LatencySettings.LatencyValues.AddFirst(num);
		LatencySettings.LatencySum += num;
	}

	private void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (LocalAvatar.UseSDKPackets)
		{
			uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
			byte[] buffer = new byte[num];
			Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
			binaryWriter.Write(PacketSequence++);
			binaryWriter.Write(num);
			binaryWriter.Write(buffer);
		}
		else
		{
			binaryWriter.Write(PacketSequence++);
			args.Packet.Write(memoryStream);
		}
		SendPacketData(memoryStream.ToArray());
	}

	private void Update()
	{
		if (packetQueue.Count <= 0)
		{
			return;
		}
		List<PacketLatencyPair> list = new List<PacketLatencyPair>();
		foreach (PacketLatencyPair item in packetQueue)
		{
			item.FakeLatency -= Time.deltaTime;
			if (item.FakeLatency < 0f)
			{
				ReceivePacketData(item.PacketData);
				list.Add(item);
			}
		}
		foreach (PacketLatencyPair item2 in list)
		{
			packetQueue.Remove(item2);
		}
	}

	private void SendPacketData(byte[] data)
	{
		PacketLatencyPair packetLatencyPair = new PacketLatencyPair();
		packetLatencyPair.PacketData = data;
		packetLatencyPair.FakeLatency = LatencySettings.NextValue();
		packetQueue.AddLast(packetLatencyPair);
	}

	private void ReceivePacketData(byte[] data)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(memoryStream);
		int sequence = binaryReader.ReadInt32();
		OvrAvatarPacket packet;
		if (LoopbackAvatar.UseSDKPackets)
		{
			int count = binaryReader.ReadInt32();
			byte[] buffer = binaryReader.ReadBytes(count);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
			packet = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
		}
		else
		{
			packet = OvrAvatarPacket.Read(memoryStream);
		}
		LoopbackAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet);
	}
}
public class P2PManager
{
	private enum MessageType : byte
	{
		Update = 1
	}

	public P2PManager()
	{
		Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
		Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Net.Connect(userID);
			SocialPlatformManager.LogOutput("P2P connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Net.Close(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("P2P request accepted from " + msg.Data.ID);
			Net.Accept(msg.Data.ID);
		}
	}

	private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.p2pConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Net.Connect(msg.Data.ID);
				SocialPlatformManager.LogOutput("P2P re-connect to " + msg.Data.ID);
			}
		}
	}

	public void SendAvatarUpdate(ulong userID, Transform rootTransform, uint sequence, byte[] avatarPacket)
	{
		byte[] array = new byte[avatarPacket.Length + 41];
		int offset = 0;
		PackByte(1, array, ref offset);
		PackULong(SocialPlatformManager.MyID, array, ref offset);
		PackFloat(rootTransform.position.x, array, ref offset);
		PackFloat(0f, array, ref offset);
		PackFloat(rootTransform.position.z, array, ref offset);
		PackFloat(rootTransform.rotation.x, array, ref offset);
		PackFloat(rootTransform.rotation.y, array, ref offset);
		PackFloat(rootTransform.rotation.z, array, ref offset);
		PackFloat(rootTransform.rotation.w, array, ref offset);
		PackUInt32(sequence, array, ref offset);
		Debug.Assert(offset == 41);
		Buffer.BlockCopy(avatarPacket, 0, array, offset, avatarPacket.Length);
		Net.SendPacket(userID, array, SendPolicy.Unreliable);
	}

	public void GetRemotePackets()
	{
		Packet packet;
		while ((packet = Net.ReadPacket()) != null)
		{
			byte[] packet2 = new byte[packet.Size];
			packet.ReadBytes(packet2);
			int offset = 0;
			MessageType messageType = (MessageType)ReadByte(packet2, ref offset);
			ulong num = ReadULong(packet2, ref offset);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(num);
			if (remoteUser == null)
			{
				SocialPlatformManager.LogOutput("Unknown remote player: " + num);
			}
			else if (messageType == MessageType.Update)
			{
				processAvatarPacket(remoteUser, ref packet2, ref offset);
			}
			else
			{
				SocialPlatformManager.LogOutput("Invalid packet type: " + packet.Size);
			}
		}
	}

	public void processAvatarPacket(RemotePlayer remote, ref byte[] packet, ref int offset)
	{
		if (remote != null)
		{
			remote.receivedRootPositionPrior = remote.receivedRootPosition;
			remote.receivedRootPosition.x = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.y = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotationPrior = remote.receivedRootRotation;
			remote.receivedRootRotation.x = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.y = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.w = ReadFloat(packet, ref offset);
			remote.RemoteAvatar.transform.position = remote.receivedRootPosition;
			remote.RemoteAvatar.transform.rotation = remote.receivedRootRotation;
			int sequence = (int)ReadUInt32(packet, ref offset);
			byte[] array = new byte[packet.Length - offset];
			Buffer.BlockCopy(packet, offset, array, 0, array.Length);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)array.Length, array);
			OvrAvatarPacket packet2 = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
			remote.RemoteAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet2);
		}
	}

	private void PackByte(byte b, byte[] buf, ref int offset)
	{
		buf[offset] = b;
		offset++;
	}

	private byte ReadByte(byte[] buf, ref int offset)
	{
		byte result = buf[offset];
		offset++;
		return result;
	}

	private void PackFloat(float f, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
		offset += 4;
	}

	private float ReadFloat(byte[] buf, ref int offset)
	{
		float result = BitConverter.ToSingle(buf, offset);
		offset += 4;
		return result;
	}

	private void PackULong(ulong u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 8);
		offset += 8;
	}

	private ulong ReadULong(byte[] buf, ref int offset)
	{
		ulong result = BitConverter.ToUInt64(buf, offset);
		offset += 8;
		return result;
	}

	private void PackUInt32(uint u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 4);
		offset += 4;
	}

	private uint ReadUInt32(byte[] buf, ref int offset)
	{
		uint result = BitConverter.ToUInt32(buf, offset);
		offset += 4;
		return result;
	}
}
public class PlayerController : SocialPlatformManager
{
	public Camera spyCamera;

	private GameObject cameraRig;

	private bool showUI = true;

	public override void Awake()
	{
		base.Awake();
		cameraRig = localPlayerHead.gameObject;
	}

	public override void Start()
	{
		base.Start();
		spyCamera.enabled = false;
	}

	public override void Update()
	{
		base.Update();
		checkInput();
	}

	private void checkInput()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			if (OVRInput.GetDown(OVRInput.Button.Back))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
			{
				ToggleUI();
			}
		}
		else
		{
			if (OVRInput.GetDown(OVRInput.Button.Three))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.Four))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick))
			{
				ToggleUI();
			}
		}
	}

	private void ToggleCamera()
	{
		spyCamera.enabled = !spyCamera.enabled;
		localAvatar.ShowThirdPerson = !localAvatar.ShowThirdPerson;
		cameraRig.SetActive(!cameraRig.activeSelf);
	}

	private void ToggleUI()
	{
		showUI = !showUI;
		helpPanel.SetActive(showUI);
		localAvatar.ShowLeftController(showUI);
	}
}
public class RemotePlayer
{
	public ulong remoteUserID;

	public bool stillInRoom;

	public PeerConnectionState p2pConnectionState;

	public PeerConnectionState voipConnectionState;

	public OvrAvatar RemoteAvatar;

	public Vector3 receivedRootPosition;

	public Vector3 receivedRootPositionPrior;

	public Quaternion receivedRootRotation;

	public Quaternion receivedRootRotationPrior;

	public VoipAudioSourceHiLevel voipSource;
}
public class RoomManager
{
	public ulong roomID;

	private ulong invitedRoomID;

	private bool amIServer;

	private bool startupDone;

	public RoomManager()
	{
		amIServer = false;
		startupDone = false;
		Rooms.SetRoomInviteAcceptedNotificationCallback(AcceptingInviteCallback);
		Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
	}

	private void AcceptingInviteCallback(Message<string> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		SocialPlatformManager.LogOutput("Launched Invite to join Room: " + msg.Data);
		invitedRoomID = Convert.ToUInt64(msg.GetString());
		if (startupDone)
		{
			CheckForInvite();
		}
	}

	public bool CheckForInvite()
	{
		startupDone = true;
		if (invitedRoomID != 0L)
		{
			JoinExistingRoom(invitedRoomID);
			return true;
		}
		return false;
	}

	public void CreateRoom()
	{
		Rooms.CreateAndJoinPrivate(RoomJoinPolicy.FriendsOfOwner, 4u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
	}

	private void CreateAndJoinPrivateRoomCallback(Message<Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		roomID = msg.Data.ID;
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}

	private void OnLaunchInviteWorkflowComplete(Message msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
		}
	}

	public void JoinExistingRoom(ulong roomID)
	{
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.JOINING_A_ROOM);
		Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
	}

	private void JoinRoomCallback(Message<Room> msg)
	{
		if (!msg.IsError)
		{
			string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			SocialPlatformManager.LogOutput("Joined Room " + msg.Data.ID + " owner: " + text + " count: " + num);
			roomID = msg.Data.ID;
			ProcessRoomData(msg);
		}
	}

	private void RoomUpdateCallback(Message<Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
		int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
		SocialPlatformManager.LogOutput("Room Update " + msg.Data.ID + " owner: " + text + " count: " + num);
		ProcessRoomData(msg);
	}

	public void LeaveCurrentRoom()
	{
		if (roomID != 0L)
		{
			Rooms.Leave(roomID);
			roomID = 0uL;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.LEAVING_A_ROOM);
	}

	private void ProcessRoomData(Message<Room> msg)
	{
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		}
		else
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.CONNECTED_IN_A_ROOM);
		}
		SocialPlatformManager.MarkAllRemoteUsersAsNotInRoom();
		if (msg.Data.UsersOptional != null)
		{
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != SocialPlatformManager.MyID)
				{
					if (!SocialPlatformManager.IsUserInRoom(item.ID))
					{
						SocialPlatformManager.AddRemoteUser(item.ID);
					}
					else
					{
						SocialPlatformManager.MarkRemoteUserInRoom(item.ID);
					}
				}
			}
		}
		SocialPlatformManager.ForgetRemoteUsersNotInRoom();
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}
}
public class SocialPlatformManager : MonoBehaviour
{
	public enum State
	{
		INITIALIZING,
		CHECKING_LAUNCH_STATE,
		CREATING_A_ROOM,
		WAITING_IN_A_ROOM,
		JOINING_A_ROOM,
		CONNECTED_IN_A_ROOM,
		LEAVING_A_ROOM,
		SHUTDOWN
	}

	private static readonly Vector3 START_ROTATION_ONE = new Vector3(0f, 180f, 0f);

	private static readonly Vector3 START_POSITION_ONE = new Vector3(0f, 4f, 5f);

	private static readonly Vector3 START_ROTATION_TWO = new Vector3(0f, 0f, 0f);

	private static readonly Vector3 START_POSITION_TWO = new Vector3(0f, 4f, -5f);

	private static readonly Vector3 START_ROTATION_THREE = new Vector3(0f, 270f, 0f);

	private static readonly Vector3 START_POSITION_THREE = new Vector3(5f, 4f, 0f);

	private static readonly Vector3 START_ROTATION_FOUR = new Vector3(0f, 90f, 0f);

	private static readonly Vector3 START_POSITION_FOUR = new Vector3(-5f, 4f, 0f);

	private static readonly Color BLACK = new Color(0f, 0f, 0f);

	private static readonly Color WHITE = new Color(1f, 1f, 1f);

	private static readonly Color CYAN = new Color(0f, 1f, 1f);

	private static readonly Color BLUE = new Color(0f, 0f, 1f);

	private static readonly Color GREEN = new Color(0f, 1f, 0f);

	private float voiceCurrent;

	private uint packetSequence;

	public OvrAvatar localAvatarPrefab;

	public OvrAvatar remoteAvatarPrefab;

	public GameObject helpPanel;

	protected MeshRenderer helpMesh;

	public Material riftMaterial;

	public Material gearMaterial;

	protected OvrAvatar localAvatar;

	protected GameObject localTrackingSpace;

	protected GameObject localPlayerHead;

	protected Dictionary<ulong, RemotePlayer> remoteUsers = new Dictionary<ulong, RemotePlayer>();

	public GameObject roomSphere;

	protected MeshRenderer sphereMesh;

	public GameObject roomFloor;

	protected MeshRenderer floorMesh;

	protected State currentState;

	protected static SocialPlatformManager s_instance = null;

	protected RoomManager roomManager;

	protected P2PManager p2pManager;

	protected VoipManager voipManager;

	protected ulong myID;

	protected string myOculusID;

	public static readonly float VOIP_SCALE = 2f;

	public static State CurrentState => s_instance.currentState;

	public static ulong MyID
	{
		get
		{
			if (s_instance != null)
			{
				return s_instance.myID;
			}
			return 0uL;
		}
	}

	public static string MyOculusID
	{
		get
		{
			if (s_instance != null && s_instance.myOculusID != null)
			{
				return s_instance.myOculusID;
			}
			return string.Empty;
		}
	}

	public virtual void Update()
	{
		p2pManager.GetRemotePackets();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			if (remoteUser.Value.voipSource == null && remoteUser.Value.RemoteAvatar.MouthAnchor != null)
			{
				remoteUser.Value.voipSource = remoteUser.Value.RemoteAvatar.MouthAnchor.AddComponent<VoipAudioSourceHiLevel>();
				remoteUser.Value.voipSource.senderID = remoteUser.Value.remoteUserID;
			}
			if (remoteUser.Value.voipSource != null)
			{
				float voiceAmplitude = Mathf.Clamp(remoteUser.Value.voipSource.peakAmplitude * VOIP_SCALE, 0f, 1f);
				remoteUser.Value.RemoteAvatar.VoiceAmplitude = voiceAmplitude;
			}
		}
		if (localAvatar != null)
		{
			localAvatar.VoiceAmplitude = Mathf.Clamp(voiceCurrent * VOIP_SCALE, 0f, 1f);
		}
		Request.RunCallbacks();
	}

	public virtual void Awake()
	{
		LogOutputLine("Start Log.");
		helpMesh = helpPanel.GetComponent<MeshRenderer>();
		sphereMesh = roomSphere.GetComponent<MeshRenderer>();
		floorMesh = roomFloor.GetComponent<MeshRenderer>();
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localPlayerHead = base.transform.Find("OVRCameraRig/TrackingSpace/CenterEyeAnchor").gameObject;
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		TransitionToState(State.INITIALIZING);
		Core.AsyncInitialize().OnComplete(InitCallback);
		roomManager = new RoomManager();
		p2pManager = new P2PManager();
		voipManager = new VoipManager();
	}

	private void InitCallback(Message<PlatformInitialize> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		LaunchDetails launchDetails = ApplicationLifecycle.GetLaunchDetails();
		LogOutput("App launched with LaunchType " + launchDetails.LaunchType);
		Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
	}

	public virtual void Start()
	{
	}

	private void IsEntitledCallback(Message msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
		}
		else
		{
			Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
		}
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		myID = msg.Data.ID;
		myOculusID = msg.Data.OculusID;
		localAvatar = UnityEngine.Object.Instantiate(localAvatarPrefab);
		localAvatar.CanOwnMicrophone = false;
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localAvatar.transform.SetParent(localTrackingSpace.transform, worldPositionStays: false);
		localAvatar.transform.localPosition = new Vector3(0f, 0f, 0f);
		localAvatar.transform.localRotation = Quaternion.identity;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("body"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 1f, 1f);
			helpMesh.material = gearMaterial;
		}
		else
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("hand_left"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 0.2f, 0.2f);
			helpMesh.material = riftMaterial;
		}
		localAvatar.oculusUserID = myID.ToString();
		localAvatar.RecordPackets = true;
		OvrAvatar ovrAvatar = localAvatar;
		ovrAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(ovrAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		localAvatar.EnableMouthVertexAnimation = true;
		Quaternion identity = Quaternion.identity;
		switch (UnityEngine.Random.Range(0, 4))
		{
		case 0:
			identity.eulerAngles = START_ROTATION_ONE;
			base.transform.localPosition = START_POSITION_ONE;
			base.transform.localRotation = identity;
			break;
		case 1:
			identity.eulerAngles = START_ROTATION_TWO;
			base.transform.localPosition = START_POSITION_TWO;
			base.transform.localRotation = identity;
			break;
		case 2:
			identity.eulerAngles = START_ROTATION_THREE;
			base.transform.localPosition = START_POSITION_THREE;
			base.transform.localRotation = identity;
			break;
		default:
			identity.eulerAngles = START_ROTATION_FOUR;
			base.transform.localPosition = START_POSITION_FOUR;
			base.transform.localRotation = identity;
			break;
		}
		TransitionToState(State.CHECKING_LAUNCH_STATE);
		if (!roomManager.CheckForInvite())
		{
			LogOutput("No invite on launch, looking for a friend to join.");
			Users.GetLoggedInUserFriendsAndRooms().OnComplete(GetLoggedInUserFriendsAndRoomsCallback);
		}
		Voip.SetMicrophoneFilterCallback(MicFilter);
	}

	private void GetLoggedInUserFriendsAndRoomsCallback(Message<UserAndRoomList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		foreach (UserAndRoom datum in msg.Data)
		{
			if (datum.User != null && datum.RoomOptional != null && !datum.RoomOptional.IsMembershipLocked && datum.RoomOptional.Joinability == RoomJoinability.CanJoin && datum.RoomOptional.JoinPolicy != 0)
			{
				LogOutput("Trying to join room " + datum.RoomOptional.ID + ", friend " + datum.User.OculusID);
				roomManager.JoinExistingRoom(datum.RoomOptional.ID);
				return;
			}
		}
		LogOutput("No friend to join. Creating my own room.");
		roomManager.CreateRoom();
		TransitionToState(State.CREATING_A_ROOM);
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] array = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, array);
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.SendAvatarUpdate(remoteUser.Key, localTrackingSpace.transform, packetSequence, array);
		}
		packetSequence++;
	}

	public void OnApplicationQuit()
	{
		roomManager.LeaveCurrentRoom();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.Disconnect(remoteUser.Key);
			voipManager.Disconnect(remoteUser.Key);
		}
		LogOutputLine("End Log.");
	}

	public void AddUser(ulong userID, ref RemotePlayer remoteUser)
	{
		remoteUsers.Add(userID, remoteUser);
	}

	public void LogOutputLine(string line)
	{
		Debug.Log(Time.time + ": " + line);
	}

	public static void TerminateWithError(Message msg)
	{
		s_instance.LogOutputLine("Error: " + msg.GetError().Message);
		UnityEngine.Application.Quit();
	}

	public static void TransitionToState(State newState)
	{
		if ((bool)s_instance)
		{
			s_instance.LogOutputLine(string.Concat("State ", s_instance.currentState, " -> ", newState));
		}
		if ((bool)s_instance && s_instance.currentState != newState)
		{
			s_instance.currentState = newState;
			if (newState == State.SHUTDOWN)
			{
				s_instance.OnApplicationQuit();
			}
		}
		SetSphereColorForState();
	}

	private static void SetSphereColorForState()
	{
		switch (s_instance.currentState)
		{
		case State.INITIALIZING:
		case State.SHUTDOWN:
			s_instance.sphereMesh.material.color = BLACK;
			break;
		case State.WAITING_IN_A_ROOM:
			s_instance.sphereMesh.material.color = WHITE;
			break;
		case State.CONNECTED_IN_A_ROOM:
			s_instance.sphereMesh.material.color = CYAN;
			break;
		}
	}

	public static void SetFloorColorForState(bool host)
	{
		if (host)
		{
			s_instance.floorMesh.material.color = BLUE;
		}
		else
		{
			s_instance.floorMesh.material.color = GREEN;
		}
	}

	public static void MarkAllRemoteUsersAsNotInRoom()
	{
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			remoteUser.Value.stillInRoom = false;
		}
	}

	public static void MarkRemoteUserInRoom(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			value.stillInRoom = true;
		}
	}

	public static void ForgetRemoteUsersNotInRoom()
	{
		List<ulong> list = new List<ulong>();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			if (!remoteUser.Value.stillInRoom)
			{
				list.Add(remoteUser.Key);
			}
		}
		foreach (ulong item in list)
		{
			RemoveRemoteUser(item);
		}
	}

	public static void LogOutput(string line)
	{
		s_instance.LogOutputLine(Time.time + ": " + line);
	}

	public static bool IsUserInRoom(ulong userID)
	{
		return s_instance.remoteUsers.ContainsKey(userID);
	}

	public static void AddRemoteUser(ulong userID)
	{
		RemotePlayer remoteUser = new RemotePlayer();
		remoteUser.RemoteAvatar = UnityEngine.Object.Instantiate(s_instance.remoteAvatarPrefab);
		remoteUser.RemoteAvatar.oculusUserID = userID.ToString();
		remoteUser.RemoteAvatar.ShowThirdPerson = true;
		remoteUser.RemoteAvatar.EnableMouthVertexAnimation = true;
		remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
		remoteUser.voipConnectionState = PeerConnectionState.Unknown;
		remoteUser.stillInRoom = true;
		remoteUser.remoteUserID = userID;
		s_instance.AddUser(userID, ref remoteUser);
		s_instance.p2pManager.ConnectTo(userID);
		s_instance.voipManager.ConnectTo(userID);
		s_instance.LogOutputLine("Adding User " + userID);
	}

	public static void RemoveRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			UnityEngine.Object.Destroy(value.RemoteAvatar.MouthAnchor.GetComponent<VoipAudioSourceHiLevel>(), 0f);
			UnityEngine.Object.Destroy(value.RemoteAvatar.gameObject, 0f);
			s_instance.remoteUsers.Remove(userID);
			s_instance.LogOutputLine("Removing User " + userID);
		}
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (localAvatar != null)
		{
			localAvatar.UpdateVoiceData(pcmData, numChannels);
		}
		float num = 0f;
		float[] array = new float[pcmData.Length];
		for (int i = 0; i < pcmData.Length; i++)
		{
			float num2 = (array[i] = (float)pcmData[i] / 32767f);
			if (num2 > num)
			{
				num = num2;
			}
		}
		voiceCurrent = num;
	}

	[MonoPInvokeCallback(typeof(Oculus.Platform.CAPI.FilterCallback))]
	public static void MicFilter(short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels)
	{
		s_instance.UpdateVoiceData(pcmData, numChannels);
	}

	public static RemotePlayer GetRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			return value;
		}
		return null;
	}
}
public class VoipManager
{
	public VoipManager()
	{
		Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
		Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Voip.Start(userID);
			SocialPlatformManager.LogOutput("Voip connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Voip.Stop(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.voipConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("Voip request accepted from " + msg.Data.ID);
			Voip.Accept(msg.Data.ID);
		}
	}

	private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.voipConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Voip.Start(msg.Data.ID);
				SocialPlatformManager.LogOutput("Voip re-connect to " + msg.Data.ID);
			}
		}
	}
}
public class GazeTarget : MonoBehaviour
{
	public ovrAvatarGazeTargetType Type;

	private static ovrAvatarGazeTargets RuntimeTargetList;

	static GazeTarget()
	{
		RuntimeTargetList.targets = new ovrAvatarGazeTarget[128];
		RuntimeTargetList.targetCount = 1u;
	}

	private void Start()
	{
		UpdateGazeTarget();
		base.transform.hasChanged = false;
	}

	private void Update()
	{
		if (base.transform.hasChanged)
		{
			base.transform.hasChanged = false;
			UpdateGazeTarget();
		}
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.ovrAvatar_RemoveGazeTargets(1u, new uint[1] { (uint)base.transform.GetInstanceID() });
	}

	private void UpdateGazeTarget()
	{
		ovrAvatarGazeTarget ovrAvatarGazeTarget2 = CreateOvrGazeTarget((uint)base.transform.GetInstanceID(), base.transform.position, Type);
		RuntimeTargetList.targets[0] = ovrAvatarGazeTarget2;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateGazeTargets(RuntimeTargetList);
	}

	private ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}
}
[Serializable]
public class AvatarLayer
{
	public int layerIndex;
}
[Serializable]
public class PacketRecordSettings
{
	internal bool RecordingFrames;

	public float UpdateRate = 1f / 30f;

	internal float AccumulatedTime;
}
public class OvrAvatar : MonoBehaviour
{
	public class PacketEventArgs : EventArgs
	{
		public readonly OvrAvatarPacket Packet;

		public PacketEventArgs(OvrAvatarPacket packet)
		{
			Packet = packet;
		}
	}

	public enum HandType
	{
		Right,
		Left,
		Max
	}

	public enum HandJoint
	{
		HandBase,
		IndexBase,
		IndexTip,
		ThumbBase,
		ThumbTip,
		Max
	}

	[Header("Avatar")]
	public IntPtr sdkAvatar = IntPtr.Zero;

	public string oculusUserID;

	public OvrAvatarDriver Driver;

	[Header("Capabilities")]
	public bool EnableBody = true;

	public bool EnableHands = true;

	public bool EnableBase = true;

	public bool EnableExpressive;

	[Header("Network")]
	public bool RecordPackets;

	public bool UseSDKPackets = true;

	public PacketRecordSettings PacketSettings = new PacketRecordSettings();

	[Header("Visibility")]
	public bool StartWithControllers;

	public AvatarLayer FirstPersonLayer;

	public AvatarLayer ThirdPersonLayer;

	public bool ShowFirstPerson = true;

	public bool ShowThirdPerson;

	internal ovrAvatarCapabilities Capabilities = ovrAvatarCapabilities.Body;

	[Header("Performance")]
	[Tooltip("LOD mesh complexity and texture resolution. Highest LOD recommended on PC and simple mobile apps. Medium LOD recommended on mobile devices or for background characters on PC. Lowest LOD recommended for background characters on mobile.")]
	[SerializeField]
	internal ovrAvatarAssetLevelOfDetail LevelOfDetail = ovrAvatarAssetLevelOfDetail.Medium;

	[Tooltip("Enable to use combined meshes to reduce draw calls. Currently only available on mobile devices. Will be forced to false on PC.")]
	private bool CombineMeshes = true;

	[Tooltip("Enable to use transparent queue, disable to use geometry queue. Requires restart to take effect.")]
	public bool UseTransparentRenderQueue = true;

	[Header("Shaders")]
	public Shader Monochrome_SurfaceShader;

	public Shader Monochrome_SurfaceShader_SelfOccluding;

	public Shader Monochrome_SurfaceShader_PBS;

	public Shader Skinshaded_SurfaceShader_SingleComponent;

	public Shader Skinshaded_VertFrag_SingleComponent;

	public Shader Skinshaded_VertFrag_CombinedMesh;

	public Shader Skinshaded_Expressive_SurfaceShader_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_CombinedMesh;

	public Shader Loader_VertFrag_CombinedMesh;

	public Shader EyeLens;

	public Shader ControllerShader;

	[Header("Other")]
	public bool CanOwnMicrophone = true;

	[Tooltip("Enable laughter detection and animation as part of OVRLipSync.")]
	public bool EnableLaughter = true;

	public GameObject MouthAnchor;

	public Transform LeftHandCustomPose;

	public Transform RightHandCustomPose;

	private HashSet<ulong> assetLoadingIds = new HashSet<ulong>();

	private bool assetsFinishedLoading;

	private OvrAvatarMaterialManager materialManager;

	private bool waitingForCombinedMesh;

	private static bool doneExpressiveGlobalInit;

	private Vector4 clothingAlphaOffset = new Vector4(0f, 0f, 0f, 1f);

	private ulong clothingAlphaTexture;

	private OVRLipSyncMicInput micInput;

	private OVRLipSyncContext lipsyncContext;

	private OVRLipSync.Frame currentFrame = new OVRLipSync.Frame();

	private float[] visemes = new float[16];

	private AudioSource audioSource;

	private ONSPAudioSource spatializedSource;

	private List<float[]> voiceUpdates = new List<float[]>();

	private static ovrAvatarVisemes RuntimeVisemes;

	private Transform cachedLeftHandCustomPose;

	private Transform[] cachedCustomLeftHandJoints;

	private ovrAvatarTransform[] cachedLeftHandTransforms;

	private Transform cachedRightHandCustomPose;

	private Transform[] cachedCustomRightHandJoints;

	private ovrAvatarTransform[] cachedRightHandTransforms;

	private bool showLeftController;

	private bool showRightController;

	private const bool USE_MOBILE_TEXTURE_FORMAT = true;

	private static readonly Vector3 MOUTH_HEAD_OFFSET;

	private const string MOUTH_HELPER_NAME = "MouthAnchor";

	private const int VISEME_COUNT = 16;

	private const float ACTION_UNIT_ONSET_SPEED = 30f;

	private const float ACTION_UNIT_FALLOFF_SPEED = 20f;

	private const float VISEME_LEVEL_MULTIPLIER = 1.5f;

	internal ulong oculusUserIDInternal;

	internal OvrAvatarBase Base;

	internal OvrAvatarTouchController ControllerLeft;

	internal OvrAvatarTouchController ControllerRight;

	internal OvrAvatarBody Body;

	internal OvrAvatarHand HandLeft;

	internal OvrAvatarHand HandRight;

	internal ovrAvatarLookAndFeelVersion LookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	internal ovrAvatarLookAndFeelVersion FallbackLookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	private OvrAvatarPacket CurrentUnityPacket;

	public EventHandler<PacketEventArgs> PacketRecorded;

	private static string[,] HandJoints;

	private static Vector3 MOUTH_POSITION_OFFSET;

	private static string VOICE_PROPERTY;

	private static string MOUTH_POSITION_PROPERTY;

	private static string MOUTH_DIRECTION_PROPERTY;

	private static string MOUTH_SCALE_PROPERTY;

	private static float MOUTH_SCALE_GLOBAL;

	private static float MOUTH_MAX_GLOBAL;

	private static string NECK_JONT;

	public float VoiceAmplitude;

	public bool EnableMouthVertexAnimation;

	private static ovrAvatarLights ovrLights;

	static OvrAvatar()
	{
		doneExpressiveGlobalInit = false;
		MOUTH_HEAD_OFFSET = new Vector3(0f, -0.085f, 0.09f);
		HandJoints = new string[2, 5]
		{
			{ "hands:r_hand_world", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1/hands:b_r_index2/hands:b_r_index3/hands:b_r_index_ignore", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2/hands:b_r_thumb3/hands:b_r_thumb_ignore" },
			{ "hands:l_hand_world", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1/hands:b_l_index2/hands:b_l_index3/hands:b_l_index_ignore", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2/hands:b_l_thumb3/hands:b_l_thumb_ignore" }
		};
		MOUTH_POSITION_OFFSET = new Vector3(0f, -0.018f, 0.1051f);
		VOICE_PROPERTY = "_Voice";
		MOUTH_POSITION_PROPERTY = "_MouthPosition";
		MOUTH_DIRECTION_PROPERTY = "_MouthDirection";
		MOUTH_SCALE_PROPERTY = "_MouthEffectScale";
		MOUTH_SCALE_GLOBAL = 0.007f;
		MOUTH_MAX_GLOBAL = 0.007f;
		NECK_JONT = "root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT";
		ovrLights = default(ovrAvatarLights);
		RuntimeVisemes.visemeParams = new float[32];
		RuntimeVisemes.visemeParamCount = 16u;
	}

	private void OnDestroy()
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_Destroy(sdkAvatar);
		}
	}

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		assetLoadingIds.Remove(asset.assetID);
	}

	public void CombinedMeshLoadedCallback(IntPtr assetPtr)
	{
		if (waitingForCombinedMesh)
		{
			ulong[] array = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshIDs(assetPtr);
			foreach (ulong item in array)
			{
				assetLoadingIds.Remove(item);
			}
			Oculus.Avatar.CAPI.ovrAvatar_GetCombinedMeshAlphaData(sdkAvatar, ref clothingAlphaTexture, ref clothingAlphaOffset);
			waitingForCombinedMesh = false;
		}
	}

	private OvrAvatarSkinnedMeshRenderComponent AddSkinnedMeshRenderComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender)
	{
		OvrAvatarSkinnedMeshRenderComponent ovrAvatarSkinnedMeshRenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderComponent>();
		ovrAvatarSkinnedMeshRenderComponent.Initialize(skinnedMeshRender, Monochrome_SurfaceShader, Monochrome_SurfaceShader_SelfOccluding, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderComponent;
	}

	private OvrAvatarSkinnedMeshRenderPBSComponent AddSkinnedMeshRenderPBSComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS)
	{
		OvrAvatarSkinnedMeshRenderPBSComponent ovrAvatarSkinnedMeshRenderPBSComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderPBSComponent>();
		ovrAvatarSkinnedMeshRenderPBSComponent.Initialize(skinnedMeshRenderPBS, Monochrome_SurfaceShader_PBS, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderPBSComponent;
	}

	private OvrAvatarSkinnedMeshPBSV2RenderComponent AddSkinnedMeshRenderPBSV2Component(IntPtr renderPart, GameObject go, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRenderPBSV2, bool isBodyPartZero, bool isControllerModel)
	{
		OvrAvatarSkinnedMeshPBSV2RenderComponent ovrAvatarSkinnedMeshPBSV2RenderComponent = go.AddComponent<OvrAvatarSkinnedMeshPBSV2RenderComponent>();
		ovrAvatarSkinnedMeshPBSV2RenderComponent.Initialize(renderPart, skinnedMeshRenderPBSV2, materialManager, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, isBodyPartZero && CombineMeshes, LevelOfDetail, isBodyPartZero && EnableExpressive, this, isControllerModel);
		return ovrAvatarSkinnedMeshPBSV2RenderComponent;
	}

	public static IntPtr GetRenderPart(ovrAvatarComponent component, uint renderPartIndex)
	{
		return Marshal.ReadIntPtr(component.renderParts, Marshal.SizeOf(typeof(IntPtr)) * (int)renderPartIndex);
	}

	private static string GetRenderPartName(ovrAvatarComponent component, uint renderPartIndex)
	{
		return component.name + "_renderPart_" + (int)renderPartIndex;
	}

	internal static void ConvertTransform(float[] transform, ref ovrAvatarTransform target)
	{
		target.position.x = transform[0];
		target.position.y = transform[1];
		target.position.z = transform[2];
		target.orientation.x = transform[3];
		target.orientation.y = transform[4];
		target.orientation.z = transform[5];
		target.orientation.w = transform[6];
		target.scale.x = transform[7];
		target.scale.y = transform[8];
		target.scale.z = transform[9];
	}

	internal static void ConvertTransform(ovrAvatarTransform transform, Transform target)
	{
		Vector3 position = transform.position;
		position.z = 0f - position.z;
		Quaternion orientation = transform.orientation;
		orientation.x = 0f - orientation.x;
		orientation.y = 0f - orientation.y;
		target.localPosition = position;
		target.localRotation = orientation;
		target.localScale = transform.scale;
	}

	public static ovrAvatarTransform CreateOvrAvatarTransform(Vector3 position, Quaternion orientation)
	{
		ovrAvatarTransform result = default(ovrAvatarTransform);
		result.position = new Vector3(position.x, position.y, 0f - position.z);
		result.orientation = new Quaternion(0f - orientation.x, 0f - orientation.y, orientation.z, orientation.w);
		result.scale = Vector3.one;
		return result;
	}

	private static ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}

	private void BuildRenderComponents()
	{
		ovrAvatarBaseComponent component = default(ovrAvatarBaseComponent);
		ovrAvatarHandComponent component2 = default(ovrAvatarHandComponent);
		ovrAvatarHandComponent component3 = default(ovrAvatarHandComponent);
		ovrAvatarControllerComponent component4 = default(ovrAvatarControllerComponent);
		ovrAvatarControllerComponent component5 = default(ovrAvatarControllerComponent);
		ovrAvatarBodyComponent component6 = default(ovrAvatarBodyComponent);
		ovrAvatarComponent component7 = default(ovrAvatarComponent);
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(sdkAvatar, ref component2))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component2.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandLeft, component7);
			HandLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(sdkAvatar, ref component3))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component3.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandRight, component7);
			HandRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref component6))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component6.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Body, component7);
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(sdkAvatar, ref component4))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component4.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerLeft, component7);
			ControllerLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(sdkAvatar, ref component5))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component5.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerRight, component7);
			ControllerRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Base, component7);
		}
	}

	private void AddAvatarComponent<T>(ref T root, ovrAvatarComponent nativeComponent) where T : OvrAvatarComponent
	{
		GameObject gameObject = new GameObject();
		gameObject.name = nativeComponent.name;
		gameObject.transform.SetParent(base.transform);
		root = gameObject.AddComponent<T>();
		root.SetOvrAvatarOwner(this);
		AddRenderParts(root, nativeComponent, gameObject.transform);
	}

	private void UpdateCustomPoses()
	{
		if (UpdatePoseRoot(LeftHandCustomPose, ref cachedLeftHandCustomPose, ref cachedCustomLeftHandJoints, ref cachedLeftHandTransforms) && cachedLeftHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (UpdatePoseRoot(RightHandCustomPose, ref cachedRightHandCustomPose, ref cachedCustomRightHandJoints, ref cachedRightHandTransforms) && cachedRightHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (sdkAvatar != IntPtr.Zero)
		{
			if (cachedLeftHandCustomPose != null && UpdateTransforms(cachedCustomLeftHandJoints, cachedLeftHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandCustomGesture(sdkAvatar, (uint)cachedLeftHandTransforms.Length, cachedLeftHandTransforms);
			}
			if (cachedRightHandCustomPose != null && UpdateTransforms(cachedCustomRightHandJoints, cachedRightHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetRightHandCustomGesture(sdkAvatar, (uint)cachedRightHandTransforms.Length, cachedRightHandTransforms);
			}
		}
	}

	private static bool UpdatePoseRoot(Transform poseRoot, ref Transform cachedPoseRoot, ref Transform[] cachedPoseJoints, ref ovrAvatarTransform[] transforms)
	{
		if (poseRoot == cachedPoseRoot)
		{
			return false;
		}
		if (!poseRoot)
		{
			cachedPoseRoot = null;
			cachedPoseJoints = null;
			transforms = null;
		}
		else
		{
			List<Transform> list = new List<Transform>();
			OrderJoints(poseRoot, list);
			cachedPoseRoot = poseRoot;
			cachedPoseJoints = list.ToArray();
			transforms = new ovrAvatarTransform[list.Count];
		}
		return true;
	}

	private static bool UpdateTransforms(Transform[] joints, ovrAvatarTransform[] transforms)
	{
		bool result = false;
		for (int i = 0; i < joints.Length; i++)
		{
			Transform transform = joints[i];
			ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(transform.localPosition, transform.localRotation);
			if (ovrAvatarTransform2.position != transforms[i].position || ovrAvatarTransform2.orientation != transforms[i].orientation)
			{
				transforms[i] = ovrAvatarTransform2;
				result = true;
			}
		}
		return result;
	}

	private static void OrderJoints(Transform transform, List<Transform> joints)
	{
		joints.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			OrderJoints(transform.GetChild(i), joints);
		}
	}

	private void AvatarSpecificationCallback(IntPtr avatarSpecification)
	{
		sdkAvatar = Oculus.Avatar.CAPI.ovrAvatar_Create(avatarSpecification, Capabilities);
		ShowLeftController(showLeftController);
		ShowRightController(showRightController);
		if (Driver != null)
		{
			Driver.UpdateTransformsFromPose(sdkAvatar);
		}
		uint num = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAssetCount(sdkAvatar);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			ulong num3 = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAsset(sdkAvatar, num2);
			if (OvrAvatarSDKManager.Instance.GetAsset(num3) == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(num3, LevelOfDetail, AssetLoadedCallback);
				assetLoadingIds.Add(num3);
			}
		}
		if (CombineMeshes)
		{
			OvrAvatarSDKManager.Instance.RegisterCombinedMeshCallback(sdkAvatar, CombinedMeshLoadedCallback);
		}
	}

	private void Start()
	{
		if (!(OvrAvatarSDKManager.Instance == null))
		{
			materialManager = base.gameObject.AddComponent<OvrAvatarMaterialManager>();
			try
			{
				oculusUserIDInternal = ulong.Parse(oculusUserID);
			}
			catch (Exception)
			{
				oculusUserIDInternal = 0uL;
			}
			if (oculusUserIDInternal == 0L)
			{
				CombineMeshes = false;
			}
			Capabilities = (ovrAvatarCapabilities)0;
			if (EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Body;
			}
			if (EnableHands)
			{
				Capabilities |= ovrAvatarCapabilities.Hands;
			}
			if (EnableBase && EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Base;
			}
			if (EnableExpressive)
			{
				Capabilities |= ovrAvatarCapabilities.Expressive;
			}
			if (OVRPlugin.positionSupported)
			{
				Capabilities |= ovrAvatarCapabilities.BodyTilt;
			}
			ShowLeftController(StartWithControllers);
			ShowRightController(StartWithControllers);
			OvrAvatarSDKManager.AvatarSpecRequestParams avatarSpecRequest = new OvrAvatarSDKManager.AvatarSpecRequestParams(oculusUserIDInternal, AvatarSpecificationCallback, CombineMeshes, LevelOfDetail, forceMobileTextureFormat: true, LookAndFeelVersion, FallbackLookAndFeelVersion, EnableExpressive);
			OvrAvatarSDKManager.Instance.RequestAvatarSpecification(avatarSpecRequest);
			OvrAvatarSDKManager.Instance.AddLoadingAvatar(GetInstanceID());
			waitingForCombinedMesh = CombineMeshes;
			if (Driver != null)
			{
				Driver.Mode = ((!UseSDKPackets) ? OvrAvatarDriver.PacketMode.Unity : OvrAvatarDriver.PacketMode.SDK);
			}
		}
	}

	private void Update()
	{
		if (!OvrAvatarSDKManager.Instance || sdkAvatar == IntPtr.Zero || materialManager == null)
		{
			return;
		}
		if (Driver != null)
		{
			Driver.UpdateTransforms(sdkAvatar);
			foreach (float[] voiceUpdate in voiceUpdates)
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateVoiceVisualization(sdkAvatar, voiceUpdate);
			}
			voiceUpdates.Clear();
			Oculus.Avatar.CAPI.ovrAvatarPose_Finalize(sdkAvatar, Time.deltaTime);
		}
		if (RecordPackets)
		{
			RecordFrame();
		}
		if (assetLoadingIds.Count != 0)
		{
			return;
		}
		if (!assetsFinishedLoading)
		{
			try
			{
				BuildRenderComponents();
			}
			catch (Exception ex)
			{
				assetsFinishedLoading = true;
				throw ex;
			}
			InitPostLoad();
			assetsFinishedLoading = true;
			OvrAvatarSDKManager.Instance.RemoveLoadingAvatar(GetInstanceID());
		}
		UpdateVoiceBehavior();
		UpdateCustomPoses();
		if (EnableExpressive)
		{
			UpdateExpressive();
		}
	}

	public static ovrAvatarHandInputState CreateInputState(ovrAvatarTransform transform, OvrAvatarDriver.ControllerPose pose)
	{
		ovrAvatarHandInputState result = default(ovrAvatarHandInputState);
		result.transform = transform;
		result.buttonMask = pose.buttons;
		result.touchMask = pose.touches;
		result.joystickX = pose.joystickPosition.x;
		result.joystickY = pose.joystickPosition.y;
		result.indexTrigger = pose.indexTrigger;
		result.handTrigger = pose.handTrigger;
		result.isActive = pose.isActive;
		return result;
	}

	public void ShowControllers(bool show)
	{
		ShowLeftController(show);
		ShowRightController(show);
	}

	public void ShowLeftController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftControllerVisibility(sdkAvatar, show);
		}
		showLeftController = show;
	}

	public void ShowRightController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightControllerVisibility(sdkAvatar, show);
		}
		showRightController = show;
	}

	public void UpdateVoiceVisualization(float[] voiceSamples)
	{
		voiceUpdates.Add(voiceSamples);
	}

	private void RecordFrame()
	{
		if (UseSDKPackets)
		{
			RecordSDKFrame();
		}
		else
		{
			RecordUnityFrame();
		}
	}

	private void RecordUnityFrame()
	{
		float num = Time.deltaTime;
		OvrAvatarDriver.PoseFrame currentPose = Driver.GetCurrentPose();
		if (CurrentUnityPacket == null)
		{
			CurrentUnityPacket = new OvrAvatarPacket(currentPose);
			num = 0f;
		}
		float num2 = 0f;
		while (num2 < num)
		{
			float num3 = num - num2;
			float num4 = PacketSettings.UpdateRate - CurrentUnityPacket.Duration;
			if (num3 < num4)
			{
				CurrentUnityPacket.AddFrame(currentPose, num3);
				num2 += num3;
				continue;
			}
			OvrAvatarDriver.PoseFrame finalFrame = CurrentUnityPacket.FinalFrame;
			OvrAvatarDriver.PoseFrame b = currentPose;
			float t = num4 / num3;
			OvrAvatarDriver.PoseFrame poseFrame = OvrAvatarDriver.PoseFrame.Interpolate(finalFrame, b, t);
			CurrentUnityPacket.AddFrame(poseFrame, num4);
			num2 += num4;
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(CurrentUnityPacket));
			}
			CurrentUnityPacket = new OvrAvatarPacket(poseFrame);
		}
	}

	private void RecordSDKFrame()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (!PacketSettings.RecordingFrames)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			PacketSettings.AccumulatedTime = 0f;
			PacketSettings.RecordingFrames = true;
		}
		PacketSettings.AccumulatedTime += Time.deltaTime;
		if (PacketSettings.AccumulatedTime >= PacketSettings.UpdateRate)
		{
			PacketSettings.AccumulatedTime = 0f;
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarPacket_EndRecording(sdkAvatar);
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(new OvrAvatarPacket
				{
					ovrNativePacket = intPtr
				}));
			}
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(intPtr);
		}
	}

	private void AddRenderParts(OvrAvatarComponent ovrComponent, ovrAvatarComponent component, Transform parent)
	{
		bool flag = ovrComponent.name == "body";
		bool flag2 = ovrComponent.name == "controller_left";
		bool flag3 = ovrComponent.name == "controller_right";
		for (uint num = 0u; num < component.renderPartCount; num++)
		{
			GameObject gameObject = new GameObject();
			gameObject.name = GetRenderPartName(component, num);
			gameObject.transform.SetParent(parent);
			IntPtr renderPart = GetRenderPart(component, num);
			ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
			OvrAvatarRenderComponent ovrAvatarRenderComponent = null;
			switch (ovrAvatarRenderPartType2)
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSV2Component(renderPart, gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(renderPart), flag && num == 0, flag2 || flag3);
				break;
			}
			if (ovrAvatarRenderComponent != null)
			{
				ovrComponent.RenderParts.Add(ovrAvatarRenderComponent);
			}
		}
	}

	public void RefreshBodyParts()
	{
		if (!(Body != null))
		{
			return;
		}
		foreach (OvrAvatarRenderComponent renderPart in Body.RenderParts)
		{
			UnityEngine.Object.Destroy(renderPart.gameObject);
		}
		Body.RenderParts.Clear();
		ovrAvatarComponent? nativeAvatarComponent = Body.GetNativeAvatarComponent();
		if (nativeAvatarComponent.HasValue)
		{
			AddRenderParts(Body, nativeAvatarComponent.Value, Body.gameObject.transform);
		}
	}

	public ovrAvatarBodyComponent? GetBodyComponent()
	{
		if (Body != null)
		{
			Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref Body.component);
			return Body.component;
		}
		return null;
	}

	public Transform GetHandTransform(HandType hand, HandJoint joint)
	{
		if (hand >= HandType.Max || joint >= HandJoint.Max)
		{
			return null;
		}
		OvrAvatarHand ovrAvatarHand = ((hand == HandType.Left) ? HandLeft : HandRight);
		if (ovrAvatarHand != null)
		{
			OvrAvatarComponent component = ovrAvatarHand.GetComponent<OvrAvatarComponent>();
			if (component != null && component.RenderParts.Count > 0)
			{
				return component.RenderParts[0].transform.Find(HandJoints[(int)hand, (int)joint]);
			}
		}
		return null;
	}

	public void GetPointingDirection(HandType hand, ref Vector3 forward, ref Vector3 up)
	{
		Transform handTransform = GetHandTransform(hand, HandJoint.HandBase);
		if (handTransform != null)
		{
			forward = handTransform.forward;
			up = handTransform.up;
		}
	}

	private void UpdateVoiceBehavior()
	{
		if (EnableMouthVertexAnimation && Body != null)
		{
			OvrAvatarComponent component = Body.GetComponent<OvrAvatarComponent>();
			VoiceAmplitude = Mathf.Clamp(VoiceAmplitude, 0f, 1f);
			if (component.RenderParts.Count > 0)
			{
				Material sharedMaterial = component.RenderParts[0].mesh.sharedMaterial;
				Transform transform = component.RenderParts[0].mesh.transform.Find(NECK_JONT);
				Vector3 vector = transform.TransformPoint(Vector3.up) - transform.position;
				sharedMaterial.SetFloat(MOUTH_SCALE_PROPERTY, vector.magnitude);
				sharedMaterial.SetFloat(VOICE_PROPERTY, Mathf.Min(vector.magnitude * MOUTH_MAX_GLOBAL, vector.magnitude * VoiceAmplitude * MOUTH_SCALE_GLOBAL));
				sharedMaterial.SetVector(MOUTH_POSITION_PROPERTY, transform.TransformPoint(MOUTH_POSITION_OFFSET));
				sharedMaterial.SetVector(MOUTH_DIRECTION_PROPERTY, transform.up);
			}
		}
	}

	private bool IsValidMic()
	{
		string[] devices = Microphone.devices;
		if (devices.Length < 1)
		{
			return false;
		}
		int num = 0;
		string deviceName = devices[num];
		Microphone.GetDeviceCaps(deviceName, out var _, out var maxFreq);
		if (maxFreq == 0)
		{
			maxFreq = 44100;
		}
		if (Microphone.Start(deviceName, loop: true, 1, maxFreq) == null)
		{
			return false;
		}
		Microphone.End(deviceName);
		return true;
	}

	private void InitPostLoad()
	{
		ExpressiveGlobalInit();
		ConfigureHelpers();
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			lipsyncContext.audioLoopback = false;
			if (CanOwnMicrophone && IsValidMic())
			{
				micInput = MouthAnchor.gameObject.AddComponent<OVRLipSyncMicInput>();
				micInput.enableMicSelectionGUI = false;
				micInput.MicFrequency = 44100f;
				micInput.micControl = OVRLipSyncMicInput.micActivation.ConstantSpeak;
			}
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitOnsetSpeed(sdkAvatar, 30f);
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitFalloffSpeed(sdkAvatar, 20f);
			Oculus.Avatar.CAPI.ovrAvatar_SetVisemeMultiplier(sdkAvatar, 1.5f);
		}
	}

	private static void ExpressiveGlobalInit()
	{
		if (!doneExpressiveGlobalInit)
		{
			doneExpressiveGlobalInit = true;
			ovrLights.lights = new ovrAvatarLight[16];
			InitializeLights();
		}
	}

	private static void InitializeLights()
	{
		ovrLights.ambientIntensity = RenderSettings.ambientLight.grayscale * 0.5f;
		Light[] array = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		int num = 0;
		for (num = 0; num < array.Length && num < ovrLights.lights.Length; num++)
		{
			Light light = array[num];
			if ((bool)light && light.enabled)
			{
				uint instanceID = (uint)light.transform.GetInstanceID();
				switch (light.type)
				{
				case LightType.Directional:
					CreateLightDirectional(instanceID, light.transform.forward, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Point:
					CreateLightPoint(instanceID, light.transform.position, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Spot:
					CreateLightSpot(instanceID, light.transform.position, light.transform.forward, light.spotAngle, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				}
			}
		}
		ovrLights.lightCount = (uint)num;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateLights(ovrLights);
	}

	private static ovrAvatarLight CreateLightDirectional(uint id, Vector3 direction, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Direction;
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightPoint(uint id, Vector3 position, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Point;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightSpot(uint id, Vector3 position, Vector3 direction, float spotAngleDeg, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Spot;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.spotAngleDeg = spotAngleDeg;
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private void UpdateExpressive()
	{
		ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(base.transform.position, base.transform.rotation);
		Oculus.Avatar.CAPI.ovrAvatar_UpdateWorldTransform(sdkAvatar, ovrAvatarTransform2);
		UpdateFacewave();
	}

	private void ConfigureHelpers()
	{
		Transform transform = base.transform.Find("body/body_renderPart_0/root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT/head_JNT");
		if (transform == null)
		{
			transform = base.transform;
		}
		if (MouthAnchor == null)
		{
			MouthAnchor = CreateHelperObject(transform, MOUTH_HEAD_OFFSET, "MouthAnchor");
		}
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			if (audioSource == null)
			{
				audioSource = MouthAnchor.gameObject.AddComponent<AudioSource>();
			}
			spatializedSource = MouthAnchor.GetComponent<ONSPAudioSource>();
			if (spatializedSource == null)
			{
				spatializedSource = MouthAnchor.gameObject.AddComponent<ONSPAudioSource>();
			}
			spatializedSource.UseInvSqr = true;
			spatializedSource.EnableRfl = false;
			spatializedSource.EnableSpatialization = true;
			spatializedSource.Far = 100f;
			spatializedSource.Near = 0.1f;
			lipsyncContext = MouthAnchor.GetComponent<OVRLipSyncContext>();
			if (lipsyncContext == null)
			{
				lipsyncContext = MouthAnchor.gameObject.AddComponent<OVRLipSyncContext>();
			}
			lipsyncContext.provider = ((!EnableLaughter) ? OVRLipSync.ContextProviders.Enhanced : OVRLipSync.ContextProviders.Enhanced_with_Laughter);
			lipsyncContext.skipAudioSource = !CanOwnMicrophone;
			StartCoroutine(WaitForMouthAudioSource());
		}
		if (GetComponent<OvrAvatarRemoteDriver>() != null)
		{
			transform.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHead;
			Transform transform2 = base.transform.Find("hand_left");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
			transform2 = base.transform.Find("hand_right");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
		}
	}

	private IEnumerator WaitForMouthAudioSource()
	{
		while (MouthAnchor.GetComponent<AudioSource>() == null)
		{
			yield return new WaitForSeconds(0.1f);
		}
		AudioSource component = MouthAnchor.GetComponent<AudioSource>();
		component.minDistance = 0.3f;
		component.maxDistance = 4f;
		component.rolloffMode = AudioRolloffMode.Logarithmic;
		component.loop = true;
		component.playOnAwake = true;
		component.spatialBlend = 1f;
		component.spatialize = true;
		component.spatializePostEffects = true;
	}

	public void DestroyHelperObjects()
	{
		if ((bool)MouthAnchor)
		{
			UnityEngine.Object.DestroyImmediate(MouthAnchor.gameObject);
		}
	}

	public GameObject CreateHelperObject(Transform parent, Vector3 localPositionOffset, string helperName, string helperTag = "")
	{
		GameObject gameObject = new GameObject();
		gameObject.name = helperName;
		if (helperTag != "")
		{
			gameObject.tag = helperTag;
		}
		gameObject.transform.SetParent(parent);
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localPosition = localPositionOffset;
		return gameObject;
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	public void UpdateVoiceData(float[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	private void UpdateFacewave()
	{
		if (!(lipsyncContext != null) || (!(micInput != null) && CanOwnMicrophone))
		{
			return;
		}
		currentFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentFrame.Visemes.Length != 15)
		{
			Debug.LogError("Unexpected number of visemes " + currentFrame.Visemes);
			return;
		}
		currentFrame.Visemes.CopyTo(visemes, 0);
		visemes[15] = (EnableLaughter ? currentFrame.laughterScore : 0f);
		for (int i = 0; i < 16; i++)
		{
			RuntimeVisemes.visemeParams[i] = visemes[i];
		}
		Oculus.Avatar.CAPI.ovrAvatar_SetVisemes(sdkAvatar, RuntimeVisemes);
	}
}
public class OvrAvatarAsset
{
	public ulong assetID;
}
public class OvrAvatarAssetMesh : OvrAvatarAsset
{
	public Mesh mesh;

	private ovrAvatarSkinnedMeshPose skinnedBindPose;

	public string[] jointNames;

	public OvrAvatarAssetMesh(ulong _assetId, IntPtr asset, ovrAvatarAssetType meshType)
	{
		assetID = _assetId;
		mesh = new Mesh();
		mesh.name = "Procedural Geometry for asset " + _assetId;
		SetSkinnedBindPose(asset, meshType);
		long vertexCount = 0L;
		IntPtr vertexBuffer = IntPtr.Zero;
		uint indexCount = 0u;
		IntPtr indexBuffer = IntPtr.Zero;
		GetVertexAndIndexData(asset, meshType, out vertexCount, out vertexBuffer, out indexCount, out indexBuffer);
		Vector3[] array = new Vector3[vertexCount];
		Vector3[] array2 = new Vector3[vertexCount];
		Vector4[] array3 = new Vector4[vertexCount];
		Vector2[] array4 = new Vector2[vertexCount];
		Color[] array5 = new Color[vertexCount];
		BoneWeight[] array6 = new BoneWeight[vertexCount];
		long num = vertexBuffer.ToInt64();
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
		{
			long num5 = Marshal.SizeOf(typeof(ovrAvatarMeshVertex));
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				long num7 = num5 * num6;
				ovrAvatarMeshVertex ovrAvatarMeshVertex2 = (ovrAvatarMeshVertex)Marshal.PtrToStructure(new IntPtr(num + num7), typeof(ovrAvatarMeshVertex));
				array[num6] = new Vector3(ovrAvatarMeshVertex2.x, ovrAvatarMeshVertex2.y, 0f - ovrAvatarMeshVertex2.z);
				array2[num6] = new Vector3(ovrAvatarMeshVertex2.nx, ovrAvatarMeshVertex2.ny, 0f - ovrAvatarMeshVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarMeshVertex2.tx, ovrAvatarMeshVertex2.ty, 0f - ovrAvatarMeshVertex2.tz, ovrAvatarMeshVertex2.tw);
				array4[num6] = new Vector2(ovrAvatarMeshVertex2.u, ovrAvatarMeshVertex2.v);
				array5[num6] = new Color(0f, 0f, 0f, 1f);
				array6[num6].boneIndex0 = ovrAvatarMeshVertex2.blendIndices[0];
				array6[num6].boneIndex1 = ovrAvatarMeshVertex2.blendIndices[1];
				array6[num6].boneIndex2 = ovrAvatarMeshVertex2.blendIndices[2];
				array6[num6].boneIndex3 = ovrAvatarMeshVertex2.blendIndices[3];
				array6[num6].weight0 = ovrAvatarMeshVertex2.blendWeights[0];
				array6[num6].weight1 = ovrAvatarMeshVertex2.blendWeights[1];
				array6[num6].weight2 = ovrAvatarMeshVertex2.blendWeights[2];
				array6[num6].weight3 = ovrAvatarMeshVertex2.blendWeights[3];
			}
			break;
		}
		case ovrAvatarAssetType.CombinedMesh:
		{
			long num2 = Marshal.SizeOf(typeof(ovrAvatarMeshVertexV2));
			for (long num3 = 0L; num3 < vertexCount; num3++)
			{
				long num4 = num2 * num3;
				ovrAvatarMeshVertexV2 ovrAvatarMeshVertexV3 = (ovrAvatarMeshVertexV2)Marshal.PtrToStructure(new IntPtr(num + num4), typeof(ovrAvatarMeshVertexV2));
				array[num3] = new Vector3(ovrAvatarMeshVertexV3.x, ovrAvatarMeshVertexV3.y, 0f - ovrAvatarMeshVertexV3.z);
				array2[num3] = new Vector3(ovrAvatarMeshVertexV3.nx, ovrAvatarMeshVertexV3.ny, 0f - ovrAvatarMeshVertexV3.nz);
				array3[num3] = new Vector4(ovrAvatarMeshVertexV3.tx, ovrAvatarMeshVertexV3.ty, 0f - ovrAvatarMeshVertexV3.tz, ovrAvatarMeshVertexV3.tw);
				array4[num3] = new Vector2(ovrAvatarMeshVertexV3.u, ovrAvatarMeshVertexV3.v);
				array5[num3] = new Color(ovrAvatarMeshVertexV3.r, ovrAvatarMeshVertexV3.g, ovrAvatarMeshVertexV3.b, ovrAvatarMeshVertexV3.a);
				array6[num3].boneIndex0 = ovrAvatarMeshVertexV3.blendIndices[0];
				array6[num3].boneIndex1 = ovrAvatarMeshVertexV3.blendIndices[1];
				array6[num3].boneIndex2 = ovrAvatarMeshVertexV3.blendIndices[2];
				array6[num3].boneIndex3 = ovrAvatarMeshVertexV3.blendIndices[3];
				array6[num3].weight0 = ovrAvatarMeshVertexV3.blendWeights[0];
				array6[num3].weight1 = ovrAvatarMeshVertexV3.blendWeights[1];
				array6[num3].weight2 = ovrAvatarMeshVertexV3.blendWeights[2];
				array6[num3].weight3 = ovrAvatarMeshVertexV3.blendWeights[3];
			}
			break;
		}
		default:
			throw new Exception("Bad Mesh Asset Type");
		}
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.uv = array4;
		mesh.tangents = array3;
		mesh.boneWeights = array6;
		mesh.colors = array5;
		LoadBlendShapes(asset, vertexCount);
		LoadSubmeshes(asset, indexBuffer, indexCount);
		uint jointCount = skinnedBindPose.jointCount;
		jointNames = new string[jointCount];
		for (uint num8 = 0u; num8 < jointCount; num8++)
		{
			jointNames[num8] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num8]);
		}
	}

	private void LoadSubmeshes(IntPtr asset, IntPtr indexBufferPtr, ulong indexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshCount(asset);
		short[] array = new short[indexCount];
		Marshal.Copy(indexBufferPtr, array, 0, (int)indexCount);
		mesh.subMeshCount = (int)num;
		uint num2 = 0u;
		for (uint num3 = 0u; num3 < num; num3++)
		{
			uint num4 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshLastIndex(asset, num3);
			uint num5 = num4 - num2;
			int[] array2 = new int[num5];
			int num6 = 0;
			for (ulong num7 = num2; num7 < num4; num7 += 3)
			{
				array2[num6 + 2] = array[num7];
				array2[num6 + 1] = array[num7 + 1];
				array2[num6] = array[num7 + 2];
				num6 += 3;
			}
			num2 += num5;
			mesh.SetIndices(array2, MeshTopology.Triangles, (int)num3);
		}
	}

	private void LoadBlendShapes(IntPtr asset, long vertexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeCount(asset);
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeVertices(asset);
		if (!(intPtr != IntPtr.Zero))
		{
			return;
		}
		long num2 = 0L;
		long num3 = Marshal.SizeOf(typeof(ovrAvatarBlendVertex));
		long num4 = intPtr.ToInt64();
		for (uint num5 = 0u; num5 < num; num5++)
		{
			Vector3[] array = new Vector3[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				ovrAvatarBlendVertex ovrAvatarBlendVertex2 = (ovrAvatarBlendVertex)Marshal.PtrToStructure(new IntPtr(num4 + num2), typeof(ovrAvatarBlendVertex));
				array[num6] = new Vector3(ovrAvatarBlendVertex2.x, ovrAvatarBlendVertex2.y, 0f - ovrAvatarBlendVertex2.z);
				array2[num6] = new Vector3(ovrAvatarBlendVertex2.nx, ovrAvatarBlendVertex2.ny, 0f - ovrAvatarBlendVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarBlendVertex2.tx, ovrAvatarBlendVertex2.ty, 0f - ovrAvatarBlendVertex2.tz);
				num2 += num3;
			}
			string shapeName = Marshal.PtrToStringAnsi(Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeName(asset, num5));
			mesh.AddBlendShapeFrame(shapeName, 100f, array, array2, array3);
		}
	}

	private void SetSkinnedBindPose(IntPtr asset, ovrAvatarAssetType meshType)
	{
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).skinnedBindPose;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).skinnedBindPose;
			break;
		}
	}

	private void GetVertexAndIndexData(IntPtr asset, ovrAvatarAssetType meshType, out long vertexCount, out IntPtr vertexBuffer, out uint indexCount, out IntPtr indexBuffer)
	{
		vertexCount = 0L;
		vertexBuffer = IntPtr.Zero;
		indexCount = 0u;
		indexBuffer = IntPtr.Zero;
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexBuffer;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexBuffer;
			break;
		}
	}

	public SkinnedMeshRenderer CreateSkinnedMeshRendererOnObject(GameObject target)
	{
		SkinnedMeshRenderer skinnedMeshRenderer = target.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = mesh;
		mesh.name = "AvatarMesh_" + assetID;
		uint jointCount = skinnedBindPose.jointCount;
		GameObject[] array = new GameObject[jointCount];
		Transform[] array2 = new Transform[jointCount];
		Matrix4x4[] array3 = new Matrix4x4[jointCount];
		for (uint num = 0u; num < jointCount; num++)
		{
			array[num] = new GameObject();
			array2[num] = array[num].transform;
			array[num].name = jointNames[num];
			int num2 = skinnedBindPose.jointParents[num];
			if (num2 == -1)
			{
				array[num].transform.parent = skinnedMeshRenderer.transform;
				skinnedMeshRenderer.rootBone = array[num].transform;
			}
			else
			{
				array[num].transform.parent = array[num2].transform;
			}
			Vector3 position = skinnedBindPose.jointTransform[num].position;
			position.z = 0f - position.z;
			array[num].transform.localPosition = position;
			Quaternion orientation = skinnedBindPose.jointTransform[num].orientation;
			orientation.x = 0f - orientation.x;
			orientation.y = 0f - orientation.y;
			array[num].transform.localRotation = orientation;
			array[num].transform.localScale = skinnedBindPose.jointTransform[num].scale;
			array3[num] = array[num].transform.worldToLocalMatrix * skinnedMeshRenderer.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.bones = array2;
		mesh.bindposes = array3;
		return skinnedMeshRenderer;
	}
}
public class OvrAvatarAssetTexture : OvrAvatarAsset
{
	public Texture2D texture;

	private const int ASTCHeaderSize = 16;

	public OvrAvatarAssetTexture(ulong _assetId, IntPtr asset)
	{
		assetID = _assetId;
		ovrAvatarTextureAssetData ovrAvatarTextureAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetTextureData(asset);
		IntPtr data = ovrAvatarTextureAssetData2.textureData;
		int num = (int)ovrAvatarTextureAssetData2.textureDataSize;
		TextureFormat textureFormat;
		switch (ovrAvatarTextureAssetData2.format)
		{
		case ovrAvatarTextureFormat.RGB24:
			textureFormat = TextureFormat.RGB24;
			break;
		case ovrAvatarTextureFormat.DXT1:
			textureFormat = TextureFormat.DXT1;
			break;
		case ovrAvatarTextureFormat.DXT5:
			textureFormat = TextureFormat.DXT5;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6:
			textureFormat = TextureFormat.ASTC_6x6;
			data = new IntPtr(data.ToInt64() + 16);
			num -= 16;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6_MIPMAPS:
			textureFormat = TextureFormat.ASTC_6x6;
			break;
		default:
			throw new NotImplementedException($"Unsupported texture format {ovrAvatarTextureAssetData2.format.ToString()}");
		}
		texture = new Texture2D((int)ovrAvatarTextureAssetData2.sizeX, (int)ovrAvatarTextureAssetData2.sizeY, textureFormat, ovrAvatarTextureAssetData2.mipCount > 1, (QualitySettings.activeColorSpace != 0) ? true : false)
		{
			filterMode = FilterMode.Trilinear,
			anisoLevel = 4
		};
		texture.LoadRawTextureData(data, num);
		texture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
	}
}
public class OvrAvatarBase : OvrAvatarComponent
{
	private ovrAvatarBaseComponent component;

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Base = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarBody : OvrAvatarComponent
{
	public ovrAvatarBodyComponent component;

	public ovrAvatarComponent? GetNativeAvatarComponent()
	{
		if (owner == null)
		{
			return null;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref nativeAvatarComponent);
			return nativeAvatarComponent;
		}
		return null;
	}

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Body = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarComponent : MonoBehaviour
{
	public static readonly string[] LayerKeywords = new string[9] { "LAYERS_0", "LAYERS_1", "LAYERS_2", "LAYERS_3", "LAYERS_4", "LAYERS_5", "LAYERS_6", "LAYERS_7", "LAYERS_8" };

	public static readonly string[] LayerSampleModeParameters = new string[8] { "_LayerSampleMode0", "_LayerSampleMode1", "_LayerSampleMode2", "_LayerSampleMode3", "_LayerSampleMode4", "_LayerSampleMode5", "_LayerSampleMode6", "_LayerSampleMode7" };

	public static readonly string[] LayerBlendModeParameters = new string[8] { "_LayerBlendMode0", "_LayerBlendMode1", "_LayerBlendMode2", "_LayerBlendMode3", "_LayerBlendMode4", "_LayerBlendMode5", "_LayerBlendMode6", "_LayerBlendMode7" };

	public static readonly string[] LayerMaskTypeParameters = new string[8] { "_LayerMaskType0", "_LayerMaskType1", "_LayerMaskType2", "_LayerMaskType3", "_LayerMaskType4", "_LayerMaskType5", "_LayerMaskType6", "_LayerMaskType7" };

	public static readonly string[] LayerColorParameters = new string[8] { "_LayerColor0", "_LayerColor1", "_LayerColor2", "_LayerColor3", "_LayerColor4", "_LayerColor5", "_LayerColor6", "_LayerColor7" };

	public static readonly string[] LayerSurfaceParameters = new string[8] { "_LayerSurface0", "_LayerSurface1", "_LayerSurface2", "_LayerSurface3", "_LayerSurface4", "_LayerSurface5", "_LayerSurface6", "_LayerSurface7" };

	public static readonly string[] LayerSampleParametersParameters = new string[8] { "_LayerSampleParameters0", "_LayerSampleParameters1", "_LayerSampleParameters2", "_LayerSampleParameters3", "_LayerSampleParameters4", "_LayerSampleParameters5", "_LayerSampleParameters6", "_LayerSampleParameters7" };

	public static readonly string[] LayerMaskParametersParameters = new string[8] { "_LayerMaskParameters0", "_LayerMaskParameters1", "_LayerMaskParameters2", "_LayerMaskParameters3", "_LayerMaskParameters4", "_LayerMaskParameters5", "_LayerMaskParameters6", "_LayerMaskParameters7" };

	public static readonly string[] LayerMaskAxisParameters = new string[8] { "_LayerMaskAxis0", "_LayerMaskAxis1", "_LayerMaskAxis2", "_LayerMaskAxis3", "_LayerMaskAxis4", "_LayerMaskAxis5", "_LayerMaskAxis6", "_LayerMaskAxis7" };

	private Dictionary<Material, ovrAvatarMaterialState> materialStates = new Dictionary<Material, ovrAvatarMaterialState>();

	public List<OvrAvatarRenderComponent> RenderParts = new List<OvrAvatarRenderComponent>();

	protected OvrAvatar owner;

	protected ovrAvatarComponent nativeAvatarComponent;

	public void SetOvrAvatarOwner(OvrAvatar ovrAvatarOwner)
	{
		owner = ovrAvatarOwner;
	}

	public void UpdateAvatar(IntPtr nativeComponent)
	{
		Oculus.Avatar.CAPI.ovrAvatarComponent_Get(nativeComponent, includeName: false, ref nativeAvatarComponent);
		OvrAvatar.ConvertTransform(nativeAvatarComponent.transform, base.transform);
		for (uint num = 0u; num < nativeAvatarComponent.renderPartCount && RenderParts.Count > num; num++)
		{
			OvrAvatarRenderComponent ovrAvatarRenderComponent = RenderParts[(int)num];
			IntPtr renderPart = OvrAvatar.GetRenderPart(nativeAvatarComponent, num);
			switch (Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart))
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				((OvrAvatarSkinnedMeshRenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				((OvrAvatarSkinnedMeshRenderPBSComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRenderPBS(owner, renderPart, ovrAvatarRenderComponent.mesh.sharedMaterial);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				((OvrAvatarSkinnedMeshPBSV2RenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			}
		}
	}

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	public void UpdateAvatarMaterial(Material mat, ovrAvatarMaterialState matState)
	{
		mat.SetColor("_BaseColor", matState.baseColor);
		mat.SetInt("_BaseMaskType", (int)matState.baseMaskType);
		mat.SetVector("_BaseMaskParameters", matState.baseMaskParameters);
		mat.SetVector("_BaseMaskAxis", matState.baseMaskAxis);
		if (matState.alphaMaskTextureID != 0L)
		{
			mat.SetTexture("_AlphaMask", GetLoadedTexture(matState.alphaMaskTextureID));
			mat.SetTextureScale("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.x, matState.alphaMaskScaleOffset.y));
			mat.SetTextureOffset("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.z, matState.alphaMaskScaleOffset.w));
		}
		if (matState.normalMapTextureID != 0L)
		{
			mat.EnableKeyword("NORMAL_MAP_ON");
			mat.SetTexture("_NormalMap", GetLoadedTexture(matState.normalMapTextureID));
			mat.SetTextureScale("_NormalMap", new Vector2(matState.normalMapScaleOffset.x, matState.normalMapScaleOffset.y));
			mat.SetTextureOffset("_NormalMap", new Vector2(matState.normalMapScaleOffset.z, matState.normalMapScaleOffset.w));
		}
		if (matState.parallaxMapTextureID != 0L)
		{
			mat.SetTexture("_ParallaxMap", GetLoadedTexture(matState.parallaxMapTextureID));
			mat.SetTextureScale("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.x, matState.parallaxMapScaleOffset.y));
			mat.SetTextureOffset("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.z, matState.parallaxMapScaleOffset.w));
		}
		if (matState.roughnessMapTextureID != 0L)
		{
			mat.EnableKeyword("ROUGHNESS_ON");
			mat.SetTexture("_RoughnessMap", GetLoadedTexture(matState.roughnessMapTextureID));
			mat.SetTextureScale("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.x, matState.roughnessMapScaleOffset.y));
			mat.SetTextureOffset("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.z, matState.roughnessMapScaleOffset.w));
		}
		mat.EnableKeyword(LayerKeywords[matState.layerCount]);
		for (ulong num = 0uL; num < matState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = matState.layers[num];
			mat.SetInt(LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			mat.SetInt(LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			mat.SetInt(LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			mat.SetColor(LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = LayerSurfaceParameters[num];
				mat.SetTexture(text, GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				mat.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				mat.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				mat.EnableKeyword("PARALLAX_ON");
			}
			mat.SetColor(LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			mat.SetColor(LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			mat.SetColor(LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
		materialStates[mat] = matState;
	}

	public static Texture2D GetLoadedTexture(ulong assetId)
	{
		return ((OvrAvatarAssetTexture)OvrAvatarSDKManager.Instance.GetAsset(assetId))?.texture;
	}
}
public abstract class OvrAvatarDriver : MonoBehaviour
{
	public enum PacketMode
	{
		SDK,
		Unity
	}

	public struct ControllerPose
	{
		public ovrAvatarButton buttons;

		public ovrAvatarTouch touches;

		public Vector2 joystickPosition;

		public float indexTrigger;

		public float handTrigger;

		public bool isActive;

		public static ControllerPose Interpolate(ControllerPose a, ControllerPose b, float t)
		{
			ControllerPose result = default(ControllerPose);
			result.buttons = ((t < 0.5f) ? a.buttons : b.buttons);
			result.touches = ((t < 0.5f) ? a.touches : b.touches);
			result.joystickPosition = Vector2.Lerp(a.joystickPosition, b.joystickPosition, t);
			result.indexTrigger = Mathf.Lerp(a.indexTrigger, b.indexTrigger, t);
			result.handTrigger = Mathf.Lerp(a.handTrigger, b.handTrigger, t);
			result.isActive = ((t < 0.5f) ? a.isActive : b.isActive);
			return result;
		}
	}

	public struct PoseFrame
	{
		public Vector3 headPosition;

		public Quaternion headRotation;

		public Vector3 handLeftPosition;

		public Quaternion handLeftRotation;

		public Vector3 handRightPosition;

		public Quaternion handRightRotation;

		public float voiceAmplitude;

		public ControllerPose controllerLeftPose;

		public ControllerPose controllerRightPose;

		public static PoseFrame Interpolate(PoseFrame a, PoseFrame b, float t)
		{
			PoseFrame result = default(PoseFrame);
			result.headPosition = Vector3.Lerp(a.headPosition, b.headPosition, t);
			result.headRotation = Quaternion.Slerp(a.headRotation, b.headRotation, t);
			result.handLeftPosition = Vector3.Lerp(a.handLeftPosition, b.handLeftPosition, t);
			result.handLeftRotation = Quaternion.Slerp(a.handLeftRotation, b.handLeftRotation, t);
			result.handRightPosition = Vector3.Lerp(a.handRightPosition, b.handRightPosition, t);
			result.handRightRotation = Quaternion.Slerp(a.handRightRotation, b.handRightRotation, t);
			result.voiceAmplitude = Mathf.Lerp(a.voiceAmplitude, b.voiceAmplitude, t);
			result.controllerLeftPose = ControllerPose.Interpolate(a.controllerLeftPose, b.controllerLeftPose, t);
			result.controllerRightPose = ControllerPose.Interpolate(a.controllerRightPose, b.controllerRightPose, t);
			return result;
		}
	}

	public PacketMode Mode;

	protected PoseFrame CurrentPose;

	private ovrAvatarControllerType ControllerType = ovrAvatarControllerType.Quest;

	public PoseFrame GetCurrentPose()
	{
		return CurrentPose;
	}

	public abstract void UpdateTransforms(IntPtr sdkAvatar);

	private void Start()
	{
		switch (OVRPlugin.GetSystemHeadsetType())
		{
		case OVRPlugin.SystemHeadset.Oculus_Quest:
		case OVRPlugin.SystemHeadset.Rift_S:
			ControllerType = ovrAvatarControllerType.Quest;
			break;
		default:
			ControllerType = ovrAvatarControllerType.Touch;
			break;
		}
	}

	public void UpdateTransformsFromPose(IntPtr sdkAvatar)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			ovrAvatarTransform headPose = OvrAvatar.CreateOvrAvatarTransform(CurrentPose.headPosition, CurrentPose.headRotation);
			ovrAvatarHandInputState inputStateLeft = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handLeftPosition, CurrentPose.handLeftRotation), CurrentPose.controllerLeftPose);
			ovrAvatarHandInputState inputStateRight = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handRightPosition, CurrentPose.handRightRotation), CurrentPose.controllerRightPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateBody(sdkAvatar, headPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateHandsWithType(sdkAvatar, inputStateLeft, inputStateRight, ControllerType);
		}
	}

	public static bool GetIsTrackedRemote()
	{
		return false;
	}
}
public class OvrAvatarHand : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarHandComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.HandLeft = null;
		}
		else
		{
			owner.HandRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class OvrAvatarLocalDriver : OvrAvatarDriver
{
	private Vector3 centerEyePosition = Vector3.zero;

	private Quaternion centerEyeRotation = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		OVRNodeStateProperties.GetNodeStatePropertyVector3(XRNode.CenterEye, NodeStatePropertyType.Position, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyePosition);
		OVRNodeStateProperties.GetNodeStatePropertyQuaternion(XRNode.CenterEye, NodeStatePropertyType.Orientation, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyeRotation);
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = centerEyePosition,
			headRotation = centerEyeRotation,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarMaterialManager : MonoBehaviour
{
	public enum TextureType
	{
		DiffuseTextures,
		NormalMaps,
		RoughnessMaps,
		Count
	}

	public struct AvatarComponentMaterialProperties
	{
		public ovrAvatarBodyPartType TypeIndex;

		public Color Color;

		public Texture2D[] Textures;

		public float DiffuseIntensity;

		public float RimIntensity;

		public float ReflectionIntensity;
	}

	public struct AvatarTextureArrayProperties
	{
		public Texture2D[] Textures;

		public Texture2DArray TextureArray;
	}

	public struct AvatarMaterialPropertyBlock
	{
		public Vector4[] Colors;

		public float[] DiffuseIntensities;

		public float[] RimIntensities;

		public float[] ReflectionIntensities;
	}

	[Serializable]
	public class AvatarMaterialConfig
	{
		public AvatarComponentMaterialProperties[] ComponentMaterialProperties;

		public AvatarMaterialPropertyBlock MaterialPropertyBlock;
	}

	private Renderer TargetRenderer;

	private AvatarTextureArrayProperties[] TextureArrays;

	private readonly string[] TextureTypeToShaderProperties = new string[3] { "_MainTex", "_NormalMap", "_RoughnessMap" };

	public AvatarMaterialConfig LocalAvatarConfig = new AvatarMaterialConfig();

	public List<ReflectionProbeBlendInfo> ReflectionProbes = new List<ReflectionProbeBlendInfo>();

	private Shader CombinedShader;

	public static string AVATAR_SHADER_LOADER = "OvrAvatar/Avatar_Mobile_Loader";

	public static string AVATAR_SHADER_MAINTEX = "_MainTex";

	public static string AVATAR_SHADER_NORMALMAP = "_NormalMap";

	public static string AVATAR_SHADER_ROUGHNESSMAP = "_RoughnessMap";

	public static string AVATAR_SHADER_COLOR = "_BaseColor";

	public static string AVATAR_SHADER_DIFFUSEINTENSITY = "_DiffuseIntensity";

	public static string AVATAR_SHADER_RIMINTENSITY = "_RimIntensity";

	public static string AVATAR_SHADER_REFLECTIONINTENSITY = "_ReflectionIntensity";

	public static string AVATAR_SHADER_CUBEMAP = "_Cubemap";

	public static string AVATAR_SHADER_ALPHA = "_Alpha";

	public static string AVATAR_SHADER_LOADING_DIMMER = "_LoadingDimmer";

	public static string AVATAR_SHADER_IRIS_COLOR = "_MaskColorIris";

	public static string AVATAR_SHADER_LIP_COLOR = "_MaskColorLips";

	public static string AVATAR_SHADER_BROW_COLOR = "_MaskColorBrows";

	public static string AVATAR_SHADER_LASH_COLOR = "_MaskColorLashes";

	public static string AVATAR_SHADER_SCLERA_COLOR = "_MaskColorSclera";

	public static string AVATAR_SHADER_GUM_COLOR = "_MaskColorGums";

	public static string AVATAR_SHADER_TEETH_COLOR = "_MaskColorTeeth";

	public static string AVATAR_SHADER_LIP_SMOOTHNESS = "_LipSmoothness";

	public static float[] DiffuseIntensities = new float[5] { 0.3f, 0.1f, 0f, 0.15f, 0.15f };

	public static float[] RimIntensities = new float[5] { 5f, 2f, 2.84f, 4f, 4f };

	public static float[] ReflectionIntensities = new float[5] { 0f, 0.3f, 0.4f, 0f, 0f };

	private const float LOADING_ANIMATION_AMPLITUDE = 0.5f;

	private const float LOADING_ANIMATION_PERIOD = 0.35f;

	private const float LOADING_ANIMATION_CURVE_SCALE = 0.25f;

	private const float LOADING_ANIMATION_DIMMER_MIN = 0.3f;

	public void CreateTextureArrays()
	{
		LocalAvatarConfig.ComponentMaterialProperties = new AvatarComponentMaterialProperties[5];
		LocalAvatarConfig.MaterialPropertyBlock.Colors = new Vector4[5];
		LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.RimIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities = new float[5];
		for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
		{
			LocalAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
		}
		TextureArrays = new AvatarTextureArrayProperties[3];
	}

	public void SetRenderer(Renderer renderer)
	{
		TargetRenderer = renderer;
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
	}

	public void OnCombinedMeshReady()
	{
		InitTextureArrays();
		SetMaterialPropertyBlock();
		StartCoroutine(RunLoadingAnimation(DeleteTextureSet));
	}

	public void AddTextureIDToTextureManager(ulong assetID, bool isSingleComponent)
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().AddTextureIDToTextureSet(GetInstanceID(), assetID, isSingleComponent);
	}

	private void DeleteTextureSet()
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().DeleteTextureSet(GetInstanceID());
	}

	public void InitTextureArrays()
	{
		AvatarComponentMaterialProperties avatarComponentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties[0];
		for (int i = 0; i < TextureArrays.Length && i < avatarComponentMaterialProperties.Textures.Length; i++)
		{
			TextureArrays[i].TextureArray = new Texture2DArray(avatarComponentMaterialProperties.Textures[0].height, avatarComponentMaterialProperties.Textures[0].width, LocalAvatarConfig.ComponentMaterialProperties.Length, avatarComponentMaterialProperties.Textures[0].format, mipChain: true, (QualitySettings.activeColorSpace != 0) ? true : false)
			{
				filterMode = FilterMode.Trilinear,
				anisoLevel = ((i == 2) ? 16 : 4)
			};
			TextureArrays[i].TextureArray.name = $"Texture Array Type: {(TextureType)i}";
			TextureArrays[i].Textures = new Texture2D[LocalAvatarConfig.ComponentMaterialProperties.Length];
			for (int j = 0; j < LocalAvatarConfig.ComponentMaterialProperties.Length; j++)
			{
				TextureArrays[i].Textures[j] = LocalAvatarConfig.ComponentMaterialProperties[j].Textures[i];
				TextureArrays[i].Textures[j].name = $"Texture Type: {(TextureType)i} Component: {j}";
			}
			ProcessTexturesWithMips(TextureArrays[i].Textures, avatarComponentMaterialProperties.Textures[i].height, TextureArrays[i].TextureArray);
		}
	}

	private void ProcessTexturesWithMips(Texture2D[] textures, int texArrayResolution, Texture2DArray texArray)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			int num = texArrayResolution;
			for (int num2 = textures[i].mipmapCount - 1; num2 >= 0; num2--)
			{
				int mipSize = texArrayResolution / num;
				OvrAvatarSDKManager.Instance.GetTextureCopyManager().CopyTexture(textures[i], texArray, num2, mipSize, i, useQueue: false);
				num /= 2;
			}
		}
	}

	private void SetMaterialPropertyBlock()
	{
		if (TargetRenderer != null)
		{
			for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
			{
				LocalAvatarConfig.MaterialPropertyBlock.Colors[i] = LocalAvatarConfig.ComponentMaterialProperties[i].Color;
				LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities[i] = DiffuseIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.RimIntensities[i] = RimIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities[i] = ReflectionIntensities[i];
			}
		}
	}

	private void ApplyMaterialPropertyBlock()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetVectorArray(AVATAR_SHADER_COLOR, LocalAvatarConfig.MaterialPropertyBlock.Colors);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_DIFFUSEINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_RIMINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.RimIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_REFLECTIONINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities);
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
		if (ReflectionProbes != null && ReflectionProbes.Count > 0 && ReflectionProbes[0].probe.texture != null)
		{
			materialPropertyBlock.SetTexture(AVATAR_SHADER_CUBEMAP, ReflectionProbes[0].probe.texture);
		}
		for (int i = 0; i < TextureArrays.Length; i++)
		{
			materialPropertyBlock.SetTexture(TextureTypeToShaderProperties[i], TextureArrays[i].TextureArray);
		}
		TargetRenderer.SetPropertyBlock(materialPropertyBlock);
	}

	public static ovrAvatarBodyPartType GetComponentType(string objectName)
	{
		if (objectName.Contains("0"))
		{
			return ovrAvatarBodyPartType.Body;
		}
		if (objectName.Contains("1"))
		{
			return ovrAvatarBodyPartType.Clothing;
		}
		if (objectName.Contains("2"))
		{
			return ovrAvatarBodyPartType.Eyewear;
		}
		if (objectName.Contains("3"))
		{
			return ovrAvatarBodyPartType.Hair;
		}
		if (objectName.Contains("4"))
		{
			return ovrAvatarBodyPartType.Beard;
		}
		return ovrAvatarBodyPartType.Count;
	}

	private ulong GetTextureIDForType(ovrAvatarPBSMaterialState materialState, TextureType type)
	{
		return type switch
		{
			TextureType.DiffuseTextures => materialState.albedoTextureID, 
			TextureType.NormalMaps => materialState.normalTextureID, 
			TextureType.RoughnessMaps => materialState.metallicnessTextureID, 
			_ => 0uL, 
		};
	}

	public void ValidateTextures(ovrAvatarPBSMaterialState[] materialStates)
	{
		AvatarComponentMaterialProperties[] componentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties;
		int[] array = new int[3];
		TextureFormat[] array2 = new TextureFormat[3];
		for (int i = 0; i < componentMaterialProperties.Length; i++)
		{
			for (int j = 0; j < componentMaterialProperties[i].Textures.Length; j++)
			{
				if (componentMaterialProperties[i].Textures[j] == null)
				{
					string text = componentMaterialProperties[i].TypeIndex.ToString();
					TextureType textureType = (TextureType)j;
					throw new Exception(text + "Invalid: " + textureType);
				}
				array[j] = componentMaterialProperties[i].Textures[j].height;
				array2[j] = componentMaterialProperties[i].Textures[j].format;
			}
		}
		for (int k = 0; k < 3; k++)
		{
			for (int l = 1; l < componentMaterialProperties.Length; l++)
			{
				if (componentMaterialProperties[l - 1].Textures[k].height != componentMaterialProperties[l].Textures[k].height)
				{
					object[] obj = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Resolutions: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj[2] = textureType.ToString();
					obj[3] = " ";
					obj[4] = componentMaterialProperties[l - 1].Textures[k].height;
					obj[5] = " (ID: ";
					obj[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj[7] = ") vs ";
					obj[8] = componentMaterialProperties[l].Textures[k].height;
					obj[9] = " (ID: ";
					obj[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj));
				}
				if (componentMaterialProperties[l - 1].Textures[k].format != componentMaterialProperties[l].Textures[k].format)
				{
					object[] obj2 = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Formats: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj2[2] = textureType.ToString();
					obj2[3] = " ";
					obj2[4] = componentMaterialProperties[l - 1].Textures[k].format;
					obj2[5] = " (ID: ";
					obj2[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj2[7] = ") vs ";
					obj2[8] = componentMaterialProperties[l].Textures[k].format;
					obj2[9] = " (ID: ";
					obj2[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj2[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj2));
				}
			}
		}
	}

	private IEnumerator RunLoadingAnimation(Action callBack)
	{
		CombinedShader = TargetRenderer.sharedMaterial.shader;
		int srcBlend = TargetRenderer.sharedMaterial.GetInt("_SrcBlend");
		int dstBlend = TargetRenderer.sharedMaterial.GetInt("_DstBlend");
		string lightModeTag = TargetRenderer.sharedMaterial.GetTag("LightMode", searchFallbacks: false);
		string renderTypeTag = TargetRenderer.sharedMaterial.GetTag("RenderType", searchFallbacks: false);
		string renderQueueTag = TargetRenderer.sharedMaterial.GetTag("Queue", searchFallbacks: false);
		string ignoreProjectorTag = TargetRenderer.sharedMaterial.GetTag("IgnoreProjector", searchFallbacks: false);
		int renderQueue = TargetRenderer.sharedMaterial.renderQueue;
		bool transparentQueue = TargetRenderer.sharedMaterial.IsKeywordEnabled("_ALPHATEST_ON");
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_LOADER);
		TargetRenderer.sharedMaterial.SetColor(AVATAR_SHADER_COLOR, Color.white);
		while (OvrAvatarSDKManager.Instance.GetTextureCopyManager().GetTextureCount() > 0)
		{
			float value = (0.5f * Mathf.Sin(Time.timeSinceLevelLoad / 0.35f) + 0.5f) * 0.25f + 0.3f;
			TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, value);
			yield return null;
		}
		TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, 1f);
		TargetRenderer.sharedMaterial.shader = CombinedShader;
		TargetRenderer.sharedMaterial.SetInt("_SrcBlend", srcBlend);
		TargetRenderer.sharedMaterial.SetInt("_DstBlend", dstBlend);
		TargetRenderer.sharedMaterial.SetOverrideTag("LightMode", lightModeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("RenderType", renderTypeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("Queue", renderQueueTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("IgnoreProjector", ignoreProjectorTag);
		if (transparentQueue)
		{
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		else
		{
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		TargetRenderer.sharedMaterial.renderQueue = renderQueue;
		ApplyMaterialPropertyBlock();
		callBack?.Invoke();
	}
}
public class OvrAvatarPacket
{
	public IntPtr ovrNativePacket = IntPtr.Zero;

	private List<float> frameTimes = new List<float>();

	private List<OvrAvatarDriver.PoseFrame> frames = new List<OvrAvatarDriver.PoseFrame>();

	private List<byte[]> encodedAudioPackets = new List<byte[]>();

	public float Duration => frameTimes[frameTimes.Count - 1];

	public OvrAvatarDriver.PoseFrame FinalFrame => frames[frames.Count - 1];

	public OvrAvatarPacket()
	{
	}

	public OvrAvatarPacket(OvrAvatarDriver.PoseFrame initialPose)
	{
		frameTimes.Add(0f);
		frames.Add(initialPose);
	}

	private OvrAvatarPacket(List<float> frameTimes, List<OvrAvatarDriver.PoseFrame> frames, List<byte[]> audioPackets)
	{
		this.frameTimes = frameTimes;
		this.frames = frames;
	}

	public void AddFrame(OvrAvatarDriver.PoseFrame frame, float deltaSeconds)
	{
		frameTimes.Add(Duration + deltaSeconds);
		frames.Add(frame);
	}

	public OvrAvatarDriver.PoseFrame GetPoseFrame(float seconds)
	{
		if (frames.Count == 1)
		{
			return frames[0];
		}
		int i;
		for (i = 1; i < frameTimes.Count && frameTimes[i] < seconds; i++)
		{
		}
		OvrAvatarDriver.PoseFrame a = frames[i - 1];
		OvrAvatarDriver.PoseFrame b = frames[i];
		float num = frameTimes[i - 1];
		float num2 = frameTimes[i];
		float t = (seconds - num) / (num2 - num);
		return OvrAvatarDriver.PoseFrame.Interpolate(a, b, t);
	}

	public static OvrAvatarPacket Read(Stream stream)
	{
		BinaryReader binaryReader = new BinaryReader(stream);
		int num = binaryReader.ReadInt32();
		List<float> list = new List<float>(num);
		for (int i = 0; i < num; i++)
		{
			list.Add(binaryReader.ReadSingle());
		}
		List<OvrAvatarDriver.PoseFrame> list2 = new List<OvrAvatarDriver.PoseFrame>(num);
		for (int j = 0; j < num; j++)
		{
			list2.Add(binaryReader.ReadPoseFrame());
		}
		int num2 = binaryReader.ReadInt32();
		List<byte[]> list3 = new List<byte[]>(num2);
		for (int k = 0; k < num2; k++)
		{
			int count = binaryReader.ReadInt32();
			byte[] item = binaryReader.ReadBytes(count);
			list3.Add(item);
		}
		return new OvrAvatarPacket(list, list2, list3);
	}

	public void Write(Stream stream)
	{
		BinaryWriter binaryWriter = new BinaryWriter(stream);
		int count = frameTimes.Count;
		binaryWriter.Write(count);
		for (int i = 0; i < count; i++)
		{
			binaryWriter.Write(frameTimes[i]);
		}
		for (int j = 0; j < count; j++)
		{
			OvrAvatarDriver.PoseFrame frame = frames[j];
			binaryWriter.Write(frame);
		}
		int count2 = encodedAudioPackets.Count;
		binaryWriter.Write(count2);
		for (int k = 0; k < count2; k++)
		{
			byte[] array = encodedAudioPackets[k];
			binaryWriter.Write(array.Length);
			binaryWriter.Write(array);
		}
	}
}
internal static class BinaryWriterExtensions
{
	public static void Write(this BinaryWriter writer, OvrAvatarDriver.PoseFrame frame)
	{
		writer.Write(frame.headPosition);
		writer.Write(frame.headRotation);
		writer.Write(frame.handLeftPosition);
		writer.Write(frame.handLeftRotation);
		writer.Write(frame.handRightPosition);
		writer.Write(frame.handRightRotation);
		writer.Write(frame.voiceAmplitude);
		writer.Write(frame.controllerLeftPose);
		writer.Write(frame.controllerRightPose);
	}

	public static void Write(this BinaryWriter writer, Vector3 vec3)
	{
		writer.Write(vec3.x);
		writer.Write(vec3.y);
		writer.Write(vec3.z);
	}

	public static void Write(this BinaryWriter writer, Vector2 vec2)
	{
		writer.Write(vec2.x);
		writer.Write(vec2.y);
	}

	public static void Write(this BinaryWriter writer, Quaternion quat)
	{
		writer.Write(quat.x);
		writer.Write(quat.y);
		writer.Write(quat.z);
		writer.Write(quat.w);
	}

	public static void Write(this BinaryWriter writer, OvrAvatarDriver.ControllerPose pose)
	{
		writer.Write((uint)pose.buttons);
		writer.Write((uint)pose.touches);
		writer.Write(pose.joystickPosition);
		writer.Write(pose.indexTrigger);
		writer.Write(pose.handTrigger);
		writer.Write(pose.isActive);
	}
}
internal static class BinaryReaderExtensions
{
	public static OvrAvatarDriver.PoseFrame ReadPoseFrame(this BinaryReader reader)
	{
		OvrAvatarDriver.PoseFrame result = default(OvrAvatarDriver.PoseFrame);
		result.headPosition = reader.ReadVector3();
		result.headRotation = reader.ReadQuaternion();
		result.handLeftPosition = reader.ReadVector3();
		result.handLeftRotation = reader.ReadQuaternion();
		result.handRightPosition = reader.ReadVector3();
		result.handRightRotation = reader.ReadQuaternion();
		result.voiceAmplitude = reader.ReadSingle();
		result.controllerLeftPose = reader.ReadControllerPose();
		result.controllerRightPose = reader.ReadControllerPose();
		return result;
	}

	public static Vector2 ReadVector2(this BinaryReader reader)
	{
		Vector2 result = default(Vector2);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		return result;
	}

	public static Vector3 ReadVector3(this BinaryReader reader)
	{
		Vector3 result = default(Vector3);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		return result;
	}

	public static Quaternion ReadQuaternion(this BinaryReader reader)
	{
		Quaternion result = default(Quaternion);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		result.w = reader.ReadSingle();
		return result;
	}

	public static OvrAvatarDriver.ControllerPose ReadControllerPose(this BinaryReader reader)
	{
		OvrAvatarDriver.ControllerPose result = default(OvrAvatarDriver.ControllerPose);
		result.buttons = (ovrAvatarButton)reader.ReadUInt32();
		result.touches = (ovrAvatarTouch)reader.ReadUInt32();
		result.joystickPosition = reader.ReadVector2();
		result.indexTrigger = reader.ReadSingle();
		result.handTrigger = reader.ReadSingle();
		result.isActive = reader.ReadBoolean();
		return result;
	}
}
public class OvrAvatarRemoteDriver : OvrAvatarDriver
{
	private Queue<OvrAvatarPacket> packetQueue = new Queue<OvrAvatarPacket>();

	private IntPtr CurrentSDKPacket = IntPtr.Zero;

	private float CurrentPacketTime;

	private const int MinPacketQueue = 1;

	private const int MaxPacketQueue = 4;

	private int CurrentSequence = -1;

	private bool isStreaming;

	private OvrAvatarPacket currentPacket;

	public void QueuePacket(int sequence, OvrAvatarPacket packet)
	{
		if (sequence > CurrentSequence)
		{
			CurrentSequence = sequence;
			packetQueue.Enqueue(packet);
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		switch (Mode)
		{
		case PacketMode.SDK:
			UpdateFromSDKPacket(sdkAvatar);
			break;
		case PacketMode.Unity:
			UpdateFromUnityPacket(sdkAvatar);
			break;
		}
	}

	private void UpdateFromSDKPacket(IntPtr sdkAvatar)
	{
		if (CurrentSDKPacket == IntPtr.Zero && packetQueue.Count >= 1)
		{
			CurrentSDKPacket = packetQueue.Dequeue().ovrNativePacket;
		}
		if (!(CurrentSDKPacket != IntPtr.Zero))
		{
			return;
		}
		float num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetDurationSeconds(CurrentSDKPacket);
		Oculus.Avatar.CAPI.ovrAvatar_UpdatePoseFromPacket(sdkAvatar, CurrentSDKPacket, Mathf.Min(num, CurrentPacketTime));
		CurrentPacketTime += Time.deltaTime;
		if (CurrentPacketTime > num)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(CurrentSDKPacket);
			CurrentSDKPacket = IntPtr.Zero;
			CurrentPacketTime -= num;
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
		}
	}

	private void UpdateFromUnityPacket(IntPtr sdkAvatar)
	{
		if (!isStreaming && packetQueue.Count > 1)
		{
			currentPacket = packetQueue.Dequeue();
			isStreaming = true;
		}
		if (!isStreaming)
		{
			return;
		}
		CurrentPacketTime += Time.deltaTime;
		while (CurrentPacketTime > currentPacket.Duration)
		{
			if (packetQueue.Count == 0)
			{
				CurrentPose = currentPacket.FinalFrame;
				CurrentPacketTime = 0f;
				currentPacket = null;
				isStreaming = false;
				return;
			}
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
			CurrentPacketTime -= currentPacket.Duration;
			currentPacket = packetQueue.Dequeue();
		}
		CurrentPose = currentPacket.GetPoseFrame(CurrentPacketTime);
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarRenderComponent : MonoBehaviour
{
	private bool firstSkinnedUpdate = true;

	public SkinnedMeshRenderer mesh;

	public Transform[] bones;

	private bool isBodyComponent;

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		if (isBodyComponent && avatar.EnableExpressive && avatar.ShowFirstPerson && !avatar.ShowThirdPerson)
		{
			bool num = (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			bool flag = (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag || flag);
			if (!num)
			{
				mesh.enabled = false;
			}
		}
		else
		{
			bool flag2 = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			flag2 |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag2);
			mesh.enabled = flag2;
		}
	}

	protected SkinnedMeshRenderer CreateSkinnedMesh(ulong assetID, ovrAvatarVisibilityFlags visibilityMask, int thirdPersonLayer, int firstPersonLayer)
	{
		isBodyComponent = base.name.Contains("body");
		OvrAvatarAssetMesh obj = ((OvrAvatarAssetMesh)OvrAvatarSDKManager.Instance.GetAsset(assetID)) ?? throw new Exception("Couldn't find mesh for asset " + assetID);
		if ((visibilityMask & ovrAvatarVisibilityFlags.ThirdPerson) != 0)
		{
			base.gameObject.layer = thirdPersonLayer;
		}
		else
		{
			base.gameObject.layer = firstPersonLayer;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = obj.CreateSkinnedMeshRendererOnObject(base.gameObject);
		skinnedMeshRenderer.quality = SkinQuality.Bone2;
		skinnedMeshRenderer.updateWhenOffscreen = true;
		if ((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0)
		{
			skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		}
		base.gameObject.SetActive(value: false);
		return skinnedMeshRenderer;
	}

	protected void UpdateSkinnedMesh(OvrAvatar avatar, Transform[] bones, ovrAvatarTransform localTransform, ovrAvatarVisibilityFlags visibilityMask, IntPtr renderPart)
	{
		UpdateActive(avatar, visibilityMask);
		OvrAvatar.ConvertTransform(localTransform, base.transform);
		ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
		ulong num = ovrAvatarRenderPartType2 switch
		{
			ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(renderPart), 
			_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
		};
		for (uint num2 = 0u; num2 < 64; num2++)
		{
			ulong num3 = (ulong)(1L << (int)num2);
			if ((firstSkinnedUpdate && num2 < bones.Length) || (num3 & num) != 0L)
			{
				Transform target = bones[num2];
				OvrAvatar.ConvertTransform(ovrAvatarRenderPartType2 switch
				{
					ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(renderPart, num2), 
					_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
				}, target);
			}
		}
		firstSkinnedUpdate = false;
	}

	protected Material CreateAvatarMaterial(string name, Shader shader)
	{
		if (shader == null)
		{
			throw new Exception("No shader provided for avatar material.");
		}
		return new Material(shader)
		{
			name = name
		};
	}
}
[Flags]
public enum ovrAvatarCapabilities
{
	Body = 1,
	Hands = 2,
	Base = 4,
	BodyTilt = 0x10,
	Expressive = 0x20,
	All = -1
}
public enum ovrAvatarMessageType
{
	AvatarSpecification,
	AssetLoaded,
	Count
}
public struct ovrAvatarMessage_AvatarSpecification
{
	public IntPtr avatarSpec;

	public ulong oculusUserID;
}
public struct ovrAvatarMessage_AssetLoaded
{
	public ulong assetID;

	public IntPtr asset;
}
public enum ovrAvatarAssetType
{
	Mesh,
	Texture,
	Pose,
	Material,
	CombinedMesh,
	PBSMaterial,
	FailedLoad,
	Count
}
public struct ovrAvatarMeshVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshVertexV2
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	public float r;

	public float g;

	public float b;

	public float a;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarBlendVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;
}
public struct ovrAvatarMeshAssetData
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public struct ovrAvatarMeshAssetDataV2
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public enum ovrAvatarTextureFormat
{
	RGB24,
	DXT1,
	DXT5,
	ASTC_RGB_6x6,
	ASTC_RGB_6x6_MIPMAPS,
	Count
}
public struct ovrAvatarTextureAssetData
{
	public ovrAvatarTextureFormat format;

	public uint sizeX;

	public uint sizeY;

	public uint mipCount;

	public ulong textureDataSize;

	public IntPtr textureData;
}
public enum ovrAvatarRenderPartType
{
	SkinnedMeshRender,
	SkinnedMeshRenderPBS,
	ProjectorRender,
	SkinnedMeshRenderPBS_V2,
	Count
}
public enum ovrAvatarLogLevel
{
	Unknown,
	Default,
	Verbose,
	Debug,
	Info,
	Warn,
	Error,
	Fatal,
	Silent
}
public struct ovrAvatarTransform
{
	public Vector3 position;

	public Quaternion orientation;

	public Vector3 scale;
}
[Flags]
public enum ovrAvatarButton
{
	One = 1,
	Two = 2,
	Three = 4,
	Joystick = 8
}
[Flags]
public enum ovrAvatarTouch
{
	One = 1,
	Two = 2,
	Joystick = 4,
	ThumbRest = 8,
	Index = 0x10,
	Pointing = 0x40,
	ThumbUp = 0x80
}
public struct ovrAvatarHandInputState
{
	public ovrAvatarTransform transform;

	public ovrAvatarButton buttonMask;

	public ovrAvatarTouch touchMask;

	public float joystickX;

	public float joystickY;

	public float indexTrigger;

	public float handTrigger;

	[MarshalAs(UnmanagedType.I1)]
	public bool isActive;
}
public struct ovrAvatarComponent
{
	public ovrAvatarTransform transform;

	public uint renderPartCount;

	public IntPtr renderParts;

	[MarshalAs(UnmanagedType.LPStr)]
	public string name;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarComponent_Offsets
{
	public static long transform = Marshal.OffsetOf(typeof(ovrAvatarComponent), "transform").ToInt64();

	public static int renderPartCount = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderPartCount").ToInt32();

	public static int renderParts = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderParts").ToInt32();

	public static int name = Marshal.OffsetOf(typeof(ovrAvatarComponent), "name").ToInt32();
}
public struct ovrAvatarBaseComponent
{
	public Vector3 basePosition;

	public IntPtr renderComponent;
}
public struct ovrAvatarBodyComponent
{
	public ovrAvatarTransform leftEyeTransform;

	public ovrAvatarTransform rightEyeTransform;

	public ovrAvatarTransform centerEyeTransform;

	public IntPtr renderComponent;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct ovrAvatarBodyComponent_Offsets
{
	public static long leftEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "leftEyeTransform").ToInt64();

	public static long rightEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "rightEyeTransform").ToInt64();

	public static long centerEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "centerEyeTransform").ToInt64();

	public static long renderComponent = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "renderComponent").ToInt64();
}
public struct ovrAvatarControllerComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public struct ovrAvatarHandComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public enum ovrAvatarMaterialLayerBlendMode
{
	Add,
	Multiply,
	Count
}
public enum ovrAvatarMaterialLayerSampleMode
{
	Color,
	Texture,
	TextureSingleChannel,
	Parallax,
	Count
}
public enum ovrAvatarMaterialMaskType
{
	None,
	Positional,
	ViewReflection,
	Fresnel,
	Pulse,
	Count
}
public enum ovrAvatarControllerType
{
	Touch,
	Malibu,
	Go,
	Quest,
	Count
}
public enum ovrAvatarAssetLevelOfDetail
{
	Lowest = 1,
	Medium = 3,
	Highest = 5
}
public enum ovrAvatarLookAndFeelVersion
{
	Unknown = -1,
	One,
	Two
}
public struct ovrAvatarMaterialLayerState
{
	public ovrAvatarMaterialLayerBlendMode blendMode;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ovrAvatarMaterialMaskType maskType;

	public Vector4 layerColor;

	public Vector4 sampleParameters;

	public ulong sampleTexture;

	public Vector4 sampleScaleOffset;

	public Vector4 maskParameters;

	public Vector4 maskAxis;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2))
		{
			return false;
		}
		if (blendMode != ovrAvatarMaterialLayerState2.blendMode)
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialLayerState2.sampleMode)
		{
			return false;
		}
		if (maskType != ovrAvatarMaterialLayerState2.maskType)
		{
			return false;
		}
		if (!VectorEquals(layerColor, ovrAvatarMaterialLayerState2.layerColor))
		{
			return false;
		}
		if (!VectorEquals(sampleParameters, ovrAvatarMaterialLayerState2.sampleParameters))
		{
			return false;
		}
		if (sampleTexture != ovrAvatarMaterialLayerState2.sampleTexture)
		{
			return false;
		}
		if (!VectorEquals(sampleScaleOffset, ovrAvatarMaterialLayerState2.sampleScaleOffset))
		{
			return false;
		}
		if (!VectorEquals(maskParameters, ovrAvatarMaterialLayerState2.maskParameters))
		{
			return false;
		}
		if (!VectorEquals(maskAxis, ovrAvatarMaterialLayerState2.maskAxis))
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return blendMode.GetHashCode() ^ sampleMode.GetHashCode() ^ maskType.GetHashCode() ^ layerColor.GetHashCode() ^ sampleParameters.GetHashCode() ^ sampleTexture.GetHashCode() ^ sampleScaleOffset.GetHashCode() ^ maskParameters.GetHashCode() ^ maskAxis.GetHashCode();
	}
}
public struct ovrAvatarMaterialState
{
	public Vector4 baseColor;

	public ovrAvatarMaterialMaskType baseMaskType;

	public Vector4 baseMaskParameters;

	public Vector4 baseMaskAxis;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ulong alphaMaskTextureID;

	public Vector4 alphaMaskScaleOffset;

	public ulong normalMapTextureID;

	public Vector4 normalMapScaleOffset;

	public ulong parallaxMapTextureID;

	public Vector4 parallaxMapScaleOffset;

	public ulong roughnessMapTextureID;

	public Vector4 roughnessMapScaleOffset;

	public uint layerCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
	public ovrAvatarMaterialLayerState[] layers;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialState ovrAvatarMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarMaterialState2.baseColor))
		{
			return false;
		}
		if (baseMaskType != ovrAvatarMaterialState2.baseMaskType)
		{
			return false;
		}
		if (!VectorEquals(baseMaskParameters, ovrAvatarMaterialState2.baseMaskParameters))
		{
			return false;
		}
		if (!VectorEquals(baseMaskAxis, ovrAvatarMaterialState2.baseMaskAxis))
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialState2.sampleMode)
		{
			return false;
		}
		if (alphaMaskTextureID != ovrAvatarMaterialState2.alphaMaskTextureID)
		{
			return false;
		}
		if (!VectorEquals(alphaMaskScaleOffset, ovrAvatarMaterialState2.alphaMaskScaleOffset))
		{
			return false;
		}
		if (normalMapTextureID != ovrAvatarMaterialState2.normalMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(normalMapScaleOffset, ovrAvatarMaterialState2.normalMapScaleOffset))
		{
			return false;
		}
		if (parallaxMapTextureID != ovrAvatarMaterialState2.parallaxMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(parallaxMapScaleOffset, ovrAvatarMaterialState2.parallaxMapScaleOffset))
		{
			return false;
		}
		if (roughnessMapTextureID != ovrAvatarMaterialState2.roughnessMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(roughnessMapScaleOffset, ovrAvatarMaterialState2.roughnessMapScaleOffset))
		{
			return false;
		}
		if (layerCount != ovrAvatarMaterialState2.layerCount)
		{
			return false;
		}
		for (int i = 0; i < layerCount; i++)
		{
			if (!layers[i].Equals(ovrAvatarMaterialState2.layers[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode()
	{
		int num = 0;
		num ^= baseColor.GetHashCode();
		num ^= baseMaskType.GetHashCode();
		num ^= baseMaskParameters.GetHashCode();
		num ^= baseMaskAxis.GetHashCode();
		num ^= sampleMode.GetHashCode();
		num ^= alphaMaskTextureID.GetHashCode();
		num ^= alphaMaskScaleOffset.GetHashCode();
		num ^= normalMapTextureID.GetHashCode();
		num ^= normalMapScaleOffset.GetHashCode();
		num ^= parallaxMapTextureID.GetHashCode();
		num ^= parallaxMapScaleOffset.GetHashCode();
		num ^= roughnessMapTextureID.GetHashCode();
		num ^= roughnessMapScaleOffset.GetHashCode();
		num ^= layerCount.GetHashCode();
		for (int i = 0; i < layerCount; i++)
		{
			num ^= layers[i].GetHashCode();
		}
		return num;
	}
}
public struct ovrAvatarExpressiveParameters
{
	public Vector4 irisColor;

	public Vector4 scleraColor;

	public Vector4 lashColor;

	public Vector4 browColor;

	public Vector4 lipColor;

	public Vector4 teethColor;

	public Vector4 gumColor;

	public float browLashIntensity;

	public float lipSmoothness;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarExpressiveParameters ovrAvatarExpressiveParameters2))
		{
			return false;
		}
		if (!VectorEquals(irisColor, ovrAvatarExpressiveParameters2.irisColor))
		{
			return false;
		}
		if (!VectorEquals(scleraColor, ovrAvatarExpressiveParameters2.scleraColor))
		{
			return false;
		}
		if (!VectorEquals(lashColor, ovrAvatarExpressiveParameters2.lashColor))
		{
			return false;
		}
		if (!VectorEquals(browColor, ovrAvatarExpressiveParameters2.browColor))
		{
			return false;
		}
		if (!VectorEquals(lipColor, ovrAvatarExpressiveParameters2.lipColor))
		{
			return false;
		}
		if (!VectorEquals(teethColor, ovrAvatarExpressiveParameters2.teethColor))
		{
			return false;
		}
		if (!VectorEquals(gumColor, ovrAvatarExpressiveParameters2.gumColor))
		{
			return false;
		}
		if (browLashIntensity != ovrAvatarExpressiveParameters2.browLashIntensity)
		{
			return false;
		}
		if (lipSmoothness != ovrAvatarExpressiveParameters2.lipSmoothness)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return irisColor.GetHashCode() ^ scleraColor.GetHashCode() ^ lashColor.GetHashCode() ^ browColor.GetHashCode() ^ lipColor.GetHashCode() ^ teethColor.GetHashCode() ^ gumColor.GetHashCode() ^ browLashIntensity.GetHashCode() ^ lipSmoothness.GetHashCode();
	}
}
public struct ovrAvatarPBSMaterialState
{
	public Vector4 baseColor;

	public ulong albedoTextureID;

	public Vector4 albedoMultiplier;

	public ulong metallicnessTextureID;

	public float glossinessScale;

	public ulong normalTextureID;

	public ulong heightTextureID;

	public ulong occlusionTextureID;

	public ulong emissionTextureID;

	public Vector4 emissionMultiplier;

	public ulong detailMaskTextureID;

	public ulong detailAlbedoTextureID;

	public ulong detailNormalTextureID;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarPBSMaterialState2.baseColor))
		{
			return false;
		}
		if (albedoTextureID != ovrAvatarPBSMaterialState2.albedoTextureID)
		{
			return false;
		}
		if (!VectorEquals(albedoMultiplier, ovrAvatarPBSMaterialState2.albedoMultiplier))
		{
			return false;
		}
		if (metallicnessTextureID != ovrAvatarPBSMaterialState2.metallicnessTextureID)
		{
			return false;
		}
		if (glossinessScale != ovrAvatarPBSMaterialState2.glossinessScale)
		{
			return false;
		}
		if (normalTextureID != ovrAvatarPBSMaterialState2.normalTextureID)
		{
			return false;
		}
		if (heightTextureID != ovrAvatarPBSMaterialState2.heightTextureID)
		{
			return false;
		}
		if (occlusionTextureID != ovrAvatarPBSMaterialState2.occlusionTextureID)
		{
			return false;
		}
		if (emissionTextureID != ovrAvatarPBSMaterialState2.emissionTextureID)
		{
			return false;
		}
		if (!VectorEquals(emissionMultiplier, ovrAvatarPBSMaterialState2.emissionMultiplier))
		{
			return false;
		}
		if (detailMaskTextureID != ovrAvatarPBSMaterialState2.detailMaskTextureID)
		{
			return false;
		}
		if (detailAlbedoTextureID != ovrAvatarPBSMaterialState2.detailAlbedoTextureID)
		{
			return false;
		}
		if (detailNormalTextureID != ovrAvatarPBSMaterialState2.detailNormalTextureID)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return baseColor.GetHashCode() ^ albedoTextureID.GetHashCode() ^ albedoMultiplier.GetHashCode() ^ metallicnessTextureID.GetHashCode() ^ glossinessScale.GetHashCode() ^ normalTextureID.GetHashCode() ^ heightTextureID.GetHashCode() ^ occlusionTextureID.GetHashCode() ^ emissionTextureID.GetHashCode() ^ emissionMultiplier.GetHashCode() ^ detailMaskTextureID.GetHashCode() ^ detailAlbedoTextureID.GetHashCode() ^ detailNormalTextureID.GetHashCode();
	}
}
public class OvrAvatarAssetMaterial : OvrAvatarAsset
{
	public ovrAvatarMaterialState material;

	public OvrAvatarAssetMaterial(ulong id, IntPtr mat)
	{
		assetID = id;
		material = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMaterialState(mat);
	}
}
public struct ovrAvatarSkinnedMeshPose
{
	public uint jointCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public ovrAvatarTransform[] jointTransform;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public int[] jointParents;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public IntPtr[] jointNames;
}
[Flags]
public enum ovrAvatarVisibilityFlags
{
	FirstPerson = 1,
	ThirdPerson = 2,
	SelfOccluding = 4
}
public struct ovrAvatarRenderPart_SkinnedMeshRender
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ulong albedoTextureAssetID;

	public ulong surfaceTextureAssetID;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_ProjectorRender
{
	public ovrAvatarTransform localTransform;

	public uint componentIndex;

	public uint renderPartIndex;

	public ovrAvatarMaterialState materialState;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarPBSMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public enum ovrAvatarHandGesture
{
	Default,
	GripSphere,
	GripCube,
	Count
}
public enum ovrAvatarBodyPartType
{
	Body,
	Clothing,
	Eyewear,
	Hair,
	Beard,
	Count
}
public struct ovrAvatarBlendShapeParams
{
	public uint blendShapeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public float[] blendShapeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarBlendShapeParams_Offsets
{
	public static int blendShapeParamCount = Marshal.OffsetOf(typeof(ovrAvatarBlendShapeParams), "blendShapeParamCount").ToInt32();

	public static long blendShapeParams = Marshal.SizeOf(typeof(uint));
}
public struct ovrAvatarVisemes
{
	public uint visemeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	public float[] visemeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarVisemes_Offsets
{
	public static int visemeParamCount = Marshal.OffsetOf(typeof(ovrAvatarVisemes), "visemeParamCount").ToInt32();

	public static long visemeParams = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarGazeTargetType
{
	AvatarHead,
	AvatarHand,
	Object,
	ObjectStatic,
	Count
}
public struct ovrAvatarGazeTarget
{
	public uint id;

	public Vector3 worldPosition;

	public ovrAvatarGazeTargetType type;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTarget_Offsets
{
	public static int id = 0;

	public static int worldPosition = Marshal.SizeOf(typeof(uint));

	public static int type = worldPosition + Marshal.SizeOf(typeof(Vector3));
}
public struct ovrAvatarGazeTargets
{
	public uint targetCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	public ovrAvatarGazeTarget[] targets;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTargets_Offsets
{
	public static int targetCount = Marshal.OffsetOf(typeof(ovrAvatarGazeTargets), "targetCount").ToInt32();

	public static long targets = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarLightType
{
	Point,
	Direction,
	Spot,
	Count
}
public struct ovrAvatarLight
{
	public uint id;

	public ovrAvatarLightType type;

	public float intensity;

	public Vector3 worldDirection;

	public Vector3 worldPosition;

	public float range;

	public float spotAngleDeg;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLight_Offsets
{
	public static long id = Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64();

	public static long type = Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64();

	public static long intensity = Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64();

	public static long worldDirection = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64();

	public static long worldPosition = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64();

	public static long range = Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64();

	public static long spotAngleDeg = Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64();
}
public struct ovrAvatarLights
{
	public float ambientIntensity;

	public uint lightCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
	public ovrAvatarLight[] lights;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLights_Offsets
{
	public static long ambientIntensity = Marshal.OffsetOf(typeof(ovrAvatarLights), "ambientIntensity").ToInt64();

	public static long lightCount = Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64();

	public static long lights = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
}
[Flags]
public enum ovrAvatarDebugContext : uint
{
	None = 0u,
	GazeTarget = 1u,
	Any = uint.MaxValue
}
public struct ovrAvatarDebugLine
{
	public Vector3 startPoint;

	public Vector3 endPoint;

	public Vector3 color;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public struct ovrAvatarDebugTransform
{
	public ovrAvatarTransform transform;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public delegate void specificationCallback(IntPtr specification);
public delegate void assetLoadedCallback(OvrAvatarAsset asset);
public delegate void combinedMeshLoadedCallback(IntPtr asset);
public class OvrAvatarSDKManager : MonoBehaviour
{
	public struct AvatarSpecRequestParams
	{
		public ulong _userId;

		public specificationCallback _callback;

		public bool _useCombinedMesh;

		public ovrAvatarAssetLevelOfDetail _lod;

		public bool _forceMobileTextureFormat;

		public ovrAvatarLookAndFeelVersion _lookVersion;

		public ovrAvatarLookAndFeelVersion _fallbackVersion;

		public bool _enableExpressive;

		public AvatarSpecRequestParams(ulong userId, specificationCallback callback, bool useCombinedMesh, ovrAvatarAssetLevelOfDetail lod, bool forceMobileTextureFormat, ovrAvatarLookAndFeelVersion lookVersion, ovrAvatarLookAndFeelVersion fallbackVersion, bool enableExpressive)
		{
			_userId = userId;
			_callback = callback;
			_useCombinedMesh = useCombinedMesh;
			_lod = lod;
			_forceMobileTextureFormat = forceMobileTextureFormat;
			_lookVersion = lookVersion;
			_fallbackVersion = fallbackVersion;
			_enableExpressive = enableExpressive;
		}
	}

	private static OvrAvatarSDKManager _instance;

	private bool initialized;

	private Dictionary<ulong, HashSet<specificationCallback>> specificationCallbacks;

	private Dictionary<ulong, HashSet<assetLoadedCallback>> assetLoadedCallbacks;

	private Dictionary<IntPtr, combinedMeshLoadedCallback> combinedMeshLoadedCallbacks;

	private Dictionary<ulong, OvrAvatarAsset> assetCache;

	private OvrAvatarTextureCopyManager textureCopyManager;

	public ovrAvatarLogLevel LoggingLevel = ovrAvatarLogLevel.Info;

	private Queue<AvatarSpecRequestParams> avatarSpecificationQueue;

	private List<int> loadingAvatars;

	private bool avatarSpecRequestAvailable = true;

	private float lastDispatchedAvatarSpecRequestTime;

	private const float AVATAR_SPEC_REQUEST_TIMEOUT = 5f;

	public static OvrAvatarSDKManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<OvrAvatarSDKManager>();
				if (_instance == null)
				{
					GameObject gameObject = new GameObject("OvrAvatarSDKManager");
					_instance = gameObject.AddComponent<OvrAvatarSDKManager>();
					_instance.textureCopyManager = gameObject.AddComponent<OvrAvatarTextureCopyManager>();
					_instance.initialized = _instance.Initialize();
				}
			}
			if (!_instance.initialized)
			{
				return null;
			}
			return _instance;
		}
	}

	private bool Initialize()
	{
		Oculus.Avatar.CAPI.Initialize();
		string text = GetAppId();
		if (text == "")
		{
			text = "0";
		}
		Oculus.Avatar.CAPI.ovrAvatar_InitializeAndroidUnity(text);
		specificationCallbacks = new Dictionary<ulong, HashSet<specificationCallback>>();
		assetLoadedCallbacks = new Dictionary<ulong, HashSet<assetLoadedCallback>>();
		combinedMeshLoadedCallbacks = new Dictionary<IntPtr, combinedMeshLoadedCallback>();
		assetCache = new Dictionary<ulong, OvrAvatarAsset>();
		avatarSpecificationQueue = new Queue<AvatarSpecRequestParams>();
		loadingAvatars = new List<int>();
		Oculus.Avatar.CAPI.ovrAvatar_SetLoggingLevel(LoggingLevel);
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(Oculus.Avatar.CAPI.LoggingCallback);
		return true;
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.Shutdown();
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(null);
		Oculus.Avatar.CAPI.ovrAvatar_Shutdown();
	}

	private void Update()
	{
		if (Instance == null)
		{
			return;
		}
		if (avatarSpecificationQueue.Count > 0 && (avatarSpecRequestAvailable || Time.time - lastDispatchedAvatarSpecRequestTime >= 5f))
		{
			avatarSpecRequestAvailable = false;
			AvatarSpecRequestParams avatarSpecRequest = avatarSpecificationQueue.Dequeue();
			DispatchAvatarSpecificationRequest(avatarSpecRequest);
			lastDispatchedAvatarSpecRequestTime = Time.time;
		}
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarMessage_Pop();
		if (intPtr == IntPtr.Zero)
		{
			return;
		}
		ovrAvatarMessageType ovrAvatarMessageType2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetType(intPtr);
		switch (ovrAvatarMessageType2)
		{
		case ovrAvatarMessageType.AssetLoaded:
		{
			ovrAvatarMessage_AssetLoaded ovrAvatarMessage_AssetLoaded2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAssetLoaded(intPtr);
			IntPtr asset = ovrAvatarMessage_AssetLoaded2.asset;
			ulong assetID = ovrAvatarMessage_AssetLoaded2.assetID;
			ovrAvatarAssetType ovrAvatarAssetType2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetType(asset);
			OvrAvatarAsset ovrAvatarAsset = null;
			IntPtr key = IntPtr.Zero;
			switch (ovrAvatarAssetType2)
			{
			case ovrAvatarAssetType.Mesh:
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.Mesh);
				break;
			case ovrAvatarAssetType.Texture:
				ovrAvatarAsset = new OvrAvatarAssetTexture(assetID, asset);
				break;
			case ovrAvatarAssetType.Material:
				ovrAvatarAsset = new OvrAvatarAssetMaterial(assetID, asset);
				break;
			case ovrAvatarAssetType.CombinedMesh:
				key = Oculus.Avatar.CAPI.ovrAvatarAsset_GetAvatar(asset);
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.CombinedMesh);
				break;
			default:
				throw new NotImplementedException($"Unsupported asset type format {ovrAvatarAssetType2.ToString()}");
			case ovrAvatarAssetType.FailedLoad:
				break;
			}
			if (ovrAvatarAssetType2 == ovrAvatarAssetType.CombinedMesh)
			{
				if (!assetCache.ContainsKey(assetID))
				{
					assetCache.Add(assetID, ovrAvatarAsset);
				}
				if (combinedMeshLoadedCallbacks.TryGetValue(key, out var value2))
				{
					value2(asset);
					combinedMeshLoadedCallbacks.Remove(key);
				}
			}
			else
			{
				if (ovrAvatarAsset == null || !assetLoadedCallbacks.TryGetValue(ovrAvatarMessage_AssetLoaded2.assetID, out var value3))
				{
					break;
				}
				assetCache.Add(assetID, ovrAvatarAsset);
				foreach (assetLoadedCallback item in value3)
				{
					item(ovrAvatarAsset);
				}
				assetLoadedCallbacks.Remove(ovrAvatarMessage_AssetLoaded2.assetID);
			}
			break;
		}
		case ovrAvatarMessageType.AvatarSpecification:
		{
			avatarSpecRequestAvailable = true;
			ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_AvatarSpecification2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAvatarSpecification(intPtr);
			if (!specificationCallbacks.TryGetValue(ovrAvatarMessage_AvatarSpecification2.oculusUserID, out var value))
			{
				break;
			}
			foreach (specificationCallback item2 in value)
			{
				item2(ovrAvatarMessage_AvatarSpecification2.avatarSpec);
			}
			specificationCallbacks.Remove(ovrAvatarMessage_AvatarSpecification2.oculusUserID);
			break;
		}
		default:
			throw new NotImplementedException("Unhandled ovrAvatarMessageType: " + ovrAvatarMessageType2);
		}
		Oculus.Avatar.CAPI.ovrAvatarMessage_Free(intPtr);
	}

	public bool IsAvatarSpecWaiting()
	{
		return avatarSpecificationQueue.Count > 0;
	}

	public bool IsAvatarLoading()
	{
		return loadingAvatars.Count > 0;
	}

	public void AddLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Add(gameobjectID);
	}

	public void RemoveLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Remove(gameobjectID);
	}

	public void RequestAvatarSpecification(AvatarSpecRequestParams avatarSpecRequest)
	{
		avatarSpecificationQueue.Enqueue(avatarSpecRequest);
	}

	private void DispatchAvatarSpecificationRequest(AvatarSpecRequestParams avatarSpecRequest)
	{
		textureCopyManager.CheckFallbackTextureSet(avatarSpecRequest._lod);
		Oculus.Avatar.CAPI.ovrAvatar_SetForceASTCTextures(avatarSpecRequest._forceMobileTextureFormat);
		if (!specificationCallbacks.TryGetValue(avatarSpecRequest._userId, out var value))
		{
			value = new HashSet<specificationCallback>();
			specificationCallbacks.Add(avatarSpecRequest._userId, value);
			IntPtr specificationRequest = Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Create(avatarSpecRequest._userId);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLookAndFeelVersion(specificationRequest, avatarSpecRequest._lookVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(specificationRequest, avatarSpecRequest._fallbackVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLevelOfDetail(specificationRequest, avatarSpecRequest._lod);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetCombineMeshes(specificationRequest, avatarSpecRequest._useCombinedMesh);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetExpressiveFlag(specificationRequest, avatarSpecRequest._enableExpressive);
			Oculus.Avatar.CAPI.ovrAvatar_RequestAvatarSpecificationFromSpecRequest(specificationRequest);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Destroy(specificationRequest);
		}
		value.Add(avatarSpecRequest._callback);
	}

	public void BeginLoadingAsset(ulong assetId, ovrAvatarAssetLevelOfDetail lod, assetLoadedCallback callback)
	{
		if (!assetLoadedCallbacks.TryGetValue(assetId, out var value))
		{
			value = new HashSet<assetLoadedCallback>();
			assetLoadedCallbacks.Add(assetId, value);
		}
		Oculus.Avatar.CAPI.ovrAvatarAsset_BeginLoadingLOD(assetId, lod);
		value.Add(callback);
	}

	public void RegisterCombinedMeshCallback(IntPtr sdkAvatar, combinedMeshLoadedCallback callback)
	{
		if (!combinedMeshLoadedCallbacks.TryGetValue(sdkAvatar, out var _))
		{
			combinedMeshLoadedCallbacks.Add(sdkAvatar, callback);
			return;
		}
		throw new Exception("Adding second combind mesh callback for same avatar");
	}

	public OvrAvatarAsset GetAsset(ulong assetId)
	{
		if (assetCache.TryGetValue(assetId, out var value))
		{
			return value;
		}
		return null;
	}

	public void DeleteAssetFromCache(ulong assetId)
	{
		if (assetCache.ContainsKey(assetId))
		{
			assetCache.Remove(assetId);
		}
	}

	public string GetAppId()
	{
		if (UnityEngine.Application.platform != RuntimePlatform.Android)
		{
			return OvrAvatarSettings.AppID;
		}
		return OvrAvatarSettings.MobileAppID;
	}

	public OvrAvatarTextureCopyManager GetTextureCopyManager()
	{
		if (textureCopyManager != null)
		{
			return textureCopyManager;
		}
		return null;
	}
}
public sealed class OvrAvatarSettings : ScriptableObject
{
	private static OvrAvatarSettings instance;

	[SerializeField]
	private string ovrAppID = "";

	[SerializeField]
	private string ovrGearAppID = "";

	public static string AppID
	{
		get
		{
			return Instance.ovrAppID;
		}
		set
		{
			Instance.ovrAppID = value;
		}
	}

	public static string MobileAppID
	{
		get
		{
			return Instance.ovrGearAppID;
		}
		set
		{
			Instance.ovrGearAppID = value;
		}
	}

	public static OvrAvatarSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<OvrAvatarSettings>("OvrAvatarSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<OvrAvatarSettings>();
				}
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class OvrAvatarSkinnedMeshRenderComponent : OvrAvatarRenderComponent
{
	private Shader surface;

	private Shader surfaceSelfOccluding;

	private bool previouslyActive;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender, Shader surface, Shader surfaceSelfOccluding, int thirdPersonLayer, int firstPersonLayer)
	{
		this.surfaceSelfOccluding = ((surfaceSelfOccluding != null) ? surfaceSelfOccluding : Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
		this.surface = ((surface != null) ? surface : Shader.Find("OvrAvatar/AvatarSurfaceShader"));
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		bones = mesh.bones;
		UpdateMeshMaterial(skinnedMeshRender.visibilityMask, mesh);
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		UpdateMeshMaterial(visibilityMask, mesh);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && (Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_MaterialStateChanged(renderPart) || (!previouslyActive && activeSelf)))
		{
			ovrAvatarMaterialState matState = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetMaterialState(renderPart);
			component.UpdateAvatarMaterial(mesh.sharedMaterial, matState);
		}
		previouslyActive = activeSelf;
	}

	private void UpdateMeshMaterial(ovrAvatarVisibilityFlags visibilityMask, SkinnedMeshRenderer rootMesh)
	{
		Shader shader = (((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) != 0) ? surfaceSelfOccluding : surface);
		if (rootMesh.sharedMaterial == null || rootMesh.sharedMaterial.shader != shader)
		{
			rootMesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		}
	}
}
public class OvrAvatarSkinnedMeshRenderPBSComponent : OvrAvatarRenderComponent
{
	private bool isMaterialInitilized;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS, Shader shader, int thirdPersonLayer, int firstPersonLayer)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShaderPBS");
		}
		mesh = CreateSkinnedMesh(skinnedMeshRenderPBS.meshAssetID, skinnedMeshRenderPBS.visibilityMask, thirdPersonLayer, firstPersonLayer);
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		bones = mesh.bones;
	}

	internal void UpdateSkinnedMeshRenderPBS(OvrAvatar avatar, IntPtr renderPart, Material mat)
	{
		if (!isMaterialInitilized)
		{
			isMaterialInitilized = true;
			ulong assetId = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(renderPart);
			ulong assetId2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(renderPart);
			mat.SetTexture("_Albedo", OvrAvatarComponent.GetLoadedTexture(assetId));
			mat.SetTexture("_Surface", OvrAvatarComponent.GetLoadedTexture(assetId2));
		}
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
	}
}
public class OvrAvatarSkinnedMeshPBSV2RenderComponent : OvrAvatarRenderComponent
{
	private OvrAvatarMaterialManager avatarMaterialManager;

	private bool previouslyActive;

	private bool isCombinedMaterial;

	private ovrAvatarExpressiveParameters ExpressiveParameters;

	private bool EnableExpressive;

	private int blendShapeCount;

	private ovrAvatarBlendShapeParams blendShapeParams;

	private const string MAIN_MATERIAL_NAME = "main_material";

	private const string EYE_MATERIAL_NAME = "eye_material";

	private const string DEFAULT_MATERIAL_NAME = "_material";

	internal void Initialize(IntPtr renderPart, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRender, OvrAvatarMaterialManager materialManager, int thirdPersonLayer, int firstPersonLayer, bool combinedMesh, ovrAvatarAssetLevelOfDetail lod, bool assignExpressiveParams, OvrAvatar avatar, bool isControllerModel)
	{
		avatarMaterialManager = materialManager;
		isCombinedMaterial = combinedMesh;
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		EnableExpressive = assignExpressiveParams;
		Shader shader = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_SingleComponent : avatar.Skinshaded_VertFrag_SingleComponent);
		Shader shader2 = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_CombinedMesh : avatar.Skinshaded_VertFrag_CombinedMesh);
		Shader shader3 = (isCombinedMaterial ? shader2 : shader);
		if (isControllerModel)
		{
			shader3 = avatar.ControllerShader;
		}
		if (EnableExpressive)
		{
			ExpressiveParameters = Oculus.Avatar.CAPI.ovrAvatar_GetExpressiveParameters(avatar.sdkAvatar);
			Shader eyeLens = avatar.EyeLens;
			Material[] array = new Material[2]
			{
				CreateAvatarMaterial(base.gameObject.name + "main_material", shader3),
				CreateAvatarMaterial(base.gameObject.name + "eye_material", eyeLens)
			};
			if (avatar.UseTransparentRenderQueue)
			{
				SetMaterialTransparent(array[0]);
			}
			else
			{
				SetMaterialOpaque(array[0]);
			}
			array[1].renderQueue = -1;
			mesh.materials = array;
		}
		else
		{
			mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader3);
			if (avatar.UseTransparentRenderQueue && !isControllerModel)
			{
				SetMaterialTransparent(mesh.sharedMaterial);
			}
			else
			{
				SetMaterialOpaque(mesh.sharedMaterial);
			}
		}
		bones = mesh.bones;
		if (isCombinedMaterial)
		{
			avatarMaterialManager.SetRenderer(mesh);
			InitializeCombinedMaterial(renderPart, (int)lod);
			avatarMaterialManager.OnCombinedMeshReady();
		}
		blendShapeParams = default(ovrAvatarBlendShapeParams);
		blendShapeParams.blendShapeParamCount = 0u;
		blendShapeParams.blendShapeParams = new float[64];
		blendShapeCount = mesh.sharedMesh.blendShapeCount;
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && !previouslyActive && activeSelf && !isCombinedMaterial)
		{
			InitializeSingleComponentMaterial(renderPart, (int)(avatar.LevelOfDetail - 1));
		}
		if (blendShapeCount > 0)
		{
			Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetBlendShapeParams(renderPart, ref blendShapeParams);
			for (uint num = 0u; num < blendShapeParams.blendShapeParamCount && num < blendShapeCount; num++)
			{
				float num2 = blendShapeParams.blendShapeParams[num];
				mesh.SetBlendShapeWeight((int)num, num2 * 100f);
			}
		}
		previouslyActive = activeSelf;
	}

	private void InitializeSingleComponentMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(renderPart);
		int componentType = (int)OvrAvatarMaterialManager.GetComponentType(base.gameObject.name);
		Texture2D texture2D = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.albedoTextureID);
		Texture2D texture2D2 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.normalTextureID);
		Texture2D texture2D3 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.metallicnessTextureID);
		if (texture2D != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.albedoTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D.anisoLevel = 4;
		if (texture2D2 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.normalTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D2 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
		}
		texture2D2.anisoLevel = 4;
		if (texture2D3 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.metallicnessTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D3 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D3.anisoLevel = 16;
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_MAINTEX, texture2D);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_NORMALMAP, texture2D2);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_ROUGHNESSMAP, texture2D3);
		mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_COLOR, ovrAvatarPBSMaterialState2.albedoMultiplier);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_DIFFUSEINTENSITY, OvrAvatarMaterialManager.DiffuseIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_RIMINTENSITY, OvrAvatarMaterialManager.RimIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_REFLECTIONINTENSITY, OvrAvatarMaterialManager.ReflectionIntensities[componentType]);
		mesh.GetClosestReflectionProbes(avatarMaterialManager.ReflectionProbes);
		if (avatarMaterialManager.ReflectionProbes != null && avatarMaterialManager.ReflectionProbes.Count > 0)
		{
			mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_CUBEMAP, avatarMaterialManager.ReflectionProbes[0].probe.texture);
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
	}

	private void InitializeCombinedMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState[] array = Oculus.Avatar.CAPI.ovrAvatar_GetBodyPBSMaterialStates(renderPart);
		if (array.Length != 5)
		{
			return;
		}
		avatarMaterialManager.CreateTextureArrays();
		OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = avatarMaterialManager.LocalAvatarConfig.ComponentMaterialProperties;
		for (int i = 0; i < array.Length; i++)
		{
			componentMaterialProperties[i].TypeIndex = (ovrAvatarBodyPartType)i;
			componentMaterialProperties[i].Color = array[i].albedoMultiplier;
			componentMaterialProperties[i].DiffuseIntensity = OvrAvatarMaterialManager.DiffuseIntensities[i];
			componentMaterialProperties[i].RimIntensity = OvrAvatarMaterialManager.RimIntensities[i];
			componentMaterialProperties[i].ReflectionIntensity = OvrAvatarMaterialManager.ReflectionIntensities[i];
			Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(array[i].albedoTextureID);
			Texture2D loadedTexture2 = OvrAvatarComponent.GetLoadedTexture(array[i].normalTextureID);
			Texture2D loadedTexture3 = OvrAvatarComponent.GetLoadedTexture(array[i].metallicnessTextureID);
			if (loadedTexture != null)
			{
				componentMaterialProperties[i].Textures[0] = loadedTexture;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].albedoTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[0] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[0].anisoLevel = 4;
			if (loadedTexture2 != null)
			{
				componentMaterialProperties[i].Textures[1] = loadedTexture2;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].normalTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[1] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
			}
			componentMaterialProperties[i].Textures[1].anisoLevel = 4;
			if (loadedTexture3 != null)
			{
				componentMaterialProperties[i].Textures[2] = loadedTexture3;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].metallicnessTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[2] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[2].anisoLevel = 16;
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
		avatarMaterialManager.ValidateTextures(array);
	}

	private void SetMaterialTransparent(Material mat)
	{
		mat.SetOverrideTag("Queue", "Transparent");
		mat.SetOverrideTag("RenderType", "Transparent");
		mat.SetInt("_SrcBlend", 5);
		mat.SetInt("_DstBlend", 10);
		mat.EnableKeyword("_ALPHATEST_ON");
		mat.EnableKeyword("_ALPHABLEND_ON");
		mat.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 3000;
	}

	private void SetMaterialOpaque(Material mat)
	{
		mat.SetOverrideTag("Queue", "Geometry");
		mat.SetOverrideTag("RenderType", "Opaque");
		mat.SetInt("_SrcBlend", 1);
		mat.SetInt("_DstBlend", 0);
		mat.DisableKeyword("_ALPHATEST_ON");
		mat.DisableKeyword("_ALPHABLEND_ON");
		mat.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 2000;
	}
}
public class OvrAvatarTextureCopyManager : MonoBehaviour
{
	[Serializable]
	public struct FallbackTextureSet
	{
		public bool Initialized;

		public Texture2D DiffuseRoughness;

		public Texture2D Normal;
	}

	private struct CopyTextureParams
	{
		public Texture Src;

		public Texture Dst;

		public int Mip;

		public int SrcSize;

		public int DstElement;

		public CopyTextureParams(Texture src, Texture dst, int mip, int srcSize, int dstElement)
		{
			Src = src;
			Dst = dst;
			Mip = mip;
			SrcSize = srcSize;
			DstElement = dstElement;
		}
	}

	public struct TextureSet
	{
		public Dictionary<ulong, bool> TextureIDSingleMeshPair;

		public bool IsProcessed;

		public TextureSet(Dictionary<ulong, bool> textureIDSingleMeshPair, bool isProcessed)
		{
			TextureIDSingleMeshPair = textureIDSingleMeshPair;
			IsProcessed = isProcessed;
		}
	}

	public FallbackTextureSet[] FallbackTextureSets = new FallbackTextureSet[6];

	private Queue<CopyTextureParams> texturesToCopy;

	private Dictionary<int, TextureSet> textureSets;

	private const int TEXTURES_TO_COPY_QUEUE_CAPACITY = 256;

	private const int COPIES_PER_FRAME = 8;

	private readonly string[] FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS = new string[6] { "null", "FallbackTextures/fallback_diffuse_roughness_256", "null", "FallbackTextures/fallback_diffuse_roughness_1024", "null", "FallbackTextures/fallback_diffuse_roughness_2048" };

	private readonly string[] FALLBACK_TEXTURE_PATHS_NORMAL = new string[6] { "null", "FallbackTextures/fallback_normal_256", "null", "FallbackTextures/fallback_normal_1024", "null", "FallbackTextures/fallback_normal_2048" };

	private const string PATH_HIGHEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_2048";

	private const string PATH_MEDIUM_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_1024";

	private const string PATH_LOWEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_256";

	private const string PATH_HIGHEST_NORMAL = "FallbackTextures/fallback_normal_2048";

	private const string PATH_MEDIUM_NORMAL = "FallbackTextures/fallback_normal_1024";

	private const string PATH_LOWEST_NORMAL = "FallbackTextures/fallback_normal_256";

	private const int GPU_TEXTURE_COPY_WAIT_TIME = 10;

	public OvrAvatarTextureCopyManager()
	{
		texturesToCopy = new Queue<CopyTextureParams>(256);
		textureSets = new Dictionary<int, TextureSet>();
	}

	public void Update()
	{
		if (texturesToCopy.Count == 0)
		{
			return;
		}
		lock (texturesToCopy)
		{
			for (int i = 0; i < Mathf.Min(8, texturesToCopy.Count); i++)
			{
				CopyTexture(texturesToCopy.Dequeue());
			}
		}
	}

	public int GetTextureCount()
	{
		return texturesToCopy.Count;
	}

	public void CopyTexture(Texture src, Texture dst, int mipLevel, int mipSize, int dstElement, bool useQueue = true)
	{
		CopyTextureParams copyTextureParams = new CopyTextureParams(src, dst, mipLevel, mipSize, dstElement);
		if (useQueue)
		{
			lock (texturesToCopy)
			{
				if (texturesToCopy.Count < 256)
				{
					texturesToCopy.Enqueue(copyTextureParams);
				}
				else
				{
					CopyTexture(copyTextureParams);
				}
				return;
			}
		}
		CopyTexture(copyTextureParams);
	}

	private void CopyTexture(CopyTextureParams copyTextureParams)
	{
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip);
	}

	public void AddTextureIDToTextureSet(int gameobjectID, ulong textureID, bool isSingleMesh)
	{
		bool value2;
		if (!textureSets.ContainsKey(gameobjectID))
		{
			TextureSet value = new TextureSet(new Dictionary<ulong, bool>(), isProcessed: false);
			value.TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
			textureSets.Add(gameobjectID, value);
		}
		else if (textureSets[gameobjectID].TextureIDSingleMeshPair.TryGetValue(textureID, out value2))
		{
			if (!value2 && isSingleMesh)
			{
				textureSets[gameobjectID].TextureIDSingleMeshPair[textureID] = true;
			}
		}
		else
		{
			textureSets[gameobjectID].TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
		}
	}

	public void DeleteTextureSet(int gameobjectID)
	{
		if (textureSets.TryGetValue(gameobjectID, out var value) && !value.IsProcessed)
		{
			StartCoroutine(DeleteTextureSetCoroutine(value, gameobjectID));
		}
	}

	private IEnumerator DeleteTextureSetCoroutine(TextureSet textureSetToDelete, int gameobjectID)
	{
		yield return new WaitForSeconds(10f);
		while (OvrAvatarSDKManager.Instance.IsAvatarLoading())
		{
			yield return null;
		}
		foreach (KeyValuePair<ulong, bool> item in textureSetToDelete.TextureIDSingleMeshPair)
		{
			bool flag = !item.Value;
			if (flag)
			{
				foreach (KeyValuePair<int, TextureSet> textureSet in textureSets)
				{
					if (textureSet.Key == gameobjectID)
					{
						continue;
					}
					foreach (KeyValuePair<ulong, bool> item2 in textureSet.Value.TextureIDSingleMeshPair)
					{
						if (item2.Key == item.Key && (!textureSet.Value.IsProcessed || item2.Value))
						{
							flag = false;
							break;
						}
					}
					if (!flag)
					{
						break;
					}
				}
			}
			if (flag)
			{
				Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(item.Key);
				if (loadedTexture != null)
				{
					OvrAvatarSDKManager.Instance.DeleteAssetFromCache(item.Key);
					UnityEngine.Object.Destroy(loadedTexture);
				}
			}
		}
		textureSetToDelete.IsProcessed = true;
		textureSets.Remove(gameobjectID);
	}

	public void CheckFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		if (!FallbackTextureSets[(int)lod].Initialized)
		{
			InitFallbackTextureSet(lod);
		}
	}

	private void InitFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		FallbackTextureSets[(int)lod].DiffuseRoughness = (FallbackTextureSets[(int)lod].DiffuseRoughness = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS[(int)lod]));
		FallbackTextureSets[(int)lod].Normal = (FallbackTextureSets[(int)lod].Normal = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_NORMAL[(int)lod]));
		FallbackTextureSets[(int)lod].Initialized = true;
	}
}
public class OvrAvatarTouchController : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarControllerComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.ControllerLeft = null;
		}
		else
		{
			owner.ControllerRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class DebugUIBuilder : MonoBehaviour
{
	public delegate void OnClick();

	public delegate void OnToggleValueChange(Toggle t);

	public delegate void OnSlider(float f);

	public delegate bool ActiveUpdate();

	public const int DEBUG_PANE_CENTER = 0;

	public const int DEBUG_PANE_RIGHT = 1;

	public const int DEBUG_PANE_LEFT = 2;

	[SerializeField]
	private RectTransform buttonPrefab;

	[SerializeField]
	private RectTransform labelPrefab;

	[SerializeField]
	private RectTransform sliderPrefab;

	[SerializeField]
	private RectTransform dividerPrefab;

	[SerializeField]
	private RectTransform togglePrefab;

	[SerializeField]
	private RectTransform radioPrefab;

	[SerializeField]
	private GameObject uiHelpersToInstantiate;

	[SerializeField]
	private Transform[] targetContentPanels;

	private bool[] reEnable;

	[SerializeField]
	private List<GameObject> toEnable;

	[SerializeField]
	private List<GameObject> toDisable;

	public static DebugUIBuilder instance;

	private const float elementSpacing = 16f;

	private const float marginH = 16f;

	private const float marginV = 16f;

	private Vector2[] insertPositions;

	private List<RectTransform>[] insertedElements;

	private Vector3 menuOffset;

	private OVRCameraRig rig;

	private Dictionary<string, ToggleGroup> radioGroups = new Dictionary<string, ToggleGroup>();

	private LaserPointer lp;

	private LineRenderer lr;

	public LaserPointer.LaserBeamBehavior laserBeamBehavior;

	public void Awake()
	{
		Debug.Assert(instance == null);
		instance = this;
		menuOffset = base.transform.position;
		base.gameObject.SetActive(value: false);
		rig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		for (int i = 0; i < toEnable.Count; i++)
		{
			toEnable[i].SetActive(value: false);
		}
		insertPositions = new Vector2[targetContentPanels.Length];
		for (int j = 0; j < insertPositions.Length; j++)
		{
			insertPositions[j].x = 16f;
			insertPositions[j].y = -16f;
		}
		insertedElements = new List<RectTransform>[targetContentPanels.Length];
		for (int k = 0; k < insertedElements.Length; k++)
		{
			insertedElements[k] = new List<RectTransform>();
		}
		if ((bool)uiHelpersToInstantiate)
		{
			UnityEngine.Object.Instantiate(uiHelpersToInstantiate);
		}
		lp = UnityEngine.Object.FindObjectOfType<LaserPointer>();
		if (!lp)
		{
			Debug.LogError("Debug UI requires use of a LaserPointer and will not function without it. Add one to your scene, or assign the UIHelpers prefab to the DebugUIBuilder in the inspector.");
			return;
		}
		lp.laserBeamBehavior = laserBeamBehavior;
		if (!toEnable.Contains(lp.gameObject))
		{
			toEnable.Add(lp.gameObject);
		}
		GetComponent<OVRRaycaster>().pointer = lp.gameObject;
		lp.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		Relayout();
		base.gameObject.SetActive(value: true);
		base.transform.position = rig.transform.TransformPoint(menuOffset);
		Vector3 eulerAngles = rig.transform.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		base.transform.eulerAngles = eulerAngles;
		if (reEnable == null || reEnable.Length < toDisable.Count)
		{
			reEnable = new bool[toDisable.Count];
		}
		reEnable.Initialize();
		int count = toDisable.Count;
		for (int i = 0; i < count; i++)
		{
			if ((bool)toDisable[i])
			{
				reEnable[i] = toDisable[i].activeSelf;
				toDisable[i].SetActive(value: false);
			}
		}
		count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: true);
		}
		int num = targetContentPanels.Length;
		for (int k = 0; k < num; k++)
		{
			targetContentPanels[k].gameObject.SetActive(insertedElements[k].Count > 0);
		}
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
		for (int i = 0; i < reEnable.Length; i++)
		{
			if ((bool)toDisable[i] && reEnable[i])
			{
				toDisable[i].SetActive(value: true);
			}
		}
		int count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: false);
		}
	}

	private void Relayout()
	{
		for (int i = 0; i < targetContentPanels.Length; i++)
		{
			RectTransform component = targetContentPanels[i].GetComponent<RectTransform>();
			List<RectTransform> list = insertedElements[i];
			int count = list.Count;
			float x = 16f;
			float num = -16f;
			float num2 = 0f;
			for (int j = 0; j < count; j++)
			{
				RectTransform rectTransform = list[j];
				rectTransform.anchoredPosition = new Vector2(x, num);
				num -= rectTransform.rect.height + 16f;
				num2 = Mathf.Max(rectTransform.rect.width + 32f, num2);
			}
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, num2);
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 0f - num + 16f);
		}
	}

	private void AddRect(RectTransform r, int targetCanvas)
	{
		if (targetCanvas > targetContentPanels.Length)
		{
			Debug.LogError("Attempted to add debug panel to canvas " + targetCanvas + ", but only " + targetContentPanels.Length + " panels were provided. Fix in the inspector or pass a lower value for target canvas.");
		}
		else
		{
			r.transform.SetParent(targetContentPanels[targetCanvas], worldPositionStays: false);
			insertedElements[targetCanvas].Add(r);
			if (base.gameObject.activeInHierarchy)
			{
				Relayout();
			}
		}
	}

	public RectTransform AddButton(string label, OnClick handler, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(buttonPrefab).GetComponent<RectTransform>();
		component.GetComponentInChildren<Button>().onClick.AddListener(delegate
		{
			handler();
		});
		((Text)component.GetComponentsInChildren(typeof(Text), includeInactive: true)[0]).text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddLabel(string label, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(labelPrefab).GetComponent<RectTransform>();
		component.GetComponent<Text>().text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddSlider(string label, float min, float max, OnSlider onValueChanged, bool wholeNumbersOnly = false, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(sliderPrefab);
		Slider componentInChildren = rectTransform.GetComponentInChildren<Slider>();
		componentInChildren.minValue = min;
		componentInChildren.maxValue = max;
		componentInChildren.onValueChanged.AddListener(delegate(float f)
		{
			onValueChanged(f);
		});
		componentInChildren.wholeNumbers = wholeNumbersOnly;
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddDivider(int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(dividerPrefab);
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, bool defaultValue, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.isOn = defaultValue;
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddRadio(string label, string group, OnToggleValueChange handler, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(radioPrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle tb = rectTransform.GetComponentInChildren<Toggle>();
		if (group == null)
		{
			group = "default";
		}
		ToggleGroup toggleGroup = null;
		bool isOn = false;
		if (!radioGroups.ContainsKey(group))
		{
			toggleGroup = tb.gameObject.AddComponent<ToggleGroup>();
			radioGroups[group] = toggleGroup;
			isOn = true;
		}
		else
		{
			toggleGroup = radioGroups[group];
		}
		tb.group = toggleGroup;
		tb.isOn = isOn;
		tb.onValueChanged.AddListener(delegate
		{
			handler(tb);
		});
		return rectTransform;
	}

	public void ToggleLaserPointer(bool isOn)
	{
		if ((bool)lp)
		{
			if (isOn)
			{
				lp.enabled = true;
			}
			else
			{
				lp.enabled = false;
			}
		}
	}
}
public class HandedInputSelector : MonoBehaviour
{
	private OVRCameraRig m_CameraRig;

	private OVRInputModule m_InputModule;

	private void Start()
	{
		m_CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		m_InputModule = UnityEngine.Object.FindObjectOfType<OVRInputModule>();
	}

	private void Update()
	{
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			SetActiveController(OVRInput.Controller.LTouch);
		}
		else
		{
			SetActiveController(OVRInput.Controller.RTouch);
		}
	}

	private void SetActiveController(OVRInput.Controller c)
	{
		Transform rayTransform = ((c != OVRInput.Controller.LTouch) ? m_CameraRig.rightHandAnchor : m_CameraRig.leftHandAnchor);
		m_InputModule.rayTransform = rayTransform;
	}
}
public class LaserPointer : OVRCursor
{
	public enum LaserBeamBehavior
	{
		On,
		Off,
		OnWhenHitTarget
	}

	public GameObject cursorVisual;

	public float maxLength = 10f;

	private LaserBeamBehavior _laserBeamBehavior;

	private bool m_restoreOnInputAcquired;

	private Vector3 _startPoint;

	private Vector3 _forward;

	private Vector3 _endPoint;

	private bool _hitTarget;

	private LineRenderer lineRenderer;

	public LaserBeamBehavior laserBeamBehavior
	{
		get
		{
			return _laserBeamBehavior;
		}
		set
		{
			_laserBeamBehavior = value;
			if (laserBeamBehavior == LaserBeamBehavior.Off || laserBeamBehavior == LaserBeamBehavior.OnWhenHitTarget)
			{
				lineRenderer.enabled = false;
			}
			else
			{
				lineRenderer.enabled = true;
			}
		}
	}

	private void Awake()
	{
		lineRenderer = GetComponent<LineRenderer>();
	}

	private void Start()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
		OVRManager.InputFocusAcquired += OnInputFocusAcquired;
		OVRManager.InputFocusLost += OnInputFocusLost;
	}

	public override void SetCursorStartDest(Vector3 start, Vector3 dest, Vector3 normal)
	{
		_startPoint = start;
		_endPoint = dest;
		_hitTarget = true;
	}

	public override void SetCursorRay(Transform t)
	{
		_startPoint = t.position;
		_forward = t.forward;
		_hitTarget = false;
	}

	private void LateUpdate()
	{
		lineRenderer.SetPosition(0, _startPoint);
		if (_hitTarget)
		{
			lineRenderer.SetPosition(1, _endPoint);
			UpdateLaserBeam(_startPoint, _endPoint);
			if ((bool)cursorVisual)
			{
				cursorVisual.transform.position = _endPoint;
				cursorVisual.SetActive(value: true);
			}
		}
		else
		{
			UpdateLaserBeam(_startPoint, _startPoint + maxLength * _forward);
			lineRenderer.SetPosition(1, _startPoint + maxLength * _forward);
			if ((bool)cursorVisual)
			{
				cursorVisual.SetActive(value: false);
			}
		}
	}

	private void UpdateLaserBeam(Vector3 start, Vector3 end)
	{
		if (laserBeamBehavior == LaserBeamBehavior.Off)
		{
			return;
		}
		if (laserBeamBehavior == LaserBeamBehavior.On)
		{
			lineRenderer.SetPosition(0, start);
			lineRenderer.SetPosition(1, end);
		}
		else
		{
			if (laserBeamBehavior != LaserBeamBehavior.OnWhenHitTarget)
			{
				return;
			}
			if (_hitTarget)
			{
				if (!lineRenderer.enabled)
				{
					lineRenderer.enabled = true;
					lineRenderer.SetPosition(0, start);
					lineRenderer.SetPosition(1, end);
				}
			}
			else if (lineRenderer.enabled)
			{
				lineRenderer.enabled = false;
			}
		}
	}

	private void OnDisable()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
	}

	public void OnInputFocusLost()
	{
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			m_restoreOnInputAcquired = true;
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnInputFocusAcquired()
	{
		if (m_restoreOnInputAcquired && (bool)base.gameObject)
		{
			m_restoreOnInputAcquired = false;
			base.gameObject.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
		OVRManager.InputFocusLost -= OnInputFocusLost;
	}
}
public class CharacterCameraConstraint : MonoBehaviour
{
	[Tooltip("This should be a reference to the OVRCameraRig that is usually a child of the PlayerController.")]
	public OVRCameraRig CameraRig;

	[Tooltip("When true, the camera will be prevented from passing through collidable geometry. This is usually considered uncomfortable for users.")]
	public bool EnableCollision;

	public LayerMask CollideLayers;

	[Tooltip("This should be set to 1 to make the screen completely fade out when the HMD is inside world geometry. Lesser values can be useful for testing.")]
	public float MaxFade = 1f;

	[Tooltip("This value is used to control how far from the character capsule the HMD must be before the fade to black begins.")]
	public float FadeMinDistance = 0.25f;

	public float PreferredHeight = 1f;

	[Tooltip("This value is used to control how far from the character capsule the HMD must be before the fade to black is complete. This should be tuned so that it is fully faded in before the camera will clip geometry that the player should not be able see beyond.")]
	public float FadeMaxDistance = 0.35f;

	private readonly Action _cameraUpdateAction;

	private readonly Action _preCharacterMovementAction;

	private CapsuleCollider _character;

	private SimpleCapsuleWithStickMovement _simplePlayerController;

	private CharacterCameraConstraint()
	{
		_cameraUpdateAction = CameraUpdate;
	}

	private void Awake()
	{
		_character = GetComponent<CapsuleCollider>();
		_simplePlayerController = GetComponent<SimpleCapsuleWithStickMovement>();
	}

	private void Start()
	{
	}

	private void OnEnable()
	{
		_simplePlayerController.CameraUpdated += _cameraUpdateAction;
	}

	private void OnDisable()
	{
		_simplePlayerController.CameraUpdated -= _cameraUpdateAction;
	}

	private void CameraUpdate()
	{
		if (!(PreferredHeight > 0f))
		{
			return;
		}
		float num;
		if (!((num = Mathf.Min(CameraRig.centerEyeAnchor.transform.localPosition.y, PreferredHeight)) <= _character.height) && EnableCollision)
		{
			Vector3 position;
			Vector3 vector = (position = _character.transform.position);
			position.y += num * 4f;
			Debug.DrawLine(vector, position);
			if (Physics.SphereCast(vector, _character.radius * 0.2f, Vector3.up, out var hitInfo, 4f, CollideLayers, QueryTriggerInteraction.Ignore))
			{
				num = hitInfo.distance + _character.radius;
			}
		}
		_character.height = num;
		Vector3 localPosition = CameraRig.transform.localPosition;
		localPosition.y = (0f - _character.height) * 0.5f;
		CameraRig.transform.localPosition = localPosition;
	}
}
public class LocomotionController : MonoBehaviour
{
	public OVRCameraRig CameraRig;

	public CapsuleCollider CharacterController;

	public SimpleCapsuleWithStickMovement PlayerController;

	private void Start()
	{
		if (CameraRig == null)
		{
			CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		}
	}
}
public class LocomotionTeleport : MonoBehaviour
{
	public enum States
	{
		Ready,
		Aim,
		CancelAim,
		PreTeleport,
		CancelTeleport,
		Teleporting,
		PostTeleport
	}

	public enum TeleportIntentions
	{
		None,
		Aim,
		PreTeleport,
		Teleport
	}

	public enum AimCollisionTypes
	{
		Point,
		Sphere,
		Capsule
	}

	public class AimData
	{
		public RaycastHit TargetHitInfo;

		public bool TargetValid;

		public Vector3? Destination;

		public float Radius;

		public List<Vector3> Points { get; private set; }

		public AimData()
		{
			Points = new List<Vector3>();
		}

		public void Reset()
		{
			Points.Clear();
			TargetValid = false;
			Destination = null;
		}
	}

	[Tooltip("Allow linear movement prior to the teleport system being activated.")]
	public bool EnableMovementDuringReady = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableMovementDuringAim = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableMovementDuringPreTeleport = true;

	[Tooltip("Allow linear movement after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableMovementDuringPostTeleport = true;

	[Tooltip("Allow rotation prior to the teleport system being activated.")]
	public bool EnableRotationDuringReady = true;

	[Tooltip("Allow rotation while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableRotationDuringAim = true;

	[Tooltip("Allow rotation while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableRotationDuringPreTeleport = true;

	[Tooltip("Allow rotation after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableRotationDuringPostTeleport = true;

	[NonSerialized]
	public TeleportAimHandler AimHandler;

	[Tooltip("This prefab will be instantiated as needed and updated to match the current aim target.")]
	public TeleportDestination TeleportDestinationPrefab;

	[Tooltip("TeleportDestinationPrefab will be instantiated into this layer.")]
	public int TeleportDestinationLayer;

	[NonSerialized]
	public TeleportInputHandler InputHandler;

	[NonSerialized]
	public TeleportIntentions CurrentIntention;

	[NonSerialized]
	public bool IsPreTeleportRequested;

	[NonSerialized]
	public bool IsTransitioning;

	[NonSerialized]
	public bool IsPostTeleportRequested;

	private TeleportDestination _teleportDestination;

	[Tooltip("When aiming at possible destinations, the aim collision type determines which shape to use for collision tests.")]
	public AimCollisionTypes AimCollisionType;

	[Tooltip("Use the character collision radius/height/skinwidth for sphere/capsule collision tests.")]
	public bool UseCharacterCollisionData;

	[Tooltip("Radius of the sphere or capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionRadius;

	[Tooltip("Height of the capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionHeight;

	public States CurrentState { get; private set; }

	public Quaternion DestinationRotation => _teleportDestination.OrientationIndicator.rotation;

	public LocomotionController LocomotionController { get; private set; }

	public event Action<bool, Vector3?, Quaternion?, Quaternion?> UpdateTeleportDestination;

	public event Action EnterStateReady;

	public event Action EnterStateAim;

	public event Action<AimData> UpdateAimData;

	public event Action ExitStateAim;

	public event Action EnterStateCancelAim;

	public event Action EnterStatePreTeleport;

	public event Action EnterStateCancelTeleport;

	public event Action EnterStateTeleporting;

	public event Action EnterStatePostTeleport;

	public event Action<Transform, Vector3, Quaternion> Teleported;

	public void EnableMovement(bool ready, bool aim, bool pre, bool post)
	{
		EnableMovementDuringReady = ready;
		EnableMovementDuringAim = aim;
		EnableMovementDuringPreTeleport = pre;
		EnableMovementDuringPostTeleport = post;
	}

	public void EnableRotation(bool ready, bool aim, bool pre, bool post)
	{
		EnableRotationDuringReady = ready;
		EnableRotationDuringAim = aim;
		EnableRotationDuringPreTeleport = pre;
		EnableRotationDuringPostTeleport = post;
	}

	public void OnUpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		if (this.UpdateTeleportDestination != null)
		{
			this.UpdateTeleportDestination(isValidDestination, position, rotation, landingRotation);
		}
	}

	public bool AimCollisionTest(Vector3 start, Vector3 end, LayerMask aimCollisionLayerMask, out RaycastHit hitInfo)
	{
		Vector3 vector = end - start;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		switch (AimCollisionType)
		{
		case AimCollisionTypes.Capsule:
		{
			float num;
			float num2;
			if (UseCharacterCollisionData)
			{
				CapsuleCollider characterController = LocomotionController.CharacterController;
				num = characterController.height;
				num2 = characterController.radius;
			}
			else
			{
				num = AimCollisionHeight;
				num2 = AimCollisionRadius;
			}
			return Physics.CapsuleCast(start + new Vector3(0f, num2, 0f), start + new Vector3(0f, num + num2, 0f), num2, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		case AimCollisionTypes.Point:
			return Physics.Raycast(start, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		case AimCollisionTypes.Sphere:
		{
			float radius = ((!UseCharacterCollisionData) ? AimCollisionRadius : LocomotionController.CharacterController.radius);
			return Physics.SphereCast(start, radius, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		default:
			throw new Exception();
		}
	}

	[Conditional("DEBUG_TELEPORT_STATES")]
	protected void LogState(string msg)
	{
	}

	protected void CreateNewTeleportDestination()
	{
		TeleportDestinationPrefab.gameObject.SetActive(value: false);
		TeleportDestination teleportDestination = UnityEngine.Object.Instantiate(TeleportDestinationPrefab);
		teleportDestination.LocomotionTeleport = this;
		teleportDestination.gameObject.layer = TeleportDestinationLayer;
		_teleportDestination = teleportDestination;
		_teleportDestination.LocomotionTeleport = this;
	}

	private void DeactivateDestination()
	{
		_teleportDestination.OnDeactivated();
	}

	public void RecycleTeleportDestination(TeleportDestination oldDestination)
	{
		if (oldDestination == _teleportDestination)
		{
			CreateNewTeleportDestination();
		}
		UnityEngine.Object.Destroy(oldDestination.gameObject);
	}

	private void EnableMotion(bool enableLinear, bool enableRotation)
	{
		LocomotionController.PlayerController.EnableLinearMovement = enableLinear;
		LocomotionController.PlayerController.EnableRotation = enableRotation;
	}

	private void Awake()
	{
		LocomotionController = GetComponent<LocomotionController>();
		CreateNewTeleportDestination();
	}

	public virtual void OnEnable()
	{
		CurrentState = States.Ready;
		StartCoroutine(ReadyStateCoroutine());
	}

	public virtual void OnDisable()
	{
		StopAllCoroutines();
	}

	protected IEnumerator ReadyStateCoroutine()
	{
		yield return null;
		CurrentState = States.Ready;
		EnableMotion(EnableMovementDuringReady, EnableRotationDuringReady);
		if (this.EnterStateReady != null)
		{
			this.EnterStateReady();
		}
		while (CurrentIntention != TeleportIntentions.Aim)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(AimStateCoroutine());
	}

	public void OnUpdateAimData(AimData aimData)
	{
		if (this.UpdateAimData != null)
		{
			this.UpdateAimData(aimData);
		}
	}

	protected IEnumerator AimStateCoroutine()
	{
		CurrentState = States.Aim;
		EnableMotion(EnableMovementDuringAim, EnableRotationDuringAim);
		if (this.EnterStateAim != null)
		{
			this.EnterStateAim();
		}
		_teleportDestination.gameObject.SetActive(value: true);
		while (CurrentIntention == TeleportIntentions.Aim)
		{
			yield return null;
		}
		if (this.ExitStateAim != null)
		{
			this.ExitStateAim();
		}
		yield return null;
		if ((CurrentIntention == TeleportIntentions.PreTeleport || CurrentIntention == TeleportIntentions.Teleport) && _teleportDestination.IsValidDestination)
		{
			StartCoroutine(PreTeleportStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelAimStateCoroutine());
		}
	}

	protected IEnumerator CancelAimStateCoroutine()
	{
		CurrentState = States.CancelAim;
		if (this.EnterStateCancelAim != null)
		{
			this.EnterStateCancelAim();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator PreTeleportStateCoroutine()
	{
		CurrentState = States.PreTeleport;
		EnableMotion(EnableMovementDuringPreTeleport, EnableRotationDuringPreTeleport);
		if (this.EnterStatePreTeleport != null)
		{
			this.EnterStatePreTeleport();
		}
		while (CurrentIntention == TeleportIntentions.PreTeleport || IsPreTeleportRequested)
		{
			yield return null;
		}
		if (_teleportDestination.IsValidDestination)
		{
			StartCoroutine(TeleportingStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelTeleportStateCoroutine());
		}
	}

	protected IEnumerator CancelTeleportStateCoroutine()
	{
		CurrentState = States.CancelTeleport;
		if (this.EnterStateCancelTeleport != null)
		{
			this.EnterStateCancelTeleport();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator TeleportingStateCoroutine()
	{
		CurrentState = States.Teleporting;
		EnableMotion(enableLinear: false, enableRotation: false);
		if (this.EnterStateTeleporting != null)
		{
			this.EnterStateTeleporting();
		}
		while (IsTransitioning)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(PostTeleportStateCoroutine());
	}

	protected IEnumerator PostTeleportStateCoroutine()
	{
		CurrentState = States.PostTeleport;
		EnableMotion(EnableMovementDuringPostTeleport, EnableRotationDuringPostTeleport);
		if (this.EnterStatePostTeleport != null)
		{
			this.EnterStatePostTeleport();
		}
		while (IsPostTeleportRequested)
		{
			yield return null;
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	public void DoTeleport()
	{
		CapsuleCollider characterController = LocomotionController.CharacterController;
		Transform transform = characterController.transform;
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += characterController.height * 0.5f;
		Quaternion landingRotation = _teleportDestination.LandingRotation;
		if (this.Teleported != null)
		{
			this.Teleported(transform, position, landingRotation);
		}
		transform.position = position;
		transform.rotation = landingRotation;
	}

	public Vector3 GetCharacterPosition()
	{
		return LocomotionController.CharacterController.transform.position;
	}

	public Quaternion GetHeadRotationY()
	{
		Quaternion value = Quaternion.identity;
		InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.Head);
		if (deviceAtXRNode.isValid)
		{
			deviceAtXRNode.TryGetFeatureValue(CommonUsages.deviceRotation, out value);
		}
		Vector3 eulerAngles = value.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		return Quaternion.Euler(eulerAngles);
	}

	public void DoWarp(Vector3 startPos, float positionPercent)
	{
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += LocomotionController.CharacterController.height / 2f;
		Transform obj = LocomotionController.CharacterController.transform;
		Vector3 position2 = Vector3.Lerp(startPos, position, positionPercent);
		obj.position = position2;
	}
}
public class SimpleCapsuleWithStickMovement : MonoBehaviour
{
	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	public bool HMDRotatesPlayer = true;

	public bool RotationEitherThumbstick;

	public float RotationAngle = 45f;

	public float Speed;

	public OVRCameraRig CameraRig;

	private bool ReadyToSnapTurn;

	private Rigidbody _rigidbody;

	public event Action CameraUpdated;

	public event Action PreCharacterMove;

	private void Awake()
	{
		_rigidbody = GetComponent<Rigidbody>();
		if (CameraRig == null)
		{
			CameraRig = GetComponentInChildren<OVRCameraRig>();
		}
	}

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (this.CameraUpdated != null)
		{
			this.CameraUpdated();
		}
		if (this.PreCharacterMove != null)
		{
			this.PreCharacterMove();
		}
		if (HMDRotatesPlayer)
		{
			RotatePlayerToHMD();
		}
		if (EnableLinearMovement)
		{
			StickMovement();
		}
		if (EnableRotation)
		{
			SnapTurn();
		}
	}

	private void RotatePlayerToHMD()
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		Vector3 position = trackingSpace.position;
		Quaternion rotation = trackingSpace.rotation;
		base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
		trackingSpace.position = position;
		trackingSpace.rotation = rotation;
	}

	private void StickMovement()
	{
		Vector3 eulerAngles = CameraRig.centerEyeAnchor.rotation.eulerAngles;
		eulerAngles.z = (eulerAngles.x = 0f);
		Quaternion quaternion = Quaternion.Euler(eulerAngles);
		Vector3 zero = Vector3.zero;
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
		zero += quaternion * (vector.x * Vector3.right);
		zero += quaternion * (vector.y * Vector3.forward);
		_rigidbody.MovePosition(_rigidbody.position + zero * Speed * Time.fixedDeltaTime);
	}

	private void SnapTurn()
	{
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickLeft) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickLeft)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y -= RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickRight) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickRight)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y += RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else
		{
			ReadyToSnapTurn = true;
		}
		base.transform.rotation = Quaternion.Euler(eulerAngles);
	}
}
public abstract class TeleportAimHandler : TeleportSupport
{
	protected override void OnEnable()
	{
		base.OnEnable();
		base.LocomotionTeleport.AimHandler = this;
	}

	protected override void OnDisable()
	{
		if (base.LocomotionTeleport.AimHandler == this)
		{
			base.LocomotionTeleport.AimHandler = null;
		}
		base.OnDisable();
	}

	public abstract void GetPoints(List<Vector3> points);
}
public class TeleportAimHandlerLaser : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range = 100f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		points.Add(aimRay.origin);
		points.Add(aimRay.origin + aimRay.direction * Range);
	}
}
public class TeleportAimHandlerParabolic : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range;

	[Tooltip("The MinimumElevation is relative to the AimPosition.")]
	public float MinimumElevation = -100f;

	[Tooltip("The Gravity is used in conjunction with AimVelocity and the aim direction to simulate a projectile.")]
	public float Gravity = -9.8f;

	[Tooltip("The AimVelocity is the initial speed of the faked projectile.")]
	[Range(0.001f, 50f)]
	public float AimVelocity = 1f;

	[Tooltip("The AimStep is the how much to subdivide the iteration.")]
	[Range(0.001f, 1f)]
	public float AimStep = 1f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		Vector3 origin = aimRay.origin;
		Vector3 vector = aimRay.direction * AimVelocity;
		float num = Range * Range;
		do
		{
			points.Add(origin);
			Vector3 vector2 = vector;
			vector2.y += Gravity * (1f / 90f) * AimStep;
			vector = vector2;
			origin += vector2 * AimStep;
		}
		while (origin.y - aimRay.origin.y > MinimumElevation && (aimRay.origin - origin).sqrMagnitude <= num);
	}
}
public class TeleportAimVisualLaser : TeleportSupport
{
	[Tooltip("This prefab will be instantiated when the aim visual is awakened, and will be set active when the user is aiming, and deactivated when they are done aiming.")]
	public LineRenderer LaserPrefab;

	private readonly Action _enterAimStateAction;

	private readonly Action _exitAimStateAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	private LineRenderer _lineRenderer;

	private Vector3[] _linePoints;

	public TeleportAimVisualLaser()
	{
		_enterAimStateAction = EnterAimState;
		_exitAimStateAction = ExitAimState;
		_updateAimDataAction = UpdateAimData;
	}

	private void EnterAimState()
	{
		_lineRenderer.gameObject.SetActive(value: true);
	}

	private void ExitAimState()
	{
		_lineRenderer.gameObject.SetActive(value: false);
	}

	private void Awake()
	{
		LaserPrefab.gameObject.SetActive(value: false);
		_lineRenderer = UnityEngine.Object.Instantiate(LaserPrefab);
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim += _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateAim -= _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim -= _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
		base.RemoveEventHandlers();
	}

	private void UpdateAimData(LocomotionTeleport.AimData obj)
	{
		_lineRenderer.sharedMaterial.color = (obj.TargetValid ? Color.green : Color.red);
		List<Vector3> points = obj.Points;
		_lineRenderer.positionCount = points.Count;
		for (int i = 0; i < points.Count; i++)
		{
			_lineRenderer.SetPosition(i, points[i]);
		}
	}
}
public class TeleportDestination : MonoBehaviour
{
	[Tooltip("If the target handler provides a target position, this transform will be moved to that position and it's game object enabled. A target position being provided does not mean the position is valid, only that the aim handler found something to test as a destination.")]
	public Transform PositionIndicator;

	[Tooltip("This transform will be rotated to match the rotation of the aiming target. Simple teleport destinations should assign this to the object containing this component. More complex teleport destinations might assign this to a sub-object that is used to indicate the landing orientation independently from the rest of the destination indicator, such as when world space effects are required. This will typically be a child of the PositionIndicator.")]
	public Transform OrientationIndicator;

	[Tooltip("After the player teleports, the character controller will have it's rotation set to this value. It is different from the OrientationIndicator transform.rotation in order to support both head-relative and forward-facing teleport modes (See TeleportOrientationHandlerThumbstick.cs).")]
	public Quaternion LandingRotation;

	[NonSerialized]
	public LocomotionTeleport LocomotionTeleport;

	[NonSerialized]
	public LocomotionTeleport.States TeleportState;

	private readonly Action<bool, Vector3?, Quaternion?, Quaternion?> _updateTeleportDestinationAction;

	private bool _eventsActive;

	public bool IsValidDestination { get; private set; }

	public event Action<TeleportDestination> Deactivated;

	private TeleportDestination()
	{
		_updateTeleportDestinationAction = UpdateTeleportDestination;
	}

	public void OnEnable()
	{
		PositionIndicator.gameObject.SetActive(value: false);
		if (OrientationIndicator != null)
		{
			OrientationIndicator.gameObject.SetActive(value: false);
		}
		LocomotionTeleport.UpdateTeleportDestination += _updateTeleportDestinationAction;
		_eventsActive = true;
	}

	private void TryDisableEventHandlers()
	{
		if (_eventsActive)
		{
			LocomotionTeleport.UpdateTeleportDestination -= _updateTeleportDestinationAction;
			_eventsActive = false;
		}
	}

	public void OnDisable()
	{
		TryDisableEventHandlers();
	}

	public void OnDeactivated()
	{
		if (this.Deactivated != null)
		{
			this.Deactivated(this);
		}
		else
		{
			Recycle();
		}
	}

	public void Recycle()
	{
		LocomotionTeleport.RecycleTeleportDestination(this);
	}

	public virtual void UpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		IsValidDestination = isValidDestination;
		LandingRotation = landingRotation.GetValueOrDefault();
		GameObject gameObject = PositionIndicator.gameObject;
		bool activeInHierarchy = gameObject.activeInHierarchy;
		if (!position.HasValue)
		{
			if (activeInHierarchy)
			{
				gameObject.SetActive(value: false);
			}
			return;
		}
		if (!activeInHierarchy)
		{
			gameObject.SetActive(value: true);
		}
		base.transform.position = position.GetValueOrDefault();
		if (OrientationIndicator == null)
		{
			if (rotation.HasValue)
			{
				base.transform.rotation = rotation.GetValueOrDefault();
			}
			return;
		}
		GameObject gameObject2 = OrientationIndicator.gameObject;
		bool activeInHierarchy2 = gameObject2.activeInHierarchy;
		if (!rotation.HasValue)
		{
			if (activeInHierarchy2)
			{
				gameObject2.SetActive(value: false);
			}
			return;
		}
		OrientationIndicator.rotation = rotation.GetValueOrDefault();
		if (!activeInHierarchy2)
		{
			gameObject2.SetActive(value: true);
		}
	}
}
public abstract class TeleportInputHandler : TeleportSupport
{
	private readonly Action _startReadyAction;

	private readonly Action _startAimAction;

	protected TeleportInputHandler()
	{
		_startReadyAction = delegate
		{
			StartCoroutine(TeleportReadyCoroutine());
		};
		_startAimAction = delegate
		{
			StartCoroutine(TeleportAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.InputHandler = this;
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateReady += _startReadyAction;
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		if (base.LocomotionTeleport.InputHandler == this)
		{
			base.LocomotionTeleport.InputHandler = null;
		}
		base.LocomotionTeleport.EnterStateReady -= _startReadyAction;
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
		base.RemoveEventHandlers();
	}

	private IEnumerator TeleportReadyCoroutine()
	{
		while (GetIntention() != LocomotionTeleport.TeleportIntentions.Aim)
		{
			yield return null;
		}
		base.LocomotionTeleport.CurrentIntention = LocomotionTeleport.TeleportIntentions.Aim;
	}

	private IEnumerator TeleportAimCoroutine()
	{
		LocomotionTeleport.TeleportIntentions intention = GetIntention();
		while (intention == LocomotionTeleport.TeleportIntentions.Aim || intention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			base.LocomotionTeleport.CurrentIntention = intention;
			yield return null;
			intention = GetIntention();
		}
		base.LocomotionTeleport.CurrentIntention = intention;
	}

	public abstract LocomotionTeleport.TeleportIntentions GetIntention();

	public abstract void GetAimData(out Ray aimRay);
}
public class TeleportInputHandlerHMD : TeleportInputHandler
{
	[Tooltip("The button used to begin aiming for a teleport.")]
	public OVRInput.RawButton AimButton;

	[Tooltip("The button used to trigger the teleport after aiming. It can be the same button as the AimButton, however you cannot abort a teleport if it is.")]
	public OVRInput.RawButton TeleportButton;

	[Tooltip("When true, the system will not use the PreTeleport intention which will allow a teleport to occur on a button downpress. When false, the button downpress will trigger the PreTeleport intention and the Teleport intention when the button is released.")]
	public bool FastTeleport;

	public Transform Pointer { get; private set; }

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(TeleportButton))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (OVRInput.GetUp(TeleportButton))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.Get(AimButton))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (AimButton == TeleportButton)
		{
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
		aimRay = new Ray(centerEyeAnchor.position, centerEyeAnchor.forward);
	}
}
public class TeleportInputHandlerTouch : TeleportInputHandlerHMD
{
	public enum InputModes
	{
		CapacitiveButtonForAimAndTeleport,
		SeparateButtonsForAimAndTeleport,
		ThumbstickTeleport,
		ThumbstickTeleportForwardBackOnly
	}

	public enum AimCapTouchButtons
	{
		A,
		B,
		LeftTrigger,
		LeftThumbstick,
		RightTrigger,
		RightThumbstick,
		X,
		Y
	}

	public Transform LeftHand;

	public Transform RightHand;

	[Tooltip("CapacitiveButtonForAimAndTeleport=Activate aiming via cap touch detection, press the same button to teleport.\nSeparateButtonsForAimAndTeleport=Use one button to begin aiming, and another to trigger the teleport.\nThumbstickTeleport=Push a thumbstick to begin aiming, release to teleport.")]
	public InputModes InputMode;

	private readonly OVRInput.RawButton[] _rawButtons = new OVRInput.RawButton[8]
	{
		OVRInput.RawButton.A,
		OVRInput.RawButton.B,
		OVRInput.RawButton.LIndexTrigger,
		OVRInput.RawButton.LThumbstick,
		OVRInput.RawButton.RIndexTrigger,
		OVRInput.RawButton.RThumbstick,
		OVRInput.RawButton.X,
		OVRInput.RawButton.Y
	};

	private readonly OVRInput.RawTouch[] _rawTouch = new OVRInput.RawTouch[8]
	{
		OVRInput.RawTouch.A,
		OVRInput.RawTouch.B,
		OVRInput.RawTouch.LIndexTrigger,
		OVRInput.RawTouch.LThumbstick,
		OVRInput.RawTouch.RIndexTrigger,
		OVRInput.RawTouch.RThumbstick,
		OVRInput.RawTouch.X,
		OVRInput.RawTouch.Y
	};

	[Tooltip("Select the controller to be used for aiming. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller AimingController;

	private OVRInput.Controller InitiatingController;

	[Tooltip("Select the button to use for triggering aim and teleport when InputMode==CapacitiveButtonForAimAndTeleport")]
	public AimCapTouchButtons CapacitiveAimAndTeleportButton;

	[Tooltip("The thumbstick magnitude required to trigger aiming and teleports when InputMode==InputModes.ThumbstickTeleport")]
	public float ThumbstickTeleportThreshold = 0.5f;

	private void Start()
	{
	}

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (InputMode == InputModes.SeparateButtonsForAimAndTeleport)
		{
			return base.GetIntention();
		}
		if (InputMode == InputModes.ThumbstickTeleport || InputMode == InputModes.ThumbstickTeleportForwardBackOnly)
		{
			Vector2 lhs = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 lhs2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			OVRInput.Controller controller = OVRInput.Controller.Touch;
			bool flag = OVRInput.Get(OVRInput.RawTouch.LThumbstick);
			bool flag2 = OVRInput.Get(OVRInput.RawTouch.RThumbstick);
			if (InputMode == InputModes.ThumbstickTeleportForwardBackOnly && base.LocomotionTeleport.CurrentIntention != LocomotionTeleport.TeleportIntentions.Aim)
			{
				num = Mathf.Abs(Vector2.Dot(lhs, Vector2.up));
				num2 = Mathf.Abs(Vector2.Dot(lhs2, Vector2.up));
			}
			else
			{
				num = lhs.magnitude;
				num2 = lhs2.magnitude;
			}
			if (AimingController == OVRInput.Controller.LTouch)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else if (AimingController == OVRInput.Controller.RTouch)
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			else if (num > num2)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			if (!(num3 > ThumbstickTeleportThreshold) && (AimingController != OVRInput.Controller.Touch || !(flag || flag2)) && !(AimingController == OVRInput.Controller.LTouch && flag) && !(AimingController == OVRInput.Controller.RTouch && flag2))
			{
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
				{
					if (!FastTeleport)
					{
						return LocomotionTeleport.TeleportIntentions.PreTeleport;
					}
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
				{
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
			}
			else if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
			{
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			if (num3 > ThumbstickTeleportThreshold)
			{
				InitiatingController = controller;
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			return LocomotionTeleport.TeleportIntentions.None;
		}
		OVRInput.RawButton rawMask = _rawButtons[(int)CapacitiveAimAndTeleportButton];
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(rawMask))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (FastTeleport || OVRInput.GetUp(rawMask))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.GetDown(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && !OVRInput.GetUp(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		OVRInput.Controller controller = AimingController;
		if (controller == OVRInput.Controller.Touch)
		{
			controller = InitiatingController;
		}
		Transform transform = ((controller == OVRInput.Controller.LTouch) ? LeftHand : RightHand);
		aimRay = new Ray(transform.position, transform.forward);
	}
}
public abstract class TeleportOrientationHandler : TeleportSupport
{
	public enum OrientationModes
	{
		HeadRelative,
		ForwardFacing
	}

	private readonly Action _updateOrientationAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	protected LocomotionTeleport.AimData AimData;

	protected TeleportOrientationHandler()
	{
		_updateOrientationAction = delegate
		{
			StartCoroutine(UpdateOrientationCoroutine());
		};
		_updateAimDataAction = UpdateAimData;
	}

	private void UpdateAimData(LocomotionTeleport.AimData aimData)
	{
		AimData = aimData;
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
	}

	private IEnumerator UpdateOrientationCoroutine()
	{
		InitializeTeleportDestination();
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport)
		{
			if (AimData != null)
			{
				UpdateTeleportDestination();
			}
			yield return null;
		}
	}

	protected abstract void InitializeTeleportDestination();

	protected abstract void UpdateTeleportDestination();

	protected Quaternion GetLandingOrientation(OrientationModes mode, Quaternion rotation)
	{
		if (mode != 0)
		{
			return rotation * Quaternion.Euler(0f, 0f - base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.localEulerAngles.y, 0f);
		}
		return rotation;
	}
}
public class TeleportOrientationHandler360 : TeleportOrientationHandler
{
	protected override void InitializeTeleportDestination()
	{
	}

	protected override void UpdateTeleportDestination()
	{
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, null, null);
	}
}
public class TeleportOrientationHandlerHMD : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Should the destination orientation be updated during the aim state in addition to the PreTeleport state?")]
	public bool UpdateOrientationDuringAim;

	[Tooltip("How far from the destination must the HMD be pointing before using it for orientation")]
	public float AimDistanceThreshold;

	[Tooltip("How far from the destination must the HMD be pointing before rejecting the teleport")]
	public float AimDistanceMaxRange;

	private Quaternion _initialRotation;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = Quaternion.identity;
	}

	protected override void UpdateTeleportDestination()
	{
		if (AimData.Destination.HasValue && (UpdateOrientationDuringAim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport))
		{
			Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
			Vector3 valueOrDefault = AimData.Destination.GetValueOrDefault();
			if (new Plane(Vector3.up, valueOrDefault).Raycast(new Ray(centerEyeAnchor.position, centerEyeAnchor.forward), out var enter))
			{
				Vector3 vector = centerEyeAnchor.position + centerEyeAnchor.forward * enter - valueOrDefault;
				vector.y = 0f;
				float magnitude = vector.magnitude;
				if (magnitude > AimDistanceThreshold)
				{
					vector.Normalize();
					Quaternion quaternion = (_initialRotation = Quaternion.LookRotation(new Vector3(vector.x, 0f, vector.z), Vector3.up));
					if (AimDistanceMaxRange > 0f && magnitude > AimDistanceMaxRange)
					{
						AimData.TargetValid = false;
					}
					base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, quaternion, GetLandingOrientation(OrientationMode, quaternion));
					return;
				}
			}
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _initialRotation, GetLandingOrientation(OrientationMode, _initialRotation));
	}
}
public class TeleportOrientationHandlerThumbstick : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Which thumbstick is to be used for adjusting the teleport orientation. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller Thumbstick;

	[Tooltip("The orientation will only change if the thumbstick magnitude is above this value. This will usually be larger than the TeleportInputHandlerTouch.ThumbstickTeleportThreshold.")]
	public float RotateStickThreshold = 0.8f;

	private Quaternion _initialRotation;

	private Quaternion _currentRotation;

	private Vector2 _lastValidDirection;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
		_currentRotation = _initialRotation;
		_lastValidDirection = default(Vector2);
	}

	protected override void UpdateTeleportDestination()
	{
		float num;
		Vector2 lastValidDirection;
		if (Thumbstick == OVRInput.Controller.Touch)
		{
			Vector2 vector = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 vector2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float magnitude = vector.magnitude;
			float magnitude2 = vector2.magnitude;
			if (magnitude > magnitude2)
			{
				num = magnitude;
				lastValidDirection = vector;
			}
			else
			{
				num = magnitude2;
				lastValidDirection = vector2;
			}
		}
		else
		{
			lastValidDirection = ((Thumbstick != OVRInput.Controller.LTouch) ? OVRInput.Get(OVRInput.RawAxis2D.RThumbstick) : OVRInput.Get(OVRInput.RawAxis2D.LThumbstick));
			num = lastValidDirection.magnitude;
		}
		if (!AimData.TargetValid)
		{
			_lastValidDirection = default(Vector2);
		}
		if (num < RotateStickThreshold)
		{
			lastValidDirection = _lastValidDirection;
			num = lastValidDirection.magnitude;
			if (num < RotateStickThreshold)
			{
				_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
				lastValidDirection.x = 0f;
				lastValidDirection.y = 1f;
			}
		}
		else
		{
			_lastValidDirection = lastValidDirection;
		}
		Quaternion rotation = base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.rotation;
		if (num > RotateStickThreshold)
		{
			lastValidDirection /= num;
			Quaternion quaternion = _initialRotation * Quaternion.LookRotation(new Vector3(lastValidDirection.x, 0f, lastValidDirection.y), Vector3.up);
			_currentRotation = rotation * quaternion;
		}
		else
		{
			_currentRotation = rotation * base.LocomotionTeleport.GetHeadRotationY();
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _currentRotation, GetLandingOrientation(OrientationMode, _currentRotation));
	}
}
public class TeleportPoint : MonoBehaviour
{
	public float dimmingSpeed = 1f;

	public float fullIntensity = 1f;

	public float lowIntensity = 0.5f;

	public Transform destTransform;

	private float lastLookAtTime;

	private void Start()
	{
	}

	public Transform GetDestTransform()
	{
		return destTransform;
	}

	private void Update()
	{
		float value = Mathf.SmoothStep(fullIntensity, lowIntensity, (Time.time - lastLookAtTime) * dimmingSpeed);
		GetComponent<MeshRenderer>().material.SetFloat("_Intensity", value);
	}

	public void OnLookAt()
	{
		lastLookAtTime = Time.time;
	}
}
public abstract class TeleportSupport : MonoBehaviour
{
	private bool _eventsActive;

	protected LocomotionTeleport LocomotionTeleport { get; private set; }

	protected virtual void OnEnable()
	{
		LocomotionTeleport = GetComponent<LocomotionTeleport>();
		Debug.Assert(!_eventsActive);
		AddEventHandlers();
		Debug.Assert(_eventsActive);
	}

	protected virtual void OnDisable()
	{
		Debug.Assert(_eventsActive);
		RemoveEventHandlers();
		Debug.Assert(!_eventsActive);
		LocomotionTeleport = null;
	}

	[Conditional("DEBUG_TELEPORT_EVENT_HANDLERS")]
	private void LogEventHandler(string msg)
	{
		Debug.Log("EventHandler: " + GetType().Name + ": " + msg);
	}

	protected virtual void AddEventHandlers()
	{
		_eventsActive = true;
	}

	protected virtual void RemoveEventHandlers()
	{
		_eventsActive = false;
	}
}
public abstract class TeleportTargetHandler : TeleportSupport
{
	[Tooltip("This bitmask controls which game object layers will be included in the targeting collision tests.")]
	public LayerMask AimCollisionLayerMask;

	protected readonly LocomotionTeleport.AimData AimData = new LocomotionTeleport.AimData();

	private readonly Action _startAimAction;

	private readonly List<Vector3> _aimPoints = new List<Vector3>();

	private const float ERROR_MARGIN = 0.1f;

	protected TeleportTargetHandler()
	{
		_startAimAction = delegate
		{
			StartCoroutine(TargetAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
	}

	private IEnumerator TargetAimCoroutine()
	{
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim)
		{
			ResetAimData();
			Vector3 start = base.LocomotionTeleport.transform.position;
			_aimPoints.Clear();
			base.LocomotionTeleport.AimHandler.GetPoints(_aimPoints);
			for (int i = 0; i < _aimPoints.Count; i++)
			{
				Vector3 end = _aimPoints[i];
				AimData.TargetValid = ConsiderTeleport(start, ref end);
				AimData.Points.Add(end);
				if (AimData.TargetValid)
				{
					AimData.Destination = ConsiderDestination(end);
					AimData.TargetValid = AimData.Destination.HasValue;
					break;
				}
				start = _aimPoints[i];
			}
			base.LocomotionTeleport.OnUpdateAimData(AimData);
			yield return null;
		}
	}

	protected virtual void ResetAimData()
	{
		AimData.Reset();
	}

	protected abstract bool ConsiderTeleport(Vector3 start, ref Vector3 end);

	public virtual Vector3? ConsiderDestination(Vector3 location)
	{
		CapsuleCollider characterController = base.LocomotionTeleport.LocomotionController.CharacterController;
		float num = characterController.radius - 0.1f;
		Vector3 vector = location;
		vector.y += num + 0.1f;
		Vector3 end = vector;
		end.y += characterController.height - 0.1f;
		if (Physics.CheckCapsule(vector, end, num, AimCollisionLayerMask, QueryTriggerInteraction.Ignore))
		{
			return null;
		}
		return location;
	}
}
public class TeleportTargetHandlerNavMesh : TeleportTargetHandler
{
	public int NavMeshAreaMask = -1;

	private NavMeshPath _path;

	private void Awake()
	{
		_path = new NavMeshPath();
	}

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}

	public override Vector3? ConsiderDestination(Vector3 location)
	{
		Vector3? result = base.ConsiderDestination(location);
		if (result.HasValue)
		{
			Vector3 characterPosition = base.LocomotionTeleport.GetCharacterPosition();
			Vector3 valueOrDefault = result.GetValueOrDefault();
			NavMesh.CalculatePath(characterPosition, valueOrDefault, NavMeshAreaMask, _path);
			if (_path.status == NavMeshPathStatus.PathComplete)
			{
				return result;
			}
		}
		return null;
	}

	[Conditional("SHOW_PATH_RESULT")]
	private void OnDrawGizmos()
	{
	}
}
public class TeleportTargetHandlerNode : TeleportTargetHandler
{
	[Tooltip("When checking line of sight to the destination, add this value to the vertical offset for targeting collision checks.")]
	public float LOSOffset = 1f;

	[Tooltip("Teleport logic will only work with TeleportPoint components that exist in the layers specified by this mask.")]
	public LayerMask TeleportLayerMask;

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (!base.LocomotionTeleport.AimCollisionTest(start, end, (int)AimCollisionLayerMask | (int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		TeleportPoint component = AimData.TargetHitInfo.collider.gameObject.GetComponent<TeleportPoint>();
		if (component == null)
		{
			return false;
		}
		Vector3 position = component.destTransform.position;
		Vector3 end2 = new Vector3(position.x, position.y + LOSOffset, position.z);
		if (base.LocomotionTeleport.AimCollisionTest(start, end2, (int)AimCollisionLayerMask & ~(int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		end = position;
		return true;
	}
}
public class TeleportTargetHandlerPhysical : TeleportTargetHandler
{
	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}
}
public abstract class TeleportTransition : TeleportSupport
{
	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting += LocomotionTeleportOnEnterStateTeleporting;
		base.AddEventHandlers();
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting -= LocomotionTeleportOnEnterStateTeleporting;
		base.RemoveEventHandlers();
	}

	protected abstract void LocomotionTeleportOnEnterStateTeleporting();
}
public class TeleportTransitionBlink : TeleportTransition
{
	[Tooltip("How long the transition takes. Usually this is greater than Teleport Delay.")]
	[Range(0.01f, 2f)]
	public float TransitionDuration = 0.5f;

	[Tooltip("At what percentage of the elapsed transition time does the teleport occur?")]
	[Range(0f, 1f)]
	public float TeleportDelay = 0.5f;

	[Tooltip("Fade to black over the duration of the transition")]
	public AnimationCurve FadeLevels = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f));

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(BlinkCoroutine());
	}

	protected IEnumerator BlinkCoroutine()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		float elapsedTime = 0f;
		float teleportTime = TransitionDuration * TeleportDelay;
		bool teleported = false;
		while (elapsedTime < TransitionDuration)
		{
			yield return null;
			elapsedTime += Time.deltaTime;
			if (!teleported && elapsedTime >= teleportTime)
			{
				teleported = true;
				base.LocomotionTeleport.DoTeleport();
			}
		}
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public class TeleportTransitionInstant : TeleportTransition
{
	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		base.LocomotionTeleport.DoTeleport();
	}
}
public class TeleportTransitionWarp : TeleportTransition
{
	[Tooltip("How much time the warp transition takes to complete.")]
	[Range(0.01f, 1f)]
	public float TransitionDuration = 0.5f;

	[HideInInspector]
	public AnimationCurve PositionLerp = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(DoWarp());
	}

	private IEnumerator DoWarp()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		Vector3 startPosition = base.LocomotionTeleport.GetCharacterPosition();
		float elapsedTime = 0f;
		while (elapsedTime < TransitionDuration)
		{
			elapsedTime += Time.deltaTime;
			float time = elapsedTime / TransitionDuration;
			float positionPercent = PositionLerp.Evaluate(time);
			base.LocomotionTeleport.DoWarp(startPosition, positionPercent);
			yield return null;
		}
		base.LocomotionTeleport.DoWarp(startPosition, 1f);
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public static class NativeVideoPlayer
{
	public enum PlabackState
	{
		Idle = 1,
		Preparing,
		Buffering,
		Ready,
		Ended
	}

	private static IntPtr? _Activity;

	private static IntPtr? _VideoPlayerClass;

	private static readonly jvalue[] EmptyParams = new jvalue[0];

	private static IntPtr getIsPlayingMethodId;

	private static IntPtr getCurrentPlaybackStateMethodId;

	private static IntPtr getDurationMethodId;

	private static IntPtr getPlaybackPositionMethodId;

	private static IntPtr setPlaybackPositionMethodId;

	private static jvalue[] setPlaybackPositionParams;

	private static IntPtr playVideoMethodId;

	private static jvalue[] playVideoParams;

	private static IntPtr stopMethodId;

	private static IntPtr resumeMethodId;

	private static IntPtr pauseMethodId;

	private static IntPtr setPlaybackSpeedMethodId;

	private static jvalue[] setPlaybackSpeedParams;

	private static IntPtr setLoopingMethodId;

	private static jvalue[] setLoopingParams;

	private static IntPtr setListenerRotationQuaternionMethodId;

	private static jvalue[] setListenerRotationQuaternionParams;

	private static IntPtr VideoPlayerClass
	{
		get
		{
			if (!_VideoPlayerClass.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/oculus/videoplayer/NativeVideoPlayer");
					if (intPtr != IntPtr.Zero)
					{
						_VideoPlayerClass = AndroidJNI.NewGlobalRef(intPtr);
						AndroidJNI.DeleteLocalRef(intPtr);
					}
					else
					{
						Debug.LogError("Failed to find NativeVideoPlayer class");
						_VideoPlayerClass = IntPtr.Zero;
					}
				}
				catch (Exception exception)
				{
					Debug.LogError("Failed to find NativeVideoPlayer class");
					Debug.LogException(exception);
					_VideoPlayerClass = IntPtr.Zero;
				}
			}
			return _VideoPlayerClass.GetValueOrDefault();
		}
	}

	private static IntPtr Activity
	{
		get
		{
			if (!_Activity.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/unity3d/player/UnityPlayer");
					IntPtr staticFieldID = AndroidJNI.GetStaticFieldID(intPtr, "currentActivity", "Landroid/app/Activity;");
					IntPtr staticObjectField = AndroidJNI.GetStaticObjectField(intPtr, staticFieldID);
					_Activity = AndroidJNI.NewGlobalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(intPtr);
				}
				catch (Exception exception)
				{
					Debug.LogException(exception);
					_Activity = IntPtr.Zero;
				}
			}
			return _Activity.GetValueOrDefault();
		}
	}

	public static bool IsAvailable => VideoPlayerClass != IntPtr.Zero;

	public static bool IsPlaying
	{
		get
		{
			if (getIsPlayingMethodId == IntPtr.Zero)
			{
				getIsPlayingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getIsPlaying", "()Z");
			}
			return AndroidJNI.CallStaticBooleanMethod(VideoPlayerClass, getIsPlayingMethodId, EmptyParams);
		}
	}

	public static PlabackState CurrentPlaybackState
	{
		get
		{
			if (getCurrentPlaybackStateMethodId == IntPtr.Zero)
			{
				getCurrentPlaybackStateMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getCurrentPlaybackState", "()I");
			}
			return (PlabackState)AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getCurrentPlaybackStateMethodId, EmptyParams);
		}
	}

	public static long Duration
	{
		get
		{
			if (getDurationMethodId == IntPtr.Zero)
			{
				getDurationMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getDuration", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getDurationMethodId, EmptyParams);
		}
	}

	public static long PlaybackPosition
	{
		get
		{
			if (getPlaybackPositionMethodId == IntPtr.Zero)
			{
				getPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getPlaybackPosition", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getPlaybackPositionMethodId, EmptyParams);
		}
		set
		{
			if (setPlaybackPositionMethodId == IntPtr.Zero)
			{
				setPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackPosition", "(J)V");
				setPlaybackPositionParams = new jvalue[1];
			}
			setPlaybackPositionParams[0].j = value;
			AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackPositionMethodId, setPlaybackPositionParams);
		}
	}

	public static void PlayVideo(string path, string drmLicenseUrl, IntPtr surfaceObj)
	{
		if (playVideoMethodId == IntPtr.Zero)
		{
			playVideoMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "playVideo", "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;Landroid/view/Surface;)V");
			playVideoParams = new jvalue[4];
		}
		IntPtr intPtr = AndroidJNI.NewStringUTF(path);
		IntPtr intPtr2 = AndroidJNI.NewStringUTF(drmLicenseUrl);
		playVideoParams[0].l = Activity;
		playVideoParams[1].l = intPtr;
		playVideoParams[2].l = intPtr2;
		playVideoParams[3].l = surfaceObj;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, playVideoMethodId, playVideoParams);
		AndroidJNI.DeleteLocalRef(intPtr);
		AndroidJNI.DeleteLocalRef(intPtr2);
	}

	public static void Stop()
	{
		if (stopMethodId == IntPtr.Zero)
		{
			stopMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "stop", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, stopMethodId, EmptyParams);
	}

	public static void Play()
	{
		if (resumeMethodId == IntPtr.Zero)
		{
			resumeMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "resume", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, resumeMethodId, EmptyParams);
	}

	public static void Pause()
	{
		if (pauseMethodId == IntPtr.Zero)
		{
			pauseMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "pause", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, pauseMethodId, EmptyParams);
	}

	public static void SetPlaybackSpeed(float speed)
	{
		if (setPlaybackSpeedMethodId == IntPtr.Zero)
		{
			setPlaybackSpeedMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackSpeed", "(F)V");
			setPlaybackSpeedParams = new jvalue[1];
		}
		setPlaybackSpeedParams[0].f = speed;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackSpeedMethodId, setPlaybackSpeedParams);
	}

	public static void SetLooping(bool looping)
	{
		if (setLoopingMethodId == IntPtr.Zero)
		{
			setLoopingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setLooping", "(Z)V");
			setLoopingParams = new jvalue[1];
		}
		setLoopingParams[0].z = looping;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setLoopingMethodId, setLoopingParams);
	}

	public static void SetListenerRotation(Quaternion rotation)
	{
		if (setListenerRotationQuaternionMethodId == IntPtr.Zero)
		{
			setListenerRotationQuaternionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setListenerRotationQuaternion", "(FFFF)V");
			setListenerRotationQuaternionParams = new jvalue[4];
		}
		setListenerRotationQuaternionParams[0].f = rotation.x;
		setListenerRotationQuaternionParams[1].f = rotation.y;
		setListenerRotationQuaternionParams[2].f = rotation.z;
		setListenerRotationQuaternionParams[3].f = rotation.w;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setListenerRotationQuaternionMethodId, setListenerRotationQuaternionParams);
	}
}
public class ButtonDownListener : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public event Action onButtonDown;

	public void OnPointerDown(PointerEventData eventData)
	{
		if (this.onButtonDown != null)
		{
			this.onButtonDown();
		}
	}
}
public class MediaPlayerImage : Image
{
	public enum ButtonType
	{
		Play,
		Pause,
		FastForward,
		Rewind,
		SkipForward,
		SkipBack,
		Stop
	}

	[SerializeField]
	private ButtonType m_ButtonType;

	public ButtonType buttonType
	{
		get
		{
			return m_ButtonType;
		}
		set
		{
			if (m_ButtonType != value)
			{
				m_ButtonType = value;
				SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper toFill)
	{
		Rect pixelAdjustedRect = GetPixelAdjustedRect();
		Vector4 vector = new Vector4(pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height);
		Color32 color = this.color;
		toFill.Clear();
		switch (m_ButtonType)
		{
		case ButtonType.Play:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			break;
		case ButtonType.Pause:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.w), color, new Vector2(0.35f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.y), color, new Vector2(0.35f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.y), color, new Vector2(0.65f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.w), color, new Vector2(0.65f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(6, 7, 4);
			break;
		case ButtonType.FastForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.Rewind:
			toFill.AddVert(new Vector3(vector.x, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.SkipForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.4375f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.y), color, new Vector2(0.4375f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.w), color, new Vector2(0.4375f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.875f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.y), color, new Vector2(0.875f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.w), color, new Vector2(0.875f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			toFill.AddTriangle(6, 7, 8);
			toFill.AddTriangle(8, 9, 6);
			break;
		case ButtonType.SkipBack:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.w), color, new Vector2(0.125f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.y), color, new Vector2(0.125f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.125f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.w), color, new Vector2(0.5625f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.y), color, new Vector2(0.5625f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5625f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(7, 8, 9);
			break;
		default:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			break;
		}
	}
}
public class MoviePlayerSample : MonoBehaviour
{
	public enum VideoShape
	{
		_360,
		_180,
		Quad
	}

	public enum VideoStereo
	{
		Mono,
		TopBottom,
		LeftRight,
		BottomTop
	}

	private bool videoPausedBeforeAppPause;

	private VideoPlayer videoPlayer;

	private OVROverlay overlay;

	private Renderer mediaRenderer;

	private RenderTexture copyTexture;

	private Material externalTex2DMaterial;

	public string MovieName;

	public string DrmLicenseUrl;

	public bool LoopVideo;

	public VideoShape Shape;

	public VideoStereo Stereo;

	public bool DisplayMono;

	private VideoShape _LastShape = (VideoShape)(-1);

	private VideoStereo _LastStereo = (VideoStereo)(-1);

	private bool _LastDisplayMono;

	public bool IsPlaying { get; private set; }

	public long Duration { get; private set; }

	public long PlaybackPosition { get; private set; }

	private void Awake()
	{
		Debug.Log("MovieSample Awake");
		mediaRenderer = GetComponent<Renderer>();
		videoPlayer = GetComponent<VideoPlayer>();
		if (videoPlayer == null)
		{
			videoPlayer = base.gameObject.AddComponent<VideoPlayer>();
		}
		videoPlayer.isLooping = LoopVideo;
		overlay = GetComponent<OVROverlay>();
		if (overlay == null)
		{
			overlay = base.gameObject.AddComponent<OVROverlay>();
		}
		overlay.enabled = false;
		overlay.isExternalSurface = NativeVideoPlayer.IsAvailable;
		overlay.enabled = overlay.currentOverlayShape != OVROverlay.OverlayShape.Equirect || UnityEngine.Application.platform == RuntimePlatform.Android;
	}

	private bool IsLocalVideo(string movieName)
	{
		return !movieName.Contains("://");
	}

	private void UpdateShapeAndStereo()
	{
		if (Shape != _LastShape || Stereo != _LastStereo || DisplayMono != _LastDisplayMono)
		{
			Rect rect = new Rect(0f, 0f, 1f, 1f);
			switch (Shape)
			{
			case VideoShape._360:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				break;
			case VideoShape._180:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				rect = new Rect(0.25f, 0f, 0.5f, 1f);
				break;
			default:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
				break;
			}
			overlay.overrideTextureRectMatrix = true;
			Rect rect2 = new Rect(0f, 0f, 1f, 1f);
			Rect rect3 = new Rect(0f, 0f, 1f, 1f);
			switch (Stereo)
			{
			case VideoStereo.LeftRight:
				rect2 = new Rect(0f, 0f, 0.5f, 1f);
				rect3 = new Rect(0.5f, 0f, 0.5f, 1f);
				break;
			case VideoStereo.TopBottom:
				rect2 = new Rect(0f, 0.5f, 1f, 0.5f);
				rect3 = new Rect(0f, 0f, 1f, 0.5f);
				break;
			case VideoStereo.BottomTop:
				rect2 = new Rect(0f, 0f, 1f, 0.5f);
				rect3 = new Rect(0f, 0.5f, 1f, 0.5f);
				break;
			}
			overlay.invertTextureRects = false;
			overlay.SetSrcDestRects(rect2, DisplayMono ? rect2 : rect3, rect, rect);
			_LastDisplayMono = DisplayMono;
			_LastStereo = Stereo;
			_LastShape = Shape;
		}
	}

	private IEnumerator Start()
	{
		if (mediaRenderer.material == null)
		{
			Debug.LogError("No material for movie surface");
			yield break;
		}
		yield return new WaitForSeconds(1f);
		if (!string.IsNullOrEmpty(MovieName))
		{
			if (IsLocalVideo(MovieName))
			{
				Play(UnityEngine.Application.streamingAssetsPath + "/" + MovieName, null);
			}
			else
			{
				Play(MovieName, DrmLicenseUrl);
			}
		}
	}

	public void Play(string moviePath, string drmLicencesUrl)
	{
		if (moviePath != string.Empty)
		{
			Debug.Log("Playing Video: " + moviePath);
			if (overlay.isExternalSurface)
			{
				OVROverlay.ExternalSurfaceObjectCreated externalSurfaceObjectCreated = delegate
				{
					Debug.Log("Playing ExoPlayer with SurfaceObject");
					NativeVideoPlayer.PlayVideo(moviePath, drmLicencesUrl, overlay.externalSurfaceObject);
					NativeVideoPlayer.SetLooping(LoopVideo);
				};
				if (overlay.externalSurfaceObject == IntPtr.Zero)
				{
					overlay.externalSurfaceObjectCreated = externalSurfaceObjectCreated;
				}
				else
				{
					externalSurfaceObjectCreated();
				}
			}
			else
			{
				Debug.Log("Playing Unity VideoPlayer");
				videoPlayer.url = moviePath;
				videoPlayer.Prepare();
				videoPlayer.Play();
			}
			Debug.Log("MovieSample Start");
			IsPlaying = true;
		}
		else
		{
			Debug.LogError("No media file name provided");
		}
	}

	public void Play()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Play();
		}
		else
		{
			videoPlayer.Play();
		}
		IsPlaying = true;
	}

	public void Pause()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Pause();
		}
		else
		{
			videoPlayer.Pause();
		}
		IsPlaying = false;
	}

	public void SeekTo(long position)
	{
		long num = Math.Max(0L, Math.Min(Duration, position));
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.PlaybackPosition = num;
		}
		else
		{
			videoPlayer.time = (double)num / 1000.0;
		}
	}

	private void Update()
	{
		UpdateShapeAndStereo();
		if (!overlay.isExternalSurface)
		{
			Texture texture = ((videoPlayer.texture != null) ? videoPlayer.texture : Texture2D.blackTexture);
			if (overlay.enabled)
			{
				if (overlay.textures[0] != texture)
				{
					overlay.enabled = false;
					overlay.textures[0] = texture;
					overlay.enabled = true;
				}
			}
			else
			{
				mediaRenderer.material.mainTexture = texture;
				mediaRenderer.material.SetVector("_SrcRectLeft", overlay.srcRectLeft.ToVector());
				mediaRenderer.material.SetVector("_SrcRectRight", overlay.srcRectRight.ToVector());
			}
			IsPlaying = videoPlayer.isPlaying;
			PlaybackPosition = (long)(videoPlayer.time * 1000.0);
			Duration = (long)(videoPlayer.length * 1000.0);
		}
		else
		{
			NativeVideoPlayer.SetListenerRotation(Camera.main.transform.rotation);
			IsPlaying = NativeVideoPlayer.IsPlaying;
			PlaybackPosition = NativeVideoPlayer.PlaybackPosition;
			Duration = NativeVideoPlayer.Duration;
			if (IsPlaying && (int)OVRManager.display.displayFrequency != 60)
			{
				OVRManager.display.displayFrequency = 60f;
			}
			else if (!IsPlaying && (int)OVRManager.display.displayFrequency != 72)
			{
				OVRManager.display.displayFrequency = 72f;
			}
		}
	}

	public void SetPlaybackSpeed(float speed)
	{
		speed = Mathf.Max(0f, speed);
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.SetPlaybackSpeed(speed);
		}
		else
		{
			videoPlayer.playbackSpeed = speed;
		}
	}

	public void Stop()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Stop();
		}
		else
		{
			videoPlayer.Stop();
		}
		IsPlaying = false;
	}

	private void OnApplicationPause(bool appWasPaused)
	{
		Debug.Log("OnApplicationPause: " + appWasPaused);
		if (appWasPaused)
		{
			videoPausedBeforeAppPause = !IsPlaying;
		}
		if (!videoPausedBeforeAppPause)
		{
			if (appWasPaused)
			{
				Pause();
			}
			else
			{
				Play();
			}
		}
	}
}
public class MoviePlayerSampleControls : MonoBehaviour
{
	private enum PlaybackState
	{
		Playing,
		Paused,
		Rewinding,
		FastForwarding
	}

	public MoviePlayerSample Player;

	public OVRInputModule InputModule;

	public OVRGazePointer GazePointer;

	public GameObject LeftHand;

	public GameObject RightHand;

	public Canvas Canvas;

	public ButtonDownListener PlayPause;

	public MediaPlayerImage PlayPauseImage;

	public Slider ProgressBar;

	public ButtonDownListener FastForward;

	public MediaPlayerImage FastForwardImage;

	public ButtonDownListener Rewind;

	public MediaPlayerImage RewindImage;

	public float TimeoutTime = 10f;

	private bool _isVisible;

	private float _lastButtonTime;

	private bool _didSeek;

	private long _seekPreviousPosition;

	private long _rewindStartPosition;

	private float _rewindStartTime;

	private PlaybackState _state;

	private void Start()
	{
		PlayPause.onButtonDown += OnPlayPauseClicked;
		FastForward.onButtonDown += OnFastForwardClicked;
		Rewind.onButtonDown += OnRewindClicked;
		ProgressBar.onValueChanged.AddListener(OnSeekBarMoved);
		PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
		FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
		RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
		SetVisible(visible: false);
	}

	private void OnPlayPauseClicked()
	{
		switch (_state)
		{
		case PlaybackState.Paused:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.FastForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.Rewind;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Playing:
			Player.Pause();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
			_state = PlaybackState.Paused;
			break;
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		}
	}

	private void OnFastForwardClicked()
	{
		switch (_state)
		{
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			Player.SetPlaybackSpeed(2f);
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Playing:
			Player.SetPlaybackSpeed(2f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition + 15000);
			break;
		}
	}

	private void OnRewindClicked()
	{
		switch (_state)
		{
		case PlaybackState.Playing:
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			Player.Pause();
			_rewindStartPosition = Player.PlaybackPosition;
			_rewindStartTime = Time.time;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.Rewinding;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition - 15000);
			break;
		}
	}

	private void OnSeekBarMoved(float value)
	{
		long num = (long)(value * (float)Player.Duration);
		if (Mathf.Abs(num - Player.PlaybackPosition) > 200f)
		{
			Seek(num);
		}
	}

	private void Seek(long pos)
	{
		_didSeek = true;
		_seekPreviousPosition = Player.PlaybackPosition;
		Player.SeekTo(pos);
	}

	private void Update()
	{
		if (OVRInput.Get(OVRInput.Button.One) || OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.Get(OVRInput.Button.SecondaryIndexTrigger))
		{
			_lastButtonTime = Time.time;
			if (!_isVisible)
			{
				SetVisible(visible: true);
			}
		}
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			InputModule.rayTransform = LeftHand.transform;
			GazePointer.rayTransform = LeftHand.transform;
		}
		else
		{
			InputModule.rayTransform = RightHand.transform;
			GazePointer.rayTransform = RightHand.transform;
		}
		if (OVRInput.Get(OVRInput.Button.Back) && _isVisible)
		{
			SetVisible(visible: false);
		}
		if (_state == PlaybackState.Rewinding)
		{
			ProgressBar.value = Mathf.Clamp01(((float)_rewindStartPosition - 1000f * (Time.time - _rewindStartTime)) / (float)Player.Duration);
		}
		if (_isVisible && _state == PlaybackState.Playing && Time.time - _lastButtonTime > TimeoutTime)
		{
			SetVisible(visible: false);
		}
		if (_isVisible && (!_didSeek || Mathf.Abs(_seekPreviousPosition - Player.PlaybackPosition) > 50f))
		{
			_didSeek = false;
			if (Player.Duration > 0)
			{
				ProgressBar.value = (float)((double)Player.PlaybackPosition / (double)Player.Duration);
			}
			else
			{
				ProgressBar.value = 0f;
			}
		}
	}

	private void SetVisible(bool visible)
	{
		Canvas.enabled = visible;
		_isVisible = visible;
		Player.DisplayMono = visible;
		LeftHand.SetActive(visible);
		RightHand.SetActive(visible);
		Debug.Log("Controls Visible: " + visible);
	}
}
public static class VectorUtil
{
	public static Vector4 ToVector(this Rect rect)
	{
		return new Vector4(rect.x, rect.y, rect.width, rect.height);
	}
}
public class DebugUISample : MonoBehaviour
{
	private bool inMenu;

	private Text sliderText;

	private void Start()
	{
		DebugUIBuilder.instance.AddButton("Button Pressed", LogButtonPressed);
		DebugUIBuilder.instance.AddLabel("Label");
		RectTransform rectTransform = DebugUIBuilder.instance.AddSlider("Slider", 1f, 10f, SliderPressed, wholeNumbersOnly: true);
		Text[] componentsInChildren = rectTransform.GetComponentsInChildren<Text>();
		sliderText = componentsInChildren[1];
		sliderText.text = rectTransform.GetComponentInChildren<Slider>().value.ToString();
		DebugUIBuilder.instance.AddDivider();
		DebugUIBuilder.instance.AddToggle("Toggle", TogglePressed);
		DebugUIBuilder.instance.AddRadio("Radio1", "group", delegate(Toggle t)
		{
			RadioPressed("Radio1", "group", t);
		});
		DebugUIBuilder.instance.AddRadio("Radio2", "group", delegate(Toggle t)
		{
			RadioPressed("Radio2", "group", t);
		});
		DebugUIBuilder.instance.AddLabel("Secondary Tab", 1);
		DebugUIBuilder.instance.AddDivider(1);
		DebugUIBuilder.instance.AddRadio("Side Radio 1", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 1", "group2", t);
		}, 1);
		DebugUIBuilder.instance.AddRadio("Side Radio 2", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 2", "group2", t);
		}, 1);
		DebugUIBuilder.instance.Show();
		inMenu = true;
	}

	public void TogglePressed(Toggle t)
	{
		Debug.Log("Toggle pressed. Is on? " + t.isOn);
	}

	public void RadioPressed(string radioLabel, string group, Toggle t)
	{
		Debug.Log("Radio value changed: " + radioLabel + ", from group " + group + ". New value: " + t.isOn);
	}

	public void SliderPressed(float f)
	{
		Debug.Log("Slider: " + f);
		sliderText.text = f.ToString();
	}

	private void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	private void LogButtonPressed()
	{
		Debug.Log("Button pressed");
	}
}
public class HandsActiveChecker : MonoBehaviour
{
	[SerializeField]
	private GameObject _notificationPrefab;

	private GameObject _notification;

	private OVRCameraRig _cameraRig;

	private Transform _centerEye;

	private void Awake()
	{
		_notification = UnityEngine.Object.Instantiate(_notificationPrefab);
		StartCoroutine(GetCenterEye());
	}

	private void Update()
	{
		if (OVRPlugin.GetHandTrackingEnabled())
		{
			_notification.SetActive(value: false);
			return;
		}
		_notification.SetActive(value: true);
		if ((bool)_centerEye)
		{
			_notification.transform.position = _centerEye.position + _centerEye.forward * 0.5f;
			_notification.transform.rotation = _centerEye.rotation;
		}
	}

	private IEnumerator GetCenterEye()
	{
		if ((_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>()) != null)
		{
			while (!_centerEye)
			{
				_centerEye = _cameraRig.centerEyeAnchor;
				yield return null;
			}
		}
	}
}
[ExecuteInEditMode]
public class CharacterCapsule : MonoBehaviour
{
	private CharacterController _character;

	private MeshFilter _meshFilter;

	private float _height;

	private float _radius;

	[Range(4f, 32f)]
	public int SubdivisionsU;

	[Range(4f, 32f)]
	public int SubdivisionsV;

	private int _subdivisionU;

	private int _subdivisionV;

	private Vector3[] _vertices;

	private int[] _triangles;

	private void Update()
	{
		if (_character == null)
		{
			_character = GetComponentInParent<CharacterController>();
			if (_character == null)
			{
				return;
			}
		}
		if (_height == _character.height && _radius == _character.radius && _subdivisionU == SubdivisionsU && _subdivisionV == SubdivisionsV)
		{
			return;
		}
		_height = _character.height;
		_radius = _character.radius;
		_subdivisionU = SubdivisionsU;
		_subdivisionV = SubdivisionsV;
		List<Vector3> list = new List<Vector3>();
		Vector3 vector = new Vector3(1f, 0f, 0f);
		Vector3 vector2 = new Vector3(0f, _height / 2f - _radius, 0f);
		Vector3 vector3 = new Vector3(0f, _radius - _height / 2f, 0f);
		list.Add(new Vector3(0f, _height / 2f, 0f));
		for (int num = SubdivisionsU - 1; num >= 0; num--)
		{
			float num2 = (float)num / (float)SubdivisionsU;
			for (int i = 0; i < SubdivisionsV; i++)
			{
				float num3 = (float)i / (float)SubdivisionsV;
				Vector3 item = Quaternion.Euler(0f, num3 * 360f, num2 * 90f) * vector * _radius + vector2;
				list.Add(item);
			}
		}
		for (int j = 0; j < SubdivisionsU; j++)
		{
			float num4 = (float)j / (float)SubdivisionsU;
			for (int k = 0; k < SubdivisionsV; k++)
			{
				float num5 = (float)k / (float)SubdivisionsV;
				Vector3 vector4 = Quaternion.Euler(0f, num5 * 360f + 180f, num4 * 90f) * vector;
				vector4 *= _radius;
				Vector3 item2 = vector3 - vector4;
				list.Add(item2);
			}
		}
		list.Add(new Vector3(0f, (0f - _height) / 2f, 0f));
		List<int> list2 = new List<int>();
		int item3;
		for (int l = 0; l < SubdivisionsV; l++)
		{
			item3 = 0;
			list2.Add(item3);
			list2.Add(l);
			list2.Add(l + 1);
		}
		list2.Add(0);
		list2.Add(SubdivisionsV);
		list2.Add(1);
		int num6;
		for (int m = 0; m < SubdivisionsU - 1; m++)
		{
			num6 = m * SubdivisionsV + 1;
			for (int n = 0; n < SubdivisionsV - 1; n++)
			{
				item3 = num6 + n;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		num6 = (SubdivisionsU - 1) * SubdivisionsV + 1;
		for (int num7 = 0; num7 < SubdivisionsV - 1; num7++)
		{
			item3 = num6 + num7;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
			list2.Add(item3 + 1);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + SubdivisionsV + 1);
		}
		item3 = num6 + SubdivisionsV - 1;
		list2.Add(item3);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1);
		for (int num8 = 0; num8 < SubdivisionsU - 1; num8++)
		{
			num6 = num8 * SubdivisionsV + SubdivisionsU * SubdivisionsV + 1;
			for (int num9 = 0; num9 < SubdivisionsV - 1; num9++)
			{
				item3 = num6 + num9;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		int num10 = list.Count - 1;
		int num11 = num10 - SubdivisionsV;
		for (int num12 = 0; num12 < SubdivisionsV; num12++)
		{
			item3 = 0;
			list2.Add(num10);
			list2.Add(num11 + num12 + 1);
			list2.Add(num11 + num12);
		}
		list2.Add(num10);
		list2.Add(num11);
		list2.Add(num10 - 1);
		_vertices = list.ToArray();
		_triangles = list2.ToArray();
		_meshFilter = base.gameObject.GetComponent<MeshFilter>();
		_meshFilter.mesh = new Mesh();
		_meshFilter.sharedMesh.vertices = _vertices;
		_meshFilter.sharedMesh.triangles = _triangles;
		_meshFilter.sharedMesh.RecalculateNormals();
	}
}
public class LocomotionSampleSupport : MonoBehaviour
{
	private LocomotionController lc;

	private bool inMenu;

	private LocomotionTeleport TeleportController => lc.GetComponent<LocomotionTeleport>();

	public void Start()
	{
		lc = UnityEngine.Object.FindObjectOfType<LocomotionController>();
		DebugUIBuilder.instance.AddButton("Node Teleport w/ A", SetupNodeTeleport);
		DebugUIBuilder.instance.AddButton("Dual-stick teleport", SetupTwoStickTeleport);
		DebugUIBuilder.instance.AddButton("L Strafe R Teleport", SetupLeftStrafeRightTeleport);
		DebugUIBuilder.instance.AddButton("Walk Only", SetupWalkOnly);
		_ = UnityEngine.Object.FindObjectOfType<EventSystem>() == null;
		SetupTwoStickTeleport();
		Physics.IgnoreLayerCollision(0, 4);
	}

	public void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	[Conditional("DEBUG_LOCOMOTION_PANEL")]
	private static void Log(string msg)
	{
	}

	public static TActivate ActivateCategory<TCategory, TActivate>(GameObject target) where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		TCategory[] components = target.GetComponents<TCategory>();
		Log(string.Concat("Activate ", typeof(TActivate), " derived from ", typeof(TCategory), "[", components.Length, "]"));
		TActivate result = null;
		foreach (MonoBehaviour monoBehaviour in components)
		{
			bool flag = monoBehaviour.GetType() == typeof(TActivate);
			Log(string.Concat(monoBehaviour.GetType(), " is ", typeof(TActivate), " = ", flag.ToString()));
			if (flag)
			{
				result = (TActivate)monoBehaviour;
			}
			if (monoBehaviour.enabled != flag)
			{
				monoBehaviour.enabled = flag;
			}
		}
		return result;
	}

	protected void ActivateHandlers<TInput, TAim, TTarget, TOrientation, TTransition>() where TInput : TeleportInputHandler where TAim : TeleportAimHandler where TTarget : TeleportTargetHandler where TOrientation : TeleportOrientationHandler where TTransition : TeleportTransition
	{
		ActivateInput<TInput>();
		ActivateAim<TAim>();
		ActivateTarget<TTarget>();
		ActivateOrientation<TOrientation>();
		ActivateTransition<TTransition>();
	}

	protected void ActivateInput<TActivate>() where TActivate : TeleportInputHandler
	{
		ActivateCategory<TeleportInputHandler, TActivate>();
	}

	protected void ActivateAim<TActivate>() where TActivate : TeleportAimHandler
	{
		ActivateCategory<TeleportAimHandler, TActivate>();
	}

	protected void ActivateTarget<TActivate>() where TActivate : TeleportTargetHandler
	{
		ActivateCategory<TeleportTargetHandler, TActivate>();
	}

	protected void ActivateOrientation<TActivate>() where TActivate : TeleportOrientationHandler
	{
		ActivateCategory<TeleportOrientationHandler, TActivate>();
	}

	protected void ActivateTransition<TActivate>() where TActivate : TeleportTransition
	{
		ActivateCategory<TeleportTransition, TActivate>();
	}

	protected TActivate ActivateCategory<TCategory, TActivate>() where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		return ActivateCategory<TCategory, TActivate>(lc.gameObject);
	}

	protected void UpdateToggle(Toggle toggle, bool enabled)
	{
		if (enabled != toggle.isOn)
		{
			toggle.isOn = enabled;
		}
	}

	private void SetupNonCap()
	{
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.SeparateButtonsForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
	}

	private void SetupTeleportDefaults()
	{
		TeleportController.enabled = true;
		lc.PlayerController.RotationEitherThumbstick = false;
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		TeleportController.EnableRotation(ready: false, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.CapacitiveButtonForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
		component.CapacitiveAimAndTeleportButton = TeleportInputHandlerTouch.AimCapTouchButtons.A;
		component.FastTeleport = false;
		TeleportInputHandlerHMD component2 = TeleportController.GetComponent<TeleportInputHandlerHMD>();
		component2.AimButton = OVRInput.RawButton.A;
		component2.TeleportButton = OVRInput.RawButton.A;
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.LTouch;
	}

	protected GameObject AddInstance(GameObject template, string label)
	{
		GameObject obj = UnityEngine.Object.Instantiate(template);
		obj.transform.SetParent(base.transform, worldPositionStays: false);
		obj.name = label;
		return obj;
	}

	private void SetupNodeTeleport()
	{
		SetupTeleportDefaults();
		SetupNonCap();
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerLaser, TeleportTargetHandlerNode, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportInputHandlerTouch>().AimingController = OVRInput.Controller.RTouch;
	}

	private void SetupTwoStickTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.Touch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.Touch;
	}

	private void SetupWalkOnly()
	{
		SetupTeleportDefaults();
		TeleportController.enabled = false;
		lc.PlayerController.EnableLinearMovement = true;
		lc.PlayerController.RotationEitherThumbstick = false;
	}

	private void SetupLeftStrafeRightTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: true, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.RTouch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.RTouch;
	}
}
[RequireComponent(typeof(Canvas))]
public class OVROverlayCanvas : MonoBehaviour
{
	public enum DrawMode
	{
		Opaque,
		OpaqueWithClip,
		TransparentDefaultAlpha,
		TransparentCorrectAlpha
	}

	[SerializeField]
	[HideInInspector]
	private Shader _transparentShader;

	[SerializeField]
	[HideInInspector]
	private Shader _opaqueShader;

	private RectTransform _rectTransform;

	private Canvas _canvas;

	private Camera _camera;

	private OVROverlay _overlay;

	private RenderTexture _renderTexture;

	private MeshRenderer _meshRenderer;

	private Mesh _quad;

	private Material _defaultMat;

	public int MaxTextureSize = 1600;

	public int MinTextureSize = 200;

	public float PixelsPerUnit = 1f;

	public int DrawRate = 1;

	public int DrawFrameOffset;

	public bool Expensive;

	public int Layer;

	public DrawMode Opacity = DrawMode.OpaqueWithClip;

	private bool ScaleViewport = UnityEngine.Application.isMobilePlatform;

	private static readonly Plane[] _FrustumPlanes = new Plane[6];

	public bool overlayEnabled
	{
		get
		{
			if ((bool)_overlay)
			{
				return _overlay.enabled;
			}
			return false;
		}
		set
		{
			if ((bool)_overlay)
			{
				_overlay.enabled = value;
				_defaultMat.color = (value ? Color.black : Color.white);
			}
		}
	}

	private void Start()
	{
		_canvas = GetComponent<Canvas>();
		_rectTransform = _canvas.GetComponent<RectTransform>();
		float width = _rectTransform.rect.width;
		float height = _rectTransform.rect.height;
		float num = ((width >= height) ? 1f : (width / height));
		float num2 = ((height >= width) ? 1f : (height / width));
		int num3 = ((!ScaleViewport) ? 8 : 0);
		int num4 = Mathf.CeilToInt(num * (float)(MaxTextureSize - num3 * 2));
		int num5 = Mathf.CeilToInt(num2 * (float)(MaxTextureSize - num3 * 2));
		int num6 = num4 + num3 * 2;
		int num7 = num5 + num3 * 2;
		float x = width * ((float)num6 / (float)num4);
		float num8 = height * ((float)num7 / (float)num5);
		float num9 = (float)num4 / (float)num6;
		float num10 = (float)num5 / (float)num7;
		Vector2 vector = ((Opacity == DrawMode.Opaque) ? new Vector2(0.005f / _rectTransform.lossyScale.x, 0.005f / _rectTransform.lossyScale.y) : Vector2.zero);
		_renderTexture = new RenderTexture(num6, num7, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
		_renderTexture.useMipMap = !ScaleViewport;
		GameObject gameObject = new GameObject(base.name + " Overlay Camera")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject.transform.SetParent(base.transform, worldPositionStays: false);
		_camera = gameObject.AddComponent<Camera>();
		_camera.stereoTargetEye = StereoTargetEyeMask.None;
		_camera.transform.position = base.transform.position - base.transform.forward;
		_camera.orthographic = true;
		_camera.enabled = false;
		_camera.targetTexture = _renderTexture;
		_camera.cullingMask = 1 << base.gameObject.layer;
		_camera.clearFlags = CameraClearFlags.Color;
		_camera.backgroundColor = Color.clear;
		_camera.orthographicSize = 0.5f * num8 * _rectTransform.localScale.y;
		_camera.nearClipPlane = 0.99f;
		_camera.farClipPlane = 1.01f;
		_quad = new Mesh
		{
			name = base.name + " Overlay Quad",
			hideFlags = HideFlags.HideAndDontSave
		};
		_quad.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f),
			new Vector3(-0.5f, 0.5f),
			new Vector3(0.5f, 0.5f),
			new Vector3(0.5f, -0.5f)
		};
		_quad.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		_quad.triangles = new int[6] { 0, 1, 2, 2, 3, 0 };
		_quad.bounds = new Bounds(Vector3.zero, Vector3.one);
		_quad.UploadMeshData(markNoLongerReadable: true);
		switch (Opacity)
		{
		case DrawMode.Opaque:
			_defaultMat = new Material(_opaqueShader);
			break;
		case DrawMode.OpaqueWithClip:
			_defaultMat = new Material(_opaqueShader);
			_defaultMat.EnableKeyword("WITH_CLIP");
			break;
		case DrawMode.TransparentDefaultAlpha:
			_defaultMat = new Material(_transparentShader);
			_defaultMat.EnableKeyword("ALPHA_SQUARED");
			break;
		case DrawMode.TransparentCorrectAlpha:
			_defaultMat = new Material(_transparentShader);
			break;
		}
		_defaultMat.mainTexture = _renderTexture;
		_defaultMat.color = Color.black;
		_defaultMat.mainTextureOffset = new Vector2(0.5f - 0.5f * num9, 0.5f - 0.5f * num10);
		_defaultMat.mainTextureScale = new Vector2(num9, num10);
		GameObject gameObject2 = new GameObject(base.name + " MeshRenderer")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject2.transform.SetParent(base.transform, worldPositionStays: false);
		gameObject2.AddComponent<MeshFilter>().sharedMesh = _quad;
		_meshRenderer = gameObject2.AddComponent<MeshRenderer>();
		_meshRenderer.sharedMaterial = _defaultMat;
		gameObject2.layer = Layer;
		gameObject2.transform.localScale = new Vector3(width - vector.x, height - vector.y, 1f);
		GameObject gameObject3 = new GameObject(base.name + " Overlay")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject3.transform.SetParent(base.transform, worldPositionStays: false);
		_overlay = gameObject3.AddComponent<OVROverlay>();
		_overlay.isDynamic = true;
		_overlay.noDepthBufferTesting = true;
		_overlay.isAlphaPremultiplied = !UnityEngine.Application.isMobilePlatform;
		_overlay.textures[0] = _renderTexture;
		_overlay.currentOverlayType = OVROverlay.OverlayType.Underlay;
		_overlay.transform.localScale = new Vector3(x, num8, 1f);
		_overlay.useExpensiveSuperSample = Expensive;
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(_defaultMat);
		UnityEngine.Object.Destroy(_quad);
		UnityEngine.Object.Destroy(_renderTexture);
	}

	private void OnEnable()
	{
		if ((bool)_overlay)
		{
			_meshRenderer.enabled = true;
			_overlay.enabled = true;
		}
		if ((bool)_camera)
		{
			_camera.enabled = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)_overlay)
		{
			_overlay.enabled = false;
			_meshRenderer.enabled = false;
		}
		if ((bool)_camera)
		{
			_camera.enabled = false;
		}
	}

	protected virtual bool ShouldRender()
	{
		if (DrawRate > 1 && Time.frameCount % DrawRate != DrawFrameOffset % DrawRate)
		{
			return false;
		}
		if (Camera.main != null)
		{
			for (int i = 0; i < 2; i++)
			{
				Camera.StereoscopicEye eye = (Camera.StereoscopicEye)i;
				GeometryUtility.CalculateFrustumPlanes(Camera.main.GetStereoProjectionMatrix(eye) * Camera.main.GetStereoViewMatrix(eye), _FrustumPlanes);
				if (GeometryUtility.TestPlanesAABB(_FrustumPlanes, _meshRenderer.bounds))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	private void Update()
	{
		if (ShouldRender())
		{
			if (ScaleViewport && Camera.main != null)
			{
				float magnitude = (Camera.main.transform.position - base.transform.position).magnitude;
				float value = Mathf.Ceil(PixelsPerUnit * Mathf.Max(_rectTransform.rect.width * base.transform.lossyScale.x, _rectTransform.rect.height * base.transform.lossyScale.y) / magnitude / 8f * (float)_renderTexture.height) * 8f;
				value = Mathf.Clamp(value, MinTextureSize, _renderTexture.height);
				float num = value - 2f;
				_camera.orthographicSize = 0.5f * _rectTransform.rect.height * _rectTransform.localScale.y * value / num;
				float num2 = _rectTransform.rect.width / _rectTransform.rect.height;
				float num3 = num * num2;
				float num4 = Mathf.Ceil((num3 + 2f) * 0.5f) * 2f / (float)_renderTexture.width;
				float num5 = value / (float)_renderTexture.height;
				float num6 = ((Opacity == DrawMode.Opaque) ? 1.001f : 0f);
				float num7 = (num3 - num6) / (float)_renderTexture.width;
				float num8 = (num - num6) / (float)_renderTexture.height;
				_camera.rect = new Rect((1f - num4) / 2f, (1f - num5) / 2f, num4, num5);
				Rect rect = new Rect(0.5f - 0.5f * num7, 0.5f - 0.5f * num8, num7, num8);
				_defaultMat.mainTextureOffset = rect.min;
				_defaultMat.mainTextureScale = rect.size;
				_overlay.overrideTextureRectMatrix = true;
				rect.y = 1f - rect.height - rect.y;
				Rect rect2 = new Rect(0f, 0f, 1f, 1f);
				_overlay.SetSrcDestRects(rect, rect, rect2, rect2);
			}
			_camera.Render();
		}
	}
}
public class StartMenu : MonoBehaviour
{
	public OVROverlay overlay;

	public OVROverlay text;

	public OVRCameraRig vrRig;

	private void Start()
	{
		DebugUIBuilder.instance.AddLabel("Select Sample Scene");
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			string scenePathByBuildIndex = SceneUtility.GetScenePathByBuildIndex(i);
			int sceneIndex = i;
			DebugUIBuilder.instance.AddButton(System.IO.Path.GetFileNameWithoutExtension(scenePathByBuildIndex), delegate
			{
				LoadScene(sceneIndex);
			});
		}
		DebugUIBuilder.instance.Show();
	}

	private void LoadScene(int idx)
	{
		DebugUIBuilder.instance.Hide();
		Debug.Log("Load scene: " + idx);
		SceneManager.LoadScene(idx);
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private AudioSource source;

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		source = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (source == null)
		{
			Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (source.spatialize)
		{
			Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			source.spatialize = false;
		}
		if (source.clip == null)
		{
			Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (source.clip.channels != numFOAChannels)
		{
			Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		if (source == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			source.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			source.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		source.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = "";

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
		array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapResolution = terrainData.heightmapResolution;
			int heightmapResolution2 = terrainData.heightmapResolution;
			int num = (heightmapResolution - 1) / terrainDecimation + 1;
			int num2 = (heightmapResolution2 - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance = treeInstances[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
		float[] array3 = new float[totalVertexCount * 3];
		int[] array4 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapResolution3 = terrainData2.heightmapResolution;
			int heightmapResolution4 = terrainData2.heightmapResolution;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapResolution3, heightmapResolution4);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapResolution3 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapResolution4 - 1) * (float)terrainDecimation);
			int num7 = (heightmapResolution3 - 1) / terrainDecimation + 1;
			int num8 = (heightmapResolution4 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array2[groupOffset].faceType = FaceType.TRIANGLES;
			array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && item3.materials.Length != 0)
			{
				item3.materials[0].StartInternal();
				array2[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array2[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array3[num11] = vector.x;
					array3[num11 + 1] = vector.y;
					array3[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array4[indexOffset] = vertexOffset + num12 * num7 + num13;
					array4[indexOffset + 1] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 2] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 4] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 5] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances = terrainData2.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance2 = treeInstances[l];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_2 = 14u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	[MonoPInvokeCallback(typeof(AudioRaycastCallback))]
	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(AudioRaycastCallback callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class All1ShaderDemoController : MonoBehaviour
{
	[SerializeField]
	private DemoCamera cam;

	[SerializeField]
	private DemoCircleExpositor[] expositors;

	[SerializeField]
	private Text expositorsTitle;

	public float expositorDistance;

	private int currExpositor;

	[SerializeField]
	private GameObject background;

	private Material backgroundMat;

	[SerializeField]
	private float colorLerpSpeed;

	private Color[] targetColors;

	private Color[] currentColors;

	private void Start()
	{
		currExpositor = 0;
		SetExpositorText();
		for (int i = 0; i < expositors.Length; i++)
		{
			expositors[i].transform.position = new Vector3(0f, expositorDistance * (float)i, 0f);
		}
		backgroundMat = background.GetComponent<Image>().material;
		targetColors = new Color[4];
		targetColors[0] = backgroundMat.GetColor("_GradTopLeftCol");
		targetColors[1] = backgroundMat.GetColor("_GradTopRightCol");
		targetColors[2] = backgroundMat.GetColor("_GradBotLeftCol");
		targetColors[3] = backgroundMat.GetColor("_GradBotRightCol");
		currentColors = targetColors.Clone() as Color[];
	}

	private void Update()
	{
		GetInput();
		currentColors[0] = Color.Lerp(currentColors[0], targetColors[currExpositor % targetColors.Length], colorLerpSpeed * Time.deltaTime);
		currentColors[1] = Color.Lerp(currentColors[1], targetColors[(1 + currExpositor) % targetColors.Length], colorLerpSpeed * Time.deltaTime);
		currentColors[2] = Color.Lerp(currentColors[2], targetColors[(2 + currExpositor) % targetColors.Length], colorLerpSpeed * Time.deltaTime);
		currentColors[3] = Color.Lerp(currentColors[3], targetColors[(3 + currExpositor) % targetColors.Length], colorLerpSpeed * Time.deltaTime);
		backgroundMat.SetColor("_GradTopLeftCol", currentColors[0]);
		backgroundMat.SetColor("_GradTopRightCol", currentColors[1]);
		backgroundMat.SetColor("_GradBotLeftCol", currentColors[2]);
		backgroundMat.SetColor("_GradBotRightCol", currentColors[3]);
	}

	private void GetInput()
	{
		if (Input.GetKeyDown(KeyCode.LeftArrow) || Input.GetKeyDown(KeyCode.A))
		{
			expositors[currExpositor].ChangeTarget(-1);
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow) || Input.GetKeyDown(KeyCode.D))
		{
			expositors[currExpositor].ChangeTarget(1);
		}
		else if (Input.GetKeyDown(KeyCode.UpArrow) || Input.GetKeyDown(KeyCode.W))
		{
			ChangeExpositor(-1);
		}
		else if (Input.GetKeyDown(KeyCode.DownArrow) || Input.GetKeyDown(KeyCode.S))
		{
			ChangeExpositor(1);
		}
	}

	private void ChangeExpositor(int offset)
	{
		currExpositor += offset;
		if (currExpositor > expositors.Length - 1)
		{
			currExpositor = 0;
		}
		else if (currExpositor < 0)
		{
			currExpositor = expositors.Length - 1;
		}
		SetExpositorText();
	}

	private void SetExpositorText()
	{
		expositorsTitle.text = expositors[currExpositor].name;
	}

	public int GetCurrExpositor()
	{
		return currExpositor;
	}
}
public class Demo2AutoScroll : MonoBehaviour
{
	private Transform[] children;

	public float totalTime;

	public GameObject sceneDescription;

	private void Start()
	{
		sceneDescription.SetActive(value: false);
		Camera.main.fieldOfView = 60f;
		children = GetComponentsInChildren<Transform>();
		for (int i = 0; i < children.Length; i++)
		{
			if (children[i].gameObject != base.gameObject)
			{
				children[i].gameObject.SetActive(value: false);
				children[i].localPosition = Vector3.zero;
			}
		}
		totalTime /= children.Length;
		StartCoroutine(ScrollElements());
	}

	private IEnumerator ScrollElements()
	{
		int i = 0;
		while (true)
		{
			if (children[i].gameObject == base.gameObject)
			{
				i = (i + 1) % children.Length;
				continue;
			}
			children[i].gameObject.SetActive(value: true);
			yield return new WaitForSeconds(totalTime);
			children[i].gameObject.SetActive(value: false);
			i = (i + 1) % children.Length;
		}
	}
}
public class DemoCamera : MonoBehaviour
{
	[SerializeField]
	private Transform targetedItem;

	[SerializeField]
	private All1ShaderDemoController demoController;

	[SerializeField]
	private float speed;

	private Vector3 offset;

	private Vector3 target;

	private bool canUpdate;

	private void Awake()
	{
		offset = base.transform.position - targetedItem.position;
		StartCoroutine(SetCamAfterStart());
	}

	private void Update()
	{
		if (canUpdate)
		{
			target.y = (float)demoController.GetCurrExpositor() * demoController.expositorDistance;
			base.transform.position = Vector3.Lerp(base.transform.position, target, speed * Time.deltaTime);
		}
	}

	private IEnumerator SetCamAfterStart()
	{
		yield return null;
		base.transform.position = targetedItem.position + offset;
		target = base.transform.position;
		canUpdate = true;
	}
}
public class DemoCircleExpositor : MonoBehaviour
{
	[SerializeField]
	private float radius = 40f;

	[SerializeField]
	private float rotateSpeed = 10f;

	private Transform[] items;

	private int count;

	private int currentTarget;

	private float offsetRotation;

	private float iniY;

	private Quaternion dummyRotation;

	private void Start()
	{
		dummyRotation = base.transform.rotation;
		iniY = base.transform.position.y;
		items = new Transform[base.transform.childCount];
		foreach (Transform item in base.transform)
		{
			items[count] = item;
			count++;
		}
		offsetRotation = 360f / (float)count;
		for (int i = 0; i < count; i++)
		{
			float f = (float)i * (float)Math.PI * 2f / (float)count;
			Vector3 position = new Vector3(Mathf.Sin(f) * radius, iniY, (0f - Mathf.Cos(f)) * radius);
			items[i].position = position;
		}
	}

	private void Update()
	{
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, dummyRotation, rotateSpeed * Time.deltaTime);
	}

	public void ChangeTarget(int offset)
	{
		currentTarget += offset;
		if (currentTarget > items.Length - 1)
		{
			currentTarget = 0;
		}
		else if (currentTarget < 0)
		{
			currentTarget = items.Length - 1;
		}
		dummyRotation *= Quaternion.Euler(Vector3.up * offset * offsetRotation);
	}
}
public class DemoItem : MonoBehaviour
{
	private static Vector3 lookAtZ = new Vector3(0f, 0f, 1f);

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.LookAt(base.transform.position + lookAtZ);
	}
}
public class DemoRandomColorSwap : MonoBehaviour
{
	[SerializeField]
	private Gradient gradient;

	private Material mat;

	private Texture texture;

	private void Start()
	{
		if (GetComponent<SpriteRenderer>() != null)
		{
			mat = GetComponent<Renderer>().material;
			mat.SetFloat("_Alpha", 1f);
			mat.SetColor("_Color", new Color(0.5f, 1f, 0f, 1f));
			mat.SetTexture("_MainTex", texture);
			InvokeRepeating("NewColor", 0f, 0.6f);
		}
	}

	private void NewColor()
	{
		mat.SetColor("_ColorSwapRed", gradient.Evaluate(UnityEngine.Random.value));
		mat.SetColor("_ColorSwapGreen", gradient.Evaluate(UnityEngine.Random.value));
		mat.SetColor("_ColorSwapBlue", gradient.Evaluate(UnityEngine.Random.value));
	}
}
[ExecuteInEditMode]
[AddComponentMenu("AllIn1SpriteShader/AddAllIn1Shader")]
public class AllIn1Shader : MonoBehaviour
{
	private enum AfterSetAction
	{
		Clear,
		CopyMaterial,
		Reset
	}

	private Material currMaterial;

	private Material prevMaterial;

	private bool matAssigned;

	private bool destroyed;

	public void MakeNewMaterial()
	{
		SetMaterial(AfterSetAction.Clear);
	}

	public void MakeCopy()
	{
		SetMaterial(AfterSetAction.CopyMaterial);
	}

	private void ResetAllProperties()
	{
		SetMaterial(AfterSetAction.Reset);
	}

	private void SetMaterial(AfterSetAction action)
	{
		Shader shader = Resources.Load("AllIn1SpriteShader", typeof(Shader)) as Shader;
		if (!UnityEngine.Application.isPlaying && UnityEngine.Application.isEditor && shader != null)
		{
			bool flag = false;
			if (GetComponent<SpriteRenderer>() != null)
			{
				flag = true;
				prevMaterial = new Material(GetComponent<Renderer>().sharedMaterial);
				currMaterial = new Material(shader);
				GetComponent<Renderer>().sharedMaterial = currMaterial;
				GetComponent<Renderer>().sharedMaterial.hideFlags = HideFlags.None;
				matAssigned = true;
				DoAfterSetAction(action);
			}
			else
			{
				Image component = GetComponent<Image>();
				if (component != null)
				{
					flag = true;
					prevMaterial = new Material(component.material);
					currMaterial = new Material(shader);
					component.material = currMaterial;
					component.material.hideFlags = HideFlags.None;
					matAssigned = true;
					DoAfterSetAction(action);
				}
			}
			if (!flag)
			{
				MissingRenderer();
			}
			else
			{
				SetSceneDirty();
			}
		}
		else if (shader == null)
		{
			Debug.LogError("Make sure the AllIn1SpriteShader file is inside the Resource folder!");
		}
	}

	private void DoAfterSetAction(AfterSetAction action)
	{
		switch (action)
		{
		case AfterSetAction.Clear:
			ClearAllKeywords();
			break;
		case AfterSetAction.CopyMaterial:
			currMaterial.CopyPropertiesFromMaterial(prevMaterial);
			break;
		}
	}

	public void TryCreateNew()
	{
		bool flag = false;
		if (GetComponent<SpriteRenderer>() != null)
		{
			flag = true;
			Renderer component = GetComponent<Renderer>();
			if (component != null && component.sharedMaterial != null && component.sharedMaterial.name.Contains("AllIn1"))
			{
				ResetAllProperties();
				ClearAllKeywords();
			}
			else
			{
				CleanMaterial();
				MakeNewMaterial();
			}
		}
		else
		{
			Image component2 = GetComponent<Image>();
			if (component2 != null)
			{
				flag = true;
				if (component2.material.name.Contains("AllIn1"))
				{
					ResetAllProperties();
					ClearAllKeywords();
				}
				else
				{
					MakeNewMaterial();
				}
			}
		}
		if (!flag)
		{
			MissingRenderer();
		}
	}

	public void ClearAllKeywords()
	{
		SetKeyword("RECTSIZE_ON");
		SetKeyword("OFFSETUV_ON");
		SetKeyword("CLIPPING_ON");
		SetKeyword("POLARUV_ON");
		SetKeyword("TWISTUV_ON");
		SetKeyword("ROTATEUV_ON");
		SetKeyword("FISHEYE_ON");
		SetKeyword("PINCH_ON");
		SetKeyword("SHAKEUV_ON");
		SetKeyword("WAVEUV_ON");
		SetKeyword("ROUNDWAVEUV_ON");
		SetKeyword("DOODLE_ON");
		SetKeyword("ZOOMUV_ON");
		SetKeyword("FADE_ON");
		SetKeyword("TEXTURESCROLL_ON");
		SetKeyword("GLOW_ON");
		SetKeyword("OUTBASE_ON");
		SetKeyword("OUTTEX_ON");
		SetKeyword("OUTDIST_ON");
		SetKeyword("DISTORT_ON");
		SetKeyword("WIND_ON");
		SetKeyword("GRADIENT_ON");
		SetKeyword("COLORSWAP_ON");
		SetKeyword("HSV_ON");
		SetKeyword("HITEFFECT_ON");
		SetKeyword("PIXELATE_ON");
		SetKeyword("NEGATIVE_ON");
		SetKeyword("COLORRAMP_ON");
		SetKeyword("GREYSCALE_ON");
		SetKeyword("POSTERIZE_ON");
		SetKeyword("BLUR_ON");
		SetKeyword("MOTIONBLUR_ON");
		SetKeyword("GHOST_ON");
		SetKeyword("INNEROUTLINE_ON");
		SetKeyword("HOLOGRAM_ON");
		SetKeyword("CHROMABERR_ON");
		SetKeyword("GLITCH_ON");
		SetKeyword("FLICKER_ON");
		SetKeyword("SHADOW_ON");
		SetKeyword("ALPHACUTOFF_ON");
		SetKeyword("CHANGECOLOR_ON");
		SetSceneDirty();
	}

	private void SetKeyword(string keyword, bool state = false)
	{
		if (destroyed)
		{
			return;
		}
		if (currMaterial == null)
		{
			FindCurrMaterial();
			if (currMaterial == null)
			{
				MissingRenderer();
				return;
			}
		}
		if (!state)
		{
			currMaterial.DisableKeyword(keyword);
		}
		else
		{
			currMaterial.EnableKeyword(keyword);
		}
	}

	private void FindCurrMaterial()
	{
		if (GetComponent<SpriteRenderer>() != null)
		{
			currMaterial = GetComponent<Renderer>().sharedMaterial;
			matAssigned = true;
			return;
		}
		Image component = GetComponent<Image>();
		if (component != null)
		{
			currMaterial = component.material;
			matAssigned = true;
		}
	}

	public void CleanMaterial()
	{
		if (GetComponent<SpriteRenderer>() != null)
		{
			GetComponent<Renderer>().sharedMaterial = new Material(Shader.Find("Sprites/Default"));
			matAssigned = false;
		}
		else
		{
			Image component = GetComponent<Image>();
			if (component != null)
			{
				component.material = new Material(Shader.Find("Sprites/Default"));
				matAssigned = false;
			}
		}
		SetSceneDirty();
	}

	public void SaveMaterial()
	{
	}

	private void SaveMaterialWithOtherName(string path, int i = 1)
	{
		int num = i;
		string text = string.Concat(path + num, ".mat");
		if (File.Exists(text))
		{
			num++;
			SaveMaterialWithOtherName(path, num);
		}
		else
		{
			DoSaving(text);
		}
	}

	private void DoSaving(string fileName)
	{
	}

	private void SetSceneDirty()
	{
	}

	private void MissingRenderer()
	{
	}

	public void ToggleSetAtlasUvs(bool activate)
	{
		SetAtlasUvs setAtlasUvs = GetComponent<SetAtlasUvs>();
		if (activate)
		{
			if (setAtlasUvs == null)
			{
				setAtlasUvs = base.gameObject.AddComponent<SetAtlasUvs>();
			}
			setAtlasUvs.GetAndSetUVs();
			SetKeyword("ATLAS_ON", state: true);
		}
		else
		{
			if (setAtlasUvs != null)
			{
				setAtlasUvs.ResetAtlasUvs();
				UnityEngine.Object.DestroyImmediate(setAtlasUvs);
			}
			SetKeyword("ATLAS_ON");
		}
	}
}
public class RandomSeed : MonoBehaviour
{
	private void Start()
	{
		if (GetComponent<SpriteRenderer>() != null)
		{
			Renderer component = GetComponent<Renderer>();
			if (component != null && component.material != null)
			{
				component.material.SetFloat("_RandomSeed", UnityEngine.Random.Range(0f, 1000f));
			}
			else
			{
				Debug.LogError("Missing Renderer or Material: " + base.gameObject.name);
			}
			return;
		}
		Image component2 = GetComponent<Image>();
		if (component2 != null)
		{
			if (component2.material != null)
			{
				component2.material.SetFloat("_RandomSeed", UnityEngine.Random.Range(0f, 1000f));
			}
			else
			{
				Debug.LogError("Missing Material on UI Image: " + base.gameObject.name);
			}
		}
		else
		{
			Debug.LogError("Missing Sprite Renderer or UI Image on: " + base.gameObject.name);
		}
	}
}
[ExecuteInEditMode]
public class SetAtlasUvs : MonoBehaviour
{
	[SerializeField]
	private bool updateEveryFrame;

	private Renderer render;

	private SpriteRenderer spriteRender;

	private Image uiImage;

	private bool isUI;

	private void Start()
	{
		if (GetRendererReferencesIfNeeded())
		{
			GetAndSetUVs();
		}
		if (!updateEveryFrame && UnityEngine.Application.isPlaying)
		{
			base.enabled = false;
		}
	}

	private void OnWillRenderObject()
	{
		if (updateEveryFrame)
		{
			GetAndSetUVs();
		}
	}

	public void GetAndSetUVs()
	{
		if (GetRendererReferencesIfNeeded())
		{
			if (!isUI)
			{
				Rect rect = spriteRender.sprite.rect;
				rect.x /= spriteRender.sprite.texture.width;
				rect.width /= spriteRender.sprite.texture.width;
				rect.y /= spriteRender.sprite.texture.height;
				rect.height /= spriteRender.sprite.texture.height;
				render.sharedMaterial.SetFloat("_MinXUV", rect.xMin);
				render.sharedMaterial.SetFloat("_MaxXUV", rect.xMax);
				render.sharedMaterial.SetFloat("_MinYUV", rect.yMin);
				render.sharedMaterial.SetFloat("_MaxYUV", rect.yMax);
			}
			else
			{
				Rect rect2 = uiImage.sprite.rect;
				rect2.x /= uiImage.sprite.texture.width;
				rect2.width /= uiImage.sprite.texture.width;
				rect2.y /= uiImage.sprite.texture.height;
				rect2.height /= uiImage.sprite.texture.height;
				uiImage.material.SetFloat("_MinXUV", rect2.xMin);
				uiImage.material.SetFloat("_MaxXUV", rect2.xMax);
				uiImage.material.SetFloat("_MinYUV", rect2.yMin);
				uiImage.material.SetFloat("_MaxYUV", rect2.yMax);
			}
		}
	}

	public void ResetAtlasUvs()
	{
		if (GetRendererReferencesIfNeeded())
		{
			if (!isUI)
			{
				render.sharedMaterial.SetFloat("_MinXUV", 0f);
				render.sharedMaterial.SetFloat("_MaxXUV", 1f);
				render.sharedMaterial.SetFloat("_MinYUV", 0f);
				render.sharedMaterial.SetFloat("_MaxYUV", 1f);
			}
			else
			{
				uiImage.material.SetFloat("_MinXUV", 0f);
				uiImage.material.SetFloat("_MaxXUV", 1f);
				uiImage.material.SetFloat("_MinYUV", 0f);
				uiImage.material.SetFloat("_MaxYUV", 1f);
			}
		}
	}

	public void UpdateEveryFrame(bool everyFrame)
	{
		updateEveryFrame = everyFrame;
	}

	private bool GetRendererReferencesIfNeeded()
	{
		if (spriteRender == null)
		{
			spriteRender = GetComponent<SpriteRenderer>();
		}
		if (spriteRender != null)
		{
			if (spriteRender.sprite == null)
			{
				return false;
			}
			if (render == null)
			{
				render = GetComponent<Renderer>();
			}
			isUI = false;
		}
		else
		{
			if (uiImage == null)
			{
				uiImage = GetComponent<Image>();
				if (!(uiImage != null))
				{
					UnityEngine.Object.DestroyImmediate(this);
					return false;
				}
			}
			if (render == null)
			{
				render = GetComponent<Renderer>();
			}
			isUI = true;
		}
		if (spriteRender == null && uiImage == null)
		{
			UnityEngine.Object.DestroyImmediate(this);
			return false;
		}
		return true;
	}
}
public static class ConsoleProDebug
{
	public static void Clear()
	{
	}

	public static void LogToFilter(string inLog, string inFilterName)
	{
		Debug.Log(inLog + "\nCPAPI:{\"cmd\":\"Filter\" \"name\":\"" + inFilterName + "\"}");
	}

	public static void Watch(string inName, string inValue)
	{
		Debug.Log(inName + " : " + inValue + "\nCPAPI:{\"cmd\":\"Watch\" \"name\":\"" + inName + "\"}");
	}

	public static void Search(string inText)
	{
		Debug.Log("\nCPAPI:{\"cmd\":\"Search\" \"text\":\"" + inText + "\"}");
	}
}
public class DynamicBoneDemo1 : MonoBehaviour
{
	public GameObject m_Player;

	private float m_weight = 1f;

	private void Update()
	{
		m_Player.transform.Rotate(new Vector3(0f, Input.GetAxis("Horizontal") * Time.deltaTime * 200f, 0f));
		m_Player.transform.Translate(base.transform.forward * Input.GetAxis("Vertical") * Time.deltaTime * 4f);
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(50f, 50f, 200f, 24f), "Press arrow key to move");
		Animation componentInChildren = m_Player.GetComponentInChildren<Animation>();
		componentInChildren.enabled = GUI.Toggle(new Rect(50f, 70f, 200f, 24f), componentInChildren.enabled, "Play Animation");
		DynamicBone[] components = m_Player.GetComponents<DynamicBone>();
		GUI.Label(new Rect(50f, 100f, 200f, 24f), "Choose dynamic bone:");
		DynamicBone obj = components[0];
		bool flag2 = (components[1].enabled = GUI.Toggle(new Rect(50f, 120f, 100f, 24f), components[0].enabled, "Breasts"));
		obj.enabled = flag2;
		components[2].enabled = GUI.Toggle(new Rect(50f, 140f, 100f, 24f), components[2].enabled, "Tail");
		GUI.Label(new Rect(50f, 160f, 200f, 24f), "Weight");
		m_weight = GUI.HorizontalSlider(new Rect(100f, 160f, 100f, 24f), m_weight, 0f, 1f);
		DynamicBone[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetWeight(m_weight);
		}
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone")]
public class DynamicBone : MonoBehaviour
{
	public enum UpdateMode
	{
		Normal,
		AnimatePhysics,
		UnscaledTime
	}

	public enum FreezeAxis
	{
		None,
		X,
		Y,
		Z
	}

	private class Particle
	{
		public Transform m_Transform;

		public int m_ParentIndex = -1;

		public float m_Damping;

		public float m_Elasticity;

		public float m_Stiffness;

		public float m_Inert;

		public float m_Friction;

		public float m_Radius;

		public float m_BoneLength;

		public bool m_isCollide;

		public Vector3 m_Position = Vector3.zero;

		public Vector3 m_PrevPosition = Vector3.zero;

		public Vector3 m_EndOffset = Vector3.zero;

		public Vector3 m_InitLocalPosition = Vector3.zero;

		public Quaternion m_InitLocalRotation = Quaternion.identity;
	}

	[Tooltip("The root of the transform hierarchy to apply physics.")]
	public Transform m_Root;

	[Tooltip("Internal physics simulation rate.")]
	public float m_UpdateRate = 60f;

	public UpdateMode m_UpdateMode;

	[Tooltip("How much the bones slowed down.")]
	[Range(0f, 1f)]
	public float m_Damping = 0.1f;

	public AnimationCurve m_DampingDistrib;

	[Tooltip("How much the force applied to return each bone to original orientation.")]
	[Range(0f, 1f)]
	public float m_Elasticity = 0.1f;

	public AnimationCurve m_ElasticityDistrib;

	[Tooltip("How much bone's original orientation are preserved.")]
	[Range(0f, 1f)]
	public float m_Stiffness = 0.1f;

	public AnimationCurve m_StiffnessDistrib;

	[Tooltip("How much character's position change is ignored in physics simulation.")]
	[Range(0f, 1f)]
	public float m_Inert;

	public AnimationCurve m_InertDistrib;

	[Tooltip("How much the bones slowed down when collide.")]
	public float m_Friction;

	public AnimationCurve m_FrictionDistrib;

	[Tooltip("Each bone can be a sphere to collide with colliders. Radius describe sphere's size.")]
	public float m_Radius;

	public AnimationCurve m_RadiusDistrib;

	[Tooltip("If End Length is not zero, an extra bone is generated at the end of transform hierarchy.")]
	public float m_EndLength;

	[Tooltip("If End Offset is not zero, an extra bone is generated at the end of transform hierarchy.")]
	public Vector3 m_EndOffset = Vector3.zero;

	[Tooltip("The force apply to bones. Partial force apply to character's initial pose is cancelled out.")]
	public Vector3 m_Gravity = Vector3.zero;

	[Tooltip("The force apply to bones.")]
	public Vector3 m_Force = Vector3.zero;

	[Tooltip("Collider objects interact with the bones.")]
	public List<DynamicBoneColliderBase> m_Colliders;

	[Tooltip("Bones exclude from physics simulation.")]
	public List<Transform> m_Exclusions;

	[Tooltip("Constrain bones to move on specified plane.")]
	public FreezeAxis m_FreezeAxis;

	[Tooltip("Disable physics simulation automatically if character is far from camera or player.")]
	public bool m_DistantDisable;

	public Transform m_ReferenceObject;

	public float m_DistanceToObject = 20f;

	private Vector3 m_LocalGravity = Vector3.zero;

	private Vector3 m_ObjectMove = Vector3.zero;

	private Vector3 m_ObjectPrevPosition = Vector3.zero;

	private float m_BoneTotalLength;

	private float m_ObjectScale = 1f;

	private float m_Time;

	private float m_Weight = 1f;

	private bool m_DistantDisabled;

	private List<Particle> m_Particles = new List<Particle>();

	private void Start()
	{
		SetupParticles();
	}

	private void FixedUpdate()
	{
		if (m_UpdateMode == UpdateMode.AnimatePhysics)
		{
			PreUpdate();
		}
	}

	private void Update()
	{
		if (m_UpdateMode != UpdateMode.AnimatePhysics)
		{
			PreUpdate();
		}
	}

	private void LateUpdate()
	{
		if (m_DistantDisable)
		{
			CheckDistance();
		}
		if (m_Weight > 0f && (!m_DistantDisable || !m_DistantDisabled))
		{
			float t = ((m_UpdateMode == UpdateMode.UnscaledTime) ? Time.unscaledDeltaTime : Time.deltaTime);
			UpdateDynamicBones(t);
		}
	}

	private void PreUpdate()
	{
		if (m_Weight > 0f && (!m_DistantDisable || !m_DistantDisabled))
		{
			InitTransforms();
		}
	}

	private void CheckDistance()
	{
		Transform referenceObject = m_ReferenceObject;
		if (referenceObject == null && Camera.main != null)
		{
			referenceObject = Camera.main.transform;
		}
		if (!(referenceObject != null))
		{
			return;
		}
		bool flag = (referenceObject.position - base.transform.position).sqrMagnitude > m_DistanceToObject * m_DistanceToObject;
		if (flag != m_DistantDisabled)
		{
			if (!flag)
			{
				ResetParticlesPosition();
			}
			m_DistantDisabled = flag;
		}
	}

	private void OnEnable()
	{
		ResetParticlesPosition();
	}

	private void OnDisable()
	{
		InitTransforms();
	}

	private void OnValidate()
	{
		m_UpdateRate = Mathf.Max(m_UpdateRate, 0f);
		m_Damping = Mathf.Clamp01(m_Damping);
		m_Elasticity = Mathf.Clamp01(m_Elasticity);
		m_Stiffness = Mathf.Clamp01(m_Stiffness);
		m_Inert = Mathf.Clamp01(m_Inert);
		m_Friction = Mathf.Clamp01(m_Friction);
		m_Radius = Mathf.Max(m_Radius, 0f);
		if (UnityEngine.Application.isEditor && UnityEngine.Application.isPlaying)
		{
			InitTransforms();
			SetupParticles();
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!base.enabled || m_Root == null)
		{
			return;
		}
		if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying && base.transform.hasChanged)
		{
			InitTransforms();
			SetupParticles();
		}
		Gizmos.color = Color.white;
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				Particle particle2 = m_Particles[particle.m_ParentIndex];
				Gizmos.DrawLine(particle.m_Position, particle2.m_Position);
			}
			if (particle.m_Radius > 0f)
			{
				Gizmos.DrawWireSphere(particle.m_Position, particle.m_Radius * m_ObjectScale);
			}
		}
	}

	public void SetWeight(float w)
	{
		if (m_Weight != w)
		{
			if (w == 0f)
			{
				InitTransforms();
			}
			else if (m_Weight == 0f)
			{
				ResetParticlesPosition();
			}
			m_Weight = w;
		}
	}

	public float GetWeight()
	{
		return m_Weight;
	}

	private void UpdateDynamicBones(float t)
	{
		if (m_Root == null)
		{
			return;
		}
		m_ObjectScale = Mathf.Abs(base.transform.lossyScale.x);
		m_ObjectMove = base.transform.position - m_ObjectPrevPosition;
		m_ObjectPrevPosition = base.transform.position;
		int num = 1;
		if (m_UpdateRate > 0f)
		{
			float num2 = 1f / m_UpdateRate;
			m_Time += t;
			num = 0;
			while (m_Time >= num2)
			{
				m_Time -= num2;
				if (++num >= 3)
				{
					m_Time = 0f;
					break;
				}
			}
		}
		if (num > 0)
		{
			for (int i = 0; i < num; i++)
			{
				UpdateParticles1();
				UpdateParticles2();
				m_ObjectMove = Vector3.zero;
			}
		}
		else
		{
			SkipUpdateParticles();
		}
		ApplyParticlesToTransforms();
	}

	private void SetupParticles()
	{
		m_Particles.Clear();
		if (!(m_Root == null))
		{
			m_LocalGravity = m_Root.InverseTransformDirection(m_Gravity);
			m_ObjectScale = Mathf.Abs(base.transform.lossyScale.x);
			m_ObjectPrevPosition = base.transform.position;
			m_ObjectMove = Vector3.zero;
			m_BoneTotalLength = 0f;
			AppendParticles(m_Root, -1, 0f);
			UpdateParameters();
		}
	}

	private void AppendParticles(Transform b, int parentIndex, float boneLength)
	{
		Particle particle = new Particle();
		particle.m_Transform = b;
		particle.m_ParentIndex = parentIndex;
		if (b != null)
		{
			particle.m_Position = (particle.m_PrevPosition = b.position);
			particle.m_InitLocalPosition = b.localPosition;
			particle.m_InitLocalRotation = b.localRotation;
		}
		else
		{
			Transform transform = m_Particles[parentIndex].m_Transform;
			if (m_EndLength > 0f)
			{
				Transform parent = transform.parent;
				if (parent != null)
				{
					particle.m_EndOffset = transform.InverseTransformPoint(transform.position * 2f - parent.position) * m_EndLength;
				}
				else
				{
					particle.m_EndOffset = new Vector3(m_EndLength, 0f, 0f);
				}
			}
			else
			{
				particle.m_EndOffset = transform.InverseTransformPoint(base.transform.TransformDirection(m_EndOffset) + transform.position);
			}
			particle.m_Position = (particle.m_PrevPosition = transform.TransformPoint(particle.m_EndOffset));
		}
		if (parentIndex >= 0)
		{
			boneLength += (m_Particles[parentIndex].m_Transform.position - particle.m_Position).magnitude;
			particle.m_BoneLength = boneLength;
			m_BoneTotalLength = Mathf.Max(m_BoneTotalLength, boneLength);
		}
		int count = m_Particles.Count;
		m_Particles.Add(particle);
		if (!(b != null))
		{
			return;
		}
		for (int i = 0; i < b.childCount; i++)
		{
			bool flag = false;
			if (m_Exclusions != null)
			{
				for (int j = 0; j < m_Exclusions.Count; j++)
				{
					if (m_Exclusions[j] == b.GetChild(i))
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				AppendParticles(b.GetChild(i), count, boneLength);
			}
			else if (m_EndLength > 0f || m_EndOffset != Vector3.zero)
			{
				AppendParticles(null, count, boneLength);
			}
		}
		if (b.childCount == 0 && (m_EndLength > 0f || m_EndOffset != Vector3.zero))
		{
			AppendParticles(null, count, boneLength);
		}
	}

	public void UpdateParameters()
	{
		if (m_Root == null)
		{
			return;
		}
		m_LocalGravity = m_Root.InverseTransformDirection(m_Gravity);
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			particle.m_Damping = m_Damping;
			particle.m_Elasticity = m_Elasticity;
			particle.m_Stiffness = m_Stiffness;
			particle.m_Inert = m_Inert;
			particle.m_Friction = m_Friction;
			particle.m_Radius = m_Radius;
			if (m_BoneTotalLength > 0f)
			{
				float time = particle.m_BoneLength / m_BoneTotalLength;
				if (m_DampingDistrib != null && m_DampingDistrib.keys.Length != 0)
				{
					particle.m_Damping *= m_DampingDistrib.Evaluate(time);
				}
				if (m_ElasticityDistrib != null && m_ElasticityDistrib.keys.Length != 0)
				{
					particle.m_Elasticity *= m_ElasticityDistrib.Evaluate(time);
				}
				if (m_StiffnessDistrib != null && m_StiffnessDistrib.keys.Length != 0)
				{
					particle.m_Stiffness *= m_StiffnessDistrib.Evaluate(time);
				}
				if (m_InertDistrib != null && m_InertDistrib.keys.Length != 0)
				{
					particle.m_Inert *= m_InertDistrib.Evaluate(time);
				}
				if (m_FrictionDistrib != null && m_FrictionDistrib.keys.Length != 0)
				{
					particle.m_Friction *= m_FrictionDistrib.Evaluate(time);
				}
				if (m_RadiusDistrib != null && m_RadiusDistrib.keys.Length != 0)
				{
					particle.m_Radius *= m_RadiusDistrib.Evaluate(time);
				}
			}
			particle.m_Damping = Mathf.Clamp01(particle.m_Damping);
			particle.m_Elasticity = Mathf.Clamp01(particle.m_Elasticity);
			particle.m_Stiffness = Mathf.Clamp01(particle.m_Stiffness);
			particle.m_Inert = Mathf.Clamp01(particle.m_Inert);
			particle.m_Friction = Mathf.Clamp01(particle.m_Friction);
			particle.m_Radius = Mathf.Max(particle.m_Radius, 0f);
		}
	}

	private void InitTransforms()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_Transform != null)
			{
				particle.m_Transform.localPosition = particle.m_InitLocalPosition;
				particle.m_Transform.localRotation = particle.m_InitLocalRotation;
			}
		}
	}

	private void ResetParticlesPosition()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_Transform != null)
			{
				particle.m_Position = (particle.m_PrevPosition = particle.m_Transform.position);
			}
			else
			{
				Transform transform = m_Particles[particle.m_ParentIndex].m_Transform;
				particle.m_Position = (particle.m_PrevPosition = transform.TransformPoint(particle.m_EndOffset));
			}
			particle.m_isCollide = false;
		}
		m_ObjectPrevPosition = base.transform.position;
	}

	private void UpdateParticles1()
	{
		Vector3 gravity = m_Gravity;
		Vector3 normalized = m_Gravity.normalized;
		Vector3 lhs = m_Root.TransformDirection(m_LocalGravity);
		Vector3 vector = normalized * Mathf.Max(Vector3.Dot(lhs, normalized), 0f);
		gravity -= vector;
		gravity = (gravity + m_Force) * m_ObjectScale;
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				Vector3 vector2 = particle.m_Position - particle.m_PrevPosition;
				Vector3 vector3 = m_ObjectMove * particle.m_Inert;
				particle.m_PrevPosition = particle.m_Position + vector3;
				float num = particle.m_Damping;
				if (particle.m_isCollide)
				{
					num += particle.m_Friction;
					if (num > 1f)
					{
						num = 1f;
					}
					particle.m_isCollide = false;
				}
				particle.m_Position += vector2 * (1f - num) + gravity + vector3;
			}
			else
			{
				particle.m_PrevPosition = particle.m_Position;
				particle.m_Position = particle.m_Transform.position;
			}
		}
	}

	private void UpdateParticles2()
	{
		Plane plane = default(Plane);
		for (int i = 1; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			Particle particle2 = m_Particles[particle.m_ParentIndex];
			float num = ((!(particle.m_Transform != null)) ? particle2.m_Transform.localToWorldMatrix.MultiplyVector(particle.m_EndOffset).magnitude : (particle2.m_Transform.position - particle.m_Transform.position).magnitude);
			float num2 = Mathf.Lerp(1f, particle.m_Stiffness, m_Weight);
			if (num2 > 0f || particle.m_Elasticity > 0f)
			{
				Matrix4x4 localToWorldMatrix = particle2.m_Transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, particle2.m_Position);
				Vector3 vector = ((!(particle.m_Transform != null)) ? localToWorldMatrix.MultiplyPoint3x4(particle.m_EndOffset) : localToWorldMatrix.MultiplyPoint3x4(particle.m_Transform.localPosition));
				Vector3 vector2 = vector - particle.m_Position;
				particle.m_Position += vector2 * particle.m_Elasticity;
				if (num2 > 0f)
				{
					vector2 = vector - particle.m_Position;
					float magnitude = vector2.magnitude;
					float num3 = num * (1f - num2) * 2f;
					if (magnitude > num3)
					{
						particle.m_Position += vector2 * ((magnitude - num3) / magnitude);
					}
				}
			}
			if (m_Colliders != null)
			{
				float particleRadius = particle.m_Radius * m_ObjectScale;
				for (int j = 0; j < m_Colliders.Count; j++)
				{
					DynamicBoneColliderBase dynamicBoneColliderBase = m_Colliders[j];
					if (dynamicBoneColliderBase != null && dynamicBoneColliderBase.enabled)
					{
						particle.m_isCollide |= dynamicBoneColliderBase.Collide(ref particle.m_Position, particleRadius);
					}
				}
			}
			if (m_FreezeAxis != 0)
			{
				switch (m_FreezeAxis)
				{
				case FreezeAxis.X:
					plane.SetNormalAndPosition(particle2.m_Transform.right, particle2.m_Position);
					break;
				case FreezeAxis.Y:
					plane.SetNormalAndPosition(particle2.m_Transform.up, particle2.m_Position);
					break;
				case FreezeAxis.Z:
					plane.SetNormalAndPosition(particle2.m_Transform.forward, particle2.m_Position);
					break;
				}
				particle.m_Position -= plane.normal * plane.GetDistanceToPoint(particle.m_Position);
			}
			Vector3 vector3 = particle2.m_Position - particle.m_Position;
			float magnitude2 = vector3.magnitude;
			if (magnitude2 > 0f)
			{
				particle.m_Position += vector3 * ((magnitude2 - num) / magnitude2);
			}
		}
	}

	private void SkipUpdateParticles()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				particle.m_PrevPosition += m_ObjectMove;
				particle.m_Position += m_ObjectMove;
				Particle particle2 = m_Particles[particle.m_ParentIndex];
				float num = ((!(particle.m_Transform != null)) ? particle2.m_Transform.localToWorldMatrix.MultiplyVector(particle.m_EndOffset).magnitude : (particle2.m_Transform.position - particle.m_Transform.position).magnitude);
				float num2 = Mathf.Lerp(1f, particle.m_Stiffness, m_Weight);
				if (num2 > 0f)
				{
					Matrix4x4 localToWorldMatrix = particle2.m_Transform.localToWorldMatrix;
					localToWorldMatrix.SetColumn(3, particle2.m_Position);
					Vector3 vector = ((!(particle.m_Transform != null)) ? localToWorldMatrix.MultiplyPoint3x4(particle.m_EndOffset) : localToWorldMatrix.MultiplyPoint3x4(particle.m_Transform.localPosition));
					Vector3 vector2 = vector - particle.m_Position;
					float magnitude = vector2.magnitude;
					float num3 = num * (1f - num2) * 2f;
					if (magnitude > num3)
					{
						particle.m_Position += vector2 * ((magnitude - num3) / magnitude);
					}
				}
				Vector3 vector3 = particle2.m_Position - particle.m_Position;
				float magnitude2 = vector3.magnitude;
				if (magnitude2 > 0f)
				{
					particle.m_Position += vector3 * ((magnitude2 - num) / magnitude2);
				}
			}
			else
			{
				particle.m_PrevPosition = particle.m_Position;
				particle.m_Position = particle.m_Transform.position;
			}
		}
	}

	private static Vector3 MirrorVector(Vector3 v, Vector3 axis)
	{
		return v - axis * (Vector3.Dot(v, axis) * 2f);
	}

	private void ApplyParticlesToTransforms()
	{
		for (int i = 1; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			Particle particle2 = m_Particles[particle.m_ParentIndex];
			if (particle2.m_Transform.childCount <= 1)
			{
				Vector3 direction = ((!(particle.m_Transform != null)) ? particle.m_EndOffset : particle.m_Transform.localPosition);
				Vector3 toDirection = particle.m_Position - particle2.m_Position;
				Quaternion quaternion = Quaternion.FromToRotation(particle2.m_Transform.TransformDirection(direction), toDirection);
				particle2.m_Transform.rotation = quaternion * particle2.m_Transform.rotation;
			}
			if (particle.m_Transform != null)
			{
				particle.m_Transform.position = particle.m_Position;
			}
		}
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone Collider")]
public class DynamicBoneCollider : DynamicBoneColliderBase
{
	[Tooltip("The radius of the sphere or capsule.")]
	public float m_Radius = 0.5f;

	[Tooltip("The height of the capsule.")]
	public float m_Height;

	private void OnValidate()
	{
		m_Radius = Mathf.Max(m_Radius, 0f);
		m_Height = Mathf.Max(m_Height, 0f);
	}

	public override bool Collide(ref Vector3 particlePosition, float particleRadius)
	{
		float num = m_Radius * Mathf.Abs(base.transform.lossyScale.x);
		float num2 = m_Height * 0.5f - m_Radius;
		if (num2 <= 0f)
		{
			if (m_Bound == Bound.Outside)
			{
				return OutsideSphere(ref particlePosition, particleRadius, base.transform.TransformPoint(m_Center), num);
			}
			return InsideSphere(ref particlePosition, particleRadius, base.transform.TransformPoint(m_Center), num);
		}
		Vector3 center = m_Center;
		Vector3 center2 = m_Center;
		switch (m_Direction)
		{
		case Direction.X:
			center.x -= num2;
			center2.x += num2;
			break;
		case Direction.Y:
			center.y -= num2;
			center2.y += num2;
			break;
		case Direction.Z:
			center.z -= num2;
			center2.z += num2;
			break;
		}
		if (m_Bound == Bound.Outside)
		{
			return OutsideCapsule(ref particlePosition, particleRadius, base.transform.TransformPoint(center), base.transform.TransformPoint(center2), num);
		}
		return InsideCapsule(ref particlePosition, particleRadius, base.transform.TransformPoint(center), base.transform.TransformPoint(center2), num);
	}

	private static bool OutsideSphere(ref Vector3 particlePosition, float particleRadius, Vector3 sphereCenter, float sphereRadius)
	{
		float num = sphereRadius + particleRadius;
		float num2 = num * num;
		Vector3 vector = particlePosition - sphereCenter;
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude > 0f && sqrMagnitude < num2)
		{
			float num3 = Mathf.Sqrt(sqrMagnitude);
			particlePosition = sphereCenter + vector * (num / num3);
			return true;
		}
		return false;
	}

	private static bool InsideSphere(ref Vector3 particlePosition, float particleRadius, Vector3 sphereCenter, float sphereRadius)
	{
		float num = sphereRadius - particleRadius;
		float num2 = num * num;
		Vector3 vector = particlePosition - sphereCenter;
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude > num2)
		{
			float num3 = Mathf.Sqrt(sqrMagnitude);
			particlePosition = sphereCenter + vector * (num / num3);
			return true;
		}
		return false;
	}

	private static bool OutsideCapsule(ref Vector3 particlePosition, float particleRadius, Vector3 capsuleP0, Vector3 capsuleP1, float capsuleRadius)
	{
		float num = capsuleRadius + particleRadius;
		float num2 = num * num;
		Vector3 vector = capsuleP1 - capsuleP0;
		Vector3 vector2 = particlePosition - capsuleP0;
		float num3 = Vector3.Dot(vector2, vector);
		if (num3 <= 0f)
		{
			float sqrMagnitude = vector2.sqrMagnitude;
			if (sqrMagnitude > 0f && sqrMagnitude < num2)
			{
				float num4 = Mathf.Sqrt(sqrMagnitude);
				particlePosition = capsuleP0 + vector2 * (num / num4);
				return true;
			}
		}
		else
		{
			float sqrMagnitude2 = vector.sqrMagnitude;
			if (num3 >= sqrMagnitude2)
			{
				vector2 = particlePosition - capsuleP1;
				float sqrMagnitude3 = vector2.sqrMagnitude;
				if (sqrMagnitude3 > 0f && sqrMagnitude3 < num2)
				{
					float num5 = Mathf.Sqrt(sqrMagnitude3);
					particlePosition = capsuleP1 + vector2 * (num / num5);
					return true;
				}
			}
			else if (sqrMagnitude2 > 0f)
			{
				num3 /= sqrMagnitude2;
				vector2 -= vector * num3;
				float sqrMagnitude4 = vector2.sqrMagnitude;
				if (sqrMagnitude4 > 0f && sqrMagnitude4 < num2)
				{
					float num6 = Mathf.Sqrt(sqrMagnitude4);
					particlePosition += vector2 * ((num - num6) / num6);
					return true;
				}
			}
		}
		return false;
	}

	private static bool InsideCapsule(ref Vector3 particlePosition, float particleRadius, Vector3 capsuleP0, Vector3 capsuleP1, float capsuleRadius)
	{
		float num = capsuleRadius - particleRadius;
		float num2 = num * num;
		Vector3 vector = capsuleP1 - capsuleP0;
		Vector3 vector2 = particlePosition - capsuleP0;
		float num3 = Vector3.Dot(vector2, vector);
		if (num3 <= 0f)
		{
			float sqrMagnitude = vector2.sqrMagnitude;
			if (sqrMagnitude > num2)
			{
				float num4 = Mathf.Sqrt(sqrMagnitude);
				particlePosition = capsuleP0 + vector2 * (num / num4);
				return true;
			}
		}
		else
		{
			float sqrMagnitude2 = vector.sqrMagnitude;
			if (num3 >= sqrMagnitude2)
			{
				vector2 = particlePosition - capsuleP1;
				float sqrMagnitude3 = vector2.sqrMagnitude;
				if (sqrMagnitude3 > num2)
				{
					float num5 = Mathf.Sqrt(sqrMagnitude3);
					particlePosition = capsuleP1 + vector2 * (num / num5);
					return true;
				}
			}
			else if (sqrMagnitude2 > 0f)
			{
				num3 /= sqrMagnitude2;
				vector2 -= vector * num3;
				float sqrMagnitude4 = vector2.sqrMagnitude;
				if (sqrMagnitude4 > num2)
				{
					float num6 = Mathf.Sqrt(sqrMagnitude4);
					particlePosition += vector2 * ((num - num6) / num6);
					return true;
				}
			}
		}
		return false;
	}

	private void OnDrawGizmosSelected()
	{
		if (!base.enabled)
		{
			return;
		}
		if (m_Bound == Bound.Outside)
		{
			Gizmos.color = Color.yellow;
		}
		else
		{
			Gizmos.color = Color.magenta;
		}
		float radius = m_Radius * Mathf.Abs(base.transform.lossyScale.x);
		float num = m_Height * 0.5f - m_Radius;
		if (num <= 0f)
		{
			Gizmos.DrawWireSphere(base.transform.TransformPoint(m_Center), radius);
			return;
		}
		Vector3 center = m_Center;
		Vector3 center2 = m_Center;
		switch (m_Direction)
		{
		case Direction.X:
			center.x -= num;
			center2.x += num;
			break;
		case Direction.Y:
			center.y -= num;
			center2.y += num;
			break;
		case Direction.Z:
			center.z -= num;
			center2.z += num;
			break;
		}
		Gizmos.DrawWireSphere(base.transform.TransformPoint(center), radius);
		Gizmos.DrawWireSphere(base.transform.TransformPoint(center2), radius);
	}
}
public class DynamicBoneColliderBase : MonoBehaviour
{
	public enum Direction
	{
		X,
		Y,
		Z
	}

	public enum Bound
	{
		Outside,
		Inside
	}

	[Tooltip("The axis of the capsule's height.")]
	public Direction m_Direction = Direction.Y;

	[Tooltip("The center of the sphere or capsule, in the object's local space.")]
	public Vector3 m_Center = Vector3.zero;

	[Tooltip("Constrain bones to outside bound or inside bound.")]
	public Bound m_Bound;

	public virtual bool Collide(ref Vector3 particlePosition, float particleRadius)
	{
		return false;
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone Plane Collider")]
public class DynamicBonePlaneCollider : DynamicBoneColliderBase
{
	private void OnValidate()
	{
	}

	public override bool Collide(ref Vector3 particlePosition, float particleRadius)
	{
		Vector3 vector = Vector3.up;
		switch (m_Direction)
		{
		case Direction.X:
			vector = base.transform.right;
			break;
		case Direction.Y:
			vector = base.transform.up;
			break;
		case Direction.Z:
			vector = base.transform.forward;
			break;
		}
		Vector3 inPoint = base.transform.TransformPoint(m_Center);
		float distanceToPoint = new Plane(vector, inPoint).GetDistanceToPoint(particlePosition);
		if (m_Bound == Bound.Outside)
		{
			if (distanceToPoint < 0f)
			{
				particlePosition -= vector * distanceToPoint;
				return true;
			}
		}
		else if (distanceToPoint > 0f)
		{
			particlePosition -= vector * distanceToPoint;
			return true;
		}
		return false;
	}

	private void OnDrawGizmosSelected()
	{
		if (base.enabled)
		{
			if (m_Bound == Bound.Outside)
			{
				Gizmos.color = Color.yellow;
			}
			else
			{
				Gizmos.color = Color.magenta;
			}
			Vector3 vector = Vector3.up;
			switch (m_Direction)
			{
			case Direction.X:
				vector = base.transform.right;
				break;
			case Direction.Y:
				vector = base.transform.up;
				break;
			case Direction.Z:
				vector = base.transform.forward;
				break;
			}
			Vector3 vector2 = base.transform.TransformPoint(m_Center);
			Gizmos.DrawLine(vector2, vector2 + vector);
		}
	}
}
public class PortalEntry : MonoBehaviour
{
	public Collider playerCollider;

	public GameObject hmdRig;

	public GameObject hmdEye;

	public StereoRenderer stereoRenderer;

	private void OnTriggerEnter(Collider other)
	{
		if (other == playerCollider)
		{
			stereoRenderer.shouldRender = false;
			Quaternion quaternion = stereoRenderer.anchorRot * Quaternion.Inverse(stereoRenderer.canvasOriginRot);
			hmdRig.transform.rotation = quaternion * hmdRig.transform.rotation;
			Vector3 vector = new Vector3(stereoRenderer.stereoCameraHead.transform.position.x - hmdEye.transform.position.x, stereoRenderer.stereoCameraHead.transform.position.y - hmdEye.transform.position.y, stereoRenderer.stereoCameraHead.transform.position.z - hmdEye.transform.position.z);
			Vector3 position = hmdRig.transform.position + vector;
			hmdRig.transform.position = position;
			stereoRenderer.shouldRender = true;
		}
	}
}
public class CreateStereoRenderer : MonoBehaviour
{
	public GameObject target;

	private void Update()
	{
		if (target.GetComponent<StereoRenderer>() == null && Input.GetKeyDown(KeyCode.Space))
		{
			StereoRenderer stereoRenderer = target.AddComponent<StereoRenderer>();
			stereoRenderer.SetUnlit(value: true);
			stereoRenderer.anchorPos = new Vector3(-0.22f, 0f, -2.39f);
			stereoRenderer.anchorEuler = new Vector3(0f, 180f, 0f);
			stereoRenderer.canvasOriginPos = new Vector3(0f, 0f, 6.57f);
		}
	}
}
[RequireComponent(typeof(StereoRenderer))]
public class PortalDoorCollideDetection : MonoBehaviour
{
	public Collider playerCollider;

	public PortalSet portalManger;

	private StereoRenderer stereoRenderer;

	private void OnEnable()
	{
		stereoRenderer = GetComponent<StereoRenderer>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other == playerCollider)
		{
			Debug.Log("**" + stereoRenderer.gameObject.transform.parent.name);
			portalManger.OnPlayerEnter(stereoRenderer);
		}
	}
}
public class PortalSet : MonoBehaviour
{
	public GameObject hmdRig;

	public GameObject hmdEye;

	private bool isColliding;

	public void OnPlayerEnter(StereoRenderer stereoRenderer)
	{
		if (!isColliding)
		{
			StartCoroutine(MovePlayer(stereoRenderer));
		}
	}

	private IEnumerator MovePlayer(StereoRenderer stereoRenderer)
	{
		isColliding = true;
		Debug.Log(stereoRenderer.gameObject.transform.parent.name);
		stereoRenderer.shouldRender = false;
		Quaternion quaternion = stereoRenderer.anchorRot * Quaternion.Inverse(stereoRenderer.canvasOriginRot);
		hmdRig.transform.rotation = quaternion * hmdRig.transform.rotation;
		Vector3 vector = new Vector3(stereoRenderer.stereoCameraHead.transform.position.x - hmdEye.transform.position.x, stereoRenderer.stereoCameraHead.transform.position.y - hmdEye.transform.position.y, stereoRenderer.stereoCameraHead.transform.position.z - hmdEye.transform.position.z);
		(stereoRenderer.anchorRot * Vector3.forward).Normalize();
		Vector3 position = hmdRig.transform.position + vector;
		hmdRig.transform.position = position;
		stereoRenderer.shouldRender = true;
		yield return new WaitForSeconds(0.1f);
		isColliding = false;
	}
}
public class FollowHmd : MonoBehaviour
{
	public GameObject hmdCamera;

	private void Update()
	{
		base.transform.position = hmdCamera.transform.position;
	}
}
public class EnableSwitch : MonoBehaviour
{
	public GameObject[] SwitchTargets;

	public bool SetActive<T>(int target) where T : MonoBehaviour
	{
		if (target < 0 || target >= SwitchTargets.Length)
		{
			return false;
		}
		for (int i = 0; i < SwitchTargets.Length; i++)
		{
			SwitchTargets[i].SetActive(value: false);
			OVRLipSyncContextMorphTarget component = SwitchTargets[i].GetComponent<OVRLipSyncContextMorphTarget>();
			if ((bool)component)
			{
				component.enabled = false;
			}
			OVRLipSyncContextTextureFlip component2 = SwitchTargets[i].GetComponent<OVRLipSyncContextTextureFlip>();
			if ((bool)component2)
			{
				component2.enabled = false;
			}
		}
		SwitchTargets[target].SetActive(value: true);
		MonoBehaviour component3 = SwitchTargets[target].GetComponent<T>();
		if (component3 != null)
		{
			component3.enabled = true;
		}
		return true;
	}
}
public class LipSyncDemo_Control : MonoBehaviour
{
	[Tooltip("Key used to rotate the demo object up to 45 degrees to the left.")]
	public KeyCode rotateLeftKey = KeyCode.LeftArrow;

	[Tooltip("Key used to rotate the demo object up to 45 degrees to the right.")]
	public KeyCode rotateRightKey = KeyCode.RightArrow;

	[Tooltip("Key used to reset demo object rotation.")]
	public KeyCode resetRotationKey = KeyCode.DownArrow;

	private float resetRotation = 180f;

	private float rotationAmount = 20f;

	private float rotationMax = 45f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(rotateLeftKey))
		{
			RotateObject(rotationAmount);
		}
		else if (Input.GetKey(rotateRightKey))
		{
			RotateObject(0f - rotationAmount);
		}
		else if (Input.GetKey(resetRotationKey))
		{
			RotateObject(resetRotation, absolute: true);
		}
	}

	private void RotateObject(float amountDegrees, bool absolute = false)
	{
		GameObject gameObject = GameObject.Find("LipSyncMorphTarget_Female");
		if (gameObject == null)
		{
			gameObject = GameObject.Find("RobotHead_TextureFlip");
		}
		if (!gameObject)
		{
			return;
		}
		if (absolute)
		{
			float num = amountDegrees - gameObject.transform.eulerAngles.y;
			gameObject.transform.Rotate(Vector3.up * num);
			return;
		}
		float num2 = Time.deltaTime * amountDegrees;
		if (num2 + gameObject.transform.eulerAngles.y >= resetRotation - rotationMax && num2 + gameObject.transform.eulerAngles.y <= resetRotation + rotationMax)
		{
			gameObject.transform.Rotate(Vector3.up * num2);
		}
	}
}
public class LipSyncDemo_SetCurrentTarget : MonoBehaviour
{
	public EnableSwitch[] SwitchTargets;

	private int targetSet;

	private int maxTarget = 6;

	private bool XRButtonBeingPressed;

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
		targetSet = 0;
		SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
		SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			targetSet = 0;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			targetSet = 1;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			targetSet = 2;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			targetSet = 3;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			targetSet = 4;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			targetSet = 5;
			SetCurrentTarget();
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
		List<InputDevice> list = new List<InputDevice>();
		InputDevices.GetDevicesWithCharacteristics(InputDeviceCharacteristics.HeldInHand, list);
		bool flag = false;
		bool flag2 = false;
		foreach (InputDevice item in list)
		{
			if (item.TryGetFeatureValue(CommonUsages.primaryButton, out var value) && value)
			{
				flag = true;
			}
			if (item.TryGetFeatureValue(CommonUsages.secondaryButton, out value) && value)
			{
				flag2 = true;
			}
		}
		if (flag && !XRButtonBeingPressed)
		{
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
		}
		if (flag2 && !XRButtonBeingPressed)
		{
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
		}
		XRButtonBeingPressed = flag || flag2;
	}

	private void SetCurrentTarget()
	{
		switch (targetSet)
		{
		case 0:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
			break;
		case 1:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(1);
			break;
		case 2:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(2);
			break;
		case 3:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(3);
			break;
		case 4:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(4);
			break;
		case 5:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(5);
			break;
		}
		OVRLipSyncDebugConsole.Clear();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.Left:
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
			break;
		case OVRTouchpad.TouchEvent.Right:
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
			break;
		}
	}
}
public class OVRLipSyncDebugConsole : MonoBehaviour
{
	public ArrayList messages = new ArrayList();

	public int maxMessages = 15;

	public Text textMsg;

	private static OVRLipSyncDebugConsole s_Instance;

	private bool clearTimeoutOn;

	private float clearTimeout;

	public static OVRLipSyncDebugConsole instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				if (s_Instance == null)
				{
					GameObject obj = new GameObject();
					obj.AddComponent<OVRLipSyncDebugConsole>();
					obj.name = "OVRLipSyncDebugConsole";
					s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				}
			}
			return s_Instance;
		}
	}

	private void Awake()
	{
		s_Instance = this;
		Init();
	}

	private void Update()
	{
		if (clearTimeoutOn)
		{
			clearTimeout -= Time.deltaTime;
			if (clearTimeout < 0f)
			{
				Clear();
				clearTimeout = 0f;
				clearTimeoutOn = false;
			}
		}
	}

	public void Init()
	{
		if (textMsg == null)
		{
			Debug.LogWarning("DebugConsole Init WARNING::UI text not set. Will not be able to display anything.");
		}
		Clear();
	}

	public static void Log(string message)
	{
		instance.AddMessage(message, Color.white);
	}

	public static void Log(string message, Color color)
	{
		instance.AddMessage(message, color);
	}

	public static void Clear()
	{
		instance.ClearMessages();
	}

	public static void ClearTimeout(float timeToClear)
	{
		instance.SetClearTimeout(timeToClear);
	}

	public void AddMessage(string message, Color color)
	{
		messages.Add(message);
		if (textMsg != null)
		{
			textMsg.color = color;
		}
		Display();
	}

	public void ClearMessages()
	{
		messages.Clear();
		Display();
	}

	public void SetClearTimeout(float timeout)
	{
		clearTimeout = timeout;
		clearTimeoutOn = true;
	}

	private void Prune()
	{
		if (messages.Count > maxMessages)
		{
			int count = ((messages.Count > 0) ? (messages.Count - maxMessages) : 0);
			messages.RemoveRange(0, count);
		}
	}

	private void Display()
	{
		if (messages.Count > maxMessages)
		{
			Prune();
		}
		if (textMsg != null)
		{
			textMsg.text = "";
			for (int i = 0; i < messages.Count; i++)
			{
				textMsg.text += (string)messages[i];
				textMsg.text += "\n";
			}
		}
	}
}
public class OVRNamedArrayAttribute : PropertyAttribute
{
	public readonly string[] names;

	public OVRNamedArrayAttribute(string[] names)
	{
		this.names = names;
	}
}
public static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		DoubleTap,
		Left,
		Right,
		Up,
		Down
	}

	public delegate void OVRTouchpadCallback<TouchEvent>(TouchEvent arg);

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	public static Delegate touchPadCallbacks = null;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if ((object)touchPadCallbacks == null)
		{
			return;
		}
		OVRTouchpadCallback<TouchEvent> oVRTouchpadCallback = touchPadCallbacks as OVRTouchpadCallback<TouchEvent>;
		if (move.magnitude < minMovMagnitudeMouse)
		{
			oVRTouchpadCallback(TouchEvent.SingleTap);
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				oVRTouchpadCallback(TouchEvent.Left);
			}
			else
			{
				oVRTouchpadCallback(TouchEvent.Right);
			}
		}
		else if (move.y > 0f)
		{
			oVRTouchpadCallback(TouchEvent.Down);
		}
		else
		{
			oVRTouchpadCallback(TouchEvent.Up);
		}
	}

	public static void AddListener(OVRTouchpadCallback<TouchEvent> handler)
	{
		touchPadCallbacks = (OVRTouchpadCallback<TouchEvent>)Delegate.Combine((OVRTouchpadCallback<TouchEvent>)touchPadCallbacks, handler);
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		}
	}
}
public class OVRLipSync : MonoBehaviour
{
	public enum Result
	{
		Success = 0,
		Unknown = -2200,
		CannotCreateContext = -2201,
		InvalidParam = -2202,
		BadSampleRate = -2203,
		MissingDLL = -2204,
		BadVersion = -2205,
		UndefinedFunction = -2206
	}

	public enum AudioDataType
	{
		S16_Mono,
		S16_Stereo,
		F32_Mono,
		F32_Stereo
	}

	public enum Viseme
	{
		sil,
		PP,
		FF,
		TH,
		DD,
		kk,
		CH,
		SS,
		nn,
		RR,
		aa,
		E,
		ih,
		oh,
		ou
	}

	public enum Signals
	{
		VisemeOn,
		VisemeOff,
		VisemeAmount,
		VisemeSmoothing,
		LaughterAmount
	}

	public enum ContextProviders
	{
		Original,
		Enhanced,
		Enhanced_with_Laughter
	}

	[Serializable]
	public class Frame
	{
		public int frameNumber;

		public int frameDelay;

		public float[] Visemes = new float[VisemeCount];

		public float laughterScore;

		public void CopyInput(Frame input)
		{
			frameNumber = input.frameNumber;
			frameDelay = input.frameDelay;
			input.Visemes.CopyTo(Visemes, 0);
			laughterScore = input.laughterScore;
		}

		public void Reset()
		{
			frameNumber = 0;
			frameDelay = 0;
			Array.Clear(Visemes, 0, VisemeCount);
			laughterScore = 0f;
		}
	}

	public static readonly int VisemeCount = Enum.GetNames(typeof(Viseme)).Length;

	public static readonly int SignalCount = Enum.GetNames(typeof(Signals)).Length;

	public const string strOVRLS = "OVRLipSync";

	private static Result sInitialized = Result.Unknown;

	public static OVRLipSync sInstance = null;

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_Initialize(int samplerate, int buffersize);

	[DllImport("OVRLipSync")]
	private static extern void ovrLipSyncDll_Shutdown();

	[DllImport("OVRLipSync")]
	private static extern IntPtr ovrLipSyncDll_GetVersion(ref int Major, ref int Minor, ref int Patch);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextEx(ref uint context, ContextProviders provider, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_DestroyContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ResetContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_SendSignal(uint context, Signals signal, int arg1, int arg2);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrameEx(uint context, IntPtr audioBuffer, uint bufferSize, AudioDataType dataType, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount, ref float laughterScore, float[] laughterCategories, int laughterCategoriesLength);

	private void Awake()
	{
		if (sInstance == null)
		{
			sInstance = this;
			if (IsInitialized() != 0)
			{
				sInitialized = Initialize();
				if (sInitialized != 0)
				{
					Debug.LogWarning($"OvrLipSync Awake: Failed to init Speech Rec library");
				}
			}
			OVRTouchpad.Create();
		}
		else
		{
			Debug.LogWarning($"OVRLipSync Awake: Only one instance of OVRPLipSync can exist in the scene.");
		}
	}

	private void OnDestroy()
	{
		if (sInstance != this)
		{
			Debug.LogWarning("OVRLipSync OnDestroy: This is not the correct OVRLipSync instance.");
		}
	}

	public static Result Initialize()
	{
		int outputSampleRate = AudioSettings.outputSampleRate;
		AudioSettings.GetDSPBufferSize(out var bufferLength, out var _);
		Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {outputSampleRate:F0} BufferSize: {bufferLength:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(outputSampleRate, bufferLength);
		return sInitialized;
	}

	public static Result Initialize(int sampleRate, int bufferSize)
	{
		Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {sampleRate:F0} BufferSize: {bufferSize:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(sampleRate, bufferSize);
		return sInitialized;
	}

	public static void Shutdown()
	{
		ovrLipSyncDll_Shutdown();
		sInitialized = Result.Unknown;
	}

	public static Result IsInitialized()
	{
		return sInitialized;
	}

	public static Result CreateContext(ref uint context, ContextProviders provider, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextEx(ref context, provider, sampleRate, enableAcceleration);
	}

	public static Result CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextWithModelFile(ref context, provider, modelPath, sampleRate, enableAcceleration);
	}

	public static Result DestroyContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_DestroyContext(context);
	}

	public static Result ResetContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ResetContext(context);
	}

	public static Result SendSignal(uint context, Signals signal, int arg1, int arg2)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_SendSignal(context, signal, arg1, arg2);
	}

	public static Result ProcessFrame(uint context, float[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.F32_Stereo : AudioDataType.F32_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}

	public static Result ProcessFrame(uint context, short[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.S16_Stereo : AudioDataType.S16_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContext : OVRLipSyncContextBase
{
	[Tooltip("Allow capturing of keyboard input to control operation.")]
	public bool enableKeyboardInput;

	[Tooltip("Register a mouse/touch callback to control loopback and gain (requires script restart).")]
	public bool enableTouchInput;

	[Tooltip("Play input audio back through audio output.")]
	public bool audioLoopback;

	[Tooltip("Key to toggle audio loopback.")]
	public KeyCode loopbackKey = KeyCode.L;

	[Tooltip("Show viseme scores in an OVRLipSyncDebugConsole display.")]
	public bool showVisemes;

	[Tooltip("Key to toggle viseme score display.")]
	public KeyCode debugVisemesKey = KeyCode.D;

	[Tooltip("Skip data from the Audio Source. Use if you intend to pass audio data in manually.")]
	public bool skipAudioSource;

	[Tooltip("Adjust the linear audio gain multiplier before processing lipsync")]
	public float gain = 1f;

	private bool hasDebugConsole;

	public KeyCode debugLaughterKey = KeyCode.H;

	public bool showLaughter;

	public float laughterScore;

	private void Start()
	{
		if (enableTouchInput)
		{
			OVRTouchpad.AddListener(LocalTouchEventCallback);
		}
		OVRLipSyncDebugConsole[] array = UnityEngine.Object.FindObjectsOfType<OVRLipSyncDebugConsole>();
		if (array.Length != 0)
		{
			hasDebugConsole = array[0];
		}
	}

	private void HandleKeyboard()
	{
		if (Input.GetKeyDown(loopbackKey))
		{
			ToggleAudioLoopback();
		}
		else if (Input.GetKeyDown(debugVisemesKey))
		{
			showVisemes = !showVisemes;
			if (showVisemes)
			{
				if (hasDebugConsole)
				{
					Debug.Log("DEBUG SHOW VISEMES: ENABLED");
					return;
				}
				Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showVisemes = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				Debug.Log("DEBUG SHOW VISEMES: DISABLED");
			}
		}
		else if (Input.GetKeyDown(debugLaughterKey))
		{
			showLaughter = !showLaughter;
			if (showLaughter)
			{
				if (hasDebugConsole)
				{
					Debug.Log("DEBUG SHOW LAUGHTER: ENABLED");
					return;
				}
				Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showLaughter = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				Debug.Log("DEBUG SHOW LAUGHTER: DISABLED");
			}
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			string text = "LINEAR GAIN: ";
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			string text2 = "LINEAR GAIN: ";
			text2 += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text2);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
	}

	private void Update()
	{
		if (enableKeyboardInput)
		{
			HandleKeyboard();
		}
		laughterScore = base.Frame.laughterScore;
		DebugShowVisemesAndLaughter();
	}

	public void PreprocessAudioSamples(float[] data, int channels)
	{
		for (int i = 0; i < data.Length; i++)
		{
			data[i] *= gain;
		}
	}

	public void PostprocessAudioSamples(float[] data, int channels)
	{
		if (!audioLoopback)
		{
			for (int i = 0; i < data.Length; i++)
			{
				data[i] *= 0f;
			}
		}
	}

	public void ProcessAudioSamplesRaw(float[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamplesRaw(short[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamples(float[] data, int channels)
	{
		if (OVRLipSync.IsInitialized() == OVRLipSync.Result.Success && !(audioSource == null))
		{
			PreprocessAudioSamples(data, channels);
			ProcessAudioSamplesRaw(data, channels);
			PostprocessAudioSamples(data, channels);
		}
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		if (!skipAudioSource)
		{
			ProcessAudioSamples(data, channels);
		}
	}

	private void DebugShowVisemesAndLaughter()
	{
		if (!hasDebugConsole)
		{
			return;
		}
		string text = "";
		if (showLaughter)
		{
			text += "Laughter:";
			int num = (int)(50f * base.Frame.laughterScore);
			for (int i = 0; i < num; i++)
			{
				text += "*";
			}
			text += "\n";
		}
		if (showVisemes)
		{
			for (int j = 0; j < base.Frame.Visemes.Length; j++)
			{
				string text2 = text;
				OVRLipSync.Viseme viseme = (OVRLipSync.Viseme)j;
				text = text2 + viseme;
				text += ":";
				int num2 = (int)(50f * base.Frame.Visemes[j]);
				for (int k = 0; k < num2; k++)
				{
					text += "*";
				}
				text += "\n";
			}
		}
		OVRLipSyncDebugConsole.Clear();
		if (text != "")
		{
			OVRLipSyncDebugConsole.Log(text);
		}
	}

	private void ToggleAudioLoopback()
	{
		audioLoopback = !audioLoopback;
		if (hasDebugConsole)
		{
			OVRLipSyncDebugConsole.Clear();
			OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			if (audioLoopback)
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: ENABLED");
			}
			else
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: DISABLED");
			}
		}
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		string text = "LINEAR GAIN: ";
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.SingleTap:
			ToggleAudioLoopback();
			break;
		case OVRTouchpad.TouchEvent.Up:
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		case OVRTouchpad.TouchEvent.Down:
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextBase : MonoBehaviour
{
	public AudioSource audioSource;

	[Tooltip("Which lip sync provider to use for viseme computation.")]
	public OVRLipSync.ContextProviders provider = OVRLipSync.ContextProviders.Enhanced;

	[Tooltip("Enable DSP offload on supported Android devices.")]
	public bool enableAcceleration = true;

	private OVRLipSync.Frame frame = new OVRLipSync.Frame();

	private uint context;

	private int _smoothing;

	public int Smoothing
	{
		get
		{
			return _smoothing;
		}
		set
		{
			switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeSmoothing, value, 0))
			{
			case OVRLipSync.Result.InvalidParam:
				Debug.LogError("OVRLipSyncContextBase.SetSmoothing: A viseme smoothing parameter is invalid, it should be between 1 and 100!");
				break;
			default:
				Debug.LogError("OVRLipSyncContextBase.SetSmoothing: An unexpected error occured.");
				break;
			case OVRLipSync.Result.Success:
				break;
			}
			_smoothing = value;
		}
	}

	public uint Context => context;

	protected OVRLipSync.Frame Frame => frame;

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		lock (this)
		{
			if (context == 0 && OVRLipSync.CreateContext(ref context, provider, 0, enableAcceleration) != 0)
			{
				Debug.LogError("OVRLipSyncContextBase.Start ERROR: Could not create Phoneme context.");
			}
		}
	}

	private void OnDestroy()
	{
		lock (this)
		{
			if (context != 0 && OVRLipSync.DestroyContext(context) != 0)
			{
				Debug.LogError("OVRLipSyncContextBase.OnDestroy ERROR: Could not delete Phoneme context.");
			}
		}
	}

	public OVRLipSync.Frame GetCurrentPhonemeFrame()
	{
		return frame;
	}

	public void SetVisemeBlend(int viseme, int amount)
	{
		switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeAmount, viseme, amount))
		{
		case OVRLipSync.Result.InvalidParam:
			Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: Viseme ID is invalid.");
			break;
		default:
			Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: An unexpected error occured.");
			break;
		case OVRLipSync.Result.Success:
			break;
		}
	}

	public void SetLaughterBlend(int amount)
	{
		if (OVRLipSync.SendSignal(context, OVRLipSync.Signals.LaughterAmount, amount, 0) != 0)
		{
			Debug.LogError("OVRLipSyncContextBase.SetLaughterBlend: An unexpected error occured.");
		}
	}

	public OVRLipSync.Result ResetContext()
	{
		frame.Reset();
		return OVRLipSync.ResetContext(context);
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextCanned : OVRLipSyncContextBase
{
	[Tooltip("Pre-computed viseme sequence asset. Compute from audio in Unity with Tools -> Oculus -> Generate Lip Sync Assets.")]
	public OVRLipSyncSequence currentSequence;

	private void Update()
	{
		if (audioSource.isPlaying && currentSequence != null)
		{
			OVRLipSync.Frame frameAtTime = currentSequence.GetFrameAtTime(audioSource.time);
			base.Frame.CopyInput(frameAtTime);
		}
	}
}
public class OVRLipSyncContextMorphTarget : MonoBehaviour
{
	[Tooltip("Skinned Mesh Rendered target to be driven by Oculus Lipsync")]
	public SkinnedMeshRenderer skinnedMeshRenderer;

	[Tooltip("Blendshape index to trigger for each viseme.")]
	public int[] visemeToBlendTargets = Enumerable.Range(0, OVRLipSync.VisemeCount).ToArray();

	[Tooltip("Enable using the test keys defined below to manually trigger each viseme.")]
	public bool enableVisemeTestKeys;

	[Tooltip("Test keys used to manually trigger an individual viseme - by default the QWERTY row of a US keyboard.")]
	public KeyCode[] visemeTestKeys = new KeyCode[15]
	{
		KeyCode.BackQuote,
		KeyCode.Tab,
		KeyCode.Q,
		KeyCode.W,
		KeyCode.E,
		KeyCode.R,
		KeyCode.T,
		KeyCode.Y,
		KeyCode.U,
		KeyCode.I,
		KeyCode.O,
		KeyCode.P,
		KeyCode.LeftBracket,
		KeyCode.RightBracket,
		KeyCode.Backslash
	};

	[Tooltip("Test key used to manually trigger laughter and visualise the results")]
	public KeyCode laughterKey = KeyCode.CapsLock;

	[Tooltip("Blendshape index to trigger for laughter")]
	public int laughterBlendTarget = OVRLipSync.VisemeCount;

	[Range(0f, 1f)]
	[Tooltip("Laughter probability threshold above which the laughter blendshape will be activated")]
	public float laughterThreshold = 0.5f;

	[Range(0f, 3f)]
	[Tooltip("Laughter animation linear multiplier, the final output will be clamped to 1.0")]
	public float laughterMultiplier = 1.5f;

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme, 100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private void Start()
	{
		if (skinnedMeshRenderer == null)
		{
			Debug.LogError("LipSyncContextMorphTarget.Start Error: Please set the target Skinned Mesh Renderer to be controlled!");
			return;
		}
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			Debug.LogError("LipSyncContextMorphTarget.Start Error: No OVRLipSyncContext component on this object!");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && skinnedMeshRenderer != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				SetVisemeToMorphTarget(currentPhonemeFrame);
				SetLaughterToMorphTarget(currentPhonemeFrame);
			}
			CheckForKeys();
			if (smoothAmount != lipsyncContext.Smoothing)
			{
				lipsyncContext.Smoothing = smoothAmount;
			}
		}
	}

	private void CheckForKeys()
	{
		if (enableVisemeTestKeys)
		{
			for (int i = 0; i < OVRLipSync.VisemeCount; i++)
			{
				CheckVisemeKey(visemeTestKeys[i], i, 100);
			}
		}
		CheckLaughterKey();
	}

	private void SetVisemeToMorphTarget(OVRLipSync.Frame frame)
	{
		for (int i = 0; i < visemeToBlendTargets.Length; i++)
		{
			if (visemeToBlendTargets[i] != -1)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(visemeToBlendTargets[i], frame.Visemes[i] * 100f);
			}
		}
	}

	private void SetLaughterToMorphTarget(OVRLipSync.Frame frame)
	{
		if (laughterBlendTarget != -1)
		{
			float laughterScore = frame.laughterScore;
			laughterScore = ((laughterScore < laughterThreshold) ? 0f : (laughterScore - laughterThreshold));
			laughterScore = Mathf.Min(laughterScore * laughterMultiplier, 1f);
			laughterScore *= 1f / laughterThreshold;
			skinnedMeshRenderer.SetBlendShapeWeight(laughterBlendTarget, laughterScore * 100f);
		}
	}

	private void CheckVisemeKey(KeyCode key, int viseme, int amount)
	{
		if (Input.GetKeyDown(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], amount);
		}
		if (Input.GetKeyUp(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], 0);
		}
	}

	private void CheckLaughterKey()
	{
		if (Input.GetKeyDown(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(100);
		}
		if (Input.GetKeyUp(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(0);
		}
	}
}
public class OVRLipSyncContextTextureFlip : MonoBehaviour
{
	public Material material;

	[Tooltip("The texture used for each viseme.")]
	[OVRNamedArray(new string[]
	{
		"sil", "PP", "FF", "TH", "DD", "kk", "CH", "SS", "nn", "RR",
		"aa", "E", "ih", "oh", "ou"
	})]
	public Texture[] Textures = new Texture[OVRLipSync.VisemeCount];

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme,100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private OVRLipSync.Frame oldFrame = new OVRLipSync.Frame();

	private void Start()
	{
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: No lip sync context component set to object");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
		if (material == null)
		{
			Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: Lip sync context texture flip has no material target to control!");
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && material != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				if (lipsyncContext.provider == OVRLipSync.ContextProviders.Original)
				{
					for (int i = 0; i < currentPhonemeFrame.Visemes.Length; i++)
					{
						float num = (float)(smoothAmount - 1) / 100f;
						oldFrame.Visemes[i] = oldFrame.Visemes[i] * num + currentPhonemeFrame.Visemes[i] * (1f - num);
					}
				}
				else
				{
					oldFrame.Visemes = currentPhonemeFrame.Visemes;
				}
				SetVisemeToTexture();
			}
		}
		if (smoothAmount != lipsyncContext.Smoothing)
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void SetVisemeToTexture()
	{
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < oldFrame.Visemes.Length; i++)
		{
			if (oldFrame.Visemes[i] > num2)
			{
				num = i;
				num2 = oldFrame.Visemes[i];
			}
		}
		if (num != -1 && num < Textures.Length)
		{
			Texture texture = Textures[num];
			if (texture != null)
			{
				material.SetTexture("_MainTex", texture);
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncMicInput : MonoBehaviour
{
	public enum micActivation
	{
		HoldToSpeak,
		PushToSpeak,
		ConstantSpeak
	}

	[Tooltip("Manual specification of Audio Source - by default will use any attached to the same object.")]
	public AudioSource audioSource;

	[Tooltip("Enable a keypress to toggle the microphone device selection GUI.")]
	public bool enableMicSelectionGUI;

	[Tooltip("Key to toggle the microphone selection GUI if enabled.")]
	public KeyCode micSelectionGUIKey = KeyCode.M;

	[SerializeField]
	[Range(0f, 100f)]
	[Tooltip("Microphone input volume control.")]
	private float micInputVolume = 100f;

	[SerializeField]
	[Tooltip("Requested microphone input frequency")]
	private int micFrequency = 48000;

	[Tooltip("Microphone input control method. Hold To Speak and Push To Speak are driven with the Mic Activation Key.")]
	public micActivation micControl = micActivation.ConstantSpeak;

	[Tooltip("Key used to drive Hold To Speak and Push To Speak methods of microphone input control.")]
	public KeyCode micActivationKey = KeyCode.Space;

	[Tooltip("Will contain the string name of the selected microphone device - read only.")]
	public string selectedDevice;

	private bool micSelected;

	private int minFreq;

	private int maxFreq;

	private bool focused = true;

	private bool initialized;

	public float MicFrequency
	{
		get
		{
			return micFrequency;
		}
		set
		{
			micFrequency = (int)Mathf.Clamp(value, 0f, 96000f);
		}
	}

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		_ = (bool)audioSource;
	}

	private void Start()
	{
		audioSource.loop = true;
		audioSource.mute = false;
		InitializeMicrophone();
	}

	private void InitializeMicrophone()
	{
		if (!initialized && Microphone.devices.Length != 0)
		{
			selectedDevice = Microphone.devices[0].ToString();
			micSelected = true;
			GetMicCaps();
			initialized = true;
		}
	}

	private void Update()
	{
		if (!focused)
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			return;
		}
		if (!UnityEngine.Application.isPlaying)
		{
			StopMicrophone();
			return;
		}
		if (!initialized)
		{
			InitializeMicrophone();
		}
		audioSource.volume = micInputVolume / 100f;
		if (micControl == micActivation.HoldToSpeak)
		{
			if (Input.GetKey(micActivationKey))
			{
				if (!Microphone.IsRecording(selectedDevice))
				{
					StartMicrophone();
				}
			}
			else if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
		}
		if (micControl == micActivation.PushToSpeak && Input.GetKeyDown(micActivationKey))
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			else if (!Microphone.IsRecording(selectedDevice))
			{
				StartMicrophone();
			}
		}
		if (micControl == micActivation.ConstantSpeak && !Microphone.IsRecording(selectedDevice))
		{
			StartMicrophone();
		}
		if (enableMicSelectionGUI && Input.GetKeyDown(micSelectionGUIKey))
		{
			micSelected = false;
		}
	}

	private void OnApplicationFocus(bool focus)
	{
		focused = focus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		focused = !pauseStatus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnDisable()
	{
		StopMicrophone();
	}

	private void OnGUI()
	{
		MicDeviceGUI(Screen.width / 2 - 150, Screen.height / 2 - 75, 300f, 50f, 10f, -300f);
	}

	public void MicDeviceGUI(float left, float top, float width, float height, float buttonSpaceTop, float buttonSpaceLeft)
	{
		if (Microphone.devices.Length < 1 || !enableMicSelectionGUI || micSelected)
		{
			return;
		}
		for (int i = 0; i < Microphone.devices.Length; i++)
		{
			if (GUI.Button(new Rect(left + (width + buttonSpaceLeft) * (float)i, top + (height + buttonSpaceTop) * (float)i, width, height), Microphone.devices[i].ToString()))
			{
				StopMicrophone();
				selectedDevice = Microphone.devices[i].ToString();
				micSelected = true;
				GetMicCaps();
				StartMicrophone();
			}
		}
	}

	public void GetMicCaps()
	{
		if (micSelected)
		{
			Microphone.GetDeviceCaps(selectedDevice, out minFreq, out maxFreq);
			if (minFreq == 0 && maxFreq == 0)
			{
				minFreq = 44100;
				maxFreq = 44100;
			}
			if (micFrequency > maxFreq)
			{
				micFrequency = maxFreq;
			}
		}
	}

	public void StartMicrophone()
	{
		if (micSelected)
		{
			audioSource.clip = Microphone.Start(selectedDevice, loop: true, 1, micFrequency);
			Stopwatch stopwatch = Stopwatch.StartNew();
			while (Microphone.GetPosition(selectedDevice) <= 0 && stopwatch.Elapsed.TotalMilliseconds < 1000.0)
			{
				Thread.Sleep(50);
			}
			if (Microphone.GetPosition(selectedDevice) <= 0)
			{
				throw new Exception("Timeout initializing microphone " + selectedDevice);
			}
			audioSource.Play();
		}
	}

	public void StopMicrophone()
	{
		if (micSelected)
		{
			if (audioSource != null && audioSource.clip != null && audioSource.clip.name == "Microphone")
			{
				audioSource.Stop();
			}
			GetComponent<OVRLipSyncContext>().ResetContext();
			Microphone.End(selectedDevice);
		}
	}

	private float GetAveragedVolume()
	{
		return 0f;
	}
}
[Serializable]
public class OVRLipSyncSequence : ScriptableObject
{
	public List<OVRLipSync.Frame> entries = new List<OVRLipSync.Frame>();

	public float length;

	public OVRLipSync.Frame GetFrameAtTime(float time)
	{
		OVRLipSync.Frame result = null;
		if (time < length && entries.Count > 0)
		{
			float num = time / length;
			result = entries[(int)((float)entries.Count * num)];
		}
		return result;
	}
}
public class MeshSimplify : MonoBehaviour
{
	[HideInInspector]
	public Mesh m_originalMesh;

	[HideInInspector]
	public Mesh m_simplifiedMesh;

	[HideInInspector]
	public bool m_bEnablePrefabUsage;

	[HideInInspector]
	public float m_fVertexAmount = 1f;

	[HideInInspector]
	public string m_strAssetPath;

	[HideInInspector]
	public MeshSimplify m_meshSimplifyRoot;

	[HideInInspector]
	public List<MeshSimplify> m_listDependentChildren = new List<MeshSimplify>();

	[HideInInspector]
	public bool m_bExpandRelevanceSpheres = true;

	public RelevanceSphere[] m_aRelevanceSpheres;

	[SerializeField]
	[HideInInspector]
	private Simplifier m_meshSimplifier;

	[SerializeField]
	[HideInInspector]
	private bool m_bGenerateIncludeChildren = true;

	[SerializeField]
	[HideInInspector]
	private bool m_bOverrideRootSettings;

	[SerializeField]
	[HideInInspector]
	private bool m_bUseEdgeLength = true;

	[SerializeField]
	[HideInInspector]
	private bool m_bUseCurvature = true;

	[SerializeField]
	[HideInInspector]
	private bool m_bProtectTexture = true;

	[SerializeField]
	[HideInInspector]
	private bool m_bLockBorder = true;

	[SerializeField]
	[HideInInspector]
	private bool m_bDataDirty = true;

	[SerializeField]
	[HideInInspector]
	private bool m_bExcludedFromTree;

	public bool RecurseIntoChildren => m_bGenerateIncludeChildren;

	public Simplifier MeshSimplifier
	{
		get
		{
			return m_meshSimplifier;
		}
		set
		{
			m_meshSimplifier = value;
		}
	}

	public static bool HasValidMeshData(GameObject go)
	{
		if (go.GetComponent<MeshFilter>() != null)
		{
			return true;
		}
		if (go.GetComponent<SkinnedMeshRenderer>() != null)
		{
			return true;
		}
		return false;
	}

	public static bool IsRootOrBelongsToTree(MeshSimplify meshSimplify, MeshSimplify root)
	{
		if (meshSimplify == null)
		{
			return false;
		}
		if (!meshSimplify.m_bExcludedFromTree)
		{
			if (!(meshSimplify.m_meshSimplifyRoot == null) && !(meshSimplify.m_meshSimplifyRoot == root) && !(meshSimplify == root))
			{
				return meshSimplify.m_meshSimplifyRoot == root.m_meshSimplifyRoot;
			}
			return true;
		}
		return false;
	}

	public bool IsGenerateIncludeChildrenActive()
	{
		return m_bGenerateIncludeChildren;
	}

	public bool HasDependentChildren()
	{
		if (m_listDependentChildren != null)
		{
			return m_listDependentChildren.Count > 0;
		}
		return false;
	}

	public bool HasDataDirty()
	{
		return m_bDataDirty;
	}

	public bool SetDataDirty(bool bDirty)
	{
		return m_bDataDirty = bDirty;
	}

	public bool HasNonMeshSimplifyGameObjectsInTree()
	{
		return HasNonMeshSimplifyGameObjectsInTreeRecursive(this, base.gameObject);
	}

	private bool HasNonMeshSimplifyGameObjectsInTreeRecursive(MeshSimplify root, GameObject gameObject)
	{
		if (gameObject.GetComponent<MeshSimplify>() == null && HasValidMeshData(gameObject))
		{
			return true;
		}
		for (int i = 0; i < gameObject.transform.childCount; i++)
		{
			if (HasNonMeshSimplifyGameObjectsInTreeRecursive(root, gameObject.transform.GetChild(i).gameObject))
			{
				return true;
			}
		}
		return false;
	}

	public void ConfigureSimplifier()
	{
		m_meshSimplifier.UseEdgeLength = ((m_meshSimplifyRoot != null && !m_bOverrideRootSettings) ? m_meshSimplifyRoot.m_bUseEdgeLength : m_bUseEdgeLength);
		m_meshSimplifier.UseCurvature = ((m_meshSimplifyRoot != null && !m_bOverrideRootSettings) ? m_meshSimplifyRoot.m_bUseCurvature : m_bUseCurvature);
		m_meshSimplifier.ProtectTexture = ((m_meshSimplifyRoot != null && !m_bOverrideRootSettings) ? m_meshSimplifyRoot.m_bProtectTexture : m_bProtectTexture);
		m_meshSimplifier.LockBorder = ((m_meshSimplifyRoot != null && !m_bOverrideRootSettings) ? m_meshSimplifyRoot.m_bLockBorder : m_bLockBorder);
	}

	public Simplifier GetMeshSimplifier()
	{
		return m_meshSimplifier;
	}

	public void ComputeData(bool bRecurseIntoChildren, Simplifier.ProgressDelegate progress = null)
	{
		ComputeDataRecursive(this, base.gameObject, bRecurseIntoChildren, progress);
	}

	private static void ComputeDataRecursive(MeshSimplify root, GameObject gameObject, bool bRecurseIntoChildren, Simplifier.ProgressDelegate progress = null)
	{
		MeshSimplify meshSimplify = gameObject.GetComponent<MeshSimplify>();
		if (meshSimplify == null && root.m_bGenerateIncludeChildren && HasValidMeshData(gameObject))
		{
			meshSimplify = gameObject.AddComponent<MeshSimplify>();
			meshSimplify.m_meshSimplifyRoot = root;
			root.m_listDependentChildren.Add(meshSimplify);
		}
		if (meshSimplify != null && IsRootOrBelongsToTree(meshSimplify, root))
		{
			meshSimplify.FreeData(bRecurseIntoChildren: false);
			MeshFilter component = meshSimplify.GetComponent<MeshFilter>();
			if (component != null && component.sharedMesh != null)
			{
				if (component.sharedMesh.vertexCount > 0)
				{
					if (meshSimplify.m_originalMesh == null)
					{
						meshSimplify.m_originalMesh = component.sharedMesh;
					}
					Simplifier[] components = meshSimplify.GetComponents<Simplifier>();
					for (int i = 0; i < components.Length; i++)
					{
						if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying)
						{
							UnityEngine.Object.DestroyImmediate(components[i]);
						}
						else
						{
							UnityEngine.Object.Destroy(components[i]);
						}
					}
					meshSimplify.m_meshSimplifier = meshSimplify.gameObject.AddComponent<Simplifier>();
					meshSimplify.m_meshSimplifier.hideFlags = HideFlags.HideInInspector;
					meshSimplify.ConfigureSimplifier();
					IEnumerator enumerator = meshSimplify.m_meshSimplifier.ProgressiveMesh(gameObject, meshSimplify.m_originalMesh, root.m_aRelevanceSpheres, meshSimplify.name, progress);
					while (enumerator.MoveNext())
					{
						if (Simplifier.Cancelled)
						{
							return;
						}
					}
					if (Simplifier.Cancelled)
					{
						return;
					}
				}
			}
			else
			{
				SkinnedMeshRenderer component2 = meshSimplify.GetComponent<SkinnedMeshRenderer>();
				if (component2 != null && component2.sharedMesh.vertexCount > 0)
				{
					if (meshSimplify.m_originalMesh == null)
					{
						meshSimplify.m_originalMesh = component2.sharedMesh;
					}
					Simplifier[] components2 = meshSimplify.GetComponents<Simplifier>();
					for (int j = 0; j < components2.Length; j++)
					{
						if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying)
						{
							UnityEngine.Object.DestroyImmediate(components2[j]);
						}
						else
						{
							UnityEngine.Object.Destroy(components2[j]);
						}
					}
					meshSimplify.m_meshSimplifier = meshSimplify.gameObject.AddComponent<Simplifier>();
					meshSimplify.m_meshSimplifier.hideFlags = HideFlags.HideInInspector;
					meshSimplify.ConfigureSimplifier();
					IEnumerator enumerator2 = meshSimplify.m_meshSimplifier.ProgressiveMesh(gameObject, meshSimplify.m_originalMesh, root.m_aRelevanceSpheres, meshSimplify.name, progress);
					while (enumerator2.MoveNext())
					{
						if (Simplifier.Cancelled)
						{
							return;
						}
					}
					if (Simplifier.Cancelled)
					{
						return;
					}
				}
			}
			meshSimplify.m_bDataDirty = false;
		}
		if (!bRecurseIntoChildren)
		{
			return;
		}
		for (int k = 0; k < gameObject.transform.childCount; k++)
		{
			ComputeDataRecursive(root, gameObject.transform.GetChild(k).gameObject, bRecurseIntoChildren, progress);
			if (Simplifier.Cancelled)
			{
				break;
			}
		}
	}

	public bool HasData()
	{
		if (!(m_meshSimplifier != null) || !(m_simplifiedMesh != null))
		{
			if (m_listDependentChildren != null)
			{
				return m_listDependentChildren.Count != 0;
			}
			return false;
		}
		return true;
	}

	public bool HasSimplifiedMesh()
	{
		if (m_simplifiedMesh != null)
		{
			return m_simplifiedMesh.vertexCount > 0;
		}
		return false;
	}

	public void ComputeMesh(bool bRecurseIntoChildren, Simplifier.ProgressDelegate progress = null)
	{
		ComputeMeshRecursive(this, base.gameObject, bRecurseIntoChildren, progress);
	}

	private static void ComputeMeshRecursive(MeshSimplify root, GameObject gameObject, bool bRecurseIntoChildren, Simplifier.ProgressDelegate progress = null)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root) && component.m_meshSimplifier != null)
		{
			if ((bool)component.m_simplifiedMesh)
			{
				component.m_simplifiedMesh.Clear();
			}
			float fVertexAmount = component.m_fVertexAmount;
			if (!component.m_bOverrideRootSettings && component.m_meshSimplifyRoot != null)
			{
				fVertexAmount = component.m_meshSimplifyRoot.m_fVertexAmount;
			}
			if (component.m_simplifiedMesh == null)
			{
				component.m_simplifiedMesh = CreateNewEmptyMesh(component);
			}
			component.ConfigureSimplifier();
			IEnumerator enumerator = component.m_meshSimplifier.ComputeMeshWithVertexCount(gameObject, component.m_simplifiedMesh, Mathf.RoundToInt(fVertexAmount * (float)component.m_meshSimplifier.GetOriginalMeshUniqueVertexCount()), component.name + " Simplified", progress);
			while (enumerator.MoveNext())
			{
				if (Simplifier.Cancelled)
				{
					return;
				}
			}
			if (Simplifier.Cancelled)
			{
				return;
			}
		}
		if (!bRecurseIntoChildren)
		{
			return;
		}
		for (int i = 0; i < gameObject.transform.childCount; i++)
		{
			ComputeMeshRecursive(root, gameObject.transform.GetChild(i).gameObject, bRecurseIntoChildren, progress);
			if (Simplifier.Cancelled)
			{
				break;
			}
		}
	}

	public void AssignSimplifiedMesh(bool bRecurseIntoChildren)
	{
		AssignSimplifiedMeshRecursive(this, base.gameObject, bRecurseIntoChildren);
	}

	private static void AssignSimplifiedMeshRecursive(MeshSimplify root, GameObject gameObject, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root) && component.m_simplifiedMesh != null)
		{
			MeshFilter component2 = component.GetComponent<MeshFilter>();
			if (component2 != null)
			{
				component2.sharedMesh = component.m_simplifiedMesh;
			}
			else
			{
				SkinnedMeshRenderer component3 = component.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					component3.sharedMesh = component.m_simplifiedMesh;
				}
			}
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				AssignSimplifiedMeshRecursive(root, gameObject.transform.GetChild(i).gameObject, bRecurseIntoChildren);
			}
		}
	}

	public void RestoreOriginalMesh(bool bDeleteData, bool bRecurseIntoChildren)
	{
		RestoreOriginalMeshRecursive(this, base.gameObject, bDeleteData, bRecurseIntoChildren);
	}

	private static void RestoreOriginalMeshRecursive(MeshSimplify root, GameObject gameObject, bool bDeleteData, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root))
		{
			if (component.m_originalMesh != null)
			{
				MeshFilter component2 = component.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					component2.sharedMesh = component.m_originalMesh;
				}
				else
				{
					SkinnedMeshRenderer component3 = component.GetComponent<SkinnedMeshRenderer>();
					if (component3 != null)
					{
						component3.sharedMesh = component.m_originalMesh;
					}
				}
			}
			if (bDeleteData)
			{
				component.FreeData(bRecurseIntoChildren: false);
				component.m_listDependentChildren.Clear();
			}
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				RestoreOriginalMeshRecursive(root, gameObject.transform.GetChild(i).gameObject, bDeleteData, bRecurseIntoChildren);
			}
		}
	}

	public bool HasOriginalMeshActive(bool bRecurseIntoChildren)
	{
		return HasOriginalMeshActiveRecursive(this, base.gameObject, bRecurseIntoChildren);
	}

	private static bool HasOriginalMeshActiveRecursive(MeshSimplify root, GameObject gameObject, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		bool flag = false;
		if (component != null && IsRootOrBelongsToTree(component, root) && component.m_originalMesh != null)
		{
			MeshFilter component2 = component.GetComponent<MeshFilter>();
			if (component2 != null)
			{
				if (component2.sharedMesh == component.m_originalMesh)
				{
					flag = true;
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = component.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null && component3.sharedMesh == component.m_originalMesh)
				{
					flag = true;
				}
			}
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				flag = flag || HasOriginalMeshActiveRecursive(root, gameObject.transform.GetChild(i).gameObject, bRecurseIntoChildren);
			}
		}
		return flag;
	}

	public bool HasVertexData(bool bRecurseIntoChildren)
	{
		return HasVertexDataRecursive(this, base.gameObject, bRecurseIntoChildren);
	}

	private static bool HasVertexDataRecursive(MeshSimplify root, GameObject gameObject, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root) && (bool)component.m_simplifiedMesh && component.m_simplifiedMesh.vertexCount > 0)
		{
			return true;
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				if (HasVertexDataRecursive(root, gameObject.transform.GetChild(i).gameObject, bRecurseIntoChildren))
				{
					return true;
				}
			}
		}
		return false;
	}

	public int GetOriginalVertexCount(bool bRecurseIntoChildren)
	{
		int nVertexCount = 0;
		GetOriginalVertexCountRecursive(this, base.gameObject, ref nVertexCount, bRecurseIntoChildren);
		return nVertexCount;
	}

	private static void GetOriginalVertexCountRecursive(MeshSimplify root, GameObject gameObject, ref int nVertexCount, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root) && component.m_originalMesh != null)
		{
			nVertexCount += component.m_originalMesh.vertexCount;
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				GetOriginalVertexCountRecursive(root, gameObject.transform.GetChild(i).gameObject, ref nVertexCount, bRecurseIntoChildren);
			}
		}
	}

	public int GetOriginalTriangleCount(bool bRecurseIntoChildren)
	{
		int nTriangleCount = 0;
		GetOriginalTriangleCountRecursive(this, base.gameObject, ref nTriangleCount, bRecurseIntoChildren);
		return nTriangleCount;
	}

	private static void GetOriginalTriangleCountRecursive(MeshSimplify root, GameObject gameObject, ref int nTriangleCount, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root) && component.m_originalMesh != null)
		{
			nTriangleCount += component.m_originalMesh.triangles.Length / 3;
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				GetOriginalTriangleCountRecursive(root, gameObject.transform.GetChild(i).gameObject, ref nTriangleCount, bRecurseIntoChildren);
			}
		}
	}

	public int GetSimplifiedVertexCount(bool bRecurseIntoChildren)
	{
		int nVertexCount = 0;
		GetSimplifiedVertexCountRecursive(this, base.gameObject, ref nVertexCount, bRecurseIntoChildren);
		return nVertexCount;
	}

	private static void GetSimplifiedVertexCountRecursive(MeshSimplify root, GameObject gameObject, ref int nVertexCount, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root) && component.m_simplifiedMesh != null)
		{
			nVertexCount += component.m_simplifiedMesh.vertexCount;
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				GetSimplifiedVertexCountRecursive(root, gameObject.transform.GetChild(i).gameObject, ref nVertexCount, bRecurseIntoChildren);
			}
		}
	}

	public int GetSimplifiedTriangleCount(bool bRecurseIntoChildren)
	{
		int nTriangleCount = 0;
		GetSimplifiedTriangleCountRecursive(this, base.gameObject, ref nTriangleCount, bRecurseIntoChildren);
		return nTriangleCount;
	}

	private static void GetSimplifiedTriangleCountRecursive(MeshSimplify root, GameObject gameObject, ref int nTriangleCount, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root) && component.m_simplifiedMesh != null)
		{
			nTriangleCount += component.m_simplifiedMesh.triangles.Length / 3;
		}
		if (bRecurseIntoChildren)
		{
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				GetSimplifiedTriangleCountRecursive(root, gameObject.transform.GetChild(i).gameObject, ref nTriangleCount, bRecurseIntoChildren);
			}
		}
	}

	public void RemoveFromTree()
	{
		if (m_meshSimplifyRoot != null)
		{
			m_meshSimplifyRoot.m_listDependentChildren.Remove(this);
		}
		RestoreOriginalMesh(bDeleteData: true, bRecurseIntoChildren: false);
		m_bExcludedFromTree = true;
	}

	public void FreeData(bool bRecurseIntoChildren)
	{
		FreeDataRecursive(this, base.gameObject, bRecurseIntoChildren);
	}

	private static void FreeDataRecursive(MeshSimplify root, GameObject gameObject, bool bRecurseIntoChildren)
	{
		MeshSimplify component = gameObject.GetComponent<MeshSimplify>();
		if (component != null && IsRootOrBelongsToTree(component, root))
		{
			if ((bool)component.m_simplifiedMesh)
			{
				component.m_simplifiedMesh.Clear();
			}
			Simplifier[] components = gameObject.GetComponents<Simplifier>();
			for (int i = 0; i < components.Length; i++)
			{
				if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying)
				{
					UnityEngine.Object.DestroyImmediate(components[i]);
				}
				else
				{
					UnityEngine.Object.Destroy(components[i]);
				}
			}
			component.m_bDataDirty = true;
		}
		if (bRecurseIntoChildren)
		{
			for (int j = 0; j < gameObject.transform.childCount; j++)
			{
				FreeDataRecursive(root, gameObject.transform.GetChild(j).gameObject, bRecurseIntoChildren);
			}
		}
	}

	private static Mesh CreateNewEmptyMesh(MeshSimplify meshSimplify)
	{
		if (meshSimplify.m_originalMesh == null)
		{
			return new Mesh();
		}
		Mesh mesh = UnityEngine.Object.Instantiate(meshSimplify.m_originalMesh);
		mesh.Clear();
		return mesh;
	}
}
[RequireComponent(typeof(MeshSimplify))]
public class RuntimeMeshSimplifier : MonoBehaviour
{
	private Dictionary<GameObject, Material[]> m_objectMaterials;

	private MeshSimplify m_selectedMeshSimplify;

	private bool m_bFinished;

	private Mesh m_newMesh;

	private int m_nLastProgress = -1;

	private string m_strLastTitle = "";

	private string m_strLastMessage = "";

	public string ProgressTitle => m_strLastTitle;

	public string ProgressMessage => m_strLastMessage;

	public int ProgressPercent => m_nLastProgress;

	public bool Finished => m_bFinished;

	public void Simplify(float percent)
	{
		if (!m_bFinished)
		{
			StartCoroutine(ComputeMeshWithVertices(Mathf.Clamp01(percent / 100f)));
		}
	}

	private void Awake()
	{
		m_selectedMeshSimplify = GetComponent<MeshSimplify>();
		m_objectMaterials = new Dictionary<GameObject, Material[]>();
		AddMaterials(m_selectedMeshSimplify.gameObject, m_objectMaterials);
		m_bFinished = false;
	}

	private void AddMaterials(GameObject theGameObject, Dictionary<GameObject, Material[]> dicMaterials)
	{
		Renderer component = theGameObject.GetComponent<Renderer>();
		if (component != null && component.sharedMaterials != null && (MeshSimplify.HasValidMeshData(theGameObject) || theGameObject.GetComponent<MeshSimplify>() != null))
		{
			dicMaterials.Add(theGameObject, component.sharedMaterials);
		}
		if (m_selectedMeshSimplify.RecurseIntoChildren)
		{
			for (int i = 0; i < theGameObject.transform.childCount; i++)
			{
				AddMaterials(theGameObject.transform.GetChild(i).gameObject, dicMaterials);
			}
		}
	}

	private void Progress(string strTitle, string strMessage, float fT)
	{
		int num = Mathf.RoundToInt(fT * 100f);
		if (num != m_nLastProgress || m_strLastTitle != strTitle || m_strLastMessage != strMessage)
		{
			m_strLastTitle = strTitle;
			m_strLastMessage = strMessage;
			m_nLastProgress = num;
		}
	}

	private IEnumerator ComputeMeshWithVertices(float fAmount)
	{
		Simplifier.CoroutineFrameMiliseconds = 20;
		foreach (KeyValuePair<GameObject, Material[]> pair in m_objectMaterials)
		{
			MeshSimplify meshSimplify = pair.Key.GetComponent<MeshSimplify>();
			MeshFilter meshFilter = pair.Key.GetComponent<MeshFilter>();
			SkinnedMeshRenderer skin = pair.Key.GetComponent<SkinnedMeshRenderer>();
			if (meshSimplify == null)
			{
				meshSimplify = pair.Key.AddComponent<MeshSimplify>();
				meshSimplify.m_meshSimplifyRoot = m_selectedMeshSimplify;
				m_selectedMeshSimplify.m_listDependentChildren.Add(meshSimplify);
			}
			if (meshSimplify.MeshSimplifier == null)
			{
				meshSimplify.MeshSimplifier = meshSimplify.gameObject.AddComponent<Simplifier>();
				meshSimplify.MeshSimplifier.hideFlags = HideFlags.HideInInspector;
				meshSimplify.ConfigureSimplifier();
			}
			if (!meshSimplify || !MeshSimplify.HasValidMeshData(pair.Key))
			{
				continue;
			}
			Mesh newMesh = null;
			if (meshFilter != null)
			{
				newMesh = UnityEngine.Object.Instantiate(meshFilter.sharedMesh);
			}
			else if (skin != null)
			{
				newMesh = UnityEngine.Object.Instantiate(skin.sharedMesh);
			}
			if (!meshSimplify.HasData())
			{
				meshSimplify.GetMeshSimplifier().CoroutineEnded = false;
				StartCoroutine(meshSimplify.GetMeshSimplifier().ProgressiveMesh(pair.Key, (meshFilter != null) ? meshFilter.sharedMesh : skin.sharedMesh, null, meshSimplify.name, Progress));
				while (!meshSimplify.GetMeshSimplifier().CoroutineEnded)
				{
					yield return null;
				}
			}
			if (meshSimplify.GetMeshSimplifier() != null)
			{
				meshSimplify.GetMeshSimplifier().CoroutineEnded = false;
				StartCoroutine(meshSimplify.GetMeshSimplifier().ComputeMeshWithVertexCount(pair.Key, newMesh, Mathf.RoundToInt(fAmount * (float)meshSimplify.GetMeshSimplifier().GetOriginalMeshUniqueVertexCount()), meshSimplify.name, Progress));
				while (!meshSimplify.GetMeshSimplifier().CoroutineEnded)
				{
					yield return null;
				}
				if (meshFilter != null)
				{
					meshFilter.mesh = newMesh;
				}
				else if (skin != null)
				{
					skin.sharedMesh = newMesh;
				}
				meshSimplify.m_simplifiedMesh = newMesh;
			}
		}
		m_bFinished = true;
	}
}
public class SimplifyMeshPreview : MonoBehaviour
{
	[Serializable]
	public class ShowcaseObject
	{
		public MeshSimplify m_meshSimplify;

		public Vector3 m_position;

		public Vector3 m_angles;

		public Vector3 m_rotationAxis = Vector3.up;

		public string m_description;
	}

	public ShowcaseObject[] ShowcaseObjects;

	public Material WireframeMaterial;

	public float MouseSensitvity = 0.3f;

	public float MouseReleaseSpeed = 3f;

	private Dictionary<GameObject, Material[]> m_objectMaterials;

	private MeshSimplify m_selectedMeshSimplify;

	private int m_nSelectedIndex = -1;

	private bool m_bWireframe;

	private float m_fRotationSpeed = 10f;

	private float m_fLastMouseX;

	private Mesh m_newMesh;

	private int m_nLastProgress = -1;

	private string m_strLastTitle = "";

	private string m_strLastMessage = "";

	private float m_fVertexAmount = 1f;

	private bool m_bGUIEnabled = true;

	private void Start()
	{
		if (ShowcaseObjects != null && ShowcaseObjects.Length != 0)
		{
			for (int i = 0; i < ShowcaseObjects.Length; i++)
			{
				ShowcaseObjects[i].m_description = ShowcaseObjects[i].m_description.Replace("\\n", Environment.NewLine);
			}
			SetActiveObject(0);
		}
		Simplifier.CoroutineFrameMiliseconds = 20;
	}

	private void Progress(string strTitle, string strMessage, float fT)
	{
		int num = Mathf.RoundToInt(fT * 100f);
		if (num != m_nLastProgress || m_strLastTitle != strTitle || m_strLastMessage != strMessage)
		{
			m_strLastTitle = strTitle;
			m_strLastMessage = strMessage;
			m_nLastProgress = num;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.F1))
		{
			m_bGUIEnabled = !m_bGUIEnabled;
		}
		if (Input.GetKeyDown(KeyCode.W))
		{
			m_bWireframe = !m_bWireframe;
			SetWireframe(m_bWireframe);
		}
		if (m_selectedMeshSimplify != null)
		{
			if (Input.GetMouseButton(0) && Input.mousePosition.y > 100f)
			{
				Vector3 eulers = ShowcaseObjects[m_nSelectedIndex].m_rotationAxis * (0f - (Input.mousePosition.x - m_fLastMouseX) * MouseSensitvity);
				m_selectedMeshSimplify.transform.Rotate(eulers, Space.Self);
			}
			else if (Input.GetMouseButtonUp(0) && Input.mousePosition.y > 100f)
			{
				m_fRotationSpeed = (0f - (Input.mousePosition.x - m_fLastMouseX)) * MouseReleaseSpeed;
			}
			else
			{
				Vector3 eulers2 = ShowcaseObjects[m_nSelectedIndex].m_rotationAxis * (m_fRotationSpeed * Time.deltaTime);
				m_selectedMeshSimplify.transform.Rotate(eulers2, Space.Self);
			}
		}
		m_fLastMouseX = Input.mousePosition.x;
	}

	private void OnGUI()
	{
		int num = 150;
		int num2 = 50;
		int num3 = 20;
		int num4 = 10;
		Rect rect = new Rect(Screen.width / 2 - num / 2, 0f, num, num2);
		GUILayout.BeginArea(new Rect(rect.x + (float)num3, rect.y + (float)num4, num - num3 * 2, num2 - num4 * 2));
		if (GUILayout.Button("Exit"))
		{
			UnityEngine.Application.Quit();
		}
		GUILayout.EndArea();
		if (!m_bGUIEnabled)
		{
			return;
		}
		int num5 = 400;
		if (ShowcaseObjects == null)
		{
			return;
		}
		bool flag = true;
		if (!string.IsNullOrEmpty(m_strLastTitle) && !string.IsNullOrEmpty(m_strLastMessage))
		{
			flag = false;
		}
		GUI.Box(new Rect(0f, 0f, num5 + 10, 400f), "");
		GUILayout.Label("Select model:", GUILayout.Width(num5));
		GUILayout.BeginHorizontal();
		for (int i = 0; i < ShowcaseObjects.Length; i++)
		{
			if (GUILayout.Button(ShowcaseObjects[i].m_meshSimplify.name) && flag)
			{
				if (m_selectedMeshSimplify != null)
				{
					UnityEngine.Object.DestroyImmediate(m_selectedMeshSimplify.gameObject);
				}
				SetActiveObject(i);
			}
		}
		GUILayout.EndHorizontal();
		if (!(m_selectedMeshSimplify != null))
		{
			return;
		}
		GUILayout.Space(20f);
		GUILayout.Label(ShowcaseObjects[m_nSelectedIndex].m_description);
		GUILayout.Space(20f);
		GUI.changed = false;
		m_bWireframe = GUILayout.Toggle(m_bWireframe, "Show wireframe");
		if (GUI.changed && m_selectedMeshSimplify != null)
		{
			SetWireframe(m_bWireframe);
		}
		GUILayout.Space(20f);
		int simplifiedVertexCount = m_selectedMeshSimplify.GetSimplifiedVertexCount(bRecurseIntoChildren: true);
		int originalVertexCount = m_selectedMeshSimplify.GetOriginalVertexCount(bRecurseIntoChildren: true);
		GUILayout.Label("Vertex count: " + simplifiedVertexCount + "/" + originalVertexCount + " " + Mathf.RoundToInt((float)simplifiedVertexCount / (float)originalVertexCount * 100f).ToString() + "% from original");
		GUILayout.Space(20f);
		if (!string.IsNullOrEmpty(m_strLastTitle) && !string.IsNullOrEmpty(m_strLastMessage))
		{
			GUILayout.Label(m_strLastTitle + ": " + m_strLastMessage, GUILayout.MaxWidth(num5));
			GUI.color = Color.blue;
			Rect lastRect = GUILayoutUtility.GetLastRect();
			GUI.Box(new Rect(10f, lastRect.yMax + 5f, 204f, 24f), "");
			GUI.Box(new Rect(12f, lastRect.yMax + 7f, m_nLastProgress * 2, 20f), "");
			return;
		}
		GUILayout.Label("Vertices: " + (m_fVertexAmount * 100f).ToString("0.00") + "%");
		m_fVertexAmount = GUILayout.HorizontalSlider(m_fVertexAmount, 0f, 1f, GUILayout.Width(200f));
		GUILayout.BeginHorizontal();
		GUILayout.Space(3f);
		if (GUILayout.Button("Compute simplified mesh", GUILayout.Width(200f)))
		{
			StartCoroutine(ComputeMeshWithVertices(m_fVertexAmount));
		}
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
	}

	private void SetActiveObject(int index)
	{
		m_nSelectedIndex = index;
		MeshSimplify meshSimplify = UnityEngine.Object.Instantiate(ShowcaseObjects[index].m_meshSimplify);
		meshSimplify.transform.position = ShowcaseObjects[index].m_position;
		meshSimplify.transform.rotation = Quaternion.Euler(ShowcaseObjects[index].m_angles);
		m_selectedMeshSimplify = meshSimplify;
		m_objectMaterials = new Dictionary<GameObject, Material[]>();
		AddMaterials(meshSimplify.gameObject, m_objectMaterials);
		m_bWireframe = false;
	}

	private void AddMaterials(GameObject theGameObject, Dictionary<GameObject, Material[]> dicMaterials)
	{
		Renderer component = theGameObject.GetComponent<Renderer>();
		MeshSimplify component2 = theGameObject.GetComponent<MeshSimplify>();
		if (component != null && component.sharedMaterials != null && component2 != null)
		{
			dicMaterials.Add(theGameObject, component.sharedMaterials);
		}
		for (int i = 0; i < theGameObject.transform.childCount; i++)
		{
			AddMaterials(theGameObject.transform.GetChild(i).gameObject, dicMaterials);
		}
	}

	private void SetWireframe(bool bEnabled)
	{
		m_bWireframe = bEnabled;
		foreach (KeyValuePair<GameObject, Material[]> objectMaterial in m_objectMaterials)
		{
			Renderer component = objectMaterial.Key.GetComponent<Renderer>();
			if (bEnabled)
			{
				Material[] array = new Material[objectMaterial.Value.Length];
				for (int i = 0; i < objectMaterial.Value.Length; i++)
				{
					array[i] = WireframeMaterial;
				}
				component.sharedMaterials = array;
			}
			else
			{
				component.sharedMaterials = objectMaterial.Value;
			}
		}
	}

	private IEnumerator ComputeMeshWithVertices(float fAmount)
	{
		foreach (KeyValuePair<GameObject, Material[]> objectMaterial in m_objectMaterials)
		{
			MeshSimplify meshSimplify = objectMaterial.Key.GetComponent<MeshSimplify>();
			MeshFilter meshFilter = objectMaterial.Key.GetComponent<MeshFilter>();
			SkinnedMeshRenderer skin = objectMaterial.Key.GetComponent<SkinnedMeshRenderer>();
			if (!meshSimplify || (!(meshFilter != null) && !(skin != null)))
			{
				continue;
			}
			Mesh newMesh = null;
			if (meshFilter != null)
			{
				newMesh = UnityEngine.Object.Instantiate(meshFilter.sharedMesh);
			}
			else if (skin != null)
			{
				newMesh = UnityEngine.Object.Instantiate(skin.sharedMesh);
			}
			if (meshSimplify.GetMeshSimplifier() != null)
			{
				meshSimplify.GetMeshSimplifier().CoroutineEnded = false;
				StartCoroutine(meshSimplify.GetMeshSimplifier().ComputeMeshWithVertexCount(objectMaterial.Key, newMesh, Mathf.RoundToInt(fAmount * (float)meshSimplify.GetMeshSimplifier().GetOriginalMeshUniqueVertexCount()), meshSimplify.name, Progress));
				while (!meshSimplify.GetMeshSimplifier().CoroutineEnded)
				{
					yield return null;
				}
				if (meshFilter != null)
				{
					meshFilter.mesh = newMesh;
				}
				else if (skin != null)
				{
					skin.sharedMesh = newMesh;
				}
				meshSimplify.m_simplifiedMesh = newMesh;
			}
		}
		m_strLastTitle = "";
		m_strLastMessage = "";
		m_nLastProgress = 0;
	}
}
public class SABoneColliderCommon
{
	public enum BoneWeightType
	{
		Bone2,
		Bone4
	}

	public enum BoneTriangleExtent
	{
		Disable,
		Vertex2,
		Vertex1
	}

	[Serializable]
	public class BoneProperty
	{
		public bool recursivery;

		public BoneProperty ShallowCopy()
		{
			return (BoneProperty)MemberwiseClone();
		}
	}

	[Serializable]
	public class SplitProperty
	{
		public BoneWeightType boneWeightType;

		public int boneWeight2 = 50;

		public int boneWeight3 = 33;

		public int boneWeight4 = 25;

		public bool greaterBoneWeight = true;

		public BoneTriangleExtent boneTriangleExtent = BoneTriangleExtent.Vertex2;

		public SplitProperty ShallowCopy()
		{
			return (SplitProperty)MemberwiseClone();
		}
	}

	[Serializable]
	public class SABoneColliderProperty
	{
		public BoneProperty boneProperty = new BoneProperty();

		public SplitProperty splitProperty = new SplitProperty();

		public SAColliderBuilderCommon.ReducerProperty reducerProperty = new SAColliderBuilderCommon.ReducerProperty();

		public SAColliderBuilderCommon.ColliderProperty colliderProperty = new SAColliderBuilderCommon.ColliderProperty();

		public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty = new SAColliderBuilderCommon.RigidbodyProperty();

		public bool modifyNameEnabled;

		public SABoneColliderProperty Copy()
		{
			SABoneColliderProperty sABoneColliderProperty = new SABoneColliderProperty();
			if (boneProperty != null)
			{
				sABoneColliderProperty.boneProperty = boneProperty.ShallowCopy();
			}
			if (splitProperty != null)
			{
				sABoneColliderProperty.splitProperty = splitProperty.ShallowCopy();
			}
			if (reducerProperty != null)
			{
				sABoneColliderProperty.reducerProperty = reducerProperty.ShallowCopy();
			}
			if (colliderProperty != null)
			{
				sABoneColliderProperty.colliderProperty = colliderProperty.ShallowCopy();
			}
			if (rigidbodyProperty != null)
			{
				sABoneColliderProperty.rigidbodyProperty = rigidbodyProperty.ShallowCopy();
			}
			sABoneColliderProperty.modifyNameEnabled = modifyNameEnabled;
			return sABoneColliderProperty;
		}
	}

	[Serializable]
	public class SABoneColliderBuilderProperty
	{
		public SplitProperty splitProperty = new SplitProperty();

		public SAColliderBuilderCommon.ReducerProperty reducerProperty = new SAColliderBuilderCommon.ReducerProperty();

		public SAColliderBuilderCommon.ColliderProperty colliderProperty = new SAColliderBuilderCommon.ColliderProperty();

		public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty = new SAColliderBuilderCommon.RigidbodyProperty();

		public bool modifyNameEnabled;

		public SABoneColliderBuilderProperty Copy()
		{
			SABoneColliderBuilderProperty sABoneColliderBuilderProperty = new SABoneColliderBuilderProperty();
			if (splitProperty != null)
			{
				sABoneColliderBuilderProperty.splitProperty = splitProperty.ShallowCopy();
			}
			if (reducerProperty != null)
			{
				sABoneColliderBuilderProperty.reducerProperty = reducerProperty.ShallowCopy();
			}
			if (colliderProperty != null)
			{
				sABoneColliderBuilderProperty.colliderProperty = colliderProperty.ShallowCopy();
			}
			if (rigidbodyProperty != null)
			{
				sABoneColliderBuilderProperty.rigidbodyProperty = rigidbodyProperty.ShallowCopy();
			}
			sABoneColliderBuilderProperty.modifyNameEnabled = modifyNameEnabled;
			return sABoneColliderBuilderProperty;
		}

		public SABoneColliderProperty ToSABoneColliderProperty()
		{
			SABoneColliderProperty sABoneColliderProperty = new SABoneColliderProperty();
			if (splitProperty != null)
			{
				sABoneColliderProperty.splitProperty = splitProperty.ShallowCopy();
			}
			if (reducerProperty != null)
			{
				sABoneColliderProperty.reducerProperty = reducerProperty.ShallowCopy();
			}
			if (colliderProperty != null)
			{
				sABoneColliderProperty.colliderProperty = colliderProperty.ShallowCopy();
			}
			if (rigidbodyProperty != null)
			{
				sABoneColliderProperty.rigidbodyProperty = rigidbodyProperty.ShallowCopy();
			}
			sABoneColliderProperty.modifyNameEnabled = modifyNameEnabled;
			return sABoneColliderProperty;
		}
	}
}
public class SAColliderBuilderCommon
{
	public enum ShapeType
	{
		None,
		Mesh,
		Box,
		Capsule,
		Sphere
	}

	public enum FitType
	{
		Outer,
		Inner
	}

	public enum MeshType
	{
		Raw,
		ConvexBoxes,
		ConvexHull,
		Box
	}

	public enum SliceMode
	{
		Auto,
		X,
		Y,
		Z
	}

	public enum ElementType
	{
		X,
		XYZ
	}

	[Serializable]
	public struct Bool3
	{
		public bool x;

		public bool y;

		public bool z;

		public Bool3(bool x, bool y, bool z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public void SetValue(bool x, bool y, bool z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	public enum ColliderToChild
	{
		Auto,
		On,
		Off
	}

	[Serializable]
	public class ReducerProperty
	{
		public ShapeType shapeType = ShapeType.Box;

		public FitType fitType;

		public MeshType meshType = MeshType.Box;

		public int maxTriangles = 255;

		public SliceMode sliceMode;

		public Vector3 scale = Vector3.one;

		public ElementType scaleElementType;

		public Vector3 minThickness = new Vector3(0.01f, 0.01f, 0.01f);

		public ElementType minThicknessElementType;

		public Bool3 optimizeRotation = new Bool3(x: true, y: true, z: true);

		public ElementType optimizeRotationElementType;

		public ColliderToChild colliderToChild;

		public Vector3 offset = Vector3.zero;

		public Vector3 thicknessA = Vector3.zero;

		public Vector3 thicknessB = Vector3.zero;

		public bool viewAdvanced;

		public ReducerProperty ShallowCopy()
		{
			return (ReducerProperty)MemberwiseClone();
		}
	}

	[Serializable]
	public class ColliderProperty
	{
		public bool convex = true;

		public bool isTrigger;

		public PhysicMaterial material;

		public bool isCreateAsset;

		public ColliderProperty ShallowCopy()
		{
			return (ColliderProperty)MemberwiseClone();
		}
	}

	[Serializable]
	public class RigidbodyProperty
	{
		public float mass = 1f;

		public float drag;

		public float angularDrag = 0.05f;

		public bool isKinematic = true;

		public bool useGravity;

		public RigidbodyInterpolation interpolation;

		public CollisionDetectionMode collisionDetectionMode;

		public bool isCreate = true;

		public bool viewAdvanced;

		public RigidbodyProperty ShallowCopy()
		{
			return (RigidbodyProperty)MemberwiseClone();
		}
	}
}
public class SAMeshColliderCommon
{
	public enum SplitMode
	{
		None,
		Material,
		Primitive,
		Polygon
	}

	[Serializable]
	public class SplitMesh
	{
		public int subMeshCount;

		public int subMesh = -1;

		public int triangle = -1;

		public Vector3 triangleVertex;

		public int[] polygonTriangles;

		public Vector3[] polygonVertices;

		[NonSerialized]
		public int[] triangles;

		[NonSerialized]
		public Vector3[] vertices;

		[NonSerialized]
		public Vector3[] triangleNormals;

		public void PurgeTemporary()
		{
			triangles = null;
			vertices = null;
			triangleNormals = null;
		}
	}

	[Serializable]
	public class SplitProperty
	{
		public bool splitMaterialEnabled = true;

		public bool splitPrimitiveEnabled = true;

		public bool splitPolygonNormalEnabled;

		public float splitPolygonNormalAngle = 45f;

		public SplitProperty ShallowCopy()
		{
			return (SplitProperty)MemberwiseClone();
		}
	}

	[Serializable]
	public class SAMeshColliderProperty
	{
		public SplitProperty splitProperty = new SplitProperty();

		public SAColliderBuilderCommon.ReducerProperty reducerProperty = new SAColliderBuilderCommon.ReducerProperty();

		public SAColliderBuilderCommon.ColliderProperty colliderProperty = new SAColliderBuilderCommon.ColliderProperty();

		public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty = new SAColliderBuilderCommon.RigidbodyProperty();

		public bool modifyNameEnabled = true;

		public SAMeshColliderProperty Copy()
		{
			SAMeshColliderProperty sAMeshColliderProperty = new SAMeshColliderProperty();
			if (splitProperty != null)
			{
				sAMeshColliderProperty.splitProperty = splitProperty.ShallowCopy();
			}
			if (reducerProperty != null)
			{
				sAMeshColliderProperty.reducerProperty = reducerProperty.ShallowCopy();
			}
			if (colliderProperty != null)
			{
				sAMeshColliderProperty.colliderProperty = colliderProperty.ShallowCopy();
			}
			if (rigidbodyProperty != null)
			{
				sAMeshColliderProperty.rigidbodyProperty = rigidbodyProperty.ShallowCopy();
			}
			sAMeshColliderProperty.modifyNameEnabled = modifyNameEnabled;
			return sAMeshColliderProperty;
		}
	}

	[Serializable]
	public class SAMeshColliderBuilderProperty
	{
		public SplitProperty splitProperty = new SplitProperty();

		public SAColliderBuilderCommon.ReducerProperty reducerProperty = new SAColliderBuilderCommon.ReducerProperty();

		public SAColliderBuilderCommon.ColliderProperty colliderProperty = new SAColliderBuilderCommon.ColliderProperty();

		public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty = new SAColliderBuilderCommon.RigidbodyProperty();

		public bool modifyNameEnabled = true;

		public SAMeshColliderBuilderProperty Copy()
		{
			SAMeshColliderBuilderProperty sAMeshColliderBuilderProperty = new SAMeshColliderBuilderProperty();
			if (splitProperty != null)
			{
				sAMeshColliderBuilderProperty.splitProperty = splitProperty.ShallowCopy();
			}
			if (reducerProperty != null)
			{
				sAMeshColliderBuilderProperty.reducerProperty = reducerProperty.ShallowCopy();
			}
			if (colliderProperty != null)
			{
				sAMeshColliderBuilderProperty.colliderProperty = colliderProperty.ShallowCopy();
			}
			if (rigidbodyProperty != null)
			{
				sAMeshColliderBuilderProperty.rigidbodyProperty = rigidbodyProperty.ShallowCopy();
			}
			sAMeshColliderBuilderProperty.modifyNameEnabled = modifyNameEnabled;
			return sAMeshColliderBuilderProperty;
		}

		public SAMeshColliderProperty ToSAMeshColliderProperty()
		{
			SAMeshColliderProperty sAMeshColliderProperty = new SAMeshColliderProperty();
			if (splitProperty != null)
			{
				sAMeshColliderProperty.splitProperty = splitProperty.ShallowCopy();
			}
			if (reducerProperty != null)
			{
				sAMeshColliderProperty.reducerProperty = reducerProperty.ShallowCopy();
			}
			if (colliderProperty != null)
			{
				sAMeshColliderProperty.colliderProperty = colliderProperty.ShallowCopy();
			}
			if (rigidbodyProperty != null)
			{
				sAMeshColliderProperty.rigidbodyProperty = rigidbodyProperty.ShallowCopy();
			}
			sAMeshColliderProperty.modifyNameEnabled = modifyNameEnabled;
			return sAMeshColliderProperty;
		}
	}
}
public class SABoneCollider : MonoBehaviour
{
	public SABoneColliderCommon.SABoneColliderProperty boneColliderProperty = new SABoneColliderCommon.SABoneColliderProperty();

	public string defaultName = "";

	public SABoneColliderCommon.SABoneColliderProperty defaultBoneColliderProperty = new SABoneColliderCommon.SABoneColliderProperty();

	[NonSerialized]
	public SABoneColliderCommon.SABoneColliderProperty edittingBoneColliderProperty;

	public bool modified;

	public bool modifiedChildren;

	[NonSerialized]
	public bool cleanupModified;

	[NonSerialized]
	public bool isDebug;

	public SABoneColliderCommon.BoneProperty boneProperty
	{
		get
		{
			if (boneColliderProperty == null)
			{
				return null;
			}
			return boneColliderProperty.boneProperty;
		}
	}

	public SABoneColliderCommon.SplitProperty splitProperty
	{
		get
		{
			if (boneColliderProperty == null)
			{
				return null;
			}
			return boneColliderProperty.splitProperty;
		}
	}

	public SAColliderBuilderCommon.ReducerProperty reducerProperty
	{
		get
		{
			if (boneColliderProperty == null)
			{
				return null;
			}
			return boneColliderProperty.reducerProperty;
		}
	}

	public SAColliderBuilderCommon.ColliderProperty colliderProperty
	{
		get
		{
			if (boneColliderProperty == null)
			{
				return null;
			}
			return boneColliderProperty.colliderProperty;
		}
	}

	public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty
	{
		get
		{
			if (boneColliderProperty == null)
			{
				return null;
			}
			return boneColliderProperty.rigidbodyProperty;
		}
	}

	public bool recursivery
	{
		get
		{
			if (boneProperty == null)
			{
				return false;
			}
			return boneProperty.recursivery;
		}
	}

	public bool modifyNameEnalbed
	{
		get
		{
			if (boneColliderProperty == null)
			{
				return false;
			}
			return boneColliderProperty.modifyNameEnabled;
		}
	}

	public void ChangeDefaultName(string defaultName)
	{
		bool flag = _IsModifyName();
		this.defaultName = defaultName;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ChangeModified(bool modified)
	{
		bool flag = _IsModifyName();
		this.modified = modified;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ChangeModifiedChildren(bool modifiedChildren)
	{
		bool flag = _IsModifyName();
		this.modifiedChildren = modifiedChildren;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ResetModified()
	{
		bool flag = _IsModifyName();
		modified = false;
		modifiedChildren = false;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ResetModifyName()
	{
		if (modifyNameEnalbed)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public string _ComputeModifyName()
	{
		if (modifyNameEnalbed)
		{
			if (modified)
			{
				if (string.IsNullOrEmpty(defaultName))
				{
					return "*";
				}
				return defaultName + "*";
			}
			if (modifiedChildren)
			{
				if (string.IsNullOrEmpty(defaultName))
				{
					return "+";
				}
				return defaultName + "+";
			}
		}
		if (string.IsNullOrEmpty(defaultName))
		{
			return "";
		}
		return defaultName;
	}

	public bool _IsModifyName()
	{
		if (modifyNameEnalbed)
		{
			if (string.IsNullOrEmpty(base.gameObject.name))
			{
				return string.IsNullOrEmpty(_ComputeModifyName());
			}
			return base.gameObject.name == _ComputeModifyName();
		}
		return false;
	}
}
public class SABoneColliderBuilder : MonoBehaviour
{
	public SABoneColliderCommon.SABoneColliderBuilderProperty boneColliderBuilderProperty = new SABoneColliderCommon.SABoneColliderBuilderProperty();

	[NonSerialized]
	public SABoneColliderCommon.SABoneColliderBuilderProperty edittingBoneColliderBuilderProperty;

	[NonSerialized]
	public bool cleanupModified;

	[NonSerialized]
	public bool isDebug;

	public SABoneColliderCommon.SplitProperty splitProperty
	{
		get
		{
			if (boneColliderBuilderProperty == null)
			{
				return null;
			}
			return boneColliderBuilderProperty.splitProperty;
		}
	}

	public SAColliderBuilderCommon.ReducerProperty reducerProperty
	{
		get
		{
			if (boneColliderBuilderProperty == null)
			{
				return null;
			}
			return boneColliderBuilderProperty.reducerProperty;
		}
	}

	public SAColliderBuilderCommon.ColliderProperty colliderProperty
	{
		get
		{
			if (boneColliderBuilderProperty == null)
			{
				return null;
			}
			return boneColliderBuilderProperty.colliderProperty;
		}
	}

	public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty
	{
		get
		{
			if (boneColliderBuilderProperty == null)
			{
				return null;
			}
			return boneColliderBuilderProperty.rigidbodyProperty;
		}
	}
}
public class SABoneColliderChild : MonoBehaviour
{
}
public class SAMeshCollider : MonoBehaviour
{
	public SAMeshColliderCommon.SplitMesh splitMesh = new SAMeshColliderCommon.SplitMesh();

	public SAMeshColliderCommon.SplitMode splitMode;

	public SAMeshColliderCommon.SAMeshColliderProperty meshColliderProperty = new SAMeshColliderCommon.SAMeshColliderProperty();

	public string defaultName = "";

	public SAMeshColliderCommon.SAMeshColliderProperty defaultMeshColliderProperty = new SAMeshColliderCommon.SAMeshColliderProperty();

	[NonSerialized]
	public SAMeshColliderCommon.SAMeshColliderProperty edittingMeshCollidertProperty;

	public bool modified;

	public bool modifiedChildren;

	[NonSerialized]
	public bool cleanupModified;

	[NonSerialized]
	public bool isDebug;

	public SAMeshColliderCommon.SplitProperty splitProperty
	{
		get
		{
			if (meshColliderProperty == null)
			{
				return null;
			}
			return meshColliderProperty.splitProperty;
		}
	}

	public SAColliderBuilderCommon.ReducerProperty reducerProperty
	{
		get
		{
			if (meshColliderProperty == null)
			{
				return null;
			}
			return meshColliderProperty.reducerProperty;
		}
	}

	public SAColliderBuilderCommon.ColliderProperty colliderProperty
	{
		get
		{
			if (meshColliderProperty == null)
			{
				return null;
			}
			return meshColliderProperty.colliderProperty;
		}
	}

	public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty
	{
		get
		{
			if (meshColliderProperty == null)
			{
				return null;
			}
			return meshColliderProperty.rigidbodyProperty;
		}
	}

	public bool splitMaterialEnabled
	{
		get
		{
			if (splitProperty == null)
			{
				return false;
			}
			return splitProperty.splitMaterialEnabled;
		}
	}

	public bool splitPrimitiveEnabled
	{
		get
		{
			if (splitProperty == null)
			{
				return false;
			}
			return splitProperty.splitPrimitiveEnabled;
		}
	}

	public bool splitPolygonNormalEnabled
	{
		get
		{
			if (splitProperty == null)
			{
				return false;
			}
			return splitProperty.splitPolygonNormalEnabled;
		}
	}

	public float splitPolygonNormalAngle
	{
		get
		{
			if (splitProperty == null)
			{
				return 0f;
			}
			return splitProperty.splitPolygonNormalAngle;
		}
	}

	public bool modifyNameEnalbed
	{
		get
		{
			if (meshColliderProperty == null)
			{
				return false;
			}
			return meshColliderProperty.modifyNameEnabled;
		}
	}

	public void ChangeDefaultName(string defaultName)
	{
		bool flag = _IsModifyName();
		this.defaultName = defaultName;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ChangeModified(bool modified)
	{
		bool flag = _IsModifyName();
		this.modified = modified;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ChangeModifiedChildren(bool modifiedChildren)
	{
		bool flag = _IsModifyName();
		this.modifiedChildren = modifiedChildren;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ResetModified()
	{
		bool flag = _IsModifyName();
		modified = false;
		modifiedChildren = false;
		if (modifyNameEnalbed && flag)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public void ResetModifyName()
	{
		if (modifyNameEnalbed)
		{
			base.gameObject.name = _ComputeModifyName();
		}
	}

	public string _ComputeModifyName()
	{
		if (modifyNameEnalbed)
		{
			if (modified)
			{
				if (string.IsNullOrEmpty(defaultName))
				{
					return "*";
				}
				return defaultName + "*";
			}
			if (modifiedChildren)
			{
				if (string.IsNullOrEmpty(defaultName))
				{
					return "+";
				}
				return defaultName + "+";
			}
		}
		if (string.IsNullOrEmpty(defaultName))
		{
			return "";
		}
		return defaultName;
	}

	public bool _IsModifyName()
	{
		if (modifyNameEnalbed)
		{
			if (string.IsNullOrEmpty(base.gameObject.name))
			{
				return string.IsNullOrEmpty(_ComputeModifyName());
			}
			return base.gameObject.name == _ComputeModifyName();
		}
		return false;
	}
}
public class SAMeshColliderBuilder : MonoBehaviour
{
	public SAMeshColliderCommon.SAMeshColliderBuilderProperty meshColliderBuilderProperty = new SAMeshColliderCommon.SAMeshColliderBuilderProperty();

	[NonSerialized]
	public SAMeshColliderCommon.SAMeshColliderBuilderProperty edittingMeshColliderBuilderProperty;

	[NonSerialized]
	public bool cleanupModified;

	[NonSerialized]
	public bool isDebug;

	public SAMeshColliderCommon.SplitProperty splitProperty
	{
		get
		{
			if (meshColliderBuilderProperty == null)
			{
				return null;
			}
			return meshColliderBuilderProperty.splitProperty;
		}
	}

	public SAColliderBuilderCommon.ReducerProperty reducerProperty
	{
		get
		{
			if (meshColliderBuilderProperty == null)
			{
				return null;
			}
			return meshColliderBuilderProperty.reducerProperty;
		}
	}

	public SAColliderBuilderCommon.ColliderProperty colliderProperty
	{
		get
		{
			if (meshColliderBuilderProperty == null)
			{
				return null;
			}
			return meshColliderBuilderProperty.colliderProperty;
		}
	}

	public SAColliderBuilderCommon.RigidbodyProperty rigidbodyProperty
	{
		get
		{
			if (meshColliderBuilderProperty == null)
			{
				return null;
			}
			return meshColliderBuilderProperty.rigidbodyProperty;
		}
	}

	public bool splitMaterialEnabled
	{
		get
		{
			if (splitProperty == null)
			{
				return false;
			}
			return splitProperty.splitMaterialEnabled;
		}
	}

	public bool splitPrimitiveEnabled
	{
		get
		{
			if (splitProperty == null)
			{
				return false;
			}
			return splitProperty.splitPrimitiveEnabled;
		}
	}

	public bool splitPolygonNormalEnabled
	{
		get
		{
			if (splitProperty == null)
			{
				return false;
			}
			return splitProperty.splitPolygonNormalEnabled;
		}
	}

	public float splitPolygonNormalAngle
	{
		get
		{
			if (splitProperty == null)
			{
				return 0f;
			}
			return splitProperty.splitPolygonNormalAngle;
		}
	}
}
public class ParameterCopy : MonoBehaviour
{
}
public class SittingAnimationSimulator : MonoBehaviour
{
	[SerializeField]
	private Animator avatarAnimator;

	[SerializeField]
	private AnimationClip sittingAnimation;

	[SerializeField]
	private RuntimeAnimatorController simulator;

	[SerializeField]
	private GameObject chair;

	private void Start()
	{
		if (!(avatarAnimator == null))
		{
			AnimatorOverrideController animatorOverrideController = new AnimatorOverrideController();
			animatorOverrideController.runtimeAnimatorController = simulator;
			avatarAnimator.runtimeAnimatorController = animatorOverrideController;
			animatorOverrideController["blank"] = sittingAnimation;
			UnityEngine.Object.Instantiate(chair, avatarAnimator.transform.position, avatarAnimator.transform.rotation);
		}
	}
}
public class SkirtSupporter : MonoBehaviour
{
	[Serializable]
	public struct BoneSet
	{
		[Tooltip("スカートボーンの根本")]
		public GameObject boneObject;

		[Tooltip("正面を0°とした場合の右回りの角度(0～359)")]
		[Range(0f, 359f)]
		public int angle;
	}

	[Header("Avatar Major Objects")]
	[Tooltip("アバターのAnimator（Humanoidの場合）")]
	public Animator avatarAnimator;

	[Tooltip("アバターのHips（相当の部位）")]
	public Transform hips;

	[Tooltip("アバターのLeftUpperLeg（相当の部位）")]
	public Transform leftUpperLeg;

	[Tooltip("アバターのRightUpperLeg（相当の部位）")]
	public Transform rightUpperLeg;

	[Tooltip("[TwistCancel設定時]アバターのLeftLowerLeg（相当の部位）")]
	public Transform leftLowerLeg;

	[Tooltip("[TwistCancel設定時]アバターのRightLowerLeg（相当の部位）")]
	public Transform rightLowerLeg;

	[Header("Avatar Skirt Objects")]
	[Tooltip("スカートボーンの親")]
	public GameObject skirtsParent;

	public List<BoneSet> skirtBones = new List<BoneSet>();

	[Header("Option")]
	[Tooltip("座り姿勢を安定させるスカート吊りを実装")]
	public bool skirtHang;

	[Tooltip("ねじり打ち消し機構を実装")]
	public bool twistCancel;

	[Tooltip("スカートのDynamicBoneをクリアして再設定する")]
	public bool dynamicBoneReset;

	[Header("Inner Objects")]
	public GameObject colliderPrefab;

	public DynamicBone dynamicBoneModel;

	private Animator before_animator;

	private GameObject before_parent;

	private void OnValidate()
	{
		MajorBonesUpdate();
		SkirtBonesUpdate();
	}

	private void MajorBonesUpdate()
	{
		if (!(avatarAnimator == before_animator))
		{
			before_animator = avatarAnimator;
			if (!(avatarAnimator == null))
			{
				hips = avatarAnimator.GetBoneTransform(HumanBodyBones.Hips);
				rightUpperLeg = avatarAnimator.GetBoneTransform(HumanBodyBones.RightUpperLeg);
				leftUpperLeg = avatarAnimator.GetBoneTransform(HumanBodyBones.LeftUpperLeg);
				rightLowerLeg = avatarAnimator.GetBoneTransform(HumanBodyBones.RightLowerLeg);
				leftLowerLeg = avatarAnimator.GetBoneTransform(HumanBodyBones.LeftLowerLeg);
			}
		}
	}

	private void SkirtBonesUpdate()
	{
		if (skirtBones.Count > 0)
		{
			OptimizeSkirtBones();
		}
		else
		{
			if (skirtsParent == before_parent)
			{
				return;
			}
			before_parent = skirtsParent;
			if (!(skirtsParent == null))
			{
				if (hips == null || leftUpperLeg == null || rightUpperLeg == null)
				{
					skirtsParent = before_parent;
					throw new Exception("Hips, LeftUpperLeg, RightUpperLeg のすべてがセットされた状態でSkirtsParentをセットしてください");
				}
				AutoSetSkirtBones();
			}
		}
	}

	private void AutoSetSkirtBones()
	{
		Vector3 position = base.transform.position;
		Quaternion rotation = base.transform.rotation;
		foreach (Transform item2 in skirtsParent.transform)
		{
			if (avatarAnimator != null)
			{
				bool flag = false;
				for (int i = 0; i < 55; i++)
				{
					if (item2 == avatarAnimator.GetBoneTransform((HumanBodyBones)i))
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			if (item2.childCount == 0)
			{
				continue;
			}
			BoneSet item = default(BoneSet);
			item.boneObject = item2.gameObject;
			Vector3 position2 = item2.GetChild(0).position;
			base.transform.position = new Vector3(rightUpperLeg.position.x, position2.y, rightUpperLeg.position.z);
			base.transform.LookAt(position2);
			float y = base.transform.eulerAngles.y;
			if (y > 180f)
			{
				base.transform.position = new Vector3(leftUpperLeg.position.x, position2.y, leftUpperLeg.position.z);
				base.transform.LookAt(position2);
				y = base.transform.eulerAngles.y;
				if (y < 180f || y > 360f)
				{
					base.transform.position = new Vector3(hips.position.x, position2.y, hips.position.z);
					base.transform.LookAt(position2);
					y = base.transform.eulerAngles.y;
				}
			}
			item.angle = (((int)y != 360) ? ((int)y) : 0);
			skirtBones.Add(item);
		}
		base.transform.position = position;
		base.transform.rotation = rotation;
		Debug.Log(skirtsParent.name + "配下のGameObjectからSkirtBonesを自動設定しました。");
	}

	private void OptimizeSkirtBones()
	{
		List<BoneSet> list = new List<BoneSet>();
		foreach (BoneSet skirtBone in skirtBones)
		{
			if (skirtBone.boneObject != null)
			{
				list.Add(skirtBone);
			}
		}
		skirtBones = list;
	}
}
public class Logger : MonoBehaviour
{
	private static Queue<string> queue = new Queue<string>(6);

	private void OnEnable()
	{
		UnityEngine.Application.logMessageReceived += HandleLog;
	}

	private void OnDisable()
	{
		UnityEngine.Application.logMessageReceived -= HandleLog;
	}

	private void OnGUI()
	{
		GUILayout.BeginArea(new Rect(0f, Screen.height - 140, Screen.width, 140f));
		foreach (string item in queue)
		{
			GUILayout.Label(item);
		}
		GUILayout.EndArea();
	}

	private void HandleLog(string message, string stackTrace, LogType type)
	{
		queue.Enqueue(Time.time + " - " + message);
		if (queue.Count > 5)
		{
			queue.Dequeue();
		}
	}
}
public class QuitScript : MonoBehaviour
{
	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class STMAppendExample : MonoBehaviour
{
	public SuperTextMesh text;

	public string appendThis = "Hello!";

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			text.Append(appendThis);
		}
	}
}
public class STMContinue : MonoBehaviour
{
	public SuperTextMesh stm;

	public KeyCode key = KeyCode.Space;

	private void Update()
	{
		if (Input.GetKeyDown(key))
		{
			stm.Continue();
		}
	}
}
public class STMDialogueSample : MonoBehaviour
{
	public SuperTextMesh textMesh;

	public KeyCode advanceKey = KeyCode.Return;

	public SpriteRenderer advanceKeySprite;

	private Vector3 advanceKeyStartScale = Vector3.one;

	public Vector3 advanceKeyScale = Vector3.one;

	public float advanceKeyTime = 1f;

	public string[] lines;

	private int currentLine;

	private void Start()
	{
		advanceKeyStartScale = advanceKeySprite.transform.localScale;
		Apply();
	}

	public void CompletedDrawing()
	{
		Debug.Log("I completed reading! Done!");
	}

	public void CompletedUnreading()
	{
		Debug.Log("I completed unreading!! Bye!");
		Apply();
	}

	private void Apply()
	{
		textMesh.Text = lines[currentLine];
		currentLine++;
		currentLine %= lines.Length;
	}

	private void Update()
	{
		if (Input.GetKey(advanceKey))
		{
			advanceKeySprite.transform.localScale = advanceKeyScale;
		}
		else
		{
			advanceKeySprite.transform.localScale = Vector3.Lerp(advanceKeySprite.transform.localScale, advanceKeyStartScale, Time.deltaTime * advanceKeyTime);
		}
		if (Input.GetKeyDown(advanceKey))
		{
			if (textMesh.reading)
			{
				textMesh.SpeedRead();
			}
			if (!textMesh.reading && !textMesh.unreading)
			{
				if (!textMesh.Continue())
				{
					textMesh.UnRead();
				}
				else
				{
					Debug.Log("CONTINUING NOW");
				}
			}
		}
		if (Input.GetKeyUp(advanceKey))
		{
			textMesh.RegularRead();
		}
	}
}
public class STMEventInterpreter : MonoBehaviour
{
	private SuperTextMesh _stm;

	public GameObject confetti;

	public AudioSource au;

	public AudioClip myClip;

	public STMSampleLink link;

	private List<STMSampleLink> allLinks = new List<STMSampleLink>();

	private List<SpriteRenderer> allBGs = new List<SpriteRenderer>();

	[HideInInspector]
	public List<SpriteRenderer> allStrikethrus = new List<SpriteRenderer>();

	[HideInInspector]
	public List<SpriteRenderer> allUnderlines = new List<SpriteRenderer>();

	public SpriteRenderer bgPrefab;

	[Header("Underline & Strikethru")]
	public SpriteRenderer linePrefab;

	[Header("Underline")]
	public Vector3 underlineDistance = new Vector3(0.02f, -0.15f, 0f);

	public float underlineWidth = 0.666667f;

	public float underlineThickness = 0.1f;

	public Color underlineColor = Color.white;

	[Header("Strikethru")]
	[Range(0f, 1f)]
	public float strikethruHeight = 0.3f;

	public float strikethruWidth = 0.666667f;

	public float strikethruThickness = 0.1f;

	public Color strikethruColor = Color.white;

	public SuperTextMesh stm
	{
		get
		{
			if (_stm == null)
			{
				_stm = base.transform.GetComponent<SuperTextMesh>();
			}
			return _stm;
		}
	}

	public void SayMessage()
	{
		Debug.Log("Saying message!");
	}

	[ContextMenu("DebugReset")]
	public void DebugReset()
	{
		allStrikethrus = new List<SpriteRenderer>();
		allUnderlines = new List<SpriteRenderer>();
	}

	public void DoEvent(string s, STMTextInfo info)
	{
		Vector3 position = info.Middle + base.transform.position;
		Vector3 vector = info.BottomLeftVert + base.transform.position;
		if (s.Contains("printpos"))
		{
			Debug.Log(info.rawIndex + " " + info.readTime + " " + s);
			Debug.DrawLine(vector, vector + Vector3.down, Color.red, 10f, depthTest: false);
		}
		else
		{
			if (s == "transcribe")
			{
				return;
			}
			if (s == "link")
			{
				Vector3 position2 = info.pos + base.transform.position + new Vector3((info.TopRightVert.x - info.pos.x) / 2f, info.size / 2f, 0f);
				STMSampleLink sTMSampleLink = UnityEngine.Object.Instantiate(link, position2, link.transform.rotation);
				sTMSampleLink.linkName = "Custom Link Address!";
				sTMSampleLink.transform.localScale = new Vector3(info.size, info.size, 0.5f);
				allLinks.Add(sTMSampleLink);
				return;
			}
			if (s.Length >= 2 && s.Substring(0, 2) == "bg")
			{
				Vector3 position3 = info.pos + base.transform.position + new Vector3((info.TopRightVert.x - info.pos.x) / 2f, info.size / 2f, 0.2f);
				SpriteRenderer spriteRenderer = UnityEngine.Object.Instantiate(bgPrefab, position3, bgPrefab.transform.rotation);
				spriteRenderer.color = Color.red;
				spriteRenderer.transform.localScale = new Vector3(info.size, info.size, 0.5f);
				allBGs.Add(spriteRenderer);
				return;
			}
			switch (s)
			{
			case "underline":
			{
				Vector3 position5 = info.pos + base.transform.position + new Vector3((info.TopRightVert.x - info.pos.x) / 2f, 0f, -0.01f) + underlineDistance;
				SpriteRenderer spriteRenderer3 = UnityEngine.Object.Instantiate(linePrefab, position5, linePrefab.transform.rotation);
				spriteRenderer3.transform.SetParent(base.transform);
				Vector3 localScale2 = new Vector3(underlineWidth, underlineThickness, 1f);
				spriteRenderer3.transform.localScale = localScale2;
				spriteRenderer3.color = underlineColor;
				allUnderlines.Add(spriteRenderer3);
				break;
			}
			case "strike":
			{
				Vector3 position4 = info.pos + base.transform.position + new Vector3((info.TopRightVert.x - info.pos.x) / 2f, info.size * strikethruHeight, -0.01f);
				SpriteRenderer spriteRenderer2 = UnityEngine.Object.Instantiate(linePrefab, position4, linePrefab.transform.rotation);
				spriteRenderer2.transform.SetParent(base.transform);
				Vector3 localScale = new Vector3(strikethruWidth, strikethruThickness, 1f);
				spriteRenderer2.transform.localScale = localScale;
				spriteRenderer2.color = strikethruColor;
				allStrikethrus.Add(spriteRenderer2);
				break;
			}
			case "confetti":
				UnityEngine.Object.Instantiate(confetti, position, confetti.transform.rotation);
				break;
			case "playSound":
				Debug.Log("Playing sound!");
				au.PlayOneShot(myClip, 1f);
				break;
			default:
				Debug.Log("Unknown event: '" + s + "'");
				break;
			}
		}
	}

	public void ClearLinks()
	{
		for (int i = 0; i < allLinks.Count; i++)
		{
			UnityEngine.Object.Destroy(allLinks[i].gameObject);
		}
		allLinks.Clear();
	}

	public void ClearBGs()
	{
		for (int i = 0; i < allBGs.Count; i++)
		{
			UnityEngine.Object.Destroy(allBGs[i].gameObject);
		}
		allBGs.Clear();
	}

	public void ClearUnderlines()
	{
		for (int i = 0; i < allUnderlines.Count; i++)
		{
			UnityEngine.Object.DestroyImmediate(allUnderlines[i].gameObject);
		}
		allUnderlines.Clear();
	}

	public void ClearStrikethrus()
	{
		for (int i = 0; i < allStrikethrus.Count; i++)
		{
			UnityEngine.Object.DestroyImmediate(allStrikethrus[i].gameObject);
		}
		allStrikethrus.Clear();
	}
}
public static class STMExtensionSample
{
	public static void SetTextWithStringAtStart(this SuperTextMesh stm, string extra)
	{
		stm.text = extra + stm.text;
	}

	public static void SetUppercaseText(this SuperTextMesh superTextMesh, string newText)
	{
		superTextMesh.text = newText.ToUpper();
	}
}
public class STMFakeCaret : MonoBehaviour
{
	public SuperTextMesh stm;

	public Vector3 offset;

	private void Update()
	{
		if (stm != null && stm.info.Count > 0 && stm.latestNumber > -1 && stm.hyphenedText[stm.latestNumber] != '\n')
		{
			STMTextInfo sTMTextInfo = stm.info[stm.latestNumber];
			base.transform.localPosition = sTMTextInfo.pos + sTMTextInfo.Advance(stm.characterSpacing, stm.quality) + offset;
		}
	}
}
public class STMInputStringDemo : MonoBehaviour
{
	public SuperTextMesh rawstm;

	public SuperTextMesh stm;

	private void Update()
	{
		string inputString = Input.inputString;
		if (Input.GetKeyDown(KeyCode.Backspace))
		{
			rawstm.text = rawstm.text.Substring(0, rawstm.text.Length - 1);
			rawstm.Rebuild();
		}
		int i = 0;
		for (int length = inputString.Length; i < length; i++)
		{
			if (inputString[i] != '\b')
			{
				rawstm.text += inputString[i];
			}
		}
		if (inputString.Length > 0)
		{
			rawstm.Rebuild();
		}
	}

	public void UpdateBox()
	{
		stm.Text = rawstm.text;
	}
}
[RequireComponent(typeof(RectTransform))]
public class STMMatchRect : MonoBehaviour
{
	private RectTransform tr;

	public SuperTextMesh stm;

	public Vector2 size;

	public Vector2 offset;

	public void OnEnable()
	{
		stm.OnPrintEvent += Match;
		tr = GetComponent<RectTransform>();
	}

	public void OnDisable()
	{
		stm.OnPrintEvent -= Match;
	}

	public void Match()
	{
		size.x = stm.bottomRightTextBounds.x - stm.topLeftTextBounds.x;
		size.y = 0f - stm.bottomRightTextBounds.y + stm.topLeftTextBounds.y;
		offset.x = stm.t.position.x + stm.rawTopLeftBounds.x + stm.rawBottomRightBounds.x * 2f;
		offset.y = stm.t.position.y - size.y - stm.rawTopLeftBounds.y;
		tr.sizeDelta = size;
		tr.position = offset;
		tr.pivot = Vector2.zero;
	}
}
public class STMPagination : MonoBehaviour
{
	public SuperTextMesh originalText;

	public SuperTextMesh overflowText;

	public void Awake()
	{
		overflowText.text = "";
	}

	public void OverflowLeftovers()
	{
		overflowText.text = originalText.leftoverText.TrimStart();
	}

	public void OverflowLeftovers(SuperTextMesh stm)
	{
		overflowText.text = stm.leftoverText.TrimStart();
	}
}
public class STMPreParse : MonoBehaviour
{
	public string addToStart = "";

	public void Parse(STMTextContainer x)
	{
		x.text = addToStart + x.text;
	}
}
public class STMPreParse2 : MonoBehaviour
{
	public string addToEnd = "";

	public void Parse(STMTextContainer x)
	{
		x.text += addToEnd;
	}
}
[RequireComponent(typeof(SuperTextMesh))]
public class STMPreParseEffect : MonoBehaviour
{
	public SuperTextMesh superTextMesh;

	public string colorName = "rainbow";

	private void Reset()
	{
		superTextMesh = GetComponent<SuperTextMesh>();
	}

	private void OnEnable()
	{
		superTextMesh.OnPreParse += AddTag;
	}

	private void OnDisable()
	{
		superTextMesh.OnPreParse -= AddTag;
	}

	private void AddTag(STMTextContainer container)
	{
		container.text = "<c=" + colorName + ">" + container.text;
	}
}
public class STMPreparse3 : MonoBehaviour
{
	public string textTag = "transcribe";

	public void Parse(STMTextContainer x)
	{
		string text = "<" + textTag + ">";
		string text2 = "</" + textTag + ">";
		int num;
		do
		{
			num = x.text.IndexOf(text);
			int num2 = ((num > -1) ? x.text.IndexOf(text2, num) : (-1));
			if (num2 == -1)
			{
				num2 = x.text.Length;
			}
			else
			{
				x.text = x.text.Remove(num2, text2.Length);
			}
			if (num > -1)
			{
				x.text = x.text.Remove(num, text.Length);
				num2 -= text.Length;
				Replace(x, num, num2);
			}
		}
		while (num > -1);
	}

	private void Replace(STMTextContainer x, int startingPoint, int endingPoint)
	{
		int num = startingPoint;
		bool flag = true;
		for (int i = startingPoint; i < endingPoint; i++)
		{
			string text = x.text[num].ToString();
			if (text == "<")
			{
				flag = false;
			}
			else if (text == ">")
			{
				flag = true;
			}
			if (flag)
			{
				string text2 = x.text[num].ToString().ToUpper();
				if (!(text2 == "A"))
				{
					if (text2 == "B")
					{
						text = "bbb";
					}
				}
				else
				{
					text = "aaa";
				}
				x.text = x.text.Remove(num, 1);
				x.text = x.text.Insert(num, text);
			}
			num += text.Length;
		}
	}
}
public class STMReadoutControls : MonoBehaviour
{
	public SuperTextMesh stm;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			stm.Read();
		}
	}
}
[RequireComponent(typeof(SuperTextMesh))]
public class STMRubyText : MonoBehaviour
{
	[Serializable]
	public class Ruby
	{
		public char ch;

		public string text;
	}

	private SuperTextMesh stm;

	public float verticalOffset;

	public float rubyTextSize = 0.25f;

	public Ruby[] ruby;

	private List<SuperTextMesh> rubyText = new List<SuperTextMesh>();

	private bool parserEnabled = true;

	private string[] split;

	private SuperTextMesh tempStm;

	private Vector3 tmpPos;

	public void OnEnable()
	{
		stm = GetComponent<SuperTextMesh>();
		stm.OnCustomEvent += Event;
		stm.OnPreParse += Parse;
		stm.OnRebuildEvent += ClearRubyText;
	}

	public void OnDisable()
	{
		stm.OnCustomEvent -= Event;
		stm.OnPreParse -= Parse;
		stm.OnRebuildEvent -= ClearRubyText;
	}

	public void Parse(STMTextContainer x)
	{
		parserEnabled = true;
		for (int i = 0; i < x.text.Length; i++)
		{
			if (x.text[i] == '<')
			{
				parserEnabled = false;
			}
			if (parserEnabled)
			{
				for (int j = 0; j < ruby.Length; j++)
				{
					if (x.text[i] == ruby[j].ch)
					{
						x.text = x.text.Insert(i, "<e=rt," + ruby[j].text + ">");
						i += 7 + ruby[j].text.Length;
					}
				}
			}
			if (x.text[i] == '>')
			{
				parserEnabled = true;
			}
		}
	}

	public void Event(string text, STMTextInfo info)
	{
		split = text.Split(',');
		if (split.Length == 2 && split[0] == "rt")
		{
			tempStm = new GameObject().AddComponent<SuperTextMesh>();
			tempStm.t.SetParent(base.transform);
			tempStm.t.name = split[1];
			tmpPos.x = info.Middle.x;
			tmpPos.y = info.pos.y + info.size + verticalOffset;
			tempStm.t.localPosition = tmpPos;
			tempStm.size = rubyTextSize;
			tempStm.font = stm.font;
			tempStm.color = stm.color;
			tempStm.anchor = TextAnchor.LowerCenter;
			tempStm.alignment = SuperTextMesh.Alignment.Center;
			tempStm.autoWrap = info.RelativeWidth;
			tempStm.bestFit = SuperTextMesh.BestFitMode.OverLimit;
			tempStm.text = split[1];
			rubyText.Add(tempStm);
		}
	}

	public void ClearRubyText()
	{
		for (int i = 0; i < rubyText.Count; i++)
		{
			UnityEngine.Object.Destroy(rubyText[i].gameObject);
		}
		rubyText.Clear();
	}
}
[RequireComponent(typeof(BoxCollider))]
public class STMSampleLink : MonoBehaviour
{
	public string linkName = "Sample Website";

	public void OnMouseDown()
	{
		Debug.Log("I was clicked!! Going to: " + linkName);
	}

	public STMSampleLink(string linkName)
	{
		this.linkName = linkName;
	}
}
public class STMSetTextExample : MonoBehaviour
{
	public SuperTextMesh stm;

	public string myString;

	private void Awake()
	{
		SetText();
	}

	[ContextMenu("SetText")]
	public void SetText()
	{
		stm.Text = myString;
	}
}
public class STMSimpleButton : MonoBehaviour
{
	public UnityEvent buttonEvent;

	public Vector3 normalSize = Vector3.one;

	public Vector3 mouseoverSize = Vector3.one;

	public Vector3 clickSize = Vector3.one;

	public void OnMouseEnter()
	{
		base.transform.localScale = mouseoverSize;
	}

	public void OnMouseExit()
	{
		base.transform.localScale = normalSize;
	}

	public void OnMouseDown()
	{
		base.transform.localScale = clickSize;
		buttonEvent.Invoke();
	}

	public void OnMouseUp()
	{
		base.transform.localScale = mouseoverSize;
	}
}
public class STMUnread : MonoBehaviour
{
	public SuperTextMesh stm;

	public KeyCode key = KeyCode.Return;

	private void Update()
	{
		if (Input.GetKeyDown(key))
		{
			stm.UnRead();
			Debug.Log("Triggering Unread!");
		}
	}

	public void OnUnreadComplete()
	{
		Debug.Log("Unread Completed!");
	}
}
public class STMVertexMod : MonoBehaviour
{
	[Header("Curve")]
	public Vector3 positionOffset;

	public float angleOffset = -1f;

	public Vector3 pivot;

	public float letterRotation = 1f;

	[Header("Sketchify")]
	[Range(0.001f, 8f)]
	public float sketchDelay = 0.25f;

	private float sketchLastTime = -1f;

	private UnityEngine.Random.State thisState;

	public float sketchAmount = 0.025f;

	private Vector3[] storedVerts = new Vector3[0];

	public bool unscaledTime = true;

	private void Awake()
	{
		sketchLastTime = -1f;
	}

	public void SketchifyVerts(Vector3[] verts, Vector3[] middles, Vector3[] positions)
	{
		if (storedVerts.Length != verts.Length)
		{
			Array.Resize(ref storedVerts, verts.Length);
			int i = 0;
			for (int num = verts.Length; i < num; i++)
			{
				storedVerts[i].x = verts[i].x + UnityEngine.Random.Range(0f - sketchAmount, sketchAmount);
				storedVerts[i].y = verts[i].y + UnityEngine.Random.Range(0f - sketchAmount, sketchAmount);
				storedVerts[i].z = verts[i].z + UnityEngine.Random.Range(0f - sketchAmount, sketchAmount);
			}
		}
		float num2 = Mathf.Floor((unscaledTime ? Time.unscaledTime : Time.time) / sketchDelay) * sketchDelay;
		if (num2 != sketchLastTime)
		{
			sketchLastTime = num2;
			if (storedVerts.Length != verts.Length)
			{
				Array.Resize(ref storedVerts, verts.Length);
			}
			int j = 0;
			for (int num3 = verts.Length; j < num3; j++)
			{
				storedVerts[j].x = verts[j].x + UnityEngine.Random.Range(0f - sketchAmount, sketchAmount);
				storedVerts[j].y = verts[j].y + UnityEngine.Random.Range(0f - sketchAmount, sketchAmount);
				storedVerts[j].z = verts[j].z + UnityEngine.Random.Range(0f - sketchAmount, sketchAmount);
			}
		}
		int k = 0;
		for (int num4 = verts.Length; k < num4; k++)
		{
			verts[k].x = storedVerts[k].x;
			verts[k].y = storedVerts[k].y;
			verts[k].z = storedVerts[k].z;
		}
	}

	public void AlignToGrid(Vector3[] verts, Vector3[] middles, Vector3[] positions)
	{
		int num = 0;
		Vector3 vector = RoundDifference(positions[0]);
		int i = 0;
		for (int num2 = positions.Length; i < num2; i++)
		{
			if (positions[i].y != positions[num].y)
			{
				num = i;
				vector = RoundDifference(positions[num]);
			}
			verts[4 * i] += vector;
			verts[4 * i + 1] += vector;
			verts[4 * i + 2] += vector;
			verts[4 * i + 3] += vector;
		}
	}

	private Vector3 RoundDifference(Vector3 original)
	{
		Vector3 vector = new Vector3(Mathf.Round(original.x), Mathf.Round(original.y), Mathf.Round(original.z));
		return original - vector;
	}

	public void ApplyCurveToVertices(Vector3[] verts, Vector3[] middles, Vector3[] positions)
	{
		int i = 0;
		for (int num = verts.Length / 4; i < num; i++)
		{
			verts[4 * i] -= new Vector3(positionOffset.x, verts[4 * i].x * positionOffset.y, positionOffset.z);
			verts[4 * i + 1] -= new Vector3(positionOffset.x, verts[4 * i].x * positionOffset.y, positionOffset.z);
			verts[4 * i + 2] -= new Vector3(positionOffset.x, verts[4 * i].x * positionOffset.y, positionOffset.z);
			verts[4 * i + 3] -= new Vector3(positionOffset.x, verts[4 * i].x * positionOffset.y, positionOffset.z);
			Vector3 myPivot = new Vector3(middles[i].x, positions[i].y, middles[i].z);
			Vector3 angles = new Vector3(0f, 0f, angleOffset * middles[i].x);
			if (float.IsNaN(angles.z))
			{
				angles = Vector3.zero;
			}
			verts[4 * i] = RotatePointAroundPivot(verts[4 * i], myPivot, angles);
			verts[4 * i + 1] = RotatePointAroundPivot(verts[4 * i + 1], myPivot, angles);
			verts[4 * i + 2] = RotatePointAroundPivot(verts[4 * i + 2], myPivot, angles);
			verts[4 * i + 3] = RotatePointAroundPivot(verts[4 * i + 3], myPivot, angles);
			angles.z += positions[i].y * letterRotation;
			verts[4 * i] = RotatePointAroundPivot(verts[4 * i], pivot, angles);
			verts[4 * i + 1] = RotatePointAroundPivot(verts[4 * i + 1], pivot, angles);
			verts[4 * i + 2] = RotatePointAroundPivot(verts[4 * i + 2], pivot, angles);
			verts[4 * i + 3] = RotatePointAroundPivot(verts[4 * i + 3], pivot, angles);
		}
	}

	private Vector3 RotatePointAroundPivot(Vector3 point, Vector3 myPivot, Vector3 angles)
	{
		Vector3 vector = point - myPivot;
		vector = Quaternion.Euler(angles) * vector;
		point = vector + myPivot;
		return point;
	}
}
public class STMVerticalWriting : MonoBehaviour
{
	public Vector3 eulerRotation;

	public void RotateLetters(Vector3[] verts, Vector3[] middles, Vector3[] positions)
	{
		int i = 0;
		for (int num = middles.Length; i < num; i++)
		{
			verts[4 * i] = RotateVertAroundMiddle(verts[4 * i], middles[i], eulerRotation);
			verts[4 * i + 1] = RotateVertAroundMiddle(verts[4 * i + 1], middles[i], eulerRotation);
			verts[4 * i + 2] = RotateVertAroundMiddle(verts[4 * i + 2], middles[i], eulerRotation);
			verts[4 * i + 3] = RotateVertAroundMiddle(verts[4 * i + 3], middles[i], eulerRotation);
		}
	}

	public Vector3 RotateVertAroundMiddle(Vector3 vert, Vector3 middle, Vector3 euler)
	{
		return Quaternion.Euler(euler) * (vert - middle) + middle;
	}
}
[CreateAssetMenu(fileName = "New Audio Clip Data", menuName = "Super Text Mesh/Audio Clip Data", order = 1)]
public class STMAudioClipData : ScriptableObject
{
	public bool showFoldout = true;

	public AudioClip[] clips;
}
[CreateAssetMenu(fileName = "New Auto Clip Data", menuName = "Super Text Mesh/Audo Clip Data", order = 1)]
public class STMAutoClipData : ScriptableObject
{
	public AudioClip clip;
}
[CreateAssetMenu(fileName = "New Color Data", menuName = "Super Text Mesh/Color Data", order = 1)]
public class STMColorData : ScriptableObject
{
	public Color color = Color.white;

	public STMColorData()
	{
		color = Color.white;
	}

	public STMColorData(Color color)
	{
		this.color = color;
	}
}
[CreateAssetMenu(fileName = "New Delay Data", menuName = "Super Text Mesh/Delay Data", order = 1)]
public class STMDelayData : ScriptableObject
{
	public int count;

	public STMDelayData(int delay)
	{
		count = delay;
	}
}
[CreateAssetMenu(fileName = "New Draw Animation", menuName = "Super Text Mesh/Draw Animation Data", order = 1)]
public class STMDrawAnimData : ScriptableObject
{
	[Tooltip("How long the Draw Animation will last.")]
	public float animTime;

	public AnimationCurve animCurve = new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f));

	public Vector3 startScale = Vector3.one;

	public Vector3 startOffset = Vector3.zero;

	[Tooltip("How long the fade animation will last.")]
	public float fadeTime;

	public AnimationCurve fadeCurve = new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f));

	[Tooltip("Starting color for read out text.")]
	public Color32 startColor = Color.clear;
}
[CreateAssetMenu(fileName = "New Font Data", menuName = "Super Text Mesh/Font Data", order = 1)]
public class STMFontData : ScriptableObject
{
	public Font font;

	[Tooltip("if new quality level should be used, or to use mesh default. Automatically disabled for non-dynamic fonts.")]
	public bool overrideQuality;

	[Tooltip("Only affects dynamic fonts.")]
	[Range(1f, 512f)]
	public int quality = 64;

	[Tooltip("Whether or not the filter mode should be overridden for this font. Be wary that having the same font use different filter modes in a scene might render strange.")]
	public bool overrideFilterMode;

	public FilterMode filterMode = FilterMode.Bilinear;

	public STMFontData(Font font)
	{
		this.font = font;
	}
}
[CreateAssetMenu(fileName = "New Gradient Data", menuName = "Super Text Mesh/Gradient Data", order = 1)]
public class STMGradientData : ScriptableObject
{
	public enum GradientDirection
	{
		Horizontal,
		Vertical
	}

	public Gradient gradient;

	public float gradientSpread = 0.1f;

	public float scrollSpeed;

	public GradientDirection direction;

	public bool smoothGradient = true;
}
[CreateAssetMenu(fileName = "New Jitter Data", menuName = "Super Text Mesh/Jitter Data", order = 1)]
public class STMJitterData : ScriptableObject
{
	public float amount;

	public bool perlin;

	public float perlinTimeMulti = 20f;

	public AnimationCurve distance = new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f));

	public AnimationCurve distanceOverTime = new AnimationCurve(new Keyframe(0f, 1f, 0f, 0f), new Keyframe(1f, 1f, 0f, 0f));

	[Range(0.0001f, 100f)]
	public float distanceOverTimeMulti = 1f;
}
[CreateAssetMenu(fileName = "New Material Data", menuName = "Super Text Mesh/Material Data", order = 1)]
public class STMMaterialData : ScriptableObject
{
	public Material material;
}
[CreateAssetMenu(fileName = "New Quad Data", menuName = "Super Text Mesh/Quad Data", order = 1)]
public class STMQuadData : ScriptableObject
{
	public Texture texture;

	[Tooltip("If a quad is a silhouette, it won't use the color from its texture, just the alpha. If it's a silhouette, it can be effected by text color.")]
	public bool silhouette;

	public bool overrideFilterMode;

	public FilterMode filterMode = FilterMode.Bilinear;

	public int columns = 1;

	public int rows = 1;

	public int iconIndex;

	public float animDelay;

	public int[] frames;

	public Vector2 size = Vector2.one;

	public Vector3 offset = Vector3.zero;

	public float advance;

	public Vector3 TopLeftVert => new Vector3(0f, size.y, 0f) + offset;

	public Vector3 TopRightVert => new Vector3(size.x, size.y, 0f) + offset;

	public Vector3 BottomRightVert => new Vector3(size.x, 0f, 0f) + offset;

	public Vector3 BottomLeftVert => new Vector3(0f, 0f, 0f) + offset;

	public Vector3 Middle => new Vector3(size.x * 0.5f, size.y * 0.5f, 0f) + offset;

	private Vector2 uvSize => new Vector2(1f / (float)columns, 1f / (float)rows);

	public Vector2 UvTopLeft(float myTime, int myIconIndex)
	{
		return new Vector2(0f, uvSize.y) + UvOffset(myTime, myIconIndex);
	}

	public Vector2 UvTopRight(float myTime, int myIconIndex)
	{
		return uvSize + UvOffset(myTime, myIconIndex);
	}

	public Vector2 UvBottomRight(float myTime, int myIconIndex)
	{
		return new Vector2(uvSize.x, 0f) + UvOffset(myTime, myIconIndex);
	}

	public Vector2 UvBottomLeft(float myTime, int myIconIndex)
	{
		return UvOffset(myTime, myIconIndex);
	}

	public Vector2 UvMiddle(float myTime, int myIconIndex)
	{
		return uvSize * 0.5f + UvOffset(myTime, myIconIndex);
	}

	private Vector2 UvOffset(float myTime, int myIconIndex)
	{
		FixColumnCount();
		if (myIconIndex < 0 && (columns > 1 || rows > 1) && animDelay > 0f && (float)frames.Length > 0f)
		{
			myIconIndex = frames[(int)Mathf.Floor(myTime / animDelay) % frames.Length];
		}
		else
		{
			myIconIndex = ((myIconIndex > -1) ? myIconIndex : iconIndex);
			myIconIndex %= columns * rows;
		}
		int num = (int)Mathf.Floor((float)myIconIndex / (float)columns);
		return new Vector2((float)(myIconIndex % columns) / (float)columns, (float)num / (float)rows);
	}

	private void OnValidate()
	{
		FixColumnCount();
	}

	private void FixColumnCount()
	{
		if (columns < 1)
		{
			columns = 1;
		}
		if (rows < 1)
		{
			rows = 1;
		}
	}
}
[CreateAssetMenu(fileName = "New Sound Clip Data", menuName = "Super Text Mesh/Sound Clip Data", order = 1)]
public class STMSoundClipData : ScriptableObject
{
	[Serializable]
	public class AutoClip
	{
		public string name;

		public AudioClip clip;
	}

	public List<AutoClip> clips = new List<AutoClip>();
}
[CreateAssetMenu(fileName = "New Gradient Data", menuName = "Super Text Mesh/Texture Data", order = 1)]
public class STMTextureData : ScriptableObject
{
	public Texture texture;

	public FilterMode filterMode;

	public bool relativeToLetter;

	public bool scaleWithText;

	public Vector2 tiling = Vector2.one;

	public Vector2 offset = Vector2.zero;

	public Vector2 scrollSpeed = Vector2.one;
}
public class STMUITextUpdater : MonoBehaviour
{
	public Text uiText;

	public SuperTextMesh stm;

	private bool needsUpdate = true;

	private void OnEnable()
	{
		needsUpdate = true;
	}

	private void LateUpdate()
	{
		if (needsUpdate)
		{
			needsUpdate = true;
			stm.text = uiText.text;
			stm.gameObject.SetActive(uiText.enabled);
		}
	}

	public void UpdateText()
	{
		needsUpdate = true;
	}
}
[CreateAssetMenu(fileName = "New Voice Data", menuName = "Super Text Mesh/Voice Data", order = 1)]
public class STMVoiceData : ScriptableObject
{
	[TextArea(3, 10)]
	public string text;
}
[Serializable]
public class STMWaveControl
{
	public AnimationCurve curveX = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));

	public AnimationCurve curveY = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));

	public AnimationCurve curveZ = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));

	[FormerlySerializedAs("offset")]
	[Range(0f, 1f)]
	[Tooltip("Timing offset compared to other waves.")]
	public float phase;

	[Tooltip("How fast the wave will move over time.")]
	public Vector3 speed = Vector3.zero;

	[Tooltip("Multiplier on the current wave value.")]
	public Vector3 strength = Vector3.zero;

	[Tooltip("Timing difference between letters.")]
	public Vector3 density = Vector3.zero;
}
[Serializable]
public class STMWaveRotationControl
{
	public AnimationCurve curveZ = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));

	[Range(0f, 1f)]
	[Tooltip("Timing offset compared to other waves.")]
	public float phase;

	[Tooltip("How fast the wave will move over time.")]
	public float speed;

	[Tooltip("Multiplier on the current wave value.")]
	public float strength;

	[Tooltip("Timing difference between letters.")]
	public float density;

	[Tooltip("Origin position of this animation.")]
	public Vector2 pivot = Vector2.zero;
}
[Serializable]
public class STMWaveScaleControl
{
	public AnimationCurve curveX = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));

	public AnimationCurve curveY = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));

	[Range(0f, 1f)]
	[Tooltip("Timing offset compared to other waves.")]
	public float phase;

	[Tooltip("How fast the wave will move over time.")]
	public Vector2 speed = Vector2.zero;

	[Tooltip("Multiplier on the current wave value.")]
	public Vector2 strength = Vector2.zero;

	[Tooltip("Timing difference between letters.")]
	public Vector2 density = Vector2.zero;

	[Tooltip("Origin position of this animation.")]
	public Vector2 pivot = Vector2.zero;
}
[CreateAssetMenu(fileName = "New Wave Data", menuName = "Super Text Mesh/Wave Data", order = 1)]
public class STMWaveData : ScriptableObject
{
	public bool animateFromTimeDrawn;

	public bool positionControl = true;

	[FormerlySerializedAs("main")]
	public STMWaveControl position;

	[Tooltip("Use these below values?")]
	public bool individualVertexControl;

	public STMWaveControl topLeft;

	public STMWaveControl topRight;

	public STMWaveControl bottomLeft;

	public STMWaveControl bottomRight;

	public bool rotationControl;

	public STMWaveRotationControl rotation;

	public bool scaleControl;

	public STMWaveScaleControl scale;
}
[Serializable]
public class STMTextContainer
{
	public string text;

	public STMTextContainer(string text)
	{
		this.text = text;
	}
}
[Serializable]
public class STMTextInfo
{
	public CharacterInfo ch;

	public Vector3 pos;

	public Vector3 offset;

	public float readTime = -1f;

	public float unreadTime = -1f;

	public int line;

	public int rawIndex;

	public float indent;

	public STMDrawAnimData drawAnimData;

	public float size;

	public SuperTextMesh.Alignment alignment;

	public SuperTextMesh.DrawOrder drawOrder;

	public List<string> ev = new List<string>();

	public List<string> ev2 = new List<string>();

	public STMColorData colorData;

	public STMGradientData gradientData;

	public STMTextureData textureData;

	public STMDelayData delayData;

	public STMWaveData waveData;

	public STMJitterData jitterData;

	public float readDelay;

	public STMAudioClipData audioClipData;

	public bool stopPreviousSound;

	public SuperTextMesh.PitchMode pitchMode;

	public float overridePitch;

	public float minPitch;

	public float maxPitch;

	public float speedReadPitch;

	public STMFontData fontData;

	public STMQuadData quadData;

	public bool isQuad;

	public int quadIndex = -1;

	public STMMaterialData materialData;

	public STMSoundClipData soundClipData;

	public int IdxIdentifier;

	public bool InfoInUse;

	private int chGlyphIndex = -1;

	private int chMinX;

	private int chMaxX;

	private int chMinY;

	private int chMaxY;

	private int chAdvance;

	public int chSize = 1;

	public bool submeshChange;

	public bool invoked;

	private Vector3 _topLeftVert;

	private Vector3 _topRightVert;

	private Vector3 _bottomRightVert;

	private Vector3 _bottomLeftVert;

	private Vector3 _middle;

	private Vector3 RelativePos_ReturnVal = Vector3.zero;

	private float RelativePos_Multiplier;

	private Vector3 RelativePos2_ReturnVal = Vector3.zero;

	private Vector3 Advance_ReturnVal = Vector3.zero;

	public char character => Convert.ToChar(chGlyphIndex);

	public Vector2 ratio
	{
		get
		{
			Vector2 zero = Vector2.zero;
			if (isQuad)
			{
				zero.x = quadData.size.x;
				zero.y = quadData.size.y;
			}
			else
			{
				zero.x = (float)chMaxX - (float)chMinX;
				zero.y = (float)chMaxY - (float)chMinY;
			}
			if (zero.x > zero.y)
			{
				return new Vector2(size, zero.y / zero.x * size);
			}
			if (zero.x < zero.y)
			{
				return new Vector2(zero.x / zero.y * size, size);
			}
			return new Vector3(size, size);
		}
	}

	public Vector3 TopLeftVert
	{
		get
		{
			if (isQuad)
			{
				return RelativePos2(quadData.TopLeftVert);
			}
			_topLeftVert.x = chMinX;
			_topLeftVert.y = chMaxY;
			_topLeftVert.z = 0f;
			return RelativePos(_topLeftVert);
		}
	}

	public Vector3 TopRightVert
	{
		get
		{
			if (isQuad)
			{
				return RelativePos2(quadData.TopRightVert);
			}
			_topRightVert.x = chMaxX;
			_topRightVert.y = chMaxY;
			_topRightVert.z = 0f;
			return RelativePos(_topRightVert);
		}
	}

	public Vector3 BottomRightVert
	{
		get
		{
			if (isQuad)
			{
				return RelativePos2(quadData.BottomRightVert);
			}
			_bottomRightVert.x = chMaxX;
			_bottomRightVert.y = chMinY;
			_bottomRightVert.z = 0f;
			return RelativePos(_bottomRightVert);
		}
	}

	public Vector3 BottomLeftVert
	{
		get
		{
			if (isQuad)
			{
				return RelativePos2(quadData.BottomLeftVert);
			}
			_bottomLeftVert.x = chMinX;
			_bottomLeftVert.y = chMinY;
			_bottomLeftVert.z = 0f;
			return RelativePos(_bottomLeftVert);
		}
	}

	public Vector3 Middle
	{
		get
		{
			if (isQuad)
			{
				return RelativePos2(quadData.Middle);
			}
			_middle.x = (float)(chMinX + chMaxX) * 0.5f;
			_middle.y = (float)(chMinY + chMaxY) * 0.5f;
			_middle.z = 0f;
			return RelativePos(_middle);
		}
	}

	public float RelativeWidth
	{
		get
		{
			if (isQuad)
			{
				return quadData.size.x * size;
			}
			return (float)chMaxX * (size / (float)chSize);
		}
	}

	public void UpdateCachedValuesIfChanged()
	{
		if (chGlyphIndex != ch.index)
		{
			chGlyphIndex = ch.index;
			chMinX = ch.minX;
			chMaxX = ch.maxX;
			chMinY = ch.minY;
			chMaxY = ch.maxY;
			chAdvance = ch.advance;
			chSize = ch.size;
		}
		chSize = ((ch.size == 0) ? 1 : ch.size);
	}

	public Vector3 RelativePos(Vector3 yeah)
	{
		RelativePos_Multiplier = size / (float)chSize;
		RelativePos_ReturnVal.x = pos.x + offset.x + yeah.x * RelativePos_Multiplier;
		RelativePos_ReturnVal.y = pos.y + offset.y + yeah.y * RelativePos_Multiplier;
		RelativePos_ReturnVal.z = pos.z + offset.z + yeah.z * RelativePos_Multiplier;
		return RelativePos_ReturnVal;
	}

	public Vector3 RelativePos2(Vector3 yeah)
	{
		RelativePos2_ReturnVal.x = pos.x + offset.x + yeah.x * size;
		RelativePos2_ReturnVal.y = pos.y + offset.y + yeah.y * size;
		RelativePos2_ReturnVal.z = pos.z + offset.z + yeah.z * size;
		return RelativePos2_ReturnVal;
	}

	public Vector3 RelativeAdvance(float extraSpacing, float quality)
	{
		return Advance(extraSpacing, quality) + pos;
	}

	public Vector3 RelativeAdvance(float extraSpacing)
	{
		return RelativeAdvance(extraSpacing, chSize);
	}

	public Vector3 Advance(float extraSpacing, float myQuality)
	{
		if (quadData != null)
		{
			Advance_ReturnVal.x = (quadData.size.x + quadData.advance) * size + extraSpacing * size / myQuality;
			Advance_ReturnVal.y = 0f;
			Advance_ReturnVal.z = 0f;
		}
		else
		{
			Advance_ReturnVal.x = ((float)chAdvance + extraSpacing * size) * (size / myQuality);
			Advance_ReturnVal.y = 0f;
			Advance_ReturnVal.z = 0f;
		}
		return Advance_ReturnVal;
	}

	public Vector3 Advance(float extraSpacing)
	{
		return Advance(extraSpacing, chSize);
	}

	public STMTextInfo()
	{
		ch = default(CharacterInfo);
		pos = Vector3.zero;
		offset = Vector3.zero;
		line = 0;
		rawIndex = 0;
		indent = 0f;
		size = 16f;
		ev.Clear();
		ev2.Clear();
		readTime = -1f;
		unreadTime = -1f;
		quadIndex = -1;
		isQuad = false;
		submeshChange = false;
		invoked = false;
	}

	public STMTextInfo(SuperTextMesh stm)
	{
		SetValues(stm);
	}

	public void SetValues(SuperTextMesh stm)
	{
		ch.style = stm.style;
		gradientData = null;
		colorData = null;
		textureData = null;
		delayData = null;
		waveData = null;
		jitterData = null;
		audioClipData = null;
		fontData = null;
		quadData = null;
		offset = Vector3.zero;
		indent = 0f;
		rawIndex = 0;
		size = stm.size;
		ev.Clear();
		ev2.Clear();
		alignment = stm.alignment;
		stopPreviousSound = stm.stopPreviousSound;
		pitchMode = stm.pitchMode;
		overridePitch = stm.overridePitch;
		minPitch = stm.minPitch;
		maxPitch = stm.maxPitch;
		speedReadPitch = stm.speedReadPitch;
		readDelay = stm.readDelay;
		if (drawAnimData != null)
		{
			if (drawAnimData.name != stm.drawAnimName)
			{
				drawAnimData = Resources.Load<STMDrawAnimData>("STMDrawAnims/" + stm.drawAnimName);
				if (drawAnimData == null)
				{
					STMDrawAnimData[] array = Resources.LoadAll<STMDrawAnimData>("STMDrawAnims");
					if (array.Length != 0)
					{
						drawAnimData = array[0];
					}
				}
			}
		}
		else
		{
			drawAnimData = Resources.Load<STMDrawAnimData>("STMDrawAnims/" + stm.drawAnimName);
			if (drawAnimData == null)
			{
				STMDrawAnimData[] array2 = Resources.LoadAll<STMDrawAnimData>("STMDrawAnims");
				if (array2.Length != 0)
				{
					drawAnimData = array2[0];
				}
			}
		}
		drawOrder = stm.drawOrder;
		quadIndex = -1;
		isQuad = false;
		materialData = null;
		soundClipData = null;
		quadIndex = -1;
		submeshChange = false;
		invoked = false;
	}

	public STMTextInfo(STMTextInfo clone, CharacterInfo ch)
		: this(clone)
	{
		this.ch = ch;
		quadData = null;
		isQuad = false;
	}

	public STMTextInfo(STMTextInfo clone)
	{
		SetValues(clone);
	}

	public void SetValues(STMTextInfo clone)
	{
		ch = clone.ch;
		pos = clone.pos;
		offset = clone.offset;
		line = clone.line;
		rawIndex = clone.rawIndex;
		indent = clone.indent;
		if (clone.ev.Count > 0)
		{
			ev = new List<string>(clone.ev);
		}
		if (clone.ev2.Count > 0)
		{
			ev2 = new List<string>(clone.ev2);
		}
		colorData = clone.colorData;
		gradientData = clone.gradientData;
		textureData = clone.textureData;
		size = clone.size;
		delayData = clone.delayData;
		waveData = clone.waveData;
		jitterData = clone.jitterData;
		alignment = clone.alignment;
		readTime = clone.readTime;
		unreadTime = clone.unreadTime;
		drawAnimData = clone.drawAnimData;
		audioClipData = clone.audioClipData;
		stopPreviousSound = clone.stopPreviousSound;
		pitchMode = clone.pitchMode;
		overridePitch = clone.overridePitch;
		minPitch = clone.minPitch;
		maxPitch = clone.maxPitch;
		speedReadPitch = clone.speedReadPitch;
		readDelay = clone.readDelay;
		drawOrder = clone.drawOrder;
		fontData = clone.fontData;
		quadData = clone.quadData;
		isQuad = clone.isQuad;
		materialData = clone.materialData;
		soundClipData = clone.soundClipData;
		quadIndex = clone.quadIndex;
		submeshChange = clone.submeshChange;
		invoked = false;
	}
}
[HelpURL("Assets/Clavian/SuperTextMesh/Documentation/SuperTextMesh.html")]
[AddComponentMenu("Mesh/Super Text Mesh", 3)]
[ExecuteInEditMode]
[DisallowMultipleComponent]
public class SuperTextMesh : MonoBehaviour, ILayoutElement
{
	public enum PitchMode
	{
		Normal,
		Single,
		Random,
		Perlin
	}

	public enum MaskMode
	{
		Inside = 0,
		Outside = -1
	}

	public enum Alignment
	{
		Left,
		Center,
		Right,
		Justified,
		ForceJustified
	}

	public enum VerticalLimitMode
	{
		ShowLast,
		CutOff,
		Ignore,
		AutoPause,
		AutoPauseFull
	}

	public delegate void OnCompleteAction();

	public delegate void OnUndrawnAction();

	public delegate void OnRebuildAction();

	public delegate void OnPrintAction();

	[Serializable]
	public class CustomEvent : UnityEvent<string, STMTextInfo>
	{
	}

	public delegate void OnCustomAction(string text, STMTextInfo info);

	[Serializable]
	public class VertexMod : UnityEvent<Vector3[], Vector3[], Vector3[]>
	{
	}

	public delegate void OnVertexModAction(Vector3[] verts, Vector3[] middles, Vector3[] positions);

	[Serializable]
	public class PreParse : UnityEvent<STMTextContainer>
	{
	}

	public delegate void OnPreParseAction(STMTextContainer container);

	public enum DrawOrder
	{
		LeftToRight,
		AllAtOnce,
		OneWordAtATime,
		Random,
		RightToLeft,
		ReverseLTR,
		RTLOneWordAtATime,
		OneLineAtATime
	}

	[Serializable]
	public enum BestFitMode
	{
		Off,
		Always,
		OverLimit
	}

	public bool showTextFoldout = true;

	public bool showAppearanceFoldout = true;

	public bool showMaterialFoldout = true;

	public bool showPositionFoldout = true;

	public bool showTimingFoldout;

	public bool showFunctionalityFoldout;

	public bool showAudioFoldout;

	public bool showEventFoldout;

	public bool showBetaFoldout;

	private static SuperTextMeshData _data;

	private Transform _t;

	private MeshFilter _f;

	private MeshRenderer _r;

	private CanvasRenderer _c;

	public List<STMTextInfo> info = new List<STMTextInfo>();

	private List<int> lineBreaks = new List<int>();

	private List<float> lineHeights = new List<float>();

	[TextArea(3, 10)]
	[FormerlySerializedAs("text")]
	public string _text = "<c=rainbow><w>Hello, World!";

	[HideInInspector]
	public string drawText;

	[HideInInspector]
	public string hyphenedText;

	[Tooltip("Font to be used by this text mesh. .rtf, .otf, and Unity fonts are supported.")]
	public Font font;

	[Tooltip("Default color of the text mesh. This can be changed with the <c> tag! See the docs for more info.")]
	public Color32 color = Color.white;

	[Tooltip("Will the text listen to tags like <b> and <i>? See docs for a full list of tags.")]
	public bool richText = true;

	[Tooltip("Delay in seconds between letters getting read out. Disabled if set to 0.")]
	public float readDelay;

	[Tooltip("Multiple of time for when speeding up text. Set it to a big number like 1000 to show all text immediately.")]
	public float speedReadScale = 2f;

	[Tooltip("Whether reading uses deltaTime or fixedDeltaTime")]
	public bool ignoreTimeScale = true;

	public bool disableAnimatedText;

	[Tooltip("Name of what draw animation will be used. Case-sensitive.")]
	public string drawAnimName = "Appear";

	[Tooltip("Delay between letters, for undrawing.")]
	public float unreadDelay = 0.05f;

	[Tooltip("Undraw order.")]
	public DrawOrder undrawOrder = DrawOrder.AllAtOnce;

	[Tooltip("Undraw animation name.")]
	public string undrawAnimName = "Appear";

	[Tooltip("Audio source for read sound clips. Sound won't be played if null.")]
	public AudioSource audioSource;

	[Tooltip("Default sound to be read by the above audio source. Can be left null to make no sound by default.")]
	public AudioClip[] audioClips;

	[Tooltip("Should a new letter's sound stop a previous one and play, or let the old one keep playing?")]
	public bool stopPreviousSound = true;

	[Tooltip("Pitch options for reading out text.")]
	public PitchMode pitchMode;

	[Tooltip("New pitch for the sound clip.")]
	[Range(0f, 3f)]
	public float overridePitch = 1f;

	[Tooltip("Minimum pitch for random pitches. If same or greater than max pitch, this will be the pitch.")]
	[Range(0f, 3f)]
	public float minPitch = 0.9f;

	[Tooltip("Maximum pitch for random pitches.")]
	[Range(0f, 3f)]
	public float maxPitch = 1.2f;

	[Range(-2f, 2f)]
	[Tooltip("This amount will be ADDED to the pitch when speedreading. Speedreading uses the delay from 'Fast Delay'")]
	public float speedReadPitch;

	[Tooltip("Multiple for how fast the perlin noise will advance.")]
	public float perlinPitchMulti = 1f;

	private bool speedReading;

	private bool skippingToEnd;

	[HideInInspector]
	public bool reading;

	private Coroutine readRoutine;

	[HideInInspector]
	public bool unreading;

	[Tooltip("Size in local space for letters, by default. Can be changed with the <s> tag.")]
	public float size = 1f;

	[HideInInspector]
	public float bestFitMulti = 1f;

	[Range(1f, 500f)]
	[Tooltip("Point size of text. Try to keep it as small as possible while looking crisp!")]
	public int quality = 64;

	[Tooltip("Choose 'Point' for a crisp look. You'll probably want that for pixel fonts!")]
	public FilterMode filterMode = FilterMode.Bilinear;

	[Tooltip("This value is used with how UI Text reacts to masking.")]
	public MaskMode maskMode;

	[Tooltip("Default letter style. Can be changed with the <i> and <b> tags, using rich text.")]
	public FontStyle style;

	[Tooltip("Additional offset for text from the transform, in local space. This does not effect the bounding box, and can be used to better align text with other elements.")]
	public Vector3 baseOffset = Vector3.zero;

	public bool relativeBaseOffset = true;

	[Tooltip("Adjust line spacing between multiple lines of text. 1 is the default for the font.")]
	public float lineSpacing = 1f;

	[Tooltip("Adjust additional spacing between characters. 0 is default.")]
	public float characterSpacing;

	[Tooltip("How far tabs indent.")]
	public float tabSize = 4f;

	[Tooltip("Distance in local space before a line break is automatically inserted at the previous space. Disabled if set to 0.")]
	public float autoWrap = 12f;

	[Tooltip("If true, STM will set its bounds based on RectTransform, without need for Content Size Fitter.")]
	public bool uiWrap = true;

	[Tooltip("If true, STM will set its bounds based on RectTransform, without need for Content Size Fitter.")]
	public bool uiLimit = true;

	[Tooltip("With auto wrap, should large words be split to fit in the box?")]
	public bool breakText;

	[Tooltip("When large words are split, Should a hyphen be inserted?")]
	public bool insertHyphens = true;

	[Tooltip("The anchor point of the mesh. For UI text, this also controls the alignment.")]
	public TextAnchor anchor;

	[Tooltip("Decides where text should align to. Uses the Auto Wrap box as bounds.")]
	public Alignment alignment;

	[Tooltip("Maximum vertical space for this text box. Infinite if set to 0.")]
	public float verticalLimit;

	[Tooltip("How to treat text that goes over the vertical limit.")]
	public VerticalLimitMode verticalLimitMode = VerticalLimitMode.Ignore;

	public string leftoverText;

	[Tooltip("The material to be used by this text mesh. This is a Material so settings can be shared between multiple text meshes easily.")]
	[FormerlySerializedAs("textMat")]
	public Material textMaterial;

	public Mesh textMesh;

	private bool areWeAnimating;

	[HideInInspector]
	public Vector3 rawTopLeftBounds;

	[HideInInspector]
	public Vector3 rawBottomRightBounds;

	[HideInInspector]
	public Vector3 rawBottomRightTextBounds;

	[HideInInspector]
	public Vector3 topLeftBounds;

	[HideInInspector]
	public Vector3 topRightBounds;

	[HideInInspector]
	public Vector3 bottomLeftBounds;

	[HideInInspector]
	public Vector3 bottomRightBounds;

	[HideInInspector]
	public Vector3 centerBounds;

	[HideInInspector]
	public Vector3 topLeftTextBounds;

	[HideInInspector]
	public Vector3 topRightTextBounds;

	[HideInInspector]
	public Vector3 bottomLeftTextBounds;

	[HideInInspector]
	public Vector3 bottomRightTextBounds;

	[HideInInspector]
	public Vector3 centerTextBounds;

	[HideInInspector]
	public Vector3 finalTopLeftTextBounds;

	[HideInInspector]
	public Vector3 finalTopRightTextBounds;

	[HideInInspector]
	public Vector3 finalBottomLeftTextBounds;

	[HideInInspector]
	public Vector3 finalBottomRightTextBounds;

	[HideInInspector]
	public Vector3 finalCenterTextBounds;

	private float lowestPosition;

	private float lowestDrawnPosition;

	private float lowestDrawnPositionRaw;

	private float furthestDrawnPosition;

	private float totalWidth;

	public Vector3 unwrappedBottomRightTextBounds;

	public UnityEvent onCompleteEvent;

	public UnityEvent onUndrawnEvent;

	public UnityEvent onRebuildEvent;

	public UnityEvent onPrintEvent;

	[FormerlySerializedAs("customEvent")]
	public CustomEvent onCustomEvent;

	[FormerlySerializedAs("vertexMod")]
	public VertexMod onVertexMod;

	[FormerlySerializedAs("preParse")]
	public PreParse onPreParse;

	public bool debugMode;

	[HideInInspector]
	public float totalReadTime;

	[HideInInspector]
	public float totalUnreadTime;

	[HideInInspector]
	public float currentReadTime;

	private Vector3[] endVerts = new Vector3[0];

	private Color32[] endCol32 = new Color32[0];

	private Vector2[] endUv = new Vector2[0];

	private Vector2[] endUv2 = new Vector2[0];

	private List<Vector4> ratiosAndUvMids = new List<Vector4>();

	private List<Vector4> isUvRotated = new List<Vector4>();

	private Vector3[] startVerts = new Vector3[0];

	private Color32[] startCol32 = new Color32[0];

	private Vector3[] midVerts = new Vector3[0];

	private Color32[] midCol32 = new Color32[0];

	private float timeDrawn;

	[Tooltip("Decides if the mesh will read out automatically when rebuilt.")]
	public bool autoRead = true;

	[Tooltip("Decides if the mesh will remember where it was if disabled/enabled while reading.")]
	public bool rememberReadPosition = true;

	[Tooltip("For UI text. If true, quality is automatically set to be the same as size.")]
	public bool autoQuality;

	[Tooltip("What order the text will draw in. 'All At Once' will ignore read delay. 'Robot' displays one word at a time. If set to 'Random', Read Delay becomes the time it'll take to draw the whole mesh.")]
	public DrawOrder drawOrder;

	private bool callReadFunction;

	private int pauseCount;

	private int currentPauseCount;

	private float autoPauseStopPoint;

	private List<KeyValuePair<int, string>> allTags = new List<KeyValuePair<int, string>>();

	private List<Font> allFonts = new List<Font>();

	private char[] linebreakFriendlyChars = new char[7] { ' ', '\n', '\t', '-', '\u00ad', '\u200a', '\u200b' };

	[Tooltip("Adjusts paragraphs for text that was input right-to-left.")]
	public bool rtl;

	public BestFitMode bestFit;

	private bool applicationFocused = true;

	private bool doEvents = true;

	private STMTextInfo UpdateMesh_info;

	private bool wasReadingBefore;

	public int latestNumber = -1;

	public float currentUnReadTime;

	private STMTextInfo DoEvent_info;

	private STMTextInfo PlaySound_info;

	public string preParsedText = "";

	private STMTextInfo ParseText_info = new STMTextInfo();

	private STMTextInfo RequestAllCharacters_info;

	private Font Limits_font;

	private CharacterInfo Limits_ch;

	private STMTextInfo Limits_info;

	private float BestFit_vertLimit;

	private int[] allLinebreakIndexes;

	private Vector3 Rebuild_pos = Vector3.zero;

	private Font Rebuild_font;

	private CharacterInfo Rebuild_ch;

	private CharacterInfo Rebuild_hyphenCh;

	private CharacterInfo Rebuild_breakCh;

	private float Rebuild_autoWrap;

	private int infoCount;

	private STMTextInfo Rebuild_info;

	private Vector3 offset = Vector3.zero;

	private Vector3 uiOffset = Vector3.zero;

	private float OffsetData_VerticalLimit;

	private int OffsetData_rowStart;

	private float OffsetData_offsetRight;

	private int OffsetData_spaceCount;

	private float OffsetData_maxHeight;

	private float OffsetData_maxWidth;

	private Vector3 anchorOffset = Vector3.zero;

	private Vector3 RecalculateBounds_point;

	private Vector3 TextBounds_leftOffset = Vector3.zero;

	private Vector3 TextBounds_rightOffset = Vector3.zero;

	private float TextBounds_diff;

	private float RecalculateBounds_textBottom;

	private Transform RecalculateBounds_t;

	private int[] drawOrderRTL = new int[0];

	private int RTL_currentLine = -1;

	private int RTL_lastEnd = -1;

	private STMTextInfo Timing_textInfo;

	private Vector3 WavePosition_Vect = Vector3.zero;

	private Vector3 WaveRotation_Pivot = Vector3.zero;

	private Vector3 WaveRotation_Offset = Vector3.zero;

	private Vector3 WaveRotation_ReturnVal = Vector3.zero;

	private Vector3 WaveRotation_myRotation = Vector3.zero;

	private Quaternion WaveRotation_myQuaternion;

	private Vector3 JitterValue_MyJit = Vector3.zero;

	private Vector3 UpdateMesh_waveValue = Vector3.zero;

	private Vector3 UpdateMesh_waveValueTopLeft = Vector3.zero;

	private Vector3 UpdateMesh_waveValueTopRight = Vector3.zero;

	private Vector3 UpdateMesh_waveValueBottomRight = Vector3.zero;

	private Vector3 UpdateMesh_waveValueBottomLeft = Vector3.zero;

	private Vector3 UpdateMesh_lowestLineOffset = Vector3.zero;

	private Vector3 UpdateMesh_wavePosition;

	private Vector2 UpdateMesh_uvOffset;

	private STMTextInfo CurrentTextInfo;

	private Vector3[] UpdateMesh_Middles = new Vector3[0];

	private Vector3[] UpdateMesh_Positions = new Vector3[0];

	private Vector3 cacheVectThree;

	private Vector3 jitterValue;

	private Vector2 vectA;

	private Vector2 vectAA;

	private Vector2 vectB;

	private Vector2 vectBB;

	private Vector2 vectC;

	private Vector2 vectCC;

	private Vector2 vectD;

	private Vector2 vectDD;

	private Vector2 infoVect;

	private Vector2 ratioHold;

	private Vector2 uvMidHold;

	private Vector4 ratioAndUvHold;

	private bool doPrintEventAfter;

	private bool doEventAfter;

	private float tmpRawBottomRightBounds;

	private Vector3 realBaseOffset = Vector3.zero;

	private Canvas parentCanvas;

	private List<SubmeshData> submeshes = new List<SubmeshData>();

	private Material[] submeshMaterials = new Material[1];

	private SharedMaterialData Submesh_sharedMaterial;

	private SubmeshData Submesh_submeshData;

	private STMTextInfo Submesh_info;

	public SuperTextMeshData data
	{
		get
		{
			if (_data == null)
			{
				_data = Resources.Load("SuperTextMeshData") as SuperTextMeshData;
				_data.RebuildDictionaries();
			}
			return _data;
		}
		set
		{
			_data = value;
		}
	}

	public Transform t
	{
		get
		{
			if (_t == null)
			{
				_t = base.transform;
			}
			return _t;
		}
	}

	public MeshFilter f
	{
		get
		{
			if (_f == null)
			{
				_f = t.GetComponent<MeshFilter>();
			}
			if (_f == null)
			{
				_f = t.gameObject.AddComponent<MeshFilter>();
			}
			return _f;
		}
	}

	public MeshRenderer r
	{
		get
		{
			if (_r == null)
			{
				_r = t.GetComponent<MeshRenderer>();
			}
			if (_r == null)
			{
				_r = t.gameObject.AddComponent<MeshRenderer>();
			}
			return _r;
		}
	}

	public CanvasRenderer c
	{
		get
		{
			if (_c == null)
			{
				_c = t.GetComponent<CanvasRenderer>();
			}
			if (_c == null)
			{
				_c = t.gameObject.AddComponent<CanvasRenderer>();
			}
			return _c;
		}
	}

	public bool uiMode => t is RectTransform;

	public string text
	{
		get
		{
			return _text;
		}
		set
		{
			_text = value ?? "";
			if (t.gameObject.activeInHierarchy)
			{
				Rebuild();
			}
		}
	}

	public string Text
	{
		get
		{
			return _text;
		}
		set
		{
			_text = value ?? "";
			if (t.gameObject.activeInHierarchy)
			{
				Rebuild();
			}
		}
	}

	public float GetDeltaTime
	{
		get
		{
			if (!data.disableAnimatedText && !disableAnimatedText && applicationFocused)
			{
				if (!ignoreTimeScale)
				{
					return Time.deltaTime;
				}
				return Time.unscaledDeltaTime;
			}
			return 0f;
		}
	}

	public float GetTime
	{
		get
		{
			if (!data.disableAnimatedText && !disableAnimatedText && applicationFocused)
			{
				if (!ignoreTimeScale)
				{
					return Time.time;
				}
				return Time.unscaledTime;
			}
			return 0f;
		}
	}

	public float GetDeltaTime2
	{
		get
		{
			if (applicationFocused)
			{
				if (!ignoreTimeScale)
				{
					return Time.deltaTime;
				}
				return Time.unscaledDeltaTime;
			}
			return 0f;
		}
	}

	public float AutoWrap
	{
		get
		{
			if (uiMode && uiWrap)
			{
				return tr.rect.width;
			}
			if (uiMode && !uiWrap)
			{
				return 0f;
			}
			return autoWrap;
		}
	}

	public RectTransform tr => t as RectTransform;

	private float VerticalLimit
	{
		get
		{
			if (uiMode && uiLimit)
			{
				return tr.rect.height;
			}
			if (uiMode && !uiLimit)
			{
				return 0f;
			}
			return verticalLimit;
		}
	}

	private STMDrawAnimData UndrawAnim
	{
		get
		{
			if (data.drawAnims.ContainsKey(undrawAnimName))
			{
				return data.drawAnims[undrawAnimName];
			}
			if (data.drawAnims.ContainsKey("Appear"))
			{
				return data.drawAnims["Appear"];
			}
			data = null;
			return null;
		}
	}

	public virtual float minWidth => 0f;

	public virtual float preferredWidth => unwrappedBottomRightTextBounds.x;

	public virtual float flexibleWidth => -1f;

	public virtual float minHeight => 0f;

	public virtual float preferredHeight => 0f - rawBottomRightTextBounds.y;

	public virtual float flexibleHeight => 0f - rawBottomRightTextBounds.y;

	public virtual int layoutPriority => 0;

	public event OnCompleteAction OnCompleteEvent;

	public event OnUndrawnAction OnUndrawnEvent;

	public event OnRebuildAction OnRebuildEvent;

	public event OnPrintAction OnPrintEvent;

	public event OnCustomAction OnCustomEvent;

	public event OnVertexModAction OnVertexMod;

	public event OnPreParseAction OnPreParse;

	private void OnApplicationFocus(bool focused)
	{
		if (!UnityEngine.Application.runInBackground)
		{
			applicationFocused = focused;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = data.boundsColor;
		RecalculateBounds();
		Gizmos.DrawLine(topLeftBounds, topRightBounds);
		Gizmos.DrawLine(topLeftBounds, bottomLeftBounds);
		Gizmos.DrawLine(topRightBounds, bottomRightBounds);
		Gizmos.DrawLine(bottomLeftBounds, bottomRightBounds);
		Gizmos.color = data.textBoundsColor;
		Gizmos.DrawLine(topLeftTextBounds, topRightTextBounds);
		Gizmos.DrawLine(topLeftTextBounds, bottomLeftTextBounds);
		Gizmos.DrawLine(topRightTextBounds, bottomRightTextBounds);
		Gizmos.DrawLine(bottomLeftTextBounds, bottomRightTextBounds);
		Gizmos.color = data.finalTextBoundsColor;
		Gizmos.DrawLine(finalTopLeftTextBounds, finalTopRightTextBounds);
		Gizmos.DrawLine(finalTopLeftTextBounds, finalBottomLeftTextBounds);
		Gizmos.DrawLine(finalTopRightTextBounds, finalBottomRightTextBounds);
		Gizmos.DrawLine(finalBottomLeftTextBounds, finalBottomRightTextBounds);
	}

	private void OnFontTextureRebuilt(Font changedFont)
	{
		if (textMesh != null && hyphenedText.Length > 0 && allFonts.Contains(changedFont))
		{
			Rebuild(currentReadTime, currentReadTime > 0f || autoRead);
		}
	}

	private void OnSceneLoaded(Scene scene, LoadSceneMode loadSceneMode)
	{
		if (this != null && t.gameObject.activeInHierarchy)
		{
			StartCoroutine(WaitFrameThenRebuild());
		}
	}

	private IEnumerator WaitFrameThenRebuild()
	{
		yield return null;
		Rebuild(currentReadTime, autoRead);
	}

	private void OnEnable()
	{
		Init();
		if (UnityEngine.Application.isPlaying)
		{
			if (callReadFunction && rememberReadPosition)
			{
				if (currentReadTime == 0f)
				{
					Rebuild(autoRead);
				}
				else if (currentReadTime >= totalReadTime)
				{
					Rebuild(currentReadTime, readAutomatically: true, executeEvents: false);
				}
				else
				{
					Rebuild(currentReadTime, autoRead);
				}
			}
			else
			{
				Rebuild(autoRead);
			}
		}
		else
		{
			Rebuild();
		}
	}

	private void Start()
	{
		textMesh = null;
		Rebuild(autoRead);
	}

	private void OnDisable()
	{
		UnInit();
		if (uiMode)
		{
			UnityEngine.Object.DestroyImmediate(textMesh);
			c.Clear();
		}
		else
		{
			UnityEngine.Object.DestroyImmediate(f.sharedMesh);
		}
	}

	private void OnDestroy()
	{
	}

	private void Init()
	{
		SceneManager.sceneLoaded += OnSceneLoaded;
		Font.textureRebuilt += OnFontTextureRebuilt;
	}

	private void UnInit()
	{
		SceneManager.sceneLoaded -= OnSceneLoaded;
		Font.textureRebuilt -= OnFontTextureRebuilt;
		StopReadRoutine();
	}

	private void OnUndoRedo()
	{
		Rebuild();
	}

	private void StopReadRoutine()
	{
		if (readRoutine != null)
		{
			StopCoroutine(readRoutine);
			reading = false;
		}
	}

	public void OnValidate()
	{
		if (font != null && !font.dynamic)
		{
			if (font.fontSize > 0)
			{
				quality = font.fontSize;
			}
			else
			{
				Debug.Log("You're probably using a custom font! \n Unity's got a bug where custom fonts have their size set to 0 by default and there's no way to change that! So to avoid this error, here's a solution: \n * Drag any font into Unity. Set it to be 'Unicode' or 'ASCII' in the inspector, depending on the characters you want your font to have. \n * Set 'Font Size' to whatever size you want 'quality' to be locked at. \n * Click the gear in the corner of the inspector and 'Create Editable Copy'. \n * Now, under the array of 'Character Rects', change size to 0 to clear everything. \n * Now you have a brand new font to edit that has a font size that's not zero! Yeah!");
			}
			style = FontStyle.Normal;
		}
		if (autoQuality)
		{
			quality = (int)Mathf.Ceil(size);
		}
		if (size < 0f)
		{
			size = 0f;
		}
		if (readDelay < 0f)
		{
			readDelay = 0f;
		}
		if (autoWrap < 0f)
		{
			autoWrap = 0f;
		}
		if (verticalLimit < 0f)
		{
			verticalLimit = 0f;
		}
		if (minPitch > maxPitch)
		{
			minPitch = maxPitch;
		}
		if (maxPitch < minPitch)
		{
			maxPitch = minPitch;
		}
		if (speedReadScale < 0.01f)
		{
			speedReadScale = 0.01f;
		}
	}

	public void InitializeFont()
	{
		if (uiMode)
		{
			if (font == null && textMaterial == null)
			{
				size = 32f;
				color = new Color32(50, 50, 50, byte.MaxValue);
			}
			if (textMaterial == null)
			{
				textMaterial = Resources.Load<Material>("DefaultSTMMaterials/UIDefault");
			}
			if (font == null)
			{
				if (data.defaultFont != null)
				{
					font = data.defaultFont;
				}
				else
				{
					font = Resources.GetBuiltinResource<Font>("Arial.ttf");
				}
			}
			return;
		}
		if (font == null)
		{
			if (data.defaultFont != null)
			{
				font = data.defaultFont;
			}
			else
			{
				font = Resources.GetBuiltinResource<Font>("Arial.ttf");
			}
		}
		if (textMaterial == null)
		{
			textMaterial = Resources.Load<Material>("DefaultSTMMaterials/Default");
		}
	}

	public static void RebuildAll()
	{
		SuperTextMesh[] array = UnityEngine.Object.FindObjectsOfType<SuperTextMesh>();
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array[i].Rebuild();
		}
	}

	public void Rebuild()
	{
		Rebuild(0f, readAutomatically: true);
	}

	public void Rebuild(bool readAutomatically)
	{
		Rebuild(0f, readAutomatically);
	}

	public void Rebuild(float startTime)
	{
		Rebuild(startTime, readAutomatically: true);
	}

	public void Rebuild(float startTime, bool readAutomatically)
	{
		Rebuild(startTime, readAutomatically, executeEvents: true);
	}

	public void Rebuild(float startTime, bool readAutomatically, bool executeEvents)
	{
		doEvents = executeEvents;
		if (uiMode)
		{
			Canvas.ForceUpdateCanvases();
		}
		if (onRebuildEvent != null && onRebuildEvent.GetPersistentEventCount() > 0)
		{
			onRebuildEvent.Invoke();
		}
		if (this.OnRebuildEvent != null)
		{
			this.OnRebuildEvent();
		}
		if (startTime < totalReadTime)
		{
			pauseCount = 0;
		}
		autoPauseStopPoint = 0f - VerticalLimit;
		currentPauseCount = 0;
		timeDrawn = ((GetTime - startTime < 0f) ? 0f : startTime);
		currentReadTime = startTime;
		totalReadTime = 0f;
		reading = false;
		unreading = false;
		speedReading = false;
		skippingToEnd = false;
		InitializeFont();
		RebuildTextInfo();
		if (audioSource != null)
		{
			audioSource.loop = false;
			audioSource.playOnAwake = false;
		}
		if (callReadFunction && UnityEngine.Application.isPlaying)
		{
			if (readAutomatically)
			{
				Read(startTime);
			}
			else
			{
				StopReadRoutine();
				SetMesh(0f);
			}
		}
		else
		{
			StopReadRoutine();
			ShowAllText(unreadingMesh: false, forceCompleteEvent: true);
		}
		ApplyMaterials();
		if (uiMode)
		{
			LayoutRebuilder.MarkLayoutForRebuild(tr);
		}
	}

	internal void Update()
	{
		if (font != null && textMaterial != null && textMesh != null)
		{
			if (!reading && areWeAnimating && currentReadTime >= totalReadTime)
			{
				currentReadTime += GetDeltaTime;
			}
			if (!reading && !unreading && areWeAnimating && (readDelay == 0f || currentReadTime >= totalReadTime))
			{
				SetMesh(-1f);
			}
		}
	}

	private void UpdatePreReadMesh(bool undrawingMesh)
	{
		UpdateMesh(0f);
		int num = hyphenedText.Length * 4;
		if (startCol32.Length != num)
		{
			Array.Resize(ref startCol32, num);
		}
		if (startVerts.Length != num)
		{
			Array.Resize(ref startVerts, num);
		}
		STMDrawAnimData undrawAnim = UndrawAnim;
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			UpdateMesh_info = info[i];
			STMDrawAnimData sTMDrawAnimData = (undrawingMesh ? undrawAnim : UpdateMesh_info.drawAnimData);
			if (UpdateMesh_info.drawAnimData.startColor != Color.clear)
			{
				startCol32[4 * i] = sTMDrawAnimData.startColor;
				startCol32[4 * i + 1] = sTMDrawAnimData.startColor;
				startCol32[4 * i + 2] = sTMDrawAnimData.startColor;
				startCol32[4 * i + 3] = sTMDrawAnimData.startColor;
			}
			else
			{
				startCol32[4 * i] = new Color32(endCol32[4 * i].r, endCol32[4 * i].g, endCol32[4 * i].b, 0);
				startCol32[4 * i + 1] = new Color32(endCol32[4 * i + 1].r, endCol32[4 * i + 1].g, endCol32[4 * i + 1].b, 0);
				startCol32[4 * i + 2] = new Color32(endCol32[4 * i + 2].r, endCol32[4 * i + 2].g, endCol32[4 * i + 2].b, 0);
				startCol32[4 * i + 3] = new Color32(endCol32[4 * i + 3].r, endCol32[4 * i + 3].g, endCol32[4 * i + 3].b, 0);
			}
			Vector3 vector = new Vector3((endVerts[4 * i].x + endVerts[4 * i + 1].x + endVerts[4 * i + 2].x + endVerts[4 * i + 3].x) * 0.25f, (endVerts[4 * i].y + endVerts[4 * i + 1].y + endVerts[4 * i + 2].y + endVerts[4 * i + 3].y) * 0.25f, (endVerts[4 * i].z + endVerts[4 * i + 1].z + endVerts[4 * i + 2].z + endVerts[4 * i + 3].z) * 0.25f);
			startVerts[4 * i] = Vector3.Scale(endVerts[4 * i] - vector, sTMDrawAnimData.startScale) + vector + sTMDrawAnimData.startOffset * UpdateMesh_info.size;
			startVerts[4 * i + 1] = Vector3.Scale(endVerts[4 * i + 1] - vector, sTMDrawAnimData.startScale) + vector + sTMDrawAnimData.startOffset * UpdateMesh_info.size;
			startVerts[4 * i + 2] = Vector3.Scale(endVerts[4 * i + 2] - vector, sTMDrawAnimData.startScale) + vector + sTMDrawAnimData.startOffset * UpdateMesh_info.size;
			startVerts[4 * i + 3] = Vector3.Scale(endVerts[4 * i + 3] - vector, sTMDrawAnimData.startScale) + vector + sTMDrawAnimData.startOffset * UpdateMesh_info.size;
		}
	}

	public void Read()
	{
		Read(0f);
	}

	public void Read(float startTime)
	{
		StopReadRoutine();
		readRoutine = StartCoroutine(ReadOutText(startTime));
	}

	public void Unread()
	{
		UnRead();
	}

	public void Undraw()
	{
		UnRead();
	}

	public void UnDraw()
	{
		UnRead();
	}

	public void UnRead()
	{
		readRoutine = StartCoroutine(UnReadOutText());
	}

	public void SpeedRead()
	{
		if (reading)
		{
			speedReading = true;
		}
	}

	public void SkipToEnd()
	{
		if (reading)
		{
			skippingToEnd = true;
		}
	}

	public void RegularRead()
	{
		speedReading = false;
	}

	public void ShowAllText()
	{
		ShowAllText(unreadingMesh: false, forceCompleteEvent: false);
	}

	private void ShowAllText(bool unreadingMesh, bool forceCompleteEvent)
	{
		speedReading = false;
		if (unreadingMesh)
		{
			unreading = false;
			if (currentUnReadTime < totalUnreadTime)
			{
				currentUnReadTime = totalUnreadTime;
			}
		}
		else if (currentReadTime < totalReadTime)
		{
			currentReadTime = totalReadTime;
		}
		wasReadingBefore = reading;
		SetMesh(unreadingMesh ? totalUnreadTime : totalReadTime, unreadingMesh);
		StopReadRoutine();
		if (!unreadingMesh)
		{
			if (wasReadingBefore || forceCompleteEvent)
			{
				if (onCompleteEvent != null)
				{
					onCompleteEvent.Invoke();
				}
				if (this.OnCompleteEvent != null)
				{
					this.OnCompleteEvent();
				}
			}
		}
		else
		{
			unreading = true;
			if (onUndrawnEvent != null)
			{
				onUndrawnEvent.Invoke();
			}
			if (this.OnUndrawnEvent != null)
			{
				this.OnUndrawnEvent();
			}
		}
	}

	public void Append(string newText)
	{
		_text += newText;
		Rebuild(totalReadTime, readAutomatically: true);
	}

	public bool Continue()
	{
		if (currentPauseCount > pauseCount)
		{
			pauseCount++;
			Rebuild(totalReadTime, readAutomatically: true);
			return true;
		}
		return false;
	}

	private void UpdateDrawnMesh(float myTime, bool undrawingMesh)
	{
		UpdateMesh(myTime);
		UpdatePreReadMesh(undrawingMesh);
		STMDrawAnimData undrawAnim = UndrawAnim;
		int num = hyphenedText.Length * 4;
		if (midVerts.Length != num)
		{
			Array.Resize(ref midVerts, num);
		}
		if (midCol32.Length != num)
		{
			Array.Resize(ref midCol32, num);
		}
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			UpdateMesh_info = info[i];
			STMDrawAnimData sTMDrawAnimData = (undrawingMesh ? undrawAnim : UpdateMesh_info.drawAnimData);
			float num2 = (undrawingMesh ? UpdateMesh_info.unreadTime : UpdateMesh_info.readTime);
			float num3 = ((sTMDrawAnimData.animTime == 0f) ? 1E-07f : sTMDrawAnimData.animTime);
			float num4 = ((sTMDrawAnimData.fadeTime == 0f) ? 1E-07f : sTMDrawAnimData.fadeTime);
			float num5 = (myTime - num2) / num3;
			float num6 = (myTime - num2) / num4;
			if (undrawingMesh)
			{
				num5 = 1f - num5;
				num6 = ((sTMDrawAnimData.fadeTime != 0f) ? (1f - num6) : 1f);
			}
			midVerts[4 * i] = LerpWithoutClamp(startVerts[4 * i], endVerts[4 * i], sTMDrawAnimData.animCurve.Evaluate(num5));
			midVerts[4 * i + 1] = LerpWithoutClamp(startVerts[4 * i + 1], endVerts[4 * i + 1], sTMDrawAnimData.animCurve.Evaluate(num5));
			midVerts[4 * i + 2] = LerpWithoutClamp(startVerts[4 * i + 2], endVerts[4 * i + 2], sTMDrawAnimData.animCurve.Evaluate(num5));
			midVerts[4 * i + 3] = LerpWithoutClamp(startVerts[4 * i + 3], endVerts[4 * i + 3], sTMDrawAnimData.animCurve.Evaluate(num5));
			midCol32[4 * i] = Color.Lerp(startCol32[4 * i], endCol32[4 * i], sTMDrawAnimData.fadeCurve.Evaluate(num6));
			midCol32[4 * i + 1] = Color.Lerp(startCol32[4 * i + 1], endCol32[4 * i + 1], sTMDrawAnimData.fadeCurve.Evaluate(num6));
			midCol32[4 * i + 2] = Color.Lerp(startCol32[4 * i + 2], endCol32[4 * i + 2], sTMDrawAnimData.fadeCurve.Evaluate(num6));
			midCol32[4 * i + 3] = Color.Lerp(startCol32[4 * i + 3], endCol32[4 * i + 3], sTMDrawAnimData.fadeCurve.Evaluate(num6));
		}
	}

	private Vector3 LerpWithoutClamp(Vector3 A, Vector3 B, float t)
	{
		return A + (B - A) * t;
	}

	private bool AreColorsTheSame(Color32 col1, Color32 col2)
	{
		if (col1.r == col2.r && col1.g == col2.g && col1.b == col2.b && col1.a == col2.a)
		{
			return true;
		}
		return false;
	}

	private IEnumerator ReadOutText(float startTime)
	{
		reading = true;
		currentReadTime = startTime;
		if (startTime.Equals(0f))
		{
			latestNumber = -1;
			lowestDrawnPosition = 0f;
			lowestDrawnPositionRaw = 0f;
			furthestDrawnPosition = 0f;
		}
		while (currentReadTime < totalReadTime)
		{
			if (skippingToEnd)
			{
				currentReadTime = totalReadTime;
			}
			SetMesh(currentReadTime);
			float getDeltaTime = GetDeltaTime2;
			getDeltaTime *= (speedReading ? speedReadScale : 1f);
			currentReadTime += getDeltaTime;
			yield return null;
		}
		if (latestNumber != hyphenedText.Length - 1)
		{
			PlaySound(hyphenedText.Length - 1);
			DoEvent(hyphenedText.Length - 1);
		}
		ShowAllText();
	}

	private IEnumerator UnReadOutText()
	{
		unreading = true;
		currentUnReadTime = 0f;
		while (currentUnReadTime < totalUnreadTime)
		{
			SetMesh(currentUnReadTime, undrawingMesh: true);
			currentUnReadTime += GetDeltaTime2;
			yield return null;
		}
		ShowAllText(unreadingMesh: true, forceCompleteEvent: false);
	}

	private void DoEvent(int i)
	{
		if (!doEvents)
		{
			return;
		}
		DoEvent_info = info[i];
		if (DoEvent_info.ev.Count > 0)
		{
			int j = 0;
			for (int count = DoEvent_info.ev.Count; j < count; j++)
			{
				if (onCustomEvent != null)
				{
					onCustomEvent.Invoke(DoEvent_info.ev[j], DoEvent_info);
				}
				if (this.OnCustomEvent != null)
				{
					this.OnCustomEvent(DoEvent_info.ev[j], DoEvent_info);
				}
			}
			DoEvent_info.ev.Clear();
		}
		if (DoEvent_info.ev2.Count <= 0)
		{
			return;
		}
		int k = 0;
		for (int count2 = DoEvent_info.ev2.Count; k < count2; k++)
		{
			if (onCustomEvent != null)
			{
				onCustomEvent.Invoke(DoEvent_info.ev2[k], DoEvent_info);
			}
			if (this.OnCustomEvent != null)
			{
				this.OnCustomEvent(DoEvent_info.ev2[k], DoEvent_info);
			}
		}
		DoEvent_info.ev2.Clear();
	}

	private string SpecialKeyToName(char ch)
	{
		return ch switch
		{
			' ' => "space", 
			'\t' => "tab", 
			'\n' => "line break", 
			'!' => "exclamation point", 
			'?' => "question mark", 
			';' => "semicolon", 
			':' => "colon", 
			'~' => "tilde", 
			'.' => "period", 
			',' => "comma", 
			'#' => "number sign", 
			'%' => "percent", 
			'&' => "ampersand", 
			'*' => "asterix", 
			'\\' => "backslash", 
			'/' => "forwardslash", 
			'{' => "openbrace", 
			'}' => "closebrace", 
			_ => new string(ch, 1).ToLower(), 
		};
	}

	public virtual void PlaySound(int i)
	{
		if (!(audioSource != null))
		{
			return;
		}
		PlaySound_info = info[i];
		if (!PlaySound_info.stopPreviousSound && audioSource.isPlaying)
		{
			return;
		}
		audioSource.Stop();
		string nameToSearch = (PlaySound_info.isQuad ? PlaySound_info.quadData.name : SpecialKeyToName(hyphenedText[i]));
		AudioClip audioClip = null;
		if (PlaySound_info.soundClipData != null)
		{
			STMSoundClipData.AutoClip autoClip = PlaySound_info.soundClipData.clips.Find((STMSoundClipData.AutoClip x) => x.name.ToLower() == nameToSearch);
			if (autoClip != null)
			{
				audioClip = autoClip.clip;
			}
		}
		STMAutoClipData sTMAutoClipData = null;
		if (data.autoClips.ContainsKey(nameToSearch.ToUpper()))
		{
			sTMAutoClipData = data.autoClips[nameToSearch.ToUpper()];
		}
		else if (data.autoClips.ContainsKey(nameToSearch))
		{
			sTMAutoClipData = data.autoClips[nameToSearch];
		}
		if (audioClip != null)
		{
			audioSource.clip = audioClip;
		}
		else if (sTMAutoClipData != null)
		{
			audioSource.clip = sTMAutoClipData.clip;
		}
		else if (PlaySound_info.audioClipData != null)
		{
			audioSource.clip = ((PlaySound_info.audioClipData.clips.Length != 0) ? PlaySound_info.audioClipData.clips[UnityEngine.Random.Range(0, PlaySound_info.audioClipData.clips.Length)] : null);
		}
		else if (audioClips.Length != 0)
		{
			audioSource.clip = ((audioClips.Length != 0) ? audioClips[UnityEngine.Random.Range(0, audioClips.Length)] : null);
		}
		else
		{
			audioSource.clip = null;
		}
		if (audioSource.clip != null)
		{
			switch (PlaySound_info.pitchMode)
			{
			case PitchMode.Perlin:
				audioSource.pitch = Mathf.PerlinNoise(GetTime * perlinPitchMulti, 0f) * (PlaySound_info.maxPitch - PlaySound_info.minPitch) + PlaySound_info.minPitch;
				break;
			case PitchMode.Random:
				audioSource.pitch = UnityEngine.Random.Range(PlaySound_info.minPitch, PlaySound_info.maxPitch);
				break;
			case PitchMode.Single:
				audioSource.pitch = PlaySound_info.overridePitch;
				break;
			default:
				audioSource.pitch = 1f;
				break;
			}
			if (speedReading)
			{
				audioSource.pitch += PlaySound_info.speedReadPitch;
			}
			audioSource.Play();
		}
	}

	private FontStyle AddStyle(FontStyle original, FontStyle newStyle)
	{
		if (font.dynamic)
		{
			switch (original)
			{
			case FontStyle.Bold:
				if (newStyle == FontStyle.Italic)
				{
					return FontStyle.BoldAndItalic;
				}
				return original;
			case FontStyle.Italic:
				if (newStyle == FontStyle.Bold)
				{
					return FontStyle.BoldAndItalic;
				}
				return original;
			case FontStyle.BoldAndItalic:
				return original;
			default:
				return newStyle;
			}
		}
		return FontStyle.Normal;
	}

	private FontStyle SubtractStyle(FontStyle original, FontStyle subStyle)
	{
		if (font.dynamic)
		{
			switch (original)
			{
			case FontStyle.Bold:
				if (subStyle == FontStyle.Bold)
				{
					return FontStyle.Normal;
				}
				return original;
			case FontStyle.Italic:
				if (subStyle == FontStyle.Italic)
				{
					return FontStyle.Normal;
				}
				return original;
			case FontStyle.BoldAndItalic:
				return subStyle switch
				{
					FontStyle.Bold => FontStyle.Italic, 
					FontStyle.Italic => FontStyle.Bold, 
					_ => original, 
				};
			default:
				return FontStyle.Normal;
			}
		}
		return FontStyle.Normal;
	}

	private bool ValidHexcode(string hex)
	{
		if (hex.Substring(0, 1) == "#")
		{
			hex = hex.Substring(1, hex.Length - 1);
		}
		if (hex.Length != 3 && hex.Length != 4 && hex.Length != 6 && hex.Length != 8)
		{
			return false;
		}
		string text = "0123456789ABCDEFabcdef";
		for (int i = 0; i < hex.Length; i++)
		{
			if (!text.Contains(hex[i].ToString()))
			{
				return false;
			}
		}
		return true;
	}

	private Color32 HexToColor(string hex)
	{
		if (hex.Substring(0, 1) == "#")
		{
			hex = hex.Substring(1, hex.Length - 1);
		}
		if (hex.Length == 8)
		{
			byte num = byte.Parse(hex.Substring(0, 2), NumberStyles.HexNumber);
			byte g = byte.Parse(hex.Substring(2, 2), NumberStyles.HexNumber);
			byte b = byte.Parse(hex.Substring(4, 2), NumberStyles.HexNumber);
			byte a = byte.Parse(hex.Substring(6, 2), NumberStyles.HexNumber);
			return new Color32(num, g, b, a);
		}
		if (hex.Length == 4)
		{
			byte num2 = byte.Parse(hex.Substring(0, 1) + hex.Substring(0, 1), NumberStyles.HexNumber);
			byte g2 = byte.Parse(hex.Substring(1, 1) + hex.Substring(1, 1), NumberStyles.HexNumber);
			byte b2 = byte.Parse(hex.Substring(2, 1) + hex.Substring(2, 1), NumberStyles.HexNumber);
			byte a2 = byte.Parse(hex.Substring(3, 1) + hex.Substring(3, 1), NumberStyles.HexNumber);
			return new Color32(num2, g2, b2, a2);
		}
		if (hex.Length == 3)
		{
			byte num3 = byte.Parse(hex.Substring(0, 1) + hex.Substring(0, 1), NumberStyles.HexNumber);
			byte g3 = byte.Parse(hex.Substring(1, 1) + hex.Substring(1, 1), NumberStyles.HexNumber);
			byte b3 = byte.Parse(hex.Substring(2, 1) + hex.Substring(2, 1), NumberStyles.HexNumber);
			return new Color32(num3, g3, b3, byte.MaxValue);
		}
		byte num4 = byte.Parse(hex.Substring(0, 2), NumberStyles.HexNumber);
		byte g4 = byte.Parse(hex.Substring(2, 2), NumberStyles.HexNumber);
		byte b4 = byte.Parse(hex.Substring(4, 2), NumberStyles.HexNumber);
		return new Color32(num4, g4, b4, byte.MaxValue);
	}

	private STMColorData GetColor(string myCol)
	{
		if (data.colors.ContainsKey(myCol))
		{
			return data.colors[myCol];
		}
		if (ValidHexcode(myCol))
		{
			STMColorData sTMColorData = ScriptableObject.CreateInstance<STMColorData>();
			sTMColorData.color = HexToColor(myCol);
			return sTMColorData;
		}
		STMColorData sTMColorData2 = ScriptableObject.CreateInstance<STMColorData>();
		switch (myCol)
		{
		case "red":
			sTMColorData2.color = Color.red;
			break;
		case "green":
			sTMColorData2.color = Color.green;
			break;
		case "blue":
			sTMColorData2.color = Color.blue;
			break;
		case "yellow":
			sTMColorData2.color = Color.yellow;
			break;
		case "cyan":
			sTMColorData2.color = Color.cyan;
			break;
		case "magenta":
			sTMColorData2.color = Color.magenta;
			break;
		case "grey":
			sTMColorData2.color = Color.grey;
			break;
		case "gray":
			sTMColorData2.color = Color.gray;
			break;
		case "black":
			sTMColorData2.color = Color.black;
			break;
		case "clear":
			sTMColorData2.color = Color.clear;
			break;
		case "white":
			sTMColorData2.color = Color.white;
			break;
		default:
			sTMColorData2.color = color;
			break;
		}
		return sTMColorData2;
	}

	private string FlipParagraphs(string myText, bool flipInfo)
	{
		string[] array = myText.Split('\n');
		List<List<List<STMTextInfo>>> list = new List<List<List<STMTextInfo>>>();
		int num = 0;
		List<STMTextInfo> list2 = new List<STMTextInfo>();
		List<STMTextInfo> list3 = new List<STMTextInfo>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = string.Join(" ", array[i].Split(' ').Reverse().ToArray());
			if (!flipInfo)
			{
				continue;
			}
			list.Add(new List<List<STMTextInfo>>());
			for (int j = 0; j < array[i].Length; j++)
			{
				if (num == 0 || array[i][j] == ' ')
				{
					list2 = new List<STMTextInfo>();
					list[i].Add(list2);
				}
				list2.Add(info[num]);
				num++;
			}
			if (info.Count > num)
			{
				list2.Add(info[num]);
				num++;
			}
		}
		if (flipInfo)
		{
			for (int k = 0; k < list.Count; k++)
			{
				for (int l = 0; l < list[k].Count; l++)
				{
					for (int m = 0; m < list[k][l].Count; m++)
					{
						list3.Add(list[k][l][m]);
					}
				}
			}
			info = list3;
		}
		return string.Join("\n", array);
	}

	private string ParseText(string myText)
	{
		info.Clear();
		preParsedText = myText;
		if ((onPreParse != null && onPreParse.GetPersistentEventCount() > 0) || this.OnPreParse != null)
		{
			STMTextContainer sTMTextContainer = new STMTextContainer(myText);
			if (onPreParse != null)
			{
				onPreParse.Invoke(sTMTextContainer);
			}
			if (this.OnPreParse != null)
			{
				this.OnPreParse(sTMTextContainer);
			}
			myText = sTMTextContainer.text;
			preParsedText = sTMTextContainer.text;
		}
		if (rtl)
		{
			myText = FlipParagraphs(myText, flipInfo: false);
		}
		ParseText_info.SetValues(this);
		allTags.Clear();
		int num = 0;
		string text = "";
		infoCount = 0;
		for (int i = 0; i < myText.Length; i++)
		{
			if (readDelay > 0f && infoCount == i && i > 0)
			{
				if (info[i - 1].isQuad)
				{
					if (data.autoDelays.ContainsKey(info[i - 1].quadData.name))
					{
						ParseText_info.delayData = data.autoDelays[info[i - 1].quadData.name];
					}
				}
				else if (data.autoDelays.ContainsKey(SpecialKeyToName(myText[i - 1])) && (myText[i] == ' ' || myText[i] == '\n' || myText[i] == '\t' || (myText.Length - i > 4 && myText.Substring(i, 4) == "<br>")))
				{
					ParseText_info.delayData = data.autoDelays[SpecialKeyToName(myText[i - 1])];
				}
			}
			bool flag = false;
			if (richText && myText[i] == '<')
			{
				int num2 = myText.IndexOf(">", i);
				int num3 = ((num2 > -1) ? myText.IndexOf("=", i, num2 - i) : (-1));
				int num4 = ((num3 > -1 && num2 > -1) ? Mathf.Min(num3, num2) : num2);
				if (num2 != -1)
				{
					string text2 = myText.Substring(i, num4 - i + 1);
					string text3 = ((num3 > -1) ? myText.Substring(num3 + 1, num2 - num3 - 1) : "");
					bool flag2 = true;
					bool flag3 = false;
					text = "";
					switch (text2)
					{
					case "<br>":
						text = '\n'.ToString();
						break;
					case "<c=":
						ParseText_info.colorData = null;
						ParseText_info.gradientData = null;
						ParseText_info.textureData = null;
						if (data.textures.ContainsKey(text3))
						{
							ParseText_info.textureData = data.textures[text3];
							ParseText_info.submeshChange = true;
						}
						else if (data.gradients.ContainsKey(text3))
						{
							ParseText_info.gradientData = data.gradients[text3];
						}
						else
						{
							ParseText_info.colorData = GetColor(text3);
						}
						break;
					case "</c>":
						ParseText_info.colorData = null;
						ParseText_info.gradientData = null;
						if (ParseText_info.textureData != null)
						{
							ParseText_info.submeshChange = true;
						}
						ParseText_info.textureData = null;
						break;
					case "<s=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result9))
						{
							ParseText_info.size = result9 * size;
						}
						break;
					}
					case "<size=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result3))
						{
							ParseText_info.size = result3;
						}
						break;
					}
					case "</s>":
					case "</size>":
						ParseText_info.size = size;
						break;
					case "<d=":
					{
						int result4;
						if (data.delays.ContainsKey(text3))
						{
							ParseText_info.delayData = data.delays[text3];
						}
						else if (int.TryParse(text3, out result4))
						{
							ParseText_info.delayData = ScriptableObject.CreateInstance<STMDelayData>();
							ParseText_info.delayData.count = result4;
						}
						break;
					}
					case "<d>":
						if (data.delays.ContainsKey("default"))
						{
							ParseText_info.delayData = data.delays["default"];
						}
						else
						{
							Debug.Log("Default delay isn't defined!");
						}
						break;
					case "<t=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result14))
						{
							if (result14 < 0f)
							{
								result14 = 0f;
							}
							ParseText_info.readTime = result14;
						}
						break;
					}
					case "<e=":
						ParseText_info.ev.Add(text3);
						break;
					case "<e2=":
						ParseText_info.ev2.Add(text3);
						break;
					case "</e>":
					case "</e2>":
						ParseText_info.ev2.Clear();
						break;
					case "<v=":
						if (data.voices.ContainsKey(text3))
						{
							text = data.voices[text3].text;
						}
						break;
					case "</v>":
						ParseText_info = new STMTextInfo(this);
						break;
					case "<f=":
					case "<font=":
						if (data.fonts.ContainsKey(text3))
						{
							ParseText_info.fontData = data.fonts[text3];
						}
						else
						{
							Debug.Log("Unknown font: '" + text3 + "'. Fonts can be defined within the Text Data Inspector and are case-sensitive.");
						}
						ParseText_info.submeshChange = true;
						break;
					case "</f>":
					case "</font>":
						ParseText_info.fontData = null;
						ParseText_info.submeshChange = true;
						break;
					case "<q=":
					case "<quad=":
					{
						string[] array = text3.Split(',');
						if (data.quads.ContainsKey(array[0]) && ParseText_info.quadData == null)
						{
							int result6;
							int result7;
							if (array.Length == 1)
							{
								ParseText_info.quadData = data.quads[text3];
								ParseText_info.isQuad = true;
								text = "\u2000";
							}
							else if (array.Length == 2)
							{
								if (int.TryParse(array[1], out var result5))
								{
									ParseText_info.quadData = data.quads[array[0]];
									ParseText_info.isQuad = true;
									ParseText_info.quadIndex = result5;
									text = "\u2000";
								}
							}
							else if (array.Length == 3 && int.TryParse(array[1], out result6) && int.TryParse(array[2], out result7))
							{
								ParseText_info.quadData = data.quads[array[0]];
								ParseText_info.isQuad = true;
								ParseText_info.quadIndex = ParseText_info.quadData.columns * result6 + result7;
								text = "\u2000";
							}
						}
						ParseText_info.submeshChange = true;
						break;
					}
					case "<m=":
					case "<material=":
						if (data.materials.ContainsKey(text3))
						{
							ParseText_info.materialData = data.materials[text3];
						}
						ParseText_info.submeshChange = true;
						break;
					case "</m>":
					case "</material>":
						ParseText_info.materialData = null;
						ParseText_info.submeshChange = true;
						break;
					case "<b>":
						ParseText_info.ch.style = AddStyle(ParseText_info.ch.style, FontStyle.Bold);
						break;
					case "</b>":
						ParseText_info.ch.style = SubtractStyle(ParseText_info.ch.style, FontStyle.Bold);
						break;
					case "<i>":
						ParseText_info.ch.style = AddStyle(ParseText_info.ch.style, FontStyle.Italic);
						break;
					case "</i>":
						ParseText_info.ch.style = SubtractStyle(ParseText_info.ch.style, FontStyle.Italic);
						break;
					case "<w=":
						if (data.waves.ContainsKey(text3))
						{
							ParseText_info.waveData = data.waves[text3];
						}
						break;
					case "<w>":
						if (data.waves.ContainsKey("default"))
						{
							ParseText_info.waveData = data.waves["default"];
						}
						break;
					case "</w>":
						ParseText_info.waveData = null;
						break;
					case "<j=":
						if (data.jitters.ContainsKey(text3))
						{
							ParseText_info.jitterData = data.jitters[text3];
						}
						break;
					case "<j>":
						if (data.jitters.ContainsKey("default"))
						{
							ParseText_info.jitterData = data.jitters["default"];
						}
						else
						{
							Debug.Log("Default jitter isn't defined!");
						}
						break;
					case "</j>":
						ParseText_info.jitterData = null;
						break;
					case "<a=":
						switch (text3.ToLower())
						{
						case "left":
							ParseText_info.alignment = Alignment.Left;
							break;
						case "right":
							ParseText_info.alignment = Alignment.Right;
							break;
						case "center":
						case "centre":
							ParseText_info.alignment = Alignment.Center;
							break;
						case "just":
						case "justify":
						case "justified":
							ParseText_info.alignment = Alignment.Justified;
							break;
						case "just2":
						case "justify2":
						case "justified2":
							ParseText_info.alignment = Alignment.ForceJustified;
							break;
						}
						break;
					case "</a>":
						ParseText_info.alignment = alignment;
						break;
					case "<stopPreviousSound=":
					{
						string text4 = text3.ToLower();
						if (!(text4 == "true"))
						{
							if (text4 == "false")
							{
								ParseText_info.stopPreviousSound = false;
							}
						}
						else
						{
							ParseText_info.stopPreviousSound = true;
						}
						break;
					}
					case "</stopPreviousSound>":
						ParseText_info.stopPreviousSound = stopPreviousSound;
						break;
					case "<pitchMode=":
						switch (text3.ToLower())
						{
						case "normal":
							ParseText_info.pitchMode = PitchMode.Normal;
							break;
						case "single":
							ParseText_info.pitchMode = PitchMode.Single;
							break;
						case "random":
							ParseText_info.pitchMode = PitchMode.Random;
							break;
						case "perlin":
							ParseText_info.pitchMode = PitchMode.Perlin;
							break;
						}
						break;
					case "</pitchMode>":
						ParseText_info.pitchMode = pitchMode;
						break;
					case "<overridePitch=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result13))
						{
							ParseText_info.overridePitch = result13;
						}
						break;
					}
					case "</overridePitch>":
						ParseText_info.overridePitch = overridePitch;
						break;
					case "<minPitch=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result12))
						{
							ParseText_info.minPitch = result12;
						}
						break;
					}
					case "</minPitch>":
						ParseText_info.minPitch = minPitch;
						break;
					case "<maxPitch=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result11))
						{
							ParseText_info.maxPitch = result11;
						}
						break;
					}
					case "</maxPitch>":
						ParseText_info.maxPitch = maxPitch;
						break;
					case "<speedReadPitch=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result10))
						{
							ParseText_info.speedReadPitch = result10;
						}
						break;
					}
					case "</speedReadPitch>":
						ParseText_info.speedReadPitch = speedReadPitch;
						break;
					case "<readDelay=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result8))
						{
							ParseText_info.readDelay = result8;
						}
						break;
					}
					case "</readDelay>":
						ParseText_info.readDelay = readDelay;
						break;
					case "<drawAnim=":
						if (data.drawAnims.ContainsKey(text3))
						{
							ParseText_info.drawAnimData = data.drawAnims[text3];
						}
						else if (data.drawAnims.ContainsKey("Appear"))
						{
							ParseText_info.drawAnimData = data.drawAnims["Appear"];
						}
						else
						{
							Debug.Log("'Appear' draw animation isn't defined!");
						}
						break;
					case "</drawAnim>":
						if (data.drawAnims.ContainsKey(drawAnimName))
						{
							ParseText_info.drawAnimData = data.drawAnims[drawAnimName];
						}
						else if (data.drawAnims.ContainsKey("Appear"))
						{
							ParseText_info.drawAnimData = data.drawAnims["Appear"];
						}
						else
						{
							Debug.Log("'Appear' draw animation isn't defined!");
						}
						break;
					case "<drawOrder=":
						switch (text3.ToLower())
						{
						case "lefttoright":
						case "ltr":
							ParseText_info.drawOrder = DrawOrder.LeftToRight;
							break;
						case "allatonce":
						case "all":
							ParseText_info.drawOrder = DrawOrder.AllAtOnce;
							break;
						case "onewordatatime":
						case "robot":
							ParseText_info.drawOrder = DrawOrder.OneWordAtATime;
							break;
						case "random":
							ParseText_info.drawOrder = DrawOrder.Random;
							break;
						case "righttoleft":
						case "rtl":
							ParseText_info.drawOrder = DrawOrder.RightToLeft;
							break;
						case "reverseltr":
							ParseText_info.drawOrder = DrawOrder.ReverseLTR;
							break;
						case "rtlonewordatatime":
						case "rtlrobot":
							ParseText_info.drawOrder = DrawOrder.RTLOneWordAtATime;
							break;
						case "onelineatatime":
						case "computer":
							ParseText_info.drawOrder = DrawOrder.OneLineAtATime;
							break;
						}
						break;
					case "</drawOrder>":
						ParseText_info.drawOrder = drawOrder;
						break;
					case "<clips=":
						if (data.soundClips.ContainsKey(text3))
						{
							ParseText_info.soundClipData = data.soundClips[text3];
						}
						break;
					case "</clips>":
						ParseText_info.soundClipData = null;
						break;
					case "<audioClips=":
						if (data.audioClips.ContainsKey(text3))
						{
							ParseText_info.audioClipData = data.audioClips[text3];
						}
						break;
					case "</audioClips>":
						ParseText_info.audioClipData = null;
						break;
					case "<indent=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result2))
						{
							ParseText_info.indent = result2;
						}
						break;
					}
					case "</indent>":
						ParseText_info.indent = 0f;
						break;
					case "<pause>":
						currentPauseCount++;
						if (UnityEngine.Application.isPlaying && currentPauseCount > pauseCount)
						{
							flag3 = true;
						}
						else if (UnityEngine.Application.isPlaying)
						{
							text = "\u200b";
						}
						break;
					case "<clear>":
						ParseText_info.colorData = null;
						ParseText_info.gradientData = null;
						ParseText_info.textureData = null;
						ParseText_info.size = size;
						ParseText_info.ev2.Clear();
						break;
					case "<y=":
					{
						if (float.TryParse(text3, NumberStyles.Any, CultureInfo.InvariantCulture, out var result))
						{
							ParseText_info.offset.y = result * ParseText_info.size;
						}
						break;
					}
					case "</y>":
						ParseText_info.offset.y = 0f;
						break;
					case "<sup>":
						ParseText_info.offset.y = data.superscriptOffset * ParseText_info.size;
						ParseText_info.size = data.superscriptSize * ParseText_info.size;
						break;
					case "</sup>":
						ParseText_info.offset.y = 0f;
						ParseText_info.size = size;
						break;
					case "<sub>":
						ParseText_info.offset.y = data.subscriptOffset * ParseText_info.size;
						ParseText_info.size = data.subscriptSize * ParseText_info.size;
						break;
					case "</sub>":
						ParseText_info.offset.y = 0f;
						ParseText_info.size = size;
						break;
					case "<u=":
						text = char.ConvertFromUtf32(int.Parse(text3, NumberStyles.HexNumber));
						break;
					default:
						flag2 = false;
						break;
					}
					if (flag2)
					{
						switch (text2)
						{
						default:
							allTags.Add(new KeyValuePair<int, string>(i, myText.Substring(i, num2 + 1 - i)));
							break;
						case "<br>":
						case "<d>":
						case "<d=":
						case "<t=":
						case "<e=":
						case "<q=":
						case "<pause>":
						case "<u=":
							break;
						}
						myText = myText.Remove(i, num2 + 1 - i);
						num += num2 + 1 - i;
						myText = myText.Insert(i, text);
						flag = true;
					}
					if (flag3)
					{
						myText = myText.Remove(i, myText.Length - i);
						break;
					}
				}
			}
			if (infoCount - 1 == i)
			{
				info[i] = new STMTextInfo(ParseText_info);
			}
			else
			{
				info.Add(new STMTextInfo(ParseText_info));
				infoCount++;
			}
			if (flag)
			{
				i--;
			}
			else
			{
				ParseText_info.delayData = null;
				ParseText_info.quadData = null;
				ParseText_info.ev.Clear();
				ParseText_info.readTime = -1f;
				ParseText_info.quadIndex = -1;
				if (ParseText_info.isQuad)
				{
					ParseText_info.submeshChange = true;
				}
				else
				{
					ParseText_info.submeshChange = false;
				}
				ParseText_info.isQuad = false;
			}
			ParseText_info.rawIndex = i + num;
		}
		if (infoCount > myText.Length)
		{
			myText += "\u200b";
		}
		return myText;
	}

	private int GetFontSize(Font myFont, STMTextInfo myInfo)
	{
		if (!myFont.dynamic && myFont.fontSize != 0)
		{
			return myFont.fontSize;
		}
		if (myInfo.fontData != null)
		{
			if (myInfo.fontData.overrideQuality)
			{
				return myInfo.fontData.quality;
			}
			return quality;
		}
		if (myInfo.ch.size != 0)
		{
			return myInfo.ch.size;
		}
		return quality;
	}

	private void RequestAllCharacters()
	{
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			RequestAllCharacters_info = info[i];
			Font font = ((RequestAllCharacters_info.fontData != null) ? RequestAllCharacters_info.fontData.font : this.font);
			font.RequestCharactersInTexture(hyphenedText[i].ToString(), GetFontSize(font, RequestAllCharacters_info), RequestAllCharacters_info.ch.style);
			font.RequestCharactersInTexture("-", GetFontSize(font, info[i]), FontStyle.Normal);
		}
	}

	private void FigureOutUnwrappedLimits(Vector3 pos)
	{
		unwrappedBottomRightTextBounds = Vector3.zero;
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			Limits_info = info[i];
			Limits_font = ((Limits_info.fontData != null) ? Limits_info.fontData.font : font);
			Limits_font.RequestCharactersInTexture(hyphenedText[i].ToString(), GetFontSize(Limits_font, Limits_info), Limits_info.ch.style);
			if (Limits_font.GetCharacterInfo(hyphenedText[i], out Limits_ch, GetFontSize(Limits_font, Limits_info), Limits_info.ch.style))
			{
				Limits_info.ch = Limits_ch;
				Limits_info.UpdateCachedValuesIfChanged();
				continue;
			}
			Limits_font = data.defaultFont;
			if (Limits_font.GetCharacterInfo(hyphenedText[i], out Limits_ch, GetFontSize(Limits_font, Limits_info), Limits_info.ch.style))
			{
				Limits_info.fontData = new STMFontData(data.defaultFont);
				Limits_info.ch = Limits_ch;
				Limits_info.UpdateCachedValuesIfChanged();
			}
		}
		int j = 0;
		for (int length2 = hyphenedText.Length; j < length2; j++)
		{
			Limits_info = info[j];
			Limits_font = ((Limits_info.fontData != null) ? Limits_info.fontData.font : font);
			float num = GetFontSize(Limits_font, Limits_info);
			if (hyphenedText[j] == '\n')
			{
				pos.x = Limits_info.indent;
				pos.y -= lineSpacing * Limits_info.size;
			}
			else if (hyphenedText[j] == '\t')
			{
				pos.x += num * 0.5f * tabSize * (Limits_info.size / num);
			}
			else
			{
				pos.x += Limits_info.Advance(characterSpacing, num).x;
			}
			unwrappedBottomRightTextBounds.x = Mathf.Max(unwrappedBottomRightTextBounds.x, pos.x);
			unwrappedBottomRightTextBounds.y = Mathf.Min(unwrappedBottomRightTextBounds.y, pos.y);
		}
	}

	private void CalculateBestFitMulti()
	{
		BestFit_vertLimit = VerticalLimit;
		bestFitMulti = 1f;
		if (bestFit != 0)
		{
			if (Rebuild_autoWrap > 0f)
			{
				bestFitMulti = AutoWrap / unwrappedBottomRightTextBounds.x * 0.99999f;
			}
			if (BestFit_vertLimit > 0f && 0f - unwrappedBottomRightTextBounds.y > BestFit_vertLimit / bestFitMulti)
			{
				bestFitMulti = (0f - BestFit_vertLimit) / unwrappedBottomRightTextBounds.y * 0.99999f;
			}
			if (bestFit == BestFitMode.OverLimit && bestFitMulti > 1f)
			{
				bestFitMulti = 1f;
			}
		}
	}

	private void CalculateLineHeights()
	{
		lineHeights.Clear();
		float num = ((infoCount > 0) ? info[0].size : size);
		int i = 0;
		for (int num2 = infoCount; i < num2; i++)
		{
			if (hyphenedText[i] == '\n')
			{
				lineHeights.Add(num);
				if (infoCount - 1 > i)
				{
					num = info[i + 1].size;
				}
			}
			else
			{
				num = Mathf.Max(num, info[i].size);
			}
		}
		lineHeights.Add(num);
	}

	private void RebuildTextInfo()
	{
		drawText = ParseText(text);
		lineBreaks.Clear();
		hyphenedText = string.Copy(drawText);
		CalculateLineHeights();
		Rebuild_pos.x = ((infoCount > 0) ? info[0].indent : 0f);
		Rebuild_pos.y = ((lineHeights.Count > 0) ? (0f - lineHeights[0]) : (0f - size));
		Rebuild_pos.z = 0f;
		if (bestFit != 0)
		{
			FigureOutUnwrappedLimits(Rebuild_pos);
		}
		else
		{
			unwrappedBottomRightTextBounds.x = 1f;
			unwrappedBottomRightTextBounds.y = 1f;
		}
		CalculateBestFitMulti();
		for (int i = 0; i < hyphenedText.Length; i++)
		{
			info[i].size *= bestFitMulti;
		}
		CalculateLineHeights();
		Rebuild_pos.x = ((infoCount > 0) ? info[0].indent : 0f);
		Rebuild_pos.y = ((lineHeights.Count > 0) ? (0f - lineHeights[0]) : size);
		totalWidth = 0f;
		allFonts.Clear();
		Rebuild_autoWrap = AutoWrap;
		if (Rebuild_autoWrap > 0f)
		{
			int j = 0;
			for (int length = hyphenedText.Length; j < length; j++)
			{
				Rebuild_info = info[j];
				Rebuild_font = ((Rebuild_info.fontData != null) ? Rebuild_info.fontData.font : font);
				Rebuild_font.RequestCharactersInTexture(hyphenedText[j].ToString(), GetFontSize(Rebuild_font, Rebuild_info), Rebuild_info.ch.style);
				if (Rebuild_font.GetCharacterInfo(hyphenedText[j], out Rebuild_ch, GetFontSize(Rebuild_font, Rebuild_info), Rebuild_info.ch.style))
				{
					Rebuild_info.ch = Rebuild_ch;
					Rebuild_info.UpdateCachedValuesIfChanged();
				}
				else
				{
					Rebuild_font = data.defaultFont;
					if (Rebuild_font.GetCharacterInfo(hyphenedText[j], out Rebuild_ch, GetFontSize(Rebuild_font, Rebuild_info), Rebuild_info.ch.style))
					{
						Rebuild_info.fontData = new STMFontData(data.defaultFont);
						Rebuild_info.ch = Rebuild_ch;
						Rebuild_info.UpdateCachedValuesIfChanged();
					}
				}
				if (!allFonts.Contains(Rebuild_font))
				{
					allFonts.Add(Rebuild_font);
				}
			}
			float num = ((infoCount > 0) ? info[0].indent : 0f);
			int num2 = -1;
			for (int k = 0; k < infoCount; k++)
			{
				Rebuild_info = info[k];
				Rebuild_font = ((Rebuild_info.fontData != null) ? Rebuild_info.fontData.font : font);
				Rebuild_font.GetCharacterInfo('\n', out Rebuild_breakCh, GetFontSize(Rebuild_font, Rebuild_info), style);
				Rebuild_font.RequestCharactersInTexture("\u00ad", GetFontSize(Rebuild_font, Rebuild_info), style);
				Rebuild_font.GetCharacterInfo('\u00ad', out Rebuild_hyphenCh, GetFontSize(Rebuild_font, Rebuild_info), style);
				if (hyphenedText[k] == '\n')
				{
					num = Rebuild_info.indent;
				}
				else if (hyphenedText[k] == '\t')
				{
					num += 0.5f * tabSize * Rebuild_info.size;
					totalWidth += 0.5f * tabSize * Rebuild_info.size;
				}
				else
				{
					num += Rebuild_info.Advance(characterSpacing).x;
					totalWidth += Rebuild_info.Advance(characterSpacing).x;
				}
				if (!(num > Rebuild_autoWrap) || k <= num2 + 1)
				{
					continue;
				}
				allLinebreakIndexes = new int[linebreakFriendlyChars.Length];
				for (int l = 0; l < linebreakFriendlyChars.Length; l++)
				{
					allLinebreakIndexes[l] = hyphenedText.LastIndexOf(linebreakFriendlyChars[l], k);
				}
				int num3 = Mathf.Max(allLinebreakIndexes);
				int num4 = hyphenedText.LastIndexOf('\n', k);
				if (!breakText && num3 != -1 && num3 > num4)
				{
					if (hyphenedText[num3] == ' ')
					{
						hyphenedText = hyphenedText.Remove(num3, 1);
						hyphenedText = hyphenedText.Insert(num3, '\n'.ToString());
						info[num3].UpdateCachedValuesIfChanged();
						k = num3;
						num2 = k;
					}
					else if (insertHyphens && hyphenedText[num3] != '-')
					{
						hyphenedText = hyphenedText.Insert(num3 + 1, "\u200b\n");
						info.Insert(num3 + 1, new STMTextInfo(info[num3], Rebuild_breakCh));
						infoCount++;
						info[num3 + 1].UpdateCachedValuesIfChanged();
						info.Insert(num3 + 1, new STMTextInfo(info[num3], Rebuild_hyphenCh));
						infoCount++;
						info[num3 + 1].UpdateCachedValuesIfChanged();
						k = num3 + 2;
						num2 = k;
					}
					else
					{
						hyphenedText = hyphenedText.Insert(num3 + 1, '\n'.ToString());
						info.Insert(num3 + 1, new STMTextInfo(info[num3], Rebuild_breakCh));
						infoCount++;
						info[num3 + 1].UpdateCachedValuesIfChanged();
						k = num3 + 1;
						num2 = k;
					}
				}
				else if (k > 0)
				{
					if (insertHyphens)
					{
						hyphenedText = hyphenedText.Insert(k, "\u00ad\n");
						info.Insert(k, new STMTextInfo(Rebuild_info, Rebuild_breakCh));
						infoCount++;
						Rebuild_info.UpdateCachedValuesIfChanged();
						info.Insert(k, new STMTextInfo(Rebuild_info, Rebuild_hyphenCh));
						infoCount++;
						Rebuild_info.UpdateCachedValuesIfChanged();
						num2 = k + 1;
					}
					else
					{
						hyphenedText = hyphenedText.Insert(k, "\n");
						info.Insert(k, new STMTextInfo(Rebuild_info, Rebuild_breakCh));
						infoCount++;
						Rebuild_info.UpdateCachedValuesIfChanged();
						num2 = k;
					}
				}
				num = Rebuild_info.indent;
			}
		}
		else
		{
			int m = 0;
			for (int length2 = hyphenedText.Length; m < length2; m++)
			{
				Rebuild_info = info[m];
				Rebuild_font = ((Rebuild_info.fontData != null) ? Rebuild_info.fontData.font : font);
				Rebuild_font.RequestCharactersInTexture(hyphenedText[m].ToString(), GetFontSize(Rebuild_font, Rebuild_info), Rebuild_info.ch.style);
				if (Rebuild_font.GetCharacterInfo(hyphenedText[m], out Rebuild_ch, GetFontSize(Rebuild_font, Rebuild_info), Rebuild_info.ch.style))
				{
					Rebuild_info.ch = Rebuild_ch;
					Rebuild_info.UpdateCachedValuesIfChanged();
				}
				else
				{
					Rebuild_font = data.defaultFont;
					if (Rebuild_font.GetCharacterInfo(hyphenedText[m], out Rebuild_ch, GetFontSize(Rebuild_font, Rebuild_info), Rebuild_info.ch.style))
					{
						Rebuild_info.fontData = new STMFontData(data.defaultFont);
						Rebuild_info.ch = Rebuild_ch;
						Rebuild_info.UpdateCachedValuesIfChanged();
					}
				}
				if (!allFonts.Contains(Rebuild_font))
				{
					allFonts.Add(Rebuild_font);
				}
			}
		}
		CalculateLineHeights();
		if (rtl)
		{
			hyphenedText = FlipParagraphs(hyphenedText, flipInfo: true);
		}
		int num5 = 0;
		int n = 0;
		for (int length3 = hyphenedText.Length; n < length3; n++)
		{
			Rebuild_info = info[n];
			Rebuild_font = ((Rebuild_info.fontData != null) ? Rebuild_info.fontData.font : font);
			float num6 = GetFontSize(Rebuild_font, Rebuild_info);
			Rebuild_info.pos = Rebuild_pos;
			if (hyphenedText[n] == '\n')
			{
				lineBreaks.Add((n != 0) ? (n - 1) : 0);
				Rebuild_pos.x = Rebuild_info.indent;
				Rebuild_pos.y -= lineSpacing * lineHeights[num5];
				num5++;
			}
			else if (length3 - 1 == n)
			{
				lineBreaks.Add(n);
			}
			else if (hyphenedText[n] == '\t')
			{
				Rebuild_pos.x += num6 * 0.5f * tabSize * (Rebuild_info.size / num6);
			}
			else
			{
				Rebuild_pos.x += Rebuild_info.Advance(characterSpacing, num6).x;
			}
		}
		lineBreaks = lineBreaks.Distinct().ToList();
		ApplyOffsetDataToTextInfo();
		TrimCutoffText();
		UpdateRTLDrawOrder();
		ApplyTimingDataToTextInfo();
		ApplyUnreadTimingDataToTextInfo();
		PrepareSubmeshes();
	}

	private void TrimCutoffText()
	{
		leftoverText = "";
		if (VerticalLimit > 0f && verticalLimitMode == VerticalLimitMode.CutOff)
		{
			float num = 0f - VerticalLimit;
			switch (anchor)
			{
			case TextAnchor.MiddleLeft:
			case TextAnchor.MiddleCenter:
			case TextAnchor.MiddleRight:
				num *= 0.5f;
				break;
			case TextAnchor.LowerLeft:
			case TextAnchor.LowerCenter:
			case TextAnchor.LowerRight:
				num = 0f;
				break;
			}
			num += uiOffset.y;
			for (int i = 0; i < hyphenedText.Length; i++)
			{
				if (info[i].pos.y < num)
				{
					hyphenedText = hyphenedText.Remove(i, hyphenedText.Length - i);
					AssembleLeftoverText();
					return;
				}
			}
		}
		else if (VerticalLimit > 0f && (verticalLimitMode == VerticalLimitMode.AutoPause || verticalLimitMode == VerticalLimitMode.AutoPauseFull))
		{
			for (int j = 0; j < hyphenedText.Length; j++)
			{
				while (info[j].pos.y < autoPauseStopPoint - offset.y)
				{
					currentPauseCount++;
					autoPauseStopPoint -= VerticalLimit;
					if (UnityEngine.Application.isPlaying && currentPauseCount > pauseCount)
					{
						hyphenedText = hyphenedText.Remove(j, hyphenedText.Length - j);
						AssembleLeftoverText();
						return;
					}
				}
			}
		}
		_ = info.Count;
		_ = 0;
	}

	private void AssembleLeftoverText()
	{
		int length = hyphenedText.Length;
		if (length > 0)
		{
			for (int i = 0; i < allTags.Count && allTags[i].Key <= length; i++)
			{
				leftoverText += allTags[i].Value;
			}
			length = info[length].rawIndex;
			leftoverText += preParsedText.Substring(length);
		}
	}

	private void ApplyOffsetDataToTextInfo()
	{
		OffsetData_VerticalLimit = VerticalLimit;
		float[] array = new float[lineBreaks.Count];
		int i = 0;
		for (int count = lineBreaks.Count; i < count; i++)
		{
			array[i] = info[lineBreaks[i]].RelativeAdvance(characterSpacing).x;
			if (float.IsNaN(array[i]))
			{
				array[i] = 0f;
			}
		}
		rawBottomRightTextBounds.x = Mathf.Max(array);
		rawBottomRightTextBounds.y = 0f;
		offset.x = 0f;
		offset.y = 0f;
		offset.z = 0f;
		if (uiMode)
		{
			uiOffset.x = 0f;
			uiOffset.y = 0f;
			uiOffset.z = 0f;
			switch (anchor)
			{
			case TextAnchor.UpperLeft:
				uiOffset.x = tr.rect.xMin;
				uiOffset.y = tr.rect.yMax;
				break;
			case TextAnchor.UpperCenter:
				uiOffset.x = (tr.rect.xMin + tr.rect.xMax) / 2f;
				uiOffset.y = tr.rect.yMax;
				break;
			case TextAnchor.UpperRight:
				uiOffset.x = tr.rect.xMax;
				uiOffset.y = tr.rect.yMax;
				break;
			case TextAnchor.MiddleLeft:
				uiOffset.x = tr.rect.xMin;
				uiOffset.y = (tr.rect.yMin + tr.rect.yMax) / 2f;
				break;
			case TextAnchor.MiddleCenter:
				uiOffset.x = (tr.rect.xMin + tr.rect.xMax) / 2f;
				uiOffset.y = (tr.rect.yMin + tr.rect.yMax) / 2f;
				break;
			case TextAnchor.MiddleRight:
				uiOffset.x = tr.rect.xMax;
				uiOffset.y = (tr.rect.yMin + tr.rect.yMax) / 2f;
				break;
			case TextAnchor.LowerLeft:
				uiOffset.x = tr.rect.xMin;
				uiOffset.y = tr.rect.yMin;
				break;
			case TextAnchor.LowerCenter:
				uiOffset.x = (tr.rect.xMin + tr.rect.xMax) / 2f;
				uiOffset.y = tr.rect.yMin;
				break;
			case TextAnchor.LowerRight:
				uiOffset.x = tr.rect.xMax;
				uiOffset.y = tr.rect.yMin;
				break;
			}
			offset.x -= uiOffset.x;
			offset.y -= uiOffset.y;
		}
		OffsetData_rowStart = 0;
		lowestPosition = 0f;
		int j = 0;
		for (int count2 = lineBreaks.Count; j < count2; j++)
		{
			OffsetData_offsetRight = 0f;
			OffsetData_offsetRight = rawBottomRightTextBounds.x - info[lineBreaks[j]].RelativeAdvance(characterSpacing).x;
			if (Rebuild_autoWrap > 0f)
			{
				OffsetData_offsetRight += Rebuild_autoWrap - rawBottomRightTextBounds.x;
			}
			OffsetData_spaceCount = 0;
			int k = OffsetData_rowStart;
			for (int num = lineBreaks[j] + 1; k < num; k++)
			{
				if (hyphenedText[k] == ' ')
				{
					OffsetData_spaceCount++;
				}
			}
			float num2 = ((OffsetData_spaceCount > 0) ? (OffsetData_offsetRight / (float)OffsetData_spaceCount) : 0f);
			int num3 = 0;
			int l = OffsetData_rowStart;
			for (int num4 = lineBreaks[j] + 1; l < num4; l++)
			{
				info[l].line = j;
				if (hyphenedText[l] == ' ')
				{
					num3++;
				}
				switch (info[l].alignment)
				{
				case Alignment.Center:
					info[l].pos.x += OffsetData_offsetRight / 2f;
					break;
				case Alignment.Right:
					info[l].pos.x += OffsetData_offsetRight;
					break;
				case Alignment.Justified:
					if (num4 != hyphenedText.Length && drawText[num4 - (hyphenedText.Length - drawText.Length)] != '\n')
					{
						info[l].pos.x += num2 * (float)num3;
					}
					break;
				case Alignment.ForceJustified:
					info[l].pos.x += num2 * (float)num3;
					break;
				}
				rawBottomRightTextBounds.y = Mathf.Min(rawBottomRightTextBounds.y, info[l].pos.y);
				if (OffsetData_VerticalLimit == 0f || (OffsetData_VerticalLimit > 0f && verticalLimitMode == VerticalLimitMode.Ignore) || info[l].pos.y >= 0f - OffsetData_VerticalLimit)
				{
					lowestPosition = Mathf.Min(lowestPosition, info[l].pos.y);
				}
			}
			OffsetData_rowStart = lineBreaks[j] + 1;
		}
		OffsetData_maxHeight = ((OffsetData_VerticalLimit > 0f) ? (0f - OffsetData_VerticalLimit) : rawBottomRightTextBounds.y);
		OffsetData_maxWidth = ((Rebuild_autoWrap > 0f) ? Rebuild_autoWrap : rawBottomRightTextBounds.x);
		switch (anchor)
		{
		case TextAnchor.UpperCenter:
			offset.x += OffsetData_maxWidth * 0.5f;
			break;
		case TextAnchor.UpperRight:
			offset.x += OffsetData_maxWidth;
			break;
		case TextAnchor.MiddleLeft:
			offset.y += OffsetData_maxHeight * 0.5f;
			break;
		case TextAnchor.MiddleCenter:
			offset.x += OffsetData_maxWidth * 0.5f;
			offset.y += OffsetData_maxHeight * 0.5f;
			break;
		case TextAnchor.MiddleRight:
			offset.x += OffsetData_maxWidth;
			offset.y += OffsetData_maxHeight * 0.5f;
			break;
		case TextAnchor.LowerLeft:
			offset.y += OffsetData_maxHeight;
			break;
		case TextAnchor.LowerCenter:
			offset.x += OffsetData_maxWidth * 0.5f;
			offset.y += OffsetData_maxHeight;
			break;
		case TextAnchor.LowerRight:
			offset.x += OffsetData_maxWidth;
			offset.y += OffsetData_maxHeight;
			break;
		}
		for (int m = 0; m < infoCount; m++)
		{
			info[m].pos -= offset;
		}
		rawTopLeftBounds.x = offset.x;
		rawTopLeftBounds.y = offset.y;
		rawTopLeftBounds.z = offset.z;
		rawBottomRightBounds.x = ((Rebuild_autoWrap > 0f) ? (offset.x - Rebuild_autoWrap) : (offset.x - rawBottomRightTextBounds.x));
		rawBottomRightBounds.y = ((OffsetData_VerticalLimit > 0f) ? (OffsetData_VerticalLimit + offset.y) : (offset.y - OffsetData_maxHeight));
		rawBottomRightBounds.z = offset.z;
		anchorOffset.x = 0f;
		anchorOffset.y = 0f;
		anchorOffset.z = 0f;
		switch (anchor)
		{
		case TextAnchor.MiddleLeft:
		case TextAnchor.MiddleCenter:
		case TextAnchor.MiddleRight:
			anchorOffset.y = ((OffsetData_VerticalLimit > 0f - rawBottomRightTextBounds.y) ? ((0f - rawBottomRightTextBounds.y + rawTopLeftBounds.y - rawBottomRightBounds.y) * 0.5f) : 0f);
			break;
		case TextAnchor.LowerLeft:
		case TextAnchor.LowerCenter:
		case TextAnchor.LowerRight:
			anchorOffset.y = ((OffsetData_VerticalLimit > 0f - rawBottomRightTextBounds.y) ? (0f - rawBottomRightTextBounds.y + rawTopLeftBounds.y - rawBottomRightBounds.y) : 0f);
			break;
		}
		RecalculateBounds();
	}

	private void RecalculateBounds()
	{
		RecalculateBounds_point.x = 0f - rawTopLeftBounds.x;
		RecalculateBounds_point.y = 0f - rawTopLeftBounds.y;
		RecalculateBounds_point.z = 0f - rawTopLeftBounds.z;
		topLeftBounds = t.TransformPoint(RecalculateBounds_point);
		RecalculateBounds_point.x = 0f - rawBottomRightBounds.x;
		RecalculateBounds_point.y = 0f - rawTopLeftBounds.y;
		RecalculateBounds_point.z = rawTopLeftBounds.z;
		topRightBounds = t.TransformPoint(RecalculateBounds_point);
		RecalculateBounds_point.x = 0f - rawTopLeftBounds.x;
		RecalculateBounds_point.y = 0f - rawBottomRightBounds.y;
		RecalculateBounds_point.z = rawBottomRightBounds.z;
		bottomLeftBounds = t.TransformPoint(RecalculateBounds_point);
		RecalculateBounds_point.x = 0f - rawBottomRightBounds.x;
		RecalculateBounds_point.y = 0f - rawBottomRightBounds.y;
		RecalculateBounds_point.z = 0f - rawBottomRightBounds.z;
		bottomRightBounds = t.TransformPoint(RecalculateBounds_point);
		centerBounds = Vector3.Lerp(topLeftBounds, bottomRightBounds, 0.5f);
		if (hyphenedText.Length == 0)
		{
			RecalculateTextBounds();
		}
		RecalculateFinalTextBounds();
	}

	private void RecalculateBoundsOffsets()
	{
		TextBounds_leftOffset.x = 0f;
		TextBounds_leftOffset.y = 0f;
		TextBounds_leftOffset.z = 0f;
		TextBounds_rightOffset.x = 0f;
		TextBounds_rightOffset.y = 0f;
		TextBounds_rightOffset.z = 0f;
		TextBounds_diff = rawBottomRightTextBounds.x + rawBottomRightBounds.x - offset.x;
		switch (alignment)
		{
		case Alignment.Center:
			TextBounds_leftOffset.x += TextBounds_diff / 2f;
			TextBounds_rightOffset.x += TextBounds_diff / 2f;
			break;
		case Alignment.Right:
			TextBounds_leftOffset.x += TextBounds_diff;
			TextBounds_rightOffset.x += TextBounds_diff;
			break;
		case Alignment.Justified:
		case Alignment.ForceJustified:
			TextBounds_rightOffset.x += TextBounds_diff;
			break;
		}
	}

	private void RecalculateTextBounds()
	{
		if (hyphenedText.Length > 0)
		{
			RecalculateBoundsOffsets();
			RecalculateBounds_t = base.transform;
			RecalculateBounds_textBottom = Mathf.Max(lowestDrawnPositionRaw - offset.y, lowestPosition - rawTopLeftBounds.y);
			RecalculateBounds_point.x = 0f - TextBounds_leftOffset.x - rawTopLeftBounds.x + anchorOffset.x;
			RecalculateBounds_point.y = 0f - TextBounds_leftOffset.y - rawTopLeftBounds.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - TextBounds_leftOffset.z - rawTopLeftBounds.z + anchorOffset.z;
			topLeftTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			RecalculateBounds_point.x = furthestDrawnPosition - rawTopLeftBounds.x - TextBounds_rightOffset.x + anchorOffset.x;
			RecalculateBounds_point.y = 0f - rawTopLeftBounds.y - TextBounds_rightOffset.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - rawTopLeftBounds.z - TextBounds_rightOffset.z + anchorOffset.z;
			topRightTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			RecalculateBounds_point.x = 0f - rawTopLeftBounds.x - TextBounds_leftOffset.x + anchorOffset.x;
			RecalculateBounds_point.y = RecalculateBounds_textBottom - TextBounds_leftOffset.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - TextBounds_leftOffset.z + anchorOffset.z;
			bottomLeftTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			RecalculateBounds_point.x = furthestDrawnPosition - rawTopLeftBounds.x - TextBounds_rightOffset.x + anchorOffset.x;
			RecalculateBounds_point.y = RecalculateBounds_textBottom - TextBounds_rightOffset.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - TextBounds_rightOffset.z + anchorOffset.z;
			bottomRightTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			centerTextBounds.x = Mathf.Lerp(topLeftTextBounds.x, bottomRightTextBounds.x, 0.5f);
			centerTextBounds.y = Mathf.Lerp(topLeftTextBounds.y, bottomRightTextBounds.y, 0.5f);
		}
		else
		{
			topLeftTextBounds.x = 0f;
			topLeftTextBounds.y = 0f;
			topLeftTextBounds.z = 0f;
			topRightTextBounds.x = 0f;
			topRightTextBounds.y = 0f;
			topRightTextBounds.z = 0f;
			bottomLeftTextBounds.x = 0f;
			bottomLeftTextBounds.y = 0f;
			bottomLeftTextBounds.z = 0f;
			bottomRightTextBounds.x = 0f;
			bottomRightTextBounds.y = 0f;
			bottomRightTextBounds.z = 0f;
			centerTextBounds.x = 0f;
			centerTextBounds.y = 0f;
			centerTextBounds.z = 0f;
		}
	}

	private void RecalculateFinalTextBounds()
	{
		if (hyphenedText.Length > 0)
		{
			RecalculateBoundsOffsets();
			RecalculateBounds_t = base.transform;
			RecalculateBounds_point.x = 0f - rawTopLeftBounds.x - TextBounds_leftOffset.x + anchorOffset.x;
			RecalculateBounds_point.y = 0f - rawTopLeftBounds.y - TextBounds_leftOffset.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - rawTopLeftBounds.z - TextBounds_leftOffset.z + anchorOffset.z;
			finalTopLeftTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			RecalculateBounds_point.x = rawBottomRightTextBounds.x - rawTopLeftBounds.x - TextBounds_rightOffset.x + anchorOffset.x;
			RecalculateBounds_point.y = 0f - rawTopLeftBounds.y - TextBounds_rightOffset.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - rawTopLeftBounds.z - TextBounds_rightOffset.z + anchorOffset.z;
			finalTopRightTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			RecalculateBounds_point.x = 0f - rawTopLeftBounds.x - TextBounds_leftOffset.x + anchorOffset.x;
			RecalculateBounds_point.y = lowestPosition - rawTopLeftBounds.y - TextBounds_leftOffset.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - rawTopLeftBounds.z - TextBounds_leftOffset.z + anchorOffset.z;
			finalBottomLeftTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			RecalculateBounds_point.x = rawBottomRightTextBounds.x - rawTopLeftBounds.x - TextBounds_rightOffset.x + anchorOffset.x;
			RecalculateBounds_point.y = lowestPosition - rawTopLeftBounds.y - TextBounds_rightOffset.y + anchorOffset.y;
			RecalculateBounds_point.z = 0f - rawTopLeftBounds.z - TextBounds_rightOffset.z + anchorOffset.z;
			finalBottomRightTextBounds = RecalculateBounds_t.TransformPoint(RecalculateBounds_point);
			finalCenterTextBounds.x = Mathf.Lerp(finalTopLeftTextBounds.x, finalBottomRightTextBounds.x, 0.5f);
			finalCenterTextBounds.y = Mathf.Lerp(finalTopLeftTextBounds.y, finalBottomRightTextBounds.y, 0.5f);
		}
		else
		{
			finalTopLeftTextBounds.x = 0f;
			finalTopLeftTextBounds.y = 0f;
			finalTopLeftTextBounds.z = 0f;
			finalTopRightTextBounds.x = 0f;
			finalTopRightTextBounds.y = 0f;
			finalTopRightTextBounds.z = 0f;
			finalBottomLeftTextBounds.x = 0f;
			finalBottomLeftTextBounds.y = 0f;
			finalBottomLeftTextBounds.z = 0f;
			finalBottomRightTextBounds.x = 0f;
			finalBottomRightTextBounds.y = 0f;
			finalBottomRightTextBounds.z = 0f;
			finalCenterTextBounds.x = 0f;
			finalCenterTextBounds.y = 0f;
			finalCenterTextBounds.z = 0f;
		}
	}

	private void UpdateRTLDrawOrder()
	{
		drawOrderRTL = new int[hyphenedText.Length];
		RTL_currentLine = 0;
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			RTL_lastEnd = ((RTL_currentLine > 0) ? (lineBreaks[RTL_currentLine - 1] + 1) : 0);
			if (RTL_currentLine < lineBreaks.Count)
			{
				drawOrderRTL[i] = -i + lineBreaks[RTL_currentLine] + RTL_lastEnd;
				if (lineBreaks[RTL_currentLine] == i)
				{
					RTL_currentLine++;
				}
			}
		}
	}

	private void ApplyTimingDataToTextInfo()
	{
		float num = 0f;
		float num2 = 0f;
		bool flag = false;
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			Timing_textInfo = info[i];
			int num3 = GetDrawOrder(Timing_textInfo.drawOrder, i, length);
			Timing_textInfo = info[num3];
			if (Timing_textInfo.readDelay > 0f)
			{
				flag = true;
			}
			float num4 = ((Timing_textInfo.delayData != null) ? ((float)Timing_textInfo.delayData.count) : 0f);
			if (Timing_textInfo.readTime < 0f)
			{
				switch (Timing_textInfo.drawOrder)
				{
				case DrawOrder.AllAtOnce:
					Timing_textInfo.readTime = num;
					break;
				case DrawOrder.Random:
					Timing_textInfo.readTime = UnityEngine.Random.Range(0f, Timing_textInfo.readDelay);
					break;
				case DrawOrder.OneWordAtATime:
					if (hyphenedText[i] == ' ' || hyphenedText[i] == '\n' || hyphenedText[i] == '\t' || hyphenedText[i] == '-')
					{
						num += ((i == 0) ? (num4 * Timing_textInfo.readDelay) : (Timing_textInfo.readDelay + num4 * Timing_textInfo.readDelay));
					}
					Timing_textInfo.readTime = num;
					break;
				case DrawOrder.OneLineAtATime:
					if (hyphenedText[i] == '\n')
					{
						num += ((i == 0) ? (num4 * Timing_textInfo.readDelay) : (Timing_textInfo.readDelay + num4 * Timing_textInfo.readDelay));
					}
					Timing_textInfo.readTime = num;
					break;
				case DrawOrder.RightToLeft:
					Timing_textInfo.readTime = num;
					num += ((num3 == 0) ? (num4 * Timing_textInfo.readDelay) : (Timing_textInfo.readDelay + num4 * Timing_textInfo.readDelay));
					break;
				case DrawOrder.ReverseLTR:
					num += ((i == 0) ? (num4 * Timing_textInfo.readDelay) : (Timing_textInfo.readDelay + num4 * Timing_textInfo.readDelay));
					Timing_textInfo.readTime = num;
					break;
				case DrawOrder.RTLOneWordAtATime:
					Timing_textInfo.readTime = num;
					if (hyphenedText[num3] == ' ' || hyphenedText[num3] == '\n' || hyphenedText[num3] == '\t' || hyphenedText[num3] == '-')
					{
						num += ((num3 == 0) ? (num4 * Timing_textInfo.readDelay) : (Timing_textInfo.readDelay + num4 * Timing_textInfo.readDelay));
					}
					break;
				default:
					num += ((i == 0) ? (num4 * Timing_textInfo.readDelay) : (Timing_textInfo.readDelay + num4 * Timing_textInfo.readDelay));
					Timing_textInfo.readTime = num;
					break;
				}
			}
			else
			{
				num = Timing_textInfo.readTime;
			}
			float num5 = ((Timing_textInfo.drawAnimData != null) ? Mathf.Max(Timing_textInfo.drawAnimData.animTime, Timing_textInfo.drawAnimData.fadeTime) : 0f);
			num2 = Mathf.Max(Timing_textInfo.readTime + num5, num2);
		}
		totalReadTime = num2 + 1E-05f;
		callReadFunction = flag;
	}

	private void ApplyUnreadTimingDataToTextInfo()
	{
		float num = 0f;
		float b = 0f;
		STMDrawAnimData undrawAnim = UndrawAnim;
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			int index = GetDrawOrder(undrawOrder, i, length);
			Timing_textInfo = info[index];
			switch (undrawOrder)
			{
			case DrawOrder.AllAtOnce:
				Timing_textInfo.unreadTime = num;
				break;
			case DrawOrder.Random:
				Timing_textInfo.unreadTime = UnityEngine.Random.Range(0f, unreadDelay);
				break;
			case DrawOrder.OneWordAtATime:
				Timing_textInfo.unreadTime = num;
				if (hyphenedText[i] == ' ' || hyphenedText[i] == '\n' || hyphenedText[i] == '\t' || hyphenedText[i] == '-')
				{
					num += unreadDelay;
				}
				break;
			case DrawOrder.RTLOneWordAtATime:
				if (hyphenedText[index] == ' ' || hyphenedText[index] == '\n' || hyphenedText[index] == '\t' || hyphenedText[index] == '-')
				{
					num += unreadDelay;
				}
				Timing_textInfo.unreadTime = num;
				break;
			case DrawOrder.RightToLeft:
				num += unreadDelay;
				Timing_textInfo.unreadTime = num;
				break;
			case DrawOrder.ReverseLTR:
				num += unreadDelay;
				Timing_textInfo.unreadTime = num;
				break;
			default:
				Timing_textInfo.unreadTime = num;
				num += unreadDelay;
				break;
			}
			float num2 = ((undrawAnim != null) ? Mathf.Max(undrawAnim.animTime, undrawAnim.fadeTime) : 0f);
			b = Mathf.Max(Timing_textInfo.unreadTime + num2, b);
		}
		totalUnreadTime = b;
	}

	private Vector3 WavePosition(STMTextInfo myInfo, STMWaveControl wave, float myTime)
	{
		WavePosition_Vect.x = wave.curveX.Evaluate(myTime * wave.speed.x + wave.phase * 6f + myInfo.pos.x * wave.density.x / myInfo.size) * wave.strength.x * myInfo.size;
		WavePosition_Vect.y = wave.curveY.Evaluate(myTime * wave.speed.y + wave.phase * 6f + myInfo.pos.x * wave.density.y / myInfo.size) * wave.strength.y * myInfo.size;
		WavePosition_Vect.z = wave.curveZ.Evaluate(myTime * wave.speed.z + wave.phase * 6f + myInfo.pos.x * wave.density.z / myInfo.size) * wave.strength.z * myInfo.size;
		return WavePosition_Vect;
	}

	private Vector3 WaveRotation(STMTextInfo myInfo, STMWaveRotationControl rot, Vector3 vertPos, float myTime)
	{
		WaveRotation_Pivot.x = myInfo.pos.x + rot.pivot.x * myInfo.RelativeWidth;
		WaveRotation_Pivot.y = myInfo.pos.y + rot.pivot.y * myInfo.size;
		WaveRotation_Pivot.z = 0f;
		WaveRotation_Offset.x = vertPos.x - WaveRotation_Pivot.x;
		WaveRotation_Offset.y = vertPos.y - WaveRotation_Pivot.y;
		WaveRotation_Offset.z = vertPos.z - WaveRotation_Pivot.z;
		WaveRotation_myRotation.x = 0f;
		WaveRotation_myRotation.y = 0f;
		WaveRotation_myRotation.z = rot.curveZ.Evaluate(myTime * rot.speed + rot.phase * 6f + myInfo.pos.x * rot.density) * rot.strength;
		WaveRotation_myQuaternion = Quaternion.Euler(WaveRotation_myRotation);
		WaveRotation_Offset = WaveRotation_myQuaternion * WaveRotation_Offset;
		WaveRotation_ReturnVal.x = WaveRotation_Offset.x + WaveRotation_Pivot.x - vertPos.x;
		WaveRotation_ReturnVal.y = WaveRotation_Offset.y + WaveRotation_Pivot.y - vertPos.y;
		WaveRotation_ReturnVal.z = WaveRotation_Offset.z + WaveRotation_Pivot.z - vertPos.z;
		return WaveRotation_ReturnVal;
	}

	private Vector3 WaveScale(STMTextInfo myInfo, STMWaveScaleControl scale, Vector3 vertPos, float myTime)
	{
		Vector3 vector = myInfo.pos + new Vector3(scale.pivot.x * myInfo.RelativeWidth, scale.pivot.y * myInfo.size, 0f);
		Vector3 a = vertPos - vector;
		Vector3 b = new Vector3(scale.curveX.Evaluate(myTime * scale.speed.x + scale.phase * 6f + myInfo.pos.x * scale.density.x) * scale.strength.x, scale.curveY.Evaluate(myTime * scale.speed.y + scale.phase * 6f + myInfo.pos.x * scale.density.y) * scale.strength.y, 1f);
		return Vector3.Scale(a, b) + vector - vertPos;
	}

	private Vector3 JitterValue(STMTextInfo myInfo, STMJitterData jit)
	{
		float num = currentReadTime - myInfo.readTime;
		bool perlin = jit.perlin;
		if (perlin)
		{
			JitterValue_MyJit.x = jit.distanceOverTime.Evaluate(num / jit.distanceOverTimeMulti) * (jit.distance.Evaluate(Mathf.PerlinNoise(jit.perlinTimeMulti * num + myInfo.pos.x, 0f)) * jit.amount * (Mathf.PerlinNoise(jit.perlinTimeMulti * num + myInfo.pos.x, 0f) - 0.5f)) * myInfo.size;
			JitterValue_MyJit.y = jit.distanceOverTime.Evaluate(num / jit.distanceOverTimeMulti) * (jit.distance.Evaluate(Mathf.PerlinNoise(jit.perlinTimeMulti * num + myInfo.pos.x + 30f, 0f)) * jit.amount * (Mathf.PerlinNoise(jit.perlinTimeMulti * num + myInfo.pos.x + 30f, 0f) - 0.5f)) * myInfo.size;
			JitterValue_MyJit.z = 0f;
		}
		else
		{
			JitterValue_MyJit.x = jit.distanceOverTime.Evaluate(num / jit.distanceOverTimeMulti) * jit.distance.Evaluate(UnityEngine.Random.value) * jit.amount * (UnityEngine.Random.value - 0.5f) * myInfo.size;
			JitterValue_MyJit.y = jit.distanceOverTime.Evaluate(num / jit.distanceOverTimeMulti) * jit.distance.Evaluate(UnityEngine.Random.value) * jit.amount * (UnityEngine.Random.value - 0.5f) * myInfo.size;
			JitterValue_MyJit.z = 0f;
		}
		return JitterValue_MyJit;
	}

	private int GetDrawOrder(DrawOrder myDrawOrder, int i, int iL)
	{
		switch (Timing_textInfo.drawOrder)
		{
		case DrawOrder.RightToLeft:
		case DrawOrder.RTLOneWordAtATime:
			return drawOrderRTL[i];
		case DrawOrder.ReverseLTR:
			return -i + iL - 1;
		default:
			return i;
		}
	}

	private void UpdateMesh(float myTime)
	{
		float getTime = GetTime;
		float num = VerticalLimit;
		int num2 = hyphenedText.Length * 4;
		areWeAnimating = false;
		if (endVerts.Length != num2)
		{
			Array.Resize(ref endVerts, num2);
		}
		if (endUv.Length != num2)
		{
			Array.Resize(ref endUv, num2);
		}
		if (endUv2.Length != num2)
		{
			Array.Resize(ref endUv2, num2);
		}
		if (endCol32.Length != num2)
		{
			Array.Resize(ref endCol32, num2);
		}
		if (ratiosAndUvMids.Count != num2)
		{
			ratiosAndUvMids = new List<Vector4>(new Vector4[num2]);
		}
		if (isUvRotated.Count != num2)
		{
			isUvRotated = new List<Vector4>(new Vector4[num2]);
		}
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			CurrentTextInfo = info[i];
			int b = GetDrawOrder(CurrentTextInfo.drawOrder, i, length);
			ratioHold = CurrentTextInfo.ratio;
			if (!reading)
			{
				DoEvent(i);
			}
			doPrintEventAfter = false;
			doEventAfter = false;
			if (reading)
			{
				float num3 = ((CurrentTextInfo.drawAnimData.animTime == 0f) ? 1E-07f : CurrentTextInfo.drawAnimData.animTime);
				if ((myTime - CurrentTextInfo.readTime) / num3 > 0f && !CurrentTextInfo.invoked)
				{
					CurrentTextInfo.invoked = true;
					doEventAfter = true;
					if (hyphenedText[i] != '\u200b')
					{
						doPrintEventAfter = true;
						if (hyphenedText[i] != ' ' && hyphenedText[i] != '\n')
						{
							lowestDrawnPosition = Mathf.Min(lowestDrawnPosition, CurrentTextInfo.pos.y);
							lowestDrawnPositionRaw = Mathf.Min(lowestDrawnPosition, CurrentTextInfo.pos.y + offset.y);
							furthestDrawnPosition = Mathf.Max(furthestDrawnPosition, CurrentTextInfo.RelativeAdvance(characterSpacing).x + offset.x + TextBounds_rightOffset.x);
						}
					}
					latestNumber = Mathf.Max(latestNumber, b);
				}
			}
			else if (!UnityEngine.Application.isPlaying || num == 0f || (verticalLimitMode != VerticalLimitMode.AutoPause && verticalLimitMode != VerticalLimitMode.AutoPauseFull))
			{
				latestNumber = hyphenedText.Length - 1;
				lowestDrawnPosition = info[latestNumber].pos.y;
				lowestDrawnPositionRaw = info[latestNumber].pos.y + offset.y;
				furthestDrawnPosition = rawBottomRightTextBounds.x;
			}
			RecalculateTextBounds();
			if (doEventAfter)
			{
				DoEvent(i);
			}
			if (doPrintEventAfter)
			{
				PlaySound(i);
				if (onPrintEvent != null)
				{
					onPrintEvent.Invoke();
				}
				if (this.OnPrintEvent != null)
				{
					this.OnPrintEvent();
				}
			}
			UpdateMesh_lowestLineOffset = anchorOffset;
			if (num > 0f && (verticalLimitMode == VerticalLimitMode.ShowLast || verticalLimitMode == VerticalLimitMode.AutoPause || verticalLimitMode == VerticalLimitMode.AutoPauseFull) && lowestDrawnPosition < 0f - rawBottomRightBounds.y)
			{
				for (int j = 0; j < lineHeights.Count; j++)
				{
					if (UpdateMesh_lowestLineOffset.y >= 0f - lowestDrawnPosition - rawBottomRightBounds.y)
					{
						break;
					}
					UpdateMesh_lowestLineOffset.y += lineHeights[j];
				}
				if (verticalLimitMode == VerticalLimitMode.AutoPauseFull)
				{
					tmpRawBottomRightBounds = rawBottomRightBounds.y;
					if (uiMode)
					{
						tmpRawBottomRightBounds *= 2f;
					}
					UpdateMesh_lowestLineOffset.y = Mathf.Ceil(UpdateMesh_lowestLineOffset.y / tmpRawBottomRightBounds) * tmpRawBottomRightBounds;
				}
			}
			jitterValue = Vector3.zero;
			if (CurrentTextInfo.jitterData != null && !data.disableAnimatedText && !disableAnimatedText)
			{
				areWeAnimating = true;
				jitterValue = JitterValue(CurrentTextInfo, CurrentTextInfo.jitterData);
			}
			UpdateMesh_waveValue = Vector3.zero;
			UpdateMesh_waveValueTopLeft = Vector3.zero;
			UpdateMesh_waveValueTopRight = Vector3.zero;
			UpdateMesh_waveValueBottomRight = Vector3.zero;
			UpdateMesh_waveValueBottomLeft = Vector3.zero;
			if (CurrentTextInfo.waveData != null && CurrentTextInfo.size != 0f && !data.disableAnimatedText && !disableAnimatedText)
			{
				areWeAnimating = true;
				float myTime2 = (CurrentTextInfo.waveData.animateFromTimeDrawn ? (currentReadTime - CurrentTextInfo.readTime) : getTime);
				if (CurrentTextInfo.waveData.positionControl)
				{
					UpdateMesh_waveValue = WavePosition(CurrentTextInfo, CurrentTextInfo.waveData.position, myTime2);
				}
				if (CurrentTextInfo.waveData.individualVertexControl)
				{
					UpdateMesh_wavePosition = WavePosition(CurrentTextInfo, CurrentTextInfo.waveData.topLeft, myTime2);
					UpdateMesh_waveValueTopLeft.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueTopLeft.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueTopLeft.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WavePosition(CurrentTextInfo, CurrentTextInfo.waveData.topRight, myTime2);
					UpdateMesh_waveValueTopRight.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueTopRight.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueTopRight.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WavePosition(CurrentTextInfo, CurrentTextInfo.waveData.bottomRight, myTime2);
					UpdateMesh_waveValueBottomRight.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueBottomRight.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueBottomRight.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WavePosition(CurrentTextInfo, CurrentTextInfo.waveData.bottomLeft, myTime2);
					UpdateMesh_waveValueBottomLeft.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueBottomLeft.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueBottomLeft.z += UpdateMesh_wavePosition.z;
				}
				if (CurrentTextInfo.waveData.rotationControl)
				{
					UpdateMesh_wavePosition = WaveRotation(CurrentTextInfo, CurrentTextInfo.waveData.rotation, CurrentTextInfo.TopLeftVert, myTime2);
					UpdateMesh_waveValueTopLeft.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueTopLeft.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueTopLeft.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WaveRotation(CurrentTextInfo, CurrentTextInfo.waveData.rotation, CurrentTextInfo.TopRightVert, myTime2);
					UpdateMesh_waveValueTopRight.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueTopRight.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueTopRight.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WaveRotation(CurrentTextInfo, CurrentTextInfo.waveData.rotation, CurrentTextInfo.BottomRightVert, myTime2);
					UpdateMesh_waveValueBottomRight.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueBottomRight.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueBottomRight.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WaveRotation(CurrentTextInfo, CurrentTextInfo.waveData.rotation, CurrentTextInfo.BottomLeftVert, myTime2);
					UpdateMesh_waveValueBottomLeft.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueBottomLeft.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueBottomLeft.z += UpdateMesh_wavePosition.z;
				}
				if (CurrentTextInfo.waveData.scaleControl)
				{
					UpdateMesh_wavePosition = WaveScale(CurrentTextInfo, CurrentTextInfo.waveData.scale, CurrentTextInfo.TopLeftVert, myTime2);
					UpdateMesh_waveValueTopLeft.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueTopLeft.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueTopLeft.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WaveScale(CurrentTextInfo, CurrentTextInfo.waveData.scale, CurrentTextInfo.TopRightVert, myTime2);
					UpdateMesh_waveValueTopRight.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueTopRight.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueTopRight.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WaveScale(CurrentTextInfo, CurrentTextInfo.waveData.scale, CurrentTextInfo.BottomRightVert, myTime2);
					UpdateMesh_waveValueBottomRight.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueBottomRight.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueBottomRight.z += UpdateMesh_wavePosition.z;
					UpdateMesh_wavePosition = WaveScale(CurrentTextInfo, CurrentTextInfo.waveData.scale, CurrentTextInfo.BottomLeftVert, myTime2);
					UpdateMesh_waveValueBottomLeft.x += UpdateMesh_wavePosition.x;
					UpdateMesh_waveValueBottomLeft.y += UpdateMesh_wavePosition.y;
					UpdateMesh_waveValueBottomLeft.z += UpdateMesh_wavePosition.z;
				}
			}
			if (num > 0f && verticalLimitMode != VerticalLimitMode.Ignore && CurrentTextInfo.pos.y + CurrentTextInfo.size + UpdateMesh_lowestLineOffset.y - anchorOffset.y > 0f - rawTopLeftBounds.y + 1E-05f)
			{
				endVerts[4 * i] = Vector3.zero;
				endVerts[4 * i + 1] = Vector3.zero;
				endVerts[4 * i + 2] = Vector3.zero;
				endVerts[4 * i + 3] = Vector3.zero;
			}
			else
			{
				if (relativeBaseOffset)
				{
					realBaseOffset.x = baseOffset.x * CurrentTextInfo.size;
					realBaseOffset.y = baseOffset.y * CurrentTextInfo.size;
					realBaseOffset.z = baseOffset.z * CurrentTextInfo.size;
				}
				else
				{
					realBaseOffset.x = baseOffset.x;
					realBaseOffset.y = baseOffset.y;
					realBaseOffset.z = baseOffset.z;
				}
				endVerts[4 * i].x = CurrentTextInfo.TopLeftVert.x + jitterValue.x + UpdateMesh_waveValueTopLeft.x + UpdateMesh_waveValue.x + UpdateMesh_lowestLineOffset.x + realBaseOffset.x;
				endVerts[4 * i].y = CurrentTextInfo.TopLeftVert.y + jitterValue.y + UpdateMesh_waveValueTopLeft.y + UpdateMesh_waveValue.y + UpdateMesh_lowestLineOffset.y + realBaseOffset.y;
				endVerts[4 * i].z = CurrentTextInfo.TopLeftVert.z + jitterValue.z + UpdateMesh_waveValueTopLeft.z + UpdateMesh_waveValue.z + UpdateMesh_lowestLineOffset.z + realBaseOffset.z;
				endVerts[4 * i + 1].x = CurrentTextInfo.TopRightVert.x + jitterValue.x + UpdateMesh_waveValueTopRight.x + UpdateMesh_waveValue.x + UpdateMesh_lowestLineOffset.x + realBaseOffset.x;
				endVerts[4 * i + 1].y = CurrentTextInfo.TopRightVert.y + jitterValue.y + UpdateMesh_waveValueTopRight.y + UpdateMesh_waveValue.y + UpdateMesh_lowestLineOffset.y + realBaseOffset.y;
				endVerts[4 * i + 1].z = CurrentTextInfo.TopRightVert.z + jitterValue.z + UpdateMesh_waveValueTopRight.z + UpdateMesh_waveValue.z + UpdateMesh_lowestLineOffset.z + realBaseOffset.z;
				endVerts[4 * i + 2].x = CurrentTextInfo.BottomRightVert.x + jitterValue.x + UpdateMesh_waveValueBottomRight.x + UpdateMesh_waveValue.x + UpdateMesh_lowestLineOffset.x + realBaseOffset.x;
				endVerts[4 * i + 2].y = CurrentTextInfo.BottomRightVert.y + jitterValue.y + UpdateMesh_waveValueBottomRight.y + UpdateMesh_waveValue.y + UpdateMesh_lowestLineOffset.y + realBaseOffset.y;
				endVerts[4 * i + 2].z = CurrentTextInfo.BottomRightVert.z + jitterValue.z + UpdateMesh_waveValueBottomRight.z + UpdateMesh_waveValue.z + UpdateMesh_lowestLineOffset.z + realBaseOffset.z;
				endVerts[4 * i + 3].x = CurrentTextInfo.BottomLeftVert.x + jitterValue.x + UpdateMesh_waveValueBottomLeft.x + UpdateMesh_waveValue.x + UpdateMesh_lowestLineOffset.x + realBaseOffset.x;
				endVerts[4 * i + 3].y = CurrentTextInfo.BottomLeftVert.y + jitterValue.y + UpdateMesh_waveValueBottomLeft.y + UpdateMesh_waveValue.y + UpdateMesh_lowestLineOffset.y + realBaseOffset.y;
				endVerts[4 * i + 3].z = CurrentTextInfo.BottomLeftVert.z + jitterValue.z + UpdateMesh_waveValueBottomLeft.z + UpdateMesh_waveValue.z + UpdateMesh_lowestLineOffset.z + realBaseOffset.z;
				if (!CurrentTextInfo.isQuad)
				{
					endUv[4 * i] = CurrentTextInfo.ch.uvTopLeft;
					endUv[4 * i + 1] = CurrentTextInfo.ch.uvTopRight;
					endUv[4 * i + 2] = CurrentTextInfo.ch.uvBottomRight;
					endUv[4 * i + 3] = CurrentTextInfo.ch.uvBottomLeft;
					uvMidHold.x = (CurrentTextInfo.ch.uvTopLeft.x + CurrentTextInfo.ch.uvTopRight.x) * 0.5f;
					uvMidHold.y = (CurrentTextInfo.ch.uvTopLeft.y + CurrentTextInfo.ch.uvBottomLeft.y) * 0.5f;
				}
				else
				{
					endUv[4 * i] = CurrentTextInfo.quadData.UvTopLeft(getTime, CurrentTextInfo.quadIndex);
					endUv[4 * i + 1] = CurrentTextInfo.quadData.UvTopRight(getTime, CurrentTextInfo.quadIndex);
					endUv[4 * i + 2] = CurrentTextInfo.quadData.UvBottomRight(getTime, CurrentTextInfo.quadIndex);
					endUv[4 * i + 3] = CurrentTextInfo.quadData.UvBottomLeft(getTime, CurrentTextInfo.quadIndex);
					uvMidHold = CurrentTextInfo.quadData.UvMiddle(getTime, CurrentTextInfo.quadIndex);
					if (CurrentTextInfo.quadData.columns > 1 && CurrentTextInfo.quadData.animDelay > 0f && CurrentTextInfo.quadIndex < 0)
					{
						areWeAnimating = true;
					}
				}
			}
			ratioAndUvHold.x = ratioHold.x;
			ratioAndUvHold.y = ratioHold.y;
			ratioAndUvHold.z = uvMidHold.x;
			ratioAndUvHold.w = uvMidHold.y;
			ratiosAndUvMids[4 * i] = ratioAndUvHold;
			ratiosAndUvMids[4 * i + 1] = ratioAndUvHold;
			ratiosAndUvMids[4 * i + 2] = ratioAndUvHold;
			ratiosAndUvMids[4 * i + 3] = ratioAndUvHold;
			ratioAndUvHold.x = ((endUv[4 * i].x != endUv[4 * i + 3].x) ? 1 : 0);
			ratioAndUvHold.y = 0f;
			ratioAndUvHold.z = 0f;
			ratioAndUvHold.w = 0f;
			isUvRotated[4 * i] = ratioAndUvHold;
			isUvRotated[4 * i + 1] = ratioAndUvHold;
			isUvRotated[4 * i + 2] = ratioAndUvHold;
			isUvRotated[4 * i + 3] = ratioAndUvHold;
			if (CurrentTextInfo.textureData != null && (i != length - 1 || (i == length - 1 && CurrentTextInfo.TopRightVert != Vector3.zero)))
			{
				if (CurrentTextInfo.textureData.scrollSpeed != Vector2.zero)
				{
					areWeAnimating = true;
				}
				UpdateMesh_uvOffset.x = getTime * CurrentTextInfo.textureData.scrollSpeed.x;
				UpdateMesh_uvOffset.y = getTime * CurrentTextInfo.textureData.scrollSpeed.y;
				float num4 = 1f;
				if (CurrentTextInfo.textureData.scaleWithText)
				{
					num4 = 1f / CurrentTextInfo.size;
				}
				cacheVectThree = endVerts[4 * i];
				vectA.x = cacheVectThree.x;
				vectA.y = cacheVectThree.y;
				cacheVectThree = endVerts[4 * i + 1];
				vectB.x = cacheVectThree.x;
				vectB.y = cacheVectThree.y;
				cacheVectThree = endVerts[4 * i + 2];
				vectC.x = cacheVectThree.x;
				vectC.y = cacheVectThree.y;
				cacheVectThree = endVerts[4 * i + 3];
				vectD.x = cacheVectThree.x;
				vectD.y = cacheVectThree.y;
				if (CurrentTextInfo.textureData.relativeToLetter)
				{
					infoVect.x = CurrentTextInfo.pos.x;
					infoVect.y = CurrentTextInfo.pos.y;
					endUv2[4 * i].x = num4 * (vectA.x - infoVect.x) + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i].y = num4 * (vectA.y - infoVect.y) + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
					endUv2[4 * i + 1].x = num4 * (vectB.x - infoVect.x) + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i + 1].y = num4 * (vectB.y - infoVect.y) + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
					endUv2[4 * i + 2].x = num4 * (vectC.x - infoVect.x) + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i + 2].y = num4 * (vectC.y - infoVect.y) + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
					endUv2[4 * i + 3].x = num4 * (vectD.x - infoVect.x) + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i + 3].y = num4 * (vectD.y - infoVect.y) + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
				}
				else
				{
					endUv2[4 * i].x = num4 * vectA.x + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i].y = num4 * vectA.y + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
					endUv2[4 * i + 1].x = num4 * vectB.x + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i + 1].y = num4 * vectB.y + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
					endUv2[4 * i + 2].x = num4 * vectC.x + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i + 2].y = num4 * vectC.y + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
					endUv2[4 * i + 3].x = num4 * vectD.x + UpdateMesh_uvOffset.x - CurrentTextInfo.textureData.offset.x;
					endUv2[4 * i + 3].y = num4 * vectD.y + UpdateMesh_uvOffset.y - CurrentTextInfo.textureData.offset.y;
				}
			}
			if (CurrentTextInfo.isQuad && !CurrentTextInfo.quadData.silhouette)
			{
				endUv2[4 * i] = endUv[4 * i];
				endUv2[4 * i + 1] = endUv[4 * i + 1];
				endUv2[4 * i + 2] = endUv[4 * i + 2];
				endUv2[4 * i + 3] = endUv[4 * i + 3];
			}
			if (CurrentTextInfo.isQuad && !CurrentTextInfo.quadData.silhouette)
			{
				endCol32[4 * i] = Color.white;
				endCol32[4 * i + 1] = Color.white;
				endCol32[4 * i + 2] = Color.white;
				endCol32[4 * i + 3] = Color.white;
			}
			else if (CurrentTextInfo.gradientData != null)
			{
				if (CurrentTextInfo.gradientData.scrollSpeed != 0f)
				{
					areWeAnimating = true;
				}
				STMGradientData.GradientDirection direction = CurrentTextInfo.gradientData.direction;
				if (direction == STMGradientData.GradientDirection.Vertical)
				{
					if (!CurrentTextInfo.gradientData.smoothGradient)
					{
						endCol32[4 * i] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + CurrentTextInfo.pos.y * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
						endCol32[4 * i + 1] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + CurrentTextInfo.pos.y * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
						endCol32[4 * i + 2] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + CurrentTextInfo.pos.y * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
						endCol32[4 * i + 3] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + CurrentTextInfo.pos.y * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					}
					else
					{
						endCol32[4 * i] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + (CurrentTextInfo.pos.y + CurrentTextInfo.size) * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
						endCol32[4 * i + 1] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + (CurrentTextInfo.pos.y + CurrentTextInfo.size) * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
						endCol32[4 * i + 2] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + CurrentTextInfo.pos.y * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
						endCol32[4 * i + 3] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + CurrentTextInfo.pos.y * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					}
				}
				else if (!CurrentTextInfo.gradientData.smoothGradient)
				{
					endCol32[4 * i] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					endCol32[4 * i + 1] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					endCol32[4 * i + 2] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					endCol32[4 * i + 3] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
				}
				else
				{
					endCol32[4 * i] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					endCol32[4 * i + 1] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i + 1].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					endCol32[4 * i + 2] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i + 2].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
					endCol32[4 * i + 3] = CurrentTextInfo.gradientData.gradient.Evaluate(Mathf.Repeat(getTime * CurrentTextInfo.gradientData.scrollSpeed + endVerts[4 * i + 3].x * CurrentTextInfo.gradientData.gradientSpread / CurrentTextInfo.size, 1f));
				}
			}
			else if (CurrentTextInfo.textureData != null)
			{
				endCol32[4 * i] = Color.white;
				endCol32[4 * i + 1] = Color.white;
				endCol32[4 * i + 2] = Color.white;
				endCol32[4 * i + 3] = Color.white;
			}
			else if (CurrentTextInfo.colorData != null)
			{
				endCol32[4 * i] = CurrentTextInfo.colorData.color;
				endCol32[4 * i + 1] = CurrentTextInfo.colorData.color;
				endCol32[4 * i + 2] = CurrentTextInfo.colorData.color;
				endCol32[4 * i + 3] = CurrentTextInfo.colorData.color;
			}
			else
			{
				endCol32[4 * i] = color;
				endCol32[4 * i + 1] = color;
				endCol32[4 * i + 2] = color;
				endCol32[4 * i + 3] = color;
			}
		}
		if ((onVertexMod != null && onVertexMod.GetPersistentEventCount() > 0) || this.OnVertexMod != null)
		{
			if (UpdateMesh_Middles.Length != hyphenedText.Length)
			{
				Array.Resize(ref UpdateMesh_Middles, hyphenedText.Length);
			}
			if (UpdateMesh_Positions.Length != hyphenedText.Length)
			{
				Array.Resize(ref UpdateMesh_Positions, hyphenedText.Length);
			}
			int k = 0;
			for (int length2 = hyphenedText.Length; k < length2; k++)
			{
				CurrentTextInfo = info[k];
				UpdateMesh_Middles[k] = CurrentTextInfo.Middle;
				UpdateMesh_Positions[k] = CurrentTextInfo.pos;
			}
			if (onVertexMod != null)
			{
				onVertexMod.Invoke(endVerts, UpdateMesh_Middles, UpdateMesh_Positions);
			}
			if (this.OnVertexMod != null)
			{
				this.OnVertexMod(endVerts, UpdateMesh_Middles, UpdateMesh_Positions);
			}
			areWeAnimating = true;
		}
		if (data.disableAnimatedText || disableAnimatedText)
		{
			areWeAnimating = false;
		}
	}

	private void SetMesh(float timeValue)
	{
		SetMesh(timeValue, undrawingMesh: false);
	}

	private void SetMesh(float timeValue, bool undrawingMesh)
	{
		if (textMesh == null)
		{
			textMesh = new Mesh();
			textMesh.MarkDynamic();
		}
		textMesh.Clear();
		if (text.Length > 0)
		{
			if (reading || unreading)
			{
				UpdateDrawnMesh(timeValue, undrawingMesh);
				textMesh.vertices = midVerts;
				textMesh.colors32 = midCol32;
			}
			else if (timeValue == 0f || undrawingMesh)
			{
				UpdatePreReadMesh(undrawingMesh);
				textMesh.vertices = startVerts;
				textMesh.colors32 = startCol32;
			}
			else
			{
				UpdateMesh(totalReadTime + 1f);
				textMesh.vertices = endVerts;
				textMesh.colors32 = endCol32;
			}
			textMesh.uv = endUv;
			textMesh.uv2 = endUv2;
			textMesh.SetUVs(2, ratiosAndUvMids);
			textMesh.SetUVs(3, isUvRotated);
			if (submeshes.Count > 1)
			{
				textMesh.subMeshCount = submeshes.Count;
				int i = 0;
				for (int subMeshCount = textMesh.subMeshCount; i < subMeshCount; i++)
				{
					textMesh.SetTriangles(submeshes[i].tris, i);
				}
			}
			else if (submeshes.Count > 0)
			{
				textMesh.subMeshCount = 1;
				textMesh.SetTriangles(submeshes[0].tris, 0);
			}
		}
		ApplyMesh();
	}

	private void ApplyMesh()
	{
		if (uiMode)
		{
			c.SetMesh(textMesh);
		}
		else
		{
			f.sharedMesh = textMesh;
		}
	}

	[ContextMenu("Clear Materials")]
	public void ClearMaterials()
	{
		if (uiMode)
		{
			int i = 0;
			for (int materialCount = c.materialCount; i < materialCount; i++)
			{
				UnityEngine.Object.DestroyImmediate(c.GetMaterial(i));
			}
			c.materialCount = 0;
		}
		else
		{
			int j = 0;
			for (int num = r.sharedMaterials.Length; j < num; j++)
			{
				UnityEngine.Object.DestroyImmediate(r.sharedMaterials[j]);
			}
		}
		SharedMaterialDataStorage.allMaterials.Clear();
	}

	private void ApplyMaterials()
	{
		if (submeshMaterials.Length != submeshes.Count)
		{
			Array.Resize(ref submeshMaterials, submeshes.Count);
		}
		int i = 0;
		for (int num = submeshMaterials.Length; i < num; i++)
		{
			submeshMaterials[i] = submeshes[i].sharedMaterialData.AsMaterial;
		}
		if (uiMode)
		{
			if (this != null && t.gameObject.activeInHierarchy)
			{
				parentCanvas = t.GetComponentInParent<Canvas>();
				if (parentCanvas != null)
				{
					parentCanvas.additionalShaderChannels |= AdditionalCanvasShaderChannels.TexCoord1;
				}
				c.materialCount = submeshMaterials.Length + 1;
				for (int j = 0; j < c.materialCount - 1; j++)
				{
					c.SetMaterial(submeshMaterials[j], j);
				}
			}
		}
		else
		{
			r.sharedMaterials = submeshMaterials;
		}
	}

	private SubmeshData DoesSubmeshExist(SharedMaterialData materialData)
	{
		for (int i = 0; i < submeshes.Count; i++)
		{
			if (submeshes[i].sharedMaterialData == materialData)
			{
				return submeshes[i];
			}
		}
		return null;
	}

	private void PrepareSubmeshes()
	{
		submeshes.Clear();
		if (info.Count > 0 && info[0] != null && !info[0].submeshChange)
		{
			Submesh_sharedMaterial = SharedMaterialDataStorage.DoesSharedMaterialExist(this);
			if (Submesh_sharedMaterial == null)
			{
				SharedMaterialDataStorage.allMaterials.Add(new SharedMaterialData(this));
				Submesh_sharedMaterial = SharedMaterialDataStorage.allMaterials[SharedMaterialDataStorage.allMaterials.Count - 1];
			}
			Submesh_submeshData = DoesSubmeshExist(Submesh_sharedMaterial);
			if (Submesh_submeshData == null)
			{
				submeshes.Add(new SubmeshData(Submesh_sharedMaterial));
				Submesh_submeshData = submeshes[submeshes.Count - 1];
			}
		}
		int i = 0;
		for (int length = hyphenedText.Length; i < length; i++)
		{
			Submesh_info = info[i];
			if (Submesh_info.submeshChange)
			{
				Submesh_sharedMaterial = SharedMaterialDataStorage.DoesSharedMaterialExist(this, Submesh_info);
			}
			if (Submesh_sharedMaterial == null)
			{
				SharedMaterialDataStorage.allMaterials.Add(new SharedMaterialData(this, Submesh_info));
				Submesh_sharedMaterial = SharedMaterialDataStorage.allMaterials[SharedMaterialDataStorage.allMaterials.Count - 1];
			}
			if (Submesh_info.submeshChange)
			{
				Submesh_submeshData = DoesSubmeshExist(Submesh_sharedMaterial);
			}
			if (Submesh_submeshData == null)
			{
				Submesh_submeshData = new SubmeshData(Submesh_sharedMaterial);
				submeshes.Add(Submesh_submeshData);
			}
			Submesh_submeshData.tris.Add(4 * i);
			Submesh_submeshData.tris.Add(4 * i + 1);
			Submesh_submeshData.tris.Add(4 * i + 2);
			Submesh_submeshData.tris.Add(4 * i);
			Submesh_submeshData.tris.Add(4 * i + 2);
			Submesh_submeshData.tris.Add(4 * i + 3);
		}
	}

	public virtual void CalculateLayoutInputHorizontal()
	{
	}

	public virtual void CalculateLayoutInputVertical()
	{
	}
}
[Serializable]
public class SubmeshData
{
	public SharedMaterialData sharedMaterialData;

	public List<int> tris = new List<int>();

	public SubmeshData(SharedMaterialData data)
	{
		sharedMaterialData = data;
	}
}
[Serializable]
public static class SharedMaterialDataStorage
{
	public static List<SharedMaterialData> allMaterials = new List<SharedMaterialData>();

	private static Transform Submesh_maskCanvas;

	private static float Submesh_stencilDepth;

	private static SharedMaterialData MaterialExists_material = null;

	public static SharedMaterialData DoesSharedMaterialExist(SuperTextMesh stm, STMTextInfo info)
	{
		if (stm.uiMode)
		{
			Submesh_maskCanvas = MaskUtilities.FindRootSortOverrideCanvas(stm.t);
			Submesh_stencilDepth = MaskUtilities.GetStencilDepth(stm.t, Submesh_maskCanvas);
		}
		else
		{
			Submesh_stencilDepth = -1f;
		}
		for (int i = 0; i < allMaterials.Count; i++)
		{
			MaterialExists_material = allMaterials[i];
			if (MaterialExists_material == null)
			{
				continue;
			}
			if (info.materialData != null)
			{
				if (MaterialExists_material.refMat != info.materialData.material)
				{
					continue;
				}
			}
			else if (MaterialExists_material.refMat != stm.textMaterial)
			{
				continue;
			}
			if (MaterialExists_material.uiStencilDepth != Submesh_stencilDepth || MaterialExists_material.uiMaskMode != (int)stm.maskMode)
			{
				continue;
			}
			if (info.fontData != null)
			{
				if (info.quadData != null || MaterialExists_material.refFont == null || MaterialExists_material.refFont != info.fontData.font)
				{
					continue;
				}
				if (info.fontData.overrideFilterMode)
				{
					if (MaterialExists_material.refFilter != info.quadData.filterMode)
					{
						continue;
					}
				}
				else if (MaterialExists_material.refFilter != stm.filterMode)
				{
					continue;
				}
			}
			else if (info.quadData != null)
			{
				if (MaterialExists_material.refTex == null || MaterialExists_material.refTex != info.quadData.texture || MaterialExists_material.refTex == MaterialExists_material.refMask == info.quadData.silhouette)
				{
					continue;
				}
			}
			else if (MaterialExists_material.refFont != stm.font || MaterialExists_material.refTex != null || MaterialExists_material.refFilter != stm.filterMode)
			{
				continue;
			}
			if (!(info.textureData != null) || !(MaterialExists_material.refMask != info.textureData.texture))
			{
				return MaterialExists_material;
			}
		}
		return null;
	}

	public static SharedMaterialData DoesSharedMaterialExist(SuperTextMesh stm)
	{
		if (stm.uiMode)
		{
			Submesh_maskCanvas = MaskUtilities.FindRootSortOverrideCanvas(stm.t);
			Submesh_stencilDepth = MaskUtilities.GetStencilDepth(stm.t, Submesh_maskCanvas);
		}
		else
		{
			Submesh_stencilDepth = -1f;
		}
		for (int i = 0; i < allMaterials.Count; i++)
		{
			MaterialExists_material = allMaterials[i];
			if (MaterialExists_material != null && !(MaterialExists_material.refMat != stm.textMaterial) && MaterialExists_material.uiStencilDepth == Submesh_stencilDepth && MaterialExists_material.uiMaskMode == (int)stm.maskMode && !(MaterialExists_material.refMask != null) && !(MaterialExists_material.refFont != stm.font) && !(MaterialExists_material.refTex != null) && MaterialExists_material.refFilter == stm.filterMode && !(MaterialExists_material.refMask != null))
			{
				return MaterialExists_material;
			}
		}
		return null;
	}
}
[Serializable]
public class SharedMaterialData
{
	private Transform maskCanvas;

	public Material refMat;

	public Font refFont;

	public Texture refTex;

	public Texture refMask;

	public Vector2 maskTiling;

	public FilterMode refFilter;

	public float uiStencilDepth;

	public int uiMaskMode;

	private Material material;

	public string materialName;

	public Material AsMaterial
	{
		get
		{
			if (material == null)
			{
				material = new Material(refMat.shader);
			}
			else
			{
				material.shader = refMat.shader;
			}
			material.CopyPropertiesFromMaterial(refMat);
			material.SetTexture("_MainTex", refTex ?? refFont.material.mainTexture);
			material.SetTexture("_MaskTex", refMask);
			material.SetTextureScale("_MaskTex", maskTiling);
			if (material.HasProperty("_BaseMap"))
			{
				material.GetTexture("_BaseMap").filterMode = refFilter;
			}
			else if (material.HasProperty("_MainTex"))
			{
				material.GetTexture("_MainTex").filterMode = refFilter;
			}
			if (uiStencilDepth > -1f)
			{
				material.SetFloat("_MaskComp", (uiStencilDepth > 0f) ? 3f : 8f);
				material.SetFloat("_MaskMode", MaskDepthToID());
				material.SetFloat("_StencilOp", 0f);
				material.SetFloat("_StencilWriteMask", (uiStencilDepth > 0f) ? 0f : 255f);
				material.SetFloat("_StencilReadMask", (uiStencilDepth > 0f) ? MaskDepthToID() : 255f);
			}
			materialName = "";
			materialName += ((refMat != null) ? refMat.name : "NULL MATERTIAL");
			materialName += " - ";
			if (refFont != null)
			{
				materialName += refFont.name;
			}
			else if (refTex != null)
			{
				if (refMask != null)
				{
					materialName = materialName + refTex.name + "|" + refMask.name;
				}
				else
				{
					materialName = materialName + refTex.name + "|SILHOUETTE";
				}
			}
			else
			{
				materialName += "NULL";
			}
			materialName += " - ";
			materialName += refFilter;
			material.name = materialName;
			return material;
		}
	}

	public SharedMaterialData(SuperTextMesh stm)
	{
		SetValues(stm);
	}

	public SharedMaterialData(SuperTextMesh stm, STMTextInfo info)
	{
		SetValues(stm, info);
	}

	public void SetValues(SuperTextMesh stm)
	{
		refMat = stm.textMaterial;
		refFont = stm.font;
		refFilter = stm.filterMode;
		if (stm.uiMode)
		{
			maskCanvas = MaskUtilities.FindRootSortOverrideCanvas(stm.tr);
			uiStencilDepth = MaskUtilities.GetStencilDepth(stm.tr, maskCanvas);
			uiMaskMode = (int)stm.maskMode;
		}
		else
		{
			uiStencilDepth = -1f;
		}
	}

	public void SetValues(SuperTextMesh stm, STMTextInfo info)
	{
		refMat = ((info.materialData != null) ? info.materialData.material : stm.textMaterial);
		refFont = ((info.fontData != null) ? info.fontData.font : stm.font);
		if (info.isQuad)
		{
			refFont = null;
			if (info.quadData.overrideFilterMode)
			{
				refFilter = info.quadData.filterMode;
			}
			else
			{
				refFilter = stm.filterMode;
			}
		}
		else if (info.fontData != null)
		{
			if (info.fontData.overrideFilterMode)
			{
				refFilter = info.fontData.filterMode;
			}
			else
			{
				refFilter = stm.filterMode;
			}
		}
		else
		{
			refFilter = stm.filterMode;
		}
		refMask = ((info.textureData != null) ? info.textureData.texture : null);
		maskTiling = ((info.textureData != null) ? info.textureData.tiling : Vector2.one);
		if (info.isQuad && !info.quadData.silhouette)
		{
			refMask = info.quadData.texture;
		}
		refTex = (info.isQuad ? info.quadData.texture : null);
		if (info.isQuad)
		{
			maskTiling = Vector2.one;
		}
		if (stm.uiMode)
		{
			maskCanvas = MaskUtilities.FindRootSortOverrideCanvas(stm.tr);
			uiStencilDepth = MaskUtilities.GetStencilDepth(stm.tr, maskCanvas);
			uiMaskMode = (int)stm.maskMode;
		}
		else
		{
			uiStencilDepth = -1f;
		}
	}

	private float MaskDepthToID()
	{
		if (uiStencilDepth >= 8f)
		{
			Debug.Log("Attempting to use a mask with depth >= 8");
			return 0f;
		}
		return Mathf.Pow(2f, uiStencilDepth) - 1f + (float)uiMaskMode;
	}
}
[CreateAssetMenu(fileName = "New Text Data", menuName = "Super Text Mesh/Super Text Mesh Data", order = 0)]
public class SuperTextMeshData : ScriptableObject
{
	[HideInInspector]
	public bool textDataEditMode;

	[HideInInspector]
	public bool showEffectsFoldout;

	[HideInInspector]
	public bool showWavesFoldout;

	public Dictionary<string, STMWaveData> waves = new Dictionary<string, STMWaveData>();

	[HideInInspector]
	public bool showJittersFoldout;

	public Dictionary<string, STMJitterData> jitters = new Dictionary<string, STMJitterData>();

	[HideInInspector]
	public bool showDrawAnimsFoldout;

	public Dictionary<string, STMDrawAnimData> drawAnims = new Dictionary<string, STMDrawAnimData>();

	[HideInInspector]
	public bool showTextColorFoldout;

	[HideInInspector]
	public bool showColorsFoldout;

	public Dictionary<string, STMColorData> colors = new Dictionary<string, STMColorData>();

	[HideInInspector]
	public bool showGradientsFoldout;

	public Dictionary<string, STMGradientData> gradients = new Dictionary<string, STMGradientData>();

	[HideInInspector]
	public bool showTexturesFoldout;

	public Dictionary<string, STMTextureData> textures = new Dictionary<string, STMTextureData>();

	[HideInInspector]
	public bool showInlineFoldout;

	[HideInInspector]
	public bool showDelaysFoldout;

	public Dictionary<string, STMDelayData> delays = new Dictionary<string, STMDelayData>();

	[HideInInspector]
	public bool showVoicesFoldout;

	public Dictionary<string, STMVoiceData> voices = new Dictionary<string, STMVoiceData>();

	[HideInInspector]
	public bool showFontsFoldout;

	public Dictionary<string, STMFontData> fonts = new Dictionary<string, STMFontData>();

	[HideInInspector]
	public bool showSoundClipsFoldout;

	public Dictionary<string, STMSoundClipData> soundClips = new Dictionary<string, STMSoundClipData>();

	[HideInInspector]
	public bool showAudioClipsFoldout;

	public Dictionary<string, STMAudioClipData> audioClips = new Dictionary<string, STMAudioClipData>();

	[HideInInspector]
	public bool showQuadsFoldout;

	public Dictionary<string, STMQuadData> quads = new Dictionary<string, STMQuadData>();

	[HideInInspector]
	public bool showMaterialsFoldout;

	public Dictionary<string, STMMaterialData> materials = new Dictionary<string, STMMaterialData>();

	[HideInInspector]
	public bool showAutomaticFoldout;

	[HideInInspector]
	public bool showAutoClipsFoldout;

	public Dictionary<string, STMAutoClipData> autoClips = new Dictionary<string, STMAutoClipData>();

	[HideInInspector]
	public bool showAutoDelaysFoldout;

	public Dictionary<string, STMDelayData> autoDelays = new Dictionary<string, STMDelayData>();

	[HideInInspector]
	public bool showMasterFoldout = true;

	[Tooltip("This disables waves and jitters from effecting text position, which might be hard for some users to read.")]
	public bool disableAnimatedText;

	public Font defaultFont;

	public Color boundsColor = Color.blue;

	public Color textBoundsColor = Color.yellow;

	public Color finalTextBoundsColor = Color.grey;

	public float superscriptOffset = 0.5f;

	public float superscriptSize = 0.5f;

	public float subscriptOffset = -0.2f;

	public float subscriptSize = 0.5f;

	public void RebuildDictionaries()
	{
		waves = Resources.LoadAll<STMWaveData>("STMWaves").ToDictionary((STMWaveData x) => x.name, (STMWaveData x) => x);
		jitters = Resources.LoadAll<STMJitterData>("STMJitters").ToDictionary((STMJitterData x) => x.name, (STMJitterData x) => x);
		drawAnims = Resources.LoadAll<STMDrawAnimData>("STMDrawAnims").ToDictionary((STMDrawAnimData x) => x.name, (STMDrawAnimData x) => x);
		colors = Resources.LoadAll<STMColorData>("STMColors").ToDictionary((STMColorData x) => x.name, (STMColorData x) => x);
		gradients = Resources.LoadAll<STMGradientData>("STMGradients").ToDictionary((STMGradientData x) => x.name, (STMGradientData x) => x);
		textures = Resources.LoadAll<STMTextureData>("STMTextures").ToDictionary((STMTextureData x) => x.name, (STMTextureData x) => x);
		delays = Resources.LoadAll<STMDelayData>("STMDelays").ToDictionary((STMDelayData x) => x.name, (STMDelayData x) => x);
		voices = Resources.LoadAll<STMVoiceData>("STMVoices").ToDictionary((STMVoiceData x) => x.name, (STMVoiceData x) => x);
		fonts = Resources.LoadAll<STMFontData>("STMFonts").ToDictionary((STMFontData x) => x.name, (STMFontData x) => x);
		soundClips = Resources.LoadAll<STMSoundClipData>("STMSoundClips").ToDictionary((STMSoundClipData x) => x.name, (STMSoundClipData x) => x);
		audioClips = Resources.LoadAll<STMAudioClipData>("STMAudioClips").ToDictionary((STMAudioClipData x) => x.name, (STMAudioClipData x) => x);
		quads = Resources.LoadAll<STMQuadData>("STMQuads").ToDictionary((STMQuadData x) => x.name, (STMQuadData x) => x);
		materials = Resources.LoadAll<STMMaterialData>("STMMaterials").ToDictionary((STMMaterialData x) => x.name, (STMMaterialData x) => x);
		autoClips = Resources.LoadAll<STMAutoClipData>("STMAutoClips").ToDictionary((STMAutoClipData x) => x.name, (STMAutoClipData x) => x);
		autoDelays = Resources.LoadAll<STMDelayData>("STMAutoDelays").ToDictionary((STMDelayData x) => x.name, (STMDelayData x) => x);
	}
}
public static class SuperTextMeshExtension
{
	public static void SetAlpha(this SuperTextMesh textMesh, float alpha)
	{
		Color color = textMesh.color;
		color.a = alpha;
		textMesh.SetColor(color);
	}

	public static void SetColor(this SuperTextMesh textMesh, Color color)
	{
		textMesh.color = color;
		textMesh.Rebuild();
	}

	public static void SetTextAndRebuild(this SuperTextMesh textMesh, string text)
	{
		textMesh.text = text;
		textMesh.Rebuild();
	}
}
public class STMChangeSortingOrder : MonoBehaviour
{
	public int sortingOrder;

	public string sortingLayer = "Default";

	private void OnEnable()
	{
		Refresh();
	}

	private void OnValidate()
	{
		Refresh();
	}

	public void Refresh()
	{
		Renderer component = GetComponent<Renderer>();
		if (component != null)
		{
			component.sortingOrder = sortingOrder;
			component.sortingLayerName = sortingLayer;
		}
	}
}
public class OVRTeleporter : MonoBehaviour
{
	[SerializeField]
	[Required]
	private RayController _leftRayController;

	[SerializeField]
	[Required]
	private RayController _rightRayController;

	[SerializeField]
	private Transform _centerEyeAnchor;

	private Transform _transform;

	private void Awake()
	{
		_leftRayController.Stopped += TeleportIfNeeded;
		_rightRayController.Stopped += TeleportIfNeeded;
		_transform = base.transform;
	}

	private void TeleportIfNeeded(bool shouldTeleport, Vector3 teleportPosition, bool isLeft)
	{
		if (shouldTeleport)
		{
			float y = teleportPosition.y;
			teleportPosition -= _centerEyeAnchor.position - _transform.position;
			teleportPosition.y = y;
			_transform.position = teleportPosition;
		}
	}
}
public class RayController : MonoBehaviour
{
	public delegate bool DestinationChangeHandler(Vector3 destination);

	[SerializeField]
	[Required]
	private VRHand _targetHand;

	public LineRenderer lineRendererPrefab;

	[SerializeField]
	[Required]
	private GameObject _destination;

	private Material _destinationMaterial;

	[SerializeField]
	private Color _validColor;

	[SerializeField]
	private Color _invalidColor;

	private readonly LineRenderer[] _lineRenderers = new LineRenderer[70];

	private bool _pressing;

	private Vector3 _velocityRef = Vector3.zero;

	public bool IsLeft = true;

	private OVRInput.Button _targetButtonType;

	public LayerMask TargetLayer;

	private bool _reachable;

	private Vector3 _lastEndPoint;

	public event Action<bool, Vector3, bool> Stopped = delegate
	{
	};

	private void Awake()
	{
		_destinationMaterial = _destination.GetComponent<MeshRenderer>().material;
		_targetButtonType = (IsLeft ? OVRInput.Button.PrimaryThumbstickUp : OVRInput.Button.SecondaryThumbstickUp);
		for (int i = 0; i < _lineRenderers.Length; i++)
		{
			_lineRenderers[i] = UnityEngine.Object.Instantiate(lineRendererPrefab);
		}
	}

	private void FixedUpdate()
	{
		if (OVRInput.Get(_targetButtonType))
		{
			if (!_pressing)
			{
				_targetHand.Vibrate();
			}
			Vector3 position = base.transform.position;
			Vector3 vector = position;
			Vector3 vector2 = default(Vector3);
			Vector3 velocity = GetVelocity(base.transform.forward);
			int hitIndex = -1;
			_reachable = false;
			for (int i = 0; i < _lineRenderers.Length; i++)
			{
				vector2 = position + GetMovingPosition(velocity, i);
				if (Physics.Linecast(vector, vector2, out var hitInfo, TargetLayer))
				{
					vector2 = hitInfo.point;
					vector2.y = hitInfo.collider.transform.position.y;
					hitIndex = i;
					_reachable = true;
				}
				_lineRenderers[i].SetPosition(0, vector);
				_lineRenderers[i].SetPosition(1, vector2);
				vector = vector2;
				if (_reachable)
				{
					break;
				}
			}
			_lastEndPoint = vector2;
			_destination.SetActive(_reachable);
			_destination.transform.position = _lastEndPoint;
			_destination.transform.rotation = Quaternion.identity;
			DisplayTracing(_lineRenderers, hitIndex, _reachable);
			_pressing = true;
			return;
		}
		if (_destination.activeSelf)
		{
			_destination.SetActive(value: false);
		}
		if (_pressing)
		{
			_pressing = false;
			this.Stopped(_reachable, _lastEndPoint, IsLeft);
			if (_reachable)
			{
				_targetHand.Vibrate(0.2f);
			}
			LineRenderer[] lineRenderers = _lineRenderers;
			for (int j = 0; j < lineRenderers.Length; j++)
			{
				lineRenderers[j].gameObject.SetActive(value: false);
			}
		}
		_reachable = false;
	}

	private Vector3 GetVelocity(Vector3 direction)
	{
		int num = 5;
		Vector3 zero = Vector3.zero;
		zero.x = direction.x;
		zero.z = direction.z;
		float f = Mathf.Acos(Vector3.Dot(direction, zero) / (direction.magnitude * zero.magnitude));
		Vector2 lhs = new Vector2(direction.x, direction.z);
		Vector2 rhs = new Vector2(0f, direction.z);
		float f2 = Mathf.Acos(Vector2.Dot(lhs, rhs) / (lhs.magnitude * rhs.magnitude));
		_velocityRef.y = (float)num * Mathf.Sin(f) * Mathf.Sign(direction.y);
		_velocityRef.z = (float)num * Mathf.Cos(f) * Mathf.Cos(f2) * Mathf.Sign(direction.z);
		_velocityRef.x = (float)num * Mathf.Cos(f) * Mathf.Sin(f2) * Mathf.Sign(direction.x);
		_velocityRef.z *= 2f;
		_velocityRef.x *= 2f;
		return _velocityRef;
	}

	private Vector3 GetMovingPosition(Vector3 velocity, int lineIndex)
	{
		float num = (float)lineIndex / 30f;
		return new Vector3(velocity.x * num, velocity.y * num - 4.9f * num * num, velocity.z * num);
	}

	private void DisplayTracing(LineRenderer[] lineRenderers, int hitIndex, bool reachable)
	{
		if (lineRenderers.Length == 0)
		{
			return;
		}
		for (int i = 0; i < lineRenderers.Length; i++)
		{
			if (hitIndex >= 0)
			{
				if (reachable)
				{
					if (i <= hitIndex)
					{
						lineRenderers[i].gameObject.SetActive(value: true);
						lineRenderers[i].sharedMaterial.color = _validColor;
					}
					else
					{
						lineRenderers[i].gameObject.SetActive(value: false);
					}
				}
				else
				{
					lineRenderers[i].gameObject.SetActive(i <= hitIndex);
					lineRenderers[i].sharedMaterial.color = _invalidColor;
				}
			}
			else
			{
				lineRenderers[i].gameObject.SetActive(value: true);
				lineRenderers[i].sharedMaterial.color = _invalidColor;
			}
		}
		_destinationMaterial.color = lineRenderers[0].sharedMaterial.color;
	}
}
public class gestures_mocap_01_follow_player : MonoBehaviour
{
	public GameObject Player;

	public float cameraHeight = 10f;

	public float cameraDistance = 5f;

	private void Update()
	{
		Vector3 position = Player.transform.position;
		Debug.Log(position.x);
		position.y = cameraHeight;
		position.x = cameraDistance + position.x;
		base.transform.position = position;
	}
}
public class gestures_mocap_02_follow_player : MonoBehaviour
{
	public GameObject Player;

	public float cameraHeight = 10f;

	public float cameraDistance = 5f;

	private void Update()
	{
		Vector3 position = Player.transform.position;
		Debug.Log(position.x);
		position.y = cameraHeight;
		position.x = cameraDistance + position.x;
		base.transform.position = position;
	}
}
public class gestures_mocap_03_follow_player : MonoBehaviour
{
	public GameObject Player;

	public float cameraHeight = 10f;

	public float cameraDistance = 5f;

	private void Update()
	{
		Vector3 position = Player.transform.position;
		Debug.Log(position.x);
		position.y = cameraHeight;
		position.x = cameraDistance + position.x;
		base.transform.position = position;
	}
}
public class Dialogue : MonoBehaviour
{
	public void RemoveDialogue()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MenuEmofx : MonoBehaviour
{
	public GameObject Character;

	public GameObject Dialogue;

	private Animator _animator;

	private Emotion _emotion;

	private bool _start;

	private int _index;

	private GameObject _newDialogue;

	private void Start()
	{
		_animator = Character.GetComponent<Animator>();
		_emotion = Character.GetComponent<Emotion>();
		_start = false;
		_index = -1;
	}

	public void OnGUI()
	{
		if (!Character.GetComponent<Walk>().Finish)
		{
			return;
		}
		if (!_start && !Character.transform.Find("Dialogues").Find(Dialogue.name))
		{
			_newDialogue = UnityEngine.Object.Instantiate(Dialogue, Dialogue.transform.localPosition, Dialogue.transform.localRotation);
			_newDialogue.transform.parent = Character.transform.Find("Dialogues").transform;
			_newDialogue.transform.name = Dialogue.name;
		}
		int num = 200;
		int num2 = 80;
		int num3 = Mathf.RoundToInt((float)Screen.width * 0.5f - (float)num * 0.5f);
		int num4 = Mathf.RoundToInt((float)Screen.height - ((float)num2 + (float)num2 * 0.5f));
		GUI.BeginGroup(new Rect(num3, num4, num, num2));
		GUI.Box(new Rect(0f, 0f, num, num2), "Emotions");
		int num5 = num - 20;
		int num6 = 20;
		int num7 = Mathf.RoundToInt((float)num * 0.5f - (float)num5 * 0.5f);
		int num8 = Mathf.RoundToInt(num6);
		if (_start)
		{
			GUI.Label(new Rect(num7, num8, num5, num6), _emotion.Name(_index));
		}
		int num9 = 32;
		int num10 = 32;
		int num11 = Mathf.RoundToInt(0f);
		int num12 = Mathf.RoundToInt(0f);
		int num13 = Mathf.RoundToInt(num9 * 3);
		int num14 = Mathf.RoundToInt(num10);
		int num15 = Mathf.RoundToInt((float)num * 0.5f - (float)num13 * 0.5f);
		int num16 = Mathf.RoundToInt(num6 * 2);
		GUI.BeginGroup(new Rect(num15, num16, num13, num14));
		if (!_start && GUI.Button(new Rect(num11, num12, Mathf.RoundToInt(num9 * 3), num10), "Start"))
		{
			_start = true;
			_index++;
			if (_newDialogue != null)
			{
				_newDialogue.GetComponent<Animator>().SetBool("Hide", value: true);
			}
			_animator.SetBool("Anim" + _index, value: true);
			_emotion.AddEmotion(_index);
		}
		if (_start)
		{
			if (GUI.Button(new Rect(num11, num12, num9, num10), "<"))
			{
				_index = ((_index > 0) ? (_index - 1) : (_emotion.EmotionsLength - 1));
				int num17 = ((_index != _emotion.EmotionsLength - 1) ? (_index + 1) : 0);
				_animator.SetBool("Anim" + num17, value: false);
				_animator.SetBool("Anim" + _index, value: true);
				_emotion.RemoveEmotion(num17);
				_emotion.AddEmotion(_index);
			}
			if (GUI.Button(new Rect(Mathf.RoundToInt(num9 * 2), num12, num9, num10), ">"))
			{
				_index = ((_index < _emotion.EmotionsLength - 1) ? (_index + 1) : 0);
				int num18 = ((_index == 0) ? (_emotion.EmotionsLength - 1) : (_index - 1));
				_animator.SetBool("Anim" + num18, value: false);
				_animator.SetBool("Anim" + _index, value: true);
				_emotion.RemoveEmotion(num18);
				_emotion.AddEmotion(_index);
			}
		}
		GUI.EndGroup();
		GUI.EndGroup();
	}
}
public class Walk : MonoBehaviour
{
	public Transform EndPoint;

	public float Duration = 11f;

	private Vector3 _startPoint;

	private float _startTime;

	private bool _finish;

	public bool Finish => _finish;

	public void Start()
	{
		_startPoint = base.transform.position;
		_startTime = Time.time;
		GetComponent<Animator>().SetBool("Walk", value: true);
	}

	public void Update()
	{
		if (!Finish)
		{
			base.transform.position = Vector3.Lerp(_startPoint, EndPoint.localPosition, (Time.time - _startTime) / Duration);
			if (base.transform.position.x <= EndPoint.localPosition.x)
			{
				GetComponent<Animator>().SetBool("Walk", value: false);
				_finish = true;
			}
		}
	}
}
[AddComponentMenu("Lara Brothers/Emotion Effects/Ageing")]
[RequireComponent(typeof(ParticleSystem))]
public class AgeingEmofx : MonoBehaviour
{
	public bool DieOfEld;

	public void LateUpdate()
	{
		if (!GetComponent<ParticleSystem>().IsAlive())
		{
			if (!DieOfEld)
			{
				base.gameObject.SetActive(value: false);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
[AddComponentMenu("Lara Brothers/Emotion Effects/Emotion")]
public class Emotion : MonoBehaviour
{
	public GameObject Target;

	public GameObject[] Emotions;

	public Vector3[] Positions;

	public int EmotionsLength => Emotions.Length;

	public int PositionsLength => Positions.Length;

	public void Awake()
	{
		if (Emotions == null)
		{
			LogWarningMessage("The Emotions property is empty.");
		}
		if (Positions == null)
		{
			LogWarningMessage("The Positions property is empty.");
		}
		if (EmotionsLength != PositionsLength)
		{
			LogWarningMessage("The Length of the properties Emotions and Positions are not equals.");
		}
	}

	public void Start()
	{
		if (Target == null)
		{
			if ((bool)base.transform.Find("Emotions"))
			{
				Target = base.transform.Find("Emotions").gameObject;
			}
			else
			{
				LogWarningMessage("The Target property is not established.");
			}
		}
	}

	public void AddEmotion(int i)
	{
		GameObject obj = UnityEngine.Object.Instantiate(Emotions[i], new Vector3(0f, 0f, 0f), Emotions[i].transform.localRotation);
		obj.transform.parent = Target.transform;
		obj.transform.localPosition = Positions[i];
		obj.transform.name = Emotions[i].name;
	}

	public void RemoveEmotion(int i)
	{
		if ((bool)Target.transform.Find(Emotions[i].name))
		{
			UnityEngine.Object.Destroy(Target.transform.Find(Emotions[i].name).gameObject);
		}
	}

	public string Name(int i)
	{
		return Emotions[i].name;
	}

	private void LogErrorMessage(string msg)
	{
		Debug.LogError("Emotion: " + msg);
	}

	private void LogWarningMessage(string msg)
	{
		Debug.LogWarning("Emotion: " + msg);
	}
}
public class CameraShake : MonoBehaviour
{
	public float shakeTimer;

	public float shakeAmount;

	public static CameraShake myCameraShake;

	private Vector3 startPos;

	private void Awake()
	{
		myCameraShake = this;
		startPos = base.transform.position;
	}

	private void Update()
	{
		if (shakeTimer >= 0f)
		{
			Vector2 vector = UnityEngine.Random.insideUnitCircle * shakeAmount;
			base.transform.position = new Vector3(base.transform.position.x + vector.x * 0.3f, base.transform.position.y + vector.y, base.transform.position.z);
			shakeTimer -= Time.deltaTime;
		}
		else
		{
			base.transform.position = startPos;
		}
	}

	public void ShakeCamera(float shakePwr, float shakeDur)
	{
		shakeAmount = shakePwr;
		shakeTimer = shakeDur;
	}
}
public class LootBoxController : MonoBehaviour
{
	public int idIcon;

	public int idEffect;

	public bool isOpened;

	public GameObject[] IconPrefabs;

	public GameObject[] EffectPrefabs;

	public GameObject[] DesFxObjs;

	public GameObject[] DesIconObjs;

	private GameObject Lootbox;

	public Text effectsText;

	public Text nameEffectText;

	private void Start()
	{
		idEffect++;
		idIcon++;
		effectsText.text = "Type       " + idEffect + " / 25";
		nameEffectText.text = EffectPrefabs[idEffect].gameObject.name;
		SetupVfx();
		isOpened = false;
	}

	private void OnMouseDown()
	{
		if (!isOpened)
		{
			StartCoroutine(PlayFx());
		}
	}

	private IEnumerator PlayFx()
	{
		isOpened = true;
		idEffect = Mathf.Clamp(idEffect, 1, 25);
		effectsText.text = "Type       " + idEffect + " / 25";
		yield return new WaitForSeconds(0.2f);
		UnityEngine.Object.Destroy(Lootbox);
		Lootbox = UnityEngine.Object.Instantiate(IconPrefabs[2], base.transform.position, base.transform.rotation);
		yield return new WaitForSeconds(0.1f);
		UnityEngine.Object.Instantiate(EffectPrefabs[idEffect], base.transform.position, base.transform.rotation);
		CameraShake.myCameraShake.ShakeCamera(0.3f, 0.1f);
	}

	private IEnumerator PlayIcon()
	{
		DesIconObjs = GameObject.FindGameObjectsWithTag("Icon");
		GameObject[] desIconObjs = DesIconObjs;
		for (int i = 0; i < desIconObjs.Length; i++)
		{
			UnityEngine.Object.Destroy(desIconObjs[i].gameObject);
		}
		yield return new WaitForSeconds(0.1f);
		Lootbox = UnityEngine.Object.Instantiate(IconPrefabs[1], base.transform.position, base.transform.rotation);
	}

	public void ChangedFx(int i)
	{
		ResetVfx();
		idEffect += i;
		idEffect = Mathf.Clamp(idEffect, 1, 25);
		effectsText.text = "Type       " + idEffect + " / 25";
		nameEffectText.text = EffectPrefabs[idEffect].gameObject.name;
	}

	public void SetupVfx()
	{
		Lootbox = UnityEngine.Object.Instantiate(IconPrefabs[1], base.transform.position, base.transform.rotation);
	}

	public void PlayAllVfx()
	{
		if (!isOpened)
		{
			StartCoroutine(PlayFx());
		}
	}

	public void ResetVfx()
	{
		DesFxObjs = GameObject.FindGameObjectsWithTag("Effects");
		GameObject[] desFxObjs = DesFxObjs;
		for (int i = 0; i < desFxObjs.Length; i++)
		{
			UnityEngine.Object.Destroy(desFxObjs[i].gameObject);
		}
		isOpened = false;
		DesIconObjs = GameObject.FindGameObjectsWithTag("Icon");
		desFxObjs = DesIconObjs;
		for (int i = 0; i < desFxObjs.Length; i++)
		{
			UnityEngine.Object.Destroy(desFxObjs[i].gameObject);
		}
		StartCoroutine(PlayIcon());
	}
}
public class ManualScripts : MonoBehaviour
{
	public GameObject[] PageObj;

	public int currentPage;

	public int minPage = 1;

	public int maxPage = 5;

	public Text txtPage;

	private void Start()
	{
		for (int i = 0; i <= maxPage; i++)
		{
			PageObj[i].SetActive(value: false);
		}
		PageObj[minPage].SetActive(value: true);
		currentPage = minPage;
		txtPage.text = "PAGE " + currentPage + " / " + maxPage;
	}

	public void ChangedPage(int i)
	{
		currentPage = Mathf.Clamp(currentPage + i, minPage, maxPage);
		for (int j = 0; j <= maxPage; j++)
		{
			PageObj[j].SetActive(value: false);
		}
		PageObj[currentPage].SetActive(value: true);
		txtPage.text = "PAGE " + currentPage + " / " + maxPage;
	}
}
public class ToggleName : MonoBehaviour
{
	public GameObject[] nameEffectText;

	private void Start()
	{
		for (int i = 0; i < 4; i++)
		{
			nameEffectText[i].SetActive(value: true);
		}
	}

	public void ToggleChanged(bool isHide)
	{
		for (int i = 0; i < 4; i++)
		{
			nameEffectText[i].SetActive(!isHide);
		}
	}
}
public class CFX2_Demo : MonoBehaviour
{
	public bool orderedSpawns = true;

	public float step = 1f;

	public float range = 5f;

	private float order = -5f;

	public Material groundMat;

	public Material waterMat;

	public GameObject[] ParticleExamples;

	private int exampleIndex;

	private string randomSpawnsDelay = "0.5";

	private bool randomSpawns;

	private bool slowMo;

	private void OnMouseDown()
	{
		RaycastHit hitInfo = default(RaycastHit);
		if (GetComponent<Collider>().Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitInfo, 9999f))
		{
			GameObject gameObject = spawnParticle();
			gameObject.transform.position = hitInfo.point + gameObject.transform.position;
		}
	}

	private GameObject spawnParticle()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(ParticleExamples[exampleIndex]);
		gameObject.transform.position = new Vector3(0f, gameObject.transform.position.y, 0f);
		gameObject.SetActive(value: true);
		for (int i = 0; i < gameObject.transform.childCount; i++)
		{
			gameObject.transform.GetChild(i).gameObject.SetActive(value: true);
		}
		return gameObject;
	}

	private void OnGUI()
	{
		GUILayout.BeginArea(new Rect(5f, 20f, Screen.width - 10, 60f));
		GUILayout.BeginHorizontal();
		GUILayout.Label("Effect");
		if (GUILayout.Button("<"))
		{
			prevParticle();
		}
		GUILayout.Label(ParticleExamples[exampleIndex].name, GUILayout.Width(210f));
		if (GUILayout.Button(">"))
		{
			nextParticle();
		}
		GUILayout.Label("Click on the ground to spawn selected particles", GUILayout.Width(150f));
		if (GUILayout.Button(CFX_Demo_RotateCamera.rotating ? "Pause Camera" : "Rotate Camera"))
		{
			CFX_Demo_RotateCamera.rotating = !CFX_Demo_RotateCamera.rotating;
		}
		if (GUILayout.Button(randomSpawns ? "Stop Random Spawns" : "Start Random Spawns", GUILayout.Width(140f)))
		{
			randomSpawns = !randomSpawns;
			if (randomSpawns)
			{
				StartCoroutine("RandomSpawnsCoroutine");
			}
			else
			{
				StopCoroutine("RandomSpawnsCoroutine");
			}
		}
		randomSpawnsDelay = GUILayout.TextField(randomSpawnsDelay, 10, GUILayout.Width(42f));
		randomSpawnsDelay = Regex.Replace(randomSpawnsDelay, "[^0-9.]", "");
		if (GUILayout.Button(GetComponent<Renderer>().enabled ? "Hide Ground" : "Show Ground", GUILayout.Width(90f)))
		{
			GetComponent<Renderer>().enabled = !GetComponent<Renderer>().enabled;
		}
		if (GUILayout.Button(slowMo ? "Normal Speed" : "Slow Motion", GUILayout.Width(100f)))
		{
			slowMo = !slowMo;
			if (slowMo)
			{
				Time.timeScale = 0.33f;
			}
			else
			{
				Time.timeScale = 1f;
			}
		}
		GUILayout.EndHorizontal();
		GUILayout.EndArea();
	}

	private IEnumerator RandomSpawnsCoroutine()
	{
		while (true)
		{
			GameObject gameObject = spawnParticle();
			if (orderedSpawns)
			{
				gameObject.transform.position = base.transform.position + new Vector3(order, gameObject.transform.position.y, 0f);
				order -= step;
				if (order < 0f - range)
				{
					order = range;
				}
			}
			else
			{
				gameObject.transform.position = base.transform.position + new Vector3(UnityEngine.Random.Range(0f - range, range), 0f, UnityEngine.Random.Range(0f - range, range)) + new Vector3(0f, gameObject.transform.position.y, 0f);
			}
			yield return new WaitForSeconds(float.Parse(randomSpawnsDelay));
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			prevParticle();
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextParticle();
		}
	}

	private void prevParticle()
	{
		exampleIndex--;
		if (exampleIndex < 0)
		{
			exampleIndex = ParticleExamples.Length - 1;
		}
		if (ParticleExamples[exampleIndex].name.Contains("Splash") || ParticleExamples[exampleIndex].name.Contains("Skim"))
		{
			GetComponent<Renderer>().material = waterMat;
		}
		else
		{
			GetComponent<Renderer>().material = groundMat;
		}
	}

	private void nextParticle()
	{
		exampleIndex++;
		if (exampleIndex >= ParticleExamples.Length)
		{
			exampleIndex = 0;
		}
		if (ParticleExamples[exampleIndex].name.Contains("Splash") || ParticleExamples[exampleIndex].name.Contains("Skim"))
		{
			GetComponent<Renderer>().material = waterMat;
		}
		else
		{
			GetComponent<Renderer>().material = groundMat;
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class CFX_AutoStopLoopedEffect : MonoBehaviour
{
	public float effectDuration = 2.5f;

	private float d;

	private void OnEnable()
	{
		d = effectDuration;
	}

	private void Update()
	{
		if (!(d > 0f))
		{
			return;
		}
		d -= Time.deltaTime;
		if (d <= 0f)
		{
			GetComponent<ParticleSystem>().Stop(withChildren: true);
			CFX_Demo_Translate component = base.gameObject.GetComponent<CFX_Demo_Translate>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
	}
}
public class CFX_Demo_New : MonoBehaviour
{
	public Renderer groundRenderer;

	public Collider groundCollider;

	[Space]
	[Space]
	public Image slowMoBtn;

	public Text slowMoLabel;

	public Image camRotBtn;

	public Text camRotLabel;

	public Image groundBtn;

	public Text groundLabel;

	[Space]
	public Text EffectLabel;

	public Text EffectIndexLabel;

	private GameObject[] ParticleExamples;

	private int exampleIndex;

	private bool slowMo;

	private Vector3 defaultCamPosition;

	private Quaternion defaultCamRotation;

	private List<GameObject> onScreenParticles = new List<GameObject>();

	private void Awake()
	{
		List<GameObject> list = new List<GameObject>();
		int childCount = base.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			GameObject item = base.transform.GetChild(i).gameObject;
			list.Add(item);
		}
		list.Sort((GameObject o1, GameObject o2) => o1.name.CompareTo(o2.name));
		ParticleExamples = list.ToArray();
		defaultCamPosition = Camera.main.transform.position;
		defaultCamRotation = Camera.main.transform.rotation;
		StartCoroutine("CheckForDeletedParticles");
		UpdateUI();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			prevParticle();
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextParticle();
		}
		else if (Input.GetKeyDown(KeyCode.Delete))
		{
			destroyParticles();
		}
		if (Input.GetMouseButtonDown(0))
		{
			RaycastHit hitInfo = default(RaycastHit);
			if (groundCollider.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hitInfo, 9999f))
			{
				GameObject gameObject = spawnParticle();
				gameObject.transform.position = hitInfo.point + gameObject.transform.position;
			}
		}
		float axis = Input.GetAxis("Mouse ScrollWheel");
		if (axis != 0f)
		{
			Camera.main.transform.Translate(Vector3.forward * ((axis < 0f) ? (-1f) : 1f), Space.Self);
		}
		if (Input.GetMouseButtonDown(2))
		{
			Camera.main.transform.position = defaultCamPosition;
			Camera.main.transform.rotation = defaultCamRotation;
		}
	}

	public void OnToggleGround()
	{
		Color white = Color.white;
		groundRenderer.enabled = !groundRenderer.enabled;
		white.a = (groundRenderer.enabled ? 1f : 0.33f);
		groundBtn.color = white;
		groundLabel.color = white;
	}

	public void OnToggleCamera()
	{
		Color white = Color.white;
		CFX_Demo_RotateCamera.rotating = !CFX_Demo_RotateCamera.rotating;
		white.a = (CFX_Demo_RotateCamera.rotating ? 1f : 0.33f);
		camRotBtn.color = white;
		camRotLabel.color = white;
	}

	public void OnToggleSlowMo()
	{
		Color white = Color.white;
		slowMo = !slowMo;
		if (slowMo)
		{
			Time.timeScale = 0.33f;
			white.a = 1f;
		}
		else
		{
			Time.timeScale = 1f;
			white.a = 0.33f;
		}
		slowMoBtn.color = white;
		slowMoLabel.color = white;
	}

	public void OnPreviousEffect()
	{
		prevParticle();
	}

	public void OnNextEffect()
	{
		nextParticle();
	}

	private void UpdateUI()
	{
		EffectLabel.text = ParticleExamples[exampleIndex].name;
		EffectIndexLabel.text = string.Format("{0}/{1}", (exampleIndex + 1).ToString("00"), ParticleExamples.Length.ToString("00"));
	}

	private GameObject spawnParticle()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(ParticleExamples[exampleIndex]);
		gameObject.transform.position = new Vector3(0f, gameObject.transform.position.y, 0f);
		gameObject.SetActive(value: true);
		ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
		if (component != null && component.main.loop)
		{
			component.gameObject.AddComponent<CFX_AutoStopLoopedEffect>();
			component.gameObject.AddComponent<CFX_AutoDestructShuriken>();
		}
		onScreenParticles.Add(gameObject);
		return gameObject;
	}

	private IEnumerator CheckForDeletedParticles()
	{
		while (true)
		{
			yield return new WaitForSeconds(5f);
			for (int num = onScreenParticles.Count - 1; num >= 0; num--)
			{
				if (onScreenParticles[num] == null)
				{
					onScreenParticles.RemoveAt(num);
				}
			}
		}
	}

	private void prevParticle()
	{
		exampleIndex--;
		if (exampleIndex < 0)
		{
			exampleIndex = ParticleExamples.Length - 1;
		}
		UpdateUI();
	}

	private void nextParticle()
	{
		exampleIndex++;
		if (exampleIndex >= ParticleExamples.Length)
		{
			exampleIndex = 0;
		}
		UpdateUI();
	}

	private void destroyParticles()
	{
		for (int num = onScreenParticles.Count - 1; num >= 0; num--)
		{
			if (onScreenParticles[num] != null)
			{
				UnityEngine.Object.Destroy(onScreenParticles[num]);
			}
			onScreenParticles.RemoveAt(num);
		}
	}
}
public class CFX_Demo_RandomDir : MonoBehaviour
{
	public Vector3 min = new Vector3(0f, 0f, 0f);

	public Vector3 max = new Vector3(0f, 360f, 0f);

	private void Awake()
	{
		base.transform.eulerAngles = new Vector3(UnityEngine.Random.Range(min.x, max.x), UnityEngine.Random.Range(min.y, max.y), UnityEngine.Random.Range(min.z, max.z));
	}
}
public class CFX_Demo_RotateCamera : MonoBehaviour
{
	public static bool rotating = true;

	public float speed = 30f;

	public Transform rotationCenter;

	private void Update()
	{
		if (rotating)
		{
			base.transform.RotateAround(rotationCenter.position, Vector3.up, speed * Time.deltaTime);
		}
	}
}
public class CFX_Demo_Translate : MonoBehaviour
{
	public float speed = 30f;

	public Vector3 rotation = Vector3.forward;

	public Vector3 axis = Vector3.forward;

	public bool gravity;

	private Vector3 dir;

	private void Start()
	{
		dir = new Vector3(UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f));
		dir.Scale(rotation);
		base.transform.localEulerAngles = dir;
	}

	private void Update()
	{
		base.transform.Translate(axis * speed * Time.deltaTime, Space.Self);
	}
}
public class CFX2_AutoRotate : MonoBehaviour
{
	public Vector3 speed = new Vector3(0f, 40f, 0f);

	private void Update()
	{
		base.transform.Rotate(speed * Time.deltaTime);
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class CFX_AutoDestructShuriken : MonoBehaviour
{
	public bool OnlyDeactivate;

	private void OnEnable()
	{
		StartCoroutine("CheckIfAlive");
	}

	private IEnumerator CheckIfAlive()
	{
		ParticleSystem ps = GetComponent<ParticleSystem>();
		while (ps != null)
		{
			yield return new WaitForSeconds(0.5f);
			if (!ps.IsAlive(withChildren: true))
			{
				if (OnlyDeactivate)
				{
					base.gameObject.SetActive(value: false);
				}
				else
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
				break;
			}
		}
	}
}
public class CFX_AutodestructWhenNoChildren : MonoBehaviour
{
	private void Update()
	{
		if (base.transform.childCount == 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class CFX_InspectorHelp : MonoBehaviour
{
	public bool Locked;

	public string Title;

	public string HelpText;

	public int MsgType;

	[ContextMenu("Unlock editing")]
	private void Unlock()
	{
		Locked = false;
	}
}
[RequireComponent(typeof(Light))]
public class CFX_LightIntensityFade : MonoBehaviour
{
	public float duration = 1f;

	public float delay;

	public float finalIntensity;

	private float baseIntensity;

	public bool autodestruct;

	private float p_lifetime;

	private float p_delay;

	private void Start()
	{
		baseIntensity = GetComponent<Light>().intensity;
	}

	private void OnEnable()
	{
		p_lifetime = 0f;
		p_delay = delay;
		if (delay > 0f)
		{
			GetComponent<Light>().enabled = false;
		}
	}

	private void Update()
	{
		if (p_delay > 0f)
		{
			p_delay -= Time.deltaTime;
			if (p_delay <= 0f)
			{
				GetComponent<Light>().enabled = true;
			}
		}
		else if (p_lifetime / duration < 1f)
		{
			GetComponent<Light>().intensity = Mathf.Lerp(baseIntensity, finalIntensity, p_lifetime / duration);
			p_lifetime += Time.deltaTime;
		}
		else if (autodestruct)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class CFX_ShurikenThreadFix : MonoBehaviour
{
	private ParticleSystem[] systems;

	private void OnEnable()
	{
		systems = GetComponentsInChildren<ParticleSystem>();
		ParticleSystem[] array = systems;
		foreach (ParticleSystem obj in array)
		{
			obj.Stop(withChildren: true);
			obj.Clear(withChildren: true);
		}
		StartCoroutine("WaitFrame");
	}

	private IEnumerator WaitFrame()
	{
		yield return null;
		ParticleSystem[] array = systems;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Play(withChildren: true);
		}
	}
}
public class CFX_SpawnSystem : MonoBehaviour
{
	private static CFX_SpawnSystem instance;

	public GameObject[] objectsToPreload = new GameObject[0];

	public int[] objectsToPreloadTimes = new int[0];

	public bool hideObjectsInHierarchy;

	public bool spawnAsChildren = true;

	public bool onlyGetInactiveObjects;

	public bool instantiateIfNeeded;

	private bool allObjectsLoaded;

	private Dictionary<int, List<GameObject>> instantiatedObjects = new Dictionary<int, List<GameObject>>();

	private Dictionary<int, int> poolCursors = new Dictionary<int, int>();

	public static bool AllObjectsLoaded => instance.allObjectsLoaded;

	public static GameObject GetNextObject(GameObject sourceObj, bool activateObject = true)
	{
		int instanceID = sourceObj.GetInstanceID();
		if (!instance.poolCursors.ContainsKey(instanceID))
		{
			Debug.LogError("[CFX_SpawnSystem.GetNextObject()] Object hasn't been preloaded: " + sourceObj.name + " (ID:" + instanceID + ")\n", instance);
			return null;
		}
		int num = instance.poolCursors[instanceID];
		GameObject gameObject = null;
		if (instance.onlyGetInactiveObjects)
		{
			int num2 = num;
			while (true)
			{
				gameObject = instance.instantiatedObjects[instanceID][num];
				instance.increasePoolCursor(instanceID);
				num = instance.poolCursors[instanceID];
				if (gameObject != null && !gameObject.activeSelf)
				{
					break;
				}
				if (num == num2)
				{
					if (instance.instantiateIfNeeded)
					{
						Debug.Log("[CFX_SpawnSystem.GetNextObject()] A new instance has been created for \"" + sourceObj.name + "\" because no active instance were found in the pool.\n", instance);
						PreloadObject(sourceObj);
						List<GameObject> list = instance.instantiatedObjects[instanceID];
						gameObject = list[list.Count - 1];
						break;
					}
					Debug.LogWarning("[CFX_SpawnSystem.GetNextObject()] There are no active instances available in the pool for \"" + sourceObj.name + "\"\nYou may need to increase the preloaded object count for this prefab?", instance);
					return null;
				}
			}
		}
		else
		{
			gameObject = instance.instantiatedObjects[instanceID][num];
			instance.increasePoolCursor(instanceID);
		}
		if (activateObject && gameObject != null)
		{
			gameObject.SetActive(value: true);
		}
		return gameObject;
	}

	public static void PreloadObject(GameObject sourceObj, int poolSize = 1)
	{
		instance.addObjectToPool(sourceObj, poolSize);
	}

	public static void UnloadObjects(GameObject sourceObj)
	{
		instance.removeObjectsFromPool(sourceObj);
	}

	private void addObjectToPool(GameObject sourceObject, int number)
	{
		int instanceID = sourceObject.GetInstanceID();
		if (!instantiatedObjects.ContainsKey(instanceID))
		{
			instantiatedObjects.Add(instanceID, new List<GameObject>());
			poolCursors.Add(instanceID, 0);
		}
		for (int i = 0; i < number; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(sourceObject);
			gameObject.SetActive(value: false);
			CFX_AutoDestructShuriken[] componentsInChildren = gameObject.GetComponentsInChildren<CFX_AutoDestructShuriken>(includeInactive: true);
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				componentsInChildren[j].OnlyDeactivate = true;
			}
			CFX_LightIntensityFade[] componentsInChildren2 = gameObject.GetComponentsInChildren<CFX_LightIntensityFade>(includeInactive: true);
			for (int j = 0; j < componentsInChildren2.Length; j++)
			{
				componentsInChildren2[j].autodestruct = false;
			}
			instantiatedObjects[instanceID].Add(gameObject);
			if (hideObjectsInHierarchy)
			{
				gameObject.hideFlags = HideFlags.HideInHierarchy;
			}
			if (spawnAsChildren)
			{
				gameObject.transform.parent = base.transform;
			}
		}
	}

	private void removeObjectsFromPool(GameObject sourceObject)
	{
		int instanceID = sourceObject.GetInstanceID();
		if (!instantiatedObjects.ContainsKey(instanceID))
		{
			Debug.LogWarning("[CFX_SpawnSystem.removeObjectsFromPool()] There aren't any preloaded object for: " + sourceObject.name + " (ID:" + instanceID + ")\n", base.gameObject);
			return;
		}
		for (int num = instantiatedObjects[instanceID].Count - 1; num >= 0; num--)
		{
			GameObject obj = instantiatedObjects[instanceID][num];
			instantiatedObjects[instanceID].RemoveAt(num);
			UnityEngine.Object.Destroy(obj);
		}
		instantiatedObjects.Remove(instanceID);
		poolCursors.Remove(instanceID);
	}

	private void increasePoolCursor(int uniqueId)
	{
		instance.poolCursors[uniqueId]++;
		if (instance.poolCursors[uniqueId] >= instance.instantiatedObjects[uniqueId].Count)
		{
			instance.poolCursors[uniqueId] = 0;
		}
	}

	private void Awake()
	{
		if (instance != null)
		{
			Debug.LogWarning("CFX_SpawnSystem: There should only be one instance of CFX_SpawnSystem per Scene!\n", base.gameObject);
		}
		instance = this;
	}

	private void Start()
	{
		allObjectsLoaded = false;
		for (int i = 0; i < objectsToPreload.Length; i++)
		{
			PreloadObject(objectsToPreload[i], objectsToPreloadTimes[i]);
		}
		allObjectsLoaded = true;
	}
}
public class MagicProjectileScript : MonoBehaviour
{
	public GameObject impactParticle;

	public GameObject projectileParticle;

	public GameObject muzzleParticle;

	public GameObject[] trailParticles;

	[HideInInspector]
	public Vector3 impactNormal;

	private bool hasCollided;

	private void Start()
	{
		projectileParticle = UnityEngine.Object.Instantiate(projectileParticle, base.transform.position, base.transform.rotation);
		projectileParticle.transform.parent = base.transform;
		if ((bool)muzzleParticle)
		{
			muzzleParticle = UnityEngine.Object.Instantiate(muzzleParticle, base.transform.position, base.transform.rotation);
			UnityEngine.Object.Destroy(muzzleParticle, 1.5f);
		}
	}

	private void OnCollisionEnter(Collision hit)
	{
		if (hasCollided)
		{
			return;
		}
		hasCollided = true;
		impactParticle = UnityEngine.Object.Instantiate(impactParticle, base.transform.position, Quaternion.FromToRotation(Vector3.up, impactNormal));
		if (hit.gameObject.tag == "Destructible")
		{
			UnityEngine.Object.Destroy(hit.gameObject);
		}
		GameObject[] array = trailParticles;
		foreach (GameObject gameObject in array)
		{
			GameObject obj = base.transform.Find(projectileParticle.name + "/" + gameObject.name).gameObject;
			obj.transform.parent = null;
			UnityEngine.Object.Destroy(obj, 3f);
		}
		UnityEngine.Object.Destroy(projectileParticle, 3f);
		UnityEngine.Object.Destroy(impactParticle, 3f);
		UnityEngine.Object.Destroy(base.gameObject);
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		for (int j = 1; j < componentsInChildren.Length; j++)
		{
			ParticleSystem particleSystem = componentsInChildren[j];
			if (particleSystem.gameObject.name.Contains("Trail"))
			{
				particleSystem.transform.SetParent(null);
				UnityEngine.Object.Destroy(particleSystem.gameObject, 2f);
			}
		}
	}
}
public class ME_DemoGUI : MonoBehaviour
{
	public GameObject Character;

	public GameObject Model;

	public int Current;

	public GameObject[] Prefabs;

	public Light Sun;

	public ReflectionProbe ReflectionProbe;

	public Light[] NightLights = new Light[0];

	public Texture HUETexture;

	public bool UseMobileVersion;

	public GameObject MobileCharacter;

	public GameObject Target;

	public Color guiColor = Color.red;

	private int currentNomber;

	private GameObject characterInstance;

	private GameObject modelInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private GUIStyle guiStyleHeaderMobile = new GUIStyle();

	private float dpiScale;

	private bool isDay;

	private float colorHUE;

	private float startSunIntensity;

	private Quaternion startSunRotation;

	private Color startAmbientLight;

	private float startAmbientIntencity;

	private float startReflectionIntencity;

	private LightShadows startLightShadows;

	private bool isButtonPressed;

	private GameObject instanceShieldProjectile;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = guiColor;
		guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
		ChangeCurrent(Current);
		startSunIntensity = Sun.intensity;
		startSunRotation = Sun.transform.rotation;
		startAmbientLight = RenderSettings.ambientLight;
		startAmbientIntencity = RenderSettings.ambientIntensity;
		startReflectionIntencity = RenderSettings.reflectionIntensity;
		startLightShadows = Sun.shadows;
	}

	private void OnGUI()
	{
		if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
		{
			isButtonPressed = false;
		}
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(1);
		}
		float num = 0f;
		if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
		{
			isButtonPressed = true;
			if (ReflectionProbe != null)
			{
				ReflectionProbe.RenderProbe();
			}
			Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
			Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
			Light[] nightLights = NightLights;
			for (int i = 0; i < nightLights.Length; i++)
			{
				nightLights[i].shadows = ((!isDay) ? startLightShadows : LightShadows.None);
			}
			Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
			RenderSettings.ambientLight = ((!isDay) ? new Color(0.2f, 0.2f, 0.2f) : startAmbientLight);
			float num2 = ((!UseMobileVersion) ? 1f : 0.3f);
			RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : num2);
			RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
			isDay = !isDay;
		}
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale + num / 2f, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + Prefabs[currentNomber].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
		GUI.DrawTexture(new Rect(12f * dpiScale, 140f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num3 = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 147f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), colorHUE, 0f, 360f);
		if ((double)Mathf.Abs(num3 - colorHUE) > 0.001)
		{
			PSMeshRendererUpdater componentInChildren = characterInstance.GetComponentInChildren<PSMeshRendererUpdater>();
			if (componentInChildren != null)
			{
				componentInChildren.UpdateColor(colorHUE / 360f);
			}
			componentInChildren = modelInstance.GetComponentInChildren<PSMeshRendererUpdater>();
			if (componentInChildren != null)
			{
				componentInChildren.UpdateColor(colorHUE / 360f);
			}
		}
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (characterInstance != null)
		{
			UnityEngine.Object.Destroy(characterInstance);
			RemoveClones();
		}
		if (modelInstance != null)
		{
			UnityEngine.Object.Destroy(modelInstance);
			RemoveClones();
		}
		characterInstance = UnityEngine.Object.Instantiate(Character);
		characterInstance.GetComponent<ME_AnimatorEvents>().EffectPrefab = Prefabs[currentNomber];
		modelInstance = UnityEngine.Object.Instantiate(Model);
		GameObject obj = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
		obj.transform.parent = modelInstance.transform;
		obj.transform.localPosition = Vector3.zero;
		obj.transform.localRotation = default(Quaternion);
		obj.GetComponent<PSMeshRendererUpdater>().UpdateMeshEffect(modelInstance);
		if (UseMobileVersion)
		{
			CancelInvoke("ReactivateEffect");
		}
	}

	private void RemoveClones()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Contains("(Clone)"))
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
	}

	private void ReactivateEffect()
	{
		characterInstance.SetActive(value: false);
		characterInstance.SetActive(value: true);
		modelInstance.SetActive(value: false);
		modelInstance.SetActive(value: true);
	}
}
public class ME_MouseOrbit : MonoBehaviour
{
	public GameObject target;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private float prevDistance;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
	}

	private void LateUpdate()
	{
		if (distance < 2f)
		{
			distance = 2f;
		}
		distance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
		if ((bool)target && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			Vector3 mousePosition = Input.mousePosition;
			float num = 1f;
			if (Screen.dpi < 1f)
			{
				num = 1f;
			}
			num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
			if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
			{
				return;
			}
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
			x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
		else
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		if (Math.Abs(prevDistance - distance) > 0.001f)
		{
			prevDistance = distance;
			Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
			Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion2;
			base.transform.position = position2;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class ME_RealtimeReflection : MonoBehaviour
{
	private ReflectionProbe probe;

	private Transform camT;

	public bool CanUpdate = true;

	private void Awake()
	{
		probe = GetComponent<ReflectionProbe>();
		camT = Camera.main.transform;
	}

	private void Update()
	{
		Vector3 position = camT.position;
		probe.transform.position = new Vector3(position.x, position.y * -1f, position.z);
		if (CanUpdate)
		{
			probe.RenderProbe();
		}
	}
}
public class ME_AnimatorEvents : MonoBehaviour
{
	public GameObject EffectPrefab;

	public GameObject SwordPrefab;

	public Transform SwordPosition;

	public Transform StartSwordPosition;

	private GameObject EffectInstance;

	private GameObject SwordInstance;

	private void Start()
	{
		if (SwordInstance != null)
		{
			UnityEngine.Object.Destroy(SwordInstance);
		}
		SwordInstance = UnityEngine.Object.Instantiate(SwordPrefab, StartSwordPosition.position, StartSwordPosition.rotation);
		SwordInstance.transform.parent = StartSwordPosition.transform;
	}

	public void ActivateEffect()
	{
		if (!(EffectPrefab == null) && !(SwordInstance == null))
		{
			if (EffectInstance != null)
			{
				UnityEngine.Object.Destroy(EffectInstance);
			}
			EffectInstance = UnityEngine.Object.Instantiate(EffectPrefab);
			EffectInstance.transform.parent = SwordInstance.transform;
			EffectInstance.transform.localPosition = Vector3.zero;
			EffectInstance.transform.localRotation = default(Quaternion);
			EffectInstance.GetComponent<PSMeshRendererUpdater>().UpdateMeshEffect(SwordInstance);
		}
	}

	public void ActivateSword()
	{
		SwordInstance.transform.parent = SwordPosition.transform;
		SwordInstance.transform.position = SwordPosition.position;
		SwordInstance.transform.rotation = SwordPosition.rotation;
	}

	public void UpdateColor(float HUE)
	{
		if (!(EffectInstance == null))
		{
			ME_EffectSettingColor mE_EffectSettingColor = EffectInstance.GetComponent<ME_EffectSettingColor>();
			if (mE_EffectSettingColor == null)
			{
				mE_EffectSettingColor = EffectInstance.AddComponent<ME_EffectSettingColor>();
			}
			ME_ColorHelper.HSBColor hsbColor = ME_ColorHelper.ColorToHSV(mE_EffectSettingColor.Color);
			hsbColor.H = HUE;
			mE_EffectSettingColor.Color = ME_ColorHelper.HSVToColor(hsbColor);
		}
	}
}
public static class ME_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material[] array = (UnityEngine.Application.isPlaying ? renderer.materials : renderer.sharedMaterials);
			if (array.Length == 0)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name in array2)
			{
				Material[] array3 = array;
				foreach (Material material in array3)
				{
					if (material != null && material.HasProperty(name))
					{
						setMatHUEColor(material, name, hue);
					}
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array2 = colorProperties;
			foreach (string name2 in array2)
			{
				if (trailMaterial != null && trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren3)
		{
			Material[] array4 = (UnityEngine.Application.isPlaying ? skinnedMeshRenderer.materials : skinnedMeshRenderer.sharedMaterials);
			if (array4.Length == 0)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name3 in array2)
			{
				Material[] array3 = array4;
				foreach (Material material3 in array3)
				{
					if (material3 != null && material3.HasProperty(name3))
					{
						setMatHUEColor(material3, name3, hue);
					}
				}
			}
		}
		Projector[] componentsInChildren4 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren4)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material4 = projector.material;
			if (material4 == null)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name4 in array2)
			{
				if (material4 != null && material4.HasProperty(name4))
				{
					projector.material = setMatHUEColor(material4, name4, hue);
				}
			}
		}
		Light[] componentsInChildren5 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren5)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren6 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren6)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int l = 1; l < colorKeys.Length; l++)
			{
				hsbColor2 = ColorToHSV(colorKeys[l].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[l].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class ME_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		Update();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		float h = ME_ColorHelper.ColorToHSV(Color).H;
		ME_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		previousColor = Color;
	}
}
[ExecuteInEditMode]
public class ME_CustomLight : MonoBehaviour
{
	private static int MaxLightsCount = 10;

	private Texture2D PointLightAttenuation;

	private List<Light> sceneLights;

	private void Awake()
	{
		Shader.SetGlobalTexture("ME_PointLightAttenuation", PointLightAttenuation);
		Shader.SetGlobalVectorArray("ME_LightPositions", ListToArrayWithMaxCount(null, MaxLightsCount));
		Shader.SetGlobalVectorArray("ME_LightColors", ListToArrayWithMaxCount(null, MaxLightsCount));
		sceneLights = UnityEngine.Object.FindObjectsOfType<Light>().ToList();
		PointLightAttenuation = GeneratePointAttenuationTexture();
		Shader.SetGlobalTexture("ME_PointLightAttenuation", PointLightAttenuation);
	}

	private void Update()
	{
		List<Light> allLights = GetAllLights();
		int num = 0;
		List<Vector4> list = new List<Vector4>();
		List<Vector4> list2 = new List<Vector4>();
		num += FillDirectionalLights(allLights, list, list2);
		allLights = SortPointLightsByDistance(allLights);
		num += FillPointLights(allLights, list, list2);
		Shader.SetGlobalInt("ME_LightCount", num);
		Shader.SetGlobalVectorArray("ME_LightPositions", ListToArrayWithMaxCount(list, MaxLightsCount));
		Shader.SetGlobalVectorArray("ME_LightColors", ListToArrayWithMaxCount(list2, MaxLightsCount));
		Color value = SampleLightProbesUp(base.transform.position, 0.5f);
		Shader.SetGlobalColor("ME_AmbientColor", value);
	}

	private void OnDisable()
	{
		Shader.SetGlobalInt("ME_LightCount", 0);
		Shader.SetGlobalVectorArray("ME_LightPositions", new Vector4[1] { Vector4.zero });
		Shader.SetGlobalVectorArray("ME_LightColors", new Vector4[1] { Vector4.zero });
		Shader.SetGlobalColor("ME_AmbientColor", Color.black);
	}

	private List<Light> GetAllLights()
	{
		List<Light> list = base.transform.root.GetComponentsInChildren<Light>().ToList();
		foreach (Light sceneLight in sceneLights)
		{
			if (sceneLight != null)
			{
				list.Add(sceneLight);
			}
		}
		return list;
	}

	private int FillDirectionalLights(List<Light> lights, List<Vector4> lightPositions, List<Vector4> lightColors)
	{
		int num = 0;
		for (int i = 0; i < lights.Count; i++)
		{
			if (lights[i].isActiveAndEnabled && lights[i].type == LightType.Directional)
			{
				Vector3 vector = -lights[i].transform.forward;
				lightPositions.Add(new Vector4(vector.x, vector.y, vector.z, 0f));
				Color color = lights[i].color * lights[i].intensity;
				lightColors.Add(new Vector4(color.r, color.g, color.b, 0f));
				num++;
			}
		}
		return num;
	}

	private int FillPointLights(List<Light> lights, List<Vector4> lightPositions, List<Vector4> lightColors)
	{
		int num = 0;
		for (int i = 0; i < lights.Count; i++)
		{
			if (lights[i].isActiveAndEnabled && lights[i].type == LightType.Point)
			{
				Vector3 position = lights[i].transform.position;
				lightPositions.Add(new Vector4(position.x, position.y, position.z, lights[i].range));
				Color color = lights[i].color * lights[i].intensity;
				lightColors.Add(new Vector4(color.r, color.g, color.b, 1f));
				num++;
			}
		}
		return num;
	}

	private Vector4[] ListToArrayWithMaxCount(List<Vector4> list, int count)
	{
		Vector4[] array = new Vector4[count];
		for (int i = 0; i < count; i++)
		{
			if (list != null && list.Count > i)
			{
				array[i] = list[i];
			}
			else
			{
				array[i] = Vector4.zero;
			}
		}
		return array;
	}

	private List<Light> SortPointLightsByDistance(List<Light> lights)
	{
		Vector3 position = base.transform.position;
		SortedDictionary<float, Light> sortedDictionary = new SortedDictionary<float, Light>();
		foreach (Light light in lights)
		{
			float key = (position - light.transform.position).magnitude + UnityEngine.Random.Range(-10000f, 10000f) / 1000000f;
			if (!sortedDictionary.ContainsKey(key))
			{
				sortedDictionary.Add(key, light);
			}
		}
		return sortedDictionary.Values.ToList();
	}

	public Color SampleLightProbesUp(Vector3 pos, float grayScaleFactor)
	{
		LightProbes.GetInterpolatedProbe(pos, null, out var probe);
		Vector4 a = new Vector4(probe[0, 3], probe[0, 1], probe[0, 2], probe[0, 0] - probe[0, 6]);
		Vector4 a2 = new Vector4(probe[1, 3], probe[1, 1], probe[1, 2], probe[1, 0] - probe[1, 6]);
		Vector4 a3 = new Vector4(probe[2, 3], probe[2, 1], probe[2, 2], probe[2, 0] - probe[2, 6]);
		Vector4 a4 = new Vector4(probe[0, 4], probe[0, 6], probe[0, 5] * 3f, probe[0, 7]);
		Vector4 a5 = new Vector4(probe[1, 4], probe[1, 6], probe[1, 5] * 3f, probe[1, 7]);
		Vector4 a6 = new Vector4(probe[2, 4], probe[2, 6], probe[2, 5] * 3f, probe[2, 7]);
		Vector3 vector = new Vector3(probe[0, 8], probe[2, 8], probe[1, 8]);
		Vector4 b = new Vector4(0f, 1f, 0f, 1f);
		Color black = Color.black;
		black.r = Vector4.Dot(a, b);
		black.g = Vector4.Dot(a2, b);
		black.b = Vector4.Dot(a3, b);
		Vector4 b2 = new Vector4(b.x * b.y, b.y * b.z, b.z * b.z, b.z * b.x);
		Color black2 = Color.black;
		black2.r = Vector4.Dot(a4, b2);
		black2.g = Vector4.Dot(a5, b2);
		black2.b = Vector4.Dot(a6, b2);
		float num = b.x * b.x - b.y * b.y;
		Vector3 vector2 = vector * num;
		Color color = new Color(vector2.x, vector2.y, vector2.z);
		Color a7 = black + black2 + color;
		float num2 = a7.r * 0.33f + a7.g * 0.33f + a7.b * 0.33f;
		a7 = Color.Lerp(a7, Color.white * num2, grayScaleFactor);
		if (QualitySettings.activeColorSpace == ColorSpace.Gamma)
		{
			return (black + black2 + color).gamma;
		}
		return a7;
	}

	private Texture2D GeneratePointAttenuationTexture()
	{
		Texture2D texture2D = new Texture2D(256, 1);
		texture2D.wrapMode = TextureWrapMode.Clamp;
		for (int i = 0; i < 256; i++)
		{
			float num = (float)i / 256f;
			float num2 = Mathf.Clamp01(1f / (1f + 25f * num * num) * Mathf.Clamp01((1f - num) * 5f));
			texture2D.SetPixel(i, 0, Color.white * num2);
		}
		texture2D.Apply();
		return texture2D;
	}
}
public class ME_FixParticlesAligment : MonoBehaviour
{
	private void Start()
	{
		GetComponent<ParticleSystem>().GetComponent<ParticleSystemRenderer>().alignment = ParticleSystemRenderSpace.World;
	}
}
public class ME_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class ME_MeshMaterialEffect : MonoBehaviour
{
	public Material Material;

	public bool IsFirstMaterial;
}
[ExecuteInEditMode]
public class ME_ParticleCollisionDecal : MonoBehaviour
{
	public ParticleSystem DecalParticles;

	public bool IsBilboard;

	public bool InstantiateWhenZeroSpeed;

	public float MaxGroundAngleDeviation = 45f;

	public float MinDistanceBetweenDecals = 0.1f;

	public float MinDistanceBetweenSurface = 0.03f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem.Particle[] particles;

	private ParticleSystem initiatorPS;

	private List<GameObject> collidedGameObjects = new List<GameObject>();

	private void OnEnable()
	{
		collisionEvents.Clear();
		collidedGameObjects.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[DecalParticles.main.maxParticles];
		if (InstantiateWhenZeroSpeed)
		{
			InvokeRepeating("CollisionDetect", 0f, 0.1f);
		}
	}

	private void OnDisable()
	{
		if (InstantiateWhenZeroSpeed)
		{
			CancelInvoke("CollisionDetect");
		}
	}

	private void CollisionDetect()
	{
		int aliveParticles = 0;
		if (InstantiateWhenZeroSpeed)
		{
			aliveParticles = DecalParticles.GetParticles(particles);
		}
		foreach (GameObject collidedGameObject in collidedGameObjects)
		{
			OnParticleCollisionManual(collidedGameObject, aliveParticles);
		}
	}

	private void OnParticleCollisionManual(GameObject other, int aliveParticles = -1)
	{
		collisionEvents.Clear();
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			if (Vector3.Angle(collisionEvents[i].normal, Vector3.up) > MaxGroundAngleDeviation)
			{
				continue;
			}
			if (InstantiateWhenZeroSpeed)
			{
				if (collisionEvents[i].velocity.sqrMagnitude > 0.1f)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < aliveParticles; j++)
				{
					if (Vector3.Distance(collisionEvents[i].intersection, particles[j].position) < MinDistanceBetweenDecals)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
			emitParams.position = collisionEvents[i].intersection + collisionEvents[i].normal * MinDistanceBetweenSurface;
			Vector3 eulerAngles = Quaternion.LookRotation(-collisionEvents[i].normal).eulerAngles;
			eulerAngles.z = UnityEngine.Random.Range(0, 360);
			emitParams.rotation3D = eulerAngles;
			DecalParticles.Emit(emitParams, 1);
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (InstantiateWhenZeroSpeed)
		{
			if (!collidedGameObjects.Contains(other))
			{
				collidedGameObjects.Add(other);
			}
		}
		else
		{
			OnParticleCollisionManual(other);
		}
	}
}
[ExecuteInEditMode]
public class ME_ParticleGravityPoint : MonoBehaviour
{
	public Transform target;

	public float Force = 1f;

	public bool DistanceRelative;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private Vector3 prevPos;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void LateUpdate()
	{
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = target.position;
		}
		float num2 = Time.deltaTime * Force;
		if (DistanceRelative)
		{
			num2 *= Mathf.Abs((prevPos - vector).magnitude);
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position);
			if (DistanceRelative)
			{
				vector2 = Vector3.Normalize(vector - prevPos);
			}
			Vector3 vector3 = vector2 * num2;
			particles[i].velocity += vector3;
		}
		ps.SetParticles(particles, num);
		prevPos = vector;
	}
}
public class ME_ParticleTrails : MonoBehaviour
{
	public GameObject TrailPrefab;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private Dictionary<uint, GameObject> hashTrails = new Dictionary<uint, GameObject>();

	private Dictionary<uint, GameObject> newHashTrails = new Dictionary<uint, GameObject>();

	private List<GameObject> currentGO = new List<GameObject>();

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
	}

	private void OnEnable()
	{
		InvokeRepeating("ClearEmptyHashes", 1f, 1f);
	}

	private void OnDisable()
	{
		Clear();
		CancelInvoke("ClearEmptyHashes");
	}

	public void Clear()
	{
		foreach (GameObject item in currentGO)
		{
			UnityEngine.Object.Destroy(item);
		}
		currentGO.Clear();
	}

	private void Update()
	{
		UpdateTrail();
	}

	private void UpdateTrail()
	{
		newHashTrails.Clear();
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			if (!hashTrails.ContainsKey(particles[i].randomSeed))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(TrailPrefab, base.transform.position, default(Quaternion));
				gameObject.transform.parent = base.transform;
				currentGO.Add(gameObject);
				newHashTrails.Add(particles[i].randomSeed, gameObject);
				gameObject.GetComponent<LineRenderer>().widthMultiplier *= particles[i].startSize;
				continue;
			}
			GameObject gameObject2 = hashTrails[particles[i].randomSeed];
			if (gameObject2 != null)
			{
				LineRenderer component = gameObject2.GetComponent<LineRenderer>();
				component.startColor *= (Color)particles[i].GetCurrentColor(ps);
				component.endColor *= (Color)particles[i].GetCurrentColor(ps);
				if (ps.main.simulationSpace == ParticleSystemSimulationSpace.World)
				{
					gameObject2.transform.position = particles[i].position;
				}
				if (ps.main.simulationSpace == ParticleSystemSimulationSpace.Local)
				{
					gameObject2.transform.position = ps.transform.TransformPoint(particles[i].position);
				}
				newHashTrails.Add(particles[i].randomSeed, gameObject2);
			}
			hashTrails.Remove(particles[i].randomSeed);
		}
		foreach (KeyValuePair<uint, GameObject> hashTrail in hashTrails)
		{
			if (hashTrail.Value != null)
			{
				hashTrail.Value.GetComponent<ME_TrailRendererNoise>().IsActive = false;
			}
		}
		AddRange(hashTrails, newHashTrails);
	}

	public void AddRange<T, S>(Dictionary<T, S> source, Dictionary<T, S> collection)
	{
		if (collection == null)
		{
			return;
		}
		foreach (KeyValuePair<T, S> item in collection)
		{
			if (!source.ContainsKey(item.Key))
			{
				source.Add(item.Key, item.Value);
			}
		}
	}

	private void ClearEmptyHashes()
	{
		hashTrails = hashTrails.Where((KeyValuePair<uint, GameObject> h) => h.Value != null).ToDictionary((KeyValuePair<uint, GameObject> h) => h.Key, (KeyValuePair<uint, GameObject> h) => h.Value);
	}
}
public class ME_Reflection : MonoBehaviour
{
	public RenderTexture tex;

	private ReflectionProbe reflectionProbe;

	private List<Light> dirLight;

	private List<float> lightIntencity;

	private void Awake()
	{
		Light[] array = UnityEngine.Object.FindObjectsOfType<Light>();
		dirLight = new List<Light>();
		lightIntencity = new List<float>();
		Light[] array2 = array;
		foreach (Light light in array2)
		{
			if (light.type == LightType.Directional)
			{
				dirLight.Add(light);
				lightIntencity.Add(light.intensity);
			}
		}
		reflectionProbe = GetComponent<ReflectionProbe>();
		tex = new RenderTexture(reflectionProbe.resolution, reflectionProbe.resolution, 0);
		tex.dimension = TextureDimension.Cube;
		tex.useMipMap = true;
		Shader.SetGlobalTexture("ME_Reflection", tex);
		reflectionProbe.RenderProbe(tex);
	}

	private void Update()
	{
		bool flag = false;
		for (int i = 0; i < dirLight.Count; i++)
		{
			if (Math.Abs(dirLight[i].intensity - lightIntencity[i]) > 0.001f)
			{
				flag = true;
				lightIntencity[i] = dirLight[i].intensity;
			}
		}
		if (flag)
		{
			reflectionProbe.RenderProbe(tex);
		}
	}
}
public class ME_TrailRendererNoise : MonoBehaviour
{
	[Range(0.01f, 10f)]
	public float MinVertexDistance = 0.1f;

	public float VertexTime = 1f;

	public float TotalLifeTime = 3f;

	public bool SmoothCurves;

	public bool IsRibbon;

	public bool IsActive = true;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float TimeScale = 0.1f;

	[Range(0.001f, 10f)]
	public float Amplitude = 1f;

	public float Gravity = 1f;

	public float TurbulenceStrength = 1f;

	public bool AutodestructWhenNotActive;

	private LineRenderer lineRenderer;

	private Transform t;

	private Vector3 prevPos;

	private List<Vector3> points = new List<Vector3>(500);

	private List<float> lifeTimes = new List<float>(500);

	private List<Vector3> velocities = new List<Vector3>(500);

	private float randomOffset;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private void Start()
	{
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.useWorldSpace = true;
		t = base.transform;
		prevPos = t.position;
		points.Insert(0, t.position);
		lifeTimes.Insert(0, VertexTime);
		velocities.Insert(0, Vector3.zero);
		randomOffset = (float)UnityEngine.Random.Range(0, 10000000) / 1000000f;
	}

	private void OnEnable()
	{
		points.Clear();
		lifeTimes.Clear();
		velocities.Clear();
	}

	private void Update()
	{
		if (IsActive)
		{
			AddNewPoints();
		}
		UpdatetPoints();
		if (SmoothCurves && points.Count > 2)
		{
			UpdateLineRendererBezier();
		}
		else
		{
			UpdateLineRenderer();
		}
		if (AutodestructWhenNotActive && !IsActive && points.Count <= 1)
		{
			UnityEngine.Object.Destroy(base.gameObject, TotalLifeTime);
		}
	}

	private void AddNewPoints()
	{
		if ((t.position - prevPos).magnitude > MinVertexDistance || (IsRibbon && points.Count == 0) || (IsRibbon && points.Count > 0 && (t.position - points[0]).magnitude > MinVertexDistance))
		{
			prevPos = t.position;
			points.Insert(0, t.position);
			lifeTimes.Insert(0, VertexTime);
			velocities.Insert(0, Vector3.zero);
		}
	}

	private void UpdatetPoints()
	{
		for (int i = 0; i < lifeTimes.Count; i++)
		{
			lifeTimes[i] -= Time.deltaTime;
			if (lifeTimes[i] <= 0f)
			{
				int count = lifeTimes.Count - i;
				lifeTimes.RemoveRange(i, count);
				points.RemoveRange(i, count);
				velocities.RemoveRange(i, count);
				break;
			}
			CalculateTurbuelence(points[i], TimeScale, Frequency, Amplitude, Gravity, i);
		}
	}

	private void UpdateLineRendererBezier()
	{
		if (SmoothCurves && points.Count > 2)
		{
			InterpolateBezier(points, 0.5f);
			List<Vector3> drawingPoints = GetDrawingPoints();
			lineRenderer.positionCount = drawingPoints.Count - 1;
			lineRenderer.SetPositions(drawingPoints.ToArray());
		}
	}

	private void UpdateLineRenderer()
	{
		lineRenderer.positionCount = Mathf.Clamp(points.Count - 1, 0, int.MaxValue);
		lineRenderer.SetPositions(points.ToArray());
	}

	private void CalculateTurbuelence(Vector3 position, float speed, float scale, float height, float gravity, int index)
	{
		float num = Time.timeSinceLevelLoad * speed + randomOffset;
		float x = position.x * scale + num;
		float num2 = position.y * scale + num + 10f;
		float y = position.z * scale + num + 25f;
		position.x = (Mathf.PerlinNoise(num2, y) - 0.5f) * height * Time.deltaTime;
		position.y = (Mathf.PerlinNoise(x, y) - 0.5f) * height * Time.deltaTime - gravity * Time.deltaTime;
		position.z = (Mathf.PerlinNoise(x, num2) - 0.5f) * height * Time.deltaTime;
		points[index] += position * TurbulenceStrength;
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1] - vector;
				Vector3 item = vector + scale * vector2;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector3 = segmentPoints[i - 1];
				Vector3 vector4 = segmentPoints[i];
				Vector3 vector5 = vector4 - vector3;
				Vector3 item2 = vector4 - scale * vector5;
				controlPoints.Add(item2);
				controlPoints.Add(vector4);
			}
			else
			{
				Vector3 vector6 = segmentPoints[i - 1];
				Vector3 vector7 = segmentPoints[i];
				Vector3 vector8 = segmentPoints[i + 1];
				Vector3 normalized = (vector8 - vector6).normalized;
				Vector3 item3 = vector7 - scale * normalized * (vector7 - vector6).magnitude;
				Vector3 item4 = vector7 + scale * normalized * (vector8 - vector7).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector7);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}
[ExecuteInEditMode]
public class PSMeshRendererUpdater : MonoBehaviour
{
	private class ParticleStartInfo
	{
		public ParticleSystem.MinMaxCurve StartSize;

		public ParticleSystem.MinMaxCurve StartSpeed;
	}

	public GameObject MeshObject;

	public float StartScaleMultiplier = 1f;

	public Color Color = Color.black;

	public string MaterialName = "MeshEffect";

	private List<Material[]> rendererMaterials = new List<Material[]>();

	private List<Material[]> skinnedMaterials = new List<Material[]>();

	public bool IsActive = true;

	public float FadeTime = 1.5f;

	private bool currentActiveStatus;

	private bool needUpdateAlpha;

	private Color oldColor = Color.black;

	private float currentAlphaTime;

	private string[] colorProperties = new string[9] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor" };

	private float alpha;

	private float prevAlpha;

	private Dictionary<string, float> startAlphaColors;

	private bool previousActiveStatus;

	private bool needUpdate;

	private bool needLastUpdate;

	private Dictionary<ParticleSystem, ParticleStartInfo> startParticleParameters;

	private void OnEnable()
	{
		alpha = 0f;
		prevAlpha = 0f;
	}

	private void Update()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			return;
		}
		if (startAlphaColors == null)
		{
			InitStartAlphaColors();
		}
		if (IsActive && alpha < 1f)
		{
			alpha += Time.deltaTime / FadeTime;
		}
		if (!IsActive && alpha > 0f)
		{
			alpha -= Time.deltaTime / FadeTime;
		}
		if (alpha > 0f && alpha < 1f)
		{
			needUpdate = true;
		}
		else
		{
			needUpdate = false;
			alpha = Mathf.Clamp01(alpha);
			if (Mathf.Abs(prevAlpha - alpha) >= Mathf.Epsilon)
			{
				UpdateVisibleStatus();
			}
		}
		prevAlpha = alpha;
		if (needUpdate)
		{
			UpdateVisibleStatus();
		}
		if (Color != oldColor)
		{
			oldColor = Color;
			UpdateColor(Color);
		}
	}

	private void InitStartAlphaColors()
	{
		startAlphaColors = new Dictionary<string, float>();
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material[] materials = renderer.materials;
			for (int j = 0; j < materials.Length; j++)
			{
				if (materials[j].name.Contains(MaterialName))
				{
					GetStartAlphaByProperties(renderer.GetHashCode().ToString(), j, materials[j]);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			Material[] materials2 = skinnedMeshRenderer.materials;
			for (int k = 0; k < materials2.Length; k++)
			{
				if (materials2[k].name.Contains(MaterialName))
				{
					GetStartAlphaByProperties(skinnedMeshRenderer.GetHashCode().ToString(), k, materials2[k]);
				}
			}
		}
		Light[] componentsInChildren3 = GetComponentsInChildren<Light>(includeInactive: true);
		for (int l = 0; l < componentsInChildren3.Length; l++)
		{
			ME_LightCurves component = componentsInChildren3[l].GetComponent<ME_LightCurves>();
			float value = 1f;
			if (component != null)
			{
				value = component.GraphIntensityMultiplier;
			}
			startAlphaColors.Add(componentsInChildren3[l].GetHashCode().ToString() + l, value);
		}
		componentsInChildren = MeshObject.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer2 in componentsInChildren)
		{
			Material[] materials3 = renderer2.materials;
			for (int m = 0; m < materials3.Length; m++)
			{
				if (materials3[m].name.Contains(MaterialName))
				{
					GetStartAlphaByProperties(renderer2.GetHashCode().ToString(), m, materials3[m]);
				}
			}
		}
		componentsInChildren2 = MeshObject.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer2 in componentsInChildren2)
		{
			Material[] materials4 = skinnedMeshRenderer2.materials;
			for (int n = 0; n < materials4.Length; n++)
			{
				if (materials4[n].name.Contains(MaterialName))
				{
					GetStartAlphaByProperties(skinnedMeshRenderer2.GetHashCode().ToString(), n, materials4[n]);
				}
			}
		}
	}

	private void InitStartParticleParameters()
	{
		startParticleParameters = new Dictionary<ParticleSystem, ParticleStartInfo>();
		ParticleSystem[] componentsInChildren = MeshObject.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			startParticleParameters.Add(particleSystem, new ParticleStartInfo
			{
				StartSize = particleSystem.main.startSize,
				StartSpeed = particleSystem.main.startSpeed
			});
		}
	}

	private void UpdateVisibleStatus()
	{
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material[] materials = renderer.materials;
			for (int j = 0; j < materials.Length; j++)
			{
				if (materials[j].name.Contains(MaterialName))
				{
					UpdateAlphaByProperties(renderer.GetHashCode().ToString(), j, materials[j], alpha);
				}
			}
		}
		componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer2 in componentsInChildren)
		{
			Material[] materials2 = renderer2.materials;
			for (int k = 0; k < materials2.Length; k++)
			{
				if (materials2[k].name.Contains(MaterialName))
				{
					UpdateAlphaByProperties(renderer2.GetHashCode().ToString(), k, materials2[k], alpha);
				}
			}
		}
		componentsInChildren = MeshObject.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer3 in componentsInChildren)
		{
			Material[] materials3 = renderer3.materials;
			for (int l = 0; l < materials3.Length; l++)
			{
				if (materials3[l].name.Contains(MaterialName))
				{
					UpdateAlphaByProperties(renderer3.GetHashCode().ToString(), l, materials3[l], alpha);
				}
			}
		}
		componentsInChildren = MeshObject.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer4 in componentsInChildren)
		{
			Material[] materials4 = renderer4.materials;
			for (int m = 0; m < materials4.Length; m++)
			{
				if (materials4[m].name.Contains(MaterialName))
				{
					UpdateAlphaByProperties(renderer4.GetHashCode().ToString(), m, materials4[m], alpha);
				}
			}
		}
		ME_LightCurves[] componentsInChildren2 = GetComponentsInChildren<ME_LightCurves>(includeInactive: true);
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].enabled = IsActive;
		}
		Light[] componentsInChildren3 = GetComponentsInChildren<Light>(includeInactive: true);
		for (int n = 0; n < componentsInChildren3.Length; n++)
		{
			if (!IsActive)
			{
				float num = startAlphaColors[componentsInChildren3[n].GetHashCode().ToString() + n];
				componentsInChildren3[n].intensity = alpha * num;
			}
		}
		ParticleSystem[] componentsInChildren4 = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem particleSystem in componentsInChildren4)
		{
			if (!IsActive && !particleSystem.isStopped)
			{
				particleSystem.Stop();
			}
			if (IsActive && particleSystem.isStopped)
			{
				particleSystem.Play();
			}
		}
		ME_TrailRendererNoise[] componentsInChildren5 = GetComponentsInChildren<ME_TrailRendererNoise>();
		for (int i = 0; i < componentsInChildren5.Length; i++)
		{
			componentsInChildren5[i].IsActive = IsActive;
		}
	}

	private void UpdateAlphaByProperties(string rendName, int materialNumber, Material mat, float alpha)
	{
		string[] array = colorProperties;
		foreach (string text in array)
		{
			if (mat.HasProperty(text))
			{
				float num = startAlphaColors[rendName + materialNumber + text.ToString()];
				Color color = mat.GetColor(text);
				color.a = alpha * num;
				mat.SetColor(text, color);
			}
		}
	}

	private void GetStartAlphaByProperties(string rendName, int materialNumber, Material mat)
	{
		string[] array = colorProperties;
		foreach (string text in array)
		{
			if (mat.HasProperty(text))
			{
				string key = rendName + materialNumber + text.ToString();
				if (!startAlphaColors.ContainsKey(key))
				{
					startAlphaColors.Add(rendName + materialNumber + text.ToString(), mat.GetColor(text).a);
				}
			}
		}
	}

	public void UpdateColor(Color color)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.HSBColor hSBColor = ME_ColorHelper.ColorToHSV(color);
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, hSBColor.H);
		}
	}

	public void UpdateColor(float HUE)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, HUE);
		}
	}

	public void UpdateMeshEffect()
	{
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = default(Quaternion);
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (!(MeshObject == null))
		{
			UpdatePSMesh(MeshObject);
			AddMaterialToMesh(MeshObject);
		}
	}

	private void CheckScaleIncludedParticles()
	{
	}

	public void UpdateMeshEffect(GameObject go)
	{
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (go == null)
		{
			Debug.Log("You need set a gameObject");
			return;
		}
		MeshObject = go;
		UpdatePSMesh(MeshObject);
		AddMaterialToMesh(MeshObject);
	}

	private void UpdatePSMesh(GameObject go)
	{
		if (startParticleParameters == null)
		{
			InitStartParticleParameters();
		}
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		MeshRenderer componentInChildren = go.GetComponentInChildren<MeshRenderer>();
		SkinnedMeshRenderer componentInChildren2 = go.GetComponentInChildren<SkinnedMeshRenderer>();
		Light[] componentsInChildren2 = GetComponentsInChildren<Light>();
		float num = 1f;
		float num2 = 1f;
		if (componentInChildren != null)
		{
			num = componentInChildren.bounds.size.magnitude;
			num2 = componentInChildren.transform.lossyScale.magnitude;
		}
		if (componentInChildren2 != null)
		{
			num = componentInChildren2.bounds.size.magnitude;
			num2 = componentInChildren2.transform.lossyScale.magnitude;
		}
		ParticleSystem[] array = componentsInChildren;
		foreach (ParticleSystem particleSystem in array)
		{
			particleSystem.transform.gameObject.SetActive(value: false);
			ParticleSystem.ShapeModule shape = particleSystem.shape;
			if (shape.enabled)
			{
				if (componentInChildren != null)
				{
					shape.shapeType = ParticleSystemShapeType.MeshRenderer;
					shape.meshRenderer = componentInChildren;
				}
				if (componentInChildren2 != null)
				{
					shape.shapeType = ParticleSystemShapeType.SkinnedMeshRenderer;
					shape.skinnedMeshRenderer = componentInChildren2;
				}
			}
			ParticleSystem.MainModule main = particleSystem.main;
			ParticleStartInfo particleStartInfo = startParticleParameters[particleSystem];
			main.startSize = UpdateParticleParam(particleStartInfo.StartSize, main.startSize, num / num2 * StartScaleMultiplier);
			main.startSpeed = UpdateParticleParam(particleStartInfo.StartSpeed, main.startSpeed, num / num2 * StartScaleMultiplier);
			particleSystem.transform.gameObject.SetActive(value: true);
		}
		if (componentInChildren != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren.bounds.center;
			}
		}
		if (componentInChildren2 != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren2.bounds.center;
			}
		}
	}

	private ParticleSystem.MinMaxCurve UpdateParticleParam(ParticleSystem.MinMaxCurve startParam, ParticleSystem.MinMaxCurve currentParam, float scale)
	{
		if (currentParam.mode == ParticleSystemCurveMode.TwoConstants)
		{
			currentParam.constantMin = startParam.constantMin * scale;
			currentParam.constantMax = startParam.constantMax * scale;
		}
		else if (currentParam.mode == ParticleSystemCurveMode.Constant)
		{
			currentParam.constant = startParam.constant * scale;
		}
		return currentParam;
	}

	private void AddMaterialToMesh(GameObject go)
	{
		ME_MeshMaterialEffect componentInChildren = GetComponentInChildren<ME_MeshMaterialEffect>();
		if (!(componentInChildren == null))
		{
			MeshRenderer componentInChildren2 = go.GetComponentInChildren<MeshRenderer>();
			SkinnedMeshRenderer componentInChildren3 = go.GetComponentInChildren<SkinnedMeshRenderer>();
			if (componentInChildren2 != null)
			{
				rendererMaterials.Add(componentInChildren2.sharedMaterials);
				componentInChildren2.sharedMaterials = AddToSharedMaterial(componentInChildren2.sharedMaterials, componentInChildren);
			}
			if (componentInChildren3 != null)
			{
				skinnedMaterials.Add(componentInChildren3.sharedMaterials);
				componentInChildren3.sharedMaterials = AddToSharedMaterial(componentInChildren3.sharedMaterials, componentInChildren);
			}
		}
	}

	private Material[] AddToSharedMaterial(Material[] sharedMaterials, ME_MeshMaterialEffect meshMatEffect)
	{
		if (meshMatEffect.IsFirstMaterial)
		{
			return new Material[1] { meshMatEffect.Material };
		}
		List<Material> list = sharedMaterials.ToList();
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].name.Contains(MaterialName))
			{
				list.RemoveAt(i);
			}
		}
		list.Add(meshMatEffect.Material);
		return list.ToArray();
	}

	private void OnDestroy()
	{
		if (MeshObject == null)
		{
			return;
		}
		MeshRenderer[] componentsInChildren = MeshObject.GetComponentsInChildren<MeshRenderer>();
		SkinnedMeshRenderer[] componentsInChildren2 = MeshObject.GetComponentsInChildren<SkinnedMeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (rendererMaterials.Count == componentsInChildren.Length)
			{
				componentsInChildren[i].sharedMaterials = rendererMaterials[i];
			}
			List<Material> list = componentsInChildren[i].sharedMaterials.ToList();
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j].name.Contains(MaterialName))
				{
					list.RemoveAt(j);
				}
			}
			componentsInChildren[i].sharedMaterials = list.ToArray();
		}
		for (int k = 0; k < componentsInChildren2.Length; k++)
		{
			if (skinnedMaterials.Count == componentsInChildren2.Length)
			{
				componentsInChildren2[k].sharedMaterials = skinnedMaterials[k];
			}
			List<Material> list2 = componentsInChildren2[k].sharedMaterials.ToList();
			for (int l = 0; l < list2.Count; l++)
			{
				if (list2[l].name.Contains(MaterialName))
				{
					list2.RemoveAt(l);
				}
			}
			componentsInChildren2[k].sharedMaterials = list2.ToArray();
		}
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
	}
}
public class ME_PerPlatformSettings : MonoBehaviour
{
	public bool DisableOnMobiles;

	public bool RenderMobileDistortion;

	[Range(0.1f, 1f)]
	public float ParticleBudgetForMobiles = 1f;

	private bool isMobile;

	private void Awake()
	{
		isMobile = IsMobilePlatform();
		if (isMobile)
		{
			if (DisableOnMobiles)
			{
				base.gameObject.SetActive(value: false);
			}
			else if (ParticleBudgetForMobiles < 0.99f)
			{
				ChangeParticlesBudget(ParticleBudgetForMobiles);
			}
		}
	}

	private bool IsMobilePlatform()
	{
		bool result = false;
		if (UnityEngine.Application.isMobilePlatform)
		{
			result = true;
		}
		return result;
	}

	private void ChangeParticlesBudget(float particlesMul)
	{
		ParticleSystem component = GetComponent<ParticleSystem>();
		if (component == null)
		{
			return;
		}
		ParticleSystem.MainModule main = component.main;
		main.maxParticles = Mathf.Max(1, (int)((float)main.maxParticles * particlesMul));
		ParticleSystem.EmissionModule emission = component.emission;
		if (!emission.enabled)
		{
			return;
		}
		ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
		if (rateOverTime.constantMin > 1f)
		{
			rateOverTime.constantMin *= particlesMul;
		}
		if (rateOverTime.constantMax > 1f)
		{
			rateOverTime.constantMax *= particlesMul;
		}
		emission.rateOverTime = rateOverTime;
		ParticleSystem.MinMaxCurve rateOverDistance = emission.rateOverDistance;
		if (rateOverDistance.constantMin > 1f)
		{
			if (rateOverDistance.constantMin > 1f)
			{
				rateOverDistance.constantMin *= particlesMul;
			}
			if (rateOverDistance.constantMax > 1f)
			{
				rateOverDistance.constantMax *= particlesMul;
			}
			emission.rateOverDistance = rateOverDistance;
		}
		ParticleSystem.Burst[] array = new ParticleSystem.Burst[emission.burstCount];
		emission.GetBursts(array);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].minCount > 1)
			{
				array[i].minCount = (short)((float)array[i].minCount * particlesMul);
			}
			if (array[i].maxCount > 1)
			{
				array[i].maxCount = (short)((float)array[i].maxCount * particlesMul);
			}
		}
		emission.SetBursts(array);
	}
}
public class CameraHolder : MonoBehaviour
{
	public struct SVA
	{
		public float S;

		public float V;

		public float A;
	}

	public Transform Holder;

	public float currDistance = 5f;

	public float xRotate = 250f;

	public float yRotate = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float prevDistance;

	private float x;

	private float y;

	[Header("GUI")]
	private float windowDpi;

	public GameObject[] Prefabs;

	private int Prefab;

	private GameObject Instance;

	private float StartColor;

	private float HueColor;

	public Texture HueTexture;

	private ParticleSystem[] particleSystems = new ParticleSystem[0];

	private List<SVA> svList = new List<SVA>();

	private float H;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			windowDpi = 1f;
		}
		if (Screen.dpi < 200f)
		{
			windowDpi = 1f;
		}
		else
		{
			windowDpi = Screen.dpi / 200f;
		}
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
		Counter(0);
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(5f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Previous effect"))
		{
			Counter(-1);
		}
		if (GUI.Button(new Rect(120f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Play again"))
		{
			Counter(0);
		}
		if (GUI.Button(new Rect(235f * windowDpi, 5f * windowDpi, 110f * windowDpi, 35f * windowDpi), "Next effect"))
		{
			Counter(1);
		}
		StartColor = HueColor;
		HueColor = GUI.HorizontalSlider(new Rect(5f * windowDpi, 45f * windowDpi, 340f * windowDpi, 35f * windowDpi), HueColor, 0f, 1f);
		GUI.DrawTexture(new Rect(5f * windowDpi, 65f * windowDpi, 340f * windowDpi, 15f * windowDpi), HueTexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		if (HueColor != StartColor)
		{
			int num = 0;
			ParticleSystem[] array = particleSystems;
			for (int i = 0; i < array.Length; i++)
			{
				ParticleSystem.MainModule main = array[i].main;
				Color color = Color.HSVToRGB(HueColor + H * 0f, svList[num].S, svList[num].V);
				main.startColor = new Color(color.r, color.g, color.b, svList[num].A);
				num++;
			}
		}
	}

	private void Counter(int count)
	{
		Prefab += count;
		if (Prefab > Prefabs.Length - 1)
		{
			Prefab = 0;
		}
		else if (Prefab < 0)
		{
			Prefab = Prefabs.Length - 1;
		}
		if (Instance != null)
		{
			UnityEngine.Object.Destroy(Instance);
		}
		Instance = UnityEngine.Object.Instantiate(Prefabs[Prefab]);
		particleSystems = Instance.GetComponentsInChildren<ParticleSystem>();
		svList.Clear();
		ParticleSystem[] array = particleSystems;
		for (int i = 0; i < array.Length; i++)
		{
			Color color = array[i].main.startColor.color;
			SVA item = default(SVA);
			Color.RGBToHSV(color, out H, out item.S, out item.V);
			item.A = color.a;
			svList.Add(item);
		}
	}

	private void LateUpdate()
	{
		if (currDistance < 2f)
		{
			currDistance = 2f;
		}
		currDistance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
		if ((bool)Holder && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			Vector3 mousePosition = Input.mousePosition;
			float num = 1f;
			if (Screen.dpi < 1f)
			{
				num = 1f;
			}
			num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
			if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
			{
				return;
			}
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
			x += (float)((double)(Input.GetAxis("Mouse X") * xRotate) * 0.02);
			y -= (float)((double)(Input.GetAxis("Mouse Y") * yRotate) * 0.02);
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - currDistance) + Holder.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
		else
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		if (prevDistance != currDistance)
		{
			prevDistance = currDistance;
			Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
			Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - currDistance) + Holder.position;
			base.transform.rotation = quaternion2;
			base.transform.position = position2;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class DemoShooting : MonoBehaviour
{
	public GameObject FirePoint;

	public Camera Cam;

	public float MaxLength;

	public GameObject[] Prefabs;

	private Ray RayMouse;

	private Vector3 direction;

	private Quaternion rotation;

	[Header("GUI")]
	private float windowDpi;

	private int Prefab;

	private GameObject Instance;

	private float hSliderValue = 0.1f;

	private float fireCountdown;

	private float buttonSaver;

	public Animation camAnim;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			windowDpi = 1f;
		}
		if (Screen.dpi < 200f)
		{
			windowDpi = 1f;
		}
		else
		{
			windowDpi = Screen.dpi / 200f;
		}
		Counter(0);
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1"))
		{
			camAnim.Play(camAnim.clip.name);
			UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
		}
		if (Input.GetMouseButton(1) && fireCountdown <= 0f)
		{
			UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
			fireCountdown = 0f;
			fireCountdown += hSliderValue;
		}
		fireCountdown -= Time.deltaTime;
		if ((Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(-1);
		}
		if ((Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(1);
		}
		buttonSaver += Time.deltaTime;
		if (Cam != null)
		{
			Vector3 mousePosition = Input.mousePosition;
			RayMouse = Cam.ScreenPointToRay(mousePosition);
			if (Physics.Raycast(RayMouse.origin, RayMouse.direction, out var hitInfo, MaxLength))
			{
				RotateToMouseDirection(base.gameObject, hitInfo.point);
			}
		}
		else
		{
			Debug.Log("No camera");
		}
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(10f * windowDpi, 5f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use left mouse button to single shoot!");
		GUI.Label(new Rect(10f * windowDpi, 25f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use and hold the right mouse button for quick shooting!");
		GUI.Label(new Rect(10f * windowDpi, 45f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Fire rate:");
		hSliderValue = GUI.HorizontalSlider(new Rect(70f * windowDpi, 50f * windowDpi, 100f * windowDpi, 20f * windowDpi), hSliderValue, 0f, 1f);
		GUI.Label(new Rect(10f * windowDpi, 65f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use the keyboard buttons A/<- and D/-> to change projectiles!");
	}

	private void Counter(int count)
	{
		Prefab += count;
		if (Prefab > Prefabs.Length - 1)
		{
			Prefab = 0;
		}
		else if (Prefab < 0)
		{
			Prefab = Prefabs.Length - 1;
		}
	}

	private void RotateToMouseDirection(GameObject obj, Vector3 destination)
	{
		direction = destination - obj.transform.position;
		rotation = Quaternion.LookRotation(direction);
		obj.transform.localRotation = Quaternion.Lerp(obj.transform.rotation, rotation, 1f);
	}
}
public class EGA_DemoLasers : MonoBehaviour
{
	public GameObject FirePoint;

	public Camera Cam;

	public float MaxLength;

	public GameObject[] Prefabs;

	private Ray RayMouse;

	private Vector3 direction;

	private Quaternion rotation;

	[Header("GUI")]
	private float windowDpi;

	private int Prefab;

	private GameObject Instance;

	private EGA_Laser LaserScript;

	private float buttonSaver;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			windowDpi = 1f;
		}
		if (Screen.dpi < 200f)
		{
			windowDpi = 1f;
		}
		else
		{
			windowDpi = Screen.dpi / 200f;
		}
		Counter(0);
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			UnityEngine.Object.Destroy(Instance);
			Instance = UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
			Instance.transform.parent = base.transform;
			LaserScript = Instance.GetComponent<EGA_Laser>();
		}
		if (Input.GetMouseButtonUp(0))
		{
			LaserScript.DisablePrepare();
			UnityEngine.Object.Destroy(Instance, 1f);
		}
		if ((Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(-1);
		}
		if ((Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(1);
		}
		buttonSaver += Time.deltaTime;
		if (Cam != null)
		{
			Vector3 mousePosition = Input.mousePosition;
			RayMouse = Cam.ScreenPointToRay(mousePosition);
			if (Physics.Raycast(RayMouse.origin, RayMouse.direction, out var hitInfo, MaxLength))
			{
				RotateToMouseDirection(base.gameObject, hitInfo.point);
				return;
			}
			Vector3 point = RayMouse.GetPoint(MaxLength);
			RotateToMouseDirection(base.gameObject, point);
		}
		else
		{
			Debug.Log("No camera");
		}
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(10f * windowDpi, 5f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use the keyboard buttons A/<- and D/-> to change lazers!");
		GUI.Label(new Rect(10f * windowDpi, 20f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use left mouse button for shooting!");
	}

	private void Counter(int count)
	{
		Prefab += count;
		if (Prefab > Prefabs.Length - 1)
		{
			Prefab = 0;
		}
		else if (Prefab < 0)
		{
			Prefab = Prefabs.Length - 1;
		}
	}

	private void RotateToMouseDirection(GameObject obj, Vector3 destination)
	{
		direction = destination - obj.transform.position;
		rotation = Quaternion.LookRotation(direction);
		obj.transform.localRotation = Quaternion.Lerp(obj.transform.rotation, rotation, 1f);
	}
}
public class EGA_Laser : MonoBehaviour
{
	public GameObject HitEffect;

	public float HitOffset;

	public float MaxLength;

	private LineRenderer Laser;

	public float MainTextureLength = 1f;

	public float NoiseTextureLength = 1f;

	private Vector4 Length = new Vector4(1f, 1f, 1f, 1f);

	private bool LaserSaver;

	private bool UpdateSaver;

	private ParticleSystem[] Effects;

	private ParticleSystem[] Hit;

	private void Start()
	{
		Laser = GetComponent<LineRenderer>();
		Effects = GetComponentsInChildren<ParticleSystem>();
		Hit = HitEffect.GetComponentsInChildren<ParticleSystem>();
	}

	private void Update()
	{
		Laser.material.SetTextureScale("_MainTex", new Vector2(Length[0], Length[1]));
		Laser.material.SetTextureScale("_Noise", new Vector2(Length[2], Length[3]));
		if (!(Laser != null) || UpdateSaver)
		{
			return;
		}
		Laser.SetPosition(0, base.transform.position);
		if (Physics.Raycast(base.transform.position, base.transform.TransformDirection(Vector3.forward), out var hitInfo, MaxLength))
		{
			Laser.SetPosition(1, hitInfo.point);
			HitEffect.transform.position = hitInfo.point + hitInfo.normal * HitOffset;
			HitEffect.transform.rotation = Quaternion.identity;
			ParticleSystem[] effects = Effects;
			foreach (ParticleSystem particleSystem in effects)
			{
				if (!particleSystem.isPlaying)
				{
					particleSystem.Play();
				}
			}
			Length[0] = MainTextureLength * Vector3.Distance(base.transform.position, hitInfo.point);
			Length[2] = NoiseTextureLength * Vector3.Distance(base.transform.position, hitInfo.point);
		}
		else
		{
			Vector3 vector = base.transform.position + base.transform.forward * MaxLength;
			Laser.SetPosition(1, vector);
			HitEffect.transform.position = vector;
			ParticleSystem[] effects = Hit;
			foreach (ParticleSystem particleSystem2 in effects)
			{
				if (particleSystem2.isPlaying)
				{
					particleSystem2.Stop();
				}
			}
			Length[0] = MainTextureLength * Vector3.Distance(base.transform.position, vector);
			Length[2] = NoiseTextureLength * Vector3.Distance(base.transform.position, vector);
		}
		if (!Laser.enabled && !LaserSaver)
		{
			LaserSaver = true;
			Laser.enabled = true;
		}
	}

	public void DisablePrepare()
	{
		if (Laser != null)
		{
			Laser.enabled = false;
		}
		UpdateSaver = true;
		if (Effects == null)
		{
			return;
		}
		ParticleSystem[] effects = Effects;
		foreach (ParticleSystem particleSystem in effects)
		{
			if (particleSystem.isPlaying)
			{
				particleSystem.Stop();
			}
		}
	}
}
public class RaycastInstance : MonoBehaviour
{
	public Camera Cam;

	public GameObject[] Prefabs;

	private int Prefab;

	private Ray RayMouse;

	private GameObject Instance;

	private float windowDpi;

	private float buttonSaver;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			windowDpi = 1f;
		}
		if (Screen.dpi < 200f)
		{
			windowDpi = 1f;
		}
		else
		{
			windowDpi = Screen.dpi / 200f;
		}
		Counter(0);
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1"))
		{
			if (Cam != null)
			{
				Vector3 mousePosition = Input.mousePosition;
				RayMouse = Cam.ScreenPointToRay(mousePosition);
				if (Physics.Raycast(RayMouse.origin, RayMouse.direction, out var hitInfo, 40f))
				{
					Instance = UnityEngine.Object.Instantiate(Prefabs[Prefab]);
					Instance.transform.position = hitInfo.point + hitInfo.normal * 0.01f;
					UnityEngine.Object.Destroy(Instance, 1.5f);
				}
			}
			else
			{
				Debug.Log("No camera");
			}
		}
		if ((Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(-1);
		}
		if ((Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(1);
		}
		buttonSaver += Time.deltaTime;
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(10f * windowDpi, 5f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use the keyboard buttons A/<- and D/-> to change prefabs!");
		GUI.Label(new Rect(10f * windowDpi, 20f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use left mouse button for instancing!");
	}

	private void Counter(int count)
	{
		Prefab += count;
		if (Prefab > Prefabs.Length - 1)
		{
			Prefab = 0;
		}
		else if (Prefab < 0)
		{
			Prefab = Prefabs.Length - 1;
		}
	}
}
public class AutoDestroyPS : MonoBehaviour
{
	private float timeLeft;

	private void Awake()
	{
		ParticleSystem.MainModule main = GetComponent<ParticleSystem>().main;
		timeLeft = main.startLifetimeMultiplier + main.duration;
		UnityEngine.Object.Destroy(base.gameObject, timeLeft);
	}
}
public class EGA_EffectSound : MonoBehaviour
{
	public bool Repeating = true;

	public float RepeatTime = 2f;

	public float StartTime;

	public bool RandomVolume;

	public float minVolume = 0.4f;

	public float maxVolume = 1f;

	private AudioClip clip;

	private AudioSource soundComponent;

	private void Start()
	{
		soundComponent = GetComponent<AudioSource>();
		clip = soundComponent.clip;
		if (RandomVolume)
		{
			soundComponent.volume = UnityEngine.Random.Range(minVolume, maxVolume);
			RepeatSound();
		}
		if (Repeating)
		{
			InvokeRepeating("RepeatSound", StartTime, RepeatTime);
		}
	}

	private void RepeatSound()
	{
		soundComponent.PlayOneShot(clip);
	}
}
public class ParticleCollisionInstance : MonoBehaviour
{
	public GameObject[] EffectsOnCollision;

	public float DestroyTimeDelay = 5f;

	public bool UseWorldSpacePosition;

	public float Offset;

	public Vector3 rotationOffset = new Vector3(0f, 0f, 0f);

	public bool useOnlyRotationOffset = true;

	public bool UseFirePointRotation;

	public bool DestoyMainEffect = true;

	private ParticleSystem part;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem ps;

	private void Start()
	{
		part = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = part.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			GameObject[] effectsOnCollision = EffectsOnCollision;
			for (int j = 0; j < effectsOnCollision.Length; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[j], collisionEvents[i].intersection + collisionEvents[i].normal * Offset, default(Quaternion));
				if (!UseWorldSpacePosition)
				{
					gameObject.transform.parent = base.transform;
				}
				if (UseFirePointRotation)
				{
					gameObject.transform.LookAt(base.transform.position);
				}
				else if (rotationOffset != Vector3.zero && useOnlyRotationOffset)
				{
					gameObject.transform.rotation = Quaternion.Euler(rotationOffset);
				}
				else
				{
					gameObject.transform.LookAt(collisionEvents[i].intersection + collisionEvents[i].normal);
					gameObject.transform.rotation *= Quaternion.Euler(rotationOffset);
				}
				UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
			}
		}
		if (DestoyMainEffect)
		{
			UnityEngine.Object.Destroy(base.gameObject, DestroyTimeDelay + 0.5f);
		}
	}
}
public class ProjectileMover : MonoBehaviour
{
	public float speed = 15f;

	public float hitOffset;

	public bool UseFirePointRotation;

	public Vector3 rotationOffset = new Vector3(0f, 0f, 0f);

	public GameObject hit;

	public GameObject flash;

	private Rigidbody rb;

	public GameObject[] Detached;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		if (flash != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(flash, base.transform.position, Quaternion.identity);
			gameObject.transform.forward = base.gameObject.transform.forward;
			ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
			if (component != null)
			{
				UnityEngine.Object.Destroy(gameObject, component.main.duration);
			}
			else
			{
				ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
				UnityEngine.Object.Destroy(gameObject, component2.main.duration);
			}
		}
		UnityEngine.Object.Destroy(base.gameObject, 5f);
	}

	private void FixedUpdate()
	{
		if (speed != 0f)
		{
			rb.velocity = base.transform.forward * speed;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		rb.constraints = RigidbodyConstraints.FreezeAll;
		speed = 0f;
		ContactPoint contactPoint = collision.contacts[0];
		Quaternion rotation = Quaternion.FromToRotation(Vector3.up, contactPoint.normal);
		Vector3 position = contactPoint.point + contactPoint.normal * hitOffset;
		if (hit != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(hit, position, rotation);
			if (UseFirePointRotation)
			{
				gameObject.transform.rotation = base.gameObject.transform.rotation * Quaternion.Euler(0f, 180f, 0f);
			}
			else if (rotationOffset != Vector3.zero)
			{
				gameObject.transform.rotation = Quaternion.Euler(rotationOffset);
			}
			else
			{
				gameObject.transform.LookAt(contactPoint.point + contactPoint.normal);
			}
			ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
			if (component != null)
			{
				UnityEngine.Object.Destroy(gameObject, component.main.duration);
			}
			else
			{
				ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
				UnityEngine.Object.Destroy(gameObject, component2.main.duration);
			}
		}
		GameObject[] detached = Detached;
		foreach (GameObject gameObject2 in detached)
		{
			if (gameObject2 != null)
			{
				gameObject2.transform.parent = null;
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class Rotator : MonoBehaviour
{
	public float x;

	public float y;

	public float z;

	private void OnEnable()
	{
		InvokeRepeating("Rotate", 0f, 0.0167f);
	}

	private void OnDisable()
	{
		CancelInvoke();
	}

	private void Rotate()
	{
		base.transform.localEulerAngles += new Vector3(x, y, z);
	}
}
public class RainbowCameraOrbit : MonoBehaviour
{
	public Transform target;

	public float distance = 5f;

	public float xSpeed = 120f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float distanceMin = 0.5f;

	public float distanceMax = 15f;

	public float smoothTime = 2f;

	private float rotationYAxis;

	private float rotationXAxis;

	private float velocityX;

	private float velocityY;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		rotationYAxis = eulerAngles.y;
		rotationXAxis = eulerAngles.x;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			if (Input.GetMouseButton(1))
			{
				velocityX += xSpeed * Input.GetAxis("Mouse X") * distance * 0.02f;
				velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
			}
			rotationYAxis += velocityX;
			rotationXAxis -= velocityY;
			rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
			distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
			if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
			{
				distance -= hitInfo.distance;
			}
			Vector3 vector = new Vector3(0f, 0f, 0f - distance);
			Vector3 position = quaternion * vector + target.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
			velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
			velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
		}
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class AnimateTiledTextureOnTrail : MonoBehaviour
{
	public delegate void VoidEvent();

	public int _columns = 2;

	public int _rows = 2;

	public Vector2 _scale = new Vector3(1f, 1f);

	public Vector2 _offset = Vector2.zero;

	public Vector2 _buffer = Vector2.zero;

	public float _framesPerSecond = 10f;

	public bool _playOnce;

	public bool _disableUponCompletion;

	public bool _enableEvents;

	public bool _playOnEnable = true;

	public bool _newMaterialInstance;

	private int _index;

	private Vector2 _textureSize = Vector2.zero;

	private Material _materialInstance;

	private bool _hasMaterialInstance;

	private bool _isPlaying;

	private List<VoidEvent> _voidEventCallbackList;

	public void RegisterCallback(VoidEvent cbFunction)
	{
		if (_enableEvents)
		{
			_voidEventCallbackList.Add(cbFunction);
		}
		else
		{
			Debug.LogWarning("AnimateTiledTextureOnTrail: You are attempting to register a callback but the events of this object are not enabled!");
		}
	}

	public void UnRegisterCallback(VoidEvent cbFunction)
	{
		if (_enableEvents)
		{
			_voidEventCallbackList.Remove(cbFunction);
		}
		else
		{
			Debug.LogWarning("AnimateTiledTextureOnTrail: You are attempting to un-register a callback but the events of this object are not enabled!");
		}
	}

	public void Play()
	{
		if (_isPlaying)
		{
			StopCoroutine("updateTiling");
			_isPlaying = false;
		}
		GetComponent<TrailRenderer>().enabled = true;
		_index = _columns;
		StartCoroutine(updateTiling());
	}

	public void ChangeMaterial(Material newMaterial, bool newInstance = false)
	{
		if (newInstance)
		{
			if (_hasMaterialInstance)
			{
				UnityEngine.Object.Destroy(GetComponent<TrailRenderer>().sharedMaterial);
			}
			_materialInstance = new Material(newMaterial);
			GetComponent<TrailRenderer>().sharedMaterial = _materialInstance;
			_hasMaterialInstance = true;
		}
		else
		{
			GetComponent<TrailRenderer>().sharedMaterial = newMaterial;
		}
		CalcTextureSize();
		GetComponent<TrailRenderer>().sharedMaterial.SetTextureScale("_MainTex", _textureSize);
	}

	private void Awake()
	{
		if (_enableEvents)
		{
			_voidEventCallbackList = new List<VoidEvent>();
		}
		ChangeMaterial(GetComponent<TrailRenderer>().sharedMaterial, _newMaterialInstance);
	}

	private void OnDestroy()
	{
		if (_hasMaterialInstance)
		{
			UnityEngine.Object.Destroy(GetComponent<TrailRenderer>().sharedMaterial);
			_hasMaterialInstance = false;
		}
	}

	private void HandleCallbacks(List<VoidEvent> cbList)
	{
		for (int i = 0; i < cbList.Count; i++)
		{
			cbList[i]();
		}
	}

	private void OnEnable()
	{
		CalcTextureSize();
		if (_playOnEnable)
		{
			Play();
		}
	}

	private void CalcTextureSize()
	{
		_textureSize = new Vector2(1f / (float)_columns, 1f / (float)_rows);
		_textureSize.x /= _scale.x;
		_textureSize.y /= _scale.y;
		_textureSize -= _buffer;
	}

	private IEnumerator updateTiling()
	{
		_isPlaying = true;
		int checkAgainst = _rows * _columns;
		while (true)
		{
			if (_index >= checkAgainst)
			{
				_index = 0;
				if (_playOnce)
				{
					if (checkAgainst == _columns)
					{
						break;
					}
					checkAgainst = _columns;
				}
			}
			ApplyOffset();
			_index++;
			yield return new WaitForSeconds(1f / _framesPerSecond);
		}
		if (_enableEvents)
		{
			HandleCallbacks(_voidEventCallbackList);
		}
		if (_disableUponCompletion)
		{
			base.gameObject.GetComponent<TrailRenderer>().enabled = false;
		}
		_isPlaying = false;
	}

	private void ApplyOffset()
	{
		Vector2 value = new Vector2((float)_index / (float)_columns - (float)(_index / _columns), 1f - (float)(_index / _columns) / (float)_rows);
		if (value.y == 1f)
		{
			value.y = 0f;
		}
		value.x += (1f / (float)_columns - _textureSize.x) / 2f;
		value.y += (1f / (float)_rows - _textureSize.y) / 2f;
		value.x += _offset.x;
		value.y += _offset.y;
		GetComponent<TrailRenderer>().sharedMaterial.SetTextureOffset("_MainTex", value);
	}
}
public class BillBoard : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.transform.rotation = Camera.main.transform.rotation;
	}
}
public class tazo_rotate : MonoBehaviour
{
	public float rotate_x;

	public float rotate_y;

	public float rotate_z;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(rotate_x * Time.deltaTime, rotate_y * Time.deltaTime, rotate_z * Time.deltaTime);
	}
}
public class CameraFollow : MonoBehaviour
{
	public Transform target;

	public Vector3 offset;

	public float somoothSpeed = 0.125f;

	private void FixedUpdate()
	{
		Vector3 b = target.position + offset;
		Vector3 position = Vector3.Lerp(base.transform.position, b, somoothSpeed * Time.deltaTime);
		base.transform.position = position;
		base.transform.LookAt(target);
	}
}
public class Fennec : MonoBehaviour
{
	private Animator fennec;

	private IEnumerator coroutine;

	private void Start()
	{
		fennec = GetComponent<Animator>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.W))
		{
			fennec.SetBool("walk", value: true);
			fennec.SetBool("threat", value: true);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("growl", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
		}
		if (Input.GetKeyUp(KeyCode.W) || Input.GetKeyUp(KeyCode.A) || Input.GetKeyUp(KeyCode.D) || Input.GetKeyUp(KeyCode.F))
		{
			fennec.SetBool("idle", value: true);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("threat", value: false);
			fennec.SetBool("growl", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
			fennec.SetBool("runattack", value: false);
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			fennec.SetBool("turnleft", value: true);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			fennec.SetBool("turnright", value: true);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
		}
		if (Input.GetKeyDown(KeyCode.W) && Input.GetKey(KeyCode.RightShift))
		{
			fennec.SetBool("trot", value: true);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
		}
		if (Input.GetKeyDown(KeyCode.A) && Input.GetKey(KeyCode.RightShift))
		{
			fennec.SetBool("trotleft", value: true);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
		}
		if (Input.GetKeyDown(KeyCode.D) && Input.GetKey(KeyCode.RightShift))
		{
			fennec.SetBool("trotright", value: true);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
		}
		if (Input.GetKeyDown(KeyCode.W) && Input.GetKey(KeyCode.RightControl))
		{
			fennec.SetBool("run", value: true);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
			fennec.SetBool("runattack", value: false);
		}
		if (Input.GetKeyDown(KeyCode.A) && Input.GetKey(KeyCode.RightControl))
		{
			fennec.SetBool("runleft", value: true);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
			fennec.SetBool("runattack", value: false);
		}
		if (Input.GetKeyDown(KeyCode.D) && Input.GetKey(KeyCode.RightControl))
		{
			fennec.SetBool("runright", value: true);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("idle", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
			fennec.SetBool("runattack", value: false);
		}
		if (Input.GetKey(KeyCode.W) && Input.GetKey(KeyCode.RightAlt))
		{
			fennec.SetBool("sniffs", value: true);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffsright", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("idle", value: false);
		}
		if (Input.GetKey(KeyCode.A) && Input.GetKey(KeyCode.RightAlt))
		{
			fennec.SetBool("sniffsleft", value: true);
			fennec.SetBool("sniffsright", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("idle", value: false);
		}
		if (Input.GetKey(KeyCode.D) && Input.GetKey(KeyCode.RightAlt))
		{
			fennec.SetBool("sniffsright", value: true);
			fennec.SetBool("sniffsleft", value: false);
			fennec.SetBool("sniffs", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("trotright", value: false);
			fennec.SetBool("trotleft", value: false);
			fennec.SetBool("trot", value: false);
			fennec.SetBool("turnright", value: false);
			fennec.SetBool("turnleft", value: false);
			fennec.SetBool("walk", value: false);
			fennec.SetBool("idle", value: false);
		}
		if (Input.GetKeyDown(KeyCode.Space))
		{
			fennec.SetBool("jump", value: true);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			fennec.SetBool("idle", value: false);
			StartCoroutine("run");
		}
		if (Input.GetKey(KeyCode.R))
		{
			fennec.SetBool("lay", value: true);
			fennec.SetBool("idle", value: false);
			StartCoroutine("idlelay");
		}
		if (Input.GetKey(KeyCode.R))
		{
			fennec.SetBool("getup", value: true);
			fennec.SetBool("idlelay", value: false);
			StartCoroutine("idle");
		}
		if (Input.GetKey(KeyCode.F))
		{
			fennec.SetBool("growl", value: true);
			fennec.SetBool("idle", value: false);
		}
		if (Input.GetKey(KeyCode.W) && Input.GetKey(KeyCode.F))
		{
			fennec.SetBool("threat", value: false);
			fennec.SetBool("attack", value: true);
			StartCoroutine("growl");
		}
		if (Input.GetKey(KeyCode.E))
		{
			fennec.SetBool("eat", value: true);
			fennec.SetBool("idle", value: false);
			StartCoroutine("idle");
		}
		if (Input.GetKey(KeyCode.S))
		{
			fennec.SetBool("sleep", value: true);
			fennec.SetBool("idlelay", value: false);
			StartCoroutine("sleep");
		}
		if (Input.GetKey(KeyCode.Keypad0))
		{
			fennec.SetBool("growl", value: false);
			fennec.SetBool("die", value: true);
		}
		if (Input.GetKey(KeyCode.Keypad1))
		{
			fennec.SetBool("growl", value: false);
			fennec.SetBool("hit", value: true);
			StartCoroutine("growl");
		}
		if (Input.GetKey(KeyCode.F))
		{
			fennec.SetBool("runattack", value: true);
			fennec.SetBool("run", value: false);
			fennec.SetBool("runleft", value: false);
			fennec.SetBool("runright", value: false);
			StartCoroutine("run");
		}
	}

	private IEnumerator run()
	{
		yield return new WaitForSeconds(0.5f);
		fennec.SetBool("run", value: true);
		fennec.SetBool("runleft", value: false);
		fennec.SetBool("runleft", value: false);
		fennec.SetBool("jump", value: false);
		fennec.SetBool("trotright", value: false);
		fennec.SetBool("trotleft", value: false);
		fennec.SetBool("trot", value: false);
		fennec.SetBool("turnright", value: false);
		fennec.SetBool("turnleft", value: false);
		fennec.SetBool("walk", value: false);
		fennec.SetBool("idle", value: false);
		fennec.SetBool("runattack", value: false);
	}

	private IEnumerator idlelay()
	{
		yield return new WaitForSeconds(0.5f);
		fennec.SetBool("idlelay", value: true);
		fennec.SetBool("lay", value: false);
		fennec.SetBool("getup", value: false);
	}

	private IEnumerator idle()
	{
		yield return new WaitForSeconds(1f);
		fennec.SetBool("idle", value: true);
		fennec.SetBool("getup", value: false);
		fennec.SetBool("idle", value: true);
		fennec.SetBool("walk", value: false);
		fennec.SetBool("turnleft", value: false);
		fennec.SetBool("turnright", value: false);
		fennec.SetBool("trot", value: false);
		fennec.SetBool("trotleft", value: false);
		fennec.SetBool("trotright", value: false);
		fennec.SetBool("run", value: false);
		fennec.SetBool("runleft", value: false);
		fennec.SetBool("runright", value: false);
		fennec.SetBool("threat", value: false);
		fennec.SetBool("growl", value: false);
		fennec.SetBool("eat", value: false);
	}

	private IEnumerator growl()
	{
		yield return new WaitForSeconds(0.5f);
		fennec.SetBool("growl", value: true);
		fennec.SetBool("attack", value: false);
		fennec.SetBool("threat", value: false);
		fennec.SetBool("hit", value: false);
	}

	private IEnumerator sleep()
	{
		yield return new WaitForSeconds(10f);
		fennec.SetBool("sleep", value: false);
		fennec.SetBool("idlelay", value: true);
	}
}
public class handanimations : MonoBehaviour
{
	public GameObject ViveController;

	public GameObject OculusController;

	public GameObject StickUp;

	public GameObject StickFront;

	private Animator anim;

	private int Idle = Animator.StringToHash("Idle");

	private int Point = Animator.StringToHash("Point");

	private int GrabLarge = Animator.StringToHash("GrabLarge");

	private int GrabSmall = Animator.StringToHash("GrabSmall");

	private int GrabStickUp = Animator.StringToHash("GrabStickUp");

	private int GrabStickFront = Animator.StringToHash("GrabStickFront");

	private int ThumbUp = Animator.StringToHash("ThumbUp");

	private int Fist = Animator.StringToHash("Fist");

	private int Gun = Animator.StringToHash("Gun");

	private int GunShoot = Animator.StringToHash("GunShoot");

	private int PushButton = Animator.StringToHash("PushButton");

	private int Spread = Animator.StringToHash("Spread");

	private int MiddleFinger = Animator.StringToHash("MiddleFinger");

	private int Peace = Animator.StringToHash("Peace");

	private int OK = Animator.StringToHash("OK");

	private int Phone = Animator.StringToHash("Phone");

	private int Rock = Animator.StringToHash("Rock");

	private int Natural = Animator.StringToHash("Natural");

	private int Number3 = Animator.StringToHash("Number3");

	private int Number4 = Animator.StringToHash("Number4");

	private int Number3V2 = Animator.StringToHash("Number3V2");

	private int HoldViveController = Animator.StringToHash("HoldViveController");

	private int PressTriggerViveController = Animator.StringToHash("PressTriggerViveController");

	private int HoldOculusController = Animator.StringToHash("HoldOculusController");

	private int PressTriggerOculusController = Animator.StringToHash("PressTriggerOculusController");

	private void Start()
	{
		anim = GetComponent<Animator>();
		OculusController.SetActive(value: false);
		ViveController.SetActive(value: false);
		StickUp.SetActive(value: false);
		StickFront.SetActive(value: false);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Q))
		{
			anim.SetTrigger(Idle);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.W))
		{
			anim.SetTrigger(Point);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.E))
		{
			anim.SetTrigger(GrabLarge);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.R))
		{
			anim.SetTrigger(GrabSmall);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.T))
		{
			anim.SetTrigger(GrabStickUp);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: true);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.Y))
		{
			anim.SetTrigger(GrabStickFront);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: true);
		}
		else if (Input.GetKeyDown(KeyCode.U))
		{
			anim.SetTrigger(ThumbUp);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.I))
		{
			anim.SetTrigger(Fist);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.O))
		{
			anim.SetTrigger(Gun);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.P))
		{
			anim.SetTrigger(GunShoot);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.A))
		{
			anim.SetTrigger(PushButton);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.S))
		{
			anim.SetTrigger(Spread);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.D))
		{
			anim.SetTrigger(MiddleFinger);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.F))
		{
			anim.SetTrigger(Peace);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.G))
		{
			anim.SetTrigger(OK);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.H))
		{
			anim.SetTrigger(Phone);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.J))
		{
			anim.SetTrigger(Rock);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.K))
		{
			anim.SetTrigger(Natural);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.L))
		{
			anim.SetTrigger(Number3);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.X))
		{
			anim.SetTrigger(Number4);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.Z))
		{
			anim.SetTrigger(Number3V2);
			OculusController.SetActive(value: false);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.C))
		{
			anim.SetTrigger(HoldViveController);
			ViveController.SetActive(value: true);
			OculusController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.V))
		{
			anim.SetTrigger(PressTriggerViveController);
			ViveController.SetActive(value: true);
			OculusController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.B))
		{
			anim.SetTrigger(HoldOculusController);
			OculusController.SetActive(value: true);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
		else if (Input.GetKeyDown(KeyCode.N))
		{
			anim.SetTrigger(PressTriggerOculusController);
			OculusController.SetActive(value: true);
			ViveController.SetActive(value: false);
			StickUp.SetActive(value: false);
			StickFront.SetActive(value: false);
		}
	}
}
public class InputSample : MonoBehaviour
{
	[SerializeField]
	private Text _triggerText;

	[SerializeField]
	private Text _sideText;

	[SerializeField]
	private Text _menuText;

	[SerializeField]
	private Text _positionVector2Text;

	[SerializeField]
	private Text _rotationVector2Text;

	private void Start()
	{
		InputEventMediator.Mediate(null, OnInputKey, null, OnUpdatePositionVector2, OnUpdateRotationVector2);
	}

	private void OnInputKey(InputKeyType keyType, InputStateType stateType)
	{
		switch (keyType)
		{
		case InputKeyType.Trigger:
			_triggerText.text = string.Concat(keyType, " : ", stateType);
			break;
		case InputKeyType.Side:
			_sideText.text = string.Concat(keyType, " : ", stateType);
			break;
		case InputKeyType.Menu:
			_menuText.text = string.Concat(keyType, " : ", stateType);
			break;
		default:
			Debug.LogWarning($"{keyType}の処理は実装されていません");
			break;
		}
	}

	private void OnUpdatePositionVector2(Vector2 vector2)
	{
		_positionVector2Text.text = "PositionVector2 : " + vector2.ToString();
	}

	private void OnUpdateRotationVector2(Vector2 vector2)
	{
		_rotationVector2Text.text = "RotationVector2 : " + vector2.ToString() + "(VR中は無効)";
	}
}
public class RankingSample : MonoBehaviour
{
}
public class SteamRankingSample : MonoBehaviour
{
}
public class LeverObjectSample : MonoBehaviour
{
	[SerializeField]
	[Required]
	private GrabbingMoveObject _grabbingMoveObject;

	[SerializeField]
	[Required]
	private GameObject _ball;

	private void Awake()
	{
		_grabbingMoveObject.ChangedState += OnChangeState;
	}

	private void OnChangeState(GrabbingMoveObject.State currentState)
	{
		if (currentState == GrabbingMoveObject.State.On)
		{
			GameObject obj = UnityEngine.Object.Instantiate(_ball);
			obj.SetActive(value: true);
			obj.transform.SetParent(base.transform.parent);
		}
	}
}
public class LeverSample : MonoBehaviour
{
}
public class TouchButtonGimmickSample : MonoBehaviour
{
	[SerializeField]
	private List<TouchButtonObjectSample> _sampleList = new List<TouchButtonObjectSample>();

	[SerializeField]
	private GameObject _child;

	private void Start()
	{
		foreach (TouchButtonObjectSample sample in _sampleList)
		{
			sample.CangedState += ShowChildIfNeeded;
		}
	}

	private void ShowChildIfNeeded(TouchButtonObject.State state)
	{
		if (state == TouchButtonObject.State.On && !_sampleList.Any((TouchButtonObjectSample sample) => sample.CurrentState != TouchButtonObject.State.On))
		{
			_child.SetActive(value: true);
		}
	}
}
public class TouchButtonObjectSample : TouchButtonObject
{
	[SerializeField]
	[Required]
	private MeshRenderer _meshRenderer;

	[SerializeField]
	[Required]
	private Material _offMaterial;

	[SerializeField]
	[Required]
	private Material _movingMaterial;

	[SerializeField]
	[Required]
	private Material _onMaterial;

	protected override void OnChangeState(State currentState)
	{
		switch (currentState)
		{
		case State.Off:
			_meshRenderer.material = _offMaterial;
			break;
		case State.Stop:
			_meshRenderer.material = _offMaterial;
			break;
		case State.On:
			_meshRenderer.material = _onMaterial;
			break;
		default:
			_meshRenderer.material = _movingMaterial;
			break;
		}
	}
}
public class AnimationMonoBehaviour : MonoBehaviour
{
	[SerializeField]
	[Required]
	protected Animator _animator;

	public void StopAnimation()
	{
		_animator.enabled = false;
	}

	public void PlayLoopAnimation(int animationKey)
	{
		_animator.enabled = true;
		_animator.Play(animationKey);
	}

	public Coroutine PlayAnimation(int animationKey, Action callback = null, bool isEnabledAnimator = true)
	{
		_animator.enabled = true;
		return StartCoroutine(_animator.Play(animationKey, delegate
		{
			_animator.enabled = isEnabledAnimator;
			callback?.Invoke();
		}));
	}
}
public class ReuseAnimationMonoBehaviour : ReuseMonoBehaviour
{
	[SerializeField]
	[Required]
	protected SpriteRenderer _spriteRenderer;

	[SerializeField]
	[Required]
	protected Animator _animator;

	public float Alpha
	{
		get
		{
			return _spriteRenderer.color.a;
		}
		set
		{
			Color color = _spriteRenderer.color;
			color.a = value;
			_spriteRenderer.color = color;
		}
	}

	public SpriteRenderer SpriteRenderer => _spriteRenderer;

	public Sprite Sprite
	{
		get
		{
			if (!(_spriteRenderer == null))
			{
				return _spriteRenderer.sprite;
			}
			return null;
		}
	}

	public virtual void StopAnimation()
	{
		_animator.enabled = false;
	}

	public virtual void PlayLoopAnimation(int animationKey)
	{
		if (base.gameObject.activeInHierarchy)
		{
			_animator.enabled = true;
			_animator.Play(animationKey);
		}
	}

	public virtual Coroutine PlayAnimation(int animationKey, Action callback = null, bool isEnabledAnimator = false)
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return null;
		}
		_animator.enabled = true;
		return StartCoroutine(_animator.Play(animationKey, delegate
		{
			_animator.enabled = isEnabledAnimator;
			callback?.Invoke();
		}));
	}
}
public abstract class ReuseMonoBehaviour : MonoBehaviour
{
	private Action<ReuseMonoBehaviour> _releaseAction;

	public virtual void InitOnFirstInstantiate()
	{
	}

	public virtual void Init(Action<ReuseMonoBehaviour> releaseAction)
	{
		_releaseAction = releaseAction;
	}

	public virtual void Release()
	{
		_releaseAction?.Invoke(this);
	}
}
public class ReuseMonoBehaviourGenerator<T> : SingletonMonoBehaviour<T> where T : MonoBehaviourWithInit
{
	protected ReuseMonoBehaviourObjetPool CreatePool(string poolObjectName, string prefabPath)
	{
		return CreatePool(base.transform, poolObjectName, prefabPath);
	}

	protected PoolType CreatePool<PoolType>(string poolObjectName, string prefabPath) where PoolType : ReuseMonoBehaviourObjetPool
	{
		return CreatePool<PoolType>(base.transform, poolObjectName, prefabPath);
	}

	protected ReuseMonoBehaviourObjetPool CreatePool(Transform parent, string poolObjectName, string prefabPath)
	{
		return CreatePool<ReuseMonoBehaviourObjetPool>(parent, poolObjectName, prefabPath);
	}

	private PoolType CreatePool<PoolType>(Transform parent, string poolObjectName, string prefabPath) where PoolType : ReuseMonoBehaviourObjetPool
	{
		PoolType val = parent.CreateChild<PoolType>(poolObjectName);
		val.transform.ResetInLocal();
		ReuseMonoBehaviour reuseMonoBehaviour = Resources.Load<ReuseMonoBehaviour>(prefabPath);
		if (reuseMonoBehaviour == null)
		{
			Debug.LogError(prefabPath + "が存在しません");
		}
		ReuseMonoBehaviour orizinal = UnityEngine.Object.Instantiate(reuseMonoBehaviour);
		val.CreateInitialPool(orizinal);
		return val;
	}
}
public class ReuseMonoBehaviourObjetPool : MonoBehaviour
{
	[SerializeField]
	[HideInInspector]
	private ReuseMonoBehaviour _original;

	[SerializeField]
	[HideInInspector]
	private List<ReuseMonoBehaviour> _poolingList = new List<ReuseMonoBehaviour>();

	[SerializeField]
	[HideInInspector]
	private List<ReuseMonoBehaviour> _usingList = new List<ReuseMonoBehaviour>();

	public ReuseMonoBehaviour Original => _original;

	public List<ReuseMonoBehaviour> UsingList => _usingList;

	public void CreateInitialPool(ReuseMonoBehaviour orizinal, int objectNum = 0)
	{
		_original = orizinal;
		_original.InitOnFirstInstantiate();
		_original.transform.SetParent(base.transform);
		_original.transform.ResetInLocal();
		_original.gameObject.SetActive(value: false);
		List<ReuseMonoBehaviour> list = new List<ReuseMonoBehaviour>();
		for (int i = 0; i < objectNum; i++)
		{
			list.Add(Get());
		}
		foreach (ReuseMonoBehaviour item in list)
		{
			Release(item);
		}
	}

	public T Get<T>() where T : ReuseMonoBehaviour
	{
		return Get() as T;
	}

	private ReuseMonoBehaviour Get()
	{
		ReuseMonoBehaviour reuseMonoBehaviour = null;
		if (_poolingList.Count > 0)
		{
			reuseMonoBehaviour = _poolingList.Pop();
		}
		else
		{
			reuseMonoBehaviour = UnityEngine.Object.Instantiate(_original, base.transform);
			reuseMonoBehaviour.name = _original.name;
		}
		reuseMonoBehaviour.gameObject.SetActive(value: true);
		reuseMonoBehaviour.Init(Release);
		_usingList.Add(reuseMonoBehaviour);
		return reuseMonoBehaviour;
	}

	protected virtual void Release(ReuseMonoBehaviour target)
	{
		_usingList.Remove(target);
		target.gameObject.SetActive(value: false);
		target.transform.SetParent(base.transform);
		if (_poolingList.Contains(target))
		{
			Debug.LogWarning(string.Concat(target, "は既にプールに入っています！"));
		}
		else
		{
			_poolingList.Add(target);
		}
	}
}
public class ReuseParticlePlayer : ReuseMonoBehaviour
{
	[SerializeField]
	[Required]
	protected ParticleSystem _particleSystem;

	private Action<ReuseParticlePlayer> _callback;

	[SerializeField]
	private AudioClip _audioClip;

	[SerializeField]
	[HideInInspector]
	private AudioPlayer _sePlayer;

	public ParticleSystem ParticleSystem => _particleSystem;

	public override void InitOnFirstInstantiate()
	{
		if (_audioClip != null)
		{
			_sePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, _audioClip);
		}
	}

	public void SetLoop(bool isLoop)
	{
		ParticleSystem.MainModule main = _particleSystem.main;
		main.loop = isLoop;
	}

	public void Play(float pitch, bool is3DSound, Action<ReuseParticlePlayer> callback = null)
	{
		_callback = callback;
		ParticleSystem.MainModule main = _particleSystem.main;
		main.stopAction = ParticleSystemStopAction.Callback;
		_particleSystem.Play();
		if (_sePlayer != null)
		{
			if (!is3DSound)
			{
				_sePlayer.Disable3DSound();
			}
			_sePlayer.Play(1f, 0f, pitch);
		}
	}

	private void OnParticleSystemStopped()
	{
		_callback?.Invoke(this);
		Release();
	}
}
public abstract class SimpleAnimationMonoBehaviour : MonoBehaviour
{
	[SerializeField]
	private SimpleAnimation _simpleAnimation;

	[SerializeField]
	private List<AnimationClip> _animationClipList = new List<AnimationClip>();

	private string _currentStateName;

	private Action _callback;

	public List<AnimationClip> AnimationClipList => _animationClipList;

	protected virtual void Awake()
	{
		if (_simpleAnimation == null)
		{
			_simpleAnimation = base.gameObject.AddComponent<SimpleAnimation>();
		}
	}

	protected virtual void Start()
	{
		foreach (AnimationClip animationClip in _animationClipList)
		{
			_simpleAnimation.AddClip(animationClip, animationClip.name);
		}
	}

	protected virtual void Update()
	{
		if (_callback != null && _simpleAnimation.GetState(_currentStateName).normalizedTime >= 1f)
		{
			Action callback = _callback;
			_callback = null;
			StartCoroutine(this.DelayMethod(0.01f, callback));
		}
	}

	public void CrossFade(int stateNo, float fadeLength = 0.1f, Action callback = null)
	{
		if (stateNo >= _animationClipList.Count)
		{
			Debug.LogWarning($"{stateNo}番目のアニメーションはありません");
		}
		else
		{
			CrossFade(_animationClipList[stateNo].name, fadeLength, callback);
		}
	}

	public void CrossFade(string stateName, float fadeLength = 0.1f, Action callback = null)
	{
		if (_currentStateName == stateName)
		{
			return;
		}
		if (_simpleAnimation.GetState(stateName) == null)
		{
			Debug.LogWarning(stateName + "というアニメーションがありません!");
			callback?.Invoke();
			return;
		}
		if (_callback != null)
		{
			Debug.LogWarning(stateName + "の再生が開始されたため、" + _currentStateName + "の再生を中止し、コールバックをすぐに実行します");
			_callback();
		}
		_currentStateName = stateName;
		_callback = callback;
		_simpleAnimation.CrossFade(_currentStateName, fadeLength);
	}
}
public abstract class SingletonMonoBehaviour<T> : MonoBehaviourWithInit where T : MonoBehaviourWithInit
{
	private static T _instance;

	public static T Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
				if (_instance == null)
				{
					Debug.LogError(string.Concat(typeof(T), " is nothing"));
				}
				else
				{
					_instance.InitIfNeeded();
				}
			}
			return _instance;
		}
	}

	protected override void Awake()
	{
		if (!(this == Instance))
		{
			Debug.LogError(string.Concat(typeof(T), " is duplicated"));
		}
	}
}
public class MonoBehaviourWithInit : MonoBehaviour
{
	private bool _isInitialized;

	public void InitIfNeeded()
	{
		if (!_isInitialized)
		{
			Init();
			_isInitialized = true;
		}
	}

	protected virtual void Init()
	{
	}

	protected virtual void Awake()
	{
	}
}
public class AchievementInfo
{
	public AchievementType AchievementType { get; private set; }

	public string Name { get; private set; } = "";


	public string Description { get; private set; } = "";


	public bool IsAchieved { get; private set; }

	public Sprite Icon { get; private set; }

	public AchievementInfo(AchievementType achievementType)
	{
		AchievementType = achievementType;
	}

	public void UpdateIfNeeded()
	{
		IsAchieved = UserDataAccessorManager.PlayRecordDataAccessor.IsAchieved(AchievementType);
		Icon = SingletonMonoBehaviour<AchievementManager>.Instance.GetSprite(AchievementType, IsAchieved);
	}
}
public class AchievementManager : SingletonMonoBehaviour<AchievementManager>
{
	private SpriteAtlas _iconSpriteAtlas;

	private readonly List<AchievementInfo> _infoList = new List<AchievementInfo>();

	private List<AchievementType> _hiddenTypeList = new List<AchievementType>();

	public event Action<AchievementInfo> UpdatedInfo = delegate
	{
	};

	private void Start()
	{
		_iconSpriteAtlas = Resources.Load<SpriteAtlas>("Texture/AchievementIcon");
		foreach (AchievementType allIn in EnumUtility.GetAllInList<AchievementType>())
		{
			_infoList.Add(new AchievementInfo(allIn));
		}
		StartCoroutine(this.DelayMethod(0.1f, UpdateAllInfo));
	}

	public void UpdateAllInfo()
	{
		foreach (AchievementInfo info in _infoList)
		{
			info.UpdateIfNeeded();
			this.UpdatedInfo(info);
		}
	}

	public void UpdateInfo(AchievementType achievementType)
	{
		AchievementInfo info = GetInfo(achievementType);
		info.UpdateIfNeeded();
		this.UpdatedInfo(info);
	}

	public static int GetAchievementTotal()
	{
		return EnumUtility.GetTypeNum<AchievementType>();
	}

	public int GetAchievedTotal()
	{
		return _infoList.Count((AchievementInfo info) => info.IsAchieved);
	}

	public AchievementInfo GetInfo(AchievementType achievementType)
	{
		AchievementInfo achievementInfo = _infoList.FirstOrDefault((AchievementInfo info) => info.AchievementType == achievementType);
		if (achievementInfo == null)
		{
			Debug.LogWarning($"{achievementType}の情報がありません");
			return null;
		}
		return achievementInfo;
	}

	public Sprite GetSprite(AchievementType achievementType, bool isAchieved)
	{
		string text = achievementType.ToString() + (isAchieved ? "1" : "2");
		if (_hiddenTypeList.Contains(achievementType) && !isAchieved)
		{
			text = "HiddenIcon";
		}
		return _iconSpriteAtlas.GetSprite(text);
	}

	public void SetAllAchievement()
	{
		EnumUtility.GetAllInList<AchievementType>().ForEach(SetAchievement);
	}

	public void SetAchievement(AchievementType achievementType)
	{
		Debug.Log($"実績{achievementType}を獲得");
		UserDataAccessorManager.PlayRecordDataAccessor.SetAchievement(achievementType);
		StartCoroutine(this.DelayMethod(0.1f, UpdateInfo, achievementType));
	}

	public void ClearAllAchievement()
	{
		EnumUtility.GetAllInList<AchievementType>().ForEach(ClearAchievement);
		StartCoroutine(this.DelayMethod(0.1f, UpdateAllInfo));
	}

	public void ClearAchievement(AchievementType achievementType)
	{
		Debug.Log($"実績{achievementType}を無効に");
		UserDataAccessorManager.PlayRecordDataAccessor.ClearAchievement(achievementType);
		StartCoroutine(this.DelayMethod(0.1f, UpdateInfo, achievementType));
	}
}
public class AchievementViewer : SingletonMonoBehaviour<AchievementViewer>
{
	[SerializeField]
	[Required]
	private SuperTextMesh _titleText;

	[SerializeField]
	[Required]
	private AchievementViewerParts _originalParts;

	private List<AchievementViewerParts> _partsList = new List<AchievementViewerParts>();

	private Coroutine _coroutine;

	private void Start()
	{
		FontMasterData.Entity.UpdateFont(_titleText);
		int num = 6;
		List<AchievementType> allInList = EnumUtility.GetAllInList<AchievementType>();
		_originalParts.AchievementType = allInList[0];
		_originalParts.TriggeredHand += OnTriggerHand;
		_partsList.Add(_originalParts);
		for (int i = 1; i < allInList.Count; i++)
		{
			int num2 = i % num;
			int num3 = i / num;
			AchievementViewerParts achievementViewerParts = _originalParts.transform.parent.CreateChildFromOriginal<AchievementViewerParts>(_originalParts.transform);
			achievementViewerParts.transform.localRotation = _originalParts.transform.localRotation;
			achievementViewerParts.transform.localPosition = _originalParts.transform.localPosition + new Vector3(28.3f * (float)num2, -28.3f * (float)num3 * 1.6f, 0f);
			achievementViewerParts.AchievementType = allInList[i];
			achievementViewerParts.TriggeredHand += OnTriggerHand;
			_partsList.Add(achievementViewerParts);
		}
		SingletonMonoBehaviour<AchievementManager>.Instance.UpdatedInfo += OnUpdateAchievementInfo;
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene += DiscardEvent;
		UpdateTitleText();
		StartCoroutine(this.DelayMethod(0.1f, SingletonMonoBehaviour<AchievementManager>.Instance.UpdateAllInfo));
	}

	private void DiscardEvent()
	{
		SingletonMonoBehaviour<AchievementManager>.Instance.UpdatedInfo -= OnUpdateAchievementInfo;
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene -= DiscardEvent;
	}

	private void OnTriggerHand(AchievementViewerParts parts)
	{
		AchievementType achievementType = parts.AchievementType;
		string text = (parts.IsAchieved ? LocalizedUtility.Get($"{achievementType}Title") : "???");
		string text2 = LocalizedUtility.Get($"{achievementType}Description");
		_titleText.text = text + "\n" + text2;
		_titleText.Rebuild();
		if (_coroutine != null)
		{
			StopCoroutine(_coroutine);
		}
		_coroutine = StartCoroutine(this.DelayMethod(2f, UpdateTitleText));
		UpdatePartsColor(parts);
	}

	private void OnUpdateAchievementInfo(AchievementInfo info)
	{
		_partsList.FirstOrDefault((AchievementViewerParts parts) => parts.AchievementType == info.AchievementType).UpdateUI(info);
		UpdateTitleText();
	}

	private void UpdateTitleText()
	{
		if (_coroutine != null)
		{
			StopCoroutine(_coroutine);
		}
		_titleText.text = string.Format(LocalizedUtility.Get("AchievementTitleText"), Mathf.RoundToInt(100f * (float)_partsList.Count((AchievementViewerParts parts) => parts.IsAchieved) / (float)_partsList.Count));
		_titleText.Rebuild();
		UpdatePartsColor();
	}

	private void UpdatePartsColor(AchievementViewerParts selectedParts = null)
	{
		foreach (AchievementViewerParts parts in _partsList)
		{
			parts.UpdateColor(parts == selectedParts);
		}
	}
}
public class AchievementViewerParts : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Image _iconImage;

	[SerializeField]
	private Color _defaultColor;

	[SerializeField]
	private Color _selectedColor;

	[SerializeField]
	private ParticleSystem _particleSystem;

	private bool _isInitialized;

	public AchievementType AchievementType { get; set; }

	public bool IsAchieved { get; private set; }

	public event Action<AchievementViewerParts> TriggeredHand = delegate
	{
	};

	private void Awake()
	{
		GetComponent<VRHandTriggerTarget>().Triggered += OnTriggerHand;
		UpdateColor(isSelected: false);
	}

	private void OnTriggerHand(VRHand hand)
	{
		hand.Vibrate();
		this.TriggeredHand(this);
	}

	public void UpdateColor(bool isSelected)
	{
		_iconImage.color = (isSelected ? _selectedColor : _defaultColor);
	}

	public void UpdateUI(AchievementInfo info)
	{
		bool isAchieved = IsAchieved;
		_iconImage.sprite = info.Icon;
		IsAchieved = info.IsAchieved;
		if (_isInitialized && !isAchieved && IsAchieved)
		{
			_particleSystem.Play();
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_ClackerOne", _particleSystem.gameObject, is3DSound: true);
		}
		_isInitialized = true;
	}
}
public static class AnalyticsUtility
{
	public static void SendPlayCount(int count)
	{
		AnalyticsEvent.LevelStart(count);
	}

	public static void SendHighScore(int Score)
	{
		Analytics.CustomEvent("HighScore", new Dictionary<string, object> { { "HighScore", Score } });
	}
}
public class SimpleAnimationChanger : MonoBehaviour
{
	[SerializeField]
	private SimpleAnimation _simpleAnimation;

	[SerializeField]
	private AnimationClip _animationClip;

	private AnimationClip _beforeAnimationClip;

	private Dictionary<string, string> _stateNameDict = new Dictionary<string, string>();

	private bool _isInitialized;

	public Dictionary<string, string> StateNameDict => _stateNameDict;

	private void Start()
	{
		if (_simpleAnimation != null)
		{
			Init();
		}
	}

	public void SetSimpleAnimation(SimpleAnimation simpleAnimation)
	{
		_simpleAnimation = simpleAnimation;
		Init();
	}

	private void Init()
	{
		if (_isInitialized)
		{
			return;
		}
		_isInitialized = true;
		_beforeAnimationClip = _animationClip;
		foreach (SimpleAnimation.State state in _simpleAnimation.GetStates())
		{
			_stateNameDict[state.clip.name] = state.name;
		}
	}

	private void OnValidate()
	{
		if (UnityEngine.Application.isPlaying && _isInitialized && _beforeAnimationClip != _animationClip)
		{
			AddStateIfneeded();
			_beforeAnimationClip = _animationClip;
		}
	}

	public void Change(string stateName)
	{
		if (_simpleAnimation == null)
		{
			Debug.LogError("_simpleAnimationがありません!");
		}
		else if (_simpleAnimation.GetState(stateName) == null)
		{
			Debug.LogError(stateName + "というアニメーションがありません!");
		}
		else
		{
			_simpleAnimation.CrossFade(stateName, 0.5f);
		}
	}

	private void AddStateIfneeded()
	{
		string text = _animationClip.name;
		if (_simpleAnimation.GetState(text) == null)
		{
			_simpleAnimation.AddState(_animationClip, text);
			_stateNameDict[_animationClip.name] = text;
		}
		Change(text);
	}
}
public class AudioPlayer : MonoBehaviour
{
	public enum State
	{
		Wait,
		Delay,
		Playing,
		Pause,
		Fading
	}

	[SerializeField]
	private AudioSource _audioSource;

	[SerializeField]
	private Action _callback;

	[SerializeField]
	private State _currentState;

	[SerializeField]
	private float _volumeRate;

	[SerializeField]
	private float _initialDelay;

	[SerializeField]
	private float _currentDelay;

	[SerializeField]
	private float _fadeProgress;

	[SerializeField]
	private float _fadeDuration;

	[SerializeField]
	private float _fadeFrom;

	[SerializeField]
	private float _fadeTo;

	private Action _fadeCallback;

	[SerializeField]
	private Action<AudioPlayer> _destroyAction;

	private const float MIN_DISTANCE = 0.2f;

	private const float MAX_DISTANCE = 10f;

	public float PlayedTime => _audioSource.time;

	public string CurrentAudioName
	{
		get
		{
			if (!(_audioSource.clip == null))
			{
				return _audioSource.clip.name;
			}
			return "";
		}
	}

	public State CurrentState => _currentState;

	public float ElapsedDelay => _initialDelay - _currentDelay;

	public void Init(GameObject targetObject, AudioClip audioClip, Action<AudioPlayer> destroyAction)
	{
		_audioSource = targetObject.AddComponent<AudioSource>();
		_audioSource.clip = audioClip;
		_audioSource.playOnAwake = false;
		_audioSource.spatialBlend = 1f;
		_audioSource.reverbZoneMix = 1f;
		_audioSource.rolloffMode = AudioRolloffMode.Linear;
		_audioSource.minDistance = 0.2f;
		_audioSource.maxDistance = 10f;
		_destroyAction = destroyAction;
	}

	public void Disable3DSound()
	{
		_audioSource.spatialBlend = 0f;
		_audioSource.reverbZoneMix = 0f;
		_audioSource.minDistance = 0f;
		_audioSource.maxDistance = 600f;
	}

	private void OnDestroy()
	{
		_destroyAction?.Invoke(this);
	}

	private void Update()
	{
		if (_currentState == State.Playing && !_audioSource.isPlaying && Mathf.Approximately(_audioSource.time, 0f))
		{
			Finish();
		}
		else if (_currentState == State.Delay)
		{
			Delay();
		}
		else if (_currentState == State.Fading)
		{
			Fade();
		}
	}

	private void Delay()
	{
		_currentDelay -= Time.deltaTime;
		if (!(_currentDelay > 0f))
		{
			_audioSource.Play();
			if (_fadeDuration > 0f)
			{
				_currentState = State.Fading;
				Update();
			}
			else
			{
				_currentState = State.Playing;
			}
		}
	}

	private void Fade()
	{
		_fadeProgress += Time.deltaTime;
		float num = Mathf.Min(_fadeProgress / _fadeDuration, 1f);
		_audioSource.volume = GetVolume() * (_fadeFrom * (1f - num) + _fadeTo * num);
		if (!(num < 1f))
		{
			if (_fadeTo <= 0f)
			{
				Finish();
			}
			else
			{
				_currentState = State.Playing;
			}
			_fadeCallback?.Invoke();
		}
	}

	public void UpdateVolume()
	{
		_audioSource.volume = GetVolume();
	}

	public void ChangeVolumeRate(float volumeRate)
	{
		_volumeRate = volumeRate;
		UpdateVolume();
	}

	private float GetVolume()
	{
		return AudioVolumeSetting.Entity.GetVolume(_audioSource.clip) * _volumeRate;
	}

	public void ChangeDistance(float min = 0.2f, float max = 10f)
	{
		_audioSource.minDistance = min;
		_audioSource.maxDistance = max;
	}

	public void ChangeTime(float time)
	{
		_audioSource.time = time;
	}

	public void Replay(Action callback = null)
	{
		Play(_volumeRate, _initialDelay, _audioSource.pitch, _audioSource.loop, callback);
	}

	public void Play(float volumeRate = 1f, float delay = 0f, float pitch = 1f, bool isLoop = false, Action callback = null)
	{
		if (_currentState != 0)
		{
			Stop();
		}
		_audioSource.Stop();
		_volumeRate = volumeRate;
		_audioSource.volume = GetVolume();
		_initialDelay = delay;
		_currentDelay = _initialDelay;
		_audioSource.pitch = pitch;
		_audioSource.loop = isLoop;
		_callback = callback;
		_currentState = ((_currentDelay > 0f) ? State.Delay : State.Playing);
		if (_currentState == State.Playing)
		{
			_audioSource.Play();
		}
		if (!_audioSource.loop && _currentState == State.Pause)
		{
			Pause();
		}
	}

	public void Stop(string audioName)
	{
		if (audioName == CurrentAudioName)
		{
			Stop();
		}
	}

	public void Stop()
	{
		_callback = null;
		Finish();
	}

	private void Finish()
	{
		_currentState = State.Wait;
		_audioSource.Stop();
		_initialDelay = 0f;
		_currentDelay = 0f;
		_fadeDuration = 0f;
		_callback?.Invoke();
	}

	public void Pause(string audioName)
	{
		if (audioName == CurrentAudioName)
		{
			Pause();
		}
	}

	public void Pause()
	{
		if (_currentState == State.Playing || _currentState == State.Fading)
		{
			_audioSource.Pause();
		}
		_currentState = State.Pause;
	}

	public void UnPause(string audioName)
	{
		if (audioName == CurrentAudioName)
		{
			UnPause();
		}
	}

	public void UnPause()
	{
		if (_currentState == State.Pause)
		{
			if (_audioSource.clip == null)
			{
				_currentState = State.Wait;
				return;
			}
			if (_currentDelay > 0f)
			{
				_currentState = State.Delay;
				return;
			}
			_audioSource.UnPause();
			_currentState = ((_fadeDuration > 0f) ? State.Fading : State.Playing);
		}
	}

	public void Fade(string audioName, float duration, float from, float to, Action callback = null)
	{
		if (audioName == CurrentAudioName)
		{
			Fade(duration, from, to, callback);
		}
	}

	public void Fade(float duration, float from, float to, Action callback = null)
	{
		if (_currentState == State.Playing || _currentState == State.Delay || _currentState == State.Fading)
		{
			_fadeProgress = 0f;
			_fadeDuration = duration;
			_fadeFrom = from;
			_fadeTo = to;
			_fadeCallback = callback;
			if (_currentState == State.Playing)
			{
				_currentState = State.Fading;
			}
			if (_currentState == State.Fading)
			{
				Update();
			}
		}
	}

	public void CancelFade()
	{
		_fadeProgress = 0f;
		_fadeDuration = 0f;
		_audioSource.volume = GetVolume();
		_currentState = State.Playing;
	}
}
public class AudioPlayerManager : SingletonMonoBehaviour<AudioPlayerManager>
{
	private Dictionary<string, AudioClip> _audioClipDict = new Dictionary<string, AudioClip>();

	private readonly List<AudioPlayer> _audioPlayerList = new List<AudioPlayer>();

	protected override void Init()
	{
		base.Init();
		_audioClipDict = Resources.LoadAll<AudioClip>("Audio").ToDictionary((AudioClip clip) => clip.name, (AudioClip clip) => clip);
	}

	public void ReleasePlayer(AudioPlayer audioPlayer)
	{
		_audioPlayerList.Remove(audioPlayer);
	}

	public List<string> GetCurrentAudioNames()
	{
		return (from player in _audioPlayerList
			where player.CurrentState != AudioPlayer.State.Wait
			select player.CurrentAudioName).ToList();
	}

	public bool IsPlaying()
	{
		return GetCurrentAudioNames().Count > 0;
	}

	public AudioPlayer GetPlayer(GameObject targetObject, AudioClip audioClip)
	{
		AudioPlayer audioPlayer = targetObject.AddComponent<AudioPlayer>();
		audioPlayer.Init(targetObject, audioClip, ReleasePlayer);
		return audioPlayer;
	}

	public AudioPlayer GetPlayer(GameObject targetObject, string audioPath)
	{
		return GetPlayer(targetObject, GetAudioClip(audioPath));
	}

	private string PathToName(string audioPath)
	{
		return System.IO.Path.GetFileNameWithoutExtension(audioPath);
	}

	private AudioClip GetAudioClip(string audioPath)
	{
		string key = PathToName(audioPath);
		if (_audioClipDict.ContainsKey(key))
		{
			return _audioClipDict[key];
		}
		AudioClip audioClip = Resources.Load<AudioClip>(audioPath);
		if (audioClip == null)
		{
			Debug.LogError(audioPath + " not found");
		}
		return audioClip;
	}

	public void PlayOneShot(AudioClip audioClip, GameObject target = null, bool is3DSound = false)
	{
		if (target == null)
		{
			target = base.gameObject;
		}
		AudioPlayer player = GetPlayer(target, audioClip);
		if (!is3DSound)
		{
			player.Disable3DSound();
		}
		player.Play(1f, 0f, 1f, isLoop: false, delegate
		{
			ReleasePlayer(player);
		});
	}

	public void PlayOneShot(string audioPath, GameObject target = null, bool is3DSound = false)
	{
		PlayOneShot(GetAudioClip(audioPath), target, is3DSound);
	}

	public void PlayOneShot(string audioPath, Vector3 position)
	{
		GameObject target = new GameObject(audioPath);
		target.transform.position = position;
		AudioPlayer player = GetPlayer(target, GetAudioClip(audioPath));
		player.Play(1f, 0f, 1f, isLoop: false, delegate
		{
			ReleasePlayer(player);
			UnityEngine.Object.Destroy(target);
		});
	}

	public void Stop(string audioPathOrName)
	{
		string audioName = PathToName(audioPathOrName);
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.Stop(audioName);
		});
	}

	public void Stop()
	{
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.Stop();
		});
	}

	public void Fade(string audioPathOrName, float duration, float from, float to, Action callback)
	{
		string audioName = PathToName(audioPathOrName);
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.Fade(audioName, duration, from, to, callback);
		});
	}

	public void FadeOut(string audioPathOrName, float duration = 1f, Action callback = null)
	{
		string audioPathOrName2 = PathToName(audioPathOrName);
		Fade(audioPathOrName2, duration, 1f, 0f, callback);
	}

	public void FadeIn(string audioPathOrName, float duration = 1f, Action callback = null)
	{
		string audioPathOrName2 = PathToName(audioPathOrName);
		Fade(audioPathOrName2, duration, 0f, 1f, callback);
	}

	public void Fade(float duration, float from, float to, Action callback)
	{
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.Fade(duration, from, to, callback);
		});
	}

	public void FadeOut(float duration = 1f, Action callback = null)
	{
		Fade(duration, 1f, 0f, callback);
	}

	public void FadeIn(float duration = 1f, Action callback = null)
	{
		Fade(duration, 0f, 1f, callback);
	}

	public void Pause(string audioPathOrName)
	{
		string audioName = PathToName(audioPathOrName);
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.UnPause(audioName);
		});
	}

	public void Pause()
	{
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.Pause();
		});
	}

	public void UnPause(string audioPathOrName)
	{
		string audioName = PathToName(audioPathOrName);
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.UnPause(audioName);
		});
	}

	public void UnPause()
	{
		_audioPlayerList.ForEach(delegate(AudioPlayer player)
		{
			player.UnPause();
		});
	}
}
[Serializable]
public class AudioVolumeInfo
{
	[SerializeField]
	private AudioClip _audioClip;

	[SerializeField]
	private float _volume = 1f;

	public AudioClip AudioClip => _audioClip;

	public float Volume
	{
		get
		{
			return _volume;
		}
		set
		{
			_volume = value;
		}
	}

	public AudioVolumeInfo(AudioClip audioClip, float volume = 1f)
	{
		_audioClip = audioClip;
		_volume = volume;
	}
}
public class AudioVolumeSetting : ScriptableObject
{
	private static AudioVolumeSetting _entity;

	[SerializeField]
	private List<AudioVolumeInfo> _infoList = new List<AudioVolumeInfo>();

	public static AudioVolumeSetting Entity
	{
		get
		{
			if (_entity == null)
			{
				_entity = Resources.Load<AudioVolumeSetting>("Data/AudioVolumeSetting");
			}
			return _entity;
		}
	}

	public void SetVolume(AudioClip targetAudioClip, float volume)
	{
		AudioVolumeInfo audioVolumeInfo = _infoList.FirstOrDefault((AudioVolumeInfo volumeInfo) => volumeInfo.AudioClip == targetAudioClip);
		if (audioVolumeInfo == null)
		{
			audioVolumeInfo = new AudioVolumeInfo(targetAudioClip, volume);
			_infoList.Add(audioVolumeInfo);
		}
		audioVolumeInfo.Volume = volume;
	}

	public AudioVolumeInfo GetInfo(AudioClip targetAudioClip)
	{
		return _infoList.FirstOrDefault((AudioVolumeInfo volumeInfo) => volumeInfo.AudioClip == targetAudioClip);
	}

	public float GetVolume(AudioClip targetAudioClip)
	{
		VolumeType volumeType = VolumeType.Etc;
		string text = targetAudioClip.name;
		if (text.Contains("BGM_") || text == "SE_Chime")
		{
			volumeType = VolumeType.BGM;
		}
		else if (text.Contains("Voice_"))
		{
			volumeType = VolumeType.Voice;
		}
		else if (text == "SE_HeartBeat")
		{
			volumeType = VolumeType.HeartBeat;
		}
		else if (text.Contains("SE_FootStep"))
		{
			volumeType = VolumeType.FootStep;
		}
		return (GetInfo(targetAudioClip)?.Volume ?? 1f) * UserDataAccessorManager.SettingDataAccessor.GetVolume(volumeType);
	}
}
public static class CacheData
{
	public static bool ShouldSetVrCameraPosition { get; private set; } = false;


	public static Vector3 VrCameraPosition { get; private set; } = Vector3.zero;


	public static void SetVRCameraPosition(Vector3 cameraPosition)
	{
		VrCameraPosition = cameraPosition;
		ShouldSetVrCameraPosition = true;
	}

	public static void ResetVRCameraPosition()
	{
		ShouldSetVrCameraPosition = false;
	}
}
public class FontMasterData : ScriptableObject
{
	private static FontMasterData _entity;

	[SerializeField]
	private List<FontMasterInfo> _infoList = new List<FontMasterInfo>();

	public static FontMasterData Entity
	{
		get
		{
			if (_entity == null)
			{
				_entity = Resources.Load<FontMasterData>("Data/FontMasterData");
			}
			return _entity;
		}
	}

	public void UpdateFonts(params SuperTextMesh[] texts)
	{
		foreach (SuperTextMesh text in texts)
		{
			UpdateFont(text);
		}
	}

	public void UpdateFont(SuperTextMesh text)
	{
		UpdateFont(text, text.font);
	}

	public void UpdateFont(SuperTextMesh text, Font defaultFont)
	{
		FontMasterInfo fontMasterInfo = _infoList.FirstOrDefault((FontMasterInfo info) => info.TargetFont == defaultFont);
		if (fontMasterInfo == null)
		{
			Debug.LogWarning($"{defaultFont}というフォントに対応するデータが設定されていません : {text.gameObject.name}");
		}
		else
		{
			text.font = fontMasterInfo.GetCurrentFont();
		}
	}
}
[Serializable]
public class FontMasterInfo
{
	[SerializeField]
	[Required]
	private Font _targetFont;

	[SerializeField]
	private List<LanguageFontPair> _pairList = new List<LanguageFontPair>();

	public Font TargetFont => _targetFont;

	public Font GetCurrentFont()
	{
		AvailableLanguage currentLanguage = UserDataAccessorManager.SettingDataAccessor.CurrentLanguage;
		LanguageFontPair languageFontPair = _pairList.FirstOrDefault((LanguageFontPair pair) => pair.Language == currentLanguage);
		if (languageFontPair != null)
		{
			return languageFontPair.Font;
		}
		return _targetFont;
	}
}
[Serializable]
public class LanguageFontPair
{
	[SerializeField]
	private AvailableLanguage _language;

	[SerializeField]
	private Font _font;

	public AvailableLanguage Language => _language;

	public Font Font => _font;
}
public static class NonResources
{
}
public class ReactivePropertyObject<T>
{
	private ReactiveProperty<T> _valueReactiveProperty;

	protected T _value
	{
		get
		{
			return _valueReactiveProperty.Value;
		}
		set
		{
			_valueReactiveProperty.Value = value;
		}
	}

	public IObservable<T> Observable => _valueReactiveProperty;

	public ReactivePropertyObject(T t)
	{
		_valueReactiveProperty = new ReactiveProperty<T>(t);
	}
}
public class FlagUserDataObject : UserDataObject<bool>
{
	public FlagUserDataObject(string saveKey, bool defaultValue)
		: base(saveKey, defaultValue)
	{
	}

	public bool IsEnabled()
	{
		return base._value;
	}

	public void ChangeState()
	{
		base._value = !base._value;
	}
}
public class HighScoreRecordDataObject : UserDataListObject<int>
{
	public HighScoreRecordDataObject(string saveKey, int defaultValue, int recordNum)
		: base(saveKey, new List<int>())
	{
		while (_list.Count < recordNum)
		{
			_list.Add(defaultValue);
		}
	}

	public void UpdateRecordIfNeeded(int score)
	{
		int num = -1;
		for (int i = 0; i < _list.Count; i++)
		{
			if (score > _list[i])
			{
				num = i;
				break;
			}
		}
		if (num != -1)
		{
			_list.Insert(num, score);
			_list.RemoveAt(_list.Count - 1);
			OnChange();
		}
	}

	public int GetScore(int order)
	{
		if (order >= _list.Count)
		{
			Debug.LogError($"{order}番目のランキングのスコアはありません : ({_list.Count})");
			return 0;
		}
		return _list[order];
	}

	public int GetOrder(int score)
	{
		return _list.IndexOf(score);
	}
}
public class PlayRecordDataAccessor
{
	private readonly UserDataObject<int> _launchCount;

	private readonly UserDataObject<int> _playCount;

	private readonly UserDataObject<float> _playingTime;

	private readonly UserDataObject<int> _highScore;

	private readonly HighScoreRecordDataObject _highScoreRecord;

	public static readonly int HIGH_SCORE_RECORD_NUM = 10;

	private readonly UserDataObject<int> _lickedCount;

	private readonly UserDataListObject<string> _lickedObjectTypes;

	private readonly Dictionary<GirlVoiceType, UserDataObject<int>> _girlVoiceNoDict = new Dictionary<GirlVoiceType, UserDataObject<int>>();

	private readonly UserDataObject<int> _hintNo;

	private Dictionary<AchievementType, UserDataObject<bool>> _achievementDict = new Dictionary<AchievementType, UserDataObject<bool>>();

	public int LaunchCount => _launchCount.Value;

	public IObservable<float> PlayingTimeObservable => _playingTime.Observable;

	public int HighScore => _highScore.Value;

	public int LickedCount => _lickedCount.Value;

	private IEnumerable<string> LickedObjectTypesEnumerable => _lickedObjectTypes.Enumerable;

	public int LickedObjectNum => _lickedObjectTypes.Count;

	public event Action<List<string>> ChangedLickedObjectTypes = delegate
	{
	};

	public PlayRecordDataAccessor()
	{
		_launchCount = new UserDataObject<int>("LaunchCount", 0);
		_playCount = new UserDataObject<int>("PlayCount", 0);
		_playingTime = new UserDataObject<float>("PlayingTime", 0f);
		_highScore = new UserDataObject<int>("HighScore", 0);
		_highScoreRecord = new HighScoreRecordDataObject("HighScoreRecord", 0, HIGH_SCORE_RECORD_NUM);
		_lickedCount = new UserDataObject<int>("LickedCount", 0);
		_lickedObjectTypes = new UserDataListObject<string>("LickedObjectTypes", new List<string>());
		_lickedObjectTypes.Changed += OnChangeLickedObjectTypes;
		foreach (GirlVoiceType allIn in EnumUtility.GetAllInList<GirlVoiceType>())
		{
			_girlVoiceNoDict[allIn] = new UserDataObject<int>(string.Format("{0}_{1}", "GirlVoiceNo", allIn), 1);
		}
		_hintNo = new UserDataObject<int>("HintNo", 1);
		foreach (AchievementType allIn2 in EnumUtility.GetAllInList<AchievementType>())
		{
			_achievementDict[allIn2] = new UserDataObject<bool>(string.Format("{0}_{1}", "Achievement", allIn2), defaultValue: false);
		}
	}

	public void AddLaunchCount(int num = 1)
	{
		_launchCount.Value += num;
	}

	public void IncrementPlayCount()
	{
		_playCount.Value++;
		AnalyticsUtility.SendPlayCount(_playCount.Value);
	}

	public void AddPlayingTime(float delta)
	{
		_playingTime.Value += delta;
	}

	public bool UpdateHighScoreIfNeeded(int score)
	{
		_highScoreRecord.UpdateRecordIfNeeded(score);
		if (HighScore >= score)
		{
			return false;
		}
		_highScore.Value = score;
		AnalyticsUtility.SendHighScore(score);
		if (score >= 100)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.Point1);
		}
		if (score >= 500)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.Point2);
		}
		if (score >= 1000)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.Point3);
		}
		if (score >= 2000)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.Point4);
		}
		if (score >= 3500)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.Point5);
		}
		if (score >= 5000)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.Point6);
		}
		return true;
	}

	public int GetScore(int order)
	{
		return _highScoreRecord.GetScore(order);
	}

	public int GetOrder(int score)
	{
		return _highScoreRecord.GetOrder(score);
	}

	public void AddLickedCount(int additionalValue = 1)
	{
		_lickedCount.Value += additionalValue;
		int lickedCount = LickedCount;
		Debug.Log($"舐めた回数 : {lickedCount}");
		if (lickedCount >= 50)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedCount1);
		}
		if (lickedCount >= 300)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedCount2);
		}
		if (lickedCount >= 1500)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedCount3);
		}
		if (lickedCount >= 3000)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedCount4);
		}
		if (lickedCount >= 4444)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedCount5);
		}
		if (lickedCount >= 7777)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedCount6);
		}
	}

	public void AddLickedObjectType(LickableObjectType lickableObjectType)
	{
		_lickedObjectTypes.AddToNotDuplicate(lickableObjectType.ToString());
	}

	public void RemoveLickedObjectType(LickableObjectType lickableObjectType)
	{
		_lickedObjectTypes.RemoveIfNeeded(lickableObjectType.ToString());
	}

	public bool IsLicked(LickableObjectType lickableObjectType)
	{
		return _lickedObjectTypes.Contains(lickableObjectType.ToString());
	}

	private void OnChangeLickedObjectTypes(List<string> lickedObjectTypes)
	{
		int count = lickedObjectTypes.Count;
		if (count >= 5)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedTypes1);
		}
		if (count >= 10)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedTypes2);
		}
		if (count >= 20)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedTypes3);
		}
		if (count >= 30)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedTypes4);
		}
		if (count >= 44)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedTypes5);
		}
		if (count >= 77)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.LickedTypes6);
		}
		this.ChangedLickedObjectTypes(lickedObjectTypes);
	}

	public int GetGirlVoiceNo(GirlVoiceType girlVoiceType)
	{
		int value = _girlVoiceNoDict[girlVoiceType].Value;
		int num = value + 1;
		if (girlVoiceType == GirlVoiceType.SerifAction || girlVoiceType == GirlVoiceType.SerifSurprise || girlVoiceType == GirlVoiceType.SerifStartGame || girlVoiceType == GirlVoiceType.SerifLickedGirlGameOver || girlVoiceType == GirlVoiceType.SerifStoleGameOver)
		{
			if (num > 10)
			{
				num = 1;
			}
		}
		else if (num > 5)
		{
			num = 1;
		}
		_girlVoiceNoDict[girlVoiceType].Value = num;
		return value;
	}

	public int GetHintNo()
	{
		return _hintNo.Value;
	}

	public void IncreaseHintNo()
	{
		_hintNo.Value++;
		if (_hintNo.Value >= 21)
		{
			_hintNo.Value = 1;
		}
	}

	public bool IsAchieved(AchievementType achievementType)
	{
		return _achievementDict[achievementType].Value;
	}

	public void SetAchievement(AchievementType achievementType)
	{
		_achievementDict[achievementType].Value = true;
	}

	public void ClearAchievement(AchievementType achievementType)
	{
		_achievementDict[achievementType].Value = false;
	}
}
public class SettingDataAccessor
{
	private readonly UserDataObject<AvailableLanguage> _currentLanguage;

	private readonly UserDataObject<AvailableLanguage> _steamGameLanguage;

	private readonly UserDataObject<bool> _isInitializedLanguage;

	private Dictionary<VolumeType, UserDataObject<float>> _volumeDict = new Dictionary<VolumeType, UserDataObject<float>>();

	private Dictionary<GirlClothesType, UserDataObject<bool>> _girlClothesFlagDict = new Dictionary<GirlClothesType, UserDataObject<bool>>();

	private readonly UserDataObject<CharacterType> _currentCharacterType;

	private readonly UserDataObject<int> _bgmNo;

	public static readonly int SQUAT_VALUE_MIN = -1;

	public static readonly int SQUAT_VALUE_MAX = 3;

	private readonly UserDataObject<bool> _squatFlag;

	private readonly UserDataObject<bool> _rotationFlag;

	private readonly UserDataObject<int> _squatValue;

	private readonly UserDataObject<int> _rotationValue;

	public AvailableLanguage CurrentLanguage => _currentLanguage.Value;

	public IObservable<AvailableLanguage> CurrentLanguageObservable => _currentLanguage.Observable;

	public CharacterType CurrentCharacterType
	{
		get
		{
			CharacterType value = _currentCharacterType.Value;
			if (CharacterUtility.CanUse(value))
			{
				return value;
			}
			Debug.LogError($"{value}は使えないのでGirlに変更");
			ChangeCharacterType(CharacterType.Girl);
			return _currentCharacterType.Value;
		}
	}

	public int BGMNo
	{
		get
		{
			if (!BGMUtility.CanUse(_bgmNo.Value))
			{
				Debug.LogError($"BGM{_bgmNo.Value}は使えないので1に変更");
				ChangeBGMNo(1);
			}
			return _bgmNo.Value;
		}
	}

	public bool SquatFlag
	{
		get
		{
			return _squatFlag.Value;
		}
		set
		{
			_squatFlag.Value = value;
			if (!_squatFlag.Value)
			{
				_squatValue.Value = 0;
			}
		}
	}

	public bool RotationFlag
	{
		get
		{
			return _rotationFlag.Value;
		}
		set
		{
			_rotationFlag.Value = value;
			if (!_rotationFlag.Value)
			{
				_rotationValue.Value = 0;
			}
		}
	}

	public int SquatValue
	{
		get
		{
			if (!SquatFlag)
			{
				return 0;
			}
			return _squatValue.Value;
		}
		set
		{
			if (SquatFlag)
			{
				_squatValue.Value = Mathf.Clamp(value, SQUAT_VALUE_MIN, SQUAT_VALUE_MAX);
			}
		}
	}

	public int RotationValue
	{
		get
		{
			if (!RotationFlag)
			{
				return 0;
			}
			return _rotationValue.Value;
		}
		set
		{
			if (RotationFlag)
			{
				_rotationValue.Value = value;
			}
		}
	}

	public event Action ChangedGirlClothes = delegate
	{
	};

	public SettingDataAccessor()
	{
		_currentLanguage = new UserDataObject<AvailableLanguage>("CurrentLanguage", AvailableLanguage.English);
		_steamGameLanguage = new UserDataObject<AvailableLanguage>("SteamLanguage", AvailableLanguage.English);
		_isInitializedLanguage = new UserDataObject<bool>("IsInitializedLanguage", defaultValue: false);
		foreach (VolumeType allIn in EnumUtility.GetAllInList<VolumeType>())
		{
			_volumeDict[allIn] = new UserDataObject<float>(string.Format("{0}_{1}", "Volume", allIn), 1f);
		}
		foreach (GirlClothesType allIn2 in EnumUtility.GetAllInList<GirlClothesType>())
		{
			_girlClothesFlagDict[allIn2] = new UserDataObject<bool>(string.Format("{0}_{1}", "GirlClothes", allIn2), defaultValue: false);
		}
		_currentCharacterType = new UserDataObject<CharacterType>("CharacterType", CharacterType.Girl);
		_bgmNo = new UserDataObject<int>("BGMNo", 1);
		_squatFlag = new UserDataObject<bool>("SquatFlag", defaultValue: true);
		_rotationFlag = new UserDataObject<bool>("RotationSquatFlag", defaultValue: true);
		_squatValue = new UserDataObject<int>("SquatValue", 0);
		_rotationValue = new UserDataObject<int>("RotationSquatValue", 0);
	}

	public void InitLanguageIfNeeded()
	{
		SystemLanguage systemLanguage = UnityEngine.Application.systemLanguage;
		if (!EnumUtility.ContainsKey<AvailableLanguage>(systemLanguage.ToString()))
		{
			Debug.LogWarning($"{systemLanguage}は有効な言語ではないので英語にします");
			systemLanguage = SystemLanguage.English;
		}
		ChangeLanguage(EnumUtility.KeyToType<AvailableLanguage>(systemLanguage.ToString()));
		_isInitializedLanguage.Value = true;
	}

	public void ChangeLanguage(AvailableLanguage language)
	{
		_currentLanguage.Value = language;
		Debug.Log($"言語変更 : {_currentLanguage.Value}");
	}

	public float GetVolume(VolumeType volumeType)
	{
		float num = 1f;
		if (volumeType == VolumeType.Voice && CurrentCharacterType == CharacterType.Boy)
		{
			num = 0.25f;
		}
		return _volumeDict[volumeType].Value * num;
	}

	public void ChangeVolume(VolumeType volumeType, float volume)
	{
		_volumeDict[volumeType].Value = Mathf.Clamp01(volume);
	}

	public bool GetGirlClothesFlag(GirlClothesType clothesType)
	{
		return _girlClothesFlagDict[clothesType].Value;
	}

	public void ChangeGirlClothesFlag(GirlClothesType clothesType, bool flag)
	{
		_girlClothesFlagDict[clothesType].Value = flag;
		this.ChangedGirlClothes();
	}

	public void ChangeCharacterType(CharacterType characterType)
	{
		if (!CharacterUtility.CanUse(characterType))
		{
			Debug.LogError($"{characterType}は使えないので設定できません");
			return;
		}
		_currentCharacterType.Value = characterType;
		Debug.Log($"キャラ変更 : {_currentCharacterType.Value}");
	}

	public void ChangeBGMNo(int bgmNo)
	{
		if (!BGMUtility.CanUse(bgmNo))
		{
			Debug.LogError($"BGMNo.{bgmNo}は使えないので設定できません");
			return;
		}
		_bgmNo.Value = bgmNo;
		Debug.Log($"BGM変更 : {_bgmNo.Value}");
	}
}
public static class UserDataAccessorManager
{
	private static PlayRecordDataAccessor _playRecordDataAccessor;

	private static SettingDataAccessor _settingDataAccessor;

	public static PlayRecordDataAccessor PlayRecordDataAccessor => _playRecordDataAccessor;

	public static SettingDataAccessor SettingDataAccessor => _settingDataAccessor;

	static UserDataAccessorManager()
	{
		CreateAccessors();
	}

	private static void CreateAccessors()
	{
		_playRecordDataAccessor = new PlayRecordDataAccessor();
		_settingDataAccessor = new SettingDataAccessor();
	}
}
public class UserDataListObject<T>
{
	[SerializeField]
	protected List<T> _list;

	public IEnumerable<T> Enumerable => _list;

	public int Count => _list.Count;

	public event Action<List<T>> Changed = delegate
	{
	};

	public UserDataListObject(string saveKey, List<T> defaultValue)
	{
		_list = ES3.Load(saveKey, defaultValue);
		Changed += delegate(List<T> list)
		{
			ES3.Save<List<T>>(saveKey, list);
		};
	}

	public bool Contains(T t)
	{
		return _list.Contains(t);
	}

	public void Add(T t)
	{
		_list.Add(t);
		OnChange();
	}

	public bool AddToNotDuplicate(T t)
	{
		if (Contains(t))
		{
			return false;
		}
		Add(t);
		return true;
	}

	public void Remove(T t)
	{
		_list.Remove(t);
		OnChange();
	}

	public bool RemoveIfNeeded(T t)
	{
		if (!Contains(t))
		{
			return false;
		}
		Remove(t);
		return true;
	}

	protected void OnChange()
	{
		this.Changed(_list);
	}
}
public class UserDataObject<T> : ReactivePropertyObject<T>
{
	public T Value
	{
		get
		{
			return base._value;
		}
		set
		{
			base._value = value;
		}
	}

	public UserDataObject(string saveKey, T defaultValue)
		: base(ES3.Load(saveKey, defaultValue))
	{
		base.Observable.Subscribe(delegate(T value)
		{
			ES3.Save<T>(saveKey, value);
		});
	}
}
public class DebugColliderRenderer : MonoBehaviour
{
}
public class DebugInfoDisplay : MonoBehaviour
{
}
public static class Debug
{
	public static bool isDebugBuild => false;

	public static void Assert(bool condition)
	{
	}

	public static void Assert(bool condition, string message)
	{
	}

	public static void Assert(bool condition, string format, params object[] args)
	{
	}

	public static void Break()
	{
	}

	public static void ClearDeveloperConsole()
	{
	}

	public static void DrawLine(Vector3 start, Vector3 end)
	{
	}

	public static void DrawLine(Vector3 start, Vector3 end, Color color)
	{
	}

	public static void DrawLine(Vector3 start, Vector3 end, Color color, float duration)
	{
	}

	public static void DrawLine(Vector3 start, Vector3 end, Color color, float duration, bool depthTest)
	{
	}

	public static void DrawRay(Vector3 start, Vector3 dir)
	{
	}

	public static void DrawRay(Vector3 start, Vector3 dir, Color color)
	{
	}

	public static void DrawRay(Vector3 start, Vector3 dir, Color color, float duration)
	{
	}

	public static void DrawRay(Vector3 start, Vector3 dir, Color color, float duration, bool depthTest)
	{
	}

	public static void Log(object message, UnityEngine.Object context = null)
	{
	}

	public static void LogFormat(string format, params object[] args)
	{
	}

	public static void LogFormat(UnityEngine.Object context, string format, params object[] args)
	{
	}

	public static void LogError(object message, UnityEngine.Object context = null)
	{
	}

	public static void LogErrorFormat(string format, params object[] args)
	{
	}

	public static void LogErrorFormat(UnityEngine.Object context, string format, params object[] args)
	{
	}

	public static void LogException(Exception exception)
	{
	}

	public static void LogException(Exception exception, UnityEngine.Object context)
	{
	}

	public static void LogWarning(object message, UnityEngine.Object context = null)
	{
	}

	public static void LogWarningFormat(string format, params object[] args)
	{
	}

	public static void LogWarningFormat(UnityEngine.Object context, string format, params object[] args)
	{
	}
}
[RequireComponent(typeof(Text))]
public class DebugLogText : MonoBehaviour
{
	private Text _text;

	private StringBuilder _builder = new StringBuilder();

	private bool _autoScroll = true;

	[SerializeField]
	[Tooltip("テキストの先頭に時刻を表示する")]
	private bool _useTimeStamp = true;

	[SerializeField]
	[Tooltip("ログの種別に応じて色を付ける")]
	private bool _coloredByLogType = true;

	[SerializeField]
	[Tooltip("通常のログを表示するか")]
	private bool _shouldShowNormalLog = true;

	[SerializeField]
	[Tooltip("警告ログを表示するか")]
	private bool _shouldShowWarninglLog = true;

	[SerializeField]
	[Tooltip("エラーログを表示するか")]
	private bool _shouldShowEroorlLog = true;

	[SerializeField]
	[Tooltip("特定の文字列を含むログは表示しない")]
	private string[] _ignore = new string[1] { "[OVR" };

	private void Awake()
	{
		_text = GetComponent<Text>();
		if (_text == null)
		{
			base.enabled = false;
			throw new NullReferenceException("No text component found.");
		}
		if (_autoScroll)
		{
			_text.verticalOverflow = VerticalWrapMode.Truncate;
		}
		if (_coloredByLogType)
		{
			_text.supportRichText = true;
		}
		_text.text = string.Empty;
	}

	private void OnEnable()
	{
		UnityEngine.Application.logMessageReceived += HandleLog;
		_builder = new StringBuilder();
	}

	private void OnDisable()
	{
		UnityEngine.Application.logMessageReceived -= HandleLog;
		_builder = null;
	}

	private void HandleLog(string logText, string stackTrace, LogType logType)
	{
		if ((!_shouldShowNormalLog && logType == LogType.Log) || (!_shouldShowWarninglLog && logType == LogType.Warning) || (!_shouldShowEroorlLog && logType == LogType.Error))
		{
			return;
		}
		_builder.Clear();
		if (_ignore.Length != 0 && _ignore.Any((string t) => t != string.Empty && logText.Contains(t)))
		{
			return;
		}
		if (_useTimeStamp)
		{
			_builder.Append($"[{DateTime.Now.ToLongTimeString()}:{DateTime.Now.Millisecond:D3}] ");
		}
		if (_coloredByLogType)
		{
			switch (logType)
			{
			case LogType.Assert:
			case LogType.Warning:
				logText = GetColoredString(logText, "yellow");
				break;
			case LogType.Error:
			case LogType.Exception:
				logText = GetColoredString(logText, "red");
				break;
			}
		}
		_builder.Append(logText);
		_builder.Append(Environment.NewLine);
		_text.text += _builder.ToString();
		if (_autoScroll && _text.verticalOverflow == VerticalWrapMode.Truncate)
		{
			AdjustText(_text);
		}
	}

	private string GetColoredString(string src, string color)
	{
		return "<color=" + color + ">" + src + "</color>";
	}

	private void AdjustText(Text t)
	{
		TextGenerator cachedTextGenerator = t.cachedTextGenerator;
		cachedTextGenerator.Populate(settings: t.GetGenerationSettings(t.rectTransform.rect.size), str: t.text);
		int characterCountVisible = cachedTextGenerator.characterCountVisible;
		if (characterCountVisible == 0 || t.text.Length <= characterCountVisible)
		{
			return;
		}
		int num = t.text.Length - characterCountVisible;
		string[] array = t.text.Split('\n');
		foreach (string text in array)
		{
			t.text = t.text.Remove(0, text.Length + 1);
			num -= text.Length + 1;
			if (num <= 0)
			{
				break;
			}
		}
	}
}
public class FPSText : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Text _text;

	private int _frameCount;

	private float _prevTime;

	private void Update()
	{
		_frameCount++;
		float num = Time.realtimeSinceStartup - _prevTime;
		if (!(num < 0.5f))
		{
			float num2 = (float)_frameCount / num;
			_text.text = $"FPS : {num2:F2}";
			_frameCount = 0;
			_prevTime = Time.realtimeSinceStartup;
		}
	}
}
public class VRDebugUIManager : SingletonMonoBehaviour<VRDebugUIManager>
{
	private Transform _parent;

	protected override void Init()
	{
		base.Init();
		_parent = base.transform.GetChild(0);
	}

	private void Start()
	{
		base.transform.localScale = Vector3.one * 0.0003f;
		base.transform.localPosition = new Vector3(0f, -0.33f, 0.64f);
		base.transform.localRotation = Quaternion.identity;
		InputEventMediator.Mediate(null, OnInputKey);
		base.gameObject.SetActive(value: false);
	}

	private void OnInputKey(InputKeyType keyType, InputStateType stateType)
	{
		if (stateType == InputStateType.Down && (keyType == InputKeyType.Menu || keyType == InputKeyType.MenuLeft || keyType == InputKeyType.MenuRight))
		{
			_parent.gameObject.SetActive(!_parent.gameObject.activeSelf);
		}
	}
}
public class MeshEffectPlayer : MonoBehaviour
{
	private List<PSMeshRendererUpdater> _meshRendererUpdaterList = new List<PSMeshRendererUpdater>();

	private Coroutine _hideCoroutine;

	[ShowInInspector]
	public bool IsPlaying { get; private set; }

	public void Init(List<Renderer> targetRendererList, string prefabPath, string materialName)
	{
		Transform transform = Resources.Load<Transform>(prefabPath);
		Material material = transform.GetComponentInChildren<ME_MeshMaterialEffect>().Material;
		if (targetRendererList.Count == 0)
		{
			SkinnedMeshRenderer[] componentsInChildren = GetComponentsInChildren<SkinnedMeshRenderer>();
			foreach (SkinnedMeshRenderer target in componentsInChildren)
			{
				CreateMeshRendererUpdater(target, transform, materialName);
			}
			MeshRenderer[] componentsInChildren2 = GetComponentsInChildren<MeshRenderer>();
			foreach (MeshRenderer target2 in componentsInChildren2)
			{
				CreateMeshRendererUpdater(target2, transform, materialName);
			}
		}
		else
		{
			foreach (Renderer targetRenderer in targetRendererList)
			{
				Renderer renderer = targetRenderer.transform.parent.CreateChildFromOriginal<Renderer>(targetRenderer.transform);
				renderer.transform.ResetInLocal();
				renderer.gameObject.SetActive(value: true);
				targetRenderer.gameObject.SetActive(value: false);
				Material[] materials = renderer.materials;
				for (int j = 0; j < materials.Length; j++)
				{
					materials[j] = material;
				}
				renderer.materials = materials;
				CreateMeshRendererUpdater(renderer, transform, materialName);
			}
		}
		Show();
		IsPlaying = false;
		this.LateUpdateAsObservable().FirstOrDefault().Subscribe(delegate
		{
			Hide();
		});
	}

	private void CreateMeshRendererUpdater(Renderer target, Transform prefab, string materialName)
	{
		PSMeshRendererUpdater pSMeshRendererUpdater = target.transform.CreateChildFromOriginal<PSMeshRendererUpdater>(prefab);
		pSMeshRendererUpdater.MaterialName = materialName;
		pSMeshRendererUpdater.UpdateMeshEffect(target.gameObject);
		_meshRendererUpdaterList.Add(pSMeshRendererUpdater);
	}

	public void Show(float hideDelay = 0f)
	{
		IsPlaying = true;
		if (_hideCoroutine != null)
		{
			StopCoroutine(_hideCoroutine);
			_hideCoroutine = null;
		}
		foreach (PSMeshRendererUpdater meshRendererUpdater in _meshRendererUpdaterList)
		{
			meshRendererUpdater.IsActive = true;
		}
		if (!(hideDelay <= 0f))
		{
			_hideCoroutine = StartCoroutine(this.DelayMethod(hideDelay, Hide));
		}
	}

	public void Hide()
	{
		IsPlaying = false;
		if (_hideCoroutine != null)
		{
			StopCoroutine(_hideCoroutine);
			_hideCoroutine = null;
		}
		foreach (PSMeshRendererUpdater meshRendererUpdater in _meshRendererUpdaterList)
		{
			meshRendererUpdater.IsActive = false;
		}
	}
}
public class PosProcesFader : MonoBehaviour
{
	[SerializeField]
	[Required]
	private PostProcessVolume _startVolume;

	[SerializeField]
	[Required]
	private PostProcessVolume _endVolume;

	[SerializeField]
	private float _fadeTime = 2f;

	public void Fade(float fadeTime)
	{
		_fadeTime = fadeTime;
		Fade();
	}

	[Button("フェード！")]
	private void Fade()
	{
		Debug.Log("フェード開始！");
		DOTween.To(() => 0f, delegate(float time)
		{
			_startVolume.weight = 1f - time / _fadeTime;
			_endVolume.weight = time / _fadeTime;
		}, _fadeTime, _fadeTime).OnComplete(delegate
		{
			Debug.Log("フェード終了！");
		});
	}
}
public class ReuseProductionGenerator : ReuseMonoBehaviourGenerator<ReuseProductionGenerator>
{
	private readonly Dictionary<ReuseParticleType, ReuseMonoBehaviourObjetPool> _particlePoolDict = new Dictionary<ReuseParticleType, ReuseMonoBehaviourObjetPool>();

	private ReuseMonoBehaviourObjetPool _scoreAcquisitionProductionPool;

	private ReuseMonoBehaviourObjetPool _scoreAcquisitionProductionCharacterPool;

	private ReuseMonoBehaviourObjetPool _flyingComboEffectPool;

	private void Start()
	{
		_scoreAcquisitionProductionPool = CreatePool(base.transform, "ScoreAcquisitionProductionPool", "Prefab/Production/Reuse/ScoreProduction/NormalScoreAcquisitionProduction");
		_scoreAcquisitionProductionCharacterPool = CreatePool(base.transform, "ScoreAcquisitionProductionCharacterPool", "Prefab/Production/Reuse/ScoreProduction/ScoreAcquisitionProductionCharacter");
		_flyingComboEffectPool = CreatePool(base.transform, "FlyingComboEffectPool", "Prefab/Production/Reuse/FlyingComboEffect");
	}

	public ReuseParticlePlayer PlayParticle(ReuseParticleType particleType, Vector3 position, float pitch = 1f, bool is3DSound = true, Action<ReuseParticlePlayer> callback = null)
	{
		if (!_particlePoolDict.ContainsKey(particleType))
		{
			_particlePoolDict[particleType] = CreatePool(particleType.ToString() + "Pool", "Prefab/Production/Reuse/Particle/" + particleType);
		}
		ReuseParticlePlayer reuseParticlePlayer = _particlePoolDict[particleType].Get<ReuseParticlePlayer>();
		reuseParticlePlayer.transform.position = position;
		reuseParticlePlayer.Play(pitch, is3DSound, callback);
		return reuseParticlePlayer;
	}

	public void PlayScoreAcquisitionProduction(int score, BonusType bonusType, int comboBonus, int distanceBonus, Vector3 position)
	{
		_scoreAcquisitionProductionPool.Get<NormalScoreAcquisitionProduction>().Play(score, bonusType, comboBonus, distanceBonus, position);
	}

	public ScoreAcquisitionProductionCharacter GetScoreAcquisitionProductionCharacter()
	{
		return _scoreAcquisitionProductionCharacterPool.Get<ScoreAcquisitionProductionCharacter>();
	}

	public void PlayFlyingComboEffect(ComboText comboText, float scaleRate)
	{
		_flyingComboEffectPool.Get<FlyingComboEffect>().Play(comboText, scaleRate);
	}
}
public static class BGMUtility
{
	public static readonly int BGM_NUM = 6;

	public static string GetPlayingBGMPath(int bgmNo)
	{
		return System.IO.Path.Combine("Audio/BGM", $"BGM_Playing{bgmNo}");
	}

	public static bool CanUse(int BGMNo)
	{
		if (BGMNo >= 1 && BGMNo <= 3)
		{
			return CharacterUtility.CanUse(CharacterType.Girl);
		}
		if (BGMNo >= 4 && BGMNo <= 6)
		{
			return CharacterUtility.CanUse(CharacterType.Boy);
		}
		return false;
	}
}
public class CallbackSet
{
	private Action _lastCallback;

	private int _callbackNum;

	public int CallbackNum => _callbackNum;

	public CallbackSet(Action lastCallback)
	{
		_lastCallback = lastCallback;
	}

	public Action GetCallback()
	{
		_callbackNum++;
		return Callback;
	}

	public TweenCallback GetTweenCallback()
	{
		_callbackNum++;
		return Callback;
	}

	private void Callback()
	{
		_callbackNum--;
		if (_callbackNum <= 0)
		{
			_lastCallback();
		}
	}
}
public static class CharacterUtility
{
	private static GirlHoldingObjectHolder _objectHolder;

	public static bool CanUse(CharacterType characterType)
	{
		return true;
	}

	public static void CheckHoldingObject(GirlHoldingObjectHolder objectHolder, LickableObjectType lickableObjectType)
	{
		_objectHolder = objectHolder;
		CheckHoldingObject(lickableObjectType);
	}

	private static void CheckHoldingObject(LickableObjectType lickableObjectType)
	{
		CharacterType currentCharacterType = SingletonMonoBehaviour<GirlManager>.Instance.CurrentCharacterType;
		if (currentCharacterType == CharacterType.Boy)
		{
			AdjustHoldingObject(0f, 0f, 0f, 0f, 0f, 0f);
		}
		switch (lickableObjectType)
		{
		case LickableObjectType.Book1:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.00081f, 0.000813f, -0.000116f, 16.875f, 186.47f, 344.161f);
			}
			else
			{
				AdjustHoldingObject(0.13f, 0.08f, -0.089f, -48f, -33.7f, -95.9f);
			}
			break;
		case LickableObjectType.Pen:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.00017f, 0.00067f, -3E-05f, 83.93508f, 0.0003967483f, 0.0003849595f);
			}
			else
			{
				AdjustHoldingObject(0.0956f, 0.04f, -0.0476f, 58.1f, -12.45f, 11.39f);
			}
			break;
		case LickableObjectType.Eraser:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.00019f, 0.00068f, 9E-05f, 83.93512f, 0.0004040359f, 271.9294f);
			}
			else
			{
				AdjustHoldingObject(0.057f, 0.022f, -0.008f, 0f, 0f, 0f);
			}
			break;
		case LickableObjectType.Dictionary1:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.00059f, 0.00096f, 7E-05f, 39.3997f, 268.873f, 274.9491f);
			}
			else
			{
				AdjustHoldingObject(0.107f, 0.091f, -0.018f, -314.266f, -89.73f, -252.462f);
			}
			break;
		case LickableObjectType.Glasses:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0f, 0.00113126f, 0.0007286004f, 6.70466f, 1.278867E-05f, -6.807385E-07f);
				AdjustHoldingObjectScale(110f);
			}
			else
			{
				AdjustHoldingObject(0f, 0.04f, 0.0659f, 7.559f, 0f, 0f);
			}
			break;
		case LickableObjectType.HeadPhone:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0f, 0.001204803f, 7.160219E-05f, 348.8756f, 1.501575E-05f, -4.154897E-08f);
				AdjustHoldingObjectScale(1f);
			}
			else
			{
				AdjustHoldingObject(0f, 0.078f, 0f, -10.27f, 0f, 0f);
			}
			break;
		case LickableObjectType.Uchiwa:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(9E-05f, 0.00083f, 0.00061f, 279.2962f, 216.5211f, 315.3518f);
			}
			else
			{
				AdjustHoldingObject(0.0883f, 0.0103f, -0.0687f, -11.852f, 78.736f, -94.441f);
			}
			break;
		case LickableObjectType.ChocoBanana:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-0.000128f, -0.000849f, 0.001687f, 27.90564f, 208.7541f, 18.9929f);
			}
			else
			{
				AdjustHoldingObject(0.01f, -0.179f, 0.191f, 34.14f, -142.17f, 20.58f);
			}
			break;
		case LickableObjectType.Lucky:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-4.5E-05f, 0.000435f, 0.001197f, 65.37896f, 243.8268f, 64.02074f);
			}
			else
			{
				AdjustHoldingObject(-0.0021f, -0.0321f, 0.1225f, 66.49f, -123.465f, 56.355f);
			}
			break;
		case LickableObjectType.Usachan:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-1E-05f, 0.0032f, -0.0005f, 3.846689E-06f, 0.8262236f, -6.39292E-07f);
			}
			else
			{
				AdjustHoldingObject(0.012f, 0.267f, 0.011f, 0f, 0f, 0f);
			}
			break;
		case LickableObjectType.BabyBottle:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-4E-05f, 0.00038f, 0.00179f, 61.08282f, 252.3185f, 73.42723f);
			}
			else
			{
				AdjustHoldingObject(0.0005f, -0.0756f, 0.1671f, 50.805f, -131.933f, 40.058f);
			}
			break;
		case LickableObjectType.TapiocaTea:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(6E-05f, 0.00022f, 0.00222f, 61.08281f, 252.3185f, 78.36407f);
			}
			else
			{
				AdjustHoldingObject(-0.0248f, -0.1968f, 0.1099f, 11.501f, -159.826f, 24.522f);
			}
			break;
		case LickableObjectType.Ice:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-3.6E-05f, 0.000428f, 0.001344f, 1.536793E-05f, 266.1894f, 83.87534f);
			}
			else
			{
				AdjustHoldingObject(0f, -0.064f, 0.118f, -3.165f, -85.464f, 56.694f);
			}
			break;
		case LickableObjectType.Candy:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(8.3E-05f, 0.000654f, -8.1E-05f, 65.37894f, 243.8267f, 66.61803f);
			}
			else
			{
				AdjustHoldingObject(0.0023f, 0.0046f, -0.037f, 67.27f, -125.104f, 53.32f);
			}
			break;
		case LickableObjectType.Recorder:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.0002f, 0.000685f, -0.00037f, 83.93508f, 0.0003967483f, 0.0003849595f);
			}
			else
			{
				AdjustHoldingObject(0.058f, 0.028f, 0.042f, 0f, 80f, -94f);
			}
			break;
		case LickableObjectType.Lip:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.000207f, 0.000605f, -7E-05f, 72.94594f, 2.290028E-05f, 1.374343E-05f);
			}
			else
			{
				AdjustHoldingObject(0.0636f, 0.0259f, 0.0116f, 0f, 80f, -94f);
			}
			break;
		case LickableObjectType.ToothBrush:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-1.6E-05f, 0.000496f, 0.001047f, 1.195283E-05f, 266.1894f, 83.87534f);
			}
			else
			{
				AdjustHoldingObject(0f, -0.0246f, 0.0944f, -7.541f, -90.351f, 77.118f);
			}
			break;
		case LickableObjectType.Taionkei:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-0.000944f, 0.001422f, 0.001479f, 6.353452f, 355.3526f, 260.5923f);
			}
			else
			{
				AdjustHoldingObject(-0.1132f, 0.0946f, 0.1347f, 1.8f, -1.893f, -96.734f);
			}
			break;
		case LickableObjectType.Toast:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-4.8E-05f, 0.00047f, 0.001297f, 0.286485f, 268.8602f, 83.88202f);
			}
			else
			{
				AdjustHoldingObject(0.0107f, -0.0324f, 0.132f, 3.652f, 96.864f, -73.268f);
			}
			break;
		case LickableObjectType.Mask:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0f, -0.001409442f, -0.001422919f, 308.8666f, -5.489081E-05f, 7.640686E-05f);
				AdjustHoldingObjectScale(1.3f);
			}
			else
			{
				AdjustHoldingObject(0f, -0.017f, 0.03f, -102f, 0f, 0f);
			}
			break;
		case LickableObjectType.Bra:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(6.667043E-05f, 0.001648033f, 0.0001733406f, 12.64384f, 355.9132f, 356.9376f);
			}
			else
			{
				AdjustHoldingObject(0.006f, 0.077f, -0.002f, 13.496f, -4.101f, -3.125f);
			}
			break;
		case LickableObjectType.Burma:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(1.833162E-05f, 0.002562903f, -0.0001220034f, 357.7472f, 268.0282f, 177.7256f);
			}
			else
			{
				AdjustHoldingObject(0.001f, 0.206f, -0.031f, 182.282f, 88.062f, -3.1289f);
			}
			break;
		case LickableObjectType.Panty:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-1.667323E-05f, 0.002558368f, -0.0002586125f, 359.1457f, 1.39729E-05f, 180f);
			}
			else
			{
				AdjustHoldingObject(-0.002f, 0.202f, -0.051f, 0f, 0f, 180f);
			}
			break;
		case LickableObjectType.Shirt:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-0.00021f, 0.00334f, 0.00039f, 16.38321f, 68.43309f, 10.30739f);
			}
			else
			{
				AdjustHoldingObject(0.262f, -0.063f, 0.022f, -68.77f, 8.86f, -87.586f);
			}
			break;
		case LickableObjectType.SwimSuitGirl:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.000292f, 0.002498f, -6E-06f, 81.8292f, 312.7787f, 233.1829f);
			}
			else
			{
				AdjustHoldingObject(0.007f, 0.007f, 0.185f, 0f, -28.925f, 0f);
			}
			break;
		case LickableObjectType.FlutterBoard:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.000564f, 0.002307f, 0.000145f, 76.47073f, 264.5121f, 185.1422f);
			}
			else
			{
				AdjustHoldingObject(0.248f, 0.128f, -0.123f, 0f, -28.925f, 44.379f);
			}
			break;
		case LickableObjectType.SwimCap:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.000268f, 0.001069f, 0.000117f, 76.47074f, 264.5121f, 185.1422f);
			}
			else
			{
				AdjustHoldingObject(0.1086f, 0.0664f, -0.017f, -59.466f, 55.037f, -406.221f);
			}
			break;
		case LickableObjectType.Loafer:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(0.000291f, 0.000999f, 0.000122f, 69.79813f, 262.7791f, 183.481f);
			}
			else
			{
				AdjustHoldingObject(0.1511f, 0.0648f, -0.0042f, -17.753f, -17.383f, -165.977f);
			}
			break;
		case LickableObjectType.Compass:
			if (currentCharacterType == CharacterType.Boy)
			{
				AdjustHoldingObject(-3E-05f, 0.00112f, 0.00225f, 16.98647f, 80.95287f, 81.50214f);
			}
			else
			{
				AdjustHoldingObject(0.073f, 0.029f, 0.001f, -261.547f, -158.575f, 207.481f);
			}
			break;
		default:
			AdjustHoldingObject(0f, 0f, 0f, 0f, 0f, 0f);
			Debug.LogWarning($"{_objectHolder.HoldingObject.ObjectType}を持つ場所が設定されていません");
			break;
		}
	}

	private static void AdjustHoldingObject(float posX, float posY, float posZ, float rotX, float rotY, float rotZ)
	{
		if (!(_objectHolder.HoldingObject == null))
		{
			Transform transform = _objectHolder.HoldingObject.transform;
			transform.SetParent(GetHoldingObjectParent(_objectHolder));
			transform.localPosition = new Vector3(posX, posY, posZ);
			transform.localRotation = Quaternion.Euler(rotX, rotY, rotZ);
		}
	}

	private static void AdjustHoldingObjectScale(float scale)
	{
		if (!(_objectHolder.HoldingObject == null))
		{
			_objectHolder.HoldingObject.transform.GetChild(0).localScale = Vector3.one * scale;
		}
	}

	public static Transform GetHoldingObjectParent(GirlHoldingObjectHolder objectHolder)
	{
		_objectHolder = objectHolder;
		LickableObjectSet holdingObject = _objectHolder.HoldingObject;
		if (holdingObject == null)
		{
			return _objectHolder.RightHand;
		}
		if (holdingObject.ObjectType == LickableObjectType.Glasses || holdingObject.ObjectType == LickableObjectType.Mask || holdingObject.ObjectType == LickableObjectType.HeadPhone || holdingObject.ObjectType == LickableObjectType.ChocoBanana || holdingObject.ObjectType == LickableObjectType.Lucky || holdingObject.ObjectType == LickableObjectType.BabyBottle || holdingObject.ObjectType == LickableObjectType.TapiocaTea || holdingObject.ObjectType == LickableObjectType.ToothBrush || holdingObject.ObjectType == LickableObjectType.Taionkei || holdingObject.ObjectType == LickableObjectType.Toast || holdingObject.ObjectType == LickableObjectType.Ice || holdingObject.ObjectType == LickableObjectType.Candy || holdingObject.ObjectType == LickableObjectType.Usachan || holdingObject.ObjectType == LickableObjectType.Bra || holdingObject.ObjectType == LickableObjectType.Burma || holdingObject.ObjectType == LickableObjectType.Panty)
		{
			return _objectHolder.Head;
		}
		return _objectHolder.RightHand;
	}
}
public class LineDeployer : MonoBehaviour
{
	[SerializeField]
	private float _distance;

	private void Awake()
	{
		Deploy();
	}

	private void OnValidate()
	{
		Deploy();
	}

	[ContextMenu("Deploy")]
	private void Deploy()
	{
		List<Transform> list = new List<Transform>();
		foreach (Transform item in base.transform)
		{
			list.Add(item.transform);
		}
		for (int i = 0; i < list.Count; i++)
		{
			list[i].localPosition = new Vector3(_distance * (float)i, 0f, 0f);
		}
	}
}
public static class LoopPlayer
{
	public static void PlayBoolAction(Func<bool> action, string errorMessage, int loopLimit = 100)
	{
		int num = 0;
		while (action())
		{
			num++;
			if (num >= loopLimit)
			{
				Debug.LogError(errorMessage);
				break;
			}
		}
	}
}
public class PerlinNoiseGenerator
{
	private float _seed;

	private float _min;

	private float _max = 1f;

	private float _rateOfChange = 1f;

	public float RateOfChange
	{
		set
		{
			_rateOfChange = value;
		}
	}

	public PerlinNoiseGenerator(float min = 0f, float max = 1f, float rateOfChange = 1f)
	{
		_seed = UnityEngine.Random.Range(0f, 100f);
		_min = min;
		_max = max;
		_rateOfChange = rateOfChange;
	}

	public void SetSeed(float seed)
	{
		_seed = seed;
	}

	public float GetNoiseARateOfChange(float rateOfChange)
	{
		return GetNoiseARateOfChange(Time.time, rateOfChange);
	}

	public float GetNoiseARateOfChange(float x, float rateOfChange)
	{
		return GetNoise(x, _seed, rateOfChange);
	}

	public float GetNoise()
	{
		return GetNoise(Time.time);
	}

	public float GetNoise(float x)
	{
		return GetNoise(x, _seed);
	}

	public float GetNoise(float x, float y)
	{
		return GetNoise(x, y, _rateOfChange);
	}

	public float GetNoise(float x, float y, float rateOfChange)
	{
		return _min + Mathf.PerlinNoise(x * rateOfChange, y * rateOfChange) * (0f - _min + _max);
	}
}
public static class ProbabilityCalculator
{
	public static bool DetectFromPercent(int percent)
	{
		return DetectFromPercent((float)percent);
	}

	public static bool DetectFromPercent(float percent)
	{
		int num = 0;
		if (percent.ToString().IndexOf(".") > 0)
		{
			num = percent.ToString().Divide(".")[1].Length;
		}
		int num2 = (int)Mathf.Pow(10f, num);
		int max = 100 * num2;
		int num3 = (int)((float)num2 * percent);
		return UnityEngine.Random.Range(0, max) < num3;
	}

	public static T DetermineFromArray<T>(params T[] targetArray)
	{
		return targetArray[UnityEngine.Random.Range(0, targetArray.Length)];
	}

	public static T DetermineFromList<T>(List<T> targetList)
	{
		return DetermineFromArray(targetList.ToArray());
	}

	public static T DetermineFromDict<T>(Dictionary<T, float> targetDict)
	{
		float num = 0f;
		foreach (float value in targetDict.Values)
		{
			num += value;
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (KeyValuePair<T, float> item in targetDict)
		{
			num2 -= item.Value;
			if (num2 <= 0f)
			{
				return item.Key;
			}
		}
		Debug.LogWarning("抽選ができませんでした");
		return new List<T>(targetDict.Keys)[0];
	}

	public static T DetermineFromDict<T>(Dictionary<T, int> targetDict)
	{
		Dictionary<T, float> dictionary = new Dictionary<T, float>();
		foreach (KeyValuePair<T, int> item in targetDict)
		{
			dictionary.Add(item.Key, item.Value);
		}
		return DetermineFromDict(dictionary);
	}
}
public class SAMeshAdjuster : MonoBehaviour
{
	[SerializeField]
	private PhysicMaterial _physicMaterial;

	[SerializeField]
	private float _sizeMin = 0.04f;

	[Button("調整")]
	private void Adjust()
	{
		List<Transform> list = base.gameObject.GetComponentsInChildren<Transform>().ToList();
		list.Remove(base.transform);
		int count = list.Count;
		Transform parent = base.transform.CreateChild("ColliderParent");
		foreach (Transform item in list)
		{
			item.SetParent(parent);
		}
		foreach (Transform item2 in list)
		{
			Collider component = item2.GetComponent<Collider>();
			if (component == null || !IsValidSize(component))
			{
				UnityEngine.Object.DestroyImmediate(item2.gameObject);
				continue;
			}
			component.material = _physicMaterial;
			UnityEngine.Object.DestroyImmediate(item2.GetComponent<SAMeshCollider>());
			UnityEngine.Object.DestroyImmediate(item2.GetComponent<Rigidbody>());
		}
		Debug.Log($"{count} →{base.gameObject.GetComponentsInChildren<Transform>().Length - 1}");
	}

	private bool IsValidSize(Collider collider)
	{
		BoxCollider boxCollider = collider as BoxCollider;
		if (boxCollider != null)
		{
			return boxCollider.size.magnitude >= _sizeMin;
		}
		CapsuleCollider capsuleCollider = collider as CapsuleCollider;
		if (capsuleCollider != null)
		{
			return capsuleCollider.radius * capsuleCollider.height >= _sizeMin;
		}
		Debug.LogWarning($"{collider}の判定が実装されていません");
		return true;
	}
}
public static class ValueBetweenChecker
{
	public static bool IsBetween(int target, int a, int b)
	{
		if (a > b)
		{
			if (target <= a)
			{
				return target >= b;
			}
			return false;
		}
		if (target <= b)
		{
			return target >= a;
		}
		return false;
	}

	public static bool IsBetween(float target, float a, float b)
	{
		if (a > b)
		{
			if (target <= a)
			{
				return target >= b;
			}
			return false;
		}
		if (target <= b)
		{
			return target >= a;
		}
		return false;
	}

	public static bool IsBetween(ref Vector2 target, ref Vector2 a, ref Vector2 b)
	{
		if (IsBetween(target.x, a.x, b.x))
		{
			return IsBetween(target.y, a.y, b.y);
		}
		return false;
	}

	public static bool IsBetween(ref Vector3 target, ref Vector3 a, ref Vector3 b)
	{
		if (IsBetween(target.x, a.x, b.x) && IsBetween(target.y, a.y, b.y))
		{
			return IsBetween(target.z, a.z, b.z);
		}
		return false;
	}

	public static bool IsBetween(ref Vector2Int target, ref Vector2Int a, ref Vector2Int b)
	{
		if (IsBetween(target.x, a.x, b.x))
		{
			return IsBetween(target.y, a.y, b.y);
		}
		return false;
	}

	public static bool IsBetween(ref Vector3Int target, ref Vector3Int a, ref Vector3Int b)
	{
		if (IsBetween(target.x, a.x, b.x) && IsBetween(target.y, a.y, b.y))
		{
			return IsBetween(target.z, a.z, b.z);
		}
		return false;
	}
}
public enum InputKeyType
{
	Trigger,
	Side,
	Menu,
	TriggerRight,
	SideRight,
	MenuRight,
	TriggerLeft,
	SideLeft,
	MenuLeft,
	SquatUpRight,
	SquatDownRight,
	SquatUpLeft,
	SquatDownLeft,
	RightRotationRight,
	LeftRotationRight,
	RightRotationLeft,
	LeftRotationLeft
}
public enum InputStateType
{
	Down,
	Up,
	Pressing,
	None
}
public abstract class InputChecker
{
	public event Action<InputKeyType, InputStateType> InputedKey = delegate
	{
	};

	public event Action ResetedRoration = delegate
	{
	};

	public abstract void CheckInput();

	public abstract void UpdatePositionVector2(ref Vector2 vector2);

	public abstract void UpdateRotationVector2(ref Vector2 vector2);

	protected void UpdateVector2IfNeeded(ref Vector2 vector2, float x, float y)
	{
		if (Mathf.Abs(x) > 0f || Mathf.Abs(y) > 0f)
		{
			vector2.x = x;
			vector2.y = y;
		}
	}

	protected void OnInputKey(InputKeyType keyType, InputStateType stateType)
	{
		this.InputedKey(keyType, stateType);
	}

	protected void OnResetRoration()
	{
		this.ResetedRoration();
	}

	public abstract void Vibrate(float duration = 0.1f, float frequency = 1E-05f);
}
public class InputCheckerForKeyboard : InputChecker
{
	private static readonly string HORIZONAL_AXIS_NAME = "Horizontal";

	private static readonly string VERTICAL_AXIS_NAME = "Vertical";

	private static readonly string MOUSE_X_AXIS_NAME = "Mouse X";

	private static readonly string MOUSE_Y_AXIS_NAME = "Mouse Y";

	public override void CheckInput()
	{
		CheckInput(KeyCode.Space, InputKeyType.Trigger);
		CheckInput(KeyCode.Return, InputKeyType.Side);
		CheckInput(KeyCode.LeftShift, InputKeyType.Menu);
		CheckInput(KeyCode.RightShift, InputKeyType.Menu);
		CheckInput(KeyCode.U, InputKeyType.SquatUpRight);
		CheckInput(KeyCode.J, InputKeyType.SquatDownRight);
		CheckInput(KeyCode.E, InputKeyType.RightRotationRight);
		CheckInput(KeyCode.Q, InputKeyType.LeftRotationRight);
		if (Input.GetKeyDown(KeyCode.R))
		{
			OnResetRoration();
		}
	}

	private void CheckInput(KeyCode keyCode, InputKeyType keyType)
	{
		if (Input.GetKeyDown(keyCode))
		{
			OnInputKey(keyType, InputStateType.Down);
		}
		else if (Input.GetKey(keyCode))
		{
			OnInputKey(keyType, InputStateType.Pressing);
		}
		else if (Input.GetKeyUp(keyCode))
		{
			OnInputKey(keyType, InputStateType.Up);
		}
	}

	public override void UpdatePositionVector2(ref Vector2 vector2)
	{
		UpdateVector2IfNeeded(ref vector2, Input.GetAxisRaw(HORIZONAL_AXIS_NAME), Input.GetAxisRaw(VERTICAL_AXIS_NAME));
	}

	public override void UpdateRotationVector2(ref Vector2 vector2)
	{
		UpdateVector2IfNeeded(ref vector2, Input.GetAxisRaw(MOUSE_X_AXIS_NAME), Input.GetAxisRaw(MOUSE_Y_AXIS_NAME));
	}

	public override void Vibrate(float duration = 0.1f, float frequency = 1E-05f)
	{
	}
}
public class InputCheckerForOVR : InputChecker
{
	private readonly bool _isLeft;

	private Coroutine _vibrateCoroutine;

	public InputCheckerForOVR(bool isLeft)
	{
		_isLeft = isLeft;
	}

	public override void CheckInput()
	{
		CheckInput(OVRInput.Button.PrimaryIndexTrigger, _isLeft ? InputKeyType.TriggerLeft : InputKeyType.TriggerRight);
		CheckInput(OVRInput.Button.PrimaryHandTrigger, _isLeft ? InputKeyType.SideLeft : InputKeyType.SideRight);
		if (_isLeft)
		{
			CheckInput(OVRInput.Button.Start, InputKeyType.MenuLeft);
		}
		CheckInput(OVRInput.Button.Two, _isLeft ? InputKeyType.RightRotationLeft : InputKeyType.SquatUpRight);
		CheckInput(OVRInput.Button.One, _isLeft ? InputKeyType.LeftRotationLeft : InputKeyType.SquatDownRight);
	}

	private void CheckInput(OVRInput.Button button, InputKeyType keyType)
	{
		if (OVRInput.GetDown(button, _isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch))
		{
			OnInputKey(keyType, InputStateType.Down);
		}
		else if (OVRInput.Get(button, _isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch))
		{
			OnInputKey(keyType, InputStateType.Pressing);
		}
		else if (OVRInput.GetUp(button, _isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch))
		{
			OnInputKey(keyType, InputStateType.Up);
		}
	}

	public override void UpdatePositionVector2(ref Vector2 vector2)
	{
		Vector2 vector3 = OVRInput.Get(_isLeft ? OVRInput.RawAxis2D.LThumbstick : OVRInput.RawAxis2D.RThumbstick);
		if (vector3.magnitude > 0f)
		{
			vector2 = vector3;
		}
	}

	public override void UpdateRotationVector2(ref Vector2 vector2)
	{
	}

	public override void Vibrate(float duration = 0.1f, float frequency = 1E-05f)
	{
		VRHandController instance = SingletonMonoBehaviour<VRHandController>.Instance;
		if (_vibrateCoroutine != null)
		{
			instance.StopCoroutine(_vibrateCoroutine);
		}
		OVRInput.SetControllerVibration(frequency, 1f, _isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		_vibrateCoroutine = instance.StartCoroutine(instance.DelayMethod(duration, delegate
		{
			OVRInput.SetControllerVibration(0f, 0f, _isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}));
	}
}
public class InputCheckerForSteamVR : InputChecker
{
	private readonly SteamVR_Action_Boolean _triggerAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("GrabPinch");

	private readonly SteamVR_Action_Boolean _sideAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("GrabGrip");

	private readonly SteamVR_Action_Boolean _menuAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("Menu");

	private readonly SteamVR_Action_Boolean _padButtonAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("PadButton");

	private readonly SteamVR_Action_Boolean _rightAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("RightButton");

	private readonly SteamVR_Action_Boolean _leftAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("LeftButton");

	private readonly SteamVR_Action_Boolean _upAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("UpButton");

	private readonly SteamVR_Action_Boolean _downAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("DownButton");

	private readonly SteamVR_Action_Vector2 _vector2Action = SteamVR_Input.GetAction<SteamVR_Action_Vector2>("JoyStick");

	private InputKeyType _triggerKeyType;

	private InputKeyType _sideKeyType;

	private InputKeyType _menuKeyType;

	private InputKeyType _rotationRightKeyType;

	private InputKeyType _rotationLeftKeyType;

	private InputKeyType _squatUpKeyType;

	private InputKeyType _squatDownKeyType;

	private SteamVR_Action_Vibration _hapicAction = SteamVR_Input.GetAction<SteamVR_Action_Vibration>("Haptic");

	public SteamVR_Input_Sources ControllerType { get; private set; }

	public InputCheckerForSteamVR(SteamVR_Input_Sources controllerType)
	{
		ControllerType = controllerType;
		if (ControllerType == SteamVR_Input_Sources.RightHand)
		{
			_triggerKeyType = InputKeyType.TriggerRight;
			_sideKeyType = InputKeyType.SideRight;
			_menuKeyType = InputKeyType.MenuRight;
			_rotationRightKeyType = InputKeyType.RightRotationRight;
			_rotationLeftKeyType = InputKeyType.LeftRotationRight;
			_squatUpKeyType = InputKeyType.SquatUpRight;
			_squatDownKeyType = InputKeyType.SquatDownRight;
		}
		else
		{
			_triggerKeyType = InputKeyType.TriggerLeft;
			_sideKeyType = InputKeyType.SideLeft;
			_menuKeyType = InputKeyType.MenuLeft;
			_rotationRightKeyType = InputKeyType.RightRotationLeft;
			_rotationLeftKeyType = InputKeyType.LeftRotationLeft;
			_squatUpKeyType = InputKeyType.SquatUpLeft;
			_squatDownKeyType = InputKeyType.SquatDownLeft;
		}
	}

	public override void CheckInput()
	{
		CheckInput(_triggerAction, _triggerKeyType);
		CheckInput(_sideAction, _sideKeyType);
		CheckInput(_menuAction, _menuKeyType);
		if (!_padButtonAction.GetStateDown(ControllerType) && !_padButtonAction.GetState(ControllerType))
		{
			CheckInput(_rightAction, _rotationRightKeyType);
			CheckInput(_leftAction, _rotationLeftKeyType);
			CheckInput(_upAction, _squatUpKeyType);
			CheckInput(_downAction, _squatDownKeyType);
		}
	}

	private void CheckInput(SteamVR_Action_Boolean action, InputKeyType keyType)
	{
		if (action.GetStateDown(ControllerType))
		{
			OnInputKey(keyType, InputStateType.Down);
		}
		else if (action.GetState(ControllerType))
		{
			OnInputKey(keyType, InputStateType.Pressing);
		}
		else if (action.GetStateUp(ControllerType))
		{
			OnInputKey(keyType, InputStateType.Up);
		}
	}

	public override void UpdatePositionVector2(ref Vector2 vector2)
	{
		Vector2 axis = _vector2Action.GetAxis(ControllerType);
		if (axis.magnitude > 0f)
		{
			vector2 = axis;
		}
	}

	public override void UpdateRotationVector2(ref Vector2 vector2)
	{
	}

	public override void Vibrate(float duration = 0.1f, float frequency = 1E-05f)
	{
		_hapicAction.Execute(0f, duration, 1E-05f, 1f, ControllerType);
	}
}
public class InputEventMediator
{
	private Action _updatedAction;

	private Action _resetedRorationAction;

	private Action<InputKeyType, InputStateType> _inputedKeyAction;

	private Action<Vector2> _updatedPositionVector2Action;

	private Action<Vector2> _updatedRotationVector2Action;

	public static InputEventMediator Mediate(Action updatedAction = null, Action<InputKeyType, InputStateType> inputedKeyAction = null, Action resetedRorationAction = null, Action<Vector2> updatedPositionVector2Action = null, Action<Vector2> updatedRotationVector2Action = null)
	{
		return new InputEventMediator(updatedAction, inputedKeyAction, resetedRorationAction, updatedPositionVector2Action, updatedRotationVector2Action);
	}

	public InputEventMediator(Action updatedAction = null, Action<InputKeyType, InputStateType> inputedKeyAction = null, Action resetedRorationAction = null, Action<Vector2> updatedPositionVector2Action = null, Action<Vector2> updatedRotationVector2Action = null)
	{
		InputHandler instance = SingletonMonoBehaviour<InputHandler>.Instance;
		if (updatedAction != null)
		{
			_updatedAction = updatedAction;
			instance.Updated += _updatedAction;
		}
		if (inputedKeyAction != null)
		{
			_inputedKeyAction = inputedKeyAction;
			instance.InputedKey += _inputedKeyAction;
		}
		if (resetedRorationAction != null)
		{
			_resetedRorationAction = resetedRorationAction;
			instance.ResetedRoration += _resetedRorationAction;
		}
		if (updatedPositionVector2Action != null)
		{
			_updatedPositionVector2Action = updatedPositionVector2Action;
			instance.UpdatedPositionVector2 += _updatedPositionVector2Action;
		}
		if (updatedRotationVector2Action != null)
		{
			_updatedRotationVector2Action = updatedRotationVector2Action;
			instance.UpdatedRotationVector2 += _updatedRotationVector2Action;
		}
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene += DiscardEvent;
	}

	private void DiscardEvent()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene -= DiscardEvent;
		InputHandler instance = SingletonMonoBehaviour<InputHandler>.Instance;
		if (_updatedAction != null)
		{
			instance.Updated -= _updatedAction;
			_updatedAction = null;
		}
		if (_inputedKeyAction != null)
		{
			instance.InputedKey -= _inputedKeyAction;
			_inputedKeyAction = null;
		}
		if (_resetedRorationAction != null)
		{
			instance.ResetedRoration -= _resetedRorationAction;
			_resetedRorationAction = null;
		}
		if (_updatedPositionVector2Action != null)
		{
			instance.UpdatedPositionVector2 -= _updatedPositionVector2Action;
			_updatedPositionVector2Action = null;
		}
		if (_updatedRotationVector2Action != null)
		{
			instance.UpdatedRotationVector2 -= _updatedRotationVector2Action;
			_updatedRotationVector2Action = null;
		}
	}
}
public class InputHandler : SingletonMonoBehaviour<InputHandler>
{
	private SceneNavigator _sceneNavigator;

	private readonly List<InputChecker> _inputCheckerList = new List<InputChecker>();

	private InputChecker _leftHandInputChecker;

	private InputChecker _rightHandInputChecker;

	private readonly List<InputKeyType> _inputKeyTypeList = EnumUtility.GetAllInList<InputKeyType>();

	private Dictionary<InputKeyType, InputStateType> _inputDict = new Dictionary<InputKeyType, InputStateType>();

	private bool _isResetRotation;

	private Vector2 _positionVector2Input = Vector2.zero;

	private Vector2 _rotationVector2Input = Vector2.zero;

	public event Action Updated = delegate
	{
	};

	public event Action<InputKeyType, InputStateType> InputedKey = delegate
	{
	};

	public event Action ResetedRoration = delegate
	{
	};

	public event Action<Vector2> UpdatedPositionVector2 = delegate
	{
	};

	public event Action<Vector2> UpdatedRotationVector2 = delegate
	{
	};

	protected override void Init()
	{
		base.Init();
		_sceneNavigator = SingletonMonoBehaviour<SceneNavigator>.Instance;
		_leftHandInputChecker = new InputCheckerForOVR(isLeft: true);
		_rightHandInputChecker = new InputCheckerForOVR(isLeft: false);
		_inputCheckerList.Add(_leftHandInputChecker);
		_inputCheckerList.Add(_rightHandInputChecker);
		foreach (InputChecker inputChecker in _inputCheckerList)
		{
			inputChecker.InputedKey += OnInputKey;
		}
	}

	private void Update()
	{
		if (_sceneNavigator.IsChanging)
		{
			return;
		}
		this.Updated();
		_inputKeyTypeList.ForEach(delegate(InputKeyType inputKeyType)
		{
			_inputDict[inputKeyType] = InputStateType.None;
		});
		_positionVector2Input.x = 0f;
		_positionVector2Input.y = 0f;
		_rotationVector2Input.x = 0f;
		_rotationVector2Input.y = 0f;
		_isResetRotation = false;
		foreach (InputChecker inputChecker in _inputCheckerList)
		{
			inputChecker.CheckInput();
			inputChecker.UpdatePositionVector2(ref _positionVector2Input);
		}
		this.UpdatedPositionVector2(_positionVector2Input);
		this.UpdatedRotationVector2(_rotationVector2Input);
		foreach (KeyValuePair<InputKeyType, InputStateType> item in _inputDict)
		{
			this.InputedKey(item.Key, item.Value);
		}
		if (_isResetRotation)
		{
			this.ResetedRoration();
		}
	}

	private void OnInputKey(InputKeyType inputKeyType, InputStateType stateType)
	{
		_inputDict[inputKeyType] = stateType;
	}

	private void OnResetRoration()
	{
		_isResetRotation = true;
	}

	public void Vibrate(bool isLeft, float duration = 0.1f, float frequency = 1E-05f)
	{
		if (isLeft)
		{
			_leftHandInputChecker.Vibrate(duration, frequency);
		}
		else
		{
			_rightHandInputChecker.Vibrate(duration, frequency);
		}
	}
}
public abstract class AutoLocalizer : MonoBehaviour
{
	protected virtual void Start()
	{
		UserDataAccessorManager.SettingDataAccessor.CurrentLanguageObservable.Subscribe(Localize).AddTo(this);
	}

	protected abstract void Localize(AvailableLanguage availableLanguage);
}
public class AutoSpriteRendererLocalizer : AutoLocalizer
{
	[SerializeField]
	private List<SpriteRenderer> _spriteRendererList = new List<SpriteRenderer>();

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _englishSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _japaneseSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _chineseSimplifiedSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _chineseTraditionalSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _russianSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _spanishSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _brazilianSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _germanSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _frenchSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _polishSprite;

	[SerializeField]
	[BoxGroup("各言語ごとのSprite", true, false, 0)]
	private Sprite _koreanSprite;

	protected override void Localize(AvailableLanguage availableLanguage)
	{
		foreach (SpriteRenderer spriteRenderer in _spriteRendererList)
		{
			UpdateSprite(spriteRenderer, availableLanguage);
		}
	}

	private void UpdateSprite(SpriteRenderer spriteRenderer, AvailableLanguage availableLanguage)
	{
		switch (availableLanguage)
		{
		case AvailableLanguage.English:
			spriteRenderer.sprite = _englishSprite;
			break;
		case AvailableLanguage.Japanese:
			spriteRenderer.sprite = _japaneseSprite;
			break;
		case AvailableLanguage.ChineseSimplified:
			spriteRenderer.sprite = _chineseSimplifiedSprite;
			break;
		case AvailableLanguage.ChineseTraditional:
			spriteRenderer.sprite = _chineseTraditionalSprite;
			break;
		case AvailableLanguage.Russian:
			spriteRenderer.sprite = _russianSprite;
			break;
		case AvailableLanguage.Spanish:
			spriteRenderer.sprite = _spanishSprite;
			break;
		case AvailableLanguage.Brazilian:
			spriteRenderer.sprite = _brazilianSprite;
			break;
		case AvailableLanguage.German:
			spriteRenderer.sprite = _germanSprite;
			break;
		case AvailableLanguage.French:
			spriteRenderer.sprite = _frenchSprite;
			break;
		case AvailableLanguage.Polish:
			spriteRenderer.sprite = _polishSprite;
			break;
		case AvailableLanguage.Korean:
			spriteRenderer.sprite = _koreanSprite;
			break;
		}
		if (spriteRenderer.sprite == null)
		{
			Debug.LogWarning($"{base.gameObject.name}の{availableLanguage}の画像が設定されていません");
			spriteRenderer.sprite = _englishSprite;
		}
	}
}
public class AutoTextLocalizer : AutoLocalizer
{
	[SerializeField]
	[Required]
	protected SuperTextMesh _text;

	[SerializeField]
	private string _textKey = "";

	protected Font _defaultFont { get; private set; }

	protected virtual void Awake()
	{
		_defaultFont = ((_text == null) ? null : _text.font);
	}

	protected override void Localize(AvailableLanguage availableLanguage)
	{
		FontMasterData.Entity.UpdateFont(_text, _defaultFont);
		_text.SetTextAndRebuild(LocalizedUtility.Get(_textKey));
	}
}
public enum AvailableLanguage
{
	English,
	Japanese,
	ChineseSimplified,
	ChineseTraditional,
	Russian,
	Spanish,
	Brazilian,
	German,
	French,
	Polish,
	Korean
}
public class LocalizedTextData : ScriptableObject
{
	[Serializable]
	private class KeyAndTextPair
	{
		[SerializeField]
		private string _key = "";

		[SerializeField]
		private string _text = "";

		public string Key => _key;

		public string Text => _text;

		public KeyAndTextPair(string key, string text)
		{
			_key = key;
			_text = text;
		}
	}

	[SerializeField]
	private List<KeyAndTextPair> _pairList = new List<KeyAndTextPair>();

	public string TextToKey(string targetText)
	{
		for (int i = 0; i < _pairList.Count; i++)
		{
			if (_pairList[i].Text == targetText)
			{
				return _pairList[i].Key;
			}
		}
		Debug.LogWarning(targetText + "のローカライズデータがありません!");
		return "";
	}

	public string Get(string key)
	{
		for (int i = 0; i < _pairList.Count; i++)
		{
			if (_pairList[i].Key == key)
			{
				return _pairList[i].Text;
			}
		}
		Debug.LogWarning(key + "のローカライズデータがありません!");
		return "";
	}

	public bool ExistsKey(string key)
	{
		for (int i = 0; i < _pairList.Count; i++)
		{
			if (_pairList[i].Key == key)
			{
				return true;
			}
		}
		return false;
	}
}
public static class LocalizedUtility
{
	private static LocalizedTextData _currentData;

	public static void Init()
	{
		UserDataAccessorManager.SettingDataAccessor.CurrentLanguageObservable.Subscribe(ReloadData);
	}

	private static void ReloadData()
	{
		ReloadData(UserDataAccessorManager.SettingDataAccessor.CurrentLanguage);
	}

	private static void ReloadData(AvailableLanguage currentLanguage)
	{
		_currentData = Load(currentLanguage);
		if (_currentData == null)
		{
			Debug.LogWarning($"{currentLanguage}のローカライズされたテキストがないので英語にします");
			_currentData = Load(AvailableLanguage.English);
		}
	}

	private static LocalizedTextData Load(AvailableLanguage language)
	{
		return Resources.Load<LocalizedTextData>("Data/LocalizedTextData/" + language);
	}

	public static string TextToKey(string targetText)
	{
		return _currentData.TextToKey(targetText);
	}

	public static string Get(string key)
	{
		return _currentData.Get(key);
	}

	public static bool ExistsKey(string key)
	{
		return _currentData.ExistsKey(key);
	}
}
public class PerlinNoiseAnimeRandomizer : MonoBehaviour
{
	private Vector3 _seed = Vector3.zero;

	[SerializeField]
	[Header("↓全体のゆらぎの倍率(大きくすると全体的に大きく動く)")]
	private float _wholeScale = 10f;

	[SerializeField]
	[Header("↓XYZごとのゆらぎの倍率(大きくすると全体的に大きく動く)")]
	private Vector3 _xyzScale = Vector3.one;

	[SerializeField]
	[Header("↓ゆらぎの速さ(大きくすると速く動く)")]
	private float _frequencyRate = 1f;

	private void Awake()
	{
		_seed = new Vector3(UnityEngine.Random.Range(0f, 100f), UnityEngine.Random.Range(0f, 100f), UnityEngine.Random.Range(0f, 100f));
	}

	public void SetStatus(float wholeScale, Vector3 xyzScale, float frequencyRate)
	{
		_wholeScale = wholeScale;
		_xyzScale = xyzScale;
		_frequencyRate = frequencyRate;
	}

	private void LateUpdate()
	{
		Vector3 vector = CreateVector3Noise(0.8f, _frequencyRate * 0.4f);
		Vector3 vector2 = CreateVector3Noise(0.1f, _frequencyRate);
		base.transform.localRotation = base.transform.localRotation * Quaternion.Euler((vector + vector2) * _wholeScale);
	}

	private Vector3 CreateVector3Noise(float ratio, float frequencyRate)
	{
		float x = Time.time * frequencyRate;
		return new Vector3((Mathf.PerlinNoise(x, _seed.x) - 0.5f) * ratio * _xyzScale.x, (Mathf.PerlinNoise(x, _seed.y) - 0.5f) * ratio * _xyzScale.y, (Mathf.PerlinNoise(x, _seed.z) - 0.5f) * ratio * _xyzScale.z);
	}
}
public class MyRankingViewer : SingletonMonoBehaviour<MyRankingViewer>
{
	[SerializeField]
	[Required]
	private MyRankingViewerParts _originalParts;

	private List<MyRankingViewerParts> _partsList = new List<MyRankingViewerParts>();

	[SerializeField]
	private Vector3 _partsSpan = Vector3.zero;

	protected override void Init()
	{
		base.Init();
		_partsList.Add(_originalParts);
		for (int i = 1; i < PlayRecordDataAccessor.HIGH_SCORE_RECORD_NUM; i++)
		{
			MyRankingViewerParts myRankingViewerParts = _originalParts.transform.parent.CreateChildFromOriginal<MyRankingViewerParts>(_originalParts.transform);
			myRankingViewerParts.transform.localRotation = _originalParts.transform.localRotation;
			myRankingViewerParts.transform.localPosition = _originalParts.transform.localPosition + _partsSpan * i;
			_partsList.Add(myRankingViewerParts);
		}
		UpdateUI(-1);
	}

	public void UpdateUI(int currentScore)
	{
		PlayRecordDataAccessor playRecordDataAccessor = UserDataAccessorManager.PlayRecordDataAccessor;
		for (int i = 0; i < _partsList.Count; i++)
		{
			int score = playRecordDataAccessor.GetScore(i);
			_partsList[i].UpdateUI(i, score);
		}
		MyRankingViewerParts myRankingViewerParts = _partsList.FirstOrDefault((MyRankingViewerParts parts) => parts.Score == currentScore);
		if (myRankingViewerParts != null)
		{
			myRankingViewerParts.PlayNewRecordProduction();
		}
	}
}
public class MyRankingViewerParts : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Transform _uiParent;

	[SerializeField]
	private ParticleSystem _newRecordEffect;

	[SerializeField]
	[Required]
	private SuperTextMesh _orderText;

	[SerializeField]
	[Required]
	private SuperTextMesh _scoreText;

	[SerializeField]
	private AnimationCurve _scaleAnimationCurve;

	public int Score { get; private set; }

	public void UpdateUI(int order, int score)
	{
		Score = score;
		_orderText.SetTextAndRebuild($"{order + 1}");
		_scoreText.SetTextAndRebuild($"{Score}");
	}

	[Button("記録更新時の演出を実行")]
	public void PlayNewRecordProduction()
	{
		AddText(_orderText, "<c=Gold>");
		AddText(_scoreText, "<c=Gold>");
		_uiParent.DOScale(new Vector3(1.3f, 1.3f, 1f), 0.3f).SetEase(_scaleAnimationCurve).OnComplete(delegate
		{
			AddText(_orderText, "<w>");
			AddText(_scoreText, "<w>");
		});
		if (_newRecordEffect != null)
		{
			_newRecordEffect.Play();
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_ClackerOne", _newRecordEffect.gameObject, is3DSound: true);
		}
	}

	private void AddText(SuperTextMesh superTextMesh, string text)
	{
		superTextMesh.text = text + superTextMesh.text;
		superTextMesh.Rebuild();
	}
}
public class RankingManager : SingletonMonoBehaviour<RankingManager>
{
}
public class RankingViewer : SingletonMonoBehaviour<RankingViewer>
{
	[SerializeField]
	[Required]
	private SuperTextMesh _titleText;

	[SerializeField]
	[Required]
	private SuperTextMesh _myRankingText;

	[SerializeField]
	[Required]
	private SuperTextMesh _topRankingText;

	[SerializeField]
	[Required]
	private RankingViewerParts _myEntryParts;

	[SerializeField]
	[Required]
	private RankingViewerParts _originalParts;

	private List<RankingViewerParts> _partsList = new List<RankingViewerParts>();

	[SerializeField]
	private RankingType _rankingType;

	[SerializeField]
	private int _partsNum = 10;

	[SerializeField]
	private Vector3 _partsSpan = Vector3.zero;
}
public class RankingViewerParts : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Transform _uiParent;

	[SerializeField]
	[Required]
	private Image _iconImage;

	[SerializeField]
	[Required]
	private Sprite _iconDefault;

	[SerializeField]
	private ParticleSystem _newRecordEffect;

	[SerializeField]
	[Required]
	private SuperTextMesh _orderText;

	[SerializeField]
	[Required]
	private SuperTextMesh _nameText;

	[SerializeField]
	[Required]
	private SuperTextMesh _scoreText;

	[SerializeField]
	private AnimationCurve _scaleAnimationCurve;

	public int Score { get; private set; }

	[Button("記録更新時の演出を実行")]
	public void PlayNewRecordProduction()
	{
		AddText(_orderText, "<c=Gold>");
		AddText(_nameText, "<c=Gold>");
		AddText(_scoreText, "<c=Gold>");
		_uiParent.DOScale(new Vector3(1.3f, 1.3f, 1f), 0.3f).SetEase(_scaleAnimationCurve).OnComplete(delegate
		{
			AddText(_orderText, "<w>");
			AddText(_nameText, "<w>");
			AddText(_scoreText, "<w>");
		});
		if (_newRecordEffect != null)
		{
			_newRecordEffect.Play();
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_ClackerOne", _newRecordEffect.gameObject, is3DSound: true);
		}
	}

	private void AddText(SuperTextMesh superTextMesh, string text)
	{
		superTextMesh.text = text + superTextMesh.text;
		superTextMesh.Rebuild();
	}
}
public class AtStartupInitializer : MonoBehaviour
{
	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void Initialize()
	{
		new GameObject("AtStartupInitializer", typeof(AtStartupInitializer));
	}

	private void Awake()
	{
		Time.timeScale = 1f;
		DOTween.Init();
		DOTween.SetTweensCapacity(200, 200);
		OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSHigh;
		LocalizedUtility.Init();
		UserDataAccessorManager.SettingDataAccessor.InitLanguageIfNeeded();
		UnityEngine.Object.DontDestroyOnLoad(new GameObject("SceneNavigator", typeof(SceneNavigator)));
		UnityEngine.Object.DontDestroyOnLoad(new GameObject("InputHandler", typeof(InputHandler)));
		UnityEngine.Object.DontDestroyOnLoad(new GameObject("AchievementManager", typeof(AchievementManager)));
		UnityEngine.Object.DontDestroyOnLoad(new GameObject("RankingManager", typeof(RankingManager)));
		UnityEngine.Object.DontDestroyOnLoad(new GameObject("AudioPlayerManager", typeof(AudioPlayerManager)));
		UnityEngine.Object.DontDestroyOnLoad(UnityEngine.Object.Instantiate(Resources.Load("Prefab/EasySave3Manager")));
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public abstract class CameraController<T> : SingletonMonoBehaviour<T> where T : MonoBehaviourWithInit
{
	[SerializeField]
	[Required]
	protected GameObject _nonVRCamera;

	[SerializeField]
	[Required]
	protected GameObject _vrCamera;

	[SerializeField]
	[Required]
	protected GameObject _oculusCamera;

	[SerializeField]
	[Required]
	private GameObject _nonVRHand;

	private int _currentRotationValue;

	private float _rotationInterval;

	public GameObject CurrentCameraObject { get; private set; }

	public Camera CurrentCamera { get; private set; }

	protected abstract Vector3 INITIAL_POSITION { get; }

	protected abstract Vector3 INITIAL_ROTATION { get; }

	protected override void Init()
	{
		base.Init();
		_oculusCamera.SetActive(value: true);
		_nonVRCamera.SetActive(value: false);
		_vrCamera.SetActive(value: false);
		_oculusCamera.transform.SetLocalPositionY(0f);
		CurrentCameraObject = _oculusCamera;
		CurrentCamera = CurrentCameraObject.GetComponentInChildren<DebugInfoDisplay>().gameObject.GetComponent<Camera>();
		InputEventMediator.Mediate(null, OnInputKey);
		base.transform.position = INITIAL_POSITION;
		base.transform.rotation = Quaternion.Euler(INITIAL_ROTATION);
		if (_vrCamera.activeSelf)
		{
			base.transform.SetLocalPositionY(1f);
		}
		UpdateSquatState();
		UpdateRotationState();
	}

	private void Update()
	{
		if (_rotationInterval > 0f)
		{
			_rotationInterval -= Time.deltaTime;
		}
	}

	public void UpdateSquatAndRotation()
	{
		UpdateSquatState();
		UpdateRotationState();
	}

	private void OnInputKey(InputKeyType keyType, InputStateType stateType)
	{
		if (stateType == InputStateType.Down && (keyType == InputKeyType.SquatUpRight || keyType == InputKeyType.SquatUpLeft || keyType == InputKeyType.SquatDownRight || keyType == InputKeyType.SquatDownLeft))
		{
			ChangeSquatState(keyType == InputKeyType.SquatUpRight || keyType == InputKeyType.SquatUpLeft, keyType == InputKeyType.SquatUpLeft || keyType == InputKeyType.SquatDownLeft);
		}
		if ((stateType == InputStateType.Down || stateType == InputStateType.Pressing) && (keyType == InputKeyType.RightRotationRight || keyType == InputKeyType.LeftRotationRight || keyType == InputKeyType.RightRotationLeft || keyType == InputKeyType.LeftRotationLeft))
		{
			if (stateType == InputStateType.Down)
			{
				_rotationInterval = 0f;
			}
			if (_rotationInterval <= 0f)
			{
				_rotationInterval = 0.3f;
				ChangeRotationState(keyType == InputKeyType.RightRotationRight || keyType == InputKeyType.RightRotationLeft, keyType == InputKeyType.RightRotationLeft || keyType == InputKeyType.LeftRotationLeft);
			}
		}
	}

	private void ChangeSquatState(bool isUp, bool isLeftHand)
	{
		int squatValue = UserDataAccessorManager.SettingDataAccessor.SquatValue;
		UserDataAccessorManager.SettingDataAccessor.SquatValue += (isUp ? 1 : (-1));
		if (squatValue != UserDataAccessorManager.SettingDataAccessor.SquatValue)
		{
			SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(isLeftHand);
		}
		UpdateSquatState();
	}

	private void UpdateSquatState()
	{
		float num = (float)UserDataAccessorManager.SettingDataAccessor.SquatValue * 0.5f;
		if (!_vrCamera.activeSelf && !_oculusCamera.activeSelf)
		{
			num += 1f;
		}
		CurrentCameraObject.transform.GetChild(0).SetLocalPositionY(num);
	}

	private void ChangeRotationState(bool isRight, bool isLeftHand)
	{
		int rotationValue = UserDataAccessorManager.SettingDataAccessor.RotationValue;
		UserDataAccessorManager.SettingDataAccessor.RotationValue += (isRight ? 1 : (-1));
		if (rotationValue != UserDataAccessorManager.SettingDataAccessor.RotationValue)
		{
			SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(isLeftHand);
		}
		UpdateRotationState();
	}

	private void UpdateRotationState()
	{
		int rotationValue = UserDataAccessorManager.SettingDataAccessor.RotationValue;
		int num = rotationValue - _currentRotationValue;
		_currentRotationValue = rotationValue;
		base.transform.RotateAround(CurrentCamera.transform.position, Vector3.up, num * 30);
	}
}
public class CameraFader : MonoBehaviour
{
	private Material _material;

	private Action _callback;

	private float _fromColor;

	private float _toColor;

	private float _duration;

	private float _currentTime;

	private bool _isIgnoreTimeScale = true;

	private bool _isPlaying;

	public bool IsPlaying => _isPlaying;

	private void Awake()
	{
		_material = Resources.Load<Material>("Material/CameraFader");
	}

	private void Update()
	{
		if (_isPlaying)
		{
			_currentTime += (_isIgnoreTimeScale ? Time.unscaledDeltaTime : Time.deltaTime);
			float num = Mathf.Min(1f, _currentTime / _duration);
			SetColor(_toColor * num + _fromColor * (1f - num));
			if (_currentTime >= _duration)
			{
				EndFade();
			}
		}
	}

	private void OnRenderImage(RenderTexture src, RenderTexture dest)
	{
		Graphics.Blit(src, dest, _material);
	}

	public void FadeOut(float duration = 0.5f, bool isIgnoreTimeScale = true, Action callback = null)
	{
		BeginFade(1f, 0f, duration, isIgnoreTimeScale, callback);
	}

	public void FadeIn(float duration = 0.5f, bool isIgnoreTimeScale = true, Action callback = null)
	{
		BeginFade(0f, 1f, duration, isIgnoreTimeScale, callback);
	}

	private void BeginFade(float fromColor, float toColor, float duration, bool isIgnoreTimeScale, Action callback)
	{
		_currentTime = 0f;
		_fromColor = fromColor;
		_toColor = toColor;
		_duration = duration;
		_isIgnoreTimeScale = isIgnoreTimeScale;
		_callback = callback;
		_isPlaying = true;
		if (duration <= 0f)
		{
			SetColor(_toColor);
			EndFade();
		}
		else
		{
			SetColor(_fromColor);
		}
	}

	private void EndFade()
	{
		_isPlaying = false;
		_callback?.Invoke();
	}

	private void SetColor(float color)
	{
		_material.SetColor("_Color", new Color(color, color, color, color));
	}
}
public class CameraMover : MonoBehaviour
{
	private Rigidbody _rigidbody;

	private Transform _currentCamera;

	private readonly float MOVE_SPEED = 2f;

	private readonly float ROTATION_SPEED = 6f;

	private Vector3 _currentVelocity = Vector3.zero;

	private readonly float ROTATION_X_LIMIT = 30f;

	public void Init(Transform currentCamera)
	{
		_rigidbody = base.gameObject.GetComponent<Rigidbody>();
		_currentCamera = currentCamera;
		InputEventMediator.Mediate(null, null, OnResetRotation, OnUpdatePositionVector2, OnUpdateRotationVector2);
	}

	private void OnUpdatePositionVector2(Vector2 vector2)
	{
		_currentVelocity = _currentCamera.rotation * new Vector3(vector2.x, 0f, vector2.y) * MOVE_SPEED;
	}

	private void OnUpdateRotationVector2(Vector2 vector2)
	{
		Vector3 localEulerAngles = base.transform.localEulerAngles;
		localEulerAngles.z = 0f;
		localEulerAngles.x -= vector2.y * ROTATION_SPEED;
		localEulerAngles.y += vector2.x * ROTATION_SPEED;
		float num = 360f - ROTATION_X_LIMIT;
		if (localEulerAngles.x > ROTATION_X_LIMIT && localEulerAngles.x < 180f)
		{
			localEulerAngles.x = ROTATION_X_LIMIT;
		}
		else if (localEulerAngles.x < num && localEulerAngles.x > 180f)
		{
			localEulerAngles.x = num;
		}
		base.transform.localEulerAngles = localEulerAngles;
	}

	private void OnResetRotation()
	{
		base.transform.rotation = Quaternion.identity;
	}

	private void FixedUpdate()
	{
		_rigidbody.velocity = _currentVelocity;
		_currentVelocity = Vector3.zero;
	}
}
public static class ClothingUtility
{
	public static bool CanChange()
	{
		return true;
	}
}
[RequireComponent(typeof(GrabableObject))]
public class GirlAccessory : MonoBehaviour
{
	private Transform _initialParent;

	private Vector3 _initialPosition;

	private Quaternion _initialRotation;

	private MeshEffectPlayer _lickEffectPlayer;

	[SerializeField]
	private List<Renderer> _effectTargetRendererList = new List<Renderer>();

	private void Start()
	{
		if (SceneNavigator.CurrentSceneName == "Main")
		{
			_lickEffectPlayer = base.gameObject.AddComponent<MeshEffectPlayer>();
			_lickEffectPlayer.Init(_effectTargetRendererList, "Prefab/Production/MeshEffect/LickCriticalEffect", "MeshEffect_LickCriticalEffect");
		}
	}

	public void Init(bool isEnabled)
	{
		GrabableObject component = base.gameObject.GetComponent<GrabableObject>();
		if (component.IsGrabbing)
		{
			component.ForciblyRelease();
		}
		Transform transform = base.transform;
		if (_initialParent == null)
		{
			_initialParent = transform.parent;
			_initialPosition = transform.localPosition;
			_initialRotation = transform.localRotation;
			component.Released += OnReleased;
			if (SceneNavigator.CurrentSceneName == "Main")
			{
				component.Grabbed += OnGrabbed;
			}
		}
		else
		{
			transform.SetParent(_initialParent);
			transform.localPosition = _initialPosition;
			transform.localRotation = _initialRotation;
		}
		Rigidbody component2 = base.gameObject.GetComponent<Rigidbody>();
		component2.isKinematic = true;
		component2.velocity = Vector3.zero;
		component2.angularVelocity = Vector3.zero;
		base.gameObject.SetActive(isEnabled);
	}

	private void OnReleased()
	{
		base.transform.SetParent(null);
	}

	private void OnGrabbed()
	{
		base.gameObject.GetComponent<GrabableObject>().Grabbed -= OnGrabbed;
		if (SingletonMonoBehaviour<GirlManager>.Instance.IsPause)
		{
			SingletonMonoBehaviour<GirlManager>.Instance.Resumed += OnStole;
		}
		else
		{
			SingletonMonoBehaviour<GameManager>.Instance.GameOver(GameOverType.Stole);
		}
	}

	private void OnStole()
	{
		SingletonMonoBehaviour<GirlManager>.Instance.Resumed -= OnStole;
		SingletonMonoBehaviour<GameManager>.Instance.GameOver(GameOverType.Stole);
	}

	public void OnLick()
	{
		_lickEffectPlayer?.Show(0.2f);
	}
}
public class BoyClothingUpdater : ClothingUpdater
{
	[SerializeField]
	[Required]
	private Material _clotheMaterial;

	[SerializeField]
	[Required]
	private Material _bodyMaterial;

	[SerializeField]
	[Required]
	private Texture _normalClotheTexture;

	[SerializeField]
	[Required]
	private Texture _spectialClotheTexture;

	[SerializeField]
	[Required]
	private Texture _normalBodyTexture;

	[SerializeField]
	[Required]
	private Texture _spectialBodyTexture;

	[SerializeField]
	[Required]
	private GameObject _clothes;

	[SerializeField]
	[Required]
	private GameObject _hair1;

	[SerializeField]
	[Required]
	private GameObject _hair2;

	[Button("服装更新")]
	protected override void UpdateClothing()
	{
		base.UpdateClothing();
		_hair2.SetActive(IsEnabled(GirlClothesType.Unique1));
		_hair1.SetActive(!_hair2.activeSelf);
		_clothes.SetActive(!IsEnabled(GirlClothesType.Unique2));
		UpdateTexture(_clotheMaterial, GirlClothesType.Unique3, _spectialClotheTexture, _normalClotheTexture);
		UpdateTexture(_bodyMaterial, GirlClothesType.Unique3, _spectialBodyTexture, _normalBodyTexture);
	}
}
public abstract class ClothingUpdater : MonoBehaviour
{
	protected bool _canChange;

	private static readonly int MAIN_TEX_ID = Shader.PropertyToID("_MainTex");

	private static readonly int EMISSION_ID = Shader.PropertyToID("_EmissionMap");

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _bra;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _burma;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _panty;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _headphone;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _catCap;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _catEar;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _glasses;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _sunglasses;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _goggles;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _eyePatchLeft;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _eyePatchRight;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _tail;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _mask;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _gasMask;

	[SerializeField]
	[BoxGroup("アクセサリ", true, false, 0)]
	private GirlAccessory _hannya;

	private void Start()
	{
		_bra?.gameObject.SetActive(value: true);
		_burma?.gameObject.SetActive(value: true);
		_panty?.gameObject.SetActive(value: true);
		_headphone?.gameObject.SetActive(value: true);
		_catCap?.gameObject.SetActive(value: true);
		_catEar?.gameObject.SetActive(value: true);
		_glasses?.gameObject.SetActive(value: true);
		_sunglasses?.gameObject.SetActive(value: true);
		_goggles?.gameObject.SetActive(value: true);
		_eyePatchLeft?.gameObject.SetActive(value: true);
		_eyePatchRight?.gameObject.SetActive(value: true);
		_tail?.gameObject.SetActive(value: true);
		_mask?.gameObject.SetActive(value: true);
		_gasMask?.gameObject.SetActive(value: true);
		_hannya?.gameObject.SetActive(value: true);
		StartCoroutine(this.DelayMethod(0.01f, UpdateClothing));
		UserDataAccessorManager.SettingDataAccessor.ChangedGirlClothes += UpdateClothing;
	}

	public void DestroyAllAccessory()
	{
		UnityEngine.Object.Destroy(_bra.gameObject);
		UnityEngine.Object.Destroy(_burma.gameObject);
		UnityEngine.Object.Destroy(_panty.gameObject);
		UnityEngine.Object.Destroy(_headphone.gameObject);
		UnityEngine.Object.Destroy(_catCap.gameObject);
		UnityEngine.Object.Destroy(_catEar.gameObject);
		UnityEngine.Object.Destroy(_glasses.gameObject);
		UnityEngine.Object.Destroy(_sunglasses.gameObject);
		UnityEngine.Object.Destroy(_goggles.gameObject);
		UnityEngine.Object.Destroy(_eyePatchLeft.gameObject);
		UnityEngine.Object.Destroy(_eyePatchRight.gameObject);
		UnityEngine.Object.Destroy(_tail.gameObject);
		UnityEngine.Object.Destroy(_mask.gameObject);
		UnityEngine.Object.Destroy(_gasMask.gameObject);
		UnityEngine.Object.Destroy(_hannya.gameObject);
	}

	private void OnDestroy()
	{
		UserDataAccessorManager.SettingDataAccessor.ChangedGirlClothes -= UpdateClothing;
	}

	[Button("服装更新")]
	protected virtual void UpdateClothing()
	{
		_canChange = ClothingUtility.CanChange();
		Debug.Log($"服装の切り替えが可能か : {_canChange}");
		InitAccessory(_bra, GirlClothesType.Bra);
		InitAccessory(_burma, GirlClothesType.Burma);
		InitAccessory(_panty, GirlClothesType.Panty);
		InitAccessory(_headphone, GirlClothesType.Headphones);
		InitAccessory(_catCap, GirlClothesType.CatCap);
		InitAccessory(_catEar, GirlClothesType.CatEar);
		InitAccessory(_glasses, GirlClothesType.Glasses);
		InitAccessory(_sunglasses, GirlClothesType.Sunglasses);
		InitAccessory(_goggles, GirlClothesType.Goggles);
		InitAccessory(_eyePatchLeft, GirlClothesType.EyePatchLeft);
		InitAccessory(_eyePatchRight, GirlClothesType.EyePatchRight);
		InitAccessory(_tail, GirlClothesType.Tail);
		InitAccessory(_mask, GirlClothesType.Mask);
		InitAccessory(_gasMask, GirlClothesType.GasMask);
		InitAccessory(_hannya, GirlClothesType.Hannya);
	}

	private void InitAccessory(GirlAccessory accessory, GirlClothesType clothesType)
	{
		if (accessory == null)
		{
			Debug.LogWarning($"{clothesType}のアクセサリがアタッチされていません");
		}
		else
		{
			accessory.Init(_canChange && UserDataAccessorManager.SettingDataAccessor.GetGirlClothesFlag(clothesType));
		}
	}

	protected void UpdateTexture(Material material, GirlClothesType clothesType, Texture spectialTexture, Texture normalTexture)
	{
		Texture value = (IsEnabled(clothesType) ? spectialTexture : normalTexture);
		material.SetTexture(MAIN_TEX_ID, value);
		material.SetTexture(EMISSION_ID, value);
	}

	protected bool IsEnabled(GirlClothesType clothesType)
	{
		if (_canChange)
		{
			return UserDataAccessorManager.SettingDataAccessor.GetGirlClothesFlag(clothesType);
		}
		return false;
	}
}
public class GirlClothingUpdater : ClothingUpdater
{
	[SerializeField]
	[Required]
	private Material _clotheMaterial;

	[SerializeField]
	[Required]
	private Material _skirtMaterial;

	[SerializeField]
	[Required]
	private Material _shoesMaterial;

	[SerializeField]
	[Required]
	private Texture _normalClotheTexture;

	[SerializeField]
	[Required]
	private Texture _omakeClotheTexture;

	[Button("服装更新")]
	protected override void UpdateClothing()
	{
		base.UpdateClothing();
		UpdateTexture(_clotheMaterial, GirlClothesType.Unique1, _omakeClotheTexture, _normalClotheTexture);
		UpdateTexture(_skirtMaterial, GirlClothesType.Unique2, _omakeClotheTexture, _normalClotheTexture);
		UpdateTexture(_shoesMaterial, GirlClothesType.Unique3, _omakeClotheTexture, _normalClotheTexture);
	}
}
public class EyeShadowPalette : MonoBehaviour
{
	[SerializeField]
	[Required]
	private GameObject _mirror;

	private void Awake()
	{
		_mirror.SetActive(value: false);
	}
}
public class KanCrowVoicePlayer : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Transform _beak;

	[SerializeField]
	private AnimationCurve _beakXAnimationCurve;

	[SerializeField]
	private AnimationCurve _beakYAnimationCurve;

	private AudioPlayer _voicePlayer;

	private Sequence _sequence;

	private void Start()
	{
		_voicePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_KanKikuchiVoice");
		GetComponent<GrabableObject>().Grabbed += OnGrabbed;
	}

	private void OnGrabbed()
	{
		_voicePlayer.Play();
		_sequence?.Kill();
		_sequence = DOTween.Sequence().Append(_beak.DOScaleX(1.09f, 1f).SetEase(_beakXAnimationCurve)).Join(_beak.DOScaleY(1.2f, 1f).SetEase(_beakYAnimationCurve));
	}
}
public abstract class PostProcessManager<T> : SingletonMonoBehaviour<T> where T : MonoBehaviourWithInit
{
	[SerializeField]
	[Required]
	protected PostProcessVolume _normalPostProcess;

	[SerializeField]
	[Required]
	private PostProcessVolume _moveScenePostProcess;

	[SerializeField]
	[Required]
	private List<PostProcessLayer> _postProcessLayerList = new List<PostProcessLayer>();

	protected override void Init()
	{
		base.Init();
		ShowNormal();
		foreach (PostProcessLayer postProcessLayer in _postProcessLayerList)
		{
			postProcessLayer.enabled = false;
		}
	}

	public virtual void ShowNormal()
	{
		_moveScenePostProcess.weight = 0f;
		_moveScenePostProcess.gameObject.SetActive(value: false);
	}

	public void CreateMoveSceneTween(Sequence sequence, float duration)
	{
		_moveScenePostProcess.gameObject.SetActive(value: true);
		sequence.Join(DOTween.To(() => 0f, delegate(float timeRate)
		{
			_normalPostProcess.weight = 1f - timeRate;
			_moveScenePostProcess.weight = timeRate;
		}, 1f, duration));
	}
}
[RequireComponent(typeof(Rigidbody))]
public class GrabableObject : RespondGrabbingObject
{
	protected Transform _transform;

	protected Rigidbody _rigidbody;

	[SerializeField]
	private float _velocityRate = 65f;

	[SerializeField]
	private float _angularVelocityRate = 65f;

	[SerializeField]
	[HideInInspector]
	private bool _shouldAdjustPosition;

	[SerializeField]
	[HideInInspector]
	private bool _shouldAdjustRotation;

	[SerializeField]
	[HideInInspector]
	private Vector3 _adjustPosition = Vector3.zero;

	[SerializeField]
	[HideInInspector]
	private Vector3 _adjustRotation = Vector3.zero;

	private Vector3 _beforePosition;

	private Vector3 _beforeRotation;

	private Vector3 _velocity;

	private Vector3 _angularVelocity;

	public Transform BeforeParent { private get; set; }

	public bool ShouldAdjustPosition => _shouldAdjustPosition;

	public bool ShouldAdjustRotation => _shouldAdjustRotation;

	public event Action Grabbed = delegate
	{
	};

	public event Action Released = delegate
	{
	};

	protected override void Awake()
	{
		base.Awake();
		_transform = base.transform;
		_rigidbody = base.gameObject.GetComponent<Rigidbody>();
		_rigidbody.interpolation = RigidbodyInterpolation.None;
		_rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		_beforePosition = _transform.position;
		_beforeRotation = _transform.rotation.eulerAngles;
		if (base.gameObject.layer != 0)
		{
			Debug.LogWarning(base.gameObject.name + "のレイヤーがDefault以外になっています");
		}
	}

	protected virtual void LateUpdate()
	{
		Vector3 position = _transform.position;
		Vector3 eulerAngles = _transform.rotation.eulerAngles;
		_velocity = position - _beforePosition;
		_angularVelocity = eulerAngles - _beforeRotation;
		_beforePosition = position;
		_beforeRotation = eulerAngles;
	}

	public override void OnGrabbed(VRHand targetHand, Action forciblyReleaseAction)
	{
		base.OnGrabbed(targetHand, (Action)Delegate.Combine(forciblyReleaseAction, new Action(SetBeforeParent)));
		BeforeParent = base.transform.parent;
		base.transform.SetParent(targetHand.transform);
		if (_shouldAdjustPosition)
		{
			base.transform.localPosition = _adjustPosition;
		}
		if (_shouldAdjustRotation)
		{
			base.transform.localRotation = Quaternion.Euler(_adjustRotation);
		}
		this.Grabbed();
		_rigidbody.isKinematic = true;
	}

	public override void OnReleased(VRHand targetHand)
	{
		base.OnReleased(targetHand);
		SetBeforeParent();
		IgnoreHand();
		_rigidbody.isKinematic = false;
		_rigidbody.velocity = _velocity * _velocityRate;
		_rigidbody.angularVelocity = _angularVelocity * _angularVelocityRate;
		this.Released();
	}

	private void SetBeforeParent()
	{
		base.transform.SetParent(BeforeParent);
	}
}
[RequireComponent(typeof(Rigidbody))]
public class GrabbingMoveObject : RespondGrabbingObject
{
	public enum State
	{
		Off,
		Middle,
		On
	}

	private Transform _transform;

	private Rigidbody _rigidbody;

	[SerializeField]
	[HideInInspector]
	private bool _existState;

	[SerializeField]
	[HideInInspector]
	private Vector3 _offPosition = Vector3.zero;

	[SerializeField]
	[HideInInspector]
	private Vector3 _onPosition = Vector3.zero;

	[SerializeField]
	[HideInInspector]
	private float _returnSpeed = 20f;

	[SerializeField]
	[HideInInspector]
	private bool _autoOff;

	private State _currentState;

	public bool ExistState => _existState;

	public float ReturnSpeed => _returnSpeed;

	public State CurrentState => _currentState;

	public event Action Moved = delegate
	{
	};

	public event Action<State> ChangedState = delegate
	{
	};

	protected override void Awake()
	{
		base.Awake();
		_transform = base.transform;
		_rigidbody = GetComponent<Rigidbody>();
	}

	private void LateUpdate()
	{
		if (_existState && !(_returnSpeed <= 0f) && !base.IsGrabbing && (_currentState != State.On || _autoOff))
		{
			Move((_offPosition - base.transform.localPosition) * _returnSpeed * Time.deltaTime);
		}
	}

	private void Move(Vector3 distance)
	{
		Vector3 targetValue = base.transform.position + distance;
		if (ExistState)
		{
			MathfUtility.Clamp(ref targetValue, ref _offPosition, ref _onPosition);
		}
		Vector3 position = _transform.position;
		_transform.localPosition = targetValue;
		Vector3 position2 = _transform.position;
		_transform.position = position;
		_rigidbody.MovePosition(position2);
		this.Moved();
		if (Vector3.Distance(targetValue, _onPosition) <= 0f)
		{
			ChangeState(State.On);
		}
		else if (Vector3.Distance(targetValue, _offPosition) <= 0f)
		{
			ChangeState(State.Off);
		}
		else
		{
			ChangeState(State.Middle);
		}
	}

	private void ChangeState(State state)
	{
		if (_currentState != state)
		{
			_currentState = state;
			this.ChangedState(_currentState);
		}
	}

	public override void OnGrabbed(VRHand targetHand, Action forciblyReleaseAction)
	{
		base.OnGrabbed(targetHand, (Action)Delegate.Combine(forciblyReleaseAction, new Action(RemoveMoveEvent)));
		_grabbignHand.Moved += Move;
	}

	public override void OnReleased(VRHand targetHand)
	{
		RemoveMoveEvent();
		base.OnReleased(targetHand);
	}

	private void RemoveMoveEvent()
	{
		_grabbignHand.Moved -= Move;
	}
}
public class LeverObject : MonoBehaviour
{
	[SerializeField]
	[Required]
	private GrabbingMoveObject _grabbingMoveObject;

	[SerializeField]
	[Required]
	private MeshRenderer _meshRenderer;

	[SerializeField]
	[Required]
	private Material _offMaterial;

	[SerializeField]
	[Required]
	private Material _middleMaterial;

	[SerializeField]
	[Required]
	private Material _onMaterial;

	private void Awake()
	{
		_grabbingMoveObject.Moved += OnMove;
		_grabbingMoveObject.ChangedState += OnChangeState;
	}

	private void OnMove()
	{
		base.transform.LookAt(_grabbingMoveObject.transform);
	}

	private void OnChangeState(GrabbingMoveObject.State currentState)
	{
		switch (currentState)
		{
		case GrabbingMoveObject.State.Off:
			_meshRenderer.material = _offMaterial;
			break;
		case GrabbingMoveObject.State.Middle:
			_meshRenderer.material = _middleMaterial;
			break;
		case GrabbingMoveObject.State.On:
			_meshRenderer.material = _onMaterial;
			break;
		}
	}
}
public class LickableObject : MonoBehaviour
{
	private LickableObjectSet _lickableObjectSet;

	[SerializeField]
	private bool _isCritical;

	public bool IsCritical => _isCritical;

	public void SetLickableObjectSet(LickableObjectSet lickableObjectSet)
	{
		_lickableObjectSet = lickableObjectSet;
	}

	[Button("名前更新")]
	private void UpdateName()
	{
		base.gameObject.name = "LickableObject";
		if (_isCritical)
		{
			base.gameObject.name += "_Critical";
		}
	}

	public LickableObjectType GetObjectType()
	{
		if (_lickableObjectSet == null)
		{
			Debug.LogWarning("LickableObjectSetがセットされていません！");
			GetComponentInParent<LickableObjectSet>().Init();
		}
		return _lickableObjectSet.ObjectType;
	}

	public void OnLick()
	{
		if (_lickableObjectSet == null)
		{
			Debug.LogWarning("LickableObjectSetがセットされていません！");
			GetComponentInParent<LickableObjectSet>().Init();
		}
		_lickableObjectSet.OnLick(_isCritical);
	}
}
public class LickableObjectManager : SingletonMonoBehaviour<LickableObjectManager>
{
	private Dictionary<LickableObjectType, Sprite> _iconDict = new Dictionary<LickableObjectType, Sprite>();

	private Dictionary<CharacterType, Sprite> _characterIconDict = new Dictionary<CharacterType, Sprite>();

	private readonly Dictionary<LickableObjectType, LickableObjectSet> _lickableObjetSetDict = new Dictionary<LickableObjectType, LickableObjectSet>();

	private readonly List<LickableObjectType> _girlHoldingObjectTypeList = new List<LickableObjectType>
	{
		LickableObjectType.Book1,
		LickableObjectType.Pen,
		LickableObjectType.Eraser,
		LickableObjectType.Dictionary1,
		LickableObjectType.Glasses,
		LickableObjectType.HeadPhone,
		LickableObjectType.Mask,
		LickableObjectType.Uchiwa,
		LickableObjectType.Lucky,
		LickableObjectType.ChocoBanana,
		LickableObjectType.TapiocaTea,
		LickableObjectType.Ice,
		LickableObjectType.ToothBrush,
		LickableObjectType.Taionkei,
		LickableObjectType.Toast,
		LickableObjectType.Candy,
		LickableObjectType.Loafer,
		LickableObjectType.SwimSuitGirl,
		LickableObjectType.FlutterBoard,
		LickableObjectType.SwimCap,
		LickableObjectType.Bra,
		LickableObjectType.Panty,
		LickableObjectType.Burma,
		LickableObjectType.Shirt
	};

	private readonly List<List<LickableObjectType>> _instructionTargetObjectTypeList = new List<List<LickableObjectType>>
	{
		new List<LickableObjectType>
		{
			LickableObjectType.Book1,
			LickableObjectType.Pen,
			LickableObjectType.Eraser,
			LickableObjectType.Dictionary1,
			LickableObjectType.Dictionary2
		},
		new List<LickableObjectType>
		{
			LickableObjectType.Glasses,
			LickableObjectType.HeadPhone,
			LickableObjectType.Mask,
			LickableObjectType.Uchiwa,
			LickableObjectType.GirlSchoolBag,
			LickableObjectType.Umbrella,
			LickableObjectType.EyeShadowPalette
		},
		new List<LickableObjectType>
		{
			LickableObjectType.Lucky,
			LickableObjectType.ChocoBanana,
			LickableObjectType.TapiocaTea,
			LickableObjectType.Ice,
			LickableObjectType.GirlDrink,
			LickableObjectType.LunchBox,
			LickableObjectType.Lip,
			LickableObjectType.SamuraiSoccer,
			LickableObjectType.GirlSmartPhone,
			LickableObjectType.Usachan,
			LickableObjectType.RemoteControler
		},
		new List<LickableObjectType>
		{
			LickableObjectType.ToothBrush,
			LickableObjectType.Taionkei,
			LickableObjectType.Toast,
			LickableObjectType.Candy,
			LickableObjectType.Spoon,
			LickableObjectType.Fork,
			LickableObjectType.ShoesL,
			LickableObjectType.ShoesR
		},
		new List<LickableObjectType>
		{
			LickableObjectType.Loafer,
			LickableObjectType.SwimSuitGirl,
			LickableObjectType.FlutterBoard,
			LickableObjectType.SwimCap,
			LickableObjectType.LuckyBox,
			LickableObjectType.Projector,
			LickableObjectType.RulerSquare1,
			LickableObjectType.ScreenHook,
			LickableObjectType.Attendancebook,
			LickableObjectType.RoseRed,
			LickableObjectType.RoseBlue,
			LickableObjectType.Choker,
			LickableObjectType.Whip
		},
		new List<LickableObjectType>
		{
			LickableObjectType.Bra,
			LickableObjectType.Panty,
			LickableObjectType.Burma,
			LickableObjectType.Shirt,
			LickableObjectType.Compass,
			LickableObjectType.BabyBottle,
			LickableObjectType.SwimSuitBoy,
			LickableObjectType.Broom,
			LickableObjectType.BlackboardEraser,
			LickableObjectType.ChalkBlue,
			LickableObjectType.ChalkPink
		}
	};

	private readonly List<LickableObjectType> _instructedTypelist = new List<LickableObjectType> { LickableObjectType.Recorder };

	private readonly List<LickableObjectType> _inBagTypelist = new List<LickableObjectType>
	{
		LickableObjectType.GirlSmartPhone,
		LickableObjectType.EyeShadowPalette,
		LickableObjectType.Usachan,
		LickableObjectType.RemoteControler,
		LickableObjectType.Choker,
		LickableObjectType.Whip
	};

	private readonly Dictionary<LickableObjectType, int> _spetialItemTypeDict = new Dictionary<LickableObjectType, int>
	{
		{
			LickableObjectType.TapiocaTeaRainbow,
			100
		},
		{
			LickableObjectType.Ingot,
			50
		},
		{
			LickableObjectType.Money,
			50
		},
		{
			LickableObjectType.TransparentTube,
			30
		},
		{
			LickableObjectType.TimeStopClock,
			30
		}
	};

	protected override void Init()
	{
		base.Init();
		SpriteAtlas spriteAtlas = Resources.Load<SpriteAtlas>("Texture/InstructionIcon");
		foreach (LickableObjectType allIn in EnumUtility.GetAllInList<LickableObjectType>())
		{
			Sprite sprite = spriteAtlas.GetSprite(allIn.ToString());
			_iconDict[allIn] = sprite;
			if (sprite == null)
			{
				Debug.LogWarning($"{allIn}のアイコンがありません");
			}
		}
		foreach (CharacterType allIn2 in EnumUtility.GetAllInList<CharacterType>())
		{
			Sprite sprite2 = spriteAtlas.GetSprite(allIn2.ToString());
			_characterIconDict[allIn2] = sprite2;
			if (sprite2 == null)
			{
				Debug.LogWarning($"{allIn2}のアイコンがありません");
			}
		}
		LickableObjectSet[] componentsInChildren = base.transform.GetComponentsInChildren<LickableObjectSet>();
		foreach (LickableObjectSet lickableObjectSet in componentsInChildren)
		{
			InitLickableObjectSet(lickableObjectSet);
		}
		List<LickableObjectSet> newCreateObjectList = new List<LickableObjectSet>();
		foreach (LickableObjectType allIn3 in EnumUtility.GetAllInList<LickableObjectType>())
		{
			if (!_lickableObjetSetDict.ContainsKey(allIn3) && allIn3 != LickableObjectType.Girl)
			{
				LickableObjectSet lickableObjectSet2 = Resources.Load<LickableObjectSet>(string.Format("{0}/{1}", "Prefab/LickableObject", allIn3));
				if (lickableObjectSet2 == null)
				{
					Debug.LogWarning($"{allIn3}のPrefabがありません！");
					continue;
				}
				LickableObjectSet lickableObjectSet3 = base.transform.CreateChildFromOriginal<LickableObjectSet>(lickableObjectSet2.transform);
				lickableObjectSet3.gameObject.SetActive(value: true);
				InitLickableObjectSet(lickableObjectSet3);
				newCreateObjectList.Add(lickableObjectSet3);
			}
		}
		StartCoroutine(this.DelayMethod(0.01f, delegate
		{
			foreach (LickableObjectSet item in newCreateObjectList)
			{
				item.gameObject.SetActive(value: false);
			}
		}));
		SingletonMonoBehaviour<GirlManager>.Instance.Girl.GetComponent<LickableObjectSet>().Init();
	}

	private void InitLickableObjectSet(LickableObjectSet lickableObjectSet)
	{
		lickableObjectSet.Init();
		if (_lickableObjetSetDict.ContainsKey(lickableObjectSet.ObjectType))
		{
			Debug.LogWarning($"{lickableObjectSet.ObjectType}が重複しています");
		}
		_lickableObjetSetDict[lickableObjectSet.ObjectType] = lickableObjectSet;
	}

	public Sprite GetIcon(LickableObjectType objectType)
	{
		if (objectType == LickableObjectType.Girl)
		{
			CharacterType currentCharacterType = SingletonMonoBehaviour<GirlManager>.Instance.CurrentCharacterType;
			if (_characterIconDict.ContainsKey(currentCharacterType))
			{
				return _characterIconDict[currentCharacterType];
			}
			Debug.LogWarning($"{currentCharacterType}のアイコンがロードされていません");
			return null;
		}
		if (_iconDict.ContainsKey(objectType))
		{
			return _iconDict[objectType];
		}
		Debug.LogWarning($"{objectType}のアイコンがロードされていません");
		return null;
	}

	public LickableObjectSet GetLickableObjectSet(LickableObjectType lickableObjectType)
	{
		if (!_lickableObjetSetDict.ContainsKey(lickableObjectType))
		{
			Debug.LogError($"{lickableObjectType}は_lickableObjetSetDictには設定されていません");
			return null;
		}
		return _lickableObjetSetDict[lickableObjectType];
	}

	private List<LickableObjectType> GetCandidateList()
	{
		int instructionCount = SingletonMonoBehaviour<InstructionManager>.Instance.InstructionCount;
		switch (instructionCount)
		{
		case 0:
			return new List<LickableObjectType> { LickableObjectType.Recorder };
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			return _instructionTargetObjectTypeList[instructionCount - 1];
		default:
			if (instructionCount == 7)
			{
				return _instructionTargetObjectTypeList[4].Concat(_instructionTargetObjectTypeList[5]).ToList();
			}
			return _instructionTargetObjectTypeList.SelectMany((List<LickableObjectType> lickableObjectTypeList) => lickableObjectTypeList).ToList();
		}
	}

	public LickableObjectSet GetGirlHoldingObject()
	{
		List<LickableObjectType> list = (from lickableObjectType in GetCandidateList()
			where _girlHoldingObjectTypeList.Contains(lickableObjectType) && !GetLickableObjectSet(lickableObjectType).gameObject.activeSelf
			select lickableObjectType).ToList();
		if (list.Count == 0)
		{
			Debug.LogWarning("女の子が持ってくる物の候補がありません");
			return GetLickableObjectSet(LickableObjectType.Recorder);
		}
		return GetLickableObjectSet(list.GetAtRandom());
	}

	public List<LickableObjectType> GetInstructionObjectTypeList(LickableObjectType holdingObjectType, int instructionNum)
	{
		List<LickableObjectType> list = (from lickableObjectType in GetCandidateList()
			where lickableObjectType != holdingObjectType && !_instructedTypelist.Contains(lickableObjectType) && GetLickableObjectSet(lickableObjectType).gameObject.activeSelf
			select lickableObjectType).ToList();
		if (list.Count < instructionNum)
		{
			list = (from lickableObjectType in GetCandidateList()
				where lickableObjectType != holdingObjectType && GetLickableObjectSet(lickableObjectType).gameObject.activeSelf
				select lickableObjectType).ToList();
		}
		List<LickableObjectType> list2 = new List<LickableObjectType> { holdingObjectType };
		_instructedTypelist.Add(holdingObjectType);
		for (int i = 1; i < instructionNum; i++)
		{
			if (list.Count == 0)
			{
				Debug.LogWarning("指示対象になるオブジェクトがありません");
				break;
			}
			LickableObjectType andRemoveAtRandom = list.GetAndRemoveAtRandom();
			list2.Add(andRemoveAtRandom);
			_instructedTypelist.Add(andRemoveAtRandom);
		}
		return list2;
	}

	public List<LickableObjectSet> GetObjectsInBag()
	{
		return _inBagTypelist.Select((LickableObjectType objectType) => GetLickableObjectSet(objectType)).ToList();
	}

	public LickableObjectSet GetSpecialItem()
	{
		if (_spetialItemTypeDict.Count == 0)
		{
			Debug.LogWarning("スペシャルアイテムが空になりました");
			return null;
		}
		LickableObjectType lickableObjectType = ProbabilityCalculator.DetermineFromDict(_spetialItemTypeDict);
		_spetialItemTypeDict.Remove(lickableObjectType);
		return GetLickableObjectSet(lickableObjectType);
	}
}
public class LickableObjectSet : MonoBehaviour
{
	private MeshEffectPlayer _lickEffectPlayer;

	private MeshEffectPlayer _lickCriticalEffecterPlayer;

	[SerializeField]
	private List<Renderer> _effectTargetRendererList = new List<Renderer>();

	[ShowInInspector]
	[ReadOnly]
	public LickableObjectType ObjectType { get; private set; }

	public event Action Licked = delegate
	{
	};

	public void Init()
	{
		string text = base.gameObject.name;
		if (EnumUtility.ContainsKey<CharacterType>(text))
		{
			text = LickableObjectType.Girl.ToString();
		}
		ObjectType = EnumUtility.KeyToType<LickableObjectType>(text);
		LickableObject[] componentsInChildren = base.gameObject.GetComponentsInChildren<LickableObject>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].SetLickableObjectSet(this);
		}
		_lickEffectPlayer = base.gameObject.AddComponent<MeshEffectPlayer>();
		_lickEffectPlayer.Init(_effectTargetRendererList, "Prefab/Production/MeshEffect/LickEffect", "MeshEffect_LickEffect");
		_lickCriticalEffecterPlayer = base.gameObject.AddComponent<MeshEffectPlayer>();
		_lickCriticalEffecterPlayer.Init(_effectTargetRendererList, "Prefab/Production/MeshEffect/LickCriticalEffect", "MeshEffect_LickCriticalEffect");
	}

	public void CheckCritical()
	{
		if (base.gameObject.GetComponentsInChildren<LickableObject>().All((LickableObject lickableObject) => !lickableObject.IsCritical))
		{
			Debug.LogWarning(base.gameObject.name + "にはクリティカル部分が存在しません");
		}
	}

	public void OnLick(bool isCritical)
	{
		_lickEffectPlayer.Hide();
		_lickCriticalEffecterPlayer.Hide();
		float hideDelay = 0.2f;
		if (isCritical)
		{
			_lickCriticalEffecterPlayer.Show(hideDelay);
		}
		else
		{
			_lickEffectPlayer.Show(hideDelay);
		}
		this.Licked();
	}
}
public class OnceLickableObject : LickableObject
{
	[SerializeField]
	private GameObject _beforeContents;

	[SerializeField]
	private GameObject _afterContents;

	private bool _isUsed;

	protected virtual bool _canUse => true;

	private void Awake()
	{
		if (_beforeContents != null)
		{
			_beforeContents.SetActive(value: true);
		}
		if (_afterContents != null)
		{
			_afterContents.SetActive(value: false);
		}
	}

	public bool UseIfNeeded()
	{
		if (_isUsed || !_canUse)
		{
			return false;
		}
		_isUsed = true;
		Use();
		return true;
	}

	protected virtual void Use()
	{
		if (_beforeContents != null)
		{
			_beforeContents.SetActive(value: false);
		}
		if (_afterContents != null)
		{
			_afterContents.SetActive(value: true);
		}
	}
}
public abstract class RespondGrabbingObject : RespondObject
{
	private Dictionary<VRHand, float> _targetHandDict = new Dictionary<VRHand, float>();

	protected VRHand _grabbignHand;

	private Action _forciblyReleaseAction;

	private MeshEffectPlayer _effectPlayer;

	[SerializeField]
	private List<Renderer> _effectTargetRendererList = new List<Renderer>();

	protected override EventType _eventType => EventType.Trigger;

	public bool IsGrabbing => _grabbignHand != null;

	protected override void Awake()
	{
		base.Awake();
		_effectPlayer = base.gameObject.AddComponent<MeshEffectPlayer>();
		_effectPlayer.Init(_effectTargetRendererList, "Prefab/Production/MeshEffect/RespondEffect", "MeshEffect_RespondEffect");
	}

	protected override void Update()
	{
		if (_targetHandDict.Count > 0)
		{
			foreach (KeyValuePair<VRHand, float> item in _targetHandDict.Where((KeyValuePair<VRHand, float> pair) => Time.time - pair.Value > 0.1f).ToList())
			{
				OnCollisionVRHandExit(item.Key);
			}
		}
		else if (_effectPlayer.IsPlaying)
		{
			_effectPlayer.Hide();
		}
		base.Update();
	}

	public void ForciblyRelease()
	{
		_forciblyReleaseAction?.Invoke();
		OnReleased(_grabbignHand);
	}

	public void SetTarget(VRHand hand)
	{
		_targetHandDict[hand] = Time.time;
		_effectPlayer.Show();
	}

	public void ResetTarget(VRHand hand)
	{
		if (_targetHandDict.ContainsKey(hand))
		{
			_targetHandDict.Remove(hand);
			if (_targetHandDict.Count == 0)
			{
				_effectPlayer.Hide();
			}
		}
	}

	public virtual void OnGrabbed(VRHand targetHand, Action forciblyReleaseAction)
	{
		_forciblyReleaseAction?.Invoke();
		_forciblyReleaseAction = forciblyReleaseAction;
		_grabbignHand = targetHand;
	}

	public virtual void OnReleased(VRHand targetHand)
	{
		_forciblyReleaseAction = null;
		_grabbignHand = null;
	}

	protected override void OnCollisionVRHandEnter(VRHand hand)
	{
		if (!(hand == null) && hand.SetRespondGrabbingObjectIfNeeded(this))
		{
			_targetHandDict[hand] = Time.time;
		}
	}

	protected override void OnCollisionVRHandStay(VRHand hand)
	{
		if (!(hand == null))
		{
			if (hand.CurrentTargetObject == null)
			{
				OnCollisionVRHandEnter(hand);
			}
			else if (_targetHandDict.ContainsKey(hand))
			{
				_targetHandDict[hand] = Time.time;
			}
		}
	}

	protected override void OnCollisionVRHandExit(VRHand hand)
	{
		if (!(hand == null))
		{
			hand.ReleaseGrabbingObject(this);
		}
	}
}
public abstract class RespondObject : MonoBehaviour
{
	private class HandState
	{
		private VRHand _hand;

		private VRHand _beforeHand;

		private readonly Action<VRHand> _onCollisionEnter;

		private readonly Action<VRHand> _onCollisionStay;

		private readonly Action<VRHand> _onCollisionExit;

		private bool _isBeforeCollsion;

		public HandState(Action<VRHand> onCollisionEnter, Action<VRHand> onCollisionStay, Action<VRHand> onCollisionExit)
		{
			_onCollisionEnter = onCollisionEnter;
			_onCollisionStay = onCollisionStay;
			_onCollisionExit = onCollisionExit;
		}

		public void SetHand(VRHand hand)
		{
			_hand = hand;
		}

		public void ReleaseHand()
		{
			_beforeHand = _hand;
			_hand = null;
		}

		public virtual void Update()
		{
			bool flag = _hand != null;
			if (flag)
			{
				if (_isBeforeCollsion)
				{
					_onCollisionStay(_hand);
				}
				else
				{
					_onCollisionEnter(_hand);
				}
			}
			else if (_isBeforeCollsion)
			{
				_onCollisionExit(_beforeHand);
				_beforeHand = null;
			}
			_isBeforeCollsion = flag;
		}
	}

	protected enum EventType
	{
		Collision,
		Trigger
	}

	private HandState _rightHandState;

	private HandState _leftHandState;

	private int _beforeLayer;

	protected abstract EventType _eventType { get; }

	protected virtual void Awake()
	{
		_rightHandState = new HandState(OnCollisionVRHandEnter, OnCollisionVRHandStay, OnCollisionVRHandExit);
		_leftHandState = new HandState(OnCollisionVRHandEnter, OnCollisionVRHandStay, OnCollisionVRHandExit);
	}

	protected virtual void Update()
	{
		_rightHandState.Update();
		_leftHandState.Update();
	}

	protected void IgnoreHand(float wait = 0.3f)
	{
		_beforeLayer = base.gameObject.layer;
		base.gameObject.SetLayerInChildren(10);
		if (!(wait <= 0f))
		{
			Observable.Timer(TimeSpan.FromSeconds(wait)).Subscribe(delegate
			{
				NotIgnoreHand();
			}).AddTo(this);
		}
	}

	protected void NotIgnoreHand()
	{
		base.gameObject.SetLayerInChildren(_beforeLayer);
	}

	private void SetCollisionHand(GameObject target)
	{
		VRHand componentInParent = target.GetComponentInParent<VRHand>();
		if (!(componentInParent == null))
		{
			(componentInParent.IsLeft ? _leftHandState : _rightHandState).SetHand(componentInParent);
		}
	}

	private void ReleaseCollisionHand(GameObject target)
	{
		VRHand componentInParent = target.GetComponentInParent<VRHand>();
		if (!(componentInParent == null))
		{
			(componentInParent.IsLeft ? _leftHandState : _rightHandState).ReleaseHand();
		}
	}

	protected virtual void OnCollisionEnter(Collision other)
	{
		if (_eventType == EventType.Collision)
		{
			SetCollisionHand(other.gameObject);
		}
	}

	protected virtual void OnCollisionStay(Collision other)
	{
		if (_eventType == EventType.Collision)
		{
			SetCollisionHand(other.gameObject);
		}
	}

	protected virtual void OnCollisionExit(Collision other)
	{
		if (_eventType == EventType.Collision)
		{
			ReleaseCollisionHand(other.gameObject);
		}
	}

	protected virtual void OnTriggerEnter(Collider other)
	{
		if (_eventType == EventType.Trigger)
		{
			SetCollisionHand(other.gameObject);
		}
	}

	protected virtual void OnTriggerStay(Collider other)
	{
		if (_eventType == EventType.Trigger)
		{
			SetCollisionHand(other.gameObject);
		}
	}

	protected virtual void OnTriggerExit(Collider other)
	{
		if (_eventType == EventType.Trigger)
		{
			ReleaseCollisionHand(other.gameObject);
		}
	}

	protected virtual void OnCollisionVRHandEnter(VRHand hand)
	{
	}

	protected virtual void OnCollisionVRHandStay(VRHand hand)
	{
	}

	protected virtual void OnCollisionVRHandExit(VRHand hand)
	{
	}
}
[RequireComponent(typeof(Rigidbody))]
public class TouchButtonObject : RespondObject
{
	private enum ButtonType
	{
		Normal,
		Auto,
		OnlyOn
	}

	public enum State
	{
		Off,
		Pushing,
		Stop,
		Returning,
		On
	}

	private Transform _transform;

	private Rigidbody _rigidbody;

	[SerializeField]
	private Vector3 _offPosition = Vector3.zero;

	[SerializeField]
	private Vector3 _onPosition = Vector3.zero;

	[SerializeField]
	private float _returnSpeed = 20f;

	[SerializeField]
	private ButtonType _buttonType;

	private State _currentState;

	protected override EventType _eventType => EventType.Collision;

	public State CurrentState => _currentState;

	public event Action<State> CangedState = delegate
	{
	};

	protected override void Awake()
	{
		base.Awake();
		_transform = base.transform;
		_rigidbody = GetComponent<Rigidbody>();
	}

	private void LateUpdate()
	{
		UpdatePosition();
	}

	private void FixedUpdate()
	{
		if (_currentState == State.Pushing)
		{
			Push();
			return;
		}
		_rigidbody.velocity = Vector3.zero;
		_rigidbody.angularVelocity = Vector3.zero;
		if (_currentState == State.Returning)
		{
			Return();
		}
	}

	private void Push()
	{
		UpdatePosition();
		if (!(Vector3.Distance(base.transform.localPosition, _onPosition) > 0f))
		{
			ChangeStateIfNeeded(State.On);
			if (_buttonType == ButtonType.OnlyOn)
			{
				IgnoreHand(-1f);
			}
		}
	}

	private void Return()
	{
		_transform.localPosition += (_offPosition - _transform.localPosition) * _returnSpeed * Time.deltaTime;
		if (Vector3.Distance(_transform.localPosition, _offPosition) <= 0.01f)
		{
			_transform.localPosition = _offPosition;
			ChangeStateIfNeeded(State.Off);
		}
	}

	private void UpdatePosition()
	{
		if (_currentState == State.On)
		{
			base.transform.localPosition = _onPosition;
			return;
		}
		if (_currentState == State.Off)
		{
			base.transform.localPosition = _offPosition;
			return;
		}
		Vector3 targetValue = _transform.localPosition;
		MathfUtility.Clamp(ref targetValue, ref _offPosition, ref _onPosition);
		_transform.localPosition = targetValue;
	}

	protected virtual void ChangeStateIfNeeded(State state)
	{
		if (_currentState != state)
		{
			_currentState = state;
			OnChangeState(_currentState);
			this.CangedState(_currentState);
		}
	}

	protected virtual void OnChangeState(State currentState)
	{
	}

	protected override void OnCollisionVRHandEnter(VRHand hand)
	{
		if (_currentState == State.On)
		{
			if (_returnSpeed > 0f)
			{
				ChangeStateIfNeeded(State.Returning);
			}
		}
		else
		{
			ChangeStateIfNeeded(State.Pushing);
		}
	}

	protected override void OnCollisionVRHandExit(VRHand hand)
	{
		if (_currentState != State.On || _buttonType == ButtonType.Auto)
		{
			ChangeStateIfNeeded((_returnSpeed > 0f) ? State.Returning : State.Stop);
		}
	}
}
public class SceneNavigator : SingletonMonoBehaviour<SceneNavigator>
{
	private string _nextSceneName;

	private float _fadeDuration;

	private const float FADE_BASE_DURATION = 0.5f;

	public static string CurrentSceneName => SceneManager.GetActiveScene().name;

	private CameraFader _cameraFader
	{
		get
		{
			Camera camera = Camera.main;
			if (CurrentSceneName != "Title")
			{
				camera = ((CurrentSceneName == "Main") ? SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCameraObject : SingletonMonoBehaviour<SettingCameraController>.Instance.CurrentCameraObject).GetComponentInChildren<DebugInfoDisplay>().gameObject.GetComponent<Camera>();
			}
			CameraFader cameraFader = camera.gameObject.GetComponent<CameraFader>();
			if (cameraFader == null)
			{
				cameraFader = camera.gameObject.AddComponent<CameraFader>();
			}
			return cameraFader;
		}
	}

	public bool IsChanging { get; private set; }

	public event Action ChangedScene = delegate
	{
	};

	public event Action FinishedFadeIn = delegate
	{
	};

	public void ChangeScene(string nextSceneName, float fadeDuration = 0.5f)
	{
		if (IsChanging)
		{
			Debug.LogWarning("フェード中なので、シーンが変更できません");
			return;
		}
		this.ChangedScene();
		IsChanging = true;
		_fadeDuration = fadeDuration;
		_nextSceneName = nextSceneName;
		FadeOut(_fadeDuration, isIgnoreTimeScale: true, FinishFadeOut);
	}

	public void FadeOut(float fadeDuration = 0.5f, bool isIgnoreTimeScale = true, Action callback = null)
	{
		_cameraFader.FadeOut(fadeDuration, isIgnoreTimeScale, callback);
	}

	private void FinishFadeOut()
	{
		SceneManager.LoadScene(_nextSceneName);
	}

	public void FadeIn(float fadeDuration = 0.5f, bool isIgnoreTimeScale = true, Action callback = null)
	{
		_cameraFader.FadeOut(0f);
		_cameraFader.FadeIn(fadeDuration, isIgnoreTimeScale, (Action)Delegate.Combine(new Action(FinishFadeIn), callback));
	}

	private void FinishFadeIn()
	{
		IsChanging = false;
		UnityEngine.Object.Destroy(_cameraFader);
		this.FinishedFadeIn();
	}
}
public abstract class SceneMoveSmartPhone : SmartPhone
{
	[SerializeField]
	[Required]
	private ParticleSystem _returnParticle;

	private Vector3 _initialPosition;

	private Quaternion _initialRotaion;

	private static readonly float RETUNRN_LIMIT = 2f;

	private float _returnLimit = RETUNRN_LIMIT;

	private bool _isActivated;

	protected Sequence _textSequence;

	private AudioPlayer _returnSEPlayer;

	private AudioPlayer _gaugeSEPlayer;

	protected override bool IsEnabled => !_isActivated;

	protected override void Awake()
	{
		base.Awake();
		_transform = base.transform;
		_initialPosition = _transform.position;
		_initialRotaion = _transform.rotation;
		CancelTextTween();
	}

	protected override void Start()
	{
		base.Start();
		_returnSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_ReturnSmartPhone");
		_gaugeSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_Gauge");
	}

	protected override void Grabbing()
	{
		base.Grabbing();
		_returnLimit = RETUNRN_LIMIT;
	}

	protected override void OnGrab()
	{
		base.OnGrab();
		CancelTextTween();
		_transformSequence.OnComplete(PlayTextTween);
	}

	protected override void Releasing()
	{
		base.Releasing();
		if (!(_returnLimit <= 0f))
		{
			_returnLimit -= Time.deltaTime;
			if (_returnLimit <= 0f)
			{
				ReturnTransformIfNeeded();
			}
		}
	}

	protected override void OnRelease()
	{
		base.OnRelease();
		_gaugeSEPlayer.Stop();
		CancelTextTween();
	}

	private void ReturnTransformIfNeeded()
	{
		_returnLimit = RETUNRN_LIMIT;
		if (!(Vector3.Distance(_transform.position, _initialPosition) <= 0.001f))
		{
			ReturnTransform();
		}
	}

	protected virtual void ReturnTransform()
	{
		_transform.position = _initialPosition;
		_transform.rotation = _initialRotaion;
		_rigidbody.velocity = Vector3.zero;
		_rigidbody.angularVelocity = Vector3.zero;
		_returnParticle.Play();
		_returnSEPlayer.Play();
	}

	private void PlayTextTween()
	{
		_gaugeSEPlayer.Play();
		float duration = 2f;
		float delay = 0.5f;
		_textSequence = DOTween.Sequence().Append(DOTween.To(() => 0f, base.FadeText, 1f, duration));
		PlayTextTween(duration, delay);
	}

	protected abstract void PlayTextTween(float duration, float delay);

	private void CancelTextTween()
	{
		if (_textSequence != null)
		{
			_textSequence.Kill();
			_textSequence = null;
		}
		FadeText(0f);
	}

	protected void Activate()
	{
		_isActivated = true;
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_ReturnTime");
		ChangeScene();
	}

	protected abstract void ChangeScene();
}
public abstract class SmartPhone : GrabableObject
{
	[SerializeField]
	[Required]
	private SuperTextMesh _text;

	private string _baseText;

	private Font _defaultFont;

	private bool _wasGrabbing;

	protected Sequence _transformSequence;

	private AudioPlayer _showSEPlayer;

	private AudioPlayer _hideSEPlayer;

	protected abstract string _textKey { get; }

	protected virtual bool IsEnabled => true;

	protected virtual void Start()
	{
		_showSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_ShowSmartPhoneText");
		_hideSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_HideSmartPhoneText");
		_defaultFont = _text.font;
		UserDataAccessorManager.SettingDataAccessor.CurrentLanguageObservable.Subscribe(Localize).AddTo(this);
	}

	protected override void Update()
	{
		base.Update();
		if (IsEnabled)
		{
			if (base.IsGrabbing)
			{
				Grabbing();
			}
			else
			{
				Releasing();
			}
			_wasGrabbing = base.IsGrabbing;
		}
	}

	private void Localize(AvailableLanguage availableLanguage)
	{
		FontMasterData.Entity.UpdateFont(_text, _defaultFont);
		_baseText = LocalizedUtility.Get(_textKey);
		UpdateText();
	}

	private void UpdateText()
	{
		_text.SetTextAndRebuild(base.IsGrabbing ? _baseText : ("<j=Lightning>" + _baseText));
	}

	protected virtual void Grabbing()
	{
		if (!_wasGrabbing)
		{
			OnGrab();
		}
	}

	protected virtual void OnGrab()
	{
		_showSEPlayer.Play();
		PlayTransformTween(-200f, 8f);
		UpdateText();
	}

	protected virtual void Releasing()
	{
		if (_wasGrabbing)
		{
			OnRelease();
		}
	}

	protected virtual void OnRelease()
	{
		PlayHideTransformTween();
		UpdateText();
	}

	private void PlayHideTransformTween()
	{
		_hideSEPlayer.Play();
		PlayTransformTween(0f, 1f);
	}

	private void PlayTransformTween(float z, float scale)
	{
		_transformSequence?.Kill();
		float duration = 0.3f;
		_transformSequence = DOTween.Sequence().Append(_text.transform.DOLocalMoveZ(z, duration).SetEase(Ease.InOutQuart)).Join(_text.transform.DOScale(Vector3.one * scale, duration).SetEase(Ease.InOutQuart));
	}

	protected void FadeText(float timeRate)
	{
		float num = 1f - timeRate;
		_text.SetColor(new Color(num, num, num, 1f));
	}
}
public class VRActiveChanger : MonoBehaviour
{
	[SerializeField]
	private List<GameObject> _targetList = new List<GameObject>();

	[SerializeField]
	private List<GameObject> _androidTargetList = new List<GameObject>();

	private void Awake()
	{
		foreach (GameObject target in _targetList)
		{
			target.SetActive(value: false);
		}
		foreach (GameObject androidTarget in _androidTargetList)
		{
			androidTarget.SetActive(value: true);
		}
	}
}
public class VRHand : SimpleAnimationMonoBehaviour
{
	public enum AnimationType
	{
		Natural,
		GrabStickUp
	}

	private Transform _transform;

	private AnimationType _currentAnimationType;

	private Vector3 _beforePosition;

	private RespondGrabbingObject _respondGrabbingObject;

	private RespondGrabbingObject _currentGrabbingObject;

	public bool IsGrabbingAnimation => _currentAnimationType == AnimationType.GrabStickUp;

	public bool IsLeft { get; private set; }

	public RespondGrabbingObject CurrentTargetObject => _respondGrabbingObject;

	public RespondGrabbingObject CurrentGrabbingObject => _currentGrabbingObject;

	public event Action<AnimationType> ChangedAnimationType = delegate
	{
	};

	public event Action<Vector3> Moved = delegate
	{
	};

	protected override void Start()
	{
		base.Start();
		ChangeAnimation(AnimationType.Natural, isForce: true);
		_transform = base.transform;
		_beforePosition = _transform.position;
	}

	protected virtual void FixedUpdate()
	{
		Vector3 position = _transform.position;
		this.Moved(position - _beforePosition);
		_beforePosition = position;
	}

	public void ChangeAnimation(AnimationType animationType, bool isForce = false)
	{
		if (_currentAnimationType == animationType && !isForce)
		{
			return;
		}
		_currentAnimationType = animationType;
		this.ChangedAnimationType(_currentAnimationType);
		CrossFade(animationType.ToString());
		if (IsGrabbingAnimation && _respondGrabbingObject != null)
		{
			_respondGrabbingObject.ResetTarget(this);
			_currentGrabbingObject = _respondGrabbingObject;
			_respondGrabbingObject = null;
			_currentGrabbingObject.OnGrabbed(this, delegate
			{
				_currentGrabbingObject = null;
			});
			Vibrate(0.2f);
		}
		if (!IsGrabbingAnimation && _currentGrabbingObject != null)
		{
			_currentGrabbingObject.OnReleased(this);
			_currentGrabbingObject = null;
		}
	}

	public void Invert()
	{
		IsLeft = true;
		base.transform.GetChild(0).GetChild(0).SetLocalScaleZ(-1f * base.transform.localScale.z);
	}

	public bool SetRespondGrabbingObjectIfNeeded(RespondGrabbingObject respondGrabbingObject)
	{
		if (IsGrabbingAnimation || _respondGrabbingObject == respondGrabbingObject)
		{
			return false;
		}
		if (_respondGrabbingObject != null)
		{
			ReleaseGrabbingObject(_respondGrabbingObject);
		}
		_respondGrabbingObject = respondGrabbingObject;
		_respondGrabbingObject.SetTarget(this);
		Vibrate();
		return true;
	}

	public void ReleaseGrabbingObject(RespondGrabbingObject respondGrabbingObject)
	{
		respondGrabbingObject.ResetTarget(this);
		if (_respondGrabbingObject == respondGrabbingObject)
		{
			_respondGrabbingObject = null;
		}
	}

	public void Vibrate(float duration = 0.1f, float frequency = 1E-05f)
	{
		SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(IsLeft, duration, frequency);
	}
}
public class VRHandController : SingletonMonoBehaviour<VRHandController>
{
	[SerializeField]
	[Required]
	private VRHand _nonVRHand;

	[SerializeField]
	[Required]
	private VRHand _handLeft;

	[SerializeField]
	[Required]
	private VRHand _handRight;

	[SerializeField]
	[Required]
	private VRHand _ovrHandLeft;

	[SerializeField]
	[Required]
	private VRHand _ovrHandRight;

	protected override void Init()
	{
		_ovrHandLeft.Invert();
		_handLeft.Invert();
		InputEventMediator.Mediate(null, OnInputKey);
	}

	private void Start()
	{
		_ovrHandLeft.transform.localPosition = new Vector3(-0.02f, -0.03f, -0.05f);
		_ovrHandLeft.transform.localRotation = Quaternion.Euler(0f, 18.33f, 77.8f);
		_ovrHandRight.transform.localPosition = new Vector3(0.02f, -0.03f, -0.05f);
		_ovrHandRight.transform.localRotation = Quaternion.Euler(0f, -18.33f, -77.8f);
	}

	private void OnInputKey(InputKeyType keyType, InputStateType stateType)
	{
		if (stateType != InputStateType.None)
		{
			switch (keyType)
			{
			case InputKeyType.TriggerRight:
				ChangeAnimation(_ovrHandRight, stateType);
				break;
			case InputKeyType.TriggerLeft:
				ChangeAnimation(_ovrHandLeft, stateType);
				break;
			}
		}
	}

	private void ChangeAnimation(VRHand vrHand, InputStateType stateType)
	{
		if (stateType == InputStateType.Down || stateType == InputStateType.Pressing)
		{
			vrHand.ChangeAnimation(VRHand.AnimationType.GrabStickUp);
		}
		else
		{
			vrHand.ChangeAnimation(VRHand.AnimationType.Natural);
		}
	}

	public RespondGrabbingObject GetGrabbingLeftObject()
	{
		return _ovrHandLeft.CurrentGrabbingObject;
	}

	public RespondGrabbingObject GetGrabbingRightObject()
	{
		return _ovrHandRight.CurrentGrabbingObject;
	}

	public bool IsGrabbing(LickableObjectType lickableObjectType)
	{
		if (!IsGrabbing(GetGrabbingLeftObject(), lickableObjectType))
		{
			return IsGrabbing(GetGrabbingRightObject(), lickableObjectType);
		}
		return true;
	}

	private bool IsGrabbing(RespondGrabbingObject grabbingObject, LickableObjectType lickableObjectType)
	{
		if (grabbingObject == null)
		{
			return false;
		}
		LickableObjectSet component = grabbingObject.gameObject.GetComponent<LickableObjectSet>();
		if (component != null)
		{
			return component.ObjectType == lickableObjectType;
		}
		return false;
	}
}
public class VRHandTriggerTarget : MonoBehaviour
{
	public event Action<VRHand> Triggered = delegate
	{
	};

	private void OnTriggerEnter(Collider other)
	{
		VRHand componentInParent = other.gameObject.GetComponentInParent<VRHand>();
		if (componentInParent != null)
		{
			this.Triggered(componentInParent);
		}
	}
}
public class FlyingComboEffect : ReuseMonoBehaviour
{
	[SerializeField]
	[HideInInspector]
	private Transform _transform;

	[SerializeField]
	[HideInInspector]
	private Catfish _catfish;

	[SerializeField]
	[HideInInspector]
	private ComboText _comboText;

	[SerializeField]
	[Required]
	private Transform _flyingEffect;

	[SerializeField]
	[Required]
	private ParticleSystem _arriveEffect;

	[SerializeField]
	private AnimationCurve _beginComboTextCurve;

	[SerializeField]
	private AnimationCurve _beginEffectCurve;

	[SerializeField]
	[HideInInspector]
	private AudioPlayer _comboElectricalSEPlayer;

	private float _specialPoint;

	private Vector3 _startPosition;

	private float _flyTime;

	private readonly float FLY_TIME = 0.9f;

	private bool _isMoving;

	[SerializeField]
	private AnimationCurve _moveCurve;

	public override void InitOnFirstInstantiate()
	{
		_transform = base.transform;
		_catfish = SingletonMonoBehaviour<Catfish>.Instance;
		_comboText = base.transform.CreateChildFromOriginal<ComboText>(Resources.Load<Transform>("Prefab/ComboText"));
		_arriveEffect.gameObject.SetActive(value: false);
		_comboElectricalSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_ComboElectrical");
	}

	public void Play(ComboText comboText, float scaleRate)
	{
		_transform.position = comboText.TweenParent.position;
		_startPosition = _transform.position;
		_specialPoint = 100f * (float)comboText.Comb * scaleRate;
		_comboText.gameObject.SetActive(value: true);
		_comboText.Copy(comboText);
		_flyingEffect.gameObject.SetActive(value: true);
		_flyingEffect.localScale = Vector3.zero;
		float duration = 0.4f;
		DOTween.Sequence().Append(_comboText.transform.DOScale(0f, duration).SetEase(_beginComboTextCurve)).Join(_flyingEffect.transform.DOScale(scaleRate, duration).SetEase(_beginEffectCurve))
			.OnComplete(BeginMove)
			.Play();
		_comboElectricalSEPlayer.Play();
	}

	private void BeginMove()
	{
		_flyTime = 0f;
		_isMoving = true;
	}

	private void Update()
	{
		if (_isMoving)
		{
			_flyTime += Time.deltaTime;
			float num = Mathf.Min(_flyTime / FLY_TIME, 1f);
			float num2 = _moveCurve.Evaluate(num);
			_transform.position = _startPosition * (1f - num2) + _catfish.transform.position * num2;
			if (num >= 1f)
			{
				FinishMove();
			}
		}
	}

	private void FinishMove()
	{
		_isMoving = false;
		StartCoroutine(this.DelayMethod(0.2f, delegate
		{
			_flyingEffect.gameObject.SetActive(value: false);
		}));
		_arriveEffect.gameObject.SetActive(value: true);
		_arriveEffect.transform.position = _catfish.transform.position;
		_arriveEffect.transform.localScale = _flyingEffect.localScale;
		_arriveEffect.Play();
		StartCoroutine(this.DelayMethod(2f, delegate
		{
			_arriveEffect.gameObject.SetActive(value: false);
			Release();
		}));
		_catfish.AddSpecialPoint(_specialPoint);
	}
}
public class HeartBeatPlayer : MonoBehaviour
{
	private GameManager _gameManager;

	private AudioPlayer _audioPlayer;

	private static readonly float VOLUME_MIN = 1f;

	private static readonly float VOLUME_MAX = 1f;

	private float _span = 1f;

	private static readonly float SPAN_MIN = 0.4f;

	private static readonly float SPAN_MAX = 1f;

	private GirlDistanceFinder _distanceFinder;

	private void Start()
	{
		_gameManager = SingletonMonoBehaviour<GameManager>.Instance;
		_distanceFinder = SingletonMonoBehaviour<GirlDistanceFinder>.Instance;
		_audioPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_HeartBeat");
		_audioPlayer.Disable3DSound();
	}

	private void LateUpdate()
	{
		if (_gameManager.CurrentState != GameManager.State.GameOver)
		{
			float distanceRate = _distanceFinder.DistanceRate;
			float volumeRate = distanceRate * VOLUME_MAX + (1f - distanceRate) * VOLUME_MIN;
			_audioPlayer.ChangeVolumeRate(volumeRate);
			_span -= Time.deltaTime;
			if (!(_span > 0f))
			{
				_audioPlayer.Play(volumeRate);
				_span = distanceRate * SPAN_MIN + (1f - distanceRate) * SPAN_MAX;
			}
		}
	}
}
public class Catfish : SingletonMonoBehaviour<Catfish>
{
	private Transform _transform;

	private Transform _girl;

	private GirlDistanceFinder _distanceFinder;

	[SerializeField]
	[Required]
	private Transform _scoreTarget;

	[SerializeField]
	private List<CatfishParts> _partsList = new List<CatfishParts>();

	[SerializeField]
	private AnimationCurve _partsAnimationCurve;

	[SerializeField]
	private float _specialPoint;

	private int _dischargeCount;

	[SerializeField]
	private List<ParticleSystem> _electrificationParticleList = new List<ParticleSystem>();

	[SerializeField]
	[Required]
	private ParticleSystem _dischargeParticleSystem;

	private AudioPlayer _thunderSEPlayer;

	private AudioPlayer _electrificationSEPlayer;

	private bool _isDead;

	public Transform ScoreTarget => _scoreTarget;

	public float SpecialPoint => _specialPoint;

	public bool IsDead => _isDead;

	public event Action Deaded = delegate
	{
	};

	private void Start()
	{
		_transform = base.transform;
		_girl = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform;
		_distanceFinder = SingletonMonoBehaviour<GirlDistanceFinder>.Instance;
		foreach (CatfishParts parts in _partsList)
		{
			parts.Init(_partsAnimationCurve);
		}
		_thunderSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_dischargeParticleSystem.gameObject, "Audio/SE/SE_Thunder");
		_electrificationSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_Electrification");
		_electrificationSEPlayer.ChangeDistance(0.2f, 2f);
		_electrificationSEPlayer.Play(0f, 0f, 1f, isLoop: true);
		base.gameObject.GetComponent<GrabableObject>().Grabbed += Dead;
		base.gameObject.GetComponent<LickableObjectSet>().Licked += Dead;
		SetSpecialPoint(0f);
	}

	private void LateUpdate()
	{
		if (_isDead)
		{
			return;
		}
		Vector3 forward = _girl.position - _transform.position;
		_transform.rotation = Quaternion.Slerp(_transform.rotation, Quaternion.LookRotation(forward), 0.1f);
		float deltaTime = Time.deltaTime * (1f + 5f * _distanceFinder.DistanceRate);
		foreach (CatfishParts parts in _partsList)
		{
			parts.Update(deltaTime);
		}
	}

	public void AddSpecialPoint(float specialPoint)
	{
		SetSpecialPoint(_specialPoint + specialPoint);
	}

	private void SetSpecialPoint(float specialPoint)
	{
		_specialPoint = specialPoint;
		float nextDischargeBorder = GetNextDischargeBorder();
		if (_specialPoint >= nextDischargeBorder)
		{
			Discharge();
			SingletonMonoBehaviour<Microwave>.Instance.Activate();
			_specialPoint -= nextDischargeBorder;
		}
		float num = _specialPoint / nextDischargeBorder;
		Debug.Log($"スペシャルポイント変化, 現在{_specialPoint}, 割合{num}");
		SetElectrificationParticle(num);
	}

	public float GetNextDischargeBorder()
	{
		float num = 0.4f + 0.2f * (float)_dischargeCount;
		return 47250f * num;
	}

	private void Discharge()
	{
		_dischargeCount++;
		_dischargeParticleSystem.Play();
		_thunderSEPlayer.Play();
	}

	private void SetElectrificationParticle(float emissionRate)
	{
		foreach (ParticleSystem electrificationParticle in _electrificationParticleList)
		{
			ParticleSystem.EmissionModule emission = electrificationParticle.emission;
			emission.rateOverTime = emissionRate * 300f;
		}
		_electrificationSEPlayer.ChangeVolumeRate(emissionRate);
	}

	private void Dead()
	{
		if (!_isDead)
		{
			_isDead = true;
			GetComponent<Rigidbody>().useGravity = true;
			GetComponent<Rigidbody>().isKinematic = false;
			Discharge();
			SetElectrificationParticle(0f);
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.KillCatFish);
			this.Deaded();
		}
	}
}
[Serializable]
public class CatfishParts
{
	[SerializeField]
	[Required]
	private Transform _transform;

	[SerializeField]
	private Vector3 _rotationMin;

	[SerializeField]
	private Vector3 _rotationMax;

	[SerializeField]
	private float _rotationTime = 1f;

	private float _currentTime;

	private AnimationCurve _animationCurve;

	[SerializeField]
	private float _noiseRate = 0.2f;

	[SerializeField]
	private float _noiseSpeed = 1f;

	private float _noiseTime;

	private PerlinNoiseGenerator _noiseGenerator;

	public void Init(AnimationCurve animationCurve)
	{
		_animationCurve = animationCurve;
		_noiseGenerator = new PerlinNoiseGenerator(0f, 1f, _noiseSpeed);
	}

	public void Update(float deltaTime)
	{
		if (!(_rotationTime <= 0f))
		{
			_currentTime += deltaTime;
			while (_currentTime > _rotationTime)
			{
				_currentTime -= _rotationTime;
			}
			_noiseTime += deltaTime;
			float timeRate = _animationCurve.Evaluate(_currentTime / _rotationTime);
			float timeRate2 = _animationCurve.Evaluate(_noiseGenerator.GetNoiseARateOfChange(_noiseTime, _noiseSpeed));
			_transform.localRotation = Quaternion.Euler(GetRotation(timeRate) * (1f - _noiseRate) + GetRotation(timeRate2) * _noiseRate);
		}
	}

	private Vector3 GetRotation(float timeRate)
	{
		return _rotationMax * timeRate + (1f - timeRate) * _rotationMin;
	}
}
public class Chalk : MonoBehaviour
{
	[SerializeField]
	private Color _color;

	[SerializeField]
	private bool _isRainbow;

	public Color Color => _color;

	public bool IsRainbow => _isRainbow;
}
public class ChalkTarget : MonoBehaviour
{
	private enum PositionTypes
	{
		X,
		Y,
		Z
	}

	[SerializeField]
	private PositionTypes _fixPositionTypes;

	[SerializeField]
	private float _fixPosition;

	[SerializeField]
	private bool _isFixLocal;

	[SerializeField]
	private Vector3 _lineRotation;

	private LineRenderer _linePrefab;

	private LineRenderer _lineRainbowPrefab;

	private LineRenderer _currentLine;

	private int _lineCount;

	private void Awake()
	{
		_linePrefab = Resources.Load<LineRenderer>("Prefab/ChalkLine");
		_lineRainbowPrefab = Resources.Load<LineRenderer>("Prefab/ChalkLineRainbow");
		if (_isFixLocal)
		{
			switch (_fixPositionTypes)
			{
			case PositionTypes.X:
				_fixPosition += base.transform.position.x;
				break;
			case PositionTypes.Y:
				_fixPosition += base.transform.position.y;
				break;
			case PositionTypes.Z:
				_fixPosition += base.transform.position.z;
				break;
			}
		}
	}

	private void Draw(Collision other)
	{
		Chalk component = other.gameObject.GetComponent<Chalk>();
		if (component == null)
		{
			return;
		}
		if (_currentLine == null)
		{
			_currentLine = base.transform.CreateChildFromOriginal<LineRenderer>(component.IsRainbow ? _lineRainbowPrefab.transform : _linePrefab.transform);
			_currentLine.transform.ResetInLocal();
			_currentLine.transform.rotation = Quaternion.Euler(_lineRotation);
			_currentLine.positionCount = 0;
			if (!component.IsRainbow)
			{
				_currentLine.startColor = component.Color;
				_currentLine.endColor = component.Color;
			}
			else
			{
				SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.ChalkRainbow);
			}
			_currentLine.sortingOrder = _lineCount;
			_lineCount++;
		}
		Vector3 point = other.contacts[0].point;
		switch (_fixPositionTypes)
		{
		case PositionTypes.X:
			point.x = _fixPosition;
			break;
		case PositionTypes.Y:
			point.y = _fixPosition;
			break;
		case PositionTypes.Z:
			point.z = _fixPosition;
			break;
		}
		_currentLine.positionCount++;
		_currentLine.SetPosition(_currentLine.positionCount - 1, point);
	}

	private void OnCollisionEnter(Collision other)
	{
		Draw(other);
	}

	private void OnCollisionStay(Collision other)
	{
		Draw(other);
	}

	private void OnCollisionExit(Collision other)
	{
		if (other.gameObject.CompareTag("Chalk"))
		{
			_currentLine = null;
		}
	}
}
public class ClassroomClock : SingletonMonoBehaviour<ClassroomClock>
{
	[SerializeField]
	[Required]
	private Transform _shortHand;

	[SerializeField]
	[Required]
	private Transform _longHand;

	private readonly float _startTime = 300f;

	private readonly float _endTime = 420f;

	protected override void Init()
	{
		base.Init();
		UpdateHand(_startTime);
	}

	private void LateUpdate()
	{
		float elapsedTimeRate = SingletonMonoBehaviour<GameManager>.Instance.ElapsedTimeRate;
		UpdateHand(_startTime * (1f - elapsedTimeRate) + _endTime * elapsedTimeRate);
	}

	private void UpdateHand(float currentTime)
	{
		int num = Mathf.FloorToInt(currentTime / 60f);
		float num2 = (currentTime - (float)(num * 60)) / 60f;
		_shortHand.SetEulerAngleZ(360f * (num2 + (float)num) / 12f);
		_longHand.SetEulerAngleZ(360f * num2);
	}
}
public class ClassroomSpeaker : SingletonMonoBehaviour<ClassroomSpeaker>
{
	private AudioPlayer _beforeAudioPlayer;

	private AudioPlayer _playingAudioPlayer;

	private AudioPlayer _currentAudioPlayer;

	protected override void Init()
	{
		base.Init();
		_beforeAudioPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/BGM/BGM_Before");
		_playingAudioPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, BGMUtility.GetPlayingBGMPath(UserDataAccessorManager.SettingDataAccessor.BGMNo));
		_beforeAudioPlayer.ChangeDistance(0.2f, 16f);
		_playingAudioPlayer.ChangeDistance(0.2f, 16f);
	}

	public void PlayBeforeBGM()
	{
		_playingAudioPlayer.Stop();
		_beforeAudioPlayer.Play(1f, 0f, 1f, isLoop: true);
		_currentAudioPlayer = _beforeAudioPlayer;
	}

	public void PlayPlayingBGM()
	{
		_beforeAudioPlayer.Stop();
		_playingAudioPlayer.Play(1f, 0f, 1f, isLoop: true);
		_currentAudioPlayer = _playingAudioPlayer;
	}

	public void PlayChime()
	{
		Stop();
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Chime", base.gameObject, is3DSound: true);
		SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstTimeUp);
	}

	public void Stop()
	{
		if (_currentAudioPlayer != null)
		{
			_currentAudioPlayer.Stop();
		}
	}

	public void Pause()
	{
		if (_currentAudioPlayer != null && _currentAudioPlayer.CurrentState == AudioPlayer.State.Playing)
		{
			_currentAudioPlayer.Pause();
		}
	}

	public void UnPause()
	{
		if (_currentAudioPlayer != null && _currentAudioPlayer.CurrentState == AudioPlayer.State.Pause)
		{
			_currentAudioPlayer.UnPause();
		}
	}

	public void Fade(float duration, float from, float to, Action callback = null)
	{
		if (_currentAudioPlayer == null)
		{
			Debug.LogWarning("BGMが再生されていないのでフェードしようとしました");
		}
		else
		{
			_currentAudioPlayer.Fade(duration, from, to, callback);
		}
	}

	public void CancelFade()
	{
		if (_currentAudioPlayer == null)
		{
			Debug.LogWarning("BGMが再生されていないのでフェードをキャンセルしようとしました");
		}
		else
		{
			_currentAudioPlayer.CancelFade();
		}
	}
}
public class LockerDoor : SingletonDoor<LockerDoor>
{
	[SerializeField]
	private Vector3 _openRotation;

	[SerializeField]
	private Vector3 _closeRotation;

	protected override string _openSEPath => "Audio/SE/SE_OpenLocker";

	protected override string _closeSEPath => "Audio/SE/SE_CloseLocker";

	protected override void Init()
	{
		base.Init();
		base.transform.localRotation = Quaternion.Euler(_closeRotation);
	}

	protected override void PlayOpenTween()
	{
		_rigidbody.DORotate(_openRotation, _openDuration).SetEase(_openCurve);
	}

	protected override void PlayCloseTween()
	{
		_rigidbody.DORotate(_closeRotation, _closeDuration).SetEase(_closeCurve);
		_closeSEPlayer.Play(1f, _closeDuration);
	}
}
public class ShelfDoor : SingletonDoor<ShelfDoor>
{
	[SerializeField]
	private Vector3 _openPosition;

	[SerializeField]
	private Vector3 _closePosition;

	protected override string _openSEPath => "Audio/SE/SE_OpenShelfDoor";

	protected override string _closeSEPath => "Audio/SE/SE_CloseShelfDoor";

	protected override void Init()
	{
		base.Init();
		base.transform.localPosition = _closePosition;
	}

	protected override void PlayOpenTween()
	{
		_rigidbody.DOMove(_openPosition, _openDuration).SetEase(_openCurve);
	}

	protected override void PlayCloseTween()
	{
		_closeSEPlayer.Play();
		_rigidbody.DOMove(_closePosition, _closeDuration).SetEase(_closeCurve);
	}
}
public abstract class SingletonDoor<T> : SingletonMonoBehaviour<T> where T : MonoBehaviourWithInit
{
	protected Rigidbody _rigidbody;

	[SerializeField]
	protected float _openDuration = 0.3f;

	[SerializeField]
	protected float _closeDuration = 0.3f;

	[SerializeField]
	protected AnimationCurve _openCurve;

	[SerializeField]
	protected AnimationCurve _closeCurve;

	protected AudioPlayer _openSEPlayer;

	protected AudioPlayer _closeSEPlayer;

	protected abstract string _openSEPath { get; }

	protected abstract string _closeSEPath { get; }

	protected override void Init()
	{
		base.Init();
		_rigidbody = base.gameObject.GetComponent<Rigidbody>();
	}

	private void Start()
	{
		_openSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, _openSEPath);
		_closeSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, _closeSEPath);
		_closeSEPlayer.ChangeDistance(0.2f, 12f);
		_openSEPlayer.ChangeDistance(0.2f, 12f);
	}

	[Button("Open")]
	public void Open()
	{
		_openSEPlayer.Play();
		PlayOpenTween();
		StartCoroutine(this.DelayMethod(_openDuration + 2f, Close));
	}

	protected abstract void PlayOpenTween();

	private void Close()
	{
		PlayCloseTween();
	}

	protected abstract void PlayCloseTween();
}
public class EyeShadowPaletteMirror : SingletonMonoBehaviour<EyeShadowPaletteMirror>
{
	private Camera _targetCamera;

	public bool IsRendered { get; private set; }

	private void Start()
	{
		if (SceneNavigator.CurrentSceneName == "Main")
		{
			_targetCamera = SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCamera;
		}
		else
		{
			_targetCamera = SingletonMonoBehaviour<SettingCameraController>.Instance.CurrentCamera;
		}
	}

	private void Update()
	{
		IsRendered = false;
	}

	private void OnWillRenderObject()
	{
		if (Camera.current == _targetCamera)
		{
			IsRendered = true;
		}
	}
}
public class GirlSchoolBag : GrabableObject
{
	private float _spawnLimit;

	private List<LickableObjectSet> _lickableObjectSetList;

	private AudioPlayer _spawnSEPlayer;

	private void Start()
	{
		_spawnSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_SpawnBagItem");
		_lickableObjectSetList = SingletonMonoBehaviour<LickableObjectManager>.Instance.GetObjectsInBag();
		LickableObjectSet lickableObjectSet = _lickableObjectSetList[0];
		lickableObjectSet.transform.SetParent(base.transform);
		lickableObjectSet.GetComponent<Rigidbody>().isKinematic = true;
		Collider[] componentsInChildren = lickableObjectSet.GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
	}

	protected override void Update()
	{
		base.Update();
		if (_lickableObjectSetList.Count <= 0)
		{
			return;
		}
		Vector3 up = base.transform.up;
		if (up.y > -0.7f)
		{
			return;
		}
		_spawnLimit -= Time.deltaTime;
		if (_spawnLimit > 0f)
		{
			return;
		}
		_spawnLimit = 1f;
		_spawnSEPlayer.Play();
		LickableObjectSet andRemove = _lickableObjectSetList.GetAndRemove(0);
		andRemove.gameObject.SetActive(value: true);
		andRemove.transform.SetParent(SingletonMonoBehaviour<GameManager>.Instance.transform.parent);
		if (andRemove.ObjectType == LickableObjectType.GirlSmartPhone)
		{
			andRemove.GetComponent<Rigidbody>().isKinematic = false;
		}
		else
		{
			andRemove.transform.position = base.transform.position + up * 0.3f;
		}
		andRemove.GetComponent<Rigidbody>().velocity = base.transform.up * 0.3f;
		Collider[] colliders = andRemove.GetComponentsInChildren<Collider>();
		Collider[] array = colliders;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
		StartCoroutine(this.DelayMethod(0.3f, delegate
		{
			Collider[] array2 = colliders;
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j].enabled = true;
			}
		}));
		if (_lickableObjectSetList.Count == 0)
		{
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.BagContents);
		}
	}
}
public class GrabableAchievementObject : MonoBehaviour
{
	private void Start()
	{
		GetComponent<GrabableObject>().Grabbed += OnGrabbed;
	}

	private void OnGrabbed()
	{
		GetComponent<GrabableObject>().Grabbed -= OnGrabbed;
		switch (GetComponent<LickableObjectSet>().ObjectType)
		{
		case LickableObjectType.KanCrow:
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.KanCrow);
			break;
		case LickableObjectType.HiddenCamera:
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.HiddenCamera);
			break;
		case LickableObjectType.Choker:
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.ChokerMirror);
			break;
		}
	}
}
public class HintObject : SingletonMonoBehaviour<HintObject>
{
	[SerializeField]
	[Required]
	private GrabableObject _entity;

	[SerializeField]
	[Required]
	private SuperTextMesh _titleText;

	[SerializeField]
	[Required]
	private SuperTextMesh _infoText;

	[SerializeField]
	[Required]
	private SuperTextMesh _noText;

	private AudioPlayer _spawnSEPlayer;

	private AudioPlayer _curseSEPlayer;

	[SerializeField]
	private AnimationCurve _scaleCurve;

	private bool _shouldIncreaseHintNo = true;

	[SerializeField]
	[Required]
	private GameObject _markerEffect;

	private bool _isEnabledEffect = true;

	[SerializeField]
	private AnimationCurve _markerTweenCurve;

	private void Start()
	{
		_spawnSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_entity.gameObject, "Audio/SE/SE_SpawnSpecialItem");
		_curseSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_entity.gameObject, "Audio/SE/SE_Curse");
		FontMasterData.Entity.UpdateFont(_titleText);
		FontMasterData.Entity.UpdateFont(_infoText);
		FontMasterData.Entity.UpdateFont(_noText);
		_titleText.SetTextAndRebuild(LocalizedUtility.Get("HintTitle"));
		_entity.gameObject.SetActive(value: true);
		StartCoroutine(this.DelayMethod(0.01f, delegate
		{
			_entity.gameObject.SetActive(value: false);
		}));
		_entity.Grabbed += OnGrabbed;
		_shouldIncreaseHintNo = true;
	}

	[Button("出現")]
	public void Appear()
	{
		_entity.gameObject.SetActive(value: true);
		_entity.transform.position = SingletonMonoBehaviour<Catfish>.Instance.transform.position;
		_entity.transform.localRotation = Quaternion.identity;
		Rigidbody component = _entity.GetComponent<Rigidbody>();
		if (SingletonMonoBehaviour<Catfish>.Instance.IsDead)
		{
			_curseSEPlayer.Play();
			SetDeadCatFishText();
			Transform transform = SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCameraObject.transform;
			_entity.transform.LookAt(transform);
			Vector3 normalized = (transform.position - _entity.transform.position).normalized;
			normalized.y += 2f;
			component.velocity = normalized * 2.5f;
		}
		else
		{
			_spawnSEPlayer.Play();
			int hintNo = UserDataAccessorManager.PlayRecordDataAccessor.GetHintNo();
			_infoText.SetTextAndRebuild(LocalizedUtility.Get($"HintInfo{hintNo}"));
			_noText.SetTextAndRebuild($"{hintNo}");
			SingletonMonoBehaviour<Catfish>.Instance.Deaded += SetDeadCatFishText;
			component.velocity = new Vector3(-1.5f, 6f, 0.25f);
		}
		component.angularVelocity = new Vector3(0f, 0f, 4f);
		BoxCollider boxCollider = _entity.GetComponent<BoxCollider>();
		boxCollider.enabled = false;
		_entity.transform.localScale = Vector3.one * 0.2f;
		_entity.transform.DOScale(Vector3.one, 0.3f).SetEase(_scaleCurve).OnComplete(delegate
		{
			boxCollider.enabled = true;
		});
	}

	private void SetDeadCatFishText()
	{
		_isEnabledEffect = false;
		_markerEffect.SetActive(value: false);
		_curseSEPlayer.Play();
		_shouldIncreaseHintNo = false;
		string text = LocalizedUtility.Get("HintKillCatFish");
		string text2 = "";
		AvailableLanguage currentLanguage = UserDataAccessorManager.SettingDataAccessor.CurrentLanguage;
		int num = 12;
		switch (currentLanguage)
		{
		case AvailableLanguage.English:
		case AvailableLanguage.ChineseSimplified:
		case AvailableLanguage.ChineseTraditional:
			num = 13;
			break;
		case AvailableLanguage.Brazilian:
			num = 11;
			break;
		case AvailableLanguage.German:
		case AvailableLanguage.French:
			num = 10;
			break;
		case AvailableLanguage.Korean:
			num = 18;
			break;
		}
		for (int i = 0; i < num; i++)
		{
			text2 += text;
		}
		_infoText.SetTextAndRebuild("<c=blood><j=underground>" + text2);
		_titleText.SetTextAndRebuild("<c=blood><j=underground>" + text);
		_noText.SetTextAndRebuild("<c=blood><j=underground>" + text);
	}

	private void OnGrabbed()
	{
		if (_isEnabledEffect)
		{
			_isEnabledEffect = false;
			_markerEffect.transform.DOScale(Vector3.zero, 0.5f).SetEase(_markerTweenCurve);
		}
		if (_shouldIncreaseHintNo)
		{
			_shouldIncreaseHintNo = false;
			UserDataAccessorManager.PlayRecordDataAccessor.IncreaseHintNo();
		}
	}
}
public class Microwave : SingletonMonoBehaviour<Microwave>
{
	[SerializeField]
	private List<MeshRenderer> _rendererList = new List<MeshRenderer>();

	[SerializeField]
	private Material _offMaterial;

	[SerializeField]
	private Material _onMaterial;

	[SerializeField]
	[Required]
	private ParticleSystem _dischargeParticleSystem;

	[SerializeField]
	[Required]
	private Transform _door;

	[SerializeField]
	private AnimationCurve _doorCurve;

	private Sequence _doorTween;

	[SerializeField]
	[Required]
	private Transform _specialItemSpawnPositionTarget;

	[SerializeField]
	private AnimationCurve _specialItemSpawnScaleCurve;

	private AudioPlayer _chinSEPlayer;

	private AudioPlayer _closeSEPlayer;

	private AudioPlayer _openSEPlayer;

	private AudioPlayer _thunderSEPlayer;

	private AudioPlayer _spawnSpecialItemSEPlayer;

	protected override void Init()
	{
		base.Init();
		_chinSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_specialItemSpawnPositionTarget.gameObject, "Audio/SE/SE_MicrowaveChin");
		_closeSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_door.gameObject, "Audio/SE/SE_MicrowaveClose");
		_openSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_door.gameObject, "Audio/SE/SE_MicrowaveOpen");
		_thunderSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_dischargeParticleSystem.gameObject, "Audio/SE/SE_Thunder");
		_spawnSpecialItemSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_specialItemSpawnPositionTarget.gameObject, "Audio/SE/SE_SpawnSpecialItem");
	}

	public void Activate()
	{
		_dischargeParticleSystem.Play();
		_thunderSEPlayer.Play();
		foreach (MeshRenderer renderer in _rendererList)
		{
			renderer.material = _onMaterial;
		}
		StartCoroutine(this.DelayMethod(0.5f, delegate
		{
			_chinSEPlayer.Play();
		}));
		StartCoroutine(this.DelayMethod(1f, OpenDoor));
		StartCoroutine(this.DelayMethod(1.5f, SpawnSpecialItem));
	}

	private void OpenDoor()
	{
		if (_doorTween != null)
		{
			_doorTween.Kill();
			_doorTween = null;
		}
		_openSEPlayer.Play();
		_doorTween = DOTween.Sequence().Append(_door.DOLocalRotate(new Vector3(0f, 90f, 0f), 0.2f).SetEase(_doorCurve)).AppendInterval(2f)
			.OnComplete(CloseDoor);
	}

	private void CloseDoor()
	{
		if (_doorTween != null)
		{
			_doorTween.Kill();
			_doorTween = null;
		}
		_doorTween = DOTween.Sequence().Append(_door.DOLocalRotate(new Vector3(0f, 0f, 0f), 1f).SetEase(_doorCurve)).OnComplete(delegate
		{
			_doorTween = null;
			_closeSEPlayer.Play();
			foreach (MeshRenderer renderer in _rendererList)
			{
				renderer.material = _offMaterial;
			}
		});
	}

	[Button("SpawnSpecialItem")]
	private void SpawnSpecialItem()
	{
		LickableObjectSet specialItem = SingletonMonoBehaviour<LickableObjectManager>.Instance.GetSpecialItem();
		if (specialItem == null)
		{
			return;
		}
		specialItem.gameObject.SetActive(value: true);
		specialItem.transform.position = _specialItemSpawnPositionTarget.position;
		List<Collider> colliderList = specialItem.GetComponentsInChildren<Collider>().ToList();
		foreach (Collider item in colliderList)
		{
			item.enabled = false;
		}
		specialItem.transform.localScale = Vector3.one * 0.2f;
		specialItem.transform.DOScale(Vector3.one, 0.5f).SetEase(_specialItemSpawnScaleCurve).OnComplete(delegate
		{
			foreach (Collider item2 in colliderList)
			{
				item2.enabled = true;
			}
		});
		_spawnSpecialItemSEPlayer.Play();
		SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstSpecialItem);
		specialItem.GetComponent<Rigidbody>().velocity = new Vector3(-2f, 6f, 0f);
	}
}
public class PlayerChoker : MonoBehaviour
{
	private bool _isRendered;

	private bool _isRendering;

	private float _renderingTime;

	private VRHandController _handController;

	private void Start()
	{
		_handController = SingletonMonoBehaviour<VRHandController>.Instance;
	}

	private void Update()
	{
		if (_isRendering)
		{
			_renderingTime += Time.deltaTime;
			if (_renderingTime > 1f)
			{
				_isRendered = true;
				SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.ChokerMirror);
			}
		}
		else
		{
			_renderingTime = 0f;
		}
		_isRendering = false;
	}

	private void OnWillRenderObject()
	{
		if (!_isRendered && Camera.current.CompareTag("MirrorCamera") && SingletonMonoBehaviour<EyeShadowPaletteMirror>.Instance.IsRendered && _handController.IsGrabbing(LickableObjectType.EyeShadowPalette))
		{
			_isRendering = true;
		}
	}
}
public class RainbowTapioca : MonoBehaviour
{
	private static readonly int GlowSpeedDiff = Shader.PropertyToID("_GlowSpeedDiff");

	private void Awake()
	{
		GetComponent<MeshRenderer>().material.SetFloat(GlowSpeedDiff, UnityEngine.Random.Range(0f, 1f));
	}
}
public class TimeStopClock : OnceLickableObject
{
	[SerializeField]
	[Required]
	private Transform _lid;

	[SerializeField]
	[Required]
	private Transform _needle;

	private Tweener _lidTween;

	[SerializeField]
	[Required]
	private ParticleSystem _stopParticle;

	[SerializeField]
	[Required]
	private ParticleSystem _resumeParticle;

	private AudioPlayer _openSEPlayer;

	private AudioPlayer _closeSEPlayer;

	private AudioPlayer _stopSEPlayer;

	private AudioPlayer _resumeSEPLayer;

	private readonly List<AudioPlayer> _clockSEPlayerList = new List<AudioPlayer>();

	private int _currentClockSENum;

	private float _clockSEInterval;

	private static readonly float LIMIT = 10f;

	private float _limit;

	private bool _wasEnabled;

	private bool _isPlaying;

	private bool _isInitialized;

	protected override bool _canUse
	{
		get
		{
			if (IsEnabled())
			{
				return !_isPlaying;
			}
			return false;
		}
	}

	private void Start()
	{
		_openSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_lid.gameObject, "Audio/SE/SE_OpenClock");
		_closeSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_lid.gameObject, "Audio/SE/SE_CloseClock");
		_stopSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_stopParticle.gameObject, "Audio/SE/SE_TimeStopEffect");
		_resumeSEPLayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_resumeParticle.gameObject, "Audio/SE/SE_TimeResumeEffect");
		for (int i = 1; i <= 2; i++)
		{
			_clockSEPlayerList.Add(SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, string.Format("{0}/SE_Clock{1}", "Audio/SE", i)));
		}
		_stopParticle.transform.SetParent(base.transform.parent);
		_resumeParticle.transform.SetParent(base.transform.parent);
		_stopParticle.transform.ResetInLocal();
		_resumeParticle.transform.ResetInLocal();
		LateUpdate();
		UpdateAccordingToLimit();
		_isInitialized = true;
	}

	protected void LateUpdate()
	{
		bool flag = IsEnabled();
		if (_wasEnabled != flag || !_isInitialized)
		{
			if (flag)
			{
				OpenLid();
			}
			else
			{
				CloseLid();
			}
		}
		_wasEnabled = flag;
		if (!_isPlaying)
		{
			return;
		}
		_limit = Mathf.Min(_limit + Time.deltaTime, LIMIT);
		UpdateAccordingToLimit();
		if (_limit >= LIMIT)
		{
			Finish();
			return;
		}
		_clockSEInterval -= Time.deltaTime;
		if (!(_clockSEInterval > 0f))
		{
			float pitch = 1f + (float)_currentClockSENum * 0.02f;
			_clockSEPlayerList[_currentClockSENum % _clockSEPlayerList.Count].Play(1f, 0f, pitch);
			_currentClockSENum++;
			_clockSEInterval = 0.45f - (float)_currentClockSENum * 0.0095f;
		}
	}

	private void UpdateAccordingToLimit()
	{
		float num = _limit / LIMIT;
		_needle.SetLocalEulerAngleZ(num * 360f);
	}

	private bool IsEnabled()
	{
		if (_limit < LIMIT)
		{
			return SingletonMonoBehaviour<GirlManager>.Instance.IsInClassroom();
		}
		return false;
	}

	protected override void Use()
	{
		base.Use();
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.Pause();
		SingletonMonoBehaviour<GirlManager>.Instance.Pause();
		SingletonMonoBehaviour<GirlGameOverActionPlayer>.Instance.Pause();
		SingletonMonoBehaviour<AfterGameOverGirlManager>.Instance.Pause();
		_stopParticle.transform.position = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform.position;
		_stopParticle.Play();
		_stopSEPlayer.Play();
		_isPlaying = true;
	}

	private void Finish()
	{
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.UnPause();
		SingletonMonoBehaviour<GirlManager>.Instance.Resume();
		SingletonMonoBehaviour<GirlGameOverActionPlayer>.Instance.Resume();
		SingletonMonoBehaviour<AfterGameOverGirlManager>.Instance.Resume();
		_resumeParticle.transform.position = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform.position;
		_resumeParticle.Play();
		_resumeSEPLayer.Play();
		_isPlaying = false;
	}

	private void OpenLid()
	{
		int num = 90;
		if (!_isInitialized)
		{
			_lid.SetLocalEulerAngleY(num);
			return;
		}
		_lidTween?.Kill();
		_lidTween = _lid.DOLocalRotate(new Vector3(0f, num, 0f), 0.3f).SetEase(Ease.InOutQuart);
		_openSEPlayer.Play();
	}

	private void CloseLid()
	{
		int num = 0;
		if (!_isInitialized)
		{
			_lid.SetLocalEulerAngleY(num);
			return;
		}
		_lidTween?.Kill();
		_lidTween = _lid.DOLocalRotate(new Vector3(0f, num, 0f), 0.3f).SetEase(Ease.InOutQuart).OnComplete(delegate
		{
			_closeSEPlayer.Play();
		});
	}
}
public class AfterGameOverGirlManager : SingletonMonoBehaviour<AfterGameOverGirlManager>
{
	private Transform _girlTransform;

	private Transform _cameraTransform;

	private bool _isPlaying;

	private bool _isPause;

	private float _surpriseLimit;

	private GirlFaceAnimationType _beforeFaceAnimationType;

	private bool _shouldReturnFace;

	public bool IsSurprising => _surpriseLimit > 0f;

	public void Play()
	{
		_girlTransform = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform;
		_cameraTransform = SingletonMonoBehaviour<GirlAnimationController>.Instance.CameraTransform;
		_isPlaying = true;
	}

	private void Update()
	{
		if (_isPlaying && !_isPause && !(_surpriseLimit <= 0f))
		{
			_surpriseLimit -= Time.deltaTime;
			if (_shouldReturnFace && _surpriseLimit <= 1f)
			{
				_shouldReturnFace = false;
				SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeFaceAnimation(_beforeFaceAnimationType);
			}
			Vector3 forward = _cameraTransform.position - _girlTransform.position;
			forward.y = 0f;
			Quaternion b = Quaternion.LookRotation(forward);
			_girlTransform.rotation = Quaternion.Slerp(_girlTransform.rotation, b, 0.1f);
		}
	}

	public void SurpriseIfNeeded()
	{
		if (_isPlaying && !_isPause && !IsSurprising)
		{
			_beforeFaceAnimationType = SingletonMonoBehaviour<GirlAnimationController>.Instance.CurrentFaceAnimationType;
			_shouldReturnFace = true;
			_surpriseLimit = 3f;
			SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(GirlBodyAnimationType.Surprise, 0.2f);
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeFaceAnimation(GirlFaceAnimationType.Surprise, 0.2f);
			SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifSurprise);
			SingletonMonoBehaviour<GirlGameOverActionPlayer>.Instance.PlayAdmirationParticle();
		}
	}

	public void Pause()
	{
		_isPause = true;
	}

	public void Resume()
	{
		_isPause = false;
	}
}
public class FootStepSEPlayer : SingletonMonoBehaviour<FootStepSEPlayer>
{
	private readonly List<AudioPlayer> _audioPlayerList = new List<AudioPlayer>();

	private List<AudioPlayer> _notUsingAudioPlayerList;

	private void Start()
	{
		for (int i = 1; i <= 8; i++)
		{
			string text = $"SE_FootStep{i}";
			GameObject targetObject = base.transform.CreateChild(text).gameObject;
			_audioPlayerList.Add(SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(targetObject, "Audio/SE/" + text));
		}
	}

	public void Play(Vector3 targetPosition)
	{
		if (_notUsingAudioPlayerList == null || _notUsingAudioPlayerList.Count == 0)
		{
			_notUsingAudioPlayerList = new List<AudioPlayer>(_audioPlayerList);
		}
		AudioPlayer andRemoveAtRandom = _notUsingAudioPlayerList.GetAndRemoveAtRandom();
		andRemoveAtRandom.transform.position = targetPosition;
		andRemoveAtRandom.Play();
	}
}
public class Girl : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Transform _speechBubbleTarget;

	[SerializeField]
	[Required]
	private GirlHoldingObjectHolder _holdingObjectHolder;

	private Action _waitCallback;

	private float _waitTime;

	public Transform SpeechBubbleTarget => _speechBubbleTarget;

	public GirlHoldingObjectHolder HoldingObjectHolder => _holdingObjectHolder;

	public bool IsInvincible { get; set; }

	private void Update()
	{
		if (_waitCallback != null && !SingletonMonoBehaviour<GirlManager>.Instance.IsPause)
		{
			_waitTime -= Time.deltaTime;
			if (_waitTime <= 0f)
			{
				_waitCallback();
				_waitCallback = null;
			}
		}
	}

	public void Hold(LickableObjectSet targetObject)
	{
		targetObject.gameObject.SetActive(value: true);
		_holdingObjectHolder.Hold(targetObject);
	}

	public void CheckHold(LickableObjectType lickableObjectType)
	{
		_holdingObjectHolder.CheckHold(lickableObjectType);
	}

	public void PutIfNeeded(Action callback)
	{
		if (!_holdingObjectHolder.IsHolding)
		{
			callback();
			return;
		}
		SingletonMonoBehaviour<InstructionManager>.Instance.GiveInstructions(HoldingObjectHolder.HoldingObjectType, SpeechBubbleTarget);
		GirlBodyAnimationType putAnimationType = _holdingObjectHolder.GetPutAnimationType();
		GirlAnimationController animationController = SingletonMonoBehaviour<GirlAnimationController>.Instance;
		if (putAnimationType == GirlBodyAnimationType.FlyHold)
		{
			_holdingObjectHolder.PlayFlyHoldSE();
		}
		animationController.ShouldLookCamera = putAnimationType == GirlBodyAnimationType.Put;
		animationController.FadeBodyAnimation(putAnimationType, 0.2f);
		_waitTime = 0.85f;
		_waitCallback = delegate
		{
			float colliderDelay = ((putAnimationType == GirlBodyAnimationType.Put) ? 0f : 0.2f);
			Vector3 velocity = (_holdingObjectHolder.Head.forward + _holdingObjectHolder.Head.up) * 0.2f;
			if (putAnimationType == GirlBodyAnimationType.Bow)
			{
				velocity = _holdingObjectHolder.Head.up * 0.3f;
			}
			else if (putAnimationType == GirlBodyAnimationType.FlyHold)
			{
				velocity = _holdingObjectHolder.Head.forward * 1f;
			}
			_holdingObjectHolder.Put(colliderDelay, velocity);
			_waitTime = 1f;
			_waitCallback = delegate
			{
				SingletonMonoBehaviour<InstructionManager>.Instance.ShowAnswer();
				animationController.ShouldLookCamera = true;
			};
			callback();
		};
	}
}
public class GirlAnimationController : SingletonMonoBehaviour<GirlAnimationController>
{
	public enum HeightType
	{
		Stand = 1,
		Crouching = 0,
		Creeping = -1
	}

	private Animator _animator;

	private HeadLookController _headLookController;

	private GirlEyeMarkManager _eyeMarkManager;

	private LickableObjectManager _lickableObjectManager;

	private Transform _cameraTransform;

	private Transform _defaultLookTarget;

	private Transform _beforeLookTarget;

	private readonly Dictionary<int, GirlBodyAnimationType> _bodyAnimationHashDict = new Dictionary<int, GirlBodyAnimationType>();

	private GirlFaceAnimationType _beforeFaceAnimationType;

	private float _beforeLookTargetLimit;

	private static readonly int SPEED_HASH = Animator.StringToHash("Speed");

	private float _currentSpeed;

	private static readonly int HEIGHT_HASH = Animator.StringToHash("Height");

	private Tweener _changeHeightTweener;

	public Transform CameraTransform => _cameraTransform;

	public bool ShouldLookCamera { private get; set; } = true;


	public bool ShouldLookClassroomClock { get; set; }

	[ShowInInspector]
	[ReadOnly]
	public GirlBodyAnimationType CurrentBodyAnimationType { get; private set; }

	[ShowInInspector]
	[ReadOnly]
	public GirlFaceAnimationType CurrentFaceAnimationType { get; private set; }

	public HeightType CurrentHeightType { get; private set; } = HeightType.Stand;


	public event Action<GirlBodyAnimationType> ChangedAnimation = delegate
	{
	};

	private void Start()
	{
		_defaultLookTarget = base.transform.CreateChild("DefaultLookTarget");
		_defaultLookTarget.ResetInLocal();
		foreach (GirlBodyAnimationType allIn in EnumUtility.GetAllInList<GirlBodyAnimationType>())
		{
			_bodyAnimationHashDict[Animator.StringToHash($"Base Layer.{allIn}")] = allIn;
		}
		_cameraTransform = SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCamera.transform;
		GameObject gameObject = SingletonMonoBehaviour<GirlManager>.Instance.Girl.gameObject;
		_animator = gameObject.GetComponent<Animator>();
		_headLookController = gameObject.GetComponent<HeadLookController>();
		SingletonMonoBehaviour<GirlMoveController>.Instance.CurrentSpeedObservable.Subscribe(OnChangeSpeed);
		ChangeHeight(HeightType.Stand);
		_eyeMarkManager = SingletonMonoBehaviour<GirlEyeMarkManager>.Instance;
		_lickableObjectManager = SingletonMonoBehaviour<LickableObjectManager>.Instance;
	}

	private void Update()
	{
		int fullPathHash = _animator.GetCurrentAnimatorStateInfo(0).fullPathHash;
		if (!_bodyAnimationHashDict.ContainsKey(fullPathHash))
		{
			Debug.LogWarning($"_bodyAnimationHashDictに含まれないハッシュ値です : {fullPathHash}");
			return;
		}
		GirlBodyAnimationType girlBodyAnimationType = _bodyAnimationHashDict[fullPathHash];
		if (girlBodyAnimationType != CurrentBodyAnimationType)
		{
			OnChangeBodyAnimation(girlBodyAnimationType);
		}
	}

	private void LateUpdate()
	{
		if (ShouldLookClassroomClock)
		{
			_headLookController.target = SingletonMonoBehaviour<ClassroomClock>.Instance.transform.position;
			_beforeLookTarget = null;
			return;
		}
		if (_cameraTransform == null)
		{
			_headLookController.target = _defaultLookTarget.position;
			_beforeLookTarget = null;
			return;
		}
		GirlFaceAnimationType girlFaceAnimationType = GirlFaceAnimationType.Normal;
		if (IsLookingCamera())
		{
			girlFaceAnimationType = GirlFaceAnimationType.Doubt;
			if (_eyeMarkManager.CurrentLeftMarkType != 0 || _eyeMarkManager.CurrentRightMarkType != 0)
			{
				girlFaceAnimationType = GirlFaceAnimationType.Surprise;
			}
			Transform transform = null;
			if (_eyeMarkManager.CurrentRightTarget != null)
			{
				transform = _eyeMarkManager.CurrentRightTarget;
			}
			else if (_eyeMarkManager.CurrentLeftTarget != null)
			{
				transform = _eyeMarkManager.CurrentLeftTarget;
			}
			if (SingletonMonoBehaviour<GirlGameOverActionPlayer>.Instance.IsPlaying || SingletonMonoBehaviour<AfterGameOverGirlManager>.Instance.IsSurprising)
			{
				transform = null;
				_beforeLookTarget = null;
			}
			if (transform == null)
			{
				if (_beforeLookTarget != null)
				{
					_headLookController.target = _beforeLookTarget.position;
					girlFaceAnimationType = _beforeFaceAnimationType;
					_beforeLookTargetLimit -= Time.deltaTime;
					if (_beforeLookTargetLimit <= 0f)
					{
						_beforeLookTarget = null;
					}
				}
				else
				{
					_headLookController.target = _cameraTransform.position;
					girlFaceAnimationType = GirlFaceAnimationType.Normal;
				}
			}
			else
			{
				_headLookController.target = transform.position;
				_beforeLookTarget = transform;
				_beforeFaceAnimationType = girlFaceAnimationType;
				_beforeLookTargetLimit = 2f;
			}
		}
		else
		{
			_headLookController.target = _defaultLookTarget.position;
			girlFaceAnimationType = GirlFaceAnimationType.Normal;
		}
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.Playing)
		{
			ChangeFaceAnimation(girlFaceAnimationType);
		}
	}

	private bool IsLookingCamera()
	{
		if (SingletonMonoBehaviour<Tongue>.Instance.IsActiveState(Tongue.State.Transparent))
		{
			return false;
		}
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.GameOver)
		{
			if (CurrentBodyAnimationType != GirlBodyAnimationType.Cry && CurrentBodyAnimationType != GirlBodyAnimationType.KO)
			{
				return CurrentBodyAnimationType != GirlBodyAnimationType.NotYet;
			}
			return false;
		}
		if (CurrentHeightType != HeightType.Stand || _changeHeightTweener != null || !ShouldLookCamera || !IsLookingCameraDistance())
		{
			return false;
		}
		if (CurrentBodyAnimationType != 0)
		{
			return CurrentBodyAnimationType == GirlBodyAnimationType.Put;
		}
		return true;
	}

	public bool IsLookingCameraDistance()
	{
		return GetCameraDistance() <= 3f;
	}

	public float GetCameraDistance()
	{
		return Vector3.Distance(_animator.transform.position, _cameraTransform.position);
	}

	private void OnChangeSpeed(float speed)
	{
		if (speed <= 0f || _currentSpeed <= 0f)
		{
			_currentSpeed = speed;
		}
		else
		{
			_currentSpeed = _currentSpeed * 0.6f + speed * 0.4f;
		}
		_animator.SetFloat(SPEED_HASH, _currentSpeed / 3f * 0.5f);
	}

	public void ChangeSpeed(float speed)
	{
		OnChangeSpeed(speed);
	}

	public void ChangeHeight(HeightType heightType, float fadeTime = 0f)
	{
		float num = (float)heightType;
		if (fadeTime > 0f)
		{
			float currentHeight = (float)CurrentHeightType;
			ChangeHeadLookControllerState(isEnabled: false);
			_changeHeightTweener = DOTween.To(() => currentHeight, delegate(float h)
			{
				_animator.SetFloat(HEIGHT_HASH, h);
			}, num, fadeTime).OnComplete(delegate
			{
				ChangeHeadLookControllerState(isEnabled: true);
				_changeHeightTweener = null;
			});
		}
		else
		{
			_animator.SetFloat(HEIGHT_HASH, num);
		}
		CurrentHeightType = heightType;
		UpdateDefaultLookTargetPosition();
	}

	public void ChangeBodyAnimation(GirlBodyAnimationType bodyAnimationType, Action callback = null)
	{
		if (CurrentBodyAnimationType == bodyAnimationType)
		{
			callback?.Invoke();
			return;
		}
		StartCoroutine(_animator.Play(Animator.StringToHash(bodyAnimationType.ToString()), callback));
		OnChangeBodyAnimation(bodyAnimationType);
	}

	public void FadeBodyAnimation(GirlBodyAnimationType bodyAnimationType, float fadeLength = 0.5f)
	{
		if (CurrentBodyAnimationType != bodyAnimationType)
		{
			_animator.CrossFade(Animator.StringToHash(bodyAnimationType.ToString()), fadeLength);
			OnChangeBodyAnimation(bodyAnimationType);
		}
	}

	private void OnChangeBodyAnimation(GirlBodyAnimationType bodyAnimationType)
	{
		Debug.Log($"FadeBodyAnimation {CurrentBodyAnimationType} → {bodyAnimationType}");
		CurrentBodyAnimationType = bodyAnimationType;
		this.ChangedAnimation(CurrentBodyAnimationType);
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState != GameManager.State.GameOver)
		{
			if (CurrentBodyAnimationType == GirlBodyAnimationType.DiveRoll || CurrentBodyAnimationType == GirlBodyAnimationType.DiveRollShort)
			{
				ChangeFaceAnimation(GirlFaceAnimationType.Anger, 0.1f);
			}
			else if (CurrentBodyAnimationType == GirlBodyAnimationType.Jump)
			{
				ChangeFaceAnimation(GirlFaceAnimationType.Surprise, 0.1f);
			}
			else if (CurrentBodyAnimationType == GirlBodyAnimationType.Normal)
			{
				ChangeFaceAnimation(GirlFaceAnimationType.Normal);
			}
		}
		UpdateDefaultLookTargetPosition();
	}

	private void UpdateDefaultLookTargetPosition()
	{
		if (CurrentBodyAnimationType == GirlBodyAnimationType.DiveRoll)
		{
			_defaultLookTarget.localPosition = new Vector3(0f, 0.576f, 0.928f);
		}
		else if (CurrentBodyAnimationType == GirlBodyAnimationType.Land || CurrentBodyAnimationType == GirlBodyAnimationType.FallLoop)
		{
			_defaultLookTarget.localPosition = new Vector3(0.1f, 0.545f, 0.652f);
		}
		else if (CurrentBodyAnimationType == GirlBodyAnimationType.Normal)
		{
			if (CurrentHeightType == HeightType.Stand)
			{
				_defaultLookTarget.localPosition = new Vector3(0f, 1.373f, 0.928f);
			}
			else if (CurrentHeightType == HeightType.Crouching)
			{
				_defaultLookTarget.localPosition = new Vector3(0.95f, -1.03f, 0.93f);
			}
			else if (CurrentHeightType == HeightType.Creeping)
			{
				_defaultLookTarget.localPosition = new Vector3(0.315f, -1.186f, 0.928f);
			}
		}
		else
		{
			_defaultLookTarget.localPosition = new Vector3(0f, 1.373f, 0.928f);
		}
	}

	public void ChangeFaceAnimation(GirlFaceAnimationType faceAnimationType, float fadeLength = 0.5f)
	{
		if (CurrentFaceAnimationType != faceAnimationType)
		{
			Debug.Log($"ChangeFaceAnimation {CurrentFaceAnimationType} → {faceAnimationType}");
			CurrentFaceAnimationType = faceAnimationType;
			_animator.CrossFade($"{CurrentFaceAnimationType}Face", fadeLength);
		}
	}

	public void ChangeHeadLookControllerState(bool isEnabled)
	{
		_headLookController.enabled = isEnabled;
	}

	public void Pause()
	{
		_animator.enabled = false;
		_headLookController.enabled = false;
	}

	public void Resume()
	{
		_animator.enabled = true;
		_headLookController.enabled = true;
	}
}
public class GirlClapHand : SingletonMonoBehaviour<GirlClapHand>
{
	private readonly List<AudioPlayer> _sePlayerList = new List<AudioPlayer>();

	private float _delay;

	public bool IsEnabled { private get; set; }

	private void Start()
	{
		for (int i = 1; i <= 4; i++)
		{
			_sePlayerList.Add(SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, string.Format("{0}/SE_Clap{1}", "Audio/SE", i)));
		}
	}

	private void Update()
	{
		if (_delay > 0f)
		{
			_delay -= Time.deltaTime;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (IsEnabled && !(_delay > 0f))
		{
			_delay = 0.2f;
			_sePlayerList.GetAtRandom().Play();
		}
	}
}
public class GirlDistanceFinder : SingletonMonoBehaviour<GirlDistanceFinder>
{
	private Transform _transform;

	private Transform _girl;

	private static readonly float DISTANCE_MIN = 10f;

	private static readonly float DISTANCE_MAX = 27f;

	public float DistanceRate { get; private set; }

	private void Start()
	{
		_transform = base.transform;
		_girl = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform;
	}

	private void Update()
	{
		Vector3 position = _transform.position;
		Vector3 position2 = _girl.position;
		float value = Mathf.Abs(position.x - position2.x) + Mathf.Abs(position.z - position2.z);
		DistanceRate = 1f - Mathf.InverseLerp(DISTANCE_MIN, DISTANCE_MAX, value);
	}
}
public class GirlEye : MonoBehaviour
{
	private Transform _transform;

	private Transform _target;

	[SerializeField]
	private int _rayCount = 10;

	[SerializeField]
	private float _raySpan = 0.1f;

	[SerializeField]
	private float _maxDistance = 10f;

	[SerializeField]
	private LayerMask _layerMask;

	private void Start()
	{
		_transform = base.transform;
		_target = SingletonMonoBehaviour<Tongue>.Instance.Center.transform;
	}

	public bool IsVisibleTarget()
	{
		Vector3 position = _transform.position;
		int num = _rayCount / 2;
		for (int i = -num; i < num; i++)
		{
			for (int j = -num; j < num; j++)
			{
				for (int k = -num; k < num; k++)
				{
					Vector3 vector = new Vector3(i, j, k) * _raySpan;
					Vector3 vector2 = position + vector;
					Vector3 normalized = (_target.position + vector - vector2).normalized;
					if (GetTongueIfNeeded(vector2, normalized, _maxDistance) != null)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private Tongue GetTongueIfNeeded(Vector3 rayStartPosition, Vector3 rayDirection, float distance)
	{
		Physics.Raycast(rayStartPosition, rayDirection, out var hitInfo, distance, _layerMask);
		Color color = Color.green;
		if (hitInfo.collider != null)
		{
			color = Color.red;
			distance = Vector3.Distance(rayStartPosition, hitInfo.collider.transform.position);
		}
		Debug.DrawRay(rayStartPosition, rayDirection * distance, color, 0.01f, depthTest: false);
		if (hitInfo.collider == null)
		{
			return null;
		}
		return hitInfo.collider.gameObject.GetComponentInParent<Tongue>();
	}
}
public class GirlEyeMarkManager : SingletonMonoBehaviour<GirlEyeMarkManager>
{
	[SerializeField]
	[Required]
	private GameObject _goldMarkLeft;

	[SerializeField]
	[Required]
	private GameObject _moneyMarkLeft;

	[SerializeField]
	[Required]
	private GameObject _heartMarkLeft;

	[SerializeField]
	[Required]
	private GameObject _goldMarkRight;

	[SerializeField]
	[Required]
	private GameObject _moneyMarkRight;

	[SerializeField]
	[Required]
	private GameObject _heartMarkRight;

	private readonly Dictionary<GirlEyeMarkType, GameObject> _leftMarkDict = new Dictionary<GirlEyeMarkType, GameObject>();

	private readonly Dictionary<GirlEyeMarkType, GameObject> _rightMarkDict = new Dictionary<GirlEyeMarkType, GameObject>();

	private bool _shouldUpdateMark;

	public const float RETURN_MARK_LIMIT = 2f;

	private Dictionary<bool, float> _returnMarkLimitDict = new Dictionary<bool, float>
	{
		{ false, 0f },
		{ true, 0f }
	};

	private VRHandController _handController;

	[ShowInInspector]
	[ReadOnly]
	public GirlEyeMarkType CurrentLeftMarkType { get; private set; }

	[ShowInInspector]
	[ReadOnly]
	public GirlEyeMarkType CurrentRightMarkType { get; private set; }

	public Transform CurrentLeftTarget { get; private set; }

	public Transform CurrentRightTarget { get; private set; }

	protected override void Init()
	{
		base.Init();
		_leftMarkDict[GirlEyeMarkType.Gold] = _goldMarkLeft;
		_leftMarkDict[GirlEyeMarkType.Money] = _moneyMarkLeft;
		_leftMarkDict[GirlEyeMarkType.Heart] = _heartMarkLeft;
		_rightMarkDict[GirlEyeMarkType.Gold] = _goldMarkRight;
		_rightMarkDict[GirlEyeMarkType.Money] = _moneyMarkRight;
		_rightMarkDict[GirlEyeMarkType.Heart] = _heartMarkRight;
		ChangeMarkType(GirlEyeMarkType.None, isLeft: true);
		ChangeMarkType(GirlEyeMarkType.None, isLeft: false);
		UpdateMarks();
	}

	private void Start()
	{
		_handController = SingletonMonoBehaviour<VRHandController>.Instance;
	}

	private void Update()
	{
		if (_handController == null)
		{
			Debug.LogWarning("_handController is null");
			return;
		}
		_shouldUpdateMark = false;
		ChangeMarkType(_handController.GetGrabbingLeftObject(), isLeft: true);
		ChangeMarkType(_handController.GetGrabbingRightObject(), isLeft: false);
		if (_shouldUpdateMark)
		{
			UpdateMarks();
		}
	}

	private void UpdateMarks()
	{
		if (CurrentLeftMarkType == GirlEyeMarkType.None)
		{
			UpdateMark(_leftMarkDict, CurrentRightMarkType);
			UpdateMark(_rightMarkDict, CurrentRightMarkType);
		}
		else if (CurrentRightMarkType == GirlEyeMarkType.None)
		{
			UpdateMark(_leftMarkDict, CurrentLeftMarkType);
			UpdateMark(_rightMarkDict, CurrentLeftMarkType);
		}
		else
		{
			UpdateMark(_rightMarkDict, CurrentLeftMarkType);
			UpdateMark(_leftMarkDict, CurrentRightMarkType);
		}
	}

	private void UpdateMark(Dictionary<GirlEyeMarkType, GameObject> markDict, GirlEyeMarkType markType)
	{
		foreach (KeyValuePair<GirlEyeMarkType, GameObject> item in markDict)
		{
			item.Value.SetActive(item.Key == markType);
		}
	}

	private void ChangeMarkType(RespondGrabbingObject grabbingObject, bool isLeft)
	{
		GirlEyeMarkType girlEyeMarkType = GirlEyeMarkType.None;
		Transform transform = null;
		if (grabbingObject != null && (SceneNavigator.CurrentSceneName != "Main" || !SingletonMonoBehaviour<Tongue>.Instance.IsActiveState(Tongue.State.Transparent)))
		{
			transform = grabbingObject.transform;
			if (transform.CompareTag("Ingot"))
			{
				girlEyeMarkType = GirlEyeMarkType.Gold;
			}
			else if (transform.CompareTag("Money"))
			{
				girlEyeMarkType = GirlEyeMarkType.Money;
			}
			else if (transform.CompareTag("KanCrow"))
			{
				girlEyeMarkType = GirlEyeMarkType.Heart;
			}
		}
		if (isLeft)
		{
			CurrentLeftTarget = transform;
		}
		else
		{
			CurrentRightTarget = transform;
		}
		if (girlEyeMarkType == GirlEyeMarkType.None)
		{
			if (_returnMarkLimitDict[isLeft] > 0f)
			{
				girlEyeMarkType = (isLeft ? CurrentLeftMarkType : CurrentRightMarkType);
				_returnMarkLimitDict[isLeft] -= Time.deltaTime;
			}
		}
		else
		{
			_returnMarkLimitDict[isLeft] = 2f;
		}
		if (girlEyeMarkType != (isLeft ? CurrentLeftMarkType : CurrentRightMarkType))
		{
			_shouldUpdateMark = true;
			ChangeMarkType(girlEyeMarkType, isLeft);
		}
	}

	private void ChangeMarkType(GirlEyeMarkType markType, bool isLeft)
	{
		if (isLeft)
		{
			CurrentLeftMarkType = markType;
		}
		else
		{
			CurrentRightMarkType = markType;
		}
	}
}
public class GirlFoot : MonoBehaviour
{
	private enum State
	{
		Down,
		Up
	}

	private State _currentState;

	private Transform _transform;

	private void Awake()
	{
		_transform = base.transform;
		_currentState = State.Down;
	}

	private void Update()
	{
		float y = _transform.position.y;
		if (_currentState == State.Down && y > 0.2f)
		{
			_currentState = State.Up;
		}
		else if (_currentState == State.Up && y < 0.1f)
		{
			_currentState = State.Down;
			SingletonMonoBehaviour<FootStepSEPlayer>.Instance.Play(base.transform.position);
		}
	}
}
public class GirlGameOverActionAttackCollider : MonoBehaviour
{
	[SerializeField]
	private GirlGameOverActionPlayer.AttackType _attackType;

	private Action<GirlGameOverActionPlayer.AttackType, Vector3> _hitAction;

	private void Start()
	{
		_hitAction = SingletonMonoBehaviour<GirlGameOverActionPlayer>.Instance.SetAttackCollider(_attackType, this);
	}

	private void OnTriggerEnter(Collider other)
	{
		_hitAction(_attackType, (base.transform.position + other.transform.position) * 0.5f);
	}
}
public class GirlGameOverActionPlayer : SingletonMonoBehaviour<GirlGameOverActionPlayer>
{
	private enum State
	{
		Stop,
		Surprise,
		Chaise,
		Attack,
		AfterAttack,
		KO,
		Praise
	}

	public enum AttackType
	{
		HeelDrop,
		RoundhouseKick,
		JumpingKick,
		SummerSalt,
		ProvocationAttack
	}

	[SerializeField]
	[Required]
	private ParticleSystem _hitParticle;

	[SerializeField]
	[Required]
	private ParticleSystem _admirationParticle;

	private AudioPlayer _admirationSEPlayer;

	[SerializeField]
	[Required]
	private NavMeshAgent _navMeshAgent;

	private GameOverType _gameOverType;

	private int _scoreRateTypeNo;

	private Dictionary<AttackType, GirlGameOverActionAttackCollider> _attackColliderDict = new Dictionary<AttackType, GirlGameOverActionAttackCollider>();

	private Transform _girlTransform;

	private Transform _cameraTransform;

	private State _currentState;

	private AttackType _attackType;

	private bool _shouldHitAttack;

	private float _waitTime;

	private Action _waitAfterAction;

	private bool _isPause;

	private bool _shouldLockCamera;

	private bool _isPlayingVoice;

	public bool IsPlaying { get; private set; }

	protected override void Init()
	{
		base.Init();
		_navMeshAgent.enabled = false;
		_admirationSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_Discover");
		_admirationSEPlayer.ChangeDistance(0.2f, 16f);
	}

	public Action<AttackType, Vector3> SetAttackCollider(AttackType attackType, GirlGameOverActionAttackCollider attackCollider)
	{
		_attackColliderDict[attackType] = attackCollider;
		_attackColliderDict[attackType].gameObject.SetActive(value: false);
		return OnHitAttack;
	}

	public void Play(GameOverType gameOverType)
	{
		IsPlaying = true;
		_gameOverType = gameOverType;
		_currentState = State.Surprise;
		float num = Mathf.Min((float)SingletonMonoBehaviour<ScoreManager>.Instance.CurrentScore / 5000f, 1f);
		_scoreRateTypeNo = Mathf.RoundToInt(num * 3f);
		Debug.Log($"ゲームオーバー scoreRate : {num}, scoreRateTypeNo : {_scoreRateTypeNo}");
		_girlTransform = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform;
		_cameraTransform = SingletonMonoBehaviour<GirlAnimationController>.Instance.CameraTransform;
		_shouldLockCamera = SingletonMonoBehaviour<GirlAnimationController>.Instance.CurrentHeightType == GirlAnimationController.HeightType.Stand;
		if (_shouldLockCamera)
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(GirlBodyAnimationType.Surprise, 0.2f);
		}
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifSurprise);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeFaceAnimation(GirlFaceAnimationType.Surprise, 0.2f);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeSpeed(0f);
		if (gameOverType == GameOverType.TimeUp)
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ShouldLookClassroomClock = true;
		}
		_waitTime = 3f;
		_waitAfterAction = ChangeFace;
		SingletonMonoBehaviour<GameEndProcessor>.Instance.Play();
	}

	private void ChangeFace()
	{
		GirlFaceAnimationType faceAnimationType = GirlFaceAnimationType.Anger;
		if (_gameOverType == GameOverType.TimeUp)
		{
			faceAnimationType = EnumUtility.KeyToType<GirlFaceAnimationType>($"TimeUp{_scoreRateTypeNo + 1}");
		}
		float num = 1.2f;
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeFaceAnimation(faceAnimationType, num);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ShouldLookClassroomClock = false;
		if (SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform.position.y > 0.985f)
		{
			SingletonMonoBehaviour<GirlMoveController>.Instance.Fall(1f, delegate
			{
				_shouldLockCamera = true;
			});
		}
		else
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand, 1f);
			_shouldLockCamera = true;
		}
		PlayVoice();
		_waitTime = num;
		_waitAfterAction = BeginChaiseIfneeded;
	}

	private void PlayVoice()
	{
		_isPlayingVoice = true;
		GirlVoiceType voiceType = GirlVoiceType.SerifLickedGirlGameOver;
		if (_gameOverType == GameOverType.Stole)
		{
			voiceType = GirlVoiceType.SerifStoleGameOver;
		}
		else if (_gameOverType == GameOverType.LickedGirl)
		{
			voiceType = GirlVoiceType.SerifLickedGirlGameOver;
		}
		else if (_gameOverType == GameOverType.TimeUp)
		{
			voiceType = EnumUtility.NoToType<GirlVoiceType>(7 + _scoreRateTypeNo);
		}
		else if (_gameOverType == GameOverType.Found)
		{
			voiceType = EnumUtility.NoToType<GirlVoiceType>(1 + _scoreRateTypeNo);
		}
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(voiceType, FinishVoice);
	}

	private void FinishVoice()
	{
		_isPlayingVoice = false;
		BeginChaiseIfneeded();
	}

	private void BeginChaiseIfneeded()
	{
		if (!_isPlayingVoice && !(_waitTime > 0f))
		{
			SingletonMonoBehaviour<GirlSpeechBubble>.Instance.Hide(1f, BeginChaise);
		}
	}

	private void BeginChaise()
	{
		if (_gameOverType == GameOverType.LickedGirl)
		{
			_currentState = State.KO;
			SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(GirlBodyAnimationType.KO, 0.2f);
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeFaceAnimation(GirlFaceAnimationType.KO);
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeadLookControllerState(isEnabled: false);
			float duration = 0.2f;
			Vector3 eulerAngles = _girlTransform.localRotation.eulerAngles;
			eulerAngles.x = -4f;
			DOTween.Sequence().Append(_girlTransform.DOLocalRotate(eulerAngles, duration)).Join(_girlTransform.DOLocalMoveY(-0.05f, duration))
				.SetDelay(0.2f);
			StartCoroutine(this.DelayMethod(0.16f, delegate
			{
				SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_KO", base.gameObject, is3DSound: true);
				Finish();
			}));
		}
		else
		{
			_currentState = State.Chaise;
			_navMeshAgent.enabled = true;
		}
	}

	private void Update()
	{
		if (!IsPlaying || _isPause)
		{
			return;
		}
		UpdateWait();
		if (_currentState != 0 && _currentState != State.AfterAttack && _currentState != State.KO && _shouldLockCamera)
		{
			Vector3 forward = (SingletonMonoBehaviour<GirlAnimationController>.Instance.ShouldLookClassroomClock ? SingletonMonoBehaviour<ClassroomClock>.Instance.transform : _cameraTransform).position - _girlTransform.position;
			forward.y = 0f;
			Quaternion b = Quaternion.LookRotation(forward);
			_girlTransform.rotation = Quaternion.Slerp(_girlTransform.rotation, b, 0.1f);
		}
		if (_currentState != State.Chaise)
		{
			return;
		}
		Vector3 position = _cameraTransform.position;
		Vector3 position2 = _girlTransform.position;
		position2.y = position.y;
		if (Vector3.Distance(position, position2) < 0.7f)
		{
			_navMeshAgent.enabled = false;
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeSpeed(0f);
			if (_gameOverType == GameOverType.TimeUp)
			{
				Praise();
			}
			else
			{
				Attack();
			}
		}
		else
		{
			_navMeshAgent.destination = position;
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeSpeed(3f);
		}
	}

	private void UpdateWait()
	{
		if (_waitAfterAction != null)
		{
			_waitTime -= Time.deltaTime;
			if (!(_waitTime > 0f))
			{
				Action waitAfterAction = _waitAfterAction;
				_waitAfterAction = null;
				waitAfterAction();
			}
		}
	}

	private void Attack()
	{
		_currentState = State.Attack;
		if (_gameOverType == GameOverType.Stole)
		{
			_attackType = AttackType.ProvocationAttack;
		}
		else
		{
			_attackType = EnumUtility.NoToType<AttackType>(_scoreRateTypeNo);
		}
		float waitTime = 0f;
		if (_attackType == AttackType.ProvocationAttack)
		{
			waitTime = 2.6f;
			_waitTime = 3.55f;
		}
		else if (_attackType == AttackType.HeelDrop)
		{
			waitTime = 0.73f;
			_waitTime = 1.98f;
		}
		else if (_attackType == AttackType.RoundhouseKick)
		{
			waitTime = 0.42f;
			_waitTime = 2.38f;
		}
		else if (_attackType == AttackType.JumpingKick)
		{
			waitTime = 0.55f;
			_waitTime = 1.98f;
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Jump", base.gameObject, is3DSound: true);
		}
		else if (_attackType == AttackType.SummerSalt)
		{
			waitTime = 0.35f;
			_waitTime = 1.83f;
		}
		if (_attackColliderDict.ContainsKey(_attackType))
		{
			_attackColliderDict[_attackType].gameObject.SetActive(value: true);
		}
		else
		{
			Debug.LogError($"{_attackType}のコライダーがありません！");
		}
		SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(EnumUtility.KeyToType<GirlBodyAnimationType>(_attackType.ToString()), 0.1f);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeadLookControllerState(isEnabled: false);
		StartCoroutine(this.DelayMethod(_waitTime, SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeadLookControllerState, t: true));
		StartCoroutine(this.DelayMethod(waitTime, delegate
		{
			SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifAction);
			_shouldHitAttack = true;
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_SwingSlap", base.gameObject, is3DSound: true);
		}));
		_waitAfterAction = AfterAttack;
	}

	private void AfterAttack()
	{
		_currentState = State.AfterAttack;
		_shouldHitAttack = false;
		_attackColliderDict[_attackType].gameObject.SetActive(value: false);
		Finish();
	}

	private void Finish()
	{
		IsPlaying = false;
		SingletonMonoBehaviour<TutorialManager>.Instance.ShowRetrySmartPhoneTargetParticle();
		SingletonMonoBehaviour<HintObject>.Instance.Appear();
		if (_gameOverType != GameOverType.LickedGirl)
		{
			SingletonMonoBehaviour<AfterGameOverGirlManager>.Instance.Play();
		}
	}

	private void Praise()
	{
		_currentState = State.Praise;
		GirlBodyAnimationType girlBodyAnimationType = EnumUtility.NoToType<GirlBodyAnimationType>(17 + _scoreRateTypeNo);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(girlBodyAnimationType, 0.2f);
		if (girlBodyAnimationType == GirlBodyAnimationType.Clap)
		{
			SingletonMonoBehaviour<GirlClapHand>.Instance.IsEnabled = true;
			StartCoroutine(this.DelayMethod(6.85f, delegate
			{
				SingletonMonoBehaviour<GirlClapHand>.Instance.IsEnabled = false;
			}));
		}
		switch (girlBodyAnimationType)
		{
		case GirlBodyAnimationType.NotYet:
			_waitTime = 3.03f;
			break;
		case GirlBodyAnimationType.Clap:
			_waitTime = 7.16f;
			break;
		case GirlBodyAnimationType.Cheer:
			_waitTime = 2.5f;
			break;
		case GirlBodyAnimationType.GlorySpin:
			_waitTime = 6.05f;
			break;
		}
		_waitAfterAction = AfterPraise;
	}

	private void AfterPraise()
	{
		Finish();
	}

	private void OnHitAttack(AttackType attackType, Vector3 hitPosition)
	{
		if (_shouldHitAttack && !_isPause)
		{
			_shouldHitAttack = false;
			_attackColliderDict[_attackType].gameObject.SetActive(value: false);
			_hitParticle.transform.SetParent(SingletonMonoBehaviour<GirlManager>.Instance.transform);
			_hitParticle.transform.position = hitPosition;
			_hitParticle.Play();
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_HitSlap", _hitParticle.gameObject, is3DSound: true);
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstStrike);
		}
	}

	public void Pause()
	{
		_isPause = true;
		_navMeshAgent.enabled = false;
	}

	public void Resume()
	{
		_isPause = false;
		if (_currentState == State.Chaise)
		{
			_navMeshAgent.enabled = true;
		}
	}

	public void PlayAdmirationParticle()
	{
		_admirationSEPlayer.Play();
		_admirationParticle.Play();
	}
}
public class GirlHoldingObjectHolder : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Transform _head;

	[SerializeField]
	[Required]
	private Transform _rightHand;

	private LickableObjectSet _holdingObject;

	private AudioPlayer _flyHoldSEPlayer;

	public Transform Head => _head;

	public Transform RightHand => _rightHand;

	public LickableObjectSet HoldingObject => _holdingObject;

	public LickableObjectType HoldingObjectType
	{
		get
		{
			if (_holdingObject == null)
			{
				Debug.LogWarning("何も掴んでいません");
				return LickableObjectType.Recorder;
			}
			return _holdingObject.ObjectType;
		}
	}

	public bool IsHolding => _holdingObject != null;

	private void Start()
	{
		_flyHoldSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_head.gameObject, "Audio/SE/SE_FlyHold");
	}

	public void Hold(LickableObjectSet targetObject)
	{
		if (_holdingObject != null)
		{
			Debug.LogWarning(_holdingObject.name + "を掴んでるのに" + targetObject.name + "を掴もうとしました");
			Put(0f, Vector3.zero);
		}
		_holdingObject = targetObject;
		_holdingObject.GetComponent<Rigidbody>().isKinematic = true;
		_ = _holdingObject.transform;
		_holdingObject.GetComponent<GrabableObject>().Grabbed += OnGrabbed;
		CheckHold(_holdingObject.ObjectType);
	}

	private void OnGrabbed()
	{
		_holdingObject.GetComponent<GrabableObject>().Grabbed -= OnGrabbed;
		_holdingObject.GetComponent<GrabableObject>().BeforeParent = SingletonMonoBehaviour<LickableObjectManager>.Instance.transform;
		_holdingObject = null;
		if (SingletonMonoBehaviour<GirlManager>.Instance.IsPause)
		{
			SingletonMonoBehaviour<GirlManager>.Instance.Resumed += OnStole;
		}
		else
		{
			SingletonMonoBehaviour<GameManager>.Instance.GameOver(GameOverType.Stole);
		}
	}

	private void OnStole()
	{
		SingletonMonoBehaviour<GirlManager>.Instance.Resumed -= OnStole;
		SingletonMonoBehaviour<GameManager>.Instance.GameOver(GameOverType.Stole);
	}

	public void CheckHold(LickableObjectType lickableObjectType)
	{
		CharacterUtility.CheckHoldingObject(this, lickableObjectType);
	}

	public void PlayFlyHoldSE()
	{
		_flyHoldSEPlayer.Play(1f, 0.5f);
	}

	public void Put(float colliderDelay, Vector3 velocity)
	{
		if (!IsHolding)
		{
			Debug.LogWarning("何も掴んでいないのに離そうとしました");
			return;
		}
		_holdingObject.GetComponent<GrabableObject>().Grabbed -= OnGrabbed;
		_holdingObject.transform.SetParent(SingletonMonoBehaviour<GameManager>.Instance.transform.parent);
		Rigidbody component = _holdingObject.GetComponent<Rigidbody>();
		component.isKinematic = false;
		component.velocity = velocity;
		component.angularVelocity = Vector3.zero;
		if (colliderDelay > 0f)
		{
			Collider[] colliders = _holdingObject.GetComponentsInChildren<Collider>();
			Collider[] array = colliders;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
			StartCoroutine(this.DelayMethod(colliderDelay, delegate
			{
				Collider[] array2 = colliders;
				for (int j = 0; j < array2.Length; j++)
				{
					array2[j].enabled = true;
				}
			}));
		}
		_holdingObject = null;
	}

	public GirlBodyAnimationType GetPutAnimationType()
	{
		if (CharacterUtility.GetHoldingObjectParent(this) == _head)
		{
			if (_holdingObject.ObjectType == LickableObjectType.Glasses || _holdingObject.ObjectType == LickableObjectType.HeadPhone || _holdingObject.ObjectType == LickableObjectType.Usachan || _holdingObject.ObjectType == LickableObjectType.Bra || _holdingObject.ObjectType == LickableObjectType.Burma || _holdingObject.ObjectType == LickableObjectType.Panty)
			{
				return GirlBodyAnimationType.Bow;
			}
			return GirlBodyAnimationType.FlyHold;
		}
		return GirlBodyAnimationType.Put;
	}
}
public class GirlManager : SingletonMonoBehaviour<GirlManager>
{
	private bool _isPause;

	private bool _wasInClassroom = true;

	private bool _wasWithinGameOver = true;

	public Girl Girl { get; private set; }

	public CharacterType CurrentCharacterType { get; private set; }

	public bool IsPause => _isPause;

	public event Action Resumed = delegate
	{
	};

	protected override void Init()
	{
		base.Init();
		CurrentCharacterType = UserDataAccessorManager.SettingDataAccessor.CurrentCharacterType;
		if (CurrentCharacterType == CharacterType.Girl)
		{
			Girl = base.transform.CreateChildFromOriginal<Girl>(Resources.Load<Transform>(System.IO.Path.Combine("Prefab/LickableObject", "Girl")));
		}
		else
		{
			Girl = base.transform.CreateChildFromOriginal<Girl>(Resources.Load<Transform>(System.IO.Path.Combine("Prefab/Character/Main", $"{CurrentCharacterType}")));
		}
		Girl.transform.position = new Vector3(3.5f, 0f, -3f);
		if (SingletonMonoBehaviour<SceneNavigator>.Instance.IsChanging)
		{
			SingletonMonoBehaviour<SceneNavigator>.Instance.FinishedFadeIn += ShowInitialInstruction;
		}
		else
		{
			ShowInitialInstruction();
		}
	}

	private void ShowInitialInstruction()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.FinishedFadeIn -= ShowInitialInstruction;
		StartCoroutine(this.DelayMethod(2f, delegate
		{
			SingletonMonoBehaviour<InstructionManager>.Instance.GiveInstructions(LickableObjectType.Recorder, Girl.SpeechBubbleTarget);
		}));
	}

	private void Update()
	{
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.GameOver)
		{
			return;
		}
		if (!SingletonMonoBehaviour<Tongue>.Instance.IsActive)
		{
			bool flag = IsWithinGameOver();
			if (!flag && _wasWithinGameOver)
			{
				SingletonMonoBehaviour<Tongue>.Instance.ShowIfNeeded();
				SingletonMonoBehaviour<TutorialManager>.Instance.ShowRecorderTargetParticle();
			}
			_wasWithinGameOver = flag;
		}
		bool flag2 = IsInClassroom();
		if (Girl.HoldingObjectHolder.IsHolding && flag2 && !_wasInClassroom)
		{
			SingletonMonoBehaviour<InstructionManager>.Instance.HideIfNeeded();
			SingletonMonoBehaviour<ComboManager>.Instance.Finish();
		}
		else if (!flag2 && _wasInClassroom)
		{
			SingletonMonoBehaviour<InstructionManager>.Instance.HideAnswer();
			StartCoroutine(this.DelayMethod(2f, delegate
			{
				SingletonMonoBehaviour<Tongue>.Instance.ResetState(Tongue.State.Transparent);
			}));
		}
		_wasInClassroom = flag2;
	}

	public bool IsWithinGameOver(bool isLickGirl = false)
	{
		if (_isPause)
		{
			return false;
		}
		if (Girl.transform.localScale.x <= 0f)
		{
			return false;
		}
		if (!isLickGirl && SingletonMonoBehaviour<Tongue>.Instance.IsActiveState(Tongue.State.Transparent))
		{
			return false;
		}
		if (!IsInClassroom())
		{
			return SingletonMonoBehaviour<GirlAnimationController>.Instance.IsLookingCameraDistance();
		}
		return true;
	}

	public bool IsInClassroom()
	{
		Vector3 position = Girl.transform.position;
		if (position.x >= -3.65f && position.x <= 4.33f && position.z >= -3.67f)
		{
			return position.z <= 3.59f;
		}
		return false;
	}

	public void Pause()
	{
		Debug.Log("一時停止");
		SingletonMonoBehaviour<GirlAnimationController>.Instance.Pause();
		SingletonMonoBehaviour<GirlMoveController>.Instance.Pause();
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Pause();
		_isPause = true;
	}

	public void Resume()
	{
		Debug.Log("一時停止から再開");
		SingletonMonoBehaviour<GirlAnimationController>.Instance.Resume();
		SingletonMonoBehaviour<GirlMoveController>.Instance.Resume();
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Resume();
		_isPause = false;
		this.Resumed();
	}
}
public class BackDoorReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(-18.19f, -0.015f, -6.43f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(-5.35f, -0.015f, -6.02f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(-3.7f, -0.015f, -3.06f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(-1.22f, -0.015f, -2.66f);

	private static readonly Vector3 RELAY_POSITION5 = new Vector3(2.22f, -0.015f, -2.53f);

	private static readonly Vector3 RELAY_POSITION6 = new Vector3(3f, -0.015f, -2.53f);

	public override GirlMoverType MoverType => GirlMoverType.BackDoorReturn;

	protected override void Begin()
	{
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3>
		{
			RELAY_POSITION2,
			RELAY_POSITION3,
			RELAY_POSITION4,
			RELAY_POSITION5,
			RELAY_POSITION6,
			InitialGirlMover.INITIAL_POSITION
		}, PathType.CatmullRom, BeginRotateToInitial);
	}
}
public class BackWindowReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(-18.19f, -0.015f, -6.43f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(-18.19f, -0.015f, 5.5f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(-2.94f, -0.015f, 5.5f);

	private static readonly Vector3 JUMP_POSITION = new Vector3(-3.176f, 0.7f, 1.314f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(-3.176f, -0.015f, -2.02f);

	private static readonly Vector3 RELAY_POSITION5 = new Vector3(-1.22f, -0.015f, -2.66f);

	private static readonly Vector3 RELAY_POSITION6 = new Vector3(2.22f, -0.015f, -2.53f);

	private static readonly Vector3 RELAY_POSITION7 = new Vector3(3f, -0.015f, -2.53f);

	public override GirlMoverType MoverType => GirlMoverType.BackWindowReturn;

	protected override void Begin()
	{
		ChangeGirlActive(isActive: false);
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3> { RELAY_POSITION2, RELAY_POSITION3 }, 7.2000003f, PathType.Linear, JumpOverWindow);
	}

	private void JumpOverWindow()
	{
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifAction);
		ChangeGirlActive(isActive: true);
		BeginRotate(new Vector3(0f, 180f, 0f), 0f);
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Jump", _navigator.Girl.position);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.StartCoroutine(SingletonMonoBehaviour<GirlAnimationController>.Instance.DelayMethod(0.88f, delegate
		{
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Landing", _navigator.Girl.position);
		}));
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeBodyAnimation(GirlBodyAnimationType.DiveRoll);
		BeginJump(JUMP_POSITION, 2.2f, 0.6f, 0.28f, delegate
		{
			BeginMove(new List<Vector3>
			{
				RELAY_POSITION4,
				RELAY_POSITION5,
				RELAY_POSITION6,
				RELAY_POSITION7,
				InitialGirlMover.INITIAL_POSITION
			}, PathType.CatmullRom, BeginRotateToInitial);
		});
	}
}
public class CeilingReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION_1 = new Vector3(20.574f, 3.468f, -8.064f);

	private static readonly Vector3 RELAY_POSITION_2 = new Vector3(18.443f, 3.468f, -6.228f);

	private static readonly Vector3 RELAY_POSITION_3 = new Vector3(16.443f, 2.971f, -6.228f);

	private static readonly Vector3 RELAY_POSITION_4 = new Vector3(14.443f, 3.468f, -6.228f);

	private static readonly Vector3 RELAY_POSITION_5 = new Vector3(5.549f, 3.468f, -6.246f);

	private static readonly Vector3 RELAY_POSITION_6 = new Vector3(3.97f, 2.939f, -4.224f);

	private static readonly Vector3 RELAY_POSITION_7 = new Vector3(3.54f, 3.22f, -3.62f);

	public override GirlMoverType MoverType => GirlMoverType.CeilingReturn;

	protected override void Begin()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Creeping);
		BeginRotate(new Vector3(0f, -90f, 180f), 0f);
		Warp(RELAY_POSITION_1);
		BeginMove(new List<Vector3> { RELAY_POSITION_2, RELAY_POSITION_3, RELAY_POSITION_4, RELAY_POSITION_5, RELAY_POSITION_6, RELAY_POSITION_7 }, PathType.CatmullRom, Fall);
	}

	private void Fall()
	{
		BeginFall(InitialGirlMover.INITIAL_POSITION, InitialGirlMover.INITIAL_ROTATION, 1f, BeginRotateToInitial);
	}
}
public class CorridorBackWindowReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(-18.19f, -0.015f, -6.43f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(-10.15f, -0.015f, -5.81f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(-4.87f, -0.015f, -6.56f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(-1.985f, -0.015f, -4.694f);

	private static readonly Vector3 JUMP_POSITION = new Vector3(-1.554f, 0.7f, -1.188f);

	private static readonly Vector3 RELAY_POSITION5 = new Vector3(3.09f, -0.015f, -1.188f);

	public override GirlMoverType MoverType => GirlMoverType.CorridorBackWindowReturn;

	protected override void Begin()
	{
		Warp(RELAY_POSITION1);
		BeginAccelerationMove(new List<Vector3> { RELAY_POSITION2, RELAY_POSITION3, RELAY_POSITION4 }, PathType.CatmullRom, JumpOverWindow);
	}

	private void JumpOverWindow()
	{
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifAction);
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Jump", _navigator.Girl.position);
		float num = 0.25f;
		SingletonMonoBehaviour<GirlAnimationController>.Instance.StartCoroutine(SingletonMonoBehaviour<GirlAnimationController>.Instance.DelayMethod(num, delegate
		{
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Landing", _navigator.Girl.position);
		}));
		SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(GirlBodyAnimationType.DiveRollShort, 0.1f);
		BeginJump(JUMP_POSITION, num + 1.6f, num, 0f, delegate
		{
			BeginMove(new List<Vector3>
			{
				RELAY_POSITION5,
				InitialGirlMover.INITIAL_POSITION
			}, PathType.CatmullRom, BeginRotateToInitial);
		});
	}
}
public class CorridorWindowReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(-18.19f, -0.015f, -6.43f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(-10.15f, -0.015f, -5.81f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(-0.88f, -0.015f, -6.56f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(2.005f, -0.015f, -4.694f);

	private static readonly Vector3 JUMP_POSITION = new Vector3(2.436f, 0.7f, -1.188f);

	private static readonly Vector3 RELAY_POSITION5 = new Vector3(3.38f, -0.015f, -1.55f);

	public override GirlMoverType MoverType => GirlMoverType.CorridorWindowReturn;

	protected override void Begin()
	{
		Warp(RELAY_POSITION1);
		BeginAccelerationMove(new List<Vector3> { RELAY_POSITION2, RELAY_POSITION3, RELAY_POSITION4 }, PathType.CatmullRom, JumpOverWindow);
	}

	private void JumpOverWindow()
	{
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifAction);
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Jump", _navigator.Girl.position);
		float num = 0.25f;
		SingletonMonoBehaviour<GirlAnimationController>.Instance.StartCoroutine(SingletonMonoBehaviour<GirlAnimationController>.Instance.DelayMethod(num, delegate
		{
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Landing", _navigator.Girl.position);
		}));
		SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(GirlBodyAnimationType.DiveRollShort, 0.1f);
		BeginJump(JUMP_POSITION, num + 1.6f, num, 0f, delegate
		{
			BeginMove(new List<Vector3>
			{
				RELAY_POSITION5,
				InitialGirlMover.INITIAL_POSITION
			}, PathType.CatmullRom, BeginRotateToInitial);
		});
	}
}
public class CreepingReturnGirlMover : NormalReturnGirlMover
{
	private bool _isStand;

	public override GirlMoverType MoverType => GirlMoverType.CreepingReturn;

	public override void Update()
	{
		base.Update();
		if (!_isStand && SingletonMonoBehaviour<GirlManager>.Instance.IsInClassroom())
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand, 0.5f);
			_isStand = true;
		}
	}

	protected override void Begin()
	{
		_isStand = false;
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Creeping);
		base.Begin();
	}

	protected override void BeginRotateToInitial()
	{
		base.BeginRotateToInitial();
	}
}
public class CrouchingReturnGirlMover : NormalReturnGirlMover
{
	private bool _isStand;

	public override GirlMoverType MoverType => GirlMoverType.CrouchingReturn;

	public override void Update()
	{
		base.Update();
		if (!_isStand && SingletonMonoBehaviour<GirlManager>.Instance.IsInClassroom())
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand, 0.5f);
			_isStand = true;
		}
	}

	protected override void Begin()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Crouching);
		base.Begin();
	}

	protected override void BeginRotateToInitial()
	{
		base.BeginRotateToInitial();
	}
}
public class GarbageBoxReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(20.71f, -0.015f, -8.93f);

	private static readonly Vector3 BOX_POSITION = new Vector3(4.55f, -1.122f, -3.404f);

	public override GirlMoverType MoverType => GirlMoverType.GarbageBoxReturn;

	protected override void Begin()
	{
		ChangeGirlActive(isActive: false);
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3> { BOX_POSITION }, 1.77f, PathType.Linear, Appear);
	}

	private void Appear()
	{
		ChangeGirlActive(isActive: true);
		BeginRotate(new Vector3(0f, -90f, 0f), 0f);
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifAction);
		float num = 0.5f;
		Transform girl = _navigator.Girl;
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Jump", girl.position);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.StartCoroutine(SingletonMonoBehaviour<GirlAnimationController>.Instance.DelayMethod(num, delegate
		{
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_LandingShort", _navigator.Girl.position);
		}));
		girl.localScale = Vector3.one * 0.3f;
		girl.DOScale(Vector3.one, 0.3f).SetDelay(0.1f);
		Vector3 iNITIAL_POSITION = InitialGirlMover.INITIAL_POSITION;
		iNITIAL_POSITION.y += 0.2f;
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeBodyAnimation(GirlBodyAnimationType.Jump);
		BeginVerticalJump(iNITIAL_POSITION, 0.9f, num, 0.1f, BeginRotateToInitial);
	}
}
public class GirlMoveController : SingletonMonoBehaviour<GirlMoveController>
{
	[SerializeField]
	[Required]
	private GirlNavigator _navigator;

	private GirlMover _currentMover;

	private readonly List<List<GirlMoverType>> _returnMoverTypeList = new List<List<GirlMoverType>>
	{
		new List<GirlMoverType> { GirlMoverType.NormalReturn },
		new List<GirlMoverType>
		{
			GirlMoverType.ReverseReturn,
			GirlMoverType.BackDoorReturn
		},
		new List<GirlMoverType>
		{
			GirlMoverType.CreepingReturn,
			GirlMoverType.ReverseCreepingReturn,
			GirlMoverType.CrouchingReturn,
			GirlMoverType.ReverseCrouchingReturn
		},
		new List<GirlMoverType>
		{
			GirlMoverType.CorridorBackWindowReturn,
			GirlMoverType.CorridorWindowReturn
		},
		new List<GirlMoverType>
		{
			GirlMoverType.WindowReturn,
			GirlMoverType.BackWindowReturn
		},
		new List<GirlMoverType>
		{
			GirlMoverType.CeilingReturn,
			GirlMoverType.ReverseCeilingReturn
		},
		new List<GirlMoverType>
		{
			GirlMoverType.LockerReturn,
			GirlMoverType.ShelfReturn,
			GirlMoverType.GarbageBoxReturn,
			GirlMoverType.TeacherReturn
		}
	};

	private int _returnCount;

	private readonly Dictionary<GirlMoverType, float> _moveTimeDict = new Dictionary<GirlMoverType, float>
	{
		{
			GirlMoverType.Homecoming,
			12.7f
		},
		{
			GirlMoverType.NormalReturn,
			18.4f
		},
		{
			GirlMoverType.ReverseReturn,
			18.4f
		},
		{
			GirlMoverType.BackDoorReturn,
			18.4f
		},
		{
			GirlMoverType.CreepingReturn,
			18.4f
		},
		{
			GirlMoverType.ReverseCreepingReturn,
			18.5f
		},
		{
			GirlMoverType.CrouchingReturn,
			18.4f
		},
		{
			GirlMoverType.ReverseCrouchingReturn,
			18.5f
		},
		{
			GirlMoverType.WindowReturn,
			20f
		},
		{
			GirlMoverType.BackWindowReturn,
			20f
		},
		{
			GirlMoverType.CorridorBackWindowReturn,
			20.2f
		},
		{
			GirlMoverType.CorridorWindowReturn,
			20.1f
		},
		{
			GirlMoverType.CeilingReturn,
			19.4f
		},
		{
			GirlMoverType.ReverseCeilingReturn,
			19.3f
		},
		{
			GirlMoverType.GarbageBoxReturn,
			22f
		},
		{
			GirlMoverType.TeacherReturn,
			22.1f
		},
		{
			GirlMoverType.LockerReturn,
			21.9f
		},
		{
			GirlMoverType.ShelfReturn,
			22.1f
		}
	};

	private bool _isTimeUp;

	public IObservable<float> CurrentSpeedObservable => _navigator.CurrentSpeedObservable;

	private void Start()
	{
		StartCoroutine(this.DelayMethod(0.01f, BeginMove));
	}

	private void FixedUpdate()
	{
		if (_currentMover != null)
		{
			_currentMover.Update();
			if (_isTimeUp)
			{
				PlayTimeUpGameOverIfNeeded();
			}
		}
	}

	private void BeginMove()
	{
		GirlMover nextMover = GetNextMover();
		if (_currentMover != null && _currentMover.MoverType == nextMover.MoverType)
		{
			Debug.LogWarning($"{_currentMover.MoverType}が連続で発生したので移動しません");
			return;
		}
		_currentMover = nextMover;
		_currentMover.Play(_navigator, BeginMove);
		Debug.Log($"BeginMove : {_currentMover.MoverType}");
	}

	private GirlMover GetNextMover()
	{
		GirlMoverType moverType = GirlMoverType.Initial;
		if (_currentMover != null)
		{
			moverType = ((_currentMover.MoverType != GirlMoverType.Homecoming) ? GirlMoverType.Homecoming : GetNextReturnMoverType());
		}
		return GetMover(moverType);
	}

	private GirlMoverType GetNextReturnMoverType()
	{
		int num = 0;
		if (_returnCount >= 0 && _returnCount < _returnMoverTypeList.Count)
		{
			num = _returnCount;
		}
		Debug.Log($"次の教室へ戻る移動タイプ, _returnCount : {_returnCount}, moveGroupNo : {num}");
		_returnCount++;
		return _returnMoverTypeList[num].GetAtRandom();
	}

	private GirlMover GetMover(GirlMoverType moverType)
	{
		switch (moverType)
		{
		case GirlMoverType.Initial:
			return new InitialGirlMover();
		case GirlMoverType.Homecoming:
			return new HomecomingGirlMover();
		case GirlMoverType.NormalReturn:
			return new NormalReturnGirlMover();
		case GirlMoverType.ReverseReturn:
			return new ReverseReturnGirlMover();
		case GirlMoverType.WindowReturn:
			return new WindowReturnGirlMover();
		case GirlMoverType.BackDoorReturn:
			return new BackDoorReturnGirlMover();
		case GirlMoverType.BackWindowReturn:
			return new BackWindowReturnGirlMover();
		case GirlMoverType.CorridorBackWindowReturn:
			return new CorridorBackWindowReturnGirlMover();
		case GirlMoverType.CorridorWindowReturn:
			return new CorridorWindowReturnGirlMover();
		case GirlMoverType.GarbageBoxReturn:
			return new GarbageBoxReturnGirlMover();
		case GirlMoverType.CrouchingReturn:
			return new CrouchingReturnGirlMover();
		case GirlMoverType.ReverseCrouchingReturn:
			return new ReverseCrouchingReturnGirlMover();
		case GirlMoverType.CreepingReturn:
			return new CreepingReturnGirlMover();
		case GirlMoverType.ReverseCreepingReturn:
			return new ReverseCreepingReturnGirlMover();
		case GirlMoverType.TeacherReturn:
			return new TeacherReturnGirlMover();
		case GirlMoverType.LockerReturn:
			return new LockerReturnGirlMover();
		case GirlMoverType.ShelfReturn:
			return new ShelfReturnGirlMover();
		case GirlMoverType.CeilingReturn:
			return new CeilingReturnGirlMover();
		case GirlMoverType.ReverseCeilingReturn:
			return new ReverseCeilingReturnGirlMover();
		default:
			Debug.LogWarning($"{moverType}に対応するGirlMoverはありません");
			return new NormalReturnGirlMover();
		}
	}

	public void Fall(float duration, Action callback = null)
	{
		Vector3 position = _navigator.Girl.position;
		position.y = -0.015f;
		_navigator.BeginFall(position, InitialGirlMover.INITIAL_ROTATION, duration, callback);
	}

	public void Pause()
	{
		_navigator.Pause();
		_currentMover?.Pause();
	}

	public void Resume()
	{
		_navigator.Resume();
		_currentMover?.Resume();
	}

	public void TimeUp()
	{
		_isTimeUp = true;
		PlayTimeUpGameOverIfNeeded();
	}

	public void GameOver(GameOverType gameOverType)
	{
		SingletonMonoBehaviour<GirlGameOverActionPlayer>.Instance.PlayAdmirationParticle();
		if (_currentMover == null)
		{
			Debug.Log("GirlMoveController GameOver No Kill");
		}
		else
		{
			Debug.Log("GirlMoveController GameOver Kill");
			_currentMover.Stop();
			_currentMover = null;
		}
		SingletonMonoBehaviour<GirlGameOverActionPlayer>.Instance.Play(gameOverType);
	}

	private void PlayTimeUpGameOverIfNeeded()
	{
		Transform transform = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform;
		if (!(transform.transform.localScale.x <= 0f))
		{
			Vector3 position = transform.position;
			Vector3 position2 = SingletonMonoBehaviour<ClassroomClock>.Instance.transform.position;
			position.y = 0f;
			position2.y = 0f;
			if (!(Vector3.Distance(position, position2) >= 3.8f))
			{
				GameOver(GameOverType.TimeUp);
			}
		}
	}
}
public abstract class GirlMover
{
	private enum State
	{
		None,
		Move,
		Rotate,
		Put,
		Wait
	}

	public const float FLOOR_Y = -0.015f;

	protected GirlNavigator _navigator;

	private Action _lastCallback;

	private Action _stateCallback;

	private bool _isPause;

	private Sequence _rotateSequence;

	private float _movingTime;

	private State _currentState;

	public const float SPEED = 3f;

	private float _waitTime;

	private float _waitLimit;

	public abstract GirlMoverType MoverType { get; }

	public void Play(GirlNavigator navigator, Action callback)
	{
		_navigator = navigator;
		_lastCallback = callback;
		_movingTime = 0f;
		ChangeGirlActive(isActive: true);
		BeginPreprocessing();
		Begin();
	}

	protected virtual void BeginPreprocessing()
	{
	}

	protected abstract void Begin();

	protected void Finish()
	{
		Debug.Log($"移動時間 : {MoverType} : {_movingTime}");
		_lastCallback();
	}

	protected void ChangeGirlActive(bool isActive)
	{
		_navigator.ChangeGirlActive(isActive);
	}

	private void BeginState(State state, Action callback)
	{
		_currentState = state;
		_stateCallback = callback;
	}

	private void FinishState()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeBodyAnimation(GirlBodyAnimationType.Normal);
		SingletonMonoBehaviour<GirlManager>.Instance.Girl.IsInvincible = false;
		_currentState = State.None;
		_stateCallback?.Invoke();
	}

	public virtual void Update()
	{
		if (!_isPause)
		{
			_movingTime += Time.deltaTime;
			if (_currentState == State.Wait)
			{
				Wait();
			}
		}
	}

	protected void Warp(Vector3 goalPoint)
	{
		BeginMove(new List<Vector3> { goalPoint }, 0f);
	}

	protected void BeginMove(List<Vector3> goalPointList, PathType pathType = PathType.CatmullRom, Action callback = null)
	{
		float num = 3f;
		if (MoverType == GirlMoverType.NormalReturn || MoverType == GirlMoverType.CrouchingReturn || MoverType == GirlMoverType.CreepingReturn || MoverType == GirlMoverType.CeilingReturn)
		{
			num *= 0.81f;
		}
		BeginMove(goalPointList, num, pathType, callback);
	}

	protected void BeginAccelerationMove(List<Vector3> goalPointList, PathType pathType = PathType.CatmullRom, Action callback = null)
	{
		BeginState(State.Move, callback);
		_navigator.BeginAccelerationMove(goalPointList, 3f, pathType, FinishState);
	}

	protected void BeginMove(List<Vector3> goalPointList, float speed, PathType pathType = PathType.CatmullRom, Action callback = null)
	{
		BeginState(State.Move, callback);
		_navigator.BeginMove(goalPointList, speed, pathType, FinishState);
	}

	protected void BeginJump(Vector3 goalPoint, float moveDuration, float jumpDuration, float delay, Action callback = null)
	{
		SingletonMonoBehaviour<GirlManager>.Instance.Girl.IsInvincible = true;
		BeginState(State.Move, callback);
		_navigator.BeginJump(goalPoint, moveDuration, jumpDuration, delay, FinishState);
	}

	protected void BeginVerticalJump(Vector3 goalPoint, float moveDuration, float jumpDuration, float delay, Action callback = null)
	{
		SingletonMonoBehaviour<GirlManager>.Instance.Girl.IsInvincible = true;
		BeginState(State.Move, callback);
		_navigator.BeginVerticalJump(goalPoint, moveDuration, jumpDuration, delay, FinishState);
	}

	protected void BeginFall(Vector3 position, Vector3 rotation, float fallDuration, Action callback = null)
	{
		SingletonMonoBehaviour<GirlManager>.Instance.Girl.IsInvincible = true;
		BeginState(State.Move, callback);
		_navigator.BeginFall(position, rotation, fallDuration, FinishState);
	}

	protected void BeginRotate(Vector3 targetRotation, float duration, Action callback = null)
	{
		BeginState(State.Rotate, callback);
		if (duration <= 0f)
		{
			_navigator.Girl.rotation = Quaternion.Euler(targetRotation);
			FinishState();
			return;
		}
		_rotateSequence = DOTween.Sequence().Append(_navigator.Girl.DORotate(targetRotation, duration)).OnComplete(delegate
		{
			_rotateSequence = null;
			FinishState();
		});
		_rotateSequence.Play();
	}

	protected void BeginWait(float waitLimit, Action callback)
	{
		BeginState(State.Wait, callback);
		_waitTime = 0f;
		_waitLimit = waitLimit;
	}

	private void Wait()
	{
		if (!SingletonMonoBehaviour<SceneNavigator>.Instance.IsChanging)
		{
			_waitTime += Time.deltaTime;
			if (_waitTime >= _waitLimit)
			{
				FinishState();
			}
		}
	}

	public void Pause()
	{
		_isPause = true;
		_rotateSequence?.Pause();
	}

	public void Resume()
	{
		_isPause = false;
		_navigator.Resume();
		_rotateSequence?.Play();
	}

	public void Stop()
	{
		_navigator.Stop();
		if (_rotateSequence == null)
		{
			Debug.Log("GirlMover Stop No Kill");
			return;
		}
		Debug.Log("GirlMover Stop Kill");
		_rotateSequence.Kill();
	}
}
public class HomecomingGirlMover : GirlMover
{
	public static readonly Vector3 RELAY_POSITION_1 = new Vector3(4.044f, -0.015f, -3.736f);

	public static readonly Vector3 RELAY_POSITION_2 = new Vector3(5.78f, -0.015f, -5.62f);

	public static readonly Vector3 RELAY_POSITION_3 = new Vector3(17.69f, -0.015f, -6.32f);

	public static readonly Vector3 GOAL_POSITION = new Vector3(20.71f, -0.015f, -8.93f);

	private readonly bool _isSkip;

	private bool _isWaitGameStart;

	private bool _isWaitGameEnd;

	public override GirlMoverType MoverType => GirlMoverType.Homecoming;

	public HomecomingGirlMover(bool isSkip = false)
	{
		_isSkip = isSkip;
	}

	public override void Update()
	{
		if (_isWaitGameStart)
		{
			if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.Playing)
			{
				_isWaitGameStart = false;
				BeginWait();
			}
		}
		else if (_isWaitGameEnd)
		{
			if (SingletonMonoBehaviour<GameManager>.Instance.ElapsedTimeRate >= 1f)
			{
				_isWaitGameEnd = false;
				Finish();
			}
		}
		else
		{
			base.Update();
		}
	}

	protected override void Begin()
	{
		if (_isSkip)
		{
			Warp(GOAL_POSITION);
			BeginWait();
		}
		else
		{
			BeginRotate(new Vector3(0f, -260.939f, 0f), 0.5f, BeginRun);
		}
	}

	private void BeginRun()
	{
		BeginMove(new List<Vector3> { RELAY_POSITION_1, RELAY_POSITION_2, RELAY_POSITION_3, GOAL_POSITION }, PathType.CatmullRom, BeginWait);
	}

	private void BeginWait()
	{
		ChangeGirlActive(isActive: false);
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState != GameManager.State.Playing)
		{
			_isWaitGameStart = true;
		}
		else if ((float)SingletonMonoBehaviour<InstructionManager>.Instance.InstructionCount >= 8f && SingletonMonoBehaviour<GameManager>.Instance.ElapsedTimeRate < 1f)
		{
			_isWaitGameEnd = true;
		}
		else
		{
			BeginWait(2f, base.Finish);
		}
	}
}
public class InitialGirlMover : GirlMover
{
	public static readonly Vector3 INITIAL_POSITION = new Vector3(3.343f, -0.015f, -3.332f);

	public static readonly Vector3 INITIAL_ROTATION = new Vector3(0f, -90f, 0f);

	public override GirlMoverType MoverType => GirlMoverType.Initial;

	protected override void Begin()
	{
		Warp(INITIAL_POSITION);
		BeginRotate(INITIAL_ROTATION, 0f);
		if (SingletonMonoBehaviour<SceneNavigator>.Instance.IsChanging)
		{
			SingletonMonoBehaviour<SceneNavigator>.Instance.FinishedFadeIn += BeginWait;
		}
		else
		{
			BeginWait();
		}
	}

	private void BeginWait()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.FinishedFadeIn -= BeginWait;
		Action callback = delegate
		{
			SingletonMonoBehaviour<GirlSpeechBubble>.Instance.Hide();
			Finish();
		};
		BeginWait(5f, callback);
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.StartCoroutine(SingletonMonoBehaviour<GirlVoicePlayer>.Instance.DelayMethod(0.5f, delegate
		{
			SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifStartGame);
		}));
	}
}
public class LockerReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(20.71f, -0.015f, -8.93f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(-4.718f, -0.015f, -8.93f);

	private static readonly Vector3 LOCKER_POSITION = new Vector3(-4.718f, -0.015f, -3.562f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(-1.22f, -0.015f, -2.66f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(2.22f, -0.015f, -2.53f);

	private static readonly Vector3 RELAY_POSITION5 = new Vector3(3f, -0.015f, -2.53f);

	public override GirlMoverType MoverType => GirlMoverType.LockerReturn;

	protected override void Begin()
	{
		ChangeGirlActive(isActive: false);
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3> { RELAY_POSITION2, LOCKER_POSITION }, 4.17f, PathType.Linear, Appear);
	}

	private void Appear()
	{
		ChangeGirlActive(isActive: true);
		BeginRotate(new Vector3(0f, 90f, 0f), 0f);
		SingletonMonoBehaviour<LockerDoor>.Instance.Open();
		BeginMove(new List<Vector3>
		{
			RELAY_POSITION3,
			RELAY_POSITION4,
			RELAY_POSITION5,
			InitialGirlMover.INITIAL_POSITION
		}, PathType.CatmullRom, BeginRotateToInitial);
	}
}
public class NormalReturnGirlMover : ReturnGirlMover
{
	public override GirlMoverType MoverType => GirlMoverType.NormalReturn;

	protected override void Begin()
	{
		Warp(HomecomingGirlMover.GOAL_POSITION);
		BeginMove(new List<Vector3>
		{
			HomecomingGirlMover.RELAY_POSITION_3,
			HomecomingGirlMover.RELAY_POSITION_2,
			HomecomingGirlMover.RELAY_POSITION_1,
			InitialGirlMover.INITIAL_POSITION
		}, PathType.CatmullRom, BeginRotateToInitial);
	}
}
public abstract class ReturnGirlMover : GirlMover
{
	protected override void BeginPreprocessing()
	{
		base.BeginPreprocessing();
		if ((float)SingletonMonoBehaviour<InstructionManager>.Instance.InstructionCount < 8f)
		{
			SingletonMonoBehaviour<GirlManager>.Instance.Girl.Hold(SingletonMonoBehaviour<LickableObjectManager>.Instance.GetGirlHoldingObject());
		}
	}

	protected virtual void BeginRotateToInitial()
	{
		BeginRotate(InitialGirlMover.INITIAL_ROTATION, 0.5f, FinishRotateToInitial);
	}

	protected virtual void FinishRotateToInitial()
	{
		BeginWait(1f, Put);
	}

	private void Put()
	{
		SingletonMonoBehaviour<GirlManager>.Instance.Girl.PutIfNeeded(delegate
		{
			BeginWait(3.5f, base.Finish);
		});
	}
}
public class ReverseCeilingReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION_1 = new Vector3(-18.19f, 3.468f, -6.43f);

	private static readonly Vector3 RELAY_POSITION_2 = new Vector3(1.5f, 3.468f, -6.43f);

	private static readonly Vector3 RELAY_POSITION_3 = new Vector3(3.97f, 2.939f, -4.224f);

	private static readonly Vector3 RELAY_POSITION_4 = new Vector3(3.54f, 3.22f, -3.62f);

	public override GirlMoverType MoverType => GirlMoverType.ReverseCeilingReturn;

	protected override void Begin()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Creeping);
		BeginRotate(new Vector3(0f, -90f, 180f), 0f);
		Warp(RELAY_POSITION_1);
		BeginMove(new List<Vector3> { RELAY_POSITION_2, RELAY_POSITION_3, RELAY_POSITION_4 }, PathType.CatmullRom, Fall);
	}

	private void Fall()
	{
		BeginFall(InitialGirlMover.INITIAL_POSITION, InitialGirlMover.INITIAL_ROTATION, 1f, BeginRotateToInitial);
	}
}
public class ReverseCreepingReturnGirlMover : ReverseReturnGirlMover
{
	private bool _isStand;

	public override GirlMoverType MoverType => GirlMoverType.ReverseCreepingReturn;

	public override void Update()
	{
		base.Update();
		if (!_isStand && SingletonMonoBehaviour<GirlManager>.Instance.IsInClassroom())
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand, 0.5f);
			_isStand = true;
		}
	}

	protected override void Begin()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Creeping);
		base.Begin();
	}

	protected override void BeginRotateToInitial()
	{
		base.BeginRotateToInitial();
	}
}
public class ReverseCrouchingReturnGirlMover : ReverseReturnGirlMover
{
	private bool _isStand;

	public override GirlMoverType MoverType => GirlMoverType.ReverseCrouchingReturn;

	public override void Update()
	{
		base.Update();
		if (!_isStand && SingletonMonoBehaviour<GirlManager>.Instance.IsInClassroom())
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand, 0.5f);
			_isStand = true;
		}
	}

	protected override void Begin()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Crouching);
		base.Begin();
	}

	protected override void BeginRotateToInitial()
	{
		base.BeginRotateToInitial();
	}
}
public class ReverseReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(-18.19f, -0.015f, -6.43f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(-3.13f, -0.015f, -6.03f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(3.031f, -0.015f, -5.512f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(4.03f, -0.015f, -3.809f);

	public override GirlMoverType MoverType => GirlMoverType.ReverseReturn;

	protected override void Begin()
	{
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3>
		{
			RELAY_POSITION2,
			RELAY_POSITION3,
			RELAY_POSITION4,
			InitialGirlMover.INITIAL_POSITION
		}, PathType.CatmullRom, BeginRotateToInitial);
	}
}
public class ShelfReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(20.71f, -0.015f, -8.93f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(20.71f, -0.015f, 2.71f);

	private static readonly Vector3 SHELF_POSITION = new Vector3(5.269f, -0.015f, 2.71f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(2.426f, -0.015f, 2.652f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(2.312f, -0.015f, -1.093f);

	private static readonly Vector3 RELAY_POSITION5 = new Vector3(3.343f, -0.015f, -1.5f);

	public override GirlMoverType MoverType => GirlMoverType.ShelfReturn;

	protected override void Begin()
	{
		ChangeGirlActive(isActive: false);
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3> { RELAY_POSITION2, SHELF_POSITION }, 3.75f, PathType.Linear, Appear);
	}

	private void Appear()
	{
		ChangeGirlActive(isActive: true);
		BeginRotate(new Vector3(0f, -90f, 0f), 0f);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Creeping);
		SingletonMonoBehaviour<ShelfDoor>.Instance.Open();
		Transform girl = _navigator.Girl;
		girl.localScale = Vector3.one * 0.8f;
		girl.DOScale(Vector3.one, 0.3f).SetDelay(0.2f);
		BeginMove(new List<Vector3>
		{
			RELAY_POSITION3,
			RELAY_POSITION4,
			RELAY_POSITION5,
			InitialGirlMover.INITIAL_POSITION
		}, PathType.CatmullRom, BeginRotateToInitial);
	}

	protected override void BeginRotateToInitial()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand, 0.5f);
		base.BeginRotateToInitial();
	}
}
public class TeacherReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(20.71f, -0.015f, -8.93f);

	private static readonly Vector3 TEACHER_POSITION = new Vector3(3.551f, 0.156f, -0.018f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(4.285f, 0.156f, -0.018f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(3.972f, 0.156f, -1.778f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(3.825f, -0.015f, -2.051f);

	public override GirlMoverType MoverType => GirlMoverType.TeacherReturn;

	protected override void Begin()
	{
		ChangeGirlActive(isActive: false);
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3> { TEACHER_POSITION }, 2.16f, PathType.Linear, Appear);
	}

	private void Appear()
	{
		ChangeGirlActive(isActive: true);
		BeginRotate(new Vector3(0f, 72f, 0f), 0f);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Crouching);
		Transform girl = _navigator.Girl;
		girl.localScale = Vector3.one * 0.6f;
		girl.DOScale(Vector3.one, 0.2f).SetDelay(0.5f);
		BeginMove(new List<Vector3>
		{
			RELAY_POSITION2,
			RELAY_POSITION3,
			RELAY_POSITION4,
			InitialGirlMover.INITIAL_POSITION
		}, PathType.CatmullRom, BeginRotateToInitial);
	}

	protected override void BeginRotateToInitial()
	{
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand, 0.5f);
		base.BeginRotateToInitial();
	}
}
public class WindowReturnGirlMover : ReturnGirlMover
{
	private static readonly Vector3 RELAY_POSITION1 = new Vector3(20.71f, -0.015f, -8.93f);

	private static readonly Vector3 RELAY_POSITION2 = new Vector3(20.71f, -0.015f, 4.734f);

	private static readonly Vector3 RELAY_POSITION3 = new Vector3(1.91f, -0.015f, 5.5f);

	private static readonly Vector3 JUMP_POSITION = new Vector3(2.305f, 0.7f, 1.314f);

	private static readonly Vector3 RELAY_POSITION4 = new Vector3(2.164f, -0.015f, -2.624f);

	private static readonly Vector3 RELAY_POSITION5 = new Vector3(3.343f, -0.015f, -2.624f);

	public override GirlMoverType MoverType => GirlMoverType.WindowReturn;

	protected override void Begin()
	{
		ChangeGirlActive(isActive: false);
		Warp(RELAY_POSITION1);
		BeginMove(new List<Vector3> { RELAY_POSITION2, RELAY_POSITION3 }, 6f, PathType.Linear, JumpOverWindow);
	}

	private void JumpOverWindow()
	{
		SingletonMonoBehaviour<GirlVoicePlayer>.Instance.Play(GirlVoiceType.SerifAction);
		ChangeGirlActive(isActive: true);
		BeginRotate(new Vector3(0f, 180f, 0f), 0f);
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Jump", _navigator.Girl.position);
		SingletonMonoBehaviour<GirlAnimationController>.Instance.StartCoroutine(SingletonMonoBehaviour<GirlAnimationController>.Instance.DelayMethod(0.88f, delegate
		{
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Landing", _navigator.Girl.position);
		}));
		SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeBodyAnimation(GirlBodyAnimationType.DiveRoll);
		BeginJump(JUMP_POSITION, 2.2f, 0.6f, 0.28f, delegate
		{
			BeginMove(new List<Vector3>
			{
				RELAY_POSITION4,
				RELAY_POSITION5,
				InitialGirlMover.INITIAL_POSITION
			}, PathType.CatmullRom, BeginRotateToInitial);
		});
	}
}
public class GirlNavigator : MonoBehaviour
{
	private Rigidbody _rigidbody;

	private ReactiveProperty<float> _currentSpeed = new ReactiveProperty<float>(0f);

	[SerializeField]
	private AnimationCurve _moveSpeedCurve;

	[SerializeField]
	private AnimationCurve _accelerationMoveSpeedCurve;

	[SerializeField]
	private AnimationCurve _fallSpeedCurve;

	[SerializeField]
	private AnimationCurve _jumpXZCurve;

	[SerializeField]
	private AnimationCurve _jumpYCurve;

	[SerializeField]
	private AnimationCurve _verticalJumpXZCurve;

	private Transform _jumpParent;

	private Sequence _moveSequence;

	private Vector3 _beforePosition;

	private float _beforeTime;

	public Transform Girl => _rigidbody.transform;

	public float CurrentSpeed => _currentSpeed.Value;

	public IObservable<float> CurrentSpeedObservable => _currentSpeed;

	private void Start()
	{
		_rigidbody = SingletonMonoBehaviour<GirlManager>.Instance.Girl.GetComponent<Rigidbody>();
	}

	private void OnMove()
	{
		Vector3 position = _rigidbody.transform.position;
		float time = Time.time;
		float num = Vector3.Distance(position, _beforePosition);
		float num2 = time - _beforeTime;
		float num3 = num / num2;
		_currentSpeed.Value = CurrentSpeed * 0.7f + num3 * 0.3f;
		_beforePosition = position;
		_beforeTime = time;
	}

	public void ChangeGirlActive(bool isActive)
	{
		_rigidbody.transform.localScale = (isActive ? Vector3.one : Vector3.zero);
	}

	public void BeginMove(List<Vector3> goalPointList, float speed, PathType pathType = PathType.CatmullRom, Action callback = null)
	{
		BeginMove(goalPointList, speed, _moveSpeedCurve, pathType, callback);
	}

	public void BeginAccelerationMove(List<Vector3> goalPointList, float speed, PathType pathType = PathType.CatmullRom, Action callback = null)
	{
		BeginMove(goalPointList, speed, _accelerationMoveSpeedCurve, pathType, callback);
	}

	private void BeginMove(List<Vector3> goalPointList, float speed, AnimationCurve moveCurve, PathType pathType, Action callback = null)
	{
		Debug.Log("GirlNavigator Begin Move");
		_moveSequence?.Kill();
		_currentSpeed.Value = 0f;
		if (speed <= 0f)
		{
			_rigidbody.transform.position = goalPointList[goalPointList.Count - 1];
			callback?.Invoke();
			return;
		}
		Vector3 a = _rigidbody.transform.position;
		float num = 0f;
		foreach (Vector3 goalPoint in goalPointList)
		{
			num += Vector3.Distance(a, goalPoint);
			a = goalPoint;
		}
		float num2 = 1.5f * num / speed;
		Debug.Log($"duration : {num2}, speed : {speed}");
		_beforePosition = _rigidbody.transform.position;
		_beforeTime = Time.time;
		_moveSequence = DOTween.Sequence().Append(_rigidbody.DOPath(goalPointList.ToArray(), num2, pathType).SetEase(moveCurve).SetLookAt(0.05f, Vector3.forward)
			.OnUpdate(OnMove)).OnComplete(delegate
		{
			Debug.Log("GirlNavigator OnComplete Move");
			_currentSpeed.Value = 0f;
			_moveSequence = null;
			callback?.Invoke();
		});
	}

	public void BeginJump(Vector3 goalPoint, float moveDuration, float jumpDuration, float delay, Action callback = null)
	{
		BeginJump(goalPoint, moveDuration, jumpDuration, delay, _jumpXZCurve, _jumpYCurve, callback);
	}

	public void BeginVerticalJump(Vector3 goalPoint, float moveDuration, float jumpDuration, float delay, Action callback = null)
	{
		BeginJump(goalPoint, moveDuration, jumpDuration, delay, _verticalJumpXZCurve, _jumpYCurve, callback);
	}

	private void BeginJump(Vector3 goalPoint, float moveDuration, float jumpDuration, float delay, AnimationCurve xzCurve, AnimationCurve yCurve, Action callback = null)
	{
		Debug.Log("GirlNavigator Begin Jump");
		_moveSequence?.Kill();
		_currentSpeed.Value = 0f;
		float endValue = goalPoint.y - _rigidbody.transform.position.y;
		goalPoint.y = 0f;
		if (_jumpParent == null)
		{
			_jumpParent = _rigidbody.transform.parent.CreateChild("JumpParent");
		}
		_jumpParent.ResetInLocal();
		_rigidbody.transform.SetParent(_jumpParent);
		_moveSequence = DOTween.Sequence().Append(_rigidbody.transform.DOLocalMove(goalPoint, moveDuration).SetEase(xzCurve)).Join(_jumpParent.DOLocalMoveY(endValue, jumpDuration).SetEase(yCurve))
			.SetDelay(delay)
			.OnComplete(delegate
			{
				Debug.Log("GirlNavigator OnComplete Jump");
				_rigidbody.transform.SetParent(_jumpParent.parent);
				_currentSpeed.Value = 0f;
				callback?.Invoke();
				_moveSequence = null;
			});
	}

	public void BeginFall(Vector3 position, Vector3 rotation, float fallDuration, Action callback = null)
	{
		Debug.Log("GirlNavigator Begin Fall");
		_moveSequence?.Kill();
		_currentSpeed.Value = 0f;
		_moveSequence = DOTween.Sequence().Append(_rigidbody.DOMove(position, fallDuration).SetEase(_fallSpeedCurve)).Join(_rigidbody.DORotate(rotation, 0.5f).OnComplete(delegate
		{
			SingletonMonoBehaviour<GirlAnimationController>.Instance.FadeBodyAnimation(GirlBodyAnimationType.FallLoop, 0.004f);
		}))
			.OnComplete(delegate
			{
				Debug.Log("GirlNavigator OnComplete Fall");
				_moveSequence = null;
				SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeHeight(GirlAnimationController.HeightType.Stand);
				SingletonMonoBehaviour<GirlAnimationController>.Instance.ChangeBodyAnimation(GirlBodyAnimationType.Land, delegate
				{
					callback?.Invoke();
				});
			});
	}

	public void Pause()
	{
		_moveSequence?.Pause();
	}

	public void Resume()
	{
		_moveSequence?.Play();
	}

	public void Stop()
	{
		if (_moveSequence == null)
		{
			Debug.Log("GirlNavigator Stop No Kill");
		}
		else
		{
			Debug.Log("GirlNavigator Stop Kill");
			_moveSequence.Kill();
			_moveSequence = null;
		}
		_currentSpeed.Value = 0f;
	}
}
public class GirlSpeechBubble : SingletonMonoBehaviour<GirlSpeechBubble>
{
	[SerializeField]
	[Required]
	private GameObject _entity;

	private Transform _transform;

	private Transform _camera;

	private Transform _girl;

	[SerializeField]
	[Required]
	private CanvasGroup _backCanvasGroup;

	[SerializeField]
	[Required]
	private CanvasGroup _textCanvasGroup;

	[SerializeField]
	[Required]
	private SuperTextMesh _text;

	[SerializeField]
	private AnimationCurve _showAnimationCurve;

	[SerializeField]
	private AnimationCurve _hideAnimationCurve;

	private readonly float _tweenDuration = 0.5f;

	private void Start()
	{
		_transform = _entity.transform;
		_girl = SingletonMonoBehaviour<GirlManager>.Instance.Girl.transform;
		_camera = SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCamera.transform;
		_entity.SetActive(value: false);
		FontMasterData.Entity.UpdateFont(_text);
	}

	private void LateUpdate()
	{
		if (_entity.activeSelf)
		{
			UpdateTransform();
		}
	}

	private void UpdateTransform()
	{
		_transform.position = _girl.position + _girl.up * 1.2f + _girl.forward * 0.25f;
		_transform.LookAt(_camera);
	}

	public void Show(string text, Action callback)
	{
		_entity.SetActive(value: true);
		UpdateTransform();
		_text.SetTextAndRebuild(text);
		_backCanvasGroup.alpha = 1f;
		_textCanvasGroup.alpha = 0f;
		_transform.SetLocalScaleY(0f);
		DOTween.Sequence().Append(_transform.DOScaleY(1f, _tweenDuration).SetEase(_showAnimationCurve)).Append(_textCanvasGroup.DOFade(1f, _tweenDuration).SetEase(_showAnimationCurve))
			.OnComplete(delegate
			{
				callback();
			});
	}

	public void Hide(float delay = 0f, Action callback = null)
	{
		_transform.SetLocalScaleY(1f);
		DOTween.Sequence().Append(_backCanvasGroup.DOFade(0f, _tweenDuration).SetEase(_hideAnimationCurve)).Join(_textCanvasGroup.DOFade(0f, _tweenDuration).SetEase(_hideAnimationCurve))
			.SetDelay(delay)
			.OnComplete(delegate
			{
				_entity.SetActive(value: false);
				callback?.Invoke();
			});
	}
}
public class GirlVoicePlayer : SingletonMonoBehaviour<GirlVoicePlayer>
{
	[SerializeField]
	[Required]
	private AudioSource _audioSource;

	private readonly Dictionary<string, AudioClip> _audioClipDict = new Dictionary<string, AudioClip>();

	[SerializeField]
	[ReadOnly]
	private bool _isPause;

	private Action _callback;

	[ShowInInspector]
	[ReadOnly]
	private bool IsPlayingAudioSource
	{
		get
		{
			if (_audioSource != null)
			{
				return _audioSource.isPlaying;
			}
			return false;
		}
	}

	[ShowInInspector]
	[ReadOnly]
	private float AudioSourceTime
	{
		get
		{
			if (!(_audioSource == null))
			{
				return _audioSource.time;
			}
			return 0f;
		}
	}

	[ShowInInspector]
	[ReadOnly]
	public bool IsPlaying { get; private set; }

	protected override void Init()
	{
		base.Init();
		AudioClip[] array = Resources.LoadAll<AudioClip>(System.IO.Path.Combine("Voice", $"{SingletonMonoBehaviour<GirlManager>.Instance.CurrentCharacterType}"));
		foreach (AudioClip audioClip in array)
		{
			_audioClipDict[audioClip.name] = audioClip;
		}
	}

	private void Update()
	{
		if (!_isPause && IsPlaying && !_audioSource.isPlaying && Mathf.Approximately(_audioSource.time, 0f))
		{
			IsPlaying = false;
			_callback?.Invoke();
			_callback = null;
		}
	}

	public void Play(GirlVoiceType voiceType, Action callback = null)
	{
		_callback = callback;
		int girlVoiceNo = UserDataAccessorManager.PlayRecordDataAccessor.GetGirlVoiceNo(voiceType);
		string text = $"{voiceType}{girlVoiceNo}";
		string text2 = "Voice_" + text;
		Debug.Log("声 : " + text2 + "再生");
		if (_audioClipDict.ContainsKey(text2))
		{
			_audioSource.clip = _audioClipDict[text2];
		}
		else
		{
			Debug.LogError(text2 + "というボイスのファイルはありません");
		}
		Action action = delegate
		{
			IsPlaying = true;
			_audioSource.Play();
		};
		CharacterType currentCharacterType = SingletonMonoBehaviour<GirlManager>.Instance.CurrentCharacterType;
		if (currentCharacterType != 0 && UserDataAccessorManager.SettingDataAccessor.CurrentLanguage == AvailableLanguage.Japanese)
		{
			text += $"_{currentCharacterType}";
		}
		if (voiceType != GirlVoiceType.SerifAction && voiceType != GirlVoiceType.SerifSurprise && LocalizedUtility.ExistsKey(text))
		{
			SingletonMonoBehaviour<GirlSpeechBubble>.Instance.Show(LocalizedUtility.Get(text), action);
		}
		else
		{
			action();
		}
	}

	public void Pause()
	{
		if (_audioSource.isPlaying)
		{
			_audioSource.Pause();
			_isPause = true;
		}
	}

	public void Resume()
	{
		if (_isPause)
		{
			_audioSource.UnPause();
		}
		_isPause = false;
	}
}
public class InstructionSpeechBubble : ReuseMonoBehaviour
{
	[SerializeField]
	[Required]
	private Image _objectImage;

	[SerializeField]
	[Required]
	private CanvasGroup _canvasGroup;

	[SerializeField]
	[Required]
	private SuperTextMesh _missText;

	[SerializeField]
	[Required]
	private SuperTextMesh _successText;

	[SerializeField]
	[Required]
	private SuperTextMesh _heartText;

	private LickableObjectType _answerObjectType;

	private LickableObjectType _selectObjectType;

	[SerializeField]
	[ReadOnly]
	private Transform _transform;

	private PerlinNoiseGenerator _xNoiseGenerator;

	private PerlinNoiseGenerator _yNoiseGenerator;

	[SerializeField]
	[Required]
	private Transform _scaleTweenParent;

	[SerializeField]
	private AnimationCurve _missTweenCurve;

	[SerializeField]
	private AnimationCurve _successTweenCurve;

	[SerializeField]
	private AnimationCurve _heartTweenCurve;

	private Tweener _colorTween;

	private Tweener _scaleTween;

	[SerializeField]
	[ReadOnly]
	private AudioPlayer _missSEPlayer;

	[SerializeField]
	[ReadOnly]
	private AudioPlayer _successSEPlayer;

	[SerializeField]
	[ReadOnly]
	private AudioPlayer _heartSEPlayer;

	public override void InitOnFirstInstantiate()
	{
		_transform = base.transform;
		_missSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_Miss");
		_successSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_Success");
		_heartSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_Heart");
	}

	public void Init(LickableObjectType lickableObjectType)
	{
		_answerObjectType = lickableObjectType;
		InitObjectIcon(_answerObjectType, 0f);
		_successText.gameObject.SetActive(value: false);
		_missText.gameObject.SetActive(value: false);
		_heartText.gameObject.SetActive(value: false);
		_successText.size = 55f;
		_successText.transform.SetLocalPositionY(8f);
		_missText.transform.SetLocalPositionY(42f);
		float rateOfChange = 1f + SingletonMonoBehaviour<GameManager>.Instance.ElapsedTimeRate;
		_xNoiseGenerator = new PerlinNoiseGenerator(0.9f, 1.1f, rateOfChange);
		_yNoiseGenerator = new PerlinNoiseGenerator(0.9f, 1.1f, rateOfChange);
	}

	private void InitObjectIcon(LickableObjectType lickableObjectType, float alpha)
	{
		_scaleTween?.Kill(complete: true);
		_colorTween?.Kill(complete: true);
		_objectImage.sprite = SingletonMonoBehaviour<LickableObjectManager>.Instance.GetIcon(lickableObjectType);
		_objectImage.gameObject.SetActive(_objectImage.sprite != null);
		_canvasGroup.alpha = alpha;
		_successSEPlayer.Stop();
		_missSEPlayer.Stop();
	}

	private void Update()
	{
		_transform.localScale = new Vector3(_xNoiseGenerator.GetNoise(), _yNoiseGenerator.GetNoise(), 0f);
	}

	private void FadeObjectImage(float endValue, float duration, float delay = 0f)
	{
		_colorTween?.Kill(complete: true);
		_colorTween = _canvasGroup.DOFade(endValue, duration).SetDelay(delay).OnComplete(delegate
		{
			_colorTween = null;
		});
	}

	public void ShowAnswer()
	{
		FadeObjectImage(1f, 0.5f);
	}

	public void HideAnswer(float delay = 0f)
	{
		FadeObjectImage(0f, 0.5f, delay);
	}

	public bool CheckInstruction(LickableObjectType lickableObjectType)
	{
		_selectObjectType = lickableObjectType;
		bool flag = _selectObjectType == LickableObjectType.Girl;
		if (!flag && _answerObjectType != lickableObjectType)
		{
			return false;
		}
		PlayTweenAndSE(flag, isSuccess: true);
		return true;
	}

	private void PlayTweenAndSE(bool isGirl, bool isSuccess)
	{
		_heartText.gameObject.SetActive(isGirl);
		_successText.gameObject.SetActive(!isGirl && isSuccess);
		_missText.gameObject.SetActive(!isSuccess);
		InitObjectIcon(_selectObjectType, 1f);
		float duration = (isSuccess ? 1f : 0.8f);
		AnimationCurve animCurve = (isSuccess ? _successTweenCurve : _missTweenCurve);
		float pitch = 1f + SingletonMonoBehaviour<ComboManager>.Instance.CombRate;
		if (isGirl)
		{
			_heartSEPlayer.Play(1f, 0f, pitch);
			duration = 0.55f;
			animCurve = _heartTweenCurve;
		}
		else if (isSuccess)
		{
			_successSEPlayer.Play(1f, 0f, pitch);
		}
		else
		{
			_missSEPlayer.Play();
		}
		_scaleTween = _scaleTweenParent.DOScale(isSuccess ? 1.3f : 0.7f, duration).SetEase(animCurve).OnComplete(delegate
		{
			_scaleTween = null;
		});
	}

	public void Incorrect()
	{
		PlayTweenAndSE(isGirl: false, isSuccess: false);
	}
}
public class InstructionSpeechBubbleSet : ReuseMonoBehaviour
{
	private readonly List<InstructionSpeechBubble> _bubbleList = new List<InstructionSpeechBubble>();

	private int _currentTagetBubbleNo;

	[SerializeField]
	[ReadOnly]
	private Transform _transform;

	[SerializeField]
	[ReadOnly]
	private Transform _camera;

	private Transform _speechBubbleTarget;

	[SerializeField]
	private AnimationCurve _popUpCurve;

	[SerializeField]
	private AnimationCurve _hideCurve;

	[SerializeField]
	[ReadOnly]
	private AudioPlayer _popUPSEPlayer;

	[SerializeField]
	[ReadOnly]
	private AudioPlayer _showAnswerSEPlayer;

	private bool _isHiddenAnswer;

	private bool _isChecked;

	private float _incorrectDeferment;

	public override void InitOnFirstInstantiate()
	{
		_transform = base.transform;
		_camera = SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCamera.transform;
		_popUPSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_PopupSpeechBubble");
		_showAnswerSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_ShowAnswer");
	}

	public void AddSpeechBubble(InstructionSpeechBubble speechBubble)
	{
		speechBubble.transform.SetParent(base.transform);
		_bubbleList.Add(speechBubble);
	}

	private void Update()
	{
		if (!(_incorrectDeferment <= 0f))
		{
			_incorrectDeferment -= Time.deltaTime;
			if (_incorrectDeferment <= 0f)
			{
				Incorrect();
			}
		}
	}

	private void LateUpdate()
	{
		if (base.gameObject.activeSelf || !(_camera != null))
		{
			if (_isHiddenAnswer)
			{
				_transform.position = _transform.position * 0.95f + (_camera.position + _camera.up * 0.3f + _camera.forward * 2f) * 0.05f;
			}
			else
			{
				_transform.position = _transform.position * 0.5f + _speechBubbleTarget.position * 0.5f;
			}
			LookAtCamera();
		}
	}

	private void LookAtCamera()
	{
		_transform.LookAt(_camera);
	}

	public Vector3 GetBeforeBubblePosition()
	{
		int num = _currentTagetBubbleNo - 1;
		if (num < 0)
		{
			num = _bubbleList.Count - 1;
		}
		return _bubbleList[num].transform.position;
	}

	public void Show(Transform speechBubbleTarget)
	{
		_speechBubbleTarget = speechBubbleTarget;
		_currentTagetBubbleNo = 0;
		_popUPSEPlayer.Play();
		_isHiddenAnswer = false;
		_isChecked = false;
		base.transform.position = _speechBubbleTarget.position;
		LookAtCamera();
		float num = 0.6f;
		float num2 = (float)(_bubbleList.Count - 1) * num * 0.5f;
		for (int i = 0; i < _bubbleList.Count; i++)
		{
			_bubbleList[i].transform.localRotation = Quaternion.identity;
			_bubbleList[i].transform.localPosition = new Vector3(num2 - num * (float)i, 0f, 0f);
		}
		_transform.localScale = Vector3.zero;
		_transform.DOScale(Vector3.one, 0.5f).SetEase(_popUpCurve).OnComplete(ShowAnswer);
	}

	public void ShowAnswer()
	{
		if (_isChecked)
		{
			return;
		}
		_showAnswerSEPlayer.Play();
		foreach (InstructionSpeechBubble bubble in _bubbleList)
		{
			bubble.ShowAnswer();
		}
	}

	public void HideAnswer()
	{
		if (_isChecked)
		{
			return;
		}
		_isHiddenAnswer = true;
		foreach (InstructionSpeechBubble bubble in _bubbleList)
		{
			bubble.HideAnswer();
		}
	}

	public void Hide()
	{
		_transform.DOScale(Vector3.zero, 0.25f).SetEase(_hideCurve).OnComplete(delegate
		{
			foreach (InstructionSpeechBubble bubble in _bubbleList)
			{
				bubble.Release();
			}
			_bubbleList.Clear();
			Release();
		});
	}

	private void FadeOutAnswers()
	{
		foreach (InstructionSpeechBubble bubble in _bubbleList)
		{
			bubble.HideAnswer(1f);
		}
		_currentTagetBubbleNo = 0;
	}

	public bool CheckInstruction(LickableObjectType lickableObjectType)
	{
		if (!_isChecked)
		{
			_isChecked = true;
			_isHiddenAnswer = true;
		}
		bool num = _bubbleList[_currentTagetBubbleNo].CheckInstruction(lickableObjectType);
		if (num)
		{
			_incorrectDeferment = 0f;
			_currentTagetBubbleNo++;
			SingletonMonoBehaviour<ComboManager>.Instance.Increase();
		}
		else if (_incorrectDeferment <= 0f)
		{
			_incorrectDeferment = 0.4f;
		}
		if (_currentTagetBubbleNo >= _bubbleList.Count)
		{
			FadeOutAnswers();
		}
		return num;
	}

	private void Incorrect()
	{
		_bubbleList[_currentTagetBubbleNo].Incorrect();
		FadeOutAnswers();
		SingletonMonoBehaviour<ComboManager>.Instance.Finish();
	}
}
public class LickedObjectViewer : SingletonMonoBehaviour<LickedObjectViewer>
{
	[SerializeField]
	[Required]
	private SuperTextMesh _titleText;

	[SerializeField]
	[Required]
	private LickedObjectViewerParts _originalParts;

	private List<LickedObjectViewerParts> _partsList = new List<LickedObjectViewerParts>();

	private void Start()
	{
		FontMasterData.Entity.UpdateFont(_titleText);
		int num = 11;
		List<LickableObjectType> allInList = EnumUtility.GetAllInList<LickableObjectType>();
		_originalParts.Init(allInList[0]);
		_partsList.Add(_originalParts);
		for (int i = 1; i < allInList.Count; i++)
		{
			int num2 = i % num;
			int num3 = i / num;
			LickedObjectViewerParts lickedObjectViewerParts = _originalParts.transform.parent.CreateChildFromOriginal<LickedObjectViewerParts>(_originalParts.transform);
			lickedObjectViewerParts.transform.localRotation = _originalParts.transform.localRotation;
			lickedObjectViewerParts.transform.localPosition = _originalParts.transform.localPosition + new Vector3(28.3f * (float)num2, -28.3f * (float)num3, 0f);
			lickedObjectViewerParts.Init(allInList[i]);
			_partsList.Add(lickedObjectViewerParts);
		}
		UserDataAccessorManager.PlayRecordDataAccessor.ChangedLickedObjectTypes += OnUpdateLickedObjectType;
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene += DiscardEvent;
		foreach (LickedObjectViewerParts parts in _partsList)
		{
			parts.ChangeActive(UserDataAccessorManager.PlayRecordDataAccessor.IsLicked(parts.LickableObjectType));
		}
		UpdateTitleText();
	}

	private void DiscardEvent()
	{
		UserDataAccessorManager.PlayRecordDataAccessor.ChangedLickedObjectTypes -= OnUpdateLickedObjectType;
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene -= DiscardEvent;
	}

	private void OnUpdateLickedObjectType(List<string> lickedObjectTypeList)
	{
		foreach (LickedObjectViewerParts parts in _partsList)
		{
			parts.ChangeActive(lickedObjectTypeList.Contains(parts.LickableObjectTypeText));
		}
		UpdateTitleText();
	}

	private void UpdateTitleText()
	{
		_titleText.text = string.Format(LocalizedUtility.Get("LickedObjectTitleText"), Mathf.RoundToInt(100f * (float)_partsList.Count((LickedObjectViewerParts parts) => parts.IsActive) / (float)_partsList.Count));
		_titleText.Rebuild();
	}
}
public class LickedObjectViewerParts : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Image _iconImage;

	[SerializeField]
	[Required]
	private Image _backImage;

	[SerializeField]
	private Color _backColor;

	public LickableObjectType LickableObjectType { get; private set; }

	public string LickableObjectTypeText { get; private set; } = "";


	public bool IsActive { get; private set; }

	public void Init(LickableObjectType lickableObjectType)
	{
		LickableObjectType = lickableObjectType;
		_iconImage.sprite = SingletonMonoBehaviour<LickableObjectManager>.Instance.GetIcon(LickableObjectType);
		LickableObjectTypeText = LickableObjectType.ToString();
	}

	public void ChangeActive(bool isActive)
	{
		IsActive = isActive;
		_iconImage.color = (isActive ? Color.white : Color.black);
		_backImage.color = (isActive ? _backColor : Color.white);
	}
}
public class ComboManager : SingletonMonoBehaviour<ComboManager>
{
	private ComboText _comboText;

	public int CurrentComb => _comboText.Comb;

	public float CombRate => _comboText.CombRate;

	protected override void Init()
	{
		base.Init();
		_comboText = base.transform.CreateChildFromOriginal<ComboText>(Resources.Load<Transform>("Prefab/ComboText"));
	}

	public void Increase()
	{
		if (!SingletonMonoBehaviour<Catfish>.Instance.IsDead)
		{
			_comboText.Increase();
		}
	}

	public void Stop()
	{
		_comboText.gameObject.SetActive(value: false);
	}

	public void Finish()
	{
		_comboText.Finish();
	}
}
public class FeverEffectManager : SingletonMonoBehaviour<FeverEffectManager>
{
	[SerializeField]
	[Required]
	private Transform _effectsFrontCamera;

	[SerializeField]
	[Required]
	private ParticleSystem _tunnelEffect;

	[SerializeField]
	[Required]
	private ParticleSystem _explosionEffect;

	private List<ParticleSystem> _tunnelEffectList;

	private float _tunnelEffectSpeed = 1f;

	private bool _isPlaying;

	private AudioPlayer _feverSEPlayer;

	private void Start()
	{
		_tunnelEffectList = _tunnelEffect.GetComponentsInChildren<ParticleSystem>().ToList();
		_effectsFrontCamera.SetParent(SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCamera.transform);
		_effectsFrontCamera.ResetInLocal();
		SingletonMonoBehaviour<GameManager>.Instance.CacheParticleIfNeeded(_explosionEffect);
		_feverSEPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_explosionEffect.gameObject, "Audio/SE/SE_Fever");
	}

	private void Update()
	{
		if (!_isPlaying)
		{
			return;
		}
		_tunnelEffectSpeed += Time.deltaTime * 0.15f;
		foreach (ParticleSystem tunnelEffect in _tunnelEffectList)
		{
			ParticleSystem.MainModule main = tunnelEffect.main;
			main.simulationSpeed = _tunnelEffectSpeed;
		}
	}

	public void Play()
	{
		_isPlaying = true;
		_tunnelEffectSpeed = 1f;
		_explosionEffect.Play();
		_feverSEPlayer.Play();
		foreach (ParticleSystem tunnelEffect in _tunnelEffectList)
		{
			tunnelEffect.Play();
		}
	}

	public void Stop()
	{
		_isPlaying = false;
		foreach (ParticleSystem tunnelEffect in _tunnelEffectList)
		{
			tunnelEffect.Stop();
		}
		_feverSEPlayer.Stop();
	}
}
public static class GameBalanceValue
{
	public const float INSTRUCTION_COUNT = 8f;

	public const float HIGH_SCORE_BORDER = 5000f;

	public const float SPECIAL_POINT_RATE_MIN = 1f;

	public const float SPECIAL_POINT_RATE_MAX = 3f;

	public const float COMB_RATE_MAX_NUM = 50f;

	public const float BASE_SPECIAL_POINT = 100f;
}
public class GameCameraController : CameraController<GameCameraController>
{
	[SerializeField]
	[Required]
	private Transform _playerChoker;

	protected override Vector3 INITIAL_POSITION => new Vector3(2.36f, 0f, -2.35f);

	protected override Vector3 INITIAL_ROTATION => new Vector3(0f, 90f, 0f);

	protected override void Init()
	{
		base.Init();
		Transform obj = base.CurrentCamera.transform.CreateChildFromOriginal(Resources.Load<Transform>("Prefab/Tongue"));
		obj.ResetInLocal();
		_playerChoker.SetParent(base.CurrentCamera.transform);
		_playerChoker.localPosition = new Vector3(0f, -0.15f, -0.033f);
		_playerChoker.gameObject.SetActive(value: false);
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene += OnChangeScene;
		obj.transform.parent.CreateChildFromOriginal(Resources.Load<Transform>("Prefab/SlapTarget")).ResetInLocal();
		if (CacheData.ShouldSetVrCameraPosition && _vrCamera.activeSelf)
		{
			_vrCamera.GetComponentInChildren<Player>().transform.position = CacheData.VrCameraPosition;
		}
	}

	private void OnChangeScene()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangedScene -= OnChangeScene;
		if (_vrCamera.activeSelf)
		{
			CacheData.SetVRCameraPosition(_vrCamera.GetComponentInChildren<Player>().transform.position);
		}
	}
}
public class GameEndProcessor : SingletonMonoBehaviour<GameEndProcessor>
{
	private bool _isPlaying;

	public void Play()
	{
		if (!_isPlaying)
		{
			_isPlaying = true;
			Debug.LogWarning("ゲーム終了！！！！");
			int currentScore = SingletonMonoBehaviour<ScoreManager>.Instance.CurrentScore;
			if (UserDataAccessorManager.PlayRecordDataAccessor.UpdateHighScoreIfNeeded(currentScore))
			{
				SingletonMonoBehaviour<HighScoreText>.Instance.PlayNewRecordProduction();
			}
			SingletonMonoBehaviour<MyRankingViewer>.Instance.UpdateUI(currentScore);
		}
	}
}
public class GameManager : SingletonMonoBehaviour<GameManager>
{
	public enum State
	{
		Before,
		Playing,
		GameOver
	}

	private State _currentState;

	public const float GAME_TIME = 247f;

	private static bool _isFirstBoot = true;

	private Transform _cacheParticleParent;

	public State CurrentState => _currentState;

	[ShowInInspector]
	[ReadOnly]
	public float ElapsedTime { get; private set; }

	[ShowInInspector]
	[ReadOnly]
	public float ElapsedTimeRate => Mathf.Clamp(ElapsedTime / 247f, 0f, 1f);

	public static bool IsFirstBoot => _isFirstBoot;

	public event Action FinishedFadeIn = delegate
	{
	};

	private void Start()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.FadeOut(0f);
		float waitTime = 0.01f;
		if (_isFirstBoot)
		{
			waitTime = 0.5f;
			_cacheParticleParent = base.transform.CreateChild("CacheParticleParent");
			_cacheParticleParent.transform.position = GetCameraForwardPosition();
			ParticleSystem[] array = Resources.LoadAll<ParticleSystem>("Prefab/Production/Cache/Particle");
			foreach (ParticleSystem particleSystem in array)
			{
				ParticleSystem particleSystem2 = _cacheParticleParent.CreateChildFromOriginal<ParticleSystem>(particleSystem.transform);
				particleSystem2.transform.ResetInLocal();
				particleSystem2.Play();
			}
		}
		StartCoroutine(this.DelayMethod(waitTime, BeginFadeIn));
	}

	private void BeginFadeIn()
	{
		if (_cacheParticleParent != null)
		{
			_cacheParticleParent.gameObject.SetActive(value: false);
		}
		SingletonMonoBehaviour<SceneNavigator>.Instance.FadeIn(0.5f, isIgnoreTimeScale: true, FinishFadeIn);
	}

	private void FinishFadeIn()
	{
		_isFirstBoot = false;
		this.FinishedFadeIn();
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.PlayBeforeBGM();
	}

	public void CacheParticleIfNeeded(ParticleSystem particle, Action callback = null)
	{
		if (!_isFirstBoot)
		{
			callback?.Invoke();
			return;
		}
		Vector3 beforePosition = particle.transform.position;
		bool beforeActive = particle.gameObject.activeSelf;
		particle.transform.position = GetCameraForwardPosition();
		particle.gameObject.SetActive(value: true);
		particle.Play();
		StartCoroutine(this.DelayMethod(0.1f, delegate
		{
			particle.gameObject.SetActive(value: false);
			particle.gameObject.SetActive(beforeActive);
			particle.transform.position = beforePosition;
			callback?.Invoke();
		}));
	}

	private Vector3 GetCameraForwardPosition()
	{
		return SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCameraObject.transform.position + SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCameraObject.transform.forward;
	}

	private void Update()
	{
		if (_currentState == State.Playing)
		{
			ElapsedTime = Mathf.Min(ElapsedTime + Time.deltaTime, 247f);
			if (ElapsedTimeRate >= 1f)
			{
				GameOver(GameOverType.TimeUp);
			}
		}
	}

	private void ChangeState(State state)
	{
		Debug.Log($"ChangeState : {state}");
		_currentState = state;
		if (_currentState == State.GameOver)
		{
			SingletonMonoBehaviour<Tongue>.Instance.ResetState(Tongue.State.Transparent);
			SingletonMonoBehaviour<ComboManager>.Instance.Stop();
			SingletonMonoBehaviour<InstructionManager>.Instance.HideIfNeeded();
		}
	}

	public void GameStart()
	{
		UserDataAccessorManager.PlayRecordDataAccessor.IncrementPlayCount();
		SingletonMonoBehaviour<TutorialManager>.Instance.HideRecorderTargetParticle();
		ChangeState(State.Playing);
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.PlayPlayingBGM();
		SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstLick);
	}

	public void GameOver(GameOverType gameOverType)
	{
		if (_currentState == State.GameOver)
		{
			SingletonMonoBehaviour<AfterGameOverGirlManager>.Instance.SurpriseIfNeeded();
			return;
		}
		ChangeState(State.GameOver);
		switch (gameOverType)
		{
		case GameOverType.Stole:
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstStoleGameOver);
			break;
		case GameOverType.LickedGirl:
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstLickedGirlGameOver);
			break;
		}
		if (gameOverType == GameOverType.TimeUp)
		{
			SingletonMonoBehaviour<ClassroomSpeaker>.Instance.PlayChime();
			SingletonMonoBehaviour<GirlMoveController>.Instance.TimeUp();
		}
		else
		{
			SingletonMonoBehaviour<ClassroomSpeaker>.Instance.Stop();
			SingletonMonoBehaviour<GirlMoveController>.Instance.GameOver(gameOverType);
		}
	}
}
public class GameScenePostProcessManager : PostProcessManager<GameScenePostProcessManager>
{
	[SerializeField]
	[Required]
	private PostProcessVolume _twilightProcess;

	[SerializeField]
	[Required]
	private PostProcessVolume _backTimePostProcess;

	private void LateUpdate()
	{
		UpdateNormalProcess();
	}

	private void UpdateNormalProcess()
	{
		if (!_backTimePostProcess.gameObject.activeSelf)
		{
			float elapsedTimeRate = SingletonMonoBehaviour<GameManager>.Instance.ElapsedTimeRate;
			_normalPostProcess.weight = 1f - elapsedTimeRate;
			_twilightProcess.weight = elapsedTimeRate;
		}
	}

	public override void ShowNormal()
	{
		base.ShowNormal();
		_backTimePostProcess.weight = 0f;
		_backTimePostProcess.gameObject.SetActive(value: false);
		UpdateNormalProcess();
	}

	public void CreateBackTimeTween(Sequence sequence, float duration)
	{
		_backTimePostProcess.gameObject.SetActive(value: true);
		sequence.Join(DOTween.To(() => 0f, delegate(float timeRate)
		{
			float elapsedTimeRate = SingletonMonoBehaviour<GameManager>.Instance.ElapsedTimeRate;
			_normalPostProcess.weight = Mathf.Max(1f - elapsedTimeRate - timeRate, 0f);
			_twilightProcess.weight = Mathf.Max(elapsedTimeRate - timeRate, 0f);
			_backTimePostProcess.weight = timeRate;
		}, 1f, duration));
	}
}
public class InstructionManager : SingletonMonoBehaviour<InstructionManager>
{
	[SerializeField]
	[Required]
	private InstructionSpeechBubble _speechBubbleOriginal;

	[SerializeField]
	[Required]
	private InstructionSpeechBubbleSet _speechBubbleSetOriginal;

	private ReuseMonoBehaviourObjetPool _speechBubblePool;

	private ReuseMonoBehaviourObjetPool _speechBubbleSetPool;

	private InstructionSpeechBubbleSet _currentSpeechBubbleSetBubbleSet;

	[ShowInInspector]
	[ReadOnly]
	public int InstructionCount { get; private set; }

	private void Start()
	{
		_speechBubblePool = base.transform.CreateChild<ReuseMonoBehaviourObjetPool>("SpeechBubblePool");
		_speechBubblePool.CreateInitialPool(_speechBubbleOriginal, 7);
		_speechBubbleSetPool = base.transform.CreateChild<ReuseMonoBehaviourObjetPool>("SpeechBubbleSetPool");
		_speechBubbleSetPool.CreateInitialPool(_speechBubbleSetOriginal, 1);
	}

	public void GiveInstructions(LickableObjectType holdingObjectType, Transform speechBubbleTarget)
	{
		int instructionNum = 1;
		if (InstructionCount >= 1 && InstructionCount <= 3)
		{
			instructionNum = 2;
		}
		else if (InstructionCount >= 4 && InstructionCount <= 6)
		{
			instructionNum = 3;
		}
		else if (InstructionCount >= 7)
		{
			instructionNum = 4;
		}
		List<LickableObjectType> instructionObjectTypeList = SingletonMonoBehaviour<LickableObjectManager>.Instance.GetInstructionObjectTypeList(holdingObjectType, instructionNum);
		if (_currentSpeechBubbleSetBubbleSet != null)
		{
			_currentSpeechBubbleSetBubbleSet.Hide();
		}
		_currentSpeechBubbleSetBubbleSet = _speechBubbleSetPool.Get<InstructionSpeechBubbleSet>();
		foreach (LickableObjectType item in instructionObjectTypeList)
		{
			InstructionSpeechBubble instructionSpeechBubble = _speechBubblePool.Get<InstructionSpeechBubble>();
			instructionSpeechBubble.Init(item);
			_currentSpeechBubbleSetBubbleSet.AddSpeechBubble(instructionSpeechBubble);
		}
		_currentSpeechBubbleSetBubbleSet.Show(speechBubbleTarget);
		InstructionCount++;
	}

	public void ShowAnswer()
	{
		if (_currentSpeechBubbleSetBubbleSet != null)
		{
			_currentSpeechBubbleSetBubbleSet.ShowAnswer();
		}
	}

	public void HideAnswer()
	{
		if (_currentSpeechBubbleSetBubbleSet != null)
		{
			_currentSpeechBubbleSetBubbleSet.HideAnswer();
		}
	}

	public void HideIfNeeded()
	{
		if (!(_currentSpeechBubbleSetBubbleSet == null))
		{
			_currentSpeechBubbleSetBubbleSet.Hide();
			_currentSpeechBubbleSetBubbleSet = null;
		}
	}

	public void CheckInstruction(LickableObject lickableObject)
	{
		if (_currentSpeechBubbleSetBubbleSet == null)
		{
			return;
		}
		LickableObjectType objectType = lickableObject.GetObjectType();
		if (_currentSpeechBubbleSetBubbleSet.CheckInstruction(objectType))
		{
			float num = 1f;
			BonusType bonusType = (BonusType)0;
			if (lickableObject.IsCritical)
			{
				num = 2f;
				bonusType |= BonusType.Critical;
			}
			if (SingletonMonoBehaviour<Tongue>.Instance.IsActiveState(Tongue.State.Gold))
			{
				num += 1f;
				bonusType |= BonusType.Gold;
			}
			if (SingletonMonoBehaviour<Tongue>.Instance.IsActiveState(Tongue.State.Money))
			{
				num += 1f;
				bonusType |= BonusType.Money;
			}
			int num2 = SingletonMonoBehaviour<ComboManager>.Instance.CurrentComb / 10;
			if (num2 >= 1)
			{
				num += (float)num2;
				bonusType |= BonusType.Combo;
			}
			int num3 = ((!SingletonMonoBehaviour<Catfish>.Instance.IsDead) ? Mathf.RoundToInt(SingletonMonoBehaviour<GirlDistanceFinder>.Instance.DistanceRate * 10f) : 0);
			if (num3 >= 1)
			{
				num += (float)num3;
				bonusType |= BonusType.Distance;
			}
			if (objectType == LickableObjectType.Girl)
			{
				num *= 2f;
				bonusType |= BonusType.Girl;
			}
			if (SingletonMonoBehaviour<Tongue>.Instance.IsFever)
			{
				num *= 2f;
				bonusType |= BonusType.Fever;
			}
			SingletonMonoBehaviour<ScoreManager>.Instance.Appear(Mathf.RoundToInt(num), bonusType, num2, num3, _currentSpeechBubbleSetBubbleSet.GetBeforeBubblePosition());
		}
	}
}
public class TutorialManager : SingletonMonoBehaviour<TutorialManager>
{
	[SerializeField]
	[Required]
	private GameObject _recorderTargetParticle;

	[SerializeField]
	[Required]
	private GameObject _retrySmartPhoneTargetParticle;

	protected override void Init()
	{
		base.Init();
		_recorderTargetParticle.SetActive(value: false);
		_retrySmartPhoneTargetParticle.SetActive(value: false);
	}

	public void ShowRecorderTargetParticle()
	{
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.Before)
		{
			_recorderTargetParticle.SetActive(value: true);
		}
	}

	public void HideRecorderTargetParticle()
	{
		_recorderTargetParticle.SetActive(value: false);
	}

	public void ShowRetrySmartPhoneTargetParticle()
	{
		_retrySmartPhoneTargetParticle.SetActive(value: true);
	}

	public void HideRetrySmartPhoneTargetParticle()
	{
		_retrySmartPhoneTargetParticle.SetActive(value: false);
	}
}
public class ComboText : MonoBehaviour
{
	[SerializeField]
	[Required]
	private SuperTextMesh _text;

	private string _textFormat;

	private float _scaleRate = 1f;

	[SerializeField]
	private Transform _tweenParent;

	[SerializeField]
	private Transform _entity;

	private Transform _camera;

	[SerializeField]
	private AnimationCurve _showAnimationCurve;

	private Tweener _scaleTweener;

	private bool _isChasingCamera = true;

	public Transform TweenParent => _tweenParent;

	public int Comb { get; private set; }

	public float CombRate => Mathf.Min(1f, (float)Comb / 50f);

	private void Start()
	{
		_camera = SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCamera.transform;
		_entity.gameObject.SetActive(!_isChasingCamera);
		_textFormat = "<j=Lightning><c=Lightning>" + LocalizedUtility.Get("Combo") + "×";
		FontMasterData.Entity.UpdateFont(_text);
	}

	public void Copy(ComboText comboText)
	{
		_entity.gameObject.SetActive(value: true);
		_isChasingCamera = false;
		_text.text = comboText._text.text;
		_tweenParent.position = comboText._tweenParent.position;
		_tweenParent.localScale = comboText._tweenParent.localScale;
		LookAtCamera();
	}

	private void LateUpdate()
	{
		if (_entity.gameObject.activeSelf)
		{
			LookAtCamera();
			ChaseCamera();
		}
	}

	private void LookAtCamera()
	{
		_entity.LookAt(_camera);
	}

	private void ChaseCamera()
	{
		if (_isChasingCamera)
		{
			_tweenParent.position = _tweenParent.position * 0.95f + GetCameraFrontPosition() * 0.05f;
		}
	}

	private Vector3 GetCameraFrontPosition()
	{
		return _camera.position - _camera.up * 0.1f + _camera.forward * 2f;
	}

	public void Increase()
	{
		Comb++;
		if (Comb != 1)
		{
			if (Comb == 2)
			{
				_entity.gameObject.SetActive(value: true);
				_tweenParent.position = GetCameraFrontPosition();
				_tweenParent.localScale = Vector3.zero;
				_scaleTweener?.Kill();
				_scaleTweener = _tweenParent.DOScale(Vector3.one, 0.2f).SetEase(_showAnimationCurve);
				LookAtCamera();
			}
			else if (Comb % 10 == 0)
			{
				float combRate = CombRate;
				_scaleRate = 1f * (1f - combRate) + 3f * combRate;
				_scaleTweener?.Kill();
				_scaleTweener = _entity.DOScale(GetEntityScale(), 0.1f).SetEase(_showAnimationCurve);
			}
			_text.text = _textFormat + Comb;
		}
	}

	private Vector3 GetEntityScale()
	{
		return Vector3.one * _scaleRate * 0.1f;
	}

	public void Finish()
	{
		if (Comb >= 2)
		{
			SingletonMonoBehaviour<ReuseProductionGenerator>.Instance.PlayFlyingComboEffect(this, _scaleRate);
		}
		_entity.gameObject.SetActive(value: false);
		Comb = 0;
		_scaleRate = 1f;
		_entity.localScale = GetEntityScale();
	}
}
public class HighScoreText : SingletonMonoBehaviour<HighScoreText>
{
	[SerializeField]
	[Required]
	private Transform _textParent;

	[SerializeField]
	[Required]
	private SuperTextMesh _infoText;

	[SerializeField]
	[Required]
	private SuperTextMesh _scoreText;

	[SerializeField]
	[Required]
	private ParticleSystem _newRecordEffect;

	[SerializeField]
	private AnimationCurve _scaleAnimationCurve;

	private void Start()
	{
		FontMasterData.Entity.UpdateFonts(_infoText, _scoreText);
		_infoText.text = LocalizedUtility.Get("HighScoreText");
		_infoText.Rebuild();
		UpdateText(isNewRecord: false);
		_newRecordEffect.gameObject.SetActive(value: false);
		SingletonMonoBehaviour<GameManager>.Instance.CacheParticleIfNeeded(_newRecordEffect);
	}

	private void UpdateText(bool isNewRecord)
	{
		_scoreText.text = UserDataAccessorManager.PlayRecordDataAccessor.HighScore.ToString();
		if (isNewRecord)
		{
			_scoreText.text = "<c=Gold>" + _scoreText.text;
		}
		_scoreText.Rebuild();
	}

	[Button("新記録の演出を実行")]
	public void PlayNewRecordProduction()
	{
		_infoText.text = "<c=Gold>" + LocalizedUtility.Get("NewRecord");
		_infoText.Rebuild();
		UpdateText(isNewRecord: true);
		_textParent.DOScale(new Vector3(1.3f, 1.3f, 1f), 1.975f).SetEase(_scaleAnimationCurve).OnComplete(delegate
		{
			_scoreText.text = "<w>" + _scoreText.text;
			_infoText.text = "<w>" + _infoText.text;
			_scoreText.Rebuild();
			_infoText.Rebuild();
		});
		_newRecordEffect.gameObject.SetActive(value: true);
		SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Clacker", _newRecordEffect.gameObject, is3DSound: true);
	}
}
public class NormalScoreAcquisitionProduction : ScoreAcquisitionProduction
{
	[SerializeField]
	private SuperTextMesh _criticalText;

	[SerializeField]
	private SuperTextMesh _goldText;

	[SerializeField]
	private SuperTextMesh _moneyText;

	[SerializeField]
	private SuperTextMesh _comboText;

	[SerializeField]
	private SuperTextMesh _distanceText;

	[SerializeField]
	private SuperTextMesh _girlText;

	[SerializeField]
	private SuperTextMesh _feverText;

	private readonly Dictionary<BonusType, SuperTextMesh> _textDict = new Dictionary<BonusType, SuperTextMesh>();

	private static string _comboTextBase;

	private static string _distanceTextBase;

	[SerializeField]
	[Required]
	private Transform _bonusTextParent;

	[SerializeField]
	private AnimationCurve _bonusTextParentCurve;

	[SerializeField]
	private AnimationCurve _riseTweenCurve;

	private Tweener _scaleTweener;

	protected override float _tweenDuration => 0.236f;

	public override void InitOnFirstInstantiate()
	{
		base.InitOnFirstInstantiate();
		FontMasterData.Entity.UpdateFonts(_criticalText, _goldText, _moneyText, _comboText, _distanceText, _girlText, _feverText);
		_criticalText.text = LocalizedUtility.Get("CriticalBonus") + "(+1)";
		_goldText.text = LocalizedUtility.Get("GoldBonus") + "(+1)";
		_moneyText.text = LocalizedUtility.Get("MoneyBonus") + "(+1)";
		_girlText.text = LocalizedUtility.Get("GirlBonus") + "(×2)";
		_feverText.text = "<c=rainbow>" + LocalizedUtility.Get("FeverBonus") + "(×2)";
		_comboTextBase = LocalizedUtility.Get("ComboBonus") + "(+{0})";
		_distanceTextBase = LocalizedUtility.Get("DistanceBonus") + "(+{0})";
	}

	protected override void Awake()
	{
		base.Awake();
		_textDict[BonusType.Critical] = _criticalText;
		_textDict[BonusType.Gold] = _goldText;
		_textDict[BonusType.Money] = _moneyText;
		_textDict[BonusType.Combo] = _comboText;
		_textDict[BonusType.Distance] = _distanceText;
		_textDict[BonusType.Girl] = _girlText;
		_textDict[BonusType.Fever] = _feverText;
	}

	public void Play(int score, BonusType targetBonusType, int comboBonus, int distanceBonus, Vector3 position)
	{
		if (comboBonus > 0)
		{
			_comboText.text = string.Format(_comboTextBase, comboBonus);
		}
		if (distanceBonus > 0)
		{
			_distanceText.text = string.Format(_distanceTextBase, distanceBonus);
		}
		float num = -0.04f;
		foreach (BonusType allIn in EnumUtility.GetAllInList<BonusType>())
		{
			bool flag = (targetBonusType & allIn) == allIn;
			_textDict[allIn].gameObject.SetActive(flag);
			if (flag)
			{
				_textDict[allIn].transform.localPosition = new Vector3(0f, num);
				num += 0.02f;
			}
		}
		_camera = SingletonMonoBehaviour<GameCameraController>.Instance.CurrentCamera.transform;
		Begin(score, position, position + _camera.forward * -0.3f);
	}

	protected override string GetScoreText()
	{
		return _score.ToString();
	}

	protected override Color GetTextEndColor()
	{
		return SingletonMonoBehaviour<TotalScoreText>.Instance.TextColor;
	}

	protected override void FinishTween()
	{
		Vector3 endValue = base.transform.localPosition + base.transform.up * 0.5f - base.transform.forward * 0.5f;
		_transform.DOLocalMove(endValue, 2f).SetEase(_riseTweenCurve).OnComplete(BeginFly);
	}

	protected override void BeginFly()
	{
		base.BeginFly();
		_scaleTweener = _bonusTextParent.DOScaleX(0f, 0.2f).SetEase(_bonusTextParentCurve).OnComplete(delegate
		{
			_scaleTweener = null;
		});
	}

	public override void Release()
	{
		if (_scaleTweener != null)
		{
			_scaleTweener.Kill();
			_scaleTweener = null;
		}
		_bonusTextParent.SetLocalScaleX(1f);
		base.Release();
	}
}
public abstract class ScoreAcquisitionProduction : ReuseMonoBehaviour
{
	private Material _material;

	private static readonly int OutlineColor = Shader.PropertyToID("_OutlineColor");

	[SerializeField]
	private AnimationCurve _scaleAnimationCurve;

	[SerializeField]
	private AnimationCurve _positionAnimationCurve;

	protected int _score;

	private bool _isFever;

	protected Transform _transform;

	protected Transform _camera;

	private readonly List<ScoreAcquisitionProductionCharacter> _characterList = new List<ScoreAcquisitionProductionCharacter>();

	private int _flyingCharacterNum;

	private static readonly float CHARACTER_SPAN = 0.03f;

	public float ToScale { get; private set; }

	protected abstract float _tweenDuration { get; }

	protected virtual void Awake()
	{
		_transform = base.transform;
		_material = UnityEngine.Object.Instantiate(Resources.Load<Material>("Material/ScoreText"));
	}

	private void Update()
	{
		LookAtCamera();
	}

	private void LateUpdate()
	{
		LookAtCamera();
	}

	private void LookAtCamera()
	{
		if (!(_camera == null))
		{
			_transform.LookAt(_camera);
		}
	}

	protected virtual void UpdateTextColor(Color color)
	{
		color.a = 1f;
		foreach (ScoreAcquisitionProductionCharacter character in _characterList)
		{
			character.Text.color = color;
		}
		UpdateOutlineColor(_material, color);
		foreach (ScoreAcquisitionProductionCharacter character2 in _characterList)
		{
			character2.Text.Rebuild();
		}
	}

	protected void UpdateOutlineColor(Material material, Color color)
	{
		float num = 0.2f;
		color.r *= num;
		color.g *= num;
		color.b *= num;
		material.SetColor(OutlineColor, color);
	}

	protected abstract string GetScoreText();

	protected void Begin(int score, Vector3 fromPosition, Vector3 toPosition)
	{
		_score = score;
		_isFever = SingletonMonoBehaviour<Tongue>.Instance.IsFever;
		_transform.position = fromPosition;
		LookAtCamera();
		string scoreText = GetScoreText();
		foreach (char c in scoreText)
		{
			ScoreAcquisitionProductionCharacter scoreAcquisitionProductionCharacter = SingletonMonoBehaviour<ReuseProductionGenerator>.Instance.GetScoreAcquisitionProductionCharacter();
			scoreAcquisitionProductionCharacter.transform.SetParent(base.transform);
			scoreAcquisitionProductionCharacter.transform.ResetInLocal();
			scoreAcquisitionProductionCharacter.Text.text = c.ToString();
			scoreAcquisitionProductionCharacter.Text.textMaterial = _material;
			_characterList.Add(scoreAcquisitionProductionCharacter);
		}
		float num = CHARACTER_SPAN * (float)_characterList.Count * 0.5f;
		foreach (ScoreAcquisitionProductionCharacter character in _characterList)
		{
			num -= CHARACTER_SPAN * 0.5f;
			character.transform.localPosition = new Vector3(num, 0f, 0f);
			num -= CHARACTER_SPAN * 0.5f;
		}
		BeginTween(toPosition);
	}

	protected abstract Color GetTextEndColor();

	private void BeginTween(Vector3 toPosition)
	{
		float num = Mathf.Abs((float)_score / 100f);
		Color textEndColor = GetTextEndColor();
		if (_score < 0)
		{
			float b = textEndColor.b;
			textEndColor.b = textEndColor.r;
			textEndColor.r = b;
		}
		Color textStartColor = Color.white;
		textStartColor.a = textEndColor.a;
		textEndColor = textEndColor * num + textStartColor * (1f - num);
		_transform.localScale = Vector3.zero;
		ToScale = 1.5f;
		Sequence t = DOTween.Sequence().Append(_transform.DOScale(Vector3.one * ToScale, _tweenDuration).SetEase(_scaleAnimationCurve)).Join(DOTween.To(() => textStartColor, UpdateTextColor, textEndColor, _tweenDuration).SetEase(_scaleAnimationCurve))
			.Join(_transform.DOLocalMove(toPosition, _tweenDuration * 0.85f).SetEase(_positionAnimationCurve));
		t.OnComplete(FinishTween);
		t.Play();
	}

	protected virtual void FinishTween()
	{
		StartCoroutine(this.DelayMethod(2f, BeginFly));
	}

	protected virtual void BeginFly()
	{
		_camera = null;
		_flyingCharacterNum = _characterList.Count;
		Vector3 textPosition = SingletonMonoBehaviour<TotalScoreText>.Instance.TextPosition;
		int num = Mathf.FloorToInt((float)_score / (float)_flyingCharacterNum);
		for (int i = 0; i < _characterList.Count; i++)
		{
			int num2 = ((i == _characterList.Count - 1) ? _score : num);
			_score -= num2;
			Vector3 spreadVelocity = new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)).normalized * 5f;
			_characterList[i].BeginFly(num2, spreadVelocity, textPosition, FinishFly);
		}
	}

	private void FinishFly()
	{
		_flyingCharacterNum--;
		if (_flyingCharacterNum == 0)
		{
			Release();
		}
	}

	public override void Release()
	{
		foreach (ScoreAcquisitionProductionCharacter character in _characterList)
		{
			character.Release();
		}
		_characterList.Clear();
		base.Release();
	}
}
public class ScoreAcquisitionProductionCharacter : ReuseMonoBehaviour
{
	[SerializeField]
	[Required]
	private SuperTextMesh _text;

	private int _score;

	private Transform _transform;

	private Action _callback;

	private Vector3 _spreadVelocity = Vector3.zero;

	private Vector3 _goalPosition;

	private float _toGoalSpeed;

	private float _flyTime;

	private float _beforeDistance;

	private bool _isMoving;

	public SuperTextMesh Text => _text;

	public void BeginFly(int score, Vector3 spreadVelocity, Vector3 goalPosition, Action callback)
	{
		_score = score;
		_spreadVelocity = spreadVelocity;
		_goalPosition = goalPosition;
		_callback = callback;
		_transform = base.transform;
		_toGoalSpeed = 0f;
		_flyTime = 0f;
		_beforeDistance = 0f;
		_isMoving = true;
		if (score == 0)
		{
			_spreadVelocity = Vector3.zero;
			_goalPosition = base.transform.position;
			_goalPosition.y -= 5f;
			_flyTime = 0.2f;
		}
	}

	private void FinishFly()
	{
		_isMoving = false;
		base.gameObject.SetActive(value: false);
		if (_score != 0)
		{
			SingletonMonoBehaviour<ScoreManager>.Instance.AddScore(_score);
		}
		_callback();
	}

	protected virtual void Update()
	{
		if (_isMoving)
		{
			Vector3 vector = _spreadVelocity + (_goalPosition - _transform.position).normalized * _toGoalSpeed;
			_transform.position += vector * Time.deltaTime;
			_spreadVelocity *= 0.9f;
			if (_flyTime > 0.2f)
			{
				_toGoalSpeed += 0.2f;
			}
			float num = Vector3.Distance(_goalPosition, _transform.position);
			if (num > _beforeDistance && _flyTime > 0.5f)
			{
				FinishFly();
			}
			_beforeDistance = num;
			_flyTime += Time.deltaTime;
		}
	}
}
public class ScoreManager : SingletonMonoBehaviour<ScoreManager>
{
	private readonly ReactiveProperty<int> _currentScoreReactiveProperty = new ReactiveProperty<int>(0);

	public IObservable<int> CurrentScoreReactiveProperty => _currentScoreReactiveProperty;

	public int CurrentScore { get; private set; }

	protected override void Init()
	{
		base.Init();
	}

	public void Appear(int score, BonusType bonusType, int comboBonus, int distanceBonus, Vector3 position)
	{
		SingletonMonoBehaviour<ReuseProductionGenerator>.Instance.PlayScoreAcquisitionProduction(score, bonusType, comboBonus, distanceBonus, position);
		CurrentScore = Mathf.Max(CurrentScore + score, 0);
	}

	public void AddScore(int score)
	{
		_currentScoreReactiveProperty.Value = Mathf.Clamp(_currentScoreReactiveProperty.Value + score, 0, 999999999);
	}
}
public class TotalScoreText : SingletonMonoBehaviour<TotalScoreText>
{
	[SerializeField]
	[Required]
	private SuperTextMesh _infoText;

	[SerializeField]
	[Required]
	private SuperTextMesh _scoreText;

	private int _startScore;

	private int _endScore;

	private bool _isCountUpping;

	private float _countUpTime;

	private static readonly float COUNT_UP_TIME = 0.5f;

	[SerializeField]
	private AnimationCurve _coutUpAnimationCurve;

	private int _consecutiveScoreCount;

	private float _consecutiveScoreLimit;

	private int _beforeScore;

	private bool _wassUp = true;

	public Vector3 TextPosition => _scoreText.transform.position;

	public Color TextColor => _scoreText.color;

	private void Start()
	{
		SingletonMonoBehaviour<ScoreManager>.Instance.CurrentScoreReactiveProperty.Subscribe(UpdateScore);
		_infoText.text = LocalizedUtility.Get("TotalScoreText");
		_infoText.Rebuild();
		FontMasterData.Entity.UpdateFonts(_infoText, _scoreText);
		UpdateText();
	}

	private void Update()
	{
		if (_consecutiveScoreLimit > 0f)
		{
			_consecutiveScoreLimit -= Time.deltaTime;
			if (_consecutiveScoreLimit <= 0f)
			{
				_consecutiveScoreCount = 0;
			}
		}
		if (_isCountUpping)
		{
			_countUpTime = Mathf.Min(_countUpTime + Time.deltaTime, COUNT_UP_TIME);
			_isCountUpping = _countUpTime < COUNT_UP_TIME;
			UpdateText();
		}
	}

	private void UpdateScore(int score)
	{
		if (_beforeScore != score)
		{
			_startScore = _endScore;
			_endScore = score;
			_countUpTime = 0f;
			_isCountUpping = true;
			UpdateText();
			bool flag = score >= _beforeScore;
			_beforeScore = score;
			if (_wassUp != flag)
			{
				_consecutiveScoreCount = 0;
			}
			_wassUp = flag;
			float pitch = Mathf.Min(1f + (float)_consecutiveScoreCount * 0.02f, 2f);
			SingletonMonoBehaviour<ReuseProductionGenerator>.Instance.PlayParticle((!flag) ? ReuseParticleType.CountDownParticle : ReuseParticleType.CountUpParticle, TextPosition, pitch, is3DSound: false);
			_consecutiveScoreCount++;
		}
	}

	private void UpdateText()
	{
		float num = _coutUpAnimationCurve.Evaluate(_countUpTime / COUNT_UP_TIME);
		int num2 = Mathf.RoundToInt((float)_startScore * (1f - num) + (float)_endScore * num);
		_scoreText.text = num2.ToString();
		_scoreText.Rebuild();
	}
}
public class GameSceneMoveSmartPhone : SceneMoveSmartPhone
{
	protected override string _textKey => "ToSetting";

	protected override void OnRelease()
	{
		base.OnRelease();
		SingletonMonoBehaviour<GameScenePostProcessManager>.Instance.ShowNormal();
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.CancelFade();
	}

	protected override void PlayTextTween(float duration, float delay)
	{
		SingletonMonoBehaviour<GameScenePostProcessManager>.Instance.CreateMoveSceneTween(_textSequence, duration);
		_textSequence.PrependInterval(delay).OnComplete(base.Activate);
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.Fade(duration + delay, 1f, 0f);
	}

	protected override void ChangeScene()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangeScene("Setting");
	}
}
public class RetrySmartPhone : SceneMoveSmartPhone
{
	protected override string _textKey => "TimeBack";

	protected override void OnGrab()
	{
		SingletonMonoBehaviour<TutorialManager>.Instance.HideRetrySmartPhoneTargetParticle();
		base.OnGrab();
	}

	protected override void OnRelease()
	{
		base.OnRelease();
		SingletonMonoBehaviour<GameScenePostProcessManager>.Instance.ShowNormal();
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.CancelFade();
	}

	protected override void PlayTextTween(float duration, float delay)
	{
		SingletonMonoBehaviour<GameScenePostProcessManager>.Instance.CreateBackTimeTween(_textSequence, duration);
		_textSequence.PrependInterval(delay).OnComplete(base.Activate);
		SingletonMonoBehaviour<ClassroomSpeaker>.Instance.Fade(duration + delay, 1f, 0f);
	}

	protected override void ChangeScene()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangeScene("Main");
	}
}
public class Tongue : SingletonMonoBehaviour<Tongue>
{
	[Flags]
	public enum State
	{
		None = 1,
		Gold = 2,
		Money = 4,
		Transparent = 8
	}

	[SerializeField]
	[Required]
	private SkinnedMeshRenderer _renderer;

	[SerializeField]
	[Required]
	private Material _normalMaterial;

	[SerializeField]
	[Required]
	private Material _goldMaterial;

	[SerializeField]
	[Required]
	private Material _silverMaterial;

	[SerializeField]
	[Required]
	private Material _halfMaterial;

	[SerializeField]
	[Required]
	private Material _transparentMaterial;

	[SerializeField]
	[Required]
	private ParticleSystem _goldParticle;

	[SerializeField]
	[Required]
	private ParticleSystem _silverParticle;

	[SerializeField]
	[Required]
	private ParticleSystem _transparentParticle;

	[SerializeField]
	[Required]
	private Transform _scoreTarget;

	[SerializeField]
	[Required]
	private Transform _center;

	private bool _isFever;

	private float _feverTime = 10f;

	private LickableObjectType _beforeLickableObjectType = LickableObjectType.Catfish;

	private float _lickableSpan;

	private State _currentState = State.None;

	private float _transparentTime;

	public Transform ScoreTarget => _scoreTarget;

	public Transform Center => _center;

	public bool IsFever => _isFever;

	public bool IsActive { get; private set; } = true;


	protected override void Init()
	{
		base.Init();
		_renderer.material = _normalMaterial;
		BoxCollider[] componentsInChildren = base.transform.GetComponentsInChildren<BoxCollider>();
		foreach (BoxCollider boxCollider in componentsInChildren)
		{
			BoxCollider boxCollider2 = boxCollider.gameObject.AddComponent<BoxCollider>();
			boxCollider2.center = boxCollider.center;
			boxCollider2.size = boxCollider.size;
			boxCollider2.isTrigger = true;
		}
	}

	private void Start()
	{
		ChangeActive(isActive: false);
		UpdateVisual();
	}

	private void Update()
	{
		_lickableSpan += Time.deltaTime;
		if (_isFever)
		{
			_feverTime -= Time.deltaTime;
			if (!(_feverTime > 0f))
			{
				ChangeFever(isFever: false);
			}
		}
	}

	private void UpdateVisual()
	{
		if (IsActiveState(State.Transparent))
		{
			_renderer.material = _transparentMaterial;
		}
		else if (!IsActiveState(State.Gold) && !IsActiveState(State.Money))
		{
			_renderer.material = _normalMaterial;
		}
		else if (!IsActiveState(State.Gold))
		{
			_renderer.material = _silverMaterial;
		}
		else if (!IsActiveState(State.Money))
		{
			_renderer.material = _goldMaterial;
		}
		else
		{
			_renderer.material = _halfMaterial;
		}
	}

	public bool IsActiveState(State state)
	{
		return (_currentState & state) == state;
	}

	private void SetState(State state)
	{
		if (!IsActiveState(state))
		{
			_currentState |= state;
			UpdateVisual();
			switch (state)
			{
			case State.Gold:
				_goldParticle.Play();
				break;
			case State.Money:
				_silverParticle.Play();
				break;
			case State.Transparent:
				_transparentParticle.Play();
				_transparentTime = Time.time;
				break;
			}
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Transform", base.gameObject, is3DSound: true);
		}
	}

	public void ResetState(State state)
	{
		if (IsActiveState(state) && (state != State.Transparent || !(Time.time - _transparentTime < 20f) || SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.GameOver))
		{
			_currentState &= ~state;
			UpdateVisual();
			if (state == State.Transparent)
			{
				_transparentParticle.Play();
			}
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_Transform", base.gameObject, is3DSound: true);
		}
	}

	private void ChangeActive(bool isActive)
	{
		IsActive = isActive;
		base.gameObject.SetActive(IsActive);
	}

	public void ShowIfNeeded()
	{
		if (!base.gameObject.activeSelf)
		{
			ChangeActive(isActive: true);
			base.transform.SetLocalScaleZ(0f);
			base.transform.DOScaleZ(1f, 0.5f);
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.PlayOneShot("Audio/SE/SE_FlyHold", base.gameObject, is3DSound: true);
		}
	}

	private void ChangeFever(bool isFever)
	{
		_isFever = isFever;
		if (_isFever)
		{
			SingletonMonoBehaviour<FeverEffectManager>.Instance.Play();
		}
		else
		{
			SingletonMonoBehaviour<FeverEffectManager>.Instance.Stop();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		GirlAccessory componentInParent = other.gameObject.GetComponentInParent<GirlAccessory>();
		LickableObject componentInParent2 = other.gameObject.GetComponentInParent<LickableObject>();
		if (componentInParent == null && componentInParent2 == null)
		{
			return;
		}
		Girl girl = ((componentInParent2 == null) ? null : componentInParent2.gameObject.GetComponent<Girl>());
		if (girl != null && girl.IsInvincible)
		{
			Debug.Log("無敵な女の子なのでスルー");
			return;
		}
		LickableObjectType lickableObjectType = ((componentInParent2 == null) ? LickableObjectType.Recorder : componentInParent2.GetObjectType());
		float num = ((componentInParent != null || _beforeLickableObjectType == lickableObjectType) ? 0.3f : 0.15f);
		if (_lickableSpan < num)
		{
			return;
		}
		_lickableSpan = 0f;
		UserDataAccessorManager.PlayRecordDataAccessor.AddLickedCount();
		ReuseParticleType particleType = (_isFever ? ReuseParticleType.LickeFeverEffect : ReuseParticleType.LickePlusEffect);
		SingletonMonoBehaviour<ReuseProductionGenerator>.Instance.PlayParticle(particleType, _scoreTarget.position);
		if (componentInParent != null)
		{
			if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.GameOver)
			{
				SingletonMonoBehaviour<AfterGameOverGirlManager>.Instance.SurpriseIfNeeded();
			}
			componentInParent.OnLick();
			return;
		}
		_beforeLickableObjectType = lickableObjectType;
		componentInParent2.OnLick();
		UserDataAccessorManager.PlayRecordDataAccessor.AddLickedObjectType(lickableObjectType);
		switch (lickableObjectType)
		{
		case LickableObjectType.Ingot:
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstIngot);
			SetState(State.Gold);
			break;
		case LickableObjectType.Money:
			SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstMoney);
			SetState(State.Money);
			break;
		case LickableObjectType.TransparentTube:
			if ((componentInParent2 as OnceLickableObject).UseIfNeeded())
			{
				SetState(State.Transparent);
				SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstTransparent);
				return;
			}
			break;
		case LickableObjectType.TimeStopClock:
			if ((componentInParent2 as OnceLickableObject).UseIfNeeded())
			{
				SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstStopTime);
				return;
			}
			break;
		}
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.Before)
		{
			SingletonMonoBehaviour<GameManager>.Instance.GameStart();
		}
		if (SingletonMonoBehaviour<GirlManager>.Instance.IsWithinGameOver(lickableObjectType == LickableObjectType.Girl))
		{
			if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.Playing)
			{
				if (_isFever)
				{
					ChangeFever(isFever: false);
				}
				SingletonMonoBehaviour<GameManager>.Instance.GameOver((lickableObjectType == LickableObjectType.Girl) ? GameOverType.LickedGirl : GameOverType.Found);
			}
			else if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.GameOver)
			{
				SingletonMonoBehaviour<AfterGameOverGirlManager>.Instance.SurpriseIfNeeded();
			}
		}
		switch (lickableObjectType)
		{
		case LickableObjectType.TapiocaTeaRainbow:
			if ((componentInParent2 as OnceLickableObject).UseIfNeeded())
			{
				ChangeFever(isFever: true);
				SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstFever);
			}
			return;
		case LickableObjectType.Girl:
			if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.Playing)
			{
				SingletonMonoBehaviour<AchievementManager>.Instance.SetAchievement(AchievementType.FirstLickedGirlSuccess);
			}
			break;
		}
		if (SingletonMonoBehaviour<GameManager>.Instance.CurrentState == GameManager.State.Playing)
		{
			SingletonMonoBehaviour<InstructionManager>.Instance.CheckInstruction(componentInParent2);
		}
	}
}
public class TongueRotator : MonoBehaviour
{
	[SerializeField]
	private AnimationCurve _rotateCurve;

	private Sequence _sequence;

	public void BeginRotate()
	{
		FinishTween();
		_sequence = DOTween.Sequence().Append(base.transform.DOLocalRotate(new Vector3(0f, 0f, -90f), 0.1f).SetEase(_rotateCurve)).OnComplete(FinishTween);
		_sequence.Play();
	}

	private void FinishTween()
	{
		if (_sequence != null)
		{
			_sequence.Kill();
			_sequence = null;
		}
	}
}
public class TongueScaler : MonoBehaviour
{
	private enum State
	{
		Normal,
		ScaleUp
	}

	private State _state;

	[SerializeField]
	private AnimationCurve _scaleUpCurve;

	[SerializeField]
	private AnimationCurve _scaleDownCurve;

	public void ScaleUp()
	{
		if (_state == State.ScaleUp)
		{
			Debug.LogWarning("舌は既に拡大中です");
			return;
		}
		_state = State.ScaleUp;
		base.transform.DOScale(Vector3.one * 2f, 0.2f).SetEase(_scaleUpCurve);
	}

	public void ScaleDown()
	{
		if (_state != State.ScaleUp)
		{
			Debug.LogWarning("舌は拡大しないので縮小できません");
			return;
		}
		_state = State.Normal;
		base.transform.DOScale(Vector3.one * 0.6f, 0.2f).SetEase(_scaleDownCurve);
	}
}
public class InvalidMessageText : MonoBehaviour
{
	[SerializeField]
	[Required]
	private SuperTextMesh _text;

	private Font _defaultFont;

	[SerializeField]
	private bool _isGirlText;

	private Transform _transform;

	private Transform _camera;

	private void Start()
	{
		base.gameObject.SetActive(!ClothingUtility.CanChange());
		_defaultFont = _text.font;
		if (_isGirlText)
		{
			_transform = base.transform;
			_camera = SingletonMonoBehaviour<SettingCameraController>.Instance.CurrentCamera.transform;
		}
		UserDataAccessorManager.SettingDataAccessor.CurrentLanguageObservable.Subscribe(Localize).AddTo(this);
	}

	private void Update()
	{
		if (!(_transform == null) && !(_camera == null))
		{
			_transform.LookAt(_camera);
		}
	}

	private void Localize(AvailableLanguage availableLanguage)
	{
		string text = string.Format(LocalizedUtility.Get("DLCInvalidMessage"), LocalizedUtility.Get("DLCName"));
		FontMasterData.Entity.UpdateFont(_text, _defaultFont);
		_text.SetTextAndRebuild("<c=Gold>" + text);
	}
}
public class LanguageChanger : SingletonMonoBehaviour<LanguageChanger>
{
	[SerializeField]
	private List<LanguageSettingObject> _languageSettingObjectList = new List<LanguageSettingObject>();

	[SerializeField]
	private Color _selectedTextColor;

	[SerializeField]
	private Color _defaultTextColor;

	private AudioPlayer _sePlayer;

	public Color SelectedTextColor => _selectedTextColor;

	public Color DefaultTextColor => _defaultTextColor;

	private void Start()
	{
		_sePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_SelectMenu");
		foreach (LanguageSettingObject languageSettingObject in _languageSettingObjectList)
		{
			languageSettingObject.Triggered += ChangeLanguage;
		}
		UserDataAccessorManager.SettingDataAccessor.CurrentLanguageObservable.Subscribe(OnChangeLanguage).AddTo(this);
	}

	private void ChangeLanguage(AvailableLanguage language, VRHand hand)
	{
		if (UserDataAccessorManager.SettingDataAccessor.CurrentLanguage != language)
		{
			SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(hand.IsLeft);
			_sePlayer.Play();
			UserDataAccessorManager.SettingDataAccessor.ChangeLanguage(language);
		}
	}

	private void OnChangeLanguage(AvailableLanguage availableLanguage)
	{
		foreach (LanguageSettingObject languageSettingObject in _languageSettingObjectList)
		{
			languageSettingObject.ChangeColor((languageSettingObject.Language == availableLanguage) ? _selectedTextColor : _defaultTextColor);
		}
	}
}
public class SettingCameraController : CameraController<SettingCameraController>
{
	protected override Vector3 INITIAL_POSITION => new Vector3(0.55f, 0f, 0.22f);

	protected override Vector3 INITIAL_ROTATION => new Vector3(0f, 180f, 0f);
}
public class SettingGirlManager : SingletonMonoBehaviour<SettingGirlManager>
{
	private SettingGirl _character;

	private CharacterType _characterType;

	private Transform _targetCharacter;

	private SettingGirlPlaceType _currentPlaceType;

	public bool IsCreatingCharacter { get; private set; }

	private void Start()
	{
		InitCharacter(UserDataAccessorManager.SettingDataAccessor.CurrentCharacterType);
	}

	public void InitCharacter(CharacterType characterType)
	{
		IsCreatingCharacter = true;
		_characterType = characterType;
		float num = 0f;
		if (_targetCharacter != null)
		{
			GirlClothingUpdater component = _targetCharacter.GetComponent<GirlClothingUpdater>();
			if (component != null)
			{
				component.DestroyAllAccessory();
			}
			num = 0.01f;
			_character = null;
			UnityEngine.Object.Destroy(_targetCharacter.gameObject);
		}
		if (num > 0f)
		{
			StartCoroutine(this.DelayMethod(num, CreateCharacter));
		}
		else
		{
			CreateCharacter();
		}
	}

	private void CreateCharacter()
	{
		if (ClothingUtility.CanChange())
		{
			_character = base.transform.CreateChildFromOriginal<SettingGirl>(Resources.Load<Transform>(System.IO.Path.Combine("Prefab/Character/Setting", $"Setting{_characterType}")));
			_targetCharacter = _character.transform;
		}
		else
		{
			_targetCharacter = base.transform.CreateChildFromOriginal<Transform>(Resources.Load<Transform>(System.IO.Path.Combine("Prefab/Character/Setting", $"Invalid{_characterType}")));
		}
		_targetCharacter.gameObject.SetActive(value: true);
		_targetCharacter.localPosition = new Vector3(100f, 0f, 0f);
		StartCoroutine(this.DelayMethod(0.03f, delegate
		{
			if (_character != null)
			{
				ChangePlace(_currentPlaceType, _character);
			}
			else
			{
				ChangeTransform(_currentPlaceType, _targetCharacter);
			}
			IsCreatingCharacter = false;
		}));
	}

	public void ChangePlace(SettingGirlPlaceType girlPlaceType)
	{
		ChangePlace(girlPlaceType, _character);
	}

	private void ChangeTransform(SettingGirlPlaceType girlPlaceType, Transform character)
	{
		if (character == null)
		{
			return;
		}
		_currentPlaceType = girlPlaceType;
		switch (_currentPlaceType)
		{
		case SettingGirlPlaceType.Initial:
			character.transform.localPosition = new Vector3(3f, 0f, -0.53f);
			character.transform.localRotation = Quaternion.Euler(0f, -50f, 0f);
			break;
		case SettingGirlPlaceType.Bench:
			if (_characterType == CharacterType.Boy)
			{
				character.transform.localPosition = new Vector3(1.358f, 0.433f, -3.629f);
				character.transform.localRotation = Quaternion.Euler(-0.058f, -91.56901f, -4.972f);
			}
			else
			{
				character.transform.localPosition = new Vector3(1.356f, 0.411f, -3.548f);
				character.transform.localRotation = Quaternion.Euler(-2.587f, -87.628f, -0.107f);
			}
			break;
		case SettingGirlPlaceType.Bed:
			if (_characterType == CharacterType.Boy)
			{
				character.transform.localPosition = new Vector3(-3.837f, 0.554f, 3.066f);
				character.transform.localRotation = Quaternion.Euler(-0.214f, -270f, 0f);
			}
			else
			{
				character.transform.localPosition = new Vector3(-3.838f, 0.534f, 3.057f);
				character.transform.localRotation = Quaternion.Euler(-2.406f, 90f, 0f);
			}
			break;
		case SettingGirlPlaceType.SimpleBed:
			character.transform.localPosition = new Vector3(0.72f, 0.6f, 1.682f);
			character.transform.localRotation = Quaternion.Euler(0f, -177.209f, -15.5f);
			break;
		case SettingGirlPlaceType.WeightScale:
			if (_characterType == CharacterType.Boy)
			{
				character.transform.localPosition = new Vector3(-2.427f, 0.119f, -3.522f);
			}
			else
			{
				character.transform.localPosition = new Vector3(-2.427f, 0.112f, -3.522f);
			}
			character.transform.localRotation = Quaternion.Euler(0f, -168.165f, 0f);
			break;
		case SettingGirlPlaceType.Shelf:
			if (_characterType == CharacterType.Boy)
			{
				character.transform.localPosition = new Vector3(-0.107f, -0.006f, 3.032f);
			}
			else
			{
				character.transform.localPosition = new Vector3(-0.107f, -0.035f, 3.032f);
			}
			character.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
			break;
		default:
			Debug.LogWarning($"{_currentPlaceType}の設定はありません");
			break;
		}
	}

	private void ChangePlace(SettingGirlPlaceType girlPlaceType, SettingGirl character)
	{
		if (!(character == null))
		{
			ChangeTransform(girlPlaceType, _character.transform);
			switch (girlPlaceType)
			{
			case SettingGirlPlaceType.Initial:
				character.ChangeBodyAnimation(GirlBodyAnimationType.Normal);
				break;
			case SettingGirlPlaceType.Bench:
				character.ChangeBodyAnimation(GirlBodyAnimationType.LiedownSide);
				break;
			case SettingGirlPlaceType.Bed:
				character.ChangeBodyAnimation(GirlBodyAnimationType.LiedownOver);
				break;
			case SettingGirlPlaceType.SimpleBed:
				character.ChangeBodyAnimation(GirlBodyAnimationType.Liedown);
				break;
			case SettingGirlPlaceType.WeightScale:
				character.ChangeBodyAnimation(GirlBodyAnimationType.LookDown);
				break;
			case SettingGirlPlaceType.Shelf:
				character.ChangeBodyAnimation(GirlBodyAnimationType.Looking);
				break;
			default:
				Debug.LogWarning($"{girlPlaceType}の設定はありません");
				break;
			}
			switch (girlPlaceType)
			{
			case SettingGirlPlaceType.Bench:
			case SettingGirlPlaceType.Bed:
			case SettingGirlPlaceType.SimpleBed:
				character.ChangeDefaultFaceAnimation(GirlFaceAnimationType.Sleep);
				break;
			case SettingGirlPlaceType.WeightScale:
				character.ChangeDefaultFaceAnimation(GirlFaceAnimationType.Sad);
				break;
			default:
				character.ChangeDefaultFaceAnimation(GirlFaceAnimationType.Normal);
				break;
			}
			switch (girlPlaceType)
			{
			case SettingGirlPlaceType.Bed:
				character.ChangeDefaultLookTargetPosition(new Vector3(0f, 0.255f, -0.52f));
				break;
			case SettingGirlPlaceType.Bench:
				character.ChangeDefaultLookTargetPosition(new Vector3(0.24f, 0.17f, -0.649f));
				break;
			case SettingGirlPlaceType.SimpleBed:
				character.ChangeDefaultLookTargetPosition(new Vector3(22.52f, -38.27f, 1.33f));
				break;
			case SettingGirlPlaceType.WeightScale:
				character.ChangeDefaultLookTargetPosition(new Vector3(0f, 0.936f, 0.382f));
				break;
			case SettingGirlPlaceType.Shelf:
				character.ChangeDefaultLookTargetPosition(new Vector3(0f, 1.434f, 0.377f));
				break;
			default:
				character.SetAlwaysChaseCamera();
				break;
			}
		}
	}
}
public class SettingSceneManager : SingletonMonoBehaviour<SettingSceneManager>
{
	[SerializeField]
	[Required]
	private GameObject _bgmTargetObject;

	private AudioPlayer _settingBGMPlayer;

	private List<AudioPlayer> _gameBGMPlayerList = new List<AudioPlayer>();

	private AudioPlayer _currentGameBGMPlayer;

	private float _gameBGMLimit;

	private void Start()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.FadeOut(0f);
		_settingBGMPlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_bgmTargetObject, "Audio/BGM/BGM_Setting");
		_settingBGMPlayer.Disable3DSound();
		for (int i = 1; i <= BGMUtility.BGM_NUM; i++)
		{
			AudioPlayer player = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, BGMUtility.GetPlayingBGMPath(i));
			player.Disable3DSound();
			_gameBGMPlayerList.Add(player);
		}
		StartCoroutine(this.DelayMethod(0.1f, BeginFadeIn));
	}

	private void BeginFadeIn()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.FadeIn(0.5f, isIgnoreTimeScale: true, FinishFadeIn);
	}

	private void FinishFadeIn()
	{
		_settingBGMPlayer.Play(1f, 0f, 1f, isLoop: true);
	}

	private void Update()
	{
		if (!(_gameBGMLimit <= 0f))
		{
			_gameBGMLimit -= Time.deltaTime;
			if (!(_gameBGMLimit > 0f))
			{
				UnPauseSettingBGM();
			}
		}
	}

	public void FadeBGM(float duration, float from, float to)
	{
		if (_currentGameBGMPlayer != null)
		{
			_currentGameBGMPlayer.Fade(duration, from, to);
		}
		else
		{
			_settingBGMPlayer.Fade(duration, from, to);
		}
	}

	public void CancelFadeBGM()
	{
		if (_currentGameBGMPlayer != null)
		{
			_currentGameBGMPlayer.CancelFade();
			UnPauseSettingBGM();
		}
		else
		{
			_settingBGMPlayer.CancelFade();
		}
	}

	public void UpdateBGMVolume()
	{
		_settingBGMPlayer.UpdateVolume();
		foreach (AudioPlayer gameBGMPlayer in _gameBGMPlayerList)
		{
			gameBGMPlayer.UpdateVolume();
		}
	}

	public void PlayGameBGM(int bgmNo)
	{
		StopGameBGM();
		_currentGameBGMPlayer = _gameBGMPlayerList[bgmNo - 1];
		_currentGameBGMPlayer.Play();
		_gameBGMLimit = 10f;
		_settingBGMPlayer.Pause();
	}

	private void StopGameBGM()
	{
		foreach (AudioPlayer gameBGMPlayer in _gameBGMPlayerList)
		{
			gameBGMPlayer.Stop();
		}
		_gameBGMLimit = 0f;
		_currentGameBGMPlayer = null;
	}

	private void UnPauseSettingBGM()
	{
		StopGameBGM();
		_settingBGMPlayer.UnPause();
	}
}
public class SettingScenePostProcessManager : PostProcessManager<SettingScenePostProcessManager>
{
	public override void ShowNormal()
	{
		base.ShowNormal();
		_normalPostProcess.weight = 1f;
	}
}
[RequireComponent(typeof(Animator), typeof(HeadLookController), typeof(GirlEyeMarkManager))]
public class SettingGirl : MonoBehaviour
{
	private Animator _animator;

	private HeadLookController _headLookController;

	private GirlEyeMarkManager _eyeMarkManager;

	private Transform _cameraTransform;

	private GirlBodyAnimationType _currentBodyAnimationType;

	private GirlFaceAnimationType _currentFaceAnimationType;

	private GirlFaceAnimationType _defaultFaceAnimationType;

	private GirlFaceAnimationType _beforeFaceAnimationType;

	private Transform _defaultLookTarget;

	private bool _isAlwaysChaseCamera = true;

	private Transform _beforeLookTarget;

	private float _beforeLookTargetLimit;

	private void Awake()
	{
		_defaultLookTarget = base.transform.CreateChild("DefaultLookTarget");
		_defaultLookTarget.ResetInLocal();
		_animator = base.gameObject.GetComponent<Animator>();
		_headLookController = base.gameObject.GetComponent<HeadLookController>();
		_eyeMarkManager = base.gameObject.GetComponent<GirlEyeMarkManager>();
		_cameraTransform = SingletonMonoBehaviour<SettingCameraController>.Instance.CurrentCamera.transform;
	}

	private void LateUpdate()
	{
		if (_cameraTransform == null || _headLookController == null)
		{
			return;
		}
		GirlFaceAnimationType girlFaceAnimationType = GirlFaceAnimationType.Doubt;
		if (_eyeMarkManager.CurrentLeftMarkType != 0 || _eyeMarkManager.CurrentRightMarkType != 0)
		{
			girlFaceAnimationType = GirlFaceAnimationType.Surprise;
		}
		Transform transform = null;
		if (_eyeMarkManager.CurrentRightTarget != null)
		{
			transform = _eyeMarkManager.CurrentRightTarget;
		}
		else if (_eyeMarkManager.CurrentLeftTarget != null)
		{
			transform = _eyeMarkManager.CurrentLeftTarget;
		}
		if (transform == null)
		{
			if (_beforeLookTarget != null)
			{
				_headLookController.target = _beforeLookTarget.position;
				girlFaceAnimationType = _beforeFaceAnimationType;
				_beforeLookTargetLimit -= Time.deltaTime;
				if (_beforeLookTargetLimit <= 0f)
				{
					_beforeLookTarget = null;
				}
			}
			else
			{
				_headLookController.target = (_isAlwaysChaseCamera ? _cameraTransform.position : _defaultLookTarget.position);
				girlFaceAnimationType = _defaultFaceAnimationType;
			}
		}
		else
		{
			_headLookController.target = transform.position;
			_beforeLookTarget = transform;
			_beforeFaceAnimationType = girlFaceAnimationType;
			_beforeLookTargetLimit = 2f;
		}
		ChangeFaceAnimation(girlFaceAnimationType);
	}

	public void ChangeDefaultLookTargetPosition(Vector3 position)
	{
		_isAlwaysChaseCamera = false;
		_defaultLookTarget.localPosition = position;
	}

	public void SetAlwaysChaseCamera()
	{
		_isAlwaysChaseCamera = true;
	}

	public void ChangeDefaultFaceAnimation(GirlFaceAnimationType faceAnimationType)
	{
		_defaultFaceAnimationType = faceAnimationType;
	}

	public void ChangeBodyAnimation(GirlBodyAnimationType bodyAnimationType)
	{
		if (_currentBodyAnimationType != bodyAnimationType)
		{
			_currentBodyAnimationType = bodyAnimationType;
			_animator.Play(Animator.StringToHash(bodyAnimationType.ToString()), 0, 0f);
		}
	}

	private void ChangeFaceAnimation(GirlFaceAnimationType faceAnimationType, float fadeLength = 0.5f)
	{
		if (_currentFaceAnimationType != faceAnimationType)
		{
			_currentFaceAnimationType = faceAnimationType;
			_animator.CrossFade($"{_currentFaceAnimationType}Face", fadeLength);
		}
	}
}
public class BGMSettingObject : GirlSettingObject
{
	[SerializeField]
	[Required]
	private GameObject _invalidBack;

	[SerializeField]
	[Required]
	private SuperTextMesh _text;

	[SerializeField]
	[Required]
	private Image _frame;

	[SerializeField]
	private Color _defaultColor;

	[SerializeField]
	private Color _checkColor;

	[SerializeField]
	private int _bgmNo;

	private bool _isSelected;

	protected override bool CanChange
	{
		get
		{
			if (_canChange)
			{
				return !_isSelected;
			}
			return false;
		}
	}

	public event Action<int> Changed = delegate
	{
	};

	public void Init(int bgmNo, int currentBGMNox)
	{
		_iconImage.gameObject.SetActive(value: false);
		_bgmNo = bgmNo;
		_text.SetTextAndRebuild(_bgmNo.ToString());
		_canChange = BGMUtility.CanUse(_bgmNo);
		_invalidBack.SetActive(!_canChange);
		UpdateUI(currentBGMNox);
	}

	public void UpdateUI(int currentBGMNox)
	{
		_isSelected = currentBGMNox == _bgmNo;
		_text.SetTextAndRebuild(_isSelected ? "✔" : _bgmNo.ToString());
		Color color = (_isSelected ? _checkColor : _defaultColor);
		_text.SetColor(color);
		_frame.color = color;
	}

	protected override void ChangeSetting()
	{
		this.Changed(_bgmNo);
	}
}
public class BGMSettingObjectPlacer : MonoBehaviour
{
	[SerializeField]
	[Required]
	private BGMSettingObject _settingObject;

	private List<BGMSettingObject> _settingObjectList = new List<BGMSettingObject>();

	private void Start()
	{
		int bGMNo = UserDataAccessorManager.SettingDataAccessor.BGMNo;
		_settingObject.InitOnFirstInstantiate(canChange: true);
		int num = 0;
		for (int i = 1; i <= BGMUtility.BGM_NUM; i++)
		{
			BGMSettingObject bGMSettingObject = _settingObject;
			if (num > 0)
			{
				bGMSettingObject = _settingObject.transform.parent.CreateChildFromOriginal<BGMSettingObject>(_settingObject.transform);
			}
			_settingObjectList.Add(bGMSettingObject);
			bGMSettingObject.Init(i, bGMNo);
			bGMSettingObject.Changed += OnChanged;
			int num2 = num % 3;
			int num3 = num / 3;
			bGMSettingObject.transform.ResetInLocal();
			bGMSettingObject.transform.localPosition = new Vector3(-32 + num2 * 32, 56 - num3 * 32, 0f);
			num++;
		}
	}

	private void OnChanged(int bgmNo)
	{
		foreach (BGMSettingObject settingObject in _settingObjectList)
		{
			settingObject.UpdateUI(bgmNo);
		}
		UserDataAccessorManager.SettingDataAccessor.ChangeBGMNo(bgmNo);
		SingletonMonoBehaviour<SettingSceneManager>.Instance.PlayGameBGM(bgmNo);
	}
}
public class CharacterSettingObject : GirlSettingObject
{
	[SerializeField]
	[Required]
	private GameObject _invalidBack;

	[SerializeField]
	private CharacterType _characterType;

	protected override bool CanChange
	{
		get
		{
			if (_canChange && !SingletonMonoBehaviour<SettingGirlManager>.Instance.IsCreatingCharacter)
			{
				return SingletonMonoBehaviour<CharacterSettingObjectPlacer>.Instance.CurrentCharacterType != _characterType;
			}
			return false;
		}
	}

	public event Action<CharacterType> Changed = delegate
	{
	};

	public void Init(CharacterType characterType, CharacterType currentCharacterType, Sprite icon)
	{
		_characterType = characterType;
		_iconImage.sprite = icon;
		_canChange = CharacterUtility.CanUse(_characterType);
		_invalidBack.SetActive(!_canChange);
		UpdateUI(currentCharacterType);
	}

	public void UpdateUI(CharacterType currentCharacterType)
	{
		float num = ((_canChange && currentCharacterType == _characterType) ? base._baseColorRate : 0.3f);
		_iconImage.color = new Color(num, num, num, 1f);
	}

	protected override void ChangeSetting()
	{
		this.Changed(_characterType);
	}
}
public class CharacterSettingObjectPlacer : SingletonMonoBehaviour<CharacterSettingObjectPlacer>
{
	[SerializeField]
	[Required]
	private CharacterSettingObject _settingObject;

	private List<CharacterSettingObject> _settingObjectList = new List<CharacterSettingObject>();

	[SerializeField]
	private CharacterType _currentCharacterType;

	public CharacterType CurrentCharacterType => _currentCharacterType;

	public event Action<CharacterType> Changed = delegate
	{
	};

	private void Start()
	{
		_currentCharacterType = UserDataAccessorManager.SettingDataAccessor.CurrentCharacterType;
		_settingObject.InitOnFirstInstantiate(canChange: true);
		SpriteAtlas spriteAtlas = Resources.Load<SpriteAtlas>("Texture/CharacterSettingIcon");
		int num = 0;
		foreach (CharacterType allIn in EnumUtility.GetAllInList<CharacterType>())
		{
			CharacterSettingObject characterSettingObject = _settingObject;
			if (num > 0)
			{
				characterSettingObject = _settingObject.transform.parent.CreateChildFromOriginal<CharacterSettingObject>(_settingObject.transform);
			}
			_settingObjectList.Add(characterSettingObject);
			characterSettingObject.Init(allIn, _currentCharacterType, spriteAtlas.GetSprite($"CharacterSettingIcon{allIn}"));
			characterSettingObject.Changed += OnChanged;
			int num2 = num % 2;
			int num3 = num / 2;
			characterSettingObject.transform.ResetInLocal();
			characterSettingObject.transform.localPosition = new Vector3(-24 + num2 * 48, 46 - num3 * 55, 0f);
			num++;
		}
		UpdateIcons();
	}

	private void OnChanged(CharacterType characterType)
	{
		_currentCharacterType = characterType;
		foreach (CharacterSettingObject settingObject in _settingObjectList)
		{
			settingObject.UpdateUI(_currentCharacterType);
		}
		UserDataAccessorManager.SettingDataAccessor.ChangeCharacterType(_currentCharacterType);
		SingletonMonoBehaviour<SettingGirlManager>.Instance.InitCharacter(_currentCharacterType);
		UpdateIcons();
		this.Changed(characterType);
	}

	private void UpdateIcons()
	{
		SingletonMonoBehaviour<GirlPlaceSettingManager>.Instance.UpdateIcons();
		SingletonMonoBehaviour<GirlClothingSettingObjectPlacer>.Instance.UpdateIcons();
	}
}
public class GirlClothingSettingObject : GirlSettingObject
{
	[SerializeField]
	private GirlClothesType _clothesType;

	[SerializeField]
	[Required]
	private SuperTextMesh _checkMark;

	public void Init(GirlClothesType clothesType)
	{
		_clothesType = clothesType;
		UpdateUI(UserDataAccessorManager.SettingDataAccessor.GetGirlClothesFlag(_clothesType));
	}

	public void UpdateSprite(SpriteAtlas iconAtlas, CharacterType currentCharacterType)
	{
		if (_clothesType == GirlClothesType.Unique1 || _clothesType == GirlClothesType.Unique2 || _clothesType == GirlClothesType.Unique3)
		{
			_iconImage.sprite = iconAtlas.GetSprite($"{SingletonMonoBehaviour<CharacterSettingObjectPlacer>.Instance.CurrentCharacterType}{_clothesType}");
		}
		else
		{
			_iconImage.sprite = iconAtlas.GetSprite($"{_clothesType}");
		}
	}

	private void UpdateUI(bool flag)
	{
		_checkMark.gameObject.SetActive(CanChange && flag);
	}

	protected override void ChangeSetting()
	{
		bool flag = !UserDataAccessorManager.SettingDataAccessor.GetGirlClothesFlag(_clothesType);
		UserDataAccessorManager.SettingDataAccessor.ChangeGirlClothesFlag(_clothesType, flag);
		UpdateUI(flag);
	}
}
public class GirlClothingSettingObjectPlacer : SingletonMonoBehaviour<GirlClothingSettingObjectPlacer>
{
	[SerializeField]
	[Required]
	private GirlClothingSettingObject _settingObject;

	private List<GirlClothingSettingObject> _settingObjectList = new List<GirlClothingSettingObject>();

	private SpriteAtlas _iconAtlas;

	protected override void Init()
	{
		base.Init();
		_settingObject.InitOnFirstInstantiate(ClothingUtility.CanChange());
		_iconAtlas = Resources.Load<SpriteAtlas>("Texture/AccessoryIcon");
		int num = 0;
		foreach (GirlClothesType allIn in EnumUtility.GetAllInList<GirlClothesType>())
		{
			GirlClothingSettingObject girlClothingSettingObject = _settingObject;
			if (num > 0)
			{
				girlClothingSettingObject = _settingObject.transform.parent.CreateChildFromOriginal<GirlClothingSettingObject>(_settingObject.transform);
			}
			girlClothingSettingObject.Init(allIn);
			_settingObjectList.Add(girlClothingSettingObject);
			int num2 = num % 3;
			int num3 = num / 3;
			girlClothingSettingObject.transform.ResetInLocal();
			girlClothingSettingObject.transform.localPosition = new Vector3(-35 + num2 * 35, 64f - (float)num3 * 29.5f, 0f);
			num++;
		}
	}

	public void UpdateIcons()
	{
		CharacterType currentCharacterType = SingletonMonoBehaviour<CharacterSettingObjectPlacer>.Instance.CurrentCharacterType;
		foreach (GirlClothingSettingObject settingObject in _settingObjectList)
		{
			settingObject.UpdateSprite(_iconAtlas, currentCharacterType);
		}
	}
}
public class GirlPlaceSettingManager : SingletonMonoBehaviour<GirlPlaceSettingManager>
{
	[SerializeField]
	[Required]
	private GirlPlaceSettingObject _settingObject;

	private List<GirlPlaceSettingObject> _settingObjectList = new List<GirlPlaceSettingObject>();

	[SerializeField]
	private SettingGirlPlaceType _currentPlaceType;

	private SpriteAtlas _iconAtlas;

	protected override void Init()
	{
		base.Init();
		_settingObject.InitOnFirstInstantiate(ClothingUtility.CanChange());
		_iconAtlas = Resources.Load<SpriteAtlas>("Texture/PlaceSettingIcon");
		int num = 0;
		foreach (SettingGirlPlaceType allIn in EnumUtility.GetAllInList<SettingGirlPlaceType>())
		{
			GirlPlaceSettingObject girlPlaceSettingObject = _settingObject;
			if (num > 0)
			{
				girlPlaceSettingObject = _settingObject.transform.parent.CreateChildFromOriginal<GirlPlaceSettingObject>(_settingObject.transform);
			}
			_settingObjectList.Add(girlPlaceSettingObject);
			girlPlaceSettingObject.Init(allIn);
			girlPlaceSettingObject.Changed += OnChanged;
			int num2 = num % 2;
			int num3 = num / 2;
			girlPlaceSettingObject.transform.ResetInLocal();
			girlPlaceSettingObject.transform.localPosition = new Vector3(-24 + num2 * 48, 46 - num3 * 55, 0f);
			num++;
		}
		OnChanged(SettingGirlPlaceType.Initial);
	}

	public void UpdateIcons()
	{
		CharacterType currentCharacterType = SingletonMonoBehaviour<CharacterSettingObjectPlacer>.Instance.CurrentCharacterType;
		foreach (GirlPlaceSettingObject settingObject in _settingObjectList)
		{
			settingObject.UpdateSprite(_iconAtlas, currentCharacterType);
		}
	}

	private void OnChanged(SettingGirlPlaceType placeType)
	{
		_currentPlaceType = placeType;
		foreach (GirlPlaceSettingObject settingObject in _settingObjectList)
		{
			settingObject.UpdateUI(_currentPlaceType);
		}
		SingletonMonoBehaviour<SettingGirlManager>.Instance.ChangePlace(_currentPlaceType);
	}
}
public class GirlPlaceSettingObject : GirlSettingObject
{
	private SettingGirlPlaceType _placeType;

	public event Action<SettingGirlPlaceType> Changed = delegate
	{
	};

	public void Init(SettingGirlPlaceType placeType)
	{
		_placeType = placeType;
	}

	public void UpdateSprite(SpriteAtlas iconAtlas, CharacterType currentCharacterType)
	{
		_iconImage.sprite = iconAtlas.GetSprite($"{currentCharacterType}{_placeType}");
	}

	public void UpdateUI(SettingGirlPlaceType currentPlaceType)
	{
		float num = ((!CanChange || currentPlaceType == _placeType) ? base._baseColorRate : 0.3f);
		_iconImage.color = new Color(num, num, num, 1f);
	}

	protected override void ChangeSetting()
	{
		this.Changed(_placeType);
	}
}
public abstract class GirlSettingObject : MonoBehaviour
{
	[SerializeField]
	[Required]
	protected Image _iconImage;

	[SerializeField]
	[ReadOnly]
	protected bool _canChange;

	[SerializeField]
	[ReadOnly]
	private AudioPlayer _sePlayer;

	private float _changeSpan;

	protected virtual bool CanChange => _canChange;

	protected float _baseColorRate => 0.9f;

	public void InitOnFirstInstantiate(bool canChange)
	{
		_canChange = canChange;
		_sePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_SelectMenu");
		_iconImage.color = Color.white * _baseColorRate;
	}

	private void Update()
	{
		if (_changeSpan > 0f)
		{
			_changeSpan -= Time.deltaTime;
		}
	}

	protected abstract void ChangeSetting();

	private void OnTriggerEnter(Collider other)
	{
		if (CanChange)
		{
			VRHand componentInParent = other.gameObject.GetComponentInParent<VRHand>();
			if (!(componentInParent == null) && !(_changeSpan > 0f))
			{
				SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(componentInParent.IsLeft);
				_changeSpan = 0.5f;
				_sePlayer.Play();
				ChangeSetting();
			}
		}
	}
}
public class LanguageSettingObject : MonoBehaviour
{
	[SerializeField]
	private AvailableLanguage _language;

	private SuperTextMesh _text;

	private Image _image;

	public AvailableLanguage Language => _language;

	public event Action<AvailableLanguage, VRHand> Triggered = delegate
	{
	};

	private void Awake()
	{
		_text = GetComponent<SuperTextMesh>();
		_image = GetComponentInChildren<Image>();
	}

	public void ChangeColor(Color color)
	{
		_text.SetColor(color);
		_image.color = color;
	}

	private void OnTriggerEnter(Collider other)
	{
		VRHand componentInParent = other.gameObject.GetComponentInParent<VRHand>();
		if (componentInParent != null)
		{
			this.Triggered(_language, componentInParent);
		}
	}
}
public class OperationSettingObject : AutoTextLocalizer
{
	[SerializeField]
	private OperationSettingType _operationSettingType;

	[SerializeField]
	[Required]
	private VRHandTriggerTarget _handTriggerTarget;

	[SerializeField]
	[Required]
	private Image _frame;

	[SerializeField]
	[Required]
	private SuperTextMesh _checkMark;

	private SettingDataAccessor _settingDataAccessor;

	private float _changeSpan;

	private AudioPlayer _sePlayer;

	private Tweener _tweener;

	private Color _tweenStartColor;

	private Color _tweenEndColor;

	protected override void Awake()
	{
		base.Awake();
		_handTriggerTarget.Triggered += ChangeSetting;
	}

	protected override void Start()
	{
		base.Start();
		_sePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, "Audio/SE/SE_SelectMenu");
		_tweenStartColor = SingletonMonoBehaviour<LanguageChanger>.Instance.SelectedTextColor;
		_tweenEndColor = SingletonMonoBehaviour<LanguageChanger>.Instance.DefaultTextColor;
		_settingDataAccessor = UserDataAccessorManager.SettingDataAccessor;
		UpdateCheckMark();
	}

	private void Update()
	{
		if (_changeSpan > 0f)
		{
			_changeSpan -= Time.deltaTime;
		}
	}

	private void UpdateCheckMark()
	{
		_checkMark.gameObject.SetActive((_operationSettingType == OperationSettingType.Rotation) ? _settingDataAccessor.RotationFlag : _settingDataAccessor.SquatFlag);
	}

	private void UpdateColor(Color color)
	{
		_text.SetColor(color);
		_checkMark.color = color;
		_frame.color = color;
	}

	private void ChangeSetting(VRHand hand)
	{
		if (!(_changeSpan > 0f))
		{
			_changeSpan = 0.2f;
			SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(hand.IsLeft);
			if (_operationSettingType == OperationSettingType.Rotation)
			{
				_settingDataAccessor.RotationFlag = !_settingDataAccessor.RotationFlag;
			}
			else if (_operationSettingType == OperationSettingType.UpDown)
			{
				_settingDataAccessor.SquatFlag = !_settingDataAccessor.SquatFlag;
			}
			UpdateCheckMark();
			SingletonMonoBehaviour<SettingCameraController>.Instance.UpdateSquatAndRotation();
			_sePlayer.Play();
			_tweener?.Kill();
			_tweener = DOTween.To(() => 0f, delegate(float timeRate)
			{
				UpdateColor(timeRate * _tweenEndColor + (1f - timeRate) * _tweenStartColor);
			}, 1f, 0.5f);
		}
	}
}
public class VolumeSettingObject : AutoTextLocalizer
{
	[SerializeField]
	private VolumeType _volumeType;

	[SerializeField]
	[Required]
	private SuperTextMesh _volumeText;

	[SerializeField]
	[Required]
	private VRHandTriggerTarget _minusButton;

	[SerializeField]
	[Required]
	private VRHandTriggerTarget _plusButton;

	private Image _minusButtonImage;

	private Image _plusButtonImage;

	[SerializeField]
	[Required]
	private Image _frame;

	private float _currentVolume;

	private readonly float _volumeSpan = 0.1f;

	private float _changeSpan;

	private AudioPlayer _sePlayer;

	private Tweener _tweener;

	private Color _tweenStartColor;

	private Color _tweenEndColor;

	protected override void Start()
	{
		_minusButtonImage = _minusButton.GetComponent<Image>();
		_plusButtonImage = _plusButton.GetComponent<Image>();
		_tweenStartColor = SingletonMonoBehaviour<LanguageChanger>.Instance.SelectedTextColor;
		_tweenEndColor = SingletonMonoBehaviour<LanguageChanger>.Instance.DefaultTextColor;
		if (_volumeType == VolumeType.Voice)
		{
			InitVoiceSEPlayer(UserDataAccessorManager.SettingDataAccessor.CurrentCharacterType);
			SingletonMonoBehaviour<CharacterSettingObjectPlacer>.Instance.Changed += InitVoiceSEPlayer;
		}
		else
		{
			string audioPath = "Audio/SE/SE_SelectMenu";
			if (_volumeType == VolumeType.FootStep)
			{
				audioPath = "Audio/SE/SE_FootStep4";
			}
			else if (_volumeType == VolumeType.HeartBeat)
			{
				audioPath = "Audio/SE/SE_HeartBeat";
			}
			_sePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, audioPath);
		}
		_currentVolume = UserDataAccessorManager.SettingDataAccessor.GetVolume(_volumeType);
		base.Start();
		_minusButton.Triggered += MinusVolume;
		_plusButton.Triggered += PlusVolume;
	}

	private void InitVoiceSEPlayer(CharacterType characterType)
	{
		if (_sePlayer != null)
		{
			SingletonMonoBehaviour<AudioPlayerManager>.Instance.ReleasePlayer(_sePlayer);
			UnityEngine.Object.Destroy(_sePlayer);
		}
		string path = System.IO.Path.Combine("Voice", $"{characterType}", "Voice_SampleVoice");
		_sePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(base.gameObject, Resources.Load<AudioClip>(path));
	}

	private void Update()
	{
		if (_changeSpan > 0f)
		{
			_changeSpan -= Time.deltaTime;
		}
	}

	protected override void Localize(AvailableLanguage availableLanguage)
	{
		FontMasterData.Entity.UpdateFont(_text, base._defaultFont);
		UpdateUI();
	}

	private void UpdateUI()
	{
		_text.SetTextAndRebuild(LocalizedUtility.Get($"Volume{_volumeType}"));
		_volumeText.SetTextAndRebuild($"{_currentVolume:F1}");
		_minusButton.gameObject.SetActive(_currentVolume > 0f);
		_plusButton.gameObject.SetActive(_currentVolume < 1f);
	}

	private void UpdateColor(Color color)
	{
		_text.SetColor(color);
		_volumeText.SetColor(color);
		_minusButtonImage.color = color;
		_plusButtonImage.color = color;
		_frame.color = color;
	}

	private bool ChangeVolumeIfNeeded(float volume)
	{
		volume = Mathf.Clamp01(volume);
		if (_changeSpan > 0f || Mathf.Approximately(_currentVolume, volume))
		{
			return false;
		}
		_changeSpan = 0.2f;
		_currentVolume = (float)Mathf.RoundToInt(volume * 100f) / 100f;
		UserDataAccessorManager.SettingDataAccessor.ChangeVolume(_volumeType, _currentVolume);
		UpdateUI();
		switch (_volumeType)
		{
		case VolumeType.Etc:
			_sePlayer.UpdateVolume();
			break;
		case VolumeType.BGM:
			SingletonMonoBehaviour<SettingSceneManager>.Instance.UpdateBGMVolume();
			break;
		default:
			Debug.LogWarning($"{_volumeType}の処理は実装されていません");
			break;
		case VolumeType.Voice:
		case VolumeType.HeartBeat:
		case VolumeType.FootStep:
			break;
		}
		_sePlayer.Play();
		_tweener?.Kill();
		_tweener = DOTween.To(() => 0f, delegate(float timeRate)
		{
			UpdateColor(timeRate * _tweenEndColor + (1f - timeRate) * _tweenStartColor);
		}, 1f, 0.5f);
		return true;
	}

	private void MinusVolume(VRHand hand)
	{
		if (ChangeVolumeIfNeeded(_currentVolume - _volumeSpan))
		{
			SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(hand.IsLeft);
		}
	}

	private void PlusVolume(VRHand hand)
	{
		if (ChangeVolumeIfNeeded(_currentVolume + _volumeSpan))
		{
			SingletonMonoBehaviour<InputHandler>.Instance.Vibrate(hand.IsLeft);
		}
	}
}
public class SettingTVText : AutoTextLocalizer
{
	private Color _textColor;

	private PerlinNoiseGenerator _noiseGenerator;

	protected override void Start()
	{
		base.Start();
		_textColor = _text.color;
		_noiseGenerator = new PerlinNoiseGenerator(0.1f, 1f, 0.5f);
	}

	private void Update()
	{
		_textColor.a = _noiseGenerator.GetNoise();
		_text.SetColor(_textColor);
	}

	protected override void Localize(AvailableLanguage availableLanguage)
	{
		FontMasterData.Entity.UpdateFont(_text, base._defaultFont);
		_text.SetTextAndRebuild("<w=SlowSeasick>" + LocalizedUtility.Get("SettingSceneMessage") + "</w>");
	}
}
public class SettingSceneMoveSmartPhone : SceneMoveSmartPhone
{
	[SerializeField]
	[Required]
	private GameObject _markerEffect;

	protected override string _textKey => "ToMain";

	protected override void OnGrab()
	{
		base.OnGrab();
		_markerEffect.SetActive(value: false);
	}

	protected override void OnRelease()
	{
		base.OnRelease();
		SingletonMonoBehaviour<SettingScenePostProcessManager>.Instance.ShowNormal();
		SingletonMonoBehaviour<SettingSceneManager>.Instance.CancelFadeBGM();
	}

	protected override void ReturnTransform()
	{
		base.ReturnTransform();
		_markerEffect.SetActive(value: true);
	}

	protected override void PlayTextTween(float duration, float delay)
	{
		SingletonMonoBehaviour<SettingScenePostProcessManager>.Instance.CreateMoveSceneTween(_textSequence, duration);
		_textSequence.PrependInterval(delay).OnComplete(base.Activate);
		SingletonMonoBehaviour<SettingSceneManager>.Instance.FadeBGM(duration + delay, 1f, 0f);
	}

	protected override void ChangeScene()
	{
		CacheData.ResetVRCameraPosition();
		SingletonMonoBehaviour<SceneNavigator>.Instance.ChangeScene("Main");
	}
}
public class UnpurchasedMessageText : MonoBehaviour
{
	[SerializeField]
	[Required]
	private SuperTextMesh _text;

	private Font _defaultFont;

	private void Start()
	{
		_defaultFont = _text.font;
		UserDataAccessorManager.SettingDataAccessor.CurrentLanguageObservable.Subscribe(Localize).AddTo(this);
	}

	private void Localize(AvailableLanguage availableLanguage)
	{
		FontMasterData.Entity.UpdateFont(_text, _defaultFont);
		_text.SetTextAndRebuild("<c=Gold>" + LocalizedUtility.Get("Unpurchased"));
	}
}
public class KanCrow : MonoBehaviour
{
	[SerializeField]
	private Transform _entity;

	[SerializeField]
	private Transform _wingR;

	[SerializeField]
	private Transform _wingL;

	[SerializeField]
	private Transform _beak;

	[SerializeField]
	private AnimationCurve _beakXAnimationCurve;

	[SerializeField]
	private AnimationCurve _beakYAnimationCurve;

	private PerlinNoiseGenerator _entityXNoiseGenerator;

	private PerlinNoiseGenerator _entityYNoiseGenerator;

	private PerlinNoiseGenerator _wingNoiseGenerator;

	private Vector3 _entityScale = Vector3.one;

	private Vector3 _wingRRotaion = Vector3.zero;

	private Vector3 _wingLRotaion = Vector3.zero;

	private void Awake()
	{
		_entityXNoiseGenerator = new PerlinNoiseGenerator(0.98f, 1.02f);
		_entityYNoiseGenerator = new PerlinNoiseGenerator(0.98f, 1.02f);
		_wingNoiseGenerator = new PerlinNoiseGenerator(0f, 30f, 3f);
	}

	private void Update()
	{
		_entityScale.x = _entityXNoiseGenerator.GetNoise(Time.time);
		_entityScale.y = _entityYNoiseGenerator.GetNoise(Time.time);
		_entity.localScale = _entityScale;
		_wingRRotaion.y = _wingNoiseGenerator.GetNoise(Time.time);
		_wingLRotaion.y = 0f - _wingRRotaion.y;
		_wingR.localRotation = Quaternion.Euler(_wingRRotaion);
		_wingL.localRotation = Quaternion.Euler(_wingLRotaion);
	}

	public void PlayVoiceAnimation(Action callback)
	{
		_beak.DOScaleX(1.09f, 1f).SetEase(_beakXAnimationCurve);
		_beak.DOScaleY(1.2f, 1f).SetEase(_beakYAnimationCurve).OnComplete(delegate
		{
			callback();
		});
	}
}
public class TitleGameLogo : MonoBehaviour
{
	[SerializeField]
	[Required]
	private GameObject _logoJa;

	[SerializeField]
	[Required]
	private GameObject _logoEn;

	private void Start()
	{
		_logoJa.SetActive(UserDataAccessorManager.SettingDataAccessor.CurrentLanguage == AvailableLanguage.Japanese);
		_logoEn.SetActive(!_logoJa.activeSelf);
	}
}
public class TitleObjects : MonoBehaviour
{
	[SerializeField]
	[Required]
	private Transform _cameraTransform;

	private Vector3 _initialDistance;

	private void Awake()
	{
		_initialDistance = base.transform.position - _cameraTransform.position;
	}

	private void LateUpdate()
	{
		base.transform.position = _cameraTransform.position + _initialDistance;
	}
}
public class TitleSceneManager : SingletonMonoBehaviour<TitleSceneManager>
{
	[SerializeField]
	[Required]
	private Camera _mainCamera;

	[SerializeField]
	[Required]
	private GameObject _uiCamera;

	[SerializeField]
	[Required]
	private KanCrow _kanCrow;

	private AudioPlayer _voicePlayer;

	[SerializeField]
	[Required]
	private List<PostProcessLayer> _postProcessLayerList = new List<PostProcessLayer>();

	private void Start()
	{
		_mainCamera.cullingMask = -1;
		_mainCamera.gameObject.tag = "MainCamera";
		_uiCamera.SetActive(value: false);
		_uiCamera.tag = "Untagged";
		foreach (PostProcessLayer postProcessLayer in _postProcessLayerList)
		{
			postProcessLayer.enabled = false;
		}
		SingletonMonoBehaviour<SceneNavigator>.Instance.FadeOut(0f);
		_voicePlayer = SingletonMonoBehaviour<AudioPlayerManager>.Instance.GetPlayer(_kanCrow.gameObject, "Audio/SE/SE_KanKikuchiVoice");
		StartCoroutine(this.DelayMethod(0.01f, FadeIn));
	}

	private void FadeIn()
	{
		SingletonMonoBehaviour<SceneNavigator>.Instance.FadeIn(0.5f, isIgnoreTimeScale: true, PlayAnimation);
	}

	private void PlayAnimation()
	{
		UserDataAccessorManager.PlayRecordDataAccessor.AddLaunchCount();
		StartCoroutine(this.DelayMethod(1.5f, delegate
		{
			_kanCrow.PlayVoiceAnimation(Finish);
			_voicePlayer.Play();
		}));
	}

	private void Finish()
	{
		StartCoroutine(this.DelayMethod(0.5f, delegate
		{
			SingletonMonoBehaviour<SceneNavigator>.Instance.ChangeScene("Setting");
		}));
	}
}
namespace Ricimi
{
	public class BasicButton : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
	{
		[Serializable]
		public class ButtonClickedEvent : UnityEvent
		{
		}

		public float fadeTime = 0.2f;

		public float onHoverAlpha;

		public float onClickAlpha;

		[SerializeField]
		private ButtonClickedEvent onClicked = new ButtonClickedEvent();

		private CanvasGroup canvasGroup;

		private void Awake()
		{
			canvasGroup = base.gameObject.AddComponent<CanvasGroup>();
		}

		public virtual void OnPointerEnter(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				StopAllCoroutines();
				StartCoroutine(Utils.FadeOut(canvasGroup, onHoverAlpha, fadeTime));
			}
		}

		public virtual void OnPointerExit(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				StopAllCoroutines();
				StartCoroutine(Utils.FadeIn(canvasGroup, 1f, fadeTime));
			}
		}

		public virtual void OnPointerDown(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				canvasGroup.alpha = onClickAlpha;
				onClicked.Invoke();
			}
		}

		public virtual void OnPointerUp(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				canvasGroup.alpha = 1f;
			}
		}
	}
	public class Popup : MonoBehaviour
	{
		public Color backgroundColor = new Color(2f / 51f, 2f / 51f, 2f / 51f, 0.6f);

		public float destroyTime = 0.5f;

		private GameObject m_background;

		public void Open()
		{
			AddBackground();
		}

		public void Close()
		{
			Animator component = GetComponent<Animator>();
			if (component.GetCurrentAnimatorStateInfo(0).IsName("Open"))
			{
				component.Play("Close");
			}
			RemoveBackground();
			StartCoroutine(RunPopupDestroy());
		}

		private IEnumerator RunPopupDestroy()
		{
			yield return new WaitForSeconds(destroyTime);
			UnityEngine.Object.Destroy(m_background);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void AddBackground()
		{
			Texture2D texture2D = new Texture2D(1, 1);
			texture2D.SetPixel(0, 0, backgroundColor);
			texture2D.Apply();
			m_background = new GameObject("PopupBackground");
			Image image = m_background.AddComponent<Image>();
			Rect rect = new Rect(0f, 0f, texture2D.width, texture2D.height);
			Sprite sprite = Sprite.Create(texture2D, rect, new Vector2(0.5f, 0.5f), 1f);
			image.material.mainTexture = texture2D;
			image.sprite = sprite;
			Color color = image.color;
			image.color = color;
			image.canvasRenderer.SetAlpha(0f);
			image.CrossFadeAlpha(1f, 0.4f, ignoreTimeScale: false);
			GameObject gameObject = GameObject.Find("Canvas");
			m_background.transform.localScale = new Vector3(1f, 1f, 1f);
			m_background.GetComponent<RectTransform>().sizeDelta = gameObject.GetComponent<RectTransform>().sizeDelta;
			m_background.transform.SetParent(gameObject.transform, worldPositionStays: false);
			m_background.transform.SetSiblingIndex(base.transform.GetSiblingIndex());
		}

		private void RemoveBackground()
		{
			Image component = m_background.GetComponent<Image>();
			if (component != null)
			{
				component.CrossFadeAlpha(0f, 0.2f, ignoreTimeScale: false);
			}
		}
	}
	public class PopupOpener : MonoBehaviour
	{
		public GameObject popupPrefab;

		protected Canvas m_canvas;

		protected void Start()
		{
			m_canvas = GameObject.Find("Canvas").GetComponent<Canvas>();
		}

		public virtual void OpenPopup()
		{
			GameObject obj = UnityEngine.Object.Instantiate(popupPrefab);
			obj.SetActive(value: true);
			obj.transform.localScale = Vector3.zero;
			obj.transform.SetParent(m_canvas.transform, worldPositionStays: false);
			obj.GetComponent<Popup>().Open();
		}
	}
	public class SceneTransition : MonoBehaviour
	{
		public string scene = "<Insert scene name>";

		public float duration = 1f;

		public Color color = Color.black;

		public void PerformTransition()
		{
			Transition.LoadLevel(scene, duration, color);
		}
	}
	public class SpriteSwapper : MonoBehaviour
	{
		public Sprite enabledSprite;

		public Sprite disabledSprite;

		private bool m_swapped = true;

		private Image m_image;

		public void Awake()
		{
			m_image = GetComponent<Image>();
		}

		public void SwapSprite()
		{
			if (m_swapped)
			{
				m_swapped = false;
				m_image.sprite = disabledSprite;
			}
			else
			{
				m_swapped = true;
				m_image.sprite = enabledSprite;
			}
		}
	}
	public class Tooltip : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public GameObject tooltip;

		public float fadeTime = 0.1f;

		public virtual void OnPointerEnter(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left && tooltip != null)
			{
				StartCoroutine(Utils.FadeIn(tooltip.GetComponent<CanvasGroup>(), 1f, fadeTime));
			}
		}

		public virtual void OnPointerExit(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left && tooltip != null)
			{
				StartCoroutine(Utils.FadeOut(tooltip.GetComponent<CanvasGroup>(), 0f, fadeTime));
			}
		}
	}
	public class Transition : MonoBehaviour
	{
		private static GameObject m_canvas;

		private GameObject m_overlay;

		private void Awake()
		{
			m_canvas = new GameObject("TransitionCanvas");
			m_canvas.AddComponent<Canvas>().renderMode = RenderMode.ScreenSpaceOverlay;
			UnityEngine.Object.DontDestroyOnLoad(m_canvas);
		}

		public static void LoadLevel(string level, float duration, Color color)
		{
			GameObject obj = new GameObject("Transition");
			obj.AddComponent<Transition>();
			obj.GetComponent<Transition>().StartFade(level, duration, color);
			obj.transform.SetParent(m_canvas.transform, worldPositionStays: false);
			obj.transform.SetAsLastSibling();
		}

		private void StartFade(string level, float duration, Color fadeColor)
		{
			StartCoroutine(RunFade(level, duration, fadeColor));
		}

		private IEnumerator RunFade(string level, float duration, Color fadeColor)
		{
			Texture2D texture2D = new Texture2D(1, 1);
			texture2D.SetPixel(0, 0, fadeColor);
			texture2D.Apply();
			m_overlay = new GameObject();
			Image image = m_overlay.AddComponent<Image>();
			Rect rect = new Rect(0f, 0f, texture2D.width, texture2D.height);
			Sprite sprite = Sprite.Create(texture2D, rect, new Vector2(0.5f, 0.5f), 1f);
			image.material.mainTexture = texture2D;
			image.sprite = sprite;
			Color color = image.color;
			image.color = color;
			image.canvasRenderer.SetAlpha(0f);
			m_overlay.transform.localScale = new Vector3(1f, 1f, 1f);
			m_overlay.GetComponent<RectTransform>().sizeDelta = m_canvas.GetComponent<RectTransform>().sizeDelta;
			m_overlay.transform.SetParent(m_canvas.transform, worldPositionStays: false);
			m_overlay.transform.SetAsFirstSibling();
			float time2 = 0f;
			float halfDuration = duration / 2f;
			while (time2 < halfDuration)
			{
				time2 += Time.deltaTime;
				image.canvasRenderer.SetAlpha(Mathf.InverseLerp(0f, 1f, time2 / halfDuration));
				yield return new WaitForEndOfFrame();
			}
			image.canvasRenderer.SetAlpha(1f);
			yield return new WaitForEndOfFrame();
			SceneManager.LoadScene(level);
			time2 = 0f;
			while (time2 < halfDuration)
			{
				time2 += Time.deltaTime;
				image.canvasRenderer.SetAlpha(Mathf.InverseLerp(1f, 0f, time2 / halfDuration));
				yield return new WaitForEndOfFrame();
			}
			image.canvasRenderer.SetAlpha(0f);
			yield return new WaitForEndOfFrame();
			UnityEngine.Object.Destroy(m_canvas);
		}
	}
	public static class Utils
	{
		public static IEnumerator FadeIn(CanvasGroup group, float alpha, float duration)
		{
			float time = 0f;
			float originalAlpha = group.alpha;
			while (time < duration)
			{
				time += Time.deltaTime;
				group.alpha = Mathf.Lerp(originalAlpha, alpha, time / duration);
				yield return new WaitForEndOfFrame();
			}
			group.alpha = alpha;
		}

		public static IEnumerator FadeOut(CanvasGroup group, float alpha, float duration)
		{
			float time = 0f;
			float originalAlpha = group.alpha;
			while (time < duration)
			{
				time += Time.deltaTime;
				group.alpha = Mathf.Lerp(originalAlpha, alpha, time / duration);
				yield return new WaitForEndOfFrame();
			}
			group.alpha = alpha;
		}
	}
}
namespace Rainbows
{
	public class RainbowSceneSelect : MonoBehaviour
	{
		public bool GUIHide;

		public bool GUIHide2;

		public bool GUIHide3;

		public void LoadSceneDemo1()
		{
			SceneManager.LoadScene("RainbowMissiles");
		}

		public void LoadSceneDemo2()
		{
			SceneManager.LoadScene("RainbowDemo01");
		}

		public void LoadSceneDemo3()
		{
			SceneManager.LoadScene("RainbowDemo02");
		}

		public void LoadSceneDemo4()
		{
			SceneManager.LoadScene("RainbowDemo03");
		}

		public void LoadSceneDemo5()
		{
			SceneManager.LoadScene("RainbowDemo04");
		}

		public void LoadSceneDemo6()
		{
			SceneManager.LoadScene("RainbowDemo05");
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.L))
			{
				GUIHide = !GUIHide;
				if (GUIHide)
				{
					GameObject.Find("CanvasSceneSelect").GetComponent<Canvas>().enabled = false;
				}
				else
				{
					GameObject.Find("CanvasSceneSelect").GetComponent<Canvas>().enabled = true;
				}
			}
			if (Input.GetKeyDown(KeyCode.J))
			{
				GUIHide2 = !GUIHide2;
				if (GUIHide2)
				{
					GameObject.Find("Canvas").GetComponent<Canvas>().enabled = false;
				}
				else
				{
					GameObject.Find("Canvas").GetComponent<Canvas>().enabled = true;
				}
			}
			if (Input.GetKeyDown(KeyCode.H))
			{
				GUIHide3 = !GUIHide3;
				if (GUIHide3)
				{
					GameObject.Find("CanvasTips").GetComponent<Canvas>().enabled = false;
				}
				else
				{
					GameObject.Find("CanvasTips").GetComponent<Canvas>().enabled = true;
				}
			}
		}
	}
}
namespace RainbowMagic
{
	public class RainbowButtonScript : MonoBehaviour
	{
		public GameObject Button;

		private Text MyButtonText;

		private string projectileParticleName;

		private RainbowFireProjectile effectScript;

		private RainbowProjectileScript projectileScript;

		public float buttonsX;

		public float buttonsY;

		public float buttonsSizeX;

		public float buttonsSizeY;

		public float buttonsDistance;

		private void Start()
		{
			effectScript = GameObject.Find("RainbowFireProjectile").GetComponent<RainbowFireProjectile>();
			getProjectileNames();
			MyButtonText = Button.transform.Find("Text").GetComponent<Text>();
			MyButtonText.text = projectileParticleName;
		}

		private void Update()
		{
			MyButtonText.text = projectileParticleName;
		}

		public void getProjectileNames()
		{
			projectileScript = effectScript.projectiles[effectScript.currentProjectile].GetComponent<RainbowProjectileScript>();
			projectileParticleName = projectileScript.projectileParticle.name;
		}

		public bool overButton()
		{
			Rect rect = new Rect(buttonsX, buttonsY, buttonsSizeX, buttonsSizeY);
			Rect rect2 = new Rect(buttonsX + buttonsDistance, buttonsY, buttonsSizeX, buttonsSizeY);
			if (rect.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)) || rect2.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)))
			{
				return true;
			}
			return false;
		}
	}
	public class RainbowFireProjectile : MonoBehaviour
	{
		private RaycastHit hit;

		public GameObject[] projectiles;

		public Transform spawnPosition;

		[HideInInspector]
		public int currentProjectile;

		public float speed = 1000f;

		private RainbowButtonScript selectedProjectileButton;

		private void Start()
		{
			selectedProjectileButton = GameObject.Find("Button").GetComponent<RainbowButtonScript>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				previousEffect();
			}
			else if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				previousEffect();
			}
			if (Input.GetKeyDown(KeyCode.Mouse0) && !EventSystem.current.IsPointerOverGameObject() && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100f))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(projectiles[currentProjectile], spawnPosition.position, Quaternion.identity);
				gameObject.transform.LookAt(hit.point);
				gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
			}
			Debug.DrawRay(Camera.main.ScreenPointToRay(Input.mousePosition).origin, Camera.main.ScreenPointToRay(Input.mousePosition).direction * 100f, Color.yellow);
		}

		public void nextEffect()
		{
			if (currentProjectile < projectiles.Length - 1)
			{
				currentProjectile++;
			}
			else
			{
				currentProjectile = 0;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void previousEffect()
		{
			if (currentProjectile > 0)
			{
				currentProjectile--;
			}
			else
			{
				currentProjectile = projectiles.Length - 1;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void AdjustSpeed(float newSpeed)
		{
			speed = newSpeed;
		}
	}
	public class RainbowProjectileScript : MonoBehaviour
	{
		public GameObject impactParticle;

		public GameObject projectileParticle;

		public GameObject muzzleParticle;

		public GameObject[] trailParticles;

		[Header("Adjust if not using Sphere Collider")]
		public float colliderRadius = 1f;

		[Range(0f, 1f)]
		public float collideOffset = 0.15f;

		private void Start()
		{
			projectileParticle = UnityEngine.Object.Instantiate(projectileParticle, base.transform.position, base.transform.rotation);
			projectileParticle.transform.parent = base.transform;
			if ((bool)muzzleParticle)
			{
				muzzleParticle = UnityEngine.Object.Instantiate(muzzleParticle, base.transform.position, base.transform.rotation);
				UnityEngine.Object.Destroy(muzzleParticle, 1.5f);
			}
		}

		private void FixedUpdate()
		{
			float radius = ((!base.transform.GetComponent<SphereCollider>()) ? colliderRadius : base.transform.GetComponent<SphereCollider>().radius);
			Vector3 velocity = base.transform.GetComponent<Rigidbody>().velocity;
			if (base.transform.GetComponent<Rigidbody>().useGravity)
			{
				velocity += Physics.gravity * Time.deltaTime;
			}
			velocity = velocity.normalized;
			float maxDistance = base.transform.GetComponent<Rigidbody>().velocity.magnitude * Time.deltaTime;
			if (!Physics.SphereCast(base.transform.position, radius, velocity, out var hitInfo, maxDistance))
			{
				return;
			}
			base.transform.position = hitInfo.point + hitInfo.normal * collideOffset;
			GameObject obj = UnityEngine.Object.Instantiate(impactParticle, base.transform.position, Quaternion.FromToRotation(Vector3.up, hitInfo.normal));
			if (hitInfo.transform.tag == "Destructible")
			{
				UnityEngine.Object.Destroy(hitInfo.transform.gameObject);
			}
			GameObject[] array = trailParticles;
			foreach (GameObject gameObject in array)
			{
				GameObject obj2 = base.transform.Find(projectileParticle.name + "/" + gameObject.name).gameObject;
				obj2.transform.parent = null;
				UnityEngine.Object.Destroy(obj2, 3f);
			}
			UnityEngine.Object.Destroy(projectileParticle, 3f);
			UnityEngine.Object.Destroy(obj, 3.5f);
			UnityEngine.Object.Destroy(base.gameObject);
			ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
			for (int j = 1; j < componentsInChildren.Length; j++)
			{
				ParticleSystem particleSystem = componentsInChildren[j];
				if (particleSystem.gameObject.name.Contains("Trail"))
				{
					particleSystem.transform.SetParent(null);
					UnityEngine.Object.Destroy(particleSystem.gameObject, 2f);
				}
			}
		}
	}
	public class RainbowMagicSoundSpawn : MonoBehaviour
	{
		public GameObject prefabSound;

		public bool destroyWhenDone = true;

		public bool soundPrefabIsChild;

		[Range(0.01f, 10f)]
		public float pitchRandomMultiplier = 1f;

		private void Start()
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(prefabSound, base.transform.position, Quaternion.identity);
			AudioSource component = gameObject.GetComponent<AudioSource>();
			if (soundPrefabIsChild)
			{
				gameObject.transform.SetParent(base.transform);
			}
			if (pitchRandomMultiplier != 1f)
			{
				if ((double)UnityEngine.Random.value < 0.5)
				{
					component.pitch *= UnityEngine.Random.Range(1f / pitchRandomMultiplier, 1f);
				}
				else
				{
					component.pitch *= UnityEngine.Random.Range(1f, pitchRandomMultiplier);
				}
			}
			if (destroyWhenDone)
			{
				float t = component.clip.length / component.pitch;
				UnityEngine.Object.Destroy(gameObject, t);
			}
		}
	}
}
namespace MagicArsenal
{
	public class MagicBeamScript : MonoBehaviour
	{
		[Header("Prefabs")]
		public GameObject[] beamLineRendererPrefab;

		public GameObject[] beamStartPrefab;

		public GameObject[] beamEndPrefab;

		private int currentBeam;

		private GameObject beamStart;

		private GameObject beamEnd;

		private GameObject beam;

		private LineRenderer line;

		[Header("Adjustable Variables")]
		public float beamEndOffset = 1f;

		public float textureScrollSpeed = 8f;

		public float textureLengthScale = 3f;

		[Header("Put Sliders here (Optional)")]
		public Slider endOffSetSlider;

		public Slider scrollSpeedSlider;

		[Header("Put UI Text object here to show beam name")]
		public Text textBeamName;

		private void Start()
		{
			if ((bool)textBeamName)
			{
				textBeamName.text = beamLineRendererPrefab[currentBeam].name;
			}
			if ((bool)endOffSetSlider)
			{
				endOffSetSlider.value = beamEndOffset;
			}
			if ((bool)scrollSpeedSlider)
			{
				scrollSpeedSlider.value = textureScrollSpeed;
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				UnityEngine.Application.Quit();
			}
			if (Input.GetMouseButtonDown(0))
			{
				beamStart = UnityEngine.Object.Instantiate(beamStartPrefab[currentBeam], new Vector3(0f, 0f, 0f), Quaternion.identity);
				beamEnd = UnityEngine.Object.Instantiate(beamEndPrefab[currentBeam], new Vector3(0f, 0f, 0f), Quaternion.identity);
				beam = UnityEngine.Object.Instantiate(beamLineRendererPrefab[currentBeam], new Vector3(0f, 0f, 0f), Quaternion.identity);
				line = beam.GetComponent<LineRenderer>();
			}
			if (Input.GetMouseButtonUp(0))
			{
				UnityEngine.Object.Destroy(beamStart);
				UnityEngine.Object.Destroy(beamEnd);
				UnityEngine.Object.Destroy(beam);
			}
			if (Input.GetMouseButton(0))
			{
				Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
				if (Physics.Raycast(ray.origin, ray.direction, out var hitInfo))
				{
					Vector3 dir = hitInfo.point - base.transform.position;
					ShootBeamInDir(base.transform.position, dir);
				}
			}
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				nextBeam();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				nextBeam();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				previousBeam();
			}
			else if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				previousBeam();
			}
		}

		public void nextBeam()
		{
			if (currentBeam < beamLineRendererPrefab.Length - 1)
			{
				currentBeam++;
			}
			else
			{
				currentBeam = 0;
			}
			if ((bool)textBeamName)
			{
				textBeamName.text = beamLineRendererPrefab[currentBeam].name;
			}
		}

		public void previousBeam()
		{
			if (currentBeam > 0)
			{
				currentBeam--;
			}
			else
			{
				currentBeam = beamLineRendererPrefab.Length - 1;
			}
			if ((bool)textBeamName)
			{
				textBeamName.text = beamLineRendererPrefab[currentBeam].name;
			}
		}

		public void UpdateEndOffset()
		{
			beamEndOffset = endOffSetSlider.value;
		}

		public void UpdateScrollSpeed()
		{
			textureScrollSpeed = scrollSpeedSlider.value;
		}

		private void ShootBeamInDir(Vector3 start, Vector3 dir)
		{
			line.positionCount = 2;
			line.SetPosition(0, start);
			beamStart.transform.position = start;
			Vector3 zero = Vector3.zero;
			zero = ((!Physics.Raycast(start, dir, out var hitInfo)) ? (base.transform.position + dir * 100f) : (hitInfo.point - dir.normalized * beamEndOffset));
			beamEnd.transform.position = zero;
			line.SetPosition(1, zero);
			beamStart.transform.LookAt(beamEnd.transform.position);
			beamEnd.transform.LookAt(beamStart.transform.position);
			float num = Vector3.Distance(start, zero);
			line.sharedMaterial.mainTextureScale = new Vector2(num / textureLengthScale, 1f);
			line.sharedMaterial.mainTextureOffset -= new Vector2(Time.deltaTime * textureScrollSpeed, 0f);
		}
	}
	public class MagicButtonScript : MonoBehaviour
	{
		public GameObject Button;

		private Text MyButtonText;

		private string projectileParticleName;

		private MagicFireProjectile effectScript;

		private MagicProjectileScript projectileScript;

		public float buttonsX;

		public float buttonsY;

		public float buttonsSizeX;

		public float buttonsSizeY;

		public float buttonsDistance;

		private void Start()
		{
			effectScript = GameObject.Find("MagicFireProjectile").GetComponent<MagicFireProjectile>();
			getProjectileNames();
			MyButtonText = Button.transform.Find("Text").GetComponent<Text>();
			MyButtonText.text = projectileParticleName;
		}

		private void Update()
		{
			MyButtonText.text = projectileParticleName;
		}

		public void getProjectileNames()
		{
			projectileScript = effectScript.projectiles[effectScript.currentProjectile].GetComponent<MagicProjectileScript>();
			projectileParticleName = projectileScript.projectileParticle.name;
		}

		public bool overButton()
		{
			Rect rect = new Rect(buttonsX, buttonsY, buttonsSizeX, buttonsSizeY);
			Rect rect2 = new Rect(buttonsX + buttonsDistance, buttonsY, buttonsSizeX, buttonsSizeY);
			if (rect.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)) || rect2.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)))
			{
				return true;
			}
			return false;
		}
	}
	public class MagicDragMouseOrbit : MonoBehaviour
	{
		public Transform target;

		public float distance = 5f;

		public float xSpeed = 120f;

		public float ySpeed = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public float distanceMin = 0.5f;

		public float distanceMax = 15f;

		public float smoothTime = 2f;

		private float rotationYAxis;

		private float rotationXAxis;

		private float velocityX;

		private float velocityY;

		private void Start()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			rotationYAxis = eulerAngles.y;
			rotationXAxis = eulerAngles.x;
			if ((bool)GetComponent<Rigidbody>())
			{
				GetComponent<Rigidbody>().freezeRotation = true;
			}
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				if (Input.GetMouseButton(1))
				{
					velocityX += xSpeed * Input.GetAxis("Mouse X") * distance * 0.02f;
					velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
				}
				rotationYAxis += velocityX;
				rotationXAxis -= velocityY;
				rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
				Quaternion quaternion = Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
				distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
				if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
				{
					distance -= hitInfo.distance;
				}
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Vector3 position = quaternion * vector + target.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
				velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
				velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
			}
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class MagicEffectCycler : MonoBehaviour
	{
		[SerializeField]
		private List<GameObject> listOfEffects;

		[Header("Loop length in seconds")]
		[SerializeField]
		private float loopTimeLength = 5f;

		private float timeOfLastInstantiate;

		private GameObject instantiatedEffect;

		private int effectIndex;

		private void Start()
		{
			instantiatedEffect = UnityEngine.Object.Instantiate(listOfEffects[effectIndex], base.transform.position, base.transform.rotation);
			effectIndex++;
			timeOfLastInstantiate = Time.time;
		}

		private void Update()
		{
			if (Time.time >= timeOfLastInstantiate + loopTimeLength)
			{
				UnityEngine.Object.Destroy(instantiatedEffect);
				instantiatedEffect = UnityEngine.Object.Instantiate(listOfEffects[effectIndex], base.transform.position, base.transform.rotation);
				timeOfLastInstantiate = Time.time;
				if (effectIndex < listOfEffects.Count - 1)
				{
					effectIndex++;
				}
				else
				{
					effectIndex = 0;
				}
			}
		}
	}
	public class MagicFireProjectile : MonoBehaviour
	{
		private RaycastHit hit;

		public GameObject[] projectiles;

		public Transform spawnPosition;

		[HideInInspector]
		public int currentProjectile;

		public float speed = 1000f;

		private MagicButtonScript selectedProjectileButton;

		private void Start()
		{
			selectedProjectileButton = GameObject.Find("Button").GetComponent<MagicButtonScript>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				previousEffect();
			}
			else if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				previousEffect();
			}
			if (Input.GetKeyDown(KeyCode.Mouse0) && !EventSystem.current.IsPointerOverGameObject() && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100f))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(projectiles[currentProjectile], spawnPosition.position, Quaternion.identity);
				gameObject.transform.LookAt(hit.point);
				gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
				gameObject.GetComponent<MagicProjectileScript>().impactNormal = hit.normal;
			}
			Debug.DrawRay(Camera.main.ScreenPointToRay(Input.mousePosition).origin, Camera.main.ScreenPointToRay(Input.mousePosition).direction * 100f, Color.yellow);
		}

		public void nextEffect()
		{
			if (currentProjectile < projectiles.Length - 1)
			{
				currentProjectile++;
			}
			else
			{
				currentProjectile = 0;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void previousEffect()
		{
			if (currentProjectile > 0)
			{
				currentProjectile--;
			}
			else
			{
				currentProjectile = projectiles.Length - 1;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void AdjustSpeed(float newSpeed)
		{
			speed = newSpeed;
		}
	}
	public class MagicLoadSceneOnClick : MonoBehaviour
	{
		public bool GUIHide;

		public bool GUIHide2;

		public bool GUIHide3;

		public void LoadSceneProjectiles()
		{
			SceneManager.LoadScene("magic_projectiles");
		}

		public void LoadSceneSprays()
		{
			SceneManager.LoadScene("magic_sprays");
		}

		public void LoadSceneAura()
		{
			SceneManager.LoadScene("magic_aura");
		}

		public void LoadSceneModular()
		{
			SceneManager.LoadScene("magic_modular");
		}

		public void LoadSceneShields2()
		{
			SceneManager.LoadScene("magic_domes");
		}

		public void LoadSceneShields()
		{
			SceneManager.LoadScene("magic_shields");
		}

		public void LoadSceneSphereBlast()
		{
			SceneManager.LoadScene("magic_sphereblast");
		}

		public void LoadSceneEnchant()
		{
			SceneManager.LoadScene("magic_enchant");
		}

		public void LoadSceneSlash()
		{
			SceneManager.LoadScene("magic_slash");
		}

		public void LoadSceneCharge()
		{
			SceneManager.LoadScene("magic_charge");
		}

		public void LoadSceneCleave()
		{
			SceneManager.LoadScene("magic_cleave");
		}

		public void LoadSceneAura2()
		{
			SceneManager.LoadScene("magic_aura2");
		}

		public void LoadSceneWalls()
		{
			SceneManager.LoadScene("magic_walls");
		}

		public void LoadSceneBeams()
		{
			SceneManager.LoadScene("magic_beams");
		}

		public void LoadSceneMeshGlow()
		{
			SceneManager.LoadScene("magic_meshglow");
		}

		public void LoadScenePillarBlast()
		{
			SceneManager.LoadScene("magic_pillarblast");
		}

		public void LoadSceneAura3()
		{
			SceneManager.LoadScene("magic_aura3");
		}

		public void LoadSceneAuraCast()
		{
			SceneManager.LoadScene("magic_auracast");
		}

		public void LoadSceneRain()
		{
			SceneManager.LoadScene("magic_rain");
		}

		public void LoadSceneAOE()
		{
			SceneManager.LoadScene("magic_aoe");
		}

		public void LoadSceneNova()
		{
			SceneManager.LoadScene("magic_nova");
		}

		public void LoadSceneFlame()
		{
			SceneManager.LoadScene("magic_flame");
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.J))
			{
				GUIHide = !GUIHide;
				if (GUIHide)
				{
					GameObject.Find("CanvasSceneSelect").GetComponent<Canvas>().enabled = false;
				}
				else
				{
					GameObject.Find("CanvasSceneSelect").GetComponent<Canvas>().enabled = true;
				}
			}
			if (Input.GetKeyDown(KeyCode.K))
			{
				GUIHide2 = !GUIHide2;
				if (GUIHide2)
				{
					GameObject.Find("Canvas").GetComponent<Canvas>().enabled = false;
				}
				else
				{
					GameObject.Find("Canvas").GetComponent<Canvas>().enabled = true;
				}
			}
			if (Input.GetKeyDown(KeyCode.L))
			{
				GUIHide3 = !GUIHide3;
				if (GUIHide3)
				{
					GameObject.Find("CanvasTips").GetComponent<Canvas>().enabled = false;
				}
				else
				{
					GameObject.Find("CanvasTips").GetComponent<Canvas>().enabled = true;
				}
			}
		}
	}
	public class MagicLoopScript : MonoBehaviour
	{
		public GameObject chosenEffect;

		public float loopTimeLimit = 2f;

		private void Start()
		{
			PlayEffect();
		}

		public void PlayEffect()
		{
			StartCoroutine("EffectLoop");
		}

		private IEnumerator EffectLoop()
		{
			GameObject effectPlayer = UnityEngine.Object.Instantiate(chosenEffect, base.transform.position, base.transform.rotation);
			yield return new WaitForSeconds(loopTimeLimit);
			UnityEngine.Object.Destroy(effectPlayer);
			PlayEffect();
		}
	}
	public class MagicBeamStatic : MonoBehaviour
	{
		[Header("Prefabs")]
		public GameObject beamLineRendererPrefab;

		public GameObject beamStartPrefab;

		public GameObject beamEndPrefab;

		private GameObject beamStart;

		private GameObject beamEnd;

		private GameObject beam;

		private LineRenderer line;

		[Header("Beam Options")]
		public bool alwaysOn = true;

		public bool beamCollides = true;

		public float beamLength = 100f;

		public float beamEndOffset;

		public float textureScrollSpeed;

		public float textureLengthScale = 1f;

		private void Start()
		{
		}

		private void OnEnable()
		{
			if (alwaysOn)
			{
				SpawnBeam();
			}
		}

		private void OnDisable()
		{
			RemoveBeam();
		}

		private void FixedUpdate()
		{
			if ((bool)beam)
			{
				line.SetPosition(0, base.transform.position);
				RaycastHit hitInfo;
				Vector3 vector = ((!beamCollides || !Physics.Raycast(base.transform.position, base.transform.forward, out hitInfo)) ? (base.transform.position + base.transform.forward * beamLength) : (hitInfo.point - base.transform.forward * beamEndOffset));
				line.SetPosition(1, vector);
				if ((bool)beamStart)
				{
					beamStart.transform.position = base.transform.position;
					beamStart.transform.LookAt(vector);
				}
				if ((bool)beamEnd)
				{
					beamEnd.transform.position = vector;
					beamEnd.transform.LookAt(beamStart.transform.position);
				}
				float num = Vector3.Distance(base.transform.position, vector);
				line.material.mainTextureScale = new Vector2(num / textureLengthScale, 1f);
				line.material.mainTextureOffset -= new Vector2(Time.deltaTime * textureScrollSpeed, 0f);
			}
		}

		public void SpawnBeam()
		{
			if ((bool)beamLineRendererPrefab)
			{
				if ((bool)beamStartPrefab)
				{
					beamStart = UnityEngine.Object.Instantiate(beamStartPrefab);
				}
				if ((bool)beamEndPrefab)
				{
					beamEnd = UnityEngine.Object.Instantiate(beamEndPrefab);
				}
				beam = UnityEngine.Object.Instantiate(beamLineRendererPrefab);
				beam.transform.position = base.transform.position;
				beam.transform.parent = base.transform;
				beam.transform.rotation = base.transform.rotation;
				line = beam.GetComponent<LineRenderer>();
				line.useWorldSpace = true;
				line.positionCount = 2;
			}
			else
			{
				MonoBehaviour.print("Add a prefab with a line renderer to the MagicBeamStatic script on " + base.gameObject.name + "!");
			}
		}

		public void RemoveBeam()
		{
			if ((bool)beam)
			{
				UnityEngine.Object.Destroy(beam);
			}
			if ((bool)beamStart)
			{
				UnityEngine.Object.Destroy(beamStart);
			}
			if ((bool)beamEnd)
			{
				UnityEngine.Object.Destroy(beamEnd);
			}
		}
	}
	public class MagicLightFade : MonoBehaviour
	{
		[Header("Seconds to dim the light")]
		public float life = 0.2f;

		public bool killAfterLife = true;

		private Light li;

		private float initIntensity;

		private void Start()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li = base.gameObject.GetComponent<Light>();
				initIntensity = li.intensity;
			}
			else
			{
				MonoBehaviour.print("No light object found on " + base.gameObject.name);
			}
		}

		private void Update()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li.intensity -= initIntensity * (Time.deltaTime / life);
				if (killAfterLife && li.intensity <= 0f)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
	}
	public class MagicLightFlicker : MonoBehaviour
	{
		public string waveFunction = "sin";

		public float startValue;

		public float amplitude = 1f;

		public float phase;

		public float frequency = 0.5f;

		private Color originalColor;

		private void Start()
		{
			originalColor = GetComponent<Light>().color;
		}

		private void Update()
		{
			GetComponent<Light>().color = originalColor * EvalWave();
		}

		private float EvalWave()
		{
			float num = (Time.time + phase) * frequency;
			num -= Mathf.Floor(num);
			float num2 = ((waveFunction == "sin") ? Mathf.Sin(num * 2f * (float)Math.PI) : ((waveFunction == "tri") ? ((!(num < 0.5f)) ? (-4f * num + 3f) : (4f * num - 1f)) : ((waveFunction == "sqr") ? ((!(num < 0.5f)) ? (-1f) : 1f) : ((waveFunction == "saw") ? num : ((waveFunction == "inv") ? (1f - num) : ((!(waveFunction == "noise")) ? 1f : (1f - UnityEngine.Random.value * 2f)))))));
			return num2 * amplitude + startValue;
		}
	}
	public class MagicRotation : MonoBehaviour
	{
		public enum spaceEnum
		{
			Local,
			World
		}

		[Header("Rotate axises by degrees per second")]
		public Vector3 rotateVector = Vector3.zero;

		public spaceEnum rotateSpace;

		private void Start()
		{
		}

		private void Update()
		{
			if (rotateSpace == spaceEnum.Local)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime);
			}
			if (rotateSpace == spaceEnum.World)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime, Space.World);
			}
		}
	}
}
namespace UltimateGameTools.MeshSimplifier
{
	[Serializable]
	public class MeshUniqueVertices
	{
		[Serializable]
		public class ListIndices
		{
			public List<int> m_listIndices;

			public ListIndices()
			{
				m_listIndices = new List<int>();
			}
		}

		[Serializable]
		public class SerializableBoneWeight
		{
			public int _boneIndex0;

			public int _boneIndex1;

			public int _boneIndex2;

			public int _boneIndex3;

			public float _boneWeight0;

			public float _boneWeight1;

			public float _boneWeight2;

			public float _boneWeight3;

			public SerializableBoneWeight(BoneWeight boneWeight)
			{
				_boneIndex0 = boneWeight.boneIndex0;
				_boneIndex1 = boneWeight.boneIndex1;
				_boneIndex2 = boneWeight.boneIndex2;
				_boneIndex3 = boneWeight.boneIndex3;
				_boneWeight0 = boneWeight.weight0;
				_boneWeight1 = boneWeight.weight1;
				_boneWeight2 = boneWeight.weight2;
				_boneWeight3 = boneWeight.weight3;
			}

			public BoneWeight ToBoneWeight()
			{
				BoneWeight result = default(BoneWeight);
				result.boneIndex0 = _boneIndex0;
				result.boneIndex1 = _boneIndex1;
				result.boneIndex2 = _boneIndex2;
				result.boneIndex3 = _boneIndex3;
				result.weight0 = _boneWeight0;
				result.weight1 = _boneWeight1;
				result.weight2 = _boneWeight2;
				result.weight3 = _boneWeight3;
				return result;
			}
		}

		public class UniqueVertex
		{
			private int m_nFixedX;

			private int m_nFixedY;

			private int m_nFixedZ;

			private const float fDecimalMultiplier = 100000f;

			public override bool Equals(object obj)
			{
				UniqueVertex uniqueVertex = obj as UniqueVertex;
				if (uniqueVertex.m_nFixedX == m_nFixedX && uniqueVertex.m_nFixedY == m_nFixedY)
				{
					return uniqueVertex.m_nFixedZ == m_nFixedZ;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return m_nFixedX + (m_nFixedY << 2) + (m_nFixedZ << 4);
			}

			public UniqueVertex(Vector3 v3Vertex)
			{
				FromVertex(v3Vertex);
			}

			public Vector3 ToVertex()
			{
				return new Vector3(FixedToCoord(m_nFixedX), FixedToCoord(m_nFixedY), FixedToCoord(m_nFixedZ));
			}

			public static bool operator ==(UniqueVertex a, UniqueVertex b)
			{
				return a.Equals(b);
			}

			public static bool operator !=(UniqueVertex a, UniqueVertex b)
			{
				return !a.Equals(b);
			}

			private void FromVertex(Vector3 vertex)
			{
				m_nFixedX = CoordToFixed(vertex.x);
				m_nFixedY = CoordToFixed(vertex.y);
				m_nFixedZ = CoordToFixed(vertex.z);
			}

			private int CoordToFixed(float fCoord)
			{
				int num = Mathf.FloorToInt(fCoord);
				int num2 = Mathf.FloorToInt((fCoord - (float)num) * 100000f);
				return (num << 16) | num2;
			}

			private float FixedToCoord(int nFixed)
			{
				float num = (float)(nFixed & 0xFFFF) / 100000f;
				return (float)(nFixed >> 16) + num;
			}
		}

		private class RepeatedVertex
		{
			private int _nFaceIndex;

			private int _nOriginalVertexIndex;

			public int FaceIndex => _nFaceIndex;

			public int OriginalVertexIndex => _nOriginalVertexIndex;

			public RepeatedVertex(int nFaceIndex, int nOriginalVertexIndex)
			{
				_nFaceIndex = nFaceIndex;
				_nOriginalVertexIndex = nOriginalVertexIndex;
			}
		}

		private class RepeatedVertexList
		{
			private int m_nUniqueIndex;

			private List<RepeatedVertex> m_listRepeatedVertices;

			public int UniqueIndex => m_nUniqueIndex;

			public RepeatedVertexList(int nUniqueIndex, RepeatedVertex repeatedVertex)
			{
				m_nUniqueIndex = nUniqueIndex;
				m_listRepeatedVertices = new List<RepeatedVertex>();
				m_listRepeatedVertices.Add(repeatedVertex);
			}

			public void Add(RepeatedVertex repeatedVertex)
			{
				m_listRepeatedVertices.Add(repeatedVertex);
			}
		}

		[SerializeField]
		private List<Vector3> m_listVertices;

		[SerializeField]
		private List<Vector3> m_listVerticesWorld;

		[SerializeField]
		private List<SerializableBoneWeight> m_listBoneWeights;

		[SerializeField]
		private ListIndices[] m_aFaceList;

		public ListIndices[] SubmeshesFaceList => m_aFaceList;

		public List<Vector3> ListVertices => m_listVertices;

		public List<Vector3> ListVerticesWorld => m_listVerticesWorld;

		public List<SerializableBoneWeight> ListBoneWeights => m_listBoneWeights;

		public void BuildData(Mesh sourceMesh, Vector3[] av3VerticesWorld)
		{
			Vector3[] vertices = sourceMesh.vertices;
			BoneWeight[] boneWeights = sourceMesh.boneWeights;
			Dictionary<UniqueVertex, RepeatedVertexList> dictionary = new Dictionary<UniqueVertex, RepeatedVertexList>();
			m_listVertices = new List<Vector3>();
			m_listVerticesWorld = new List<Vector3>();
			m_listBoneWeights = new List<SerializableBoneWeight>();
			m_aFaceList = new ListIndices[sourceMesh.subMeshCount];
			for (int i = 0; i < sourceMesh.subMeshCount; i++)
			{
				m_aFaceList[i] = new ListIndices();
				int[] triangles = sourceMesh.GetTriangles(i);
				for (int j = 0; j < triangles.Length; j++)
				{
					UniqueVertex key = new UniqueVertex(vertices[triangles[j]]);
					if (dictionary.ContainsKey(key))
					{
						dictionary[key].Add(new RepeatedVertex(j / 3, triangles[j]));
						m_aFaceList[i].m_listIndices.Add(dictionary[key].UniqueIndex);
						continue;
					}
					int count = m_listVertices.Count;
					dictionary.Add(key, new RepeatedVertexList(count, new RepeatedVertex(j / 3, triangles[j])));
					m_listVertices.Add(vertices[triangles[j]]);
					m_listVerticesWorld.Add(av3VerticesWorld[triangles[j]]);
					m_aFaceList[i].m_listIndices.Add(count);
					if (boneWeights != null && boneWeights.Length != 0)
					{
						m_listBoneWeights.Add(new SerializableBoneWeight(boneWeights[triangles[j]]));
					}
				}
			}
		}
	}
	[Serializable]
	public class RelevanceSphere
	{
		public bool m_bExpanded;

		public Vector3 m_v3Position;

		public Vector3 m_v3Rotation;

		public Vector3 m_v3Scale;

		public float m_fRelevance;

		public RelevanceSphere()
		{
			m_v3Scale = Vector3.one;
		}

		public void SetDefault(Transform target, float fRelevance)
		{
			m_bExpanded = true;
			m_v3Position = target.position + Vector3.up;
			m_v3Rotation = target.rotation.eulerAngles;
			m_v3Scale = Vector3.one;
			m_fRelevance = fRelevance;
		}
	}
	public class Simplifier : MonoBehaviour
	{
		public delegate void ProgressDelegate(string strTitle, string strProgressMessage, float fT);

		private class Triangle
		{
			private Vertex[] m_aVertices;

			private bool m_bUVData;

			private int[] m_aUV;

			private int[] m_aIndices;

			private Vector3 m_v3Normal;

			private int m_nSubMesh;

			public Vertex[] Vertices => m_aVertices;

			public bool HasUVData => m_bUVData;

			public int[] IndicesUV => m_aUV;

			public Vector3 Normal => m_v3Normal;

			public int[] Indices => m_aIndices;

			public Triangle(Simplifier simplifier, int nSubMesh, Vertex v0, Vertex v1, Vertex v2, bool bUVData, int nIndex1, int nIndex2, int nIndex3)
			{
				m_aVertices = new Vertex[3];
				m_aUV = new int[3];
				m_aIndices = new int[3];
				m_aVertices[0] = v0;
				m_aVertices[1] = v1;
				m_aVertices[2] = v2;
				m_nSubMesh = nSubMesh;
				m_bUVData = bUVData;
				if (m_bUVData)
				{
					m_aUV[0] = nIndex1;
					m_aUV[1] = nIndex2;
					m_aUV[2] = nIndex3;
				}
				m_aIndices[0] = nIndex1;
				m_aIndices[1] = nIndex2;
				m_aIndices[2] = nIndex3;
				ComputeNormal();
				simplifier.m_aListTriangles[nSubMesh].m_listTriangles.Add(this);
				for (int i = 0; i < 3; i++)
				{
					m_aVertices[i].m_listFaces.Add(this);
					for (int j = 0; j < 3; j++)
					{
						if (i != j && !m_aVertices[i].m_listNeighbors.Contains(m_aVertices[j]))
						{
							m_aVertices[i].m_listNeighbors.Add(m_aVertices[j]);
						}
					}
				}
			}

			public void Destructor(Simplifier simplifier)
			{
				simplifier.m_aListTriangles[m_nSubMesh].m_listTriangles.Remove(this);
				for (int i = 0; i < 3; i++)
				{
					if (m_aVertices[i] != null)
					{
						m_aVertices[i].m_listFaces.Remove(this);
					}
				}
				for (int i = 0; i < 3; i++)
				{
					int num = (i + 1) % 3;
					if (m_aVertices[i] != null && m_aVertices[num] != null)
					{
						m_aVertices[i].RemoveIfNonNeighbor(m_aVertices[num]);
						m_aVertices[num].RemoveIfNonNeighbor(m_aVertices[i]);
					}
				}
			}

			public bool HasVertex(Vertex v)
			{
				if (v != m_aVertices[0] && v != m_aVertices[1])
				{
					return v == m_aVertices[2];
				}
				return true;
			}

			public void ComputeNormal()
			{
				Vector3 v3Position = m_aVertices[0].m_v3Position;
				Vector3 v3Position2 = m_aVertices[1].m_v3Position;
				Vector3 v3Position3 = m_aVertices[2].m_v3Position;
				m_v3Normal = Vector3.Cross(v3Position2 - v3Position, v3Position3 - v3Position2);
				if (m_v3Normal.magnitude != 0f)
				{
					m_v3Normal = m_v3Normal.normalized;
				}
			}

			public int TexAt(Vertex vertex)
			{
				for (int i = 0; i < 3; i++)
				{
					if (m_aVertices[i] == vertex)
					{
						return m_aUV[i];
					}
				}
				UnityEngine.Debug.LogError("TexAt(): Vertex not found");
				return 0;
			}

			public int TexAt(int i)
			{
				return m_aUV[i];
			}

			public void SetTexAt(Vertex vertex, int uv)
			{
				for (int i = 0; i < 3; i++)
				{
					if (m_aVertices[i] == vertex)
					{
						m_aUV[i] = uv;
						return;
					}
				}
				UnityEngine.Debug.LogError("SetTexAt(): Vertex not found");
			}

			public void SetTexAt(int i, int uv)
			{
				m_aUV[i] = uv;
			}

			public void ReplaceVertex(Vertex vold, Vertex vnew)
			{
				if (vold == m_aVertices[0])
				{
					m_aVertices[0] = vnew;
				}
				else if (vold == m_aVertices[1])
				{
					m_aVertices[1] = vnew;
				}
				else
				{
					m_aVertices[2] = vnew;
				}
				vold.m_listFaces.Remove(this);
				vnew.m_listFaces.Add(this);
				for (int i = 0; i < 3; i++)
				{
					vold.RemoveIfNonNeighbor(m_aVertices[i]);
					m_aVertices[i].RemoveIfNonNeighbor(vold);
				}
				for (int i = 0; i < 3; i++)
				{
					for (int j = 0; j < 3; j++)
					{
						if (i != j && !m_aVertices[i].m_listNeighbors.Contains(m_aVertices[j]))
						{
							m_aVertices[i].m_listNeighbors.Add(m_aVertices[j]);
						}
					}
				}
				ComputeNormal();
			}
		}

		private class TriangleList
		{
			public List<Triangle> m_listTriangles;

			public TriangleList()
			{
				m_listTriangles = new List<Triangle>();
			}
		}

		private class Vertex
		{
			public Vector3 m_v3Position;

			public Vector3 m_v3PositionWorld;

			public bool m_bHasBoneWeight;

			public BoneWeight m_boneWeight;

			public int m_nID;

			public List<Vertex> m_listNeighbors;

			public List<Triangle> m_listFaces;

			public float m_fObjDist;

			public Vertex m_collapse;

			public int m_nHeapSpot;

			public Vertex(Simplifier simplifier, Vector3 v, Vector3 v3World, bool bHasBoneWeight, BoneWeight boneWeight, int nID)
			{
				m_v3Position = v;
				m_v3PositionWorld = v3World;
				m_bHasBoneWeight = bHasBoneWeight;
				m_boneWeight = boneWeight;
				m_nID = nID;
				m_listNeighbors = new List<Vertex>();
				m_listFaces = new List<Triangle>();
				simplifier.m_listVertices.Add(this);
			}

			public void Destructor(Simplifier simplifier)
			{
				while (m_listNeighbors.Count > 0)
				{
					m_listNeighbors[0].m_listNeighbors.Remove(this);
					if (m_listNeighbors.Count > 0)
					{
						m_listNeighbors.RemoveAt(0);
					}
				}
				simplifier.m_listVertices.Remove(this);
			}

			public void RemoveIfNonNeighbor(Vertex n)
			{
				if (!m_listNeighbors.Contains(n))
				{
					return;
				}
				for (int i = 0; i < m_listFaces.Count; i++)
				{
					if (m_listFaces[i].HasVertex(n))
					{
						return;
					}
				}
				m_listNeighbors.Remove(n);
			}

			public bool IsBorder()
			{
				for (int i = 0; i < m_listNeighbors.Count; i++)
				{
					int num = 0;
					for (int j = 0; j < m_listFaces.Count; j++)
					{
						if (m_listFaces[j].HasVertex(m_listNeighbors[i]))
						{
							num++;
						}
					}
					if (num == 1)
					{
						return true;
					}
				}
				return false;
			}
		}

		private class VertexDataHashComparer : IEqualityComparer<VertexDataHash>
		{
			public bool Equals(VertexDataHash a, VertexDataHash b)
			{
				if (a.UV1 == b.UV1 && a.UV2 == b.UV2 && a.Vertex == b.Vertex && a.Color.r == b.Color.r && a.Color.g == b.Color.g && a.Color.b == b.Color.b)
				{
					return a.Color.a == b.Color.a;
				}
				return false;
			}

			public int GetHashCode(VertexDataHash vdata)
			{
				return vdata.GetHashCode();
			}
		}

		private class VertexDataHash
		{
			private Vector3 _v3Vertex;

			private Vector3 _v3Normal;

			private Vector2 _v2Mapping1;

			private Vector2 _v2Mapping2;

			private Color32 _color;

			private MeshUniqueVertices.UniqueVertex _uniqueVertex;

			public Vector3 Vertex => _v3Vertex;

			public Vector3 Normal => _v3Normal;

			public Vector2 UV1 => _v2Mapping1;

			public Vector2 UV2 => _v2Mapping2;

			public Color32 Color => _color;

			public VertexDataHash(Vector3 v3Vertex, Vector3 v3Normal, Vector2 v2Mapping1, Vector2 v2Mapping2, Color32 color)
			{
				_v3Vertex = v3Vertex;
				_v3Normal = v3Normal;
				_v2Mapping1 = v2Mapping1;
				_v2Mapping2 = v2Mapping2;
				_color = color;
				_uniqueVertex = new MeshUniqueVertices.UniqueVertex(v3Vertex);
			}

			public override bool Equals(object obj)
			{
				VertexDataHash vertexDataHash = obj as VertexDataHash;
				if (vertexDataHash._v2Mapping1 == _v2Mapping1 && vertexDataHash._v2Mapping2 == _v2Mapping2 && vertexDataHash._v3Vertex == _v3Vertex && vertexDataHash._color.r == _color.r && vertexDataHash._color.g == _color.g && vertexDataHash._color.b == _color.b)
				{
					return vertexDataHash._color.a == _color.a;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return _uniqueVertex.GetHashCode();
			}

			public static bool operator ==(VertexDataHash a, VertexDataHash b)
			{
				return a.Equals(b);
			}

			public static bool operator !=(VertexDataHash a, VertexDataHash b)
			{
				return !a.Equals(b);
			}
		}

		private static int m_nCoroutineFrameMiliseconds;

		private const float MAX_VERTEX_COLLAPSE_COST = 10000000f;

		private List<Vertex> m_listVertices;

		private List<Vertex> m_listHeap;

		private TriangleList[] m_aListTriangles;

		[SerializeField]
		[HideInInspector]
		private int m_nOriginalMeshVertexCount = -1;

		[SerializeField]
		[HideInInspector]
		private float m_fOriginalMeshSize = 1f;

		[SerializeField]
		[HideInInspector]
		private List<int> m_listVertexMap;

		[SerializeField]
		[HideInInspector]
		private List<int> m_listVertexPermutationBack;

		[SerializeField]
		[HideInInspector]
		private MeshUniqueVertices m_meshUniqueVertices;

		[SerializeField]
		[HideInInspector]
		private Mesh m_meshOriginal;

		[SerializeField]
		[HideInInspector]
		private bool m_bUseEdgeLength = true;

		[SerializeField]
		[HideInInspector]
		private bool m_bUseCurvature = true;

		[SerializeField]
		[HideInInspector]
		private bool m_bProtectTexture = true;

		[SerializeField]
		[HideInInspector]
		private bool m_bLockBorder = true;

		public static bool Cancelled { get; set; }

		public static int CoroutineFrameMiliseconds
		{
			get
			{
				return m_nCoroutineFrameMiliseconds;
			}
			set
			{
				m_nCoroutineFrameMiliseconds = value;
			}
		}

		public bool CoroutineEnded { get; set; }

		public bool UseEdgeLength
		{
			get
			{
				return m_bUseEdgeLength;
			}
			set
			{
				m_bUseEdgeLength = value;
			}
		}

		public bool UseCurvature
		{
			get
			{
				return m_bUseCurvature;
			}
			set
			{
				m_bUseCurvature = value;
			}
		}

		public bool ProtectTexture
		{
			get
			{
				return m_bProtectTexture;
			}
			set
			{
				m_bProtectTexture = value;
			}
		}

		public bool LockBorder
		{
			get
			{
				return m_bLockBorder;
			}
			set
			{
				m_bLockBorder = value;
			}
		}

		public IEnumerator ProgressiveMesh(GameObject gameObject, Mesh sourceMesh, RelevanceSphere[] aRelevanceSpheres, string strProgressDisplayObjectName = "", ProgressDelegate progress = null)
		{
			m_meshOriginal = sourceMesh;
			Vector3[] worldVertices = GetWorldVertices(gameObject);
			if (worldVertices == null)
			{
				CoroutineEnded = true;
				yield break;
			}
			m_listVertexMap = new List<int>();
			m_listVertexPermutationBack = new List<int>();
			m_listVertices = new List<Vertex>();
			m_aListTriangles = new TriangleList[m_meshOriginal.subMeshCount];
			if (progress != null)
			{
				progress("Preprocessing mesh: " + strProgressDisplayObjectName, "Building unique vertex data", 1f);
				if (Cancelled)
				{
					CoroutineEnded = true;
					yield break;
				}
			}
			m_meshUniqueVertices = new MeshUniqueVertices();
			m_meshUniqueVertices.BuildData(m_meshOriginal, worldVertices);
			m_nOriginalMeshVertexCount = m_meshUniqueVertices.ListVertices.Count;
			m_fOriginalMeshSize = Mathf.Max(m_meshOriginal.bounds.size.x, m_meshOriginal.bounds.size.y, m_meshOriginal.bounds.size.z);
			m_listHeap = new List<Vertex>(m_meshUniqueVertices.ListVertices.Count);
			for (int i = 0; i < m_meshUniqueVertices.ListVertices.Count; i++)
			{
				m_listVertexMap.Add(-1);
				m_listVertexPermutationBack.Add(-1);
			}
			Vector2[] uv = m_meshOriginal.uv;
			AddVertices(m_meshUniqueVertices.ListVertices, m_meshUniqueVertices.ListVerticesWorld, m_meshUniqueVertices.ListBoneWeights);
			for (int j = 0; j < m_meshOriginal.subMeshCount; j++)
			{
				int[] triangles = m_meshOriginal.GetTriangles(j);
				m_aListTriangles[j] = new TriangleList();
				AddFaceListSubMesh(j, m_meshUniqueVertices.SubmeshesFaceList[j].m_listIndices, triangles, uv);
			}
			if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying)
			{
				IEnumerator enumerator = ComputeAllEdgeCollapseCosts(strProgressDisplayObjectName, gameObject.transform, aRelevanceSpheres, progress);
				while (enumerator.MoveNext())
				{
					if (Cancelled)
					{
						CoroutineEnded = true;
						yield break;
					}
				}
			}
			else
			{
				yield return StartCoroutine(ComputeAllEdgeCollapseCosts(strProgressDisplayObjectName, gameObject.transform, aRelevanceSpheres, progress));
			}
			int nVertices = m_listVertices.Count;
			Stopwatch stopwatch = Stopwatch.StartNew();
			while (m_listVertices.Count > 0)
			{
				if (progress != null && (m_listVertices.Count & 0xFF) == 0)
				{
					progress("Preprocessing mesh: " + strProgressDisplayObjectName, "Collapsing edges", 1f - (float)m_listVertices.Count / (float)nVertices);
					if (Cancelled)
					{
						CoroutineEnded = true;
						yield break;
					}
				}
				if (stopwatch.ElapsedMilliseconds > CoroutineFrameMiliseconds && CoroutineFrameMiliseconds > 0)
				{
					yield return null;
					stopwatch = Stopwatch.StartNew();
				}
				Vertex vertex = MinimumCostEdge();
				m_listVertexPermutationBack[m_listVertices.Count - 1] = vertex.m_nID;
				m_listVertexMap[vertex.m_nID] = ((vertex.m_collapse != null) ? vertex.m_collapse.m_nID : (-1));
				Collapse(vertex, vertex.m_collapse, bRecompute: true, gameObject.transform, aRelevanceSpheres);
			}
			m_listHeap.Clear();
			CoroutineEnded = true;
		}

		public IEnumerator ComputeMeshWithVertexCount(GameObject gameObject, Mesh meshOut, int nVertices, string strProgressDisplayObjectName = "", ProgressDelegate progress = null)
		{
			if (GetOriginalMeshUniqueVertexCount() == -1)
			{
				CoroutineEnded = true;
				yield break;
			}
			if (nVertices < 3)
			{
				CoroutineEnded = true;
				yield break;
			}
			if (nVertices >= GetOriginalMeshUniqueVertexCount())
			{
				meshOut.triangles = new int[0];
				meshOut.subMeshCount = m_meshOriginal.subMeshCount;
				meshOut.vertices = m_meshOriginal.vertices;
				meshOut.normals = m_meshOriginal.normals;
				meshOut.tangents = m_meshOriginal.tangents;
				meshOut.uv = m_meshOriginal.uv;
				meshOut.uv2 = m_meshOriginal.uv2;
				meshOut.colors32 = m_meshOriginal.colors32;
				meshOut.boneWeights = m_meshOriginal.boneWeights;
				meshOut.bindposes = m_meshOriginal.bindposes;
				meshOut.triangles = m_meshOriginal.triangles;
				meshOut.subMeshCount = m_meshOriginal.subMeshCount;
				for (int i = 0; i < m_meshOriginal.subMeshCount; i++)
				{
					meshOut.SetTriangles(m_meshOriginal.GetTriangles(i), i);
				}
				meshOut.name = gameObject.name + " simplified mesh";
				CoroutineEnded = true;
				yield break;
			}
			m_listVertices = new List<Vertex>();
			m_aListTriangles = new TriangleList[m_meshOriginal.subMeshCount];
			List<Vertex> listVertices = new List<Vertex>();
			AddVertices(m_meshUniqueVertices.ListVertices, m_meshUniqueVertices.ListVerticesWorld, m_meshUniqueVertices.ListBoneWeights);
			for (int j = 0; j < m_listVertices.Count; j++)
			{
				m_listVertices[j].m_collapse = ((m_listVertexMap[j] == -1) ? null : m_listVertices[m_listVertexMap[j]]);
				listVertices.Add(m_listVertices[m_listVertexPermutationBack[j]]);
			}
			Vector2[] uv = m_meshOriginal.uv;
			for (int k = 0; k < m_meshOriginal.subMeshCount; k++)
			{
				int[] triangles = m_meshOriginal.GetTriangles(k);
				m_aListTriangles[k] = new TriangleList();
				AddFaceListSubMesh(k, m_meshUniqueVertices.SubmeshesFaceList[k].m_listIndices, triangles, uv);
			}
			int nTotalVertices = listVertices.Count;
			Stopwatch stopwatch = Stopwatch.StartNew();
			while (listVertices.Count > nVertices)
			{
				if (progress != null && nTotalVertices != nVertices && (listVertices.Count & 0xFF) == 0)
				{
					float fT = 1f - (float)(listVertices.Count - nVertices) / (float)(nTotalVertices - nVertices);
					progress("Simplifying mesh: " + strProgressDisplayObjectName, "Collapsing edges", fT);
					if (Cancelled)
					{
						CoroutineEnded = true;
						yield break;
					}
				}
				Vertex vertex = listVertices[listVertices.Count - 1];
				listVertices.RemoveAt(listVertices.Count - 1);
				Collapse(vertex, vertex.m_collapse, bRecompute: false, null, null);
				if (stopwatch.ElapsedMilliseconds > CoroutineFrameMiliseconds && CoroutineFrameMiliseconds > 0)
				{
					yield return null;
					stopwatch = Stopwatch.StartNew();
				}
			}
			Vector3[] array = new Vector3[m_listVertices.Count];
			for (int l = 0; l < m_listVertices.Count; l++)
			{
				m_listVertices[l].m_nID = l;
				array[l] = m_listVertices[l].m_v3Position;
			}
			if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying)
			{
				IEnumerator enumerator = ConsolidateMesh(gameObject, m_meshOriginal, meshOut, m_aListTriangles, array, strProgressDisplayObjectName, progress);
				while (enumerator.MoveNext())
				{
					if (Cancelled)
					{
						CoroutineEnded = true;
						yield break;
					}
				}
			}
			else
			{
				yield return StartCoroutine(ConsolidateMesh(gameObject, m_meshOriginal, meshOut, m_aListTriangles, array, strProgressDisplayObjectName, progress));
			}
			CoroutineEnded = true;
		}

		public int GetOriginalMeshUniqueVertexCount()
		{
			return m_nOriginalMeshVertexCount;
		}

		public int GetOriginalMeshTriangleCount()
		{
			return m_meshOriginal.triangles.Length / 3;
		}

		public static Vector3[] GetWorldVertices(GameObject gameObject)
		{
			Vector3[] array = null;
			SkinnedMeshRenderer component = gameObject.GetComponent<SkinnedMeshRenderer>();
			MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
			if (component != null)
			{
				if (component.sharedMesh == null)
				{
					return null;
				}
				array = component.sharedMesh.vertices;
				BoneWeight[] boneWeights = component.sharedMesh.boneWeights;
				Matrix4x4[] bindposes = component.sharedMesh.bindposes;
				Transform[] bones = component.bones;
				if (array == null || boneWeights == null || bindposes == null || bones == null)
				{
					return null;
				}
				if (boneWeights.Length == 0 || bindposes.Length == 0 || bones.Length == 0)
				{
					return null;
				}
				for (int i = 0; i < array.Length; i++)
				{
					BoneWeight boneWeight = boneWeights[i];
					Vector3 zero = Vector3.zero;
					if (Math.Abs(boneWeight.weight0) > 1E-05f)
					{
						Vector3 point = bindposes[boneWeight.boneIndex0].MultiplyPoint3x4(array[i]);
						zero += bones[boneWeight.boneIndex0].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight0;
					}
					if (Math.Abs(boneWeight.weight1) > 1E-05f)
					{
						Vector3 point = bindposes[boneWeight.boneIndex1].MultiplyPoint3x4(array[i]);
						zero += bones[boneWeight.boneIndex1].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight1;
					}
					if (Math.Abs(boneWeight.weight2) > 1E-05f)
					{
						Vector3 point = bindposes[boneWeight.boneIndex2].MultiplyPoint3x4(array[i]);
						zero += bones[boneWeight.boneIndex2].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight2;
					}
					if (Math.Abs(boneWeight.weight3) > 1E-05f)
					{
						Vector3 point = bindposes[boneWeight.boneIndex3].MultiplyPoint3x4(array[i]);
						zero += bones[boneWeight.boneIndex3].transform.localToWorldMatrix.MultiplyPoint3x4(point) * boneWeight.weight3;
					}
					array[i] = zero;
				}
			}
			else if (component2 != null)
			{
				if (component2.sharedMesh == null)
				{
					return null;
				}
				array = component2.sharedMesh.vertices;
				if (array == null)
				{
					return null;
				}
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = gameObject.transform.TransformPoint(array[j]);
				}
			}
			return array;
		}

		private IEnumerator ConsolidateMesh(GameObject gameObject, Mesh meshIn, Mesh meshOut, TriangleList[] aListTriangles, Vector3[] av3Vertices, string strProgressDisplayObjectName = "", ProgressDelegate progress = null)
		{
			Vector3[] av3NormalsIn = meshIn.normals;
			Vector4[] av4TangentsIn = meshIn.tangents;
			Vector2[] av2Mapping1In = meshIn.uv;
			Vector2[] av2Mapping2In = meshIn.uv2;
			Color[] acolColorsIn = meshIn.colors;
			Color32[] aColors32In = meshIn.colors32;
			List<List<int>> listlistIndicesOut = new List<List<int>>();
			List<Vector3> listVerticesOut = new List<Vector3>();
			List<Vector3> listNormalsOut = new List<Vector3>();
			List<Vector4> listTangentsOut = new List<Vector4>();
			List<Vector2> listMapping1Out = new List<Vector2>();
			List<Vector2> listMapping2Out = new List<Vector2>();
			List<Color32> listColors32Out = new List<Color32>();
			List<BoneWeight> listBoneWeightsOut = new List<BoneWeight>();
			Dictionary<VertexDataHash, int> dicVertexDataHash2Index = new Dictionary<VertexDataHash, int>(new VertexDataHashComparer());
			bool bUV1 = av2Mapping1In != null && av2Mapping1In.Length != 0;
			bool bUV2 = av2Mapping2In != null && av2Mapping2In.Length != 0;
			bool bNormal = av3NormalsIn != null && av3NormalsIn.Length != 0;
			bool bTangent = av4TangentsIn != null && av4TangentsIn.Length != 0;
			Stopwatch stopwatch = Stopwatch.StartNew();
			for (int nSubMesh = 0; nSubMesh < aListTriangles.Length; nSubMesh++)
			{
				List<int> listIndicesOut = new List<int>();
				string strMesh = ((aListTriangles.Length > 1) ? ("Consolidating submesh " + (nSubMesh + 1)) : "Consolidating mesh");
				for (int i = 0; i < aListTriangles[nSubMesh].m_listTriangles.Count; i++)
				{
					if (progress != null && (i & 0xFF) == 0)
					{
						float fT = ((aListTriangles[nSubMesh].m_listTriangles.Count == 1) ? 1f : ((float)i / (float)(aListTriangles[nSubMesh].m_listTriangles.Count - 1)));
						progress("Simplifying mesh: " + strProgressDisplayObjectName, strMesh, fT);
						if (Cancelled)
						{
							yield break;
						}
					}
					if (stopwatch.ElapsedMilliseconds > CoroutineFrameMiliseconds && CoroutineFrameMiliseconds > 0)
					{
						yield return null;
						stopwatch = Stopwatch.StartNew();
					}
					for (int j = 0; j < 3; j++)
					{
						int num = aListTriangles[nSubMesh].m_listTriangles[i].IndicesUV[j];
						int num2 = aListTriangles[nSubMesh].m_listTriangles[i].Indices[j];
						bool flag = false;
						Vector3 v3Position = aListTriangles[nSubMesh].m_listTriangles[i].Vertices[j].m_v3Position;
						Vector3 vector = (bNormal ? av3NormalsIn[num2] : Vector3.zero);
						Vector4 item = (bTangent ? av4TangentsIn[num2] : Vector4.zero);
						Vector2 vector2 = (bUV1 ? av2Mapping1In[num] : Vector2.zero);
						Vector2 vector3 = (bUV2 ? av2Mapping2In[num2] : Vector2.zero);
						Color32 color = new Color32(0, 0, 0, 0);
						if (acolColorsIn != null && acolColorsIn.Length != 0)
						{
							color = acolColorsIn[num2];
							flag = true;
						}
						else if (aColors32In != null && aColors32In.Length != 0)
						{
							color = aColors32In[num2];
							flag = true;
						}
						VertexDataHash vertexDataHash = new VertexDataHash(v3Position, vector, vector2, vector3, color);
						if (dicVertexDataHash2Index.ContainsKey(vertexDataHash))
						{
							listIndicesOut.Add(dicVertexDataHash2Index[vertexDataHash]);
							continue;
						}
						dicVertexDataHash2Index.Add(vertexDataHash, listVerticesOut.Count);
						listVerticesOut.Add(vertexDataHash.Vertex);
						if (bNormal)
						{
							listNormalsOut.Add(vector);
						}
						if (bUV1)
						{
							listMapping1Out.Add(vector2);
						}
						if (bUV2)
						{
							listMapping2Out.Add(vector3);
						}
						if (bTangent)
						{
							listTangentsOut.Add(item);
						}
						if (flag)
						{
							listColors32Out.Add(color);
						}
						if (aListTriangles[nSubMesh].m_listTriangles[i].Vertices[j].m_bHasBoneWeight)
						{
							listBoneWeightsOut.Add(aListTriangles[nSubMesh].m_listTriangles[i].Vertices[j].m_boneWeight);
						}
						listIndicesOut.Add(listVerticesOut.Count - 1);
					}
				}
				listlistIndicesOut.Add(listIndicesOut);
			}
			meshOut.triangles = new int[0];
			meshOut.vertices = listVerticesOut.ToArray();
			meshOut.normals = ((listNormalsOut.Count > 0) ? listNormalsOut.ToArray() : null);
			meshOut.tangents = ((listTangentsOut.Count > 0) ? listTangentsOut.ToArray() : null);
			meshOut.uv = ((listMapping1Out.Count > 0) ? listMapping1Out.ToArray() : null);
			meshOut.uv2 = ((listMapping2Out.Count > 0) ? listMapping2Out.ToArray() : null);
			meshOut.colors32 = ((listColors32Out.Count > 0) ? listColors32Out.ToArray() : null);
			meshOut.boneWeights = ((listBoneWeightsOut.Count > 0) ? listBoneWeightsOut.ToArray() : null);
			meshOut.bindposes = meshIn.bindposes;
			meshOut.subMeshCount = listlistIndicesOut.Count;
			for (int k = 0; k < listlistIndicesOut.Count; k++)
			{
				meshOut.SetTriangles(listlistIndicesOut[k].ToArray(), k);
			}
			meshOut.name = gameObject.name + " simplified mesh";
			progress("Simplifying mesh: " + strProgressDisplayObjectName, "Mesh consolidation done", 1f);
		}

		private int MapVertex(int nVertex, int nMax)
		{
			if (nMax <= 0)
			{
				return 0;
			}
			while (nVertex >= nMax)
			{
				nVertex = m_listVertexMap[nVertex];
			}
			return nVertex;
		}

		private float ComputeEdgeCollapseCost(Vertex u, Vertex v, float fRelevanceBias)
		{
			bool bUseEdgeLength = m_bUseEdgeLength;
			bool bUseCurvature = m_bUseCurvature;
			bool bProtectTexture = m_bProtectTexture;
			bool bLockBorder = m_bLockBorder;
			float num = (bUseEdgeLength ? (Vector3.Magnitude(v.m_v3Position - u.m_v3Position) / m_fOriginalMeshSize) : 1f);
			float num2 = 0.001f;
			List<Triangle> list = new List<Triangle>();
			for (int i = 0; i < u.m_listFaces.Count; i++)
			{
				if (u.m_listFaces[i].HasVertex(v))
				{
					list.Add(u.m_listFaces[i]);
				}
			}
			if (bUseCurvature)
			{
				for (int i = 0; i < u.m_listFaces.Count; i++)
				{
					float num3 = 1f;
					for (int j = 0; j < list.Count; j++)
					{
						float num4 = Vector3.Dot(u.m_listFaces[i].Normal, list[j].Normal);
						num3 = Mathf.Min(num3, (1f - num4) / 2f);
					}
					num2 = Mathf.Max(num2, num3);
				}
			}
			if (u.IsBorder() && list.Count > 1)
			{
				num2 = 1f;
			}
			if (bProtectTexture)
			{
				bool flag = true;
				for (int i = 0; i < u.m_listFaces.Count; i++)
				{
					for (int k = 0; k < list.Count; k++)
					{
						if (!u.m_listFaces[i].HasUVData)
						{
							flag = false;
							break;
						}
						if (u.m_listFaces[i].TexAt(u) == list[k].TexAt(u))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					num2 = 1f;
				}
			}
			if (bLockBorder && u.IsBorder())
			{
				num2 = 10000000f;
			}
			num2 += fRelevanceBias;
			return num * num2;
		}

		private void ComputeEdgeCostAtVertex(Vertex v, Transform transform, RelevanceSphere[] aRelevanceSpheres)
		{
			if (v.m_listNeighbors.Count == 0)
			{
				v.m_collapse = null;
				v.m_fObjDist = -0.01f;
				return;
			}
			v.m_fObjDist = 10000000f;
			v.m_collapse = null;
			float fRelevanceBias = 0f;
			if (aRelevanceSpheres != null)
			{
				for (int i = 0; i < aRelevanceSpheres.Length; i++)
				{
					Matrix4x4 matrix4x = Matrix4x4.TRS(aRelevanceSpheres[i].m_v3Position, Quaternion.Euler(aRelevanceSpheres[i].m_v3Rotation), aRelevanceSpheres[i].m_v3Scale);
					Vector3 v3PositionWorld = v.m_v3PositionWorld;
					if (matrix4x.inverse.MultiplyPoint(v3PositionWorld).magnitude <= 0.5f)
					{
						fRelevanceBias = aRelevanceSpheres[i].m_fRelevance;
					}
				}
			}
			for (int j = 0; j < v.m_listNeighbors.Count; j++)
			{
				float num = ComputeEdgeCollapseCost(v, v.m_listNeighbors[j], fRelevanceBias);
				if (v.m_collapse == null || num < v.m_fObjDist)
				{
					v.m_collapse = v.m_listNeighbors[j];
					v.m_fObjDist = num;
				}
			}
		}

		private IEnumerator ComputeAllEdgeCollapseCosts(string strProgressDisplayObjectName, Transform transform, RelevanceSphere[] aRelevanceSpheres, ProgressDelegate progress = null)
		{
			Stopwatch stopwatch = Stopwatch.StartNew();
			for (int i = 0; i < m_listVertices.Count; i++)
			{
				if (progress != null && (i & 0xFF) == 0)
				{
					progress("Preprocessing mesh: " + strProgressDisplayObjectName, "Computing edge collapse cost", (m_listVertices.Count == 1) ? 1f : ((float)i / ((float)m_listVertices.Count - 1f)));
					if (Cancelled)
					{
						break;
					}
				}
				if (stopwatch.ElapsedMilliseconds > CoroutineFrameMiliseconds && CoroutineFrameMiliseconds > 0)
				{
					yield return null;
					stopwatch = Stopwatch.StartNew();
				}
				ComputeEdgeCostAtVertex(m_listVertices[i], transform, aRelevanceSpheres);
				HeapAdd(m_listVertices[i]);
			}
		}

		private void Collapse(Vertex u, Vertex v, bool bRecompute, Transform transform, RelevanceSphere[] aRelevanceSpheres)
		{
			if (v == null)
			{
				u.Destructor(this);
				return;
			}
			List<Vertex> list = new List<Vertex>();
			for (int i = 0; i < u.m_listNeighbors.Count; i++)
			{
				list.Add(u.m_listNeighbors[i]);
			}
			List<Triangle> list2 = new List<Triangle>();
			for (int i = 0; i < u.m_listFaces.Count; i++)
			{
				if (u.m_listFaces[i].HasVertex(v))
				{
					list2.Add(u.m_listFaces[i]);
				}
			}
			for (int i = 0; i < u.m_listFaces.Count; i++)
			{
				if (u.m_listFaces[i].HasVertex(v) || !u.m_listFaces[i].HasUVData)
				{
					continue;
				}
				for (int j = 0; j < list2.Count; j++)
				{
					if (u.m_listFaces[i].TexAt(u) == list2[j].TexAt(u))
					{
						u.m_listFaces[i].SetTexAt(u, list2[j].TexAt(v));
						break;
					}
				}
			}
			for (int i = u.m_listFaces.Count - 1; i >= 0; i--)
			{
				if (i < u.m_listFaces.Count && i >= 0 && u.m_listFaces[i].HasVertex(v))
				{
					u.m_listFaces[i].Destructor(this);
				}
			}
			for (int i = u.m_listFaces.Count - 1; i >= 0; i--)
			{
				u.m_listFaces[i].ReplaceVertex(u, v);
			}
			u.Destructor(this);
			if (bRecompute)
			{
				for (int i = 0; i < list.Count; i++)
				{
					ComputeEdgeCostAtVertex(list[i], transform, aRelevanceSpheres);
					HeapSortUp(list[i].m_nHeapSpot);
					HeapSortDown(list[i].m_nHeapSpot);
				}
			}
		}

		private void AddVertices(List<Vector3> listVertices, List<Vector3> listVerticesWorld, List<MeshUniqueVertices.SerializableBoneWeight> listBoneWeights)
		{
			bool flag = listBoneWeights != null && listBoneWeights.Count > 0;
			for (int i = 0; i < listVertices.Count; i++)
			{
				new Vertex(this, listVertices[i], listVerticesWorld[i], flag, flag ? listBoneWeights[i].ToBoneWeight() : default(BoneWeight), i);
			}
		}

		private void AddFaceListSubMesh(int nSubMesh, List<int> listTriangles, int[] anIndices, Vector2[] v2Mapping)
		{
			bool bUVData = false;
			if (v2Mapping != null && v2Mapping.Length != 0)
			{
				bUVData = true;
			}
			for (int i = 0; i < listTriangles.Count / 3; i++)
			{
				Triangle t = new Triangle(this, nSubMesh, m_listVertices[listTriangles[i * 3]], m_listVertices[listTriangles[i * 3 + 1]], m_listVertices[listTriangles[i * 3 + 2]], bUVData, anIndices[i * 3], anIndices[i * 3 + 1], anIndices[i * 3 + 2]);
				ShareUV(v2Mapping, t);
			}
		}

		private void ShareUV(Vector2[] aMapping, Triangle t)
		{
			if (!t.HasUVData || aMapping == null || aMapping.Length == 0)
			{
				return;
			}
			for (int i = 0; i < 3; i++)
			{
				int num = i;
				for (int j = 0; j < t.Vertices[num].m_listFaces.Count; j++)
				{
					Triangle triangle = t.Vertices[num].m_listFaces[j];
					if (t == triangle)
					{
						continue;
					}
					int num2 = t.TexAt(t.Vertices[num]);
					int num3 = triangle.TexAt(t.Vertices[num]);
					if (num2 != num3)
					{
						Vector2 vector = aMapping[num2];
						Vector2 vector2 = aMapping[num3];
						if (vector == vector2)
						{
							t.SetTexAt(t.Vertices[num], num3);
						}
					}
				}
			}
		}

		private Vertex MinimumCostEdge()
		{
			return HeapPop();
		}

		private float HeapValue(int i)
		{
			if (i < 0 || i >= m_listHeap.Count)
			{
				return 1E+13f;
			}
			if (m_listHeap[i] == null)
			{
				return 1E+13f;
			}
			return m_listHeap[i].m_fObjDist;
		}

		private void HeapSortUp(int k)
		{
			int num;
			while (HeapValue(k) < HeapValue(num = (k - 1) / 2))
			{
				Vertex value = m_listHeap[k];
				m_listHeap[k] = m_listHeap[num];
				m_listHeap[k].m_nHeapSpot = k;
				m_listHeap[num] = value;
				m_listHeap[num].m_nHeapSpot = num;
				k = num;
			}
		}

		private void HeapSortDown(int k)
		{
			if (k == -1)
			{
				return;
			}
			int num;
			while (HeapValue(k) > HeapValue(num = (k + 1) * 2) || HeapValue(k) > HeapValue(num - 1))
			{
				num = ((HeapValue(num) < HeapValue(num - 1)) ? num : (num - 1));
				Vertex vertex = m_listHeap[k];
				m_listHeap[k] = m_listHeap[num];
				m_listHeap[k].m_nHeapSpot = k;
				m_listHeap[num] = vertex;
				if (vertex != null)
				{
					m_listHeap[num].m_nHeapSpot = num;
				}
				k = num;
			}
		}

		private void HeapAdd(Vertex v)
		{
			int count = m_listHeap.Count;
			m_listHeap.Add(v);
			v.m_nHeapSpot = count;
			HeapSortUp(count);
		}

		private Vertex HeapPop()
		{
			Vertex vertex = m_listHeap[0];
			vertex.m_nHeapSpot = -1;
			m_listHeap[0] = null;
			HeapSortDown(0);
			return vertex;
		}
	}
}
namespace HTC.UnityPlugin.StereoRendering
{
	public interface IDeviceParamFactory
	{
		int GetRenderWidth();

		int GetRenderHeight();

		Vector3 GetEyeSeperation(int eye);

		Quaternion GetEyeLocalRotation(int eye);

		Matrix4x4 GetProjectionMatrix(int eye, float nearPlane, float farPlane);
	}
	public class SteamVRParamFactory : IDeviceParamFactory
	{
		public int GetRenderWidth()
		{
			return (int)SteamVR.instance.sceneWidth;
		}

		public int GetRenderHeight()
		{
			return (int)SteamVR.instance.sceneHeight;
		}

		public Vector3 GetEyeSeperation(int eye)
		{
			Vector3 pos = SteamVR.instance.eyes[eye].pos;
			pos.z = 0f;
			return pos;
		}

		public Quaternion GetEyeLocalRotation(int eye)
		{
			return SteamVR.instance.eyes[eye].rot;
		}

		public Matrix4x4 GetProjectionMatrix(int eye, float nearPlane, float farPlane)
		{
			return HMDMatrix4x4ToMatrix4x4(SteamVR.instance.hmd.GetProjectionMatrix((EVREye)eye, nearPlane, farPlane));
		}

		private Matrix4x4 HMDMatrix4x4ToMatrix4x4(HmdMatrix44_t hmdMatrix)
		{
			Matrix4x4 identity = Matrix4x4.identity;
			identity[0, 0] = hmdMatrix.m0;
			identity[0, 1] = hmdMatrix.m1;
			identity[0, 2] = hmdMatrix.m2;
			identity[0, 3] = hmdMatrix.m3;
			identity[1, 0] = hmdMatrix.m4;
			identity[1, 1] = hmdMatrix.m5;
			identity[1, 2] = hmdMatrix.m6;
			identity[1, 3] = hmdMatrix.m7;
			identity[2, 0] = hmdMatrix.m8;
			identity[2, 1] = hmdMatrix.m9;
			identity[2, 2] = hmdMatrix.m10;
			identity[2, 3] = hmdMatrix.m11;
			identity[3, 0] = hmdMatrix.m12;
			identity[3, 1] = hmdMatrix.m13;
			identity[3, 2] = hmdMatrix.m14;
			identity[3, 3] = hmdMatrix.m15;
			return identity;
		}
	}
	public enum HmdType
	{
		Unsupported,
		SteamVR,
		OVR,
		WaveVR
	}
	public class StereoRenderDevice
	{
		public static HmdType GetHmdType()
		{
			HmdType result = HmdType.Unsupported;
			string loadedDeviceName = XRSettings.loadedDeviceName;
			if (loadedDeviceName == "OpenVR")
			{
				result = HmdType.SteamVR;
			}
			else if (loadedDeviceName == "Oculus")
			{
				result = HmdType.OVR;
			}
			return result;
		}

		public static IDeviceParamFactory InitParamFactory(HmdType hmdType)
		{
			return new SteamVRParamFactory();
		}

		public static bool IsNotUnityNativeSupport(HmdType type)
		{
			return type == HmdType.WaveVR;
		}
	}
	[DisallowMultipleComponent]
	public class StereoRenderManager : MonoBehaviour
	{
		private static StereoRenderManager instance;

		private static bool isApplicationQuitting;

		public HmdType hmdType;

		public IDeviceParamFactory paramFactory;

		private static GameObject mainCameraParent;

		private static Camera mainCamera;

		public List<StereoRenderer> stereoRendererList = new List<StereoRenderer>();

		public static bool Active => instance != null;

		public static StereoRenderManager Instance
		{
			get
			{
				Initialize();
				return instance;
			}
		}

		private static void Initialize()
		{
			if (Active || isApplicationQuitting)
			{
				return;
			}
			StereoRenderManager[] array = UnityEngine.Object.FindObjectsOfType<StereoRenderManager>();
			if (array.Length != 0)
			{
				instance = array[0];
				if (array.Length > 1)
				{
					Debug.LogError("Multiple StereoRenderManager is not supported.");
				}
			}
			if (!XRSettings.enabled)
			{
				Debug.LogError("VR is not enabled for this application.");
			}
			Camera hmdRig = GetHmdRig();
			if (hmdRig == null)
			{
				return;
			}
			if (hmdRig.transform.parent == null)
			{
				Debug.LogError("HMD rig is not of proper hierarchy. You need a \"rig\" object as its root.");
				return;
			}
			if (!Active)
			{
				instance = hmdRig.gameObject.AddComponent<StereoRenderManager>();
			}
			if (Active)
			{
				mainCamera = hmdRig;
				mainCameraParent = hmdRig.transform.parent.gameObject;
			}
		}

		private static Camera GetHmdRig()
		{
			Camera result = null;
			if (Camera.main != null)
			{
				Camera.main.gameObject.AddComponent<VRRenderEventDetector>().Initialize(0);
				result = Camera.main;
			}
			return result;
		}

		public void InitParamFactory()
		{
			if (paramFactory == null)
			{
				hmdType = StereoRenderDevice.GetHmdType();
				paramFactory = StereoRenderDevice.InitParamFactory(hmdType);
				if (paramFactory == null)
				{
					Debug.LogError("Current VR device is unsupported.");
				}
			}
		}

		private void OnApplicationQuit()
		{
			isApplicationQuitting = true;
		}

		public void InvokeStereoRenderers(VRRenderEventDetector detector)
		{
			for (int i = 0; i < stereoRendererList.Count; i++)
			{
				StereoRenderer stereoRenderer = stereoRendererList[i];
				if (stereoRenderer.shouldRender)
				{
					stereoRenderer.Render(detector);
				}
			}
		}

		public void AddToManager(StereoRenderer stereoRenderer)
		{
			stereoRendererList.Add(stereoRenderer);
		}

		public void RemoveFromManager(StereoRenderer stereoRenderer)
		{
			stereoRendererList.Remove(stereoRenderer);
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(Renderer))]
	public class StereoRenderer : MonoBehaviour
	{
		public Transform canvasOrigin;

		[SerializeField]
		private Vector3 m_canvasOriginWorldPosition = new Vector3(0f, 0f, 0f);

		[SerializeField]
		private Vector3 m_canvasOriginWorldRotation = new Vector3(0f, 0f, 0f);

		public Transform anchorTransform;

		[SerializeField]
		private Vector3 m_anchorWorldPosition = new Vector3(0f, 0f, 0f);

		[SerializeField]
		private Vector3 m_anchorWorldRotation = new Vector3(0f, 0f, 0f);

		private Matrix4x4 leftProjMatrix;

		private Matrix4x4 rightProjMatrix;

		private bool canvasVisible;

		public bool shouldRender = true;

		public bool useObliqueClip = true;

		public bool useScissor = true;

		[SerializeField]
		private bool isUnlit;

		public GameObject stereoCameraHead;

		public Camera stereoCameraEye;

		private RenderTexture leftEyeTexture;

		private RenderTexture rightEyeTexture;

		public float textureResolutionScale = 1f;

		private Material stereoMaterial;

		[SerializeField]
		private List<GameObject> ignoreWhenRender = new List<GameObject>();

		private List<int> ignoreObjOriginalLayer = new List<int>();

		public string ignoreLayerName = "StereoRender_Ignore";

		private int ignoreLayerNumber = -1;

		public float reflectionOffset = 0.05f;

		private Rect fullViewport = new Rect(0f, 0f, 1f, 1f);

		public bool isMirror;

		private Matrix4x4 reflectionMat;

		private Action preRenderListeners;

		private Action postRenderListeners;

		public Vector3 canvasOriginPos
		{
			get
			{
				if (canvasOrigin == null)
				{
					return m_canvasOriginWorldPosition;
				}
				return canvasOrigin.position;
			}
			set
			{
				m_canvasOriginWorldPosition = value;
			}
		}

		public Vector3 canvasOriginEuler
		{
			get
			{
				if (canvasOrigin == null)
				{
					return m_canvasOriginWorldRotation;
				}
				return canvasOrigin.eulerAngles;
			}
			set
			{
				m_canvasOriginWorldRotation = value;
			}
		}

		public Quaternion canvasOriginRot
		{
			get
			{
				return Quaternion.Euler(canvasOriginEuler);
			}
			set
			{
				canvasOriginEuler = value.eulerAngles;
			}
		}

		public Vector3 canvasOriginForward => canvasOriginRot * Vector3.forward;

		public Vector3 canvasOriginUp => canvasOriginRot * Vector3.up;

		public Vector3 canvasOriginRight => canvasOriginRot * Vector3.right;

		public Vector3 localCanvasOriginPos
		{
			get
			{
				return base.transform.InverseTransformPoint(canvasOriginPos);
			}
			set
			{
				canvasOriginPos = base.transform.InverseTransformPoint(value);
			}
		}

		public Vector3 localCanvasOriginEuler
		{
			get
			{
				return (Quaternion.Inverse(base.transform.rotation) * Quaternion.Euler(canvasOriginEuler)).eulerAngles;
			}
			set
			{
				canvasOriginEuler = (base.transform.rotation * Quaternion.Euler(value)).eulerAngles;
			}
		}

		public Quaternion localCanvasOriginRot
		{
			get
			{
				return Quaternion.Inverse(base.transform.rotation) * canvasOriginRot;
			}
			set
			{
				canvasOriginRot = base.transform.rotation * value;
			}
		}

		public Vector3 anchorPos
		{
			get
			{
				if (anchorTransform == null)
				{
					return m_anchorWorldPosition;
				}
				return anchorTransform.position;
			}
			set
			{
				m_anchorWorldPosition = value;
			}
		}

		public Vector3 anchorEuler
		{
			get
			{
				if (anchorTransform == null)
				{
					return m_anchorWorldRotation;
				}
				return anchorTransform.eulerAngles;
			}
			set
			{
				m_anchorWorldRotation = value;
			}
		}

		public Quaternion anchorRot
		{
			get
			{
				return Quaternion.Euler(anchorEuler);
			}
			set
			{
				anchorEuler = value.eulerAngles;
			}
		}

		public Vector3 anchorForward => anchorRot * Vector3.forward;

		public Vector3 anchorUp => anchorRot * Vector3.up;

		private void Start()
		{
			if (!IsEditing())
			{
				StereoRenderManager.Instance.InitParamFactory();
				if (stereoCameraHead == null)
				{
					CreateStereoCameraRig();
				}
				leftProjMatrix = StereoRenderManager.Instance.paramFactory.GetProjectionMatrix(0, stereoCameraEye.nearClipPlane, stereoCameraEye.farClipPlane);
				rightProjMatrix = StereoRenderManager.Instance.paramFactory.GetProjectionMatrix(1, stereoCameraEye.nearClipPlane, stereoCameraEye.farClipPlane);
				SwapStereoShader();
				CreateRenderTextures(StereoRenderManager.Instance.paramFactory.GetRenderWidth(), StereoRenderManager.Instance.paramFactory.GetRenderHeight());
				StereoRenderManager.Instance.AddToManager(this);
				ignoreLayerNumber = LayerMask.NameToLayer(ignoreLayerName);
				if (ignoreWhenRender.Count != 0 && ignoreLayerNumber == -1)
				{
					Debug.LogError("Layer \"" + ignoreLayerName + "\" is not created.");
				}
				else
				{
					stereoCameraEye.cullingMask &= ~(1 << ignoreLayerNumber);
				}
			}
		}

		private void OnDestroy()
		{
			if (IsEditing())
			{
				UnityEngine.Object.DestroyImmediate(stereoCameraHead);
			}
			else if (UnityEngine.Application.isPlaying)
			{
				StereoRenderManager.Instance.RemoveFromManager(this);
			}
		}

		private void CreateStereoCameraRig()
		{
			stereoCameraHead = new GameObject("Stereo Camera Head [" + base.gameObject.name + "]");
			stereoCameraHead.transform.parent = base.transform;
			GameObject gameObject = new GameObject("Stereo Camera Eye [" + base.gameObject.name + "]");
			gameObject.transform.parent = stereoCameraHead.transform;
			stereoCameraEye = gameObject.AddComponent<Camera>();
			stereoCameraEye.enabled = false;
		}

		private void SwapStereoShader()
		{
			Renderer component = GetComponent<Renderer>();
			Material[] materials = component.materials;
			int num = 0;
			for (num = 0; num < materials.Length; num++)
			{
				Material material = materials[num];
				if (!(material.shader.name == "Custom/StereoRenderShader"))
				{
					continue;
				}
				stereoMaterial = material;
				if (StereoRenderDevice.IsNotUnityNativeSupport(StereoRenderManager.Instance.hmdType))
				{
					if (isUnlit)
					{
						component.materials[num].shader = Shader.Find("Custom/StereoRenderShader-SingleTexture-Unlit");
					}
					else
					{
						component.materials[num].shader = Shader.Find("Custom/StereoRenderShader-SingleTexture");
					}
				}
				else if (isUnlit)
				{
					component.materials[num].shader = Shader.Find("Custom/StereoRenderShader-Unlit");
				}
				break;
			}
			if (num != materials.Length)
			{
				return;
			}
			component.sharedMaterial = (Material)Resources.Load("StereoRenderMaterial", typeof(Material));
			if (StereoRenderDevice.IsNotUnityNativeSupport(StereoRenderManager.Instance.hmdType))
			{
				if (isUnlit)
				{
					component.materials[num].shader = Shader.Find("Custom/StereoRenderShader-SingleTexture-Unlit");
				}
				else
				{
					component.materials[num].shader = Shader.Find("Custom/StereoRenderShader-SingleTexture");
				}
			}
			stereoMaterial = component.materials[0];
		}

		private void CreateRenderTextures(int sceneWidth, int sceneHeight, int aaLevel = 4)
		{
			int depth = 24;
			int width = (int)(textureResolutionScale * (float)sceneWidth);
			int height = (int)(textureResolutionScale * (float)sceneHeight);
			leftEyeTexture = new RenderTexture(width, height, depth);
			leftEyeTexture.antiAliasing = aaLevel;
			rightEyeTexture = new RenderTexture(width, height, depth);
			rightEyeTexture.antiAliasing = aaLevel;
		}

		private void Update()
		{
			if (isMirror)
			{
				anchorPos = canvasOriginPos;
				anchorRot = canvasOriginRot;
			}
		}

		private void OnWillRenderObject()
		{
			if (Camera.current.GetComponent<VRRenderEventDetector>() != null)
			{
				canvasVisible = true;
			}
		}

		public void Render(VRRenderEventDetector detector)
		{
			MoveStereoCameraBasedOnHmdPose(detector);
			if (preRenderListeners != null)
			{
				preRenderListeners();
			}
			if (canvasVisible)
			{
				ignoreObjOriginalLayer.Clear();
				for (int i = 0; i < ignoreWhenRender.Count; i++)
				{
					ignoreObjOriginalLayer.Add(ignoreWhenRender[i].layer);
					if (ignoreLayerNumber > 0)
					{
						ignoreWhenRender[i].layer = ignoreLayerNumber;
					}
				}
				if (isMirror)
				{
					GL.invertCulling = true;
				}
				if (StereoRenderDevice.IsNotUnityNativeSupport(StereoRenderManager.Instance.hmdType))
				{
					RenderToOneStereoTexture(detector);
				}
				else
				{
					RenderToTwoStereoTextures(detector);
				}
				if (isMirror)
				{
					GL.invertCulling = false;
				}
				for (int j = 0; j < ignoreWhenRender.Count; j++)
				{
					ignoreWhenRender[j].layer = ignoreObjOriginalLayer[j];
				}
				canvasVisible = false;
			}
			if (postRenderListeners != null)
			{
				postRenderListeners();
			}
		}

		public void MoveStereoCameraBasedOnHmdPose(VRRenderEventDetector detector)
		{
			Vector3 position = detector.transform.position;
			Quaternion rotation = detector.transform.rotation;
			if (isMirror)
			{
				float num = 0.07f;
				float w = 0f - Vector3.Dot(canvasOriginUp, canvasOriginPos) - num;
				Vector4 normal = new Vector4(canvasOriginUp.x, canvasOriginUp.y, canvasOriginUp.z, w);
				reflectionMat = Matrix4x4.zero;
				CalculateReflectionMatrix(ref reflectionMat, normal);
				Vector3 position2 = reflectionMat.MultiplyPoint(position);
				stereoCameraHead.transform.position = position2;
				stereoCameraHead.transform.rotation = rotation;
			}
			else
			{
				Vector3 vector = position - canvasOriginPos;
				Quaternion quaternion = anchorRot * Quaternion.Inverse(canvasOriginRot);
				Vector3 vector2 = quaternion * vector;
				stereoCameraHead.transform.position = anchorPos + vector2;
				stereoCameraHead.transform.rotation = quaternion * rotation;
			}
		}

		private void RenderToTwoStereoTextures(VRRenderEventDetector detector)
		{
			Vector3 eyeSeperation = StereoRenderManager.Instance.paramFactory.GetEyeSeperation(0);
			Quaternion eyeLocalRotation = StereoRenderManager.Instance.paramFactory.GetEyeLocalRotation(0);
			Vector3 eyeSeperation2 = StereoRenderManager.Instance.paramFactory.GetEyeSeperation(1);
			Quaternion eyeLocalRotation2 = StereoRenderManager.Instance.paramFactory.GetEyeLocalRotation(1);
			RenderEye(eyeSeperation, eyeLocalRotation, leftProjMatrix, detector.unityCamera.worldToCameraMatrix, leftEyeTexture, "_LeftEyeTexture");
			Matrix4x4 worldToCameraMatrix = detector.unityCamera.worldToCameraMatrix;
			worldToCameraMatrix.m03 -= 2f * Mathf.Abs(eyeSeperation.x);
			RenderEye(eyeSeperation2, eyeLocalRotation2, rightProjMatrix, worldToCameraMatrix, rightEyeTexture, "_RightEyeTexture");
		}

		private void RenderToOneStereoTexture(VRRenderEventDetector detector)
		{
			if (detector.eye == 0)
			{
				Vector3 eyeSeperation = StereoRenderManager.Instance.paramFactory.GetEyeSeperation(0);
				Quaternion eyeLocalRotation = StereoRenderManager.Instance.paramFactory.GetEyeLocalRotation(0);
				RenderEye(eyeSeperation, eyeLocalRotation, leftProjMatrix, detector.unityCamera.worldToCameraMatrix, leftEyeTexture, "_MainTexture");
			}
			else
			{
				Vector3 eyeSeperation2 = StereoRenderManager.Instance.paramFactory.GetEyeSeperation(1);
				Quaternion eyeLocalRotation2 = StereoRenderManager.Instance.paramFactory.GetEyeLocalRotation(1);
				RenderEye(eyeSeperation2, eyeLocalRotation2, rightProjMatrix, detector.unityCamera.worldToCameraMatrix, rightEyeTexture, "_MainTexture");
			}
		}

		private void RenderEye(Vector3 eyeOffset, Quaternion eyeRotation, Matrix4x4 projMat, Matrix4x4 worldToCameraMat, RenderTexture targetTexture, string textureName)
		{
			stereoCameraEye.transform.localPosition = eyeOffset;
			stereoCameraEye.transform.localRotation = eyeRotation;
			if (isMirror)
			{
				stereoCameraEye.worldToCameraMatrix = worldToCameraMat * reflectionMat;
			}
			stereoCameraEye.projectionMatrix = projMat;
			if (useScissor)
			{
				Rect scissorRect = GetScissorRect(projMat * worldToCameraMat);
				stereoCameraEye.rect = scissorRect;
				stereoCameraEye.projectionMatrix = GetScissorMatrix(scissorRect) * stereoCameraEye.projectionMatrix;
			}
			else
			{
				stereoCameraEye.rect = fullViewport;
			}
			if (useObliqueClip)
			{
				Vector4 obliqueNearClipPlane = GetObliqueNearClipPlane();
				stereoCameraEye.projectionMatrix = stereoCameraEye.CalculateObliqueMatrix(obliqueNearClipPlane);
			}
			stereoCameraEye.targetTexture = targetTexture;
			stereoCameraEye.Render();
			stereoMaterial.SetTexture(textureName, targetTexture);
		}

		public void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 normal)
		{
			reflectionMat.m00 = 1f - 2f * normal[0] * normal[0];
			reflectionMat.m01 = -2f * normal[0] * normal[1];
			reflectionMat.m02 = -2f * normal[0] * normal[2];
			reflectionMat.m03 = -2f * normal[3] * normal[0];
			reflectionMat.m10 = -2f * normal[1] * normal[0];
			reflectionMat.m11 = 1f - 2f * normal[1] * normal[1];
			reflectionMat.m12 = -2f * normal[1] * normal[2];
			reflectionMat.m13 = -2f * normal[3] * normal[1];
			reflectionMat.m20 = -2f * normal[2] * normal[0];
			reflectionMat.m21 = -2f * normal[2] * normal[1];
			reflectionMat.m22 = 1f - 2f * normal[2] * normal[2];
			reflectionMat.m23 = -2f * normal[3] * normal[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
		}

		private Vector4 GetCameraSpacePlane(Camera cam, Vector3 pt, Vector3 normal)
		{
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(pt);
			Vector3 normalized = worldToCameraMatrix.MultiplyVector(normal).normalized;
			return new Vector4(normalized.x, normalized.y, normalized.z, 0f - Vector3.Dot(lhs, normalized));
		}

		private Vector4 GetObliqueNearClipPlane()
		{
			Vector4 zero = Vector4.zero;
			if (!isMirror)
			{
				return GetCameraSpacePlane(stereoCameraEye, anchorPos, anchorForward);
			}
			float w = 0f - Vector3.Dot(canvasOriginUp, canvasOriginPos) - reflectionOffset;
			return GetCameraSpacePlane(normal: new Vector4(canvasOriginUp.x, canvasOriginUp.y, canvasOriginUp.z, w), cam: stereoCameraEye, pt: canvasOriginPos);
		}

		private Rect GetScissorRect(Matrix4x4 mat)
		{
			Renderer component = GetComponent<Renderer>();
			Vector3 center = component.bounds.center;
			Vector3 extents = component.bounds.extents;
			Vector3[] obj = new Vector3[8]
			{
				WorldPointToViewport(mat, new Vector3(center.x - extents.x, center.y - extents.y, center.z - extents.z)),
				WorldPointToViewport(mat, new Vector3(center.x + extents.x, center.y - extents.y, center.z - extents.z)),
				WorldPointToViewport(mat, new Vector3(center.x - extents.x, center.y - extents.y, center.z + extents.z)),
				WorldPointToViewport(mat, new Vector3(center.x + extents.x, center.y - extents.y, center.z + extents.z)),
				WorldPointToViewport(mat, new Vector3(center.x - extents.x, center.y + extents.y, center.z - extents.z)),
				WorldPointToViewport(mat, new Vector3(center.x + extents.x, center.y + extents.y, center.z - extents.z)),
				WorldPointToViewport(mat, new Vector3(center.x - extents.x, center.y + extents.y, center.z + extents.z)),
				WorldPointToViewport(mat, new Vector3(center.x + extents.x, center.y + extents.y, center.z + extents.z))
			};
			bool flag = false;
			Vector2 lhs = obj[0];
			Vector2 lhs2 = obj[0];
			Vector3[] array = obj;
			for (int i = 0; i < array.Length; i++)
			{
				Vector3 vector = array[i];
				if (vector.z < 0f)
				{
					flag = true;
					break;
				}
				lhs = Vector2.Min(lhs, vector);
				lhs2 = Vector2.Max(lhs2, vector);
			}
			if (flag)
			{
				return fullViewport;
			}
			lhs = Vector2.Max(lhs, Vector2.zero);
			lhs2 = Vector2.Min(lhs2, Vector2.one);
			return new Rect(lhs.x, lhs.y, lhs2.x - lhs.x, lhs2.y - lhs.y);
		}

		private Matrix4x4 GetScissorMatrix(Rect rect)
		{
			Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(1f / rect.width - 1f, 1f / rect.height - 1f, 0f), Quaternion.identity, new Vector3(1f / rect.width, 1f / rect.height, 1f));
			return Matrix4x4.TRS(new Vector3((0f - rect.x) * 2f / rect.width, (0f - rect.y) * 2f / rect.height, 0f), Quaternion.identity, Vector3.one) * matrix4x;
		}

		private Vector3 WorldPointToViewport(Matrix4x4 mat, Vector3 point)
		{
			Vector3 vector = default(Vector3);
			vector.x = mat.m00 * point.x + mat.m01 * point.y + mat.m02 * point.z + mat.m03;
			vector.y = mat.m10 * point.x + mat.m11 * point.y + mat.m12 * point.z + mat.m13;
			vector.z = mat.m20 * point.x + mat.m21 * point.y + mat.m22 * point.z + mat.m23;
			float num = mat.m30 * point.x + mat.m31 * point.y + mat.m32 * point.z + mat.m33;
			num = 1f / num;
			vector.x *= num;
			vector.y *= num;
			vector.z = num;
			point = vector;
			point.x = point.x * 0.5f + 0.5f;
			point.y = point.y * 0.5f + 0.5f;
			return point;
		}

		public void SetProjetionMatrices(Matrix4x4 leftMat, Matrix4x4 rightMat)
		{
			leftProjMatrix = leftMat;
			rightProjMatrix = rightMat;
		}

		public void AddPreRenderListener(Action listener)
		{
			if (listener != null)
			{
				preRenderListeners = (Action)Delegate.Combine(preRenderListeners, listener);
			}
		}

		public void AddPostRenderListener(Action listener)
		{
			if (listener != null)
			{
				postRenderListeners = (Action)Delegate.Combine(postRenderListeners, listener);
			}
		}

		public void RemovePreRenderListener(Action listener)
		{
			if (listener != null)
			{
				preRenderListeners = (Action)Delegate.Remove(preRenderListeners, listener);
			}
		}

		public void RemovePostRenderListener(Action listener)
		{
			if (listener != null)
			{
				postRenderListeners = (Action)Delegate.Remove(postRenderListeners, listener);
			}
		}

		public bool IsEditing()
		{
			if (UnityEngine.Application.isEditor)
			{
				return !UnityEngine.Application.isPlaying;
			}
			return false;
		}

		public void SetUnlit(bool value)
		{
			isUnlit = value;
			SwapStereoShader();
		}
	}
	[RequireComponent(typeof(Camera))]
	[DisallowMultipleComponent]
	public class VRRenderEventDetector : MonoBehaviour
	{
		public Camera unityCamera;

		public int eye;

		public void Initialize(int e)
		{
			unityCamera = GetComponent<Camera>();
			eye = e;
		}

		private void OnPreRender()
		{
			StereoRenderManager.Instance.InvokeStereoRenderers(this);
		}
	}
}
namespace DG.Tweening
{
	public static class DOTweenModuleAudio
	{
		public static TweenerCore<float, float, FloatOptions> DOFade(this AudioSource target, float endValue, float duration)
		{
			if (endValue < 0f)
			{
				endValue = 0f;
			}
			else if (endValue > 1f)
			{
				endValue = 1f;
			}
			TweenerCore<float, float, FloatOptions> tweenerCore = DOTween.To(() => target.volume, delegate(float x)
			{
				target.volume = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<float, float, FloatOptions> DOPitch(this AudioSource target, float endValue, float duration)
		{
			TweenerCore<float, float, FloatOptions> tweenerCore = DOTween.To(() => target.pitch, delegate(float x)
			{
				target.pitch = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<float, float, FloatOptions> DOSetFloat(this AudioMixer target, string floatName, float endValue, float duration)
		{
			TweenerCore<float, float, FloatOptions> tweenerCore = DOTween.To(delegate
			{
				target.GetFloat(floatName, out var value);
				return value;
			}, delegate(float x)
			{
				target.SetFloat(floatName, x);
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static int DOComplete(this AudioMixer target, bool withCallbacks = false)
		{
			return DOTween.Complete(target, withCallbacks);
		}

		public static int DOKill(this AudioMixer target, bool complete = false)
		{
			return DOTween.Kill(target, complete);
		}

		public static int DOFlip(this AudioMixer target)
		{
			return DOTween.Flip(target);
		}

		public static int DOGoto(this AudioMixer target, float to, bool andPlay = false)
		{
			return DOTween.Goto(target, to, andPlay);
		}

		public static int DOPause(this AudioMixer target)
		{
			return DOTween.Pause(target);
		}

		public static int DOPlay(this AudioMixer target)
		{
			return DOTween.Play(target);
		}

		public static int DOPlayBackwards(this AudioMixer target)
		{
			return DOTween.PlayBackwards(target);
		}

		public static int DOPlayForward(this AudioMixer target)
		{
			return DOTween.PlayForward(target);
		}

		public static int DORestart(this AudioMixer target)
		{
			return DOTween.Restart(target);
		}

		public static int DORewind(this AudioMixer target)
		{
			return DOTween.Rewind(target);
		}

		public static int DOSmoothRewind(this AudioMixer target)
		{
			return DOTween.SmoothRewind(target);
		}

		public static int DOTogglePause(this AudioMixer target)
		{
			return DOTween.TogglePause(target);
		}
	}
	public static class DOTweenModulePhysics
	{
		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMove(this Rigidbody target, Vector3 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveX(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue, 0f, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveY(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, endValue, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveZ(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, 0f, endValue), duration);
			tweenerCore.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DORotate(this Rigidbody target, Vector3 endValue, float duration, RotateMode mode = RotateMode.Fast)
		{
			TweenerCore<Quaternion, Vector3, QuaternionOptions> tweenerCore = DOTween.To(() => target.rotation, target.MoveRotation, endValue, duration);
			tweenerCore.SetTarget(target);
			tweenerCore.plugOptions.rotateMode = mode;
			return tweenerCore;
		}

		public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DOLookAt(this Rigidbody target, Vector3 towards, float duration, AxisConstraint axisConstraint = AxisConstraint.None, Vector3? up = null)
		{
			TweenerCore<Quaternion, Vector3, QuaternionOptions> tweenerCore = DOTween.To(() => target.rotation, target.MoveRotation, towards, duration).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetLookAt);
			tweenerCore.plugOptions.axisConstraint = axisConstraint;
			tweenerCore.plugOptions.up = ((!up.HasValue) ? Vector3.up : up.Value);
			return tweenerCore;
		}

		public static Sequence DOJump(this Rigidbody target, Vector3 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			float startPosY = 0f;
			float offsetY = -1f;
			bool offsetYSet = false;
			Sequence s = DOTween.Sequence();
			Tween yTween = DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, jumpPower, 0f), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad)
				.SetRelative()
				.SetLoops(numJumps * 2, LoopType.Yoyo)
				.OnStart(delegate
				{
					startPosY = target.position.y;
				});
			s.Append(DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue.x, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)).Join(DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, 0f, endValue.z), duration).SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)).Join(yTween)
				.SetTarget(target)
				.SetEase(DOTween.defaultEaseType);
			yTween.OnUpdate(delegate
			{
				if (!offsetYSet)
				{
					offsetYSet = true;
					offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
				}
				Vector3 position = target.position;
				position.y += DOVirtual.EasedValue(0f, offsetY, yTween.ElapsedPercentage(), Ease.OutQuad);
				target.MovePosition(position);
			});
			return s;
		}

		public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOPath(this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			if (resolution < 1)
			{
				resolution = 1;
			}
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, new DG.Tweening.Plugins.Core.PathCore.Path(pathType, path, resolution, gizmoColor), duration).SetTarget(target).SetUpdate(UpdateType.Fixed);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			return tweenerCore;
		}

		public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOLocalPath(this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			if (resolution < 1)
			{
				resolution = 1;
			}
			Transform trans = target.transform;
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => trans.localPosition, delegate(Vector3 x)
			{
				target.MovePosition((trans.parent == null) ? x : trans.parent.TransformPoint(x));
			}, new DG.Tweening.Plugins.Core.PathCore.Path(pathType, path, resolution, gizmoColor), duration).SetTarget(target).SetUpdate(UpdateType.Fixed);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			tweenerCore.plugOptions.useLocalPosition = true;
			return tweenerCore;
		}

		internal static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOPath(this Rigidbody target, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, path, duration).SetTarget(target);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			return tweenerCore;
		}

		internal static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOLocalPath(this Rigidbody target, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			Transform trans = target.transform;
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => trans.localPosition, delegate(Vector3 x)
			{
				target.MovePosition((trans.parent == null) ? x : trans.parent.TransformPoint(x));
			}, path, duration).SetTarget(target);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			tweenerCore.plugOptions.useLocalPosition = true;
			return tweenerCore;
		}
	}
	public static class DOTweenModulePhysics2D
	{
		public static TweenerCore<Vector2, Vector2, VectorOptions> DOMove(this Rigidbody2D target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOMoveX(this Rigidbody2D target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector2(endValue, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOMoveY(this Rigidbody2D target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector2(0f, endValue), duration);
			tweenerCore.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<float, float, FloatOptions> DORotate(this Rigidbody2D target, float endValue, float duration)
		{
			TweenerCore<float, float, FloatOptions> tweenerCore = DOTween.To(() => target.rotation, target.MoveRotation, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static Sequence DOJump(this Rigidbody2D target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			float startPosY = 0f;
			float offsetY = -1f;
			bool offsetYSet = false;
			Sequence s = DOTween.Sequence();
			Tween yTween = DOTween.To(() => target.position, delegate(Vector2 x)
			{
				target.position = x;
			}, new Vector2(0f, jumpPower), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad)
				.SetRelative()
				.SetLoops(numJumps * 2, LoopType.Yoyo)
				.OnStart(delegate
				{
					startPosY = target.position.y;
				});
			s.Append(DOTween.To(() => target.position, delegate(Vector2 x)
			{
				target.position = x;
			}, new Vector2(endValue.x, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)).Join(yTween).SetTarget(target)
				.SetEase(DOTween.defaultEaseType);
			yTween.OnUpdate(delegate
			{
				if (!offsetYSet)
				{
					offsetYSet = true;
					offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
				}
				Vector3 vector = target.position;
				vector.y += DOVirtual.EasedValue(0f, offsetY, yTween.ElapsedPercentage(), Ease.OutQuad);
				target.MovePosition(vector);
			});
			return s;
		}
	}
	public static class DOTweenModuleSprite
	{
		public static TweenerCore<Color, Color, ColorOptions> DOColor(this SpriteRenderer target, Color endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOFade(this SpriteRenderer target, float endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static Sequence DOGradientColor(this SpriteRenderer target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Tweener DOBlendableColor(this SpriteRenderer target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}
	}
	public static class DOTweenModuleUI
	{
		public static class Utils
		{
			public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
			{
				Vector2 vector = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
				Vector2 screenPoint = RectTransformUtility.WorldToScreenPoint(null, from.position);
				screenPoint += vector;
				RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenPoint, null, out var localPoint);
				Vector2 vector2 = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
				return to.anchoredPosition + localPoint - vector2;
			}
		}

		public static TweenerCore<float, float, FloatOptions> DOFade(this CanvasGroup target, float endValue, float duration)
		{
			TweenerCore<float, float, FloatOptions> tweenerCore = DOTween.To(() => target.alpha, delegate(float x)
			{
				target.alpha = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOColor(this Graphic target, Color endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOFade(this Graphic target, float endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOColor(this Image target, Color endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOFade(this Image target, float endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<float, float, FloatOptions> DOFillAmount(this Image target, float endValue, float duration)
		{
			if (endValue > 1f)
			{
				endValue = 1f;
			}
			else if (endValue < 0f)
			{
				endValue = 0f;
			}
			TweenerCore<float, float, FloatOptions> tweenerCore = DOTween.To(() => target.fillAmount, delegate(float x)
			{
				target.fillAmount = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static Sequence DOGradientColor(this Image target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOFlexibleSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => new Vector2(target.flexibleWidth, target.flexibleHeight), delegate(Vector2 x)
			{
				target.flexibleWidth = x.x;
				target.flexibleHeight = x.y;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOMinSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => new Vector2(target.minWidth, target.minHeight), delegate(Vector2 x)
			{
				target.minWidth = x.x;
				target.minHeight = x.y;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOPreferredSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => new Vector2(target.preferredWidth, target.preferredHeight), delegate(Vector2 x)
			{
				target.preferredWidth = x.x;
				target.preferredHeight = x.y;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOColor(this Outline target, Color endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.To(() => target.effectColor, delegate(Color x)
			{
				target.effectColor = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOFade(this Outline target, float endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.ToAlpha(() => target.effectColor, delegate(Color x)
			{
				target.effectColor = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOScale(this Outline target, Vector2 endValue, float duration)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.effectDistance, delegate(Vector2 x)
			{
				target.effectDistance = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPos(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosX(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(endValue, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorPosY(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(0f, endValue), duration);
			tweenerCore.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3D(this RectTransform target, Vector3 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DX(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(endValue, 0f, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DY(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(0f, endValue, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOAnchorPos3DZ(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(0f, 0f, endValue), duration);
			tweenerCore.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMax(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.anchorMax, delegate(Vector2 x)
			{
				target.anchorMax = x;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOAnchorMin(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.anchorMin, delegate(Vector2 x)
			{
				target.anchorMin = x;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivot(this RectTransform target, Vector2 endValue, float duration)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotX(this RectTransform target, float endValue, float duration)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, new Vector2(endValue, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.X).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOPivotY(this RectTransform target, float endValue, float duration)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, new Vector2(0f, endValue), duration);
			tweenerCore.SetOptions(AxisConstraint.Y).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOSizeDelta(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.sizeDelta, delegate(Vector2 x)
			{
				target.sizeDelta = x;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static Tweener DOPunchAnchorPos(this RectTransform target, Vector2 punch, float duration, int vibrato = 10, float elasticity = 1f, bool snapping = false)
		{
			return DOTween.Punch(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, punch, duration, vibrato, elasticity).SetTarget(target).SetOptions(snapping);
		}

		public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, float strength = 100f, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			return DOTween.Shake(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, duration, strength, vibrato, randomness, ignoreZAxis: true, fadeOut).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake)
				.SetOptions(snapping);
		}

		public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, Vector2 strength, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			return DOTween.Shake(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, duration, strength, vibrato, randomness, fadeOut).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake)
				.SetOptions(snapping);
		}

		public static Sequence DOJumpAnchorPos(this RectTransform target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			float startPosY = 0f;
			float offsetY = -1f;
			bool offsetYSet = false;
			Sequence s = DOTween.Sequence();
			Tween t = DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(0f, jumpPower), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad)
				.SetRelative()
				.SetLoops(numJumps * 2, LoopType.Yoyo)
				.OnStart(delegate
				{
					startPosY = target.anchoredPosition.y;
				});
			s.Append(DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(endValue.x, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)).Join(t).SetTarget(target)
				.SetEase(DOTween.defaultEaseType);
			s.OnUpdate(delegate
			{
				if (!offsetYSet)
				{
					offsetYSet = true;
					offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
				}
				Vector2 anchoredPosition = target.anchoredPosition;
				anchoredPosition.y += DOVirtual.EasedValue(0f, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
				target.anchoredPosition = anchoredPosition;
			});
			return s;
		}

		public static Tweener DONormalizedPos(this ScrollRect target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.horizontalNormalizedPosition, target.verticalNormalizedPosition), delegate(Vector2 x)
			{
				target.horizontalNormalizedPosition = x.x;
				target.verticalNormalizedPosition = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.horizontalNormalizedPosition, delegate(float x)
			{
				target.horizontalNormalizedPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.verticalNormalizedPosition, delegate(float x)
			{
				target.verticalNormalizedPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static TweenerCore<float, float, FloatOptions> DOValue(this Slider target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<float, float, FloatOptions> tweenerCore = DOTween.To(() => target.value, delegate(float x)
			{
				target.value = x;
			}, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOColor(this Text target, Color endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Color, Color, ColorOptions> DOFade(this Text target, float endValue, float duration)
		{
			TweenerCore<Color, Color, ColorOptions> tweenerCore = DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<string, string, StringOptions> DOText(this Text target, string endValue, float duration, bool richTextEnabled = true, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
		{
			TweenerCore<string, string, StringOptions> tweenerCore = DOTween.To(() => target.text, delegate(string x)
			{
				target.text = x;
			}, endValue, duration);
			tweenerCore.SetOptions(richTextEnabled, scrambleMode, scrambleChars).SetTarget(target);
			return tweenerCore;
		}

		public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}
	}
	public static class DOTweenModuleUnityVersion
	{
		public static Sequence DOGradientColor(this Material target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Sequence DOGradientColor(this Material target, Gradient gradient, string property, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.SetColor(property, gradientColorKey.color);
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, property, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static CustomYieldInstruction WaitForCompletion(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForCompletion(t);
		}

		public static CustomYieldInstruction WaitForRewind(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForRewind(t);
		}

		public static CustomYieldInstruction WaitForKill(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForKill(t);
		}

		public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
		}

		public static CustomYieldInstruction WaitForPosition(this Tween t, float position, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForPosition(t, position);
		}

		public static CustomYieldInstruction WaitForStart(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForStart(t);
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOOffset(this Material target, Vector2 endValue, int propertyID, float duration)
		{
			if (!target.HasProperty(propertyID))
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
				}
				return null;
			}
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.GetTextureOffset(propertyID), delegate(Vector2 x)
			{
				target.SetTextureOffset(propertyID, x);
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOTiling(this Material target, Vector2 endValue, int propertyID, float duration)
		{
			if (!target.HasProperty(propertyID))
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
				}
				return null;
			}
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.GetTextureScale(propertyID), delegate(Vector2 x)
			{
				target.SetTextureScale(propertyID, x);
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}
	}
	public static class DOTweenCYInstruction
	{
		public class WaitForCompletion : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.IsComplete();
					}
					return false;
				}
			}

			public WaitForCompletion(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForRewind : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						if (t.playedOnce)
						{
							return t.position * (float)(t.CompletedLoops() + 1) > 0f;
						}
						return true;
					}
					return false;
				}
			}

			public WaitForRewind(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForKill : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting => t.active;

			public WaitForKill(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForElapsedLoops : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly int elapsedLoops;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.CompletedLoops() < elapsedLoops;
					}
					return false;
				}
			}

			public WaitForElapsedLoops(Tween tween, int elapsedLoops)
			{
				t = tween;
				this.elapsedLoops = elapsedLoops;
			}
		}

		public class WaitForPosition : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly float position;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.position * (float)(t.CompletedLoops() + 1) < position;
					}
					return false;
				}
			}

			public WaitForPosition(Tween tween, float position)
			{
				t = tween;
				this.position = position;
			}
		}

		public class WaitForStart : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.playedOnce;
					}
					return false;
				}
			}

			public WaitForStart(Tween tween)
			{
				t = tween;
			}
		}
	}
	public static class DOTweenModuleUtils
	{
		public static class Physics
		{
			public static void SetOrientationOnPath(PathOptions options, Tween t, Quaternion newRot, Transform trans)
			{
				if (options.isRigidbody)
				{
					((Rigidbody)t.target).rotation = newRot;
				}
				else
				{
					trans.rotation = newRot;
				}
			}

			public static bool HasRigidbody2D(Component target)
			{
				return target.GetComponent<Rigidbody2D>() != null;
			}

			[Preserve]
			public static bool HasRigidbody(Component target)
			{
				return target.GetComponent<Rigidbody>() != null;
			}

			[Preserve]
			public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> CreateDOTweenPathTween(MonoBehaviour target, bool tweenRigidbody, bool isLocal, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode)
			{
				Rigidbody rigidbody = (tweenRigidbody ? target.GetComponent<Rigidbody>() : null);
				if (tweenRigidbody && rigidbody != null)
				{
					return isLocal ? rigidbody.DOLocalPath(path, duration, pathMode) : rigidbody.DOPath(path, duration, pathMode);
				}
				return isLocal ? target.transform.DOLocalPath(path, duration, pathMode) : target.transform.DOPath(path, duration, pathMode);
			}
		}

		private static bool _initialized;

		[Preserve]
		public static void Init()
		{
			if (!_initialized)
			{
				_initialized = true;
				DOTweenExternalCommand.SetOrientationOnPath += Physics.SetOrientationOnPath;
			}
		}

		[Preserve]
		private static void Preserver()
		{
			AppDomain.CurrentDomain.GetAssemblies();
			typeof(MonoBehaviour).GetMethod("Stub");
		}
	}
	[AddComponentMenu("DOTween/DOTween Animation")]
	public class DOTweenAnimation : ABSAnimationComponent
	{
		public enum AnimationType
		{
			None,
			Move,
			LocalMove,
			Rotate,
			LocalRotate,
			Scale,
			Color,
			Fade,
			Text,
			PunchPosition,
			PunchRotation,
			PunchScale,
			ShakePosition,
			ShakeRotation,
			ShakeScale,
			CameraAspect,
			CameraBackgroundColor,
			CameraFieldOfView,
			CameraOrthoSize,
			CameraPixelRect,
			CameraRect,
			UIWidthHeight
		}

		public enum TargetType
		{
			Unset,
			Camera,
			CanvasGroup,
			Image,
			Light,
			RectTransform,
			Renderer,
			SpriteRenderer,
			Rigidbody,
			Rigidbody2D,
			Text,
			Transform,
			tk2dBaseSprite,
			tk2dTextMesh,
			TextMeshPro,
			TextMeshProUGUI
		}

		public bool targetIsSelf = true;

		public GameObject targetGO;

		public bool tweenTargetIsTargetGO = true;

		public float delay;

		public float duration = 1f;

		public Ease easeType = Ease.OutQuad;

		public AnimationCurve easeCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public LoopType loopType;

		public int loops = 1;

		public string id = "";

		public bool isRelative;

		public bool isFrom;

		public bool isIndependentUpdate;

		public bool autoKill = true;

		public bool isActive = true;

		public bool isValid;

		public Component target;

		public AnimationType animationType;

		public TargetType targetType;

		public TargetType forcedTargetType;

		public bool autoPlay = true;

		public bool useTargetAsV3;

		public float endValueFloat;

		public Vector3 endValueV3;

		public Vector2 endValueV2;

		public Color endValueColor = new Color(1f, 1f, 1f, 1f);

		public string endValueString = "";

		public Rect endValueRect = new Rect(0f, 0f, 0f, 0f);

		public Transform endValueTransform;

		public bool optionalBool0;

		public float optionalFloat0;

		public int optionalInt0;

		public RotateMode optionalRotationMode;

		public ScrambleMode optionalScrambleMode;

		public string optionalString;

		private bool _tweenCreated;

		private int _playCount = -1;

		public static event Action<DOTweenAnimation> OnReset;

		private static void Dispatch_OnReset(DOTweenAnimation anim)
		{
			if (DOTweenAnimation.OnReset != null)
			{
				DOTweenAnimation.OnReset(anim);
			}
		}

		private void Awake()
		{
			if (isActive && isValid && (animationType != AnimationType.Move || !useTargetAsV3))
			{
				CreateTween();
				_tweenCreated = true;
			}
		}

		private void Start()
		{
			if (!_tweenCreated && isActive && isValid)
			{
				CreateTween();
				_tweenCreated = true;
			}
		}

		private void Reset()
		{
			Dispatch_OnReset(this);
		}

		private void OnDestroy()
		{
			if (tween != null && tween.IsActive())
			{
				tween.Kill();
			}
			tween = null;
		}

		public void CreateTween()
		{
			GameObject tweenGO = GetTweenGO();
			if (target == null || tweenGO == null)
			{
				if (targetIsSelf && target == null)
				{
					Debug.LogWarning($"{base.gameObject.name} :: This DOTweenAnimation's target is NULL, because the animation was created with a DOTween Pro version older than 0.9.255. To fix this, exit Play mode then simply select this object, and it will update automatically", base.gameObject);
				}
				else
				{
					Debug.LogWarning($"{base.gameObject.name} :: This DOTweenAnimation's target/GameObject is unset: the tween will not be created.", base.gameObject);
				}
				return;
			}
			if (forcedTargetType != 0)
			{
				this.targetType = forcedTargetType;
			}
			if (this.targetType == TargetType.Unset)
			{
				this.targetType = TypeToDOTargetType(target.GetType());
			}
			switch (animationType)
			{
			case AnimationType.Move:
				if (useTargetAsV3)
				{
					isRelative = false;
					if (endValueTransform == null)
					{
						Debug.LogWarning($"{base.gameObject.name} :: This tween's TO target is NULL, a Vector3 of (0,0,0) will be used instead", base.gameObject);
						endValueV3 = Vector3.zero;
					}
					else if (this.targetType == TargetType.RectTransform)
					{
						RectTransform rectTransform = endValueTransform as RectTransform;
						if (rectTransform == null)
						{
							Debug.LogWarning($"{base.gameObject.name} :: This tween's TO target should be a RectTransform, a Vector3 of (0,0,0) will be used instead", base.gameObject);
							endValueV3 = Vector3.zero;
						}
						else
						{
							RectTransform rectTransform2 = target as RectTransform;
							if (rectTransform2 == null)
							{
								Debug.LogWarning($"{base.gameObject.name} :: This tween's target and TO target are not of the same type. Please reassign the values", base.gameObject);
							}
							else
							{
								endValueV3 = DOTweenModuleUI.Utils.SwitchToRectTransform(rectTransform, rectTransform2);
							}
						}
					}
					else
					{
						endValueV3 = endValueTransform.position;
					}
				}
				switch (this.targetType)
				{
				case TargetType.Transform:
					tween = ((Transform)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOAnchorPos3D(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Rigidbody:
					tween = ((Rigidbody)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				case TargetType.Rigidbody2D:
					tween = ((Rigidbody2D)target).DOMove(endValueV3, duration, optionalBool0);
					break;
				}
				break;
			case AnimationType.LocalMove:
				tween = tweenGO.transform.DOLocalMove(endValueV3, duration, optionalBool0);
				break;
			case AnimationType.Rotate:
				switch (this.targetType)
				{
				case TargetType.Transform:
					tween = ((Transform)target).DORotate(endValueV3, duration, optionalRotationMode);
					break;
				case TargetType.Rigidbody:
					tween = ((Rigidbody)target).DORotate(endValueV3, duration, optionalRotationMode);
					break;
				case TargetType.Rigidbody2D:
					tween = ((Rigidbody2D)target).DORotate(endValueFloat, duration);
					break;
				}
				break;
			case AnimationType.LocalRotate:
				tween = tweenGO.transform.DOLocalRotate(endValueV3, duration, optionalRotationMode);
				break;
			case AnimationType.Scale:
				_ = this.targetType;
				tween = tweenGO.transform.DOScale(optionalBool0 ? new Vector3(endValueFloat, endValueFloat, endValueFloat) : endValueV3, duration);
				break;
			case AnimationType.UIWidthHeight:
				tween = ((RectTransform)target).DOSizeDelta(optionalBool0 ? new Vector2(endValueFloat, endValueFloat) : endValueV2, duration);
				break;
			case AnimationType.Color:
				isRelative = false;
				switch (this.targetType)
				{
				case TargetType.Renderer:
					tween = ((Renderer)target).material.DOColor(endValueColor, duration);
					break;
				case TargetType.Light:
					tween = ((Light)target).DOColor(endValueColor, duration);
					break;
				case TargetType.SpriteRenderer:
					tween = ((SpriteRenderer)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Image:
					tween = ((Graphic)target).DOColor(endValueColor, duration);
					break;
				case TargetType.Text:
					tween = ((Text)target).DOColor(endValueColor, duration);
					break;
				}
				break;
			case AnimationType.Fade:
				isRelative = false;
				switch (this.targetType)
				{
				case TargetType.Renderer:
					tween = ((Renderer)target).material.DOFade(endValueFloat, duration);
					break;
				case TargetType.Light:
					tween = ((Light)target).DOIntensity(endValueFloat, duration);
					break;
				case TargetType.SpriteRenderer:
					tween = ((SpriteRenderer)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Image:
					tween = ((Graphic)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.Text:
					tween = ((Text)target).DOFade(endValueFloat, duration);
					break;
				case TargetType.CanvasGroup:
					tween = ((CanvasGroup)target).DOFade(endValueFloat, duration);
					break;
				}
				break;
			case AnimationType.Text:
			{
				TargetType targetType = this.targetType;
				if (targetType == TargetType.Text)
				{
					tween = ((Text)target).DOText(endValueString, duration, optionalBool0, optionalScrambleMode, optionalString);
				}
				break;
			}
			case AnimationType.PunchPosition:
				switch (this.targetType)
				{
				case TargetType.Transform:
					tween = ((Transform)target).DOPunchPosition(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
					break;
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOPunchAnchorPos(endValueV3, duration, optionalInt0, optionalFloat0, optionalBool0);
					break;
				}
				break;
			case AnimationType.PunchScale:
				tween = tweenGO.transform.DOPunchScale(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case AnimationType.PunchRotation:
				tween = tweenGO.transform.DOPunchRotation(endValueV3, duration, optionalInt0, optionalFloat0);
				break;
			case AnimationType.ShakePosition:
				switch (this.targetType)
				{
				case TargetType.Transform:
					tween = ((Transform)target).DOShakePosition(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
					break;
				case TargetType.RectTransform:
					tween = ((RectTransform)target).DOShakeAnchorPos(duration, endValueV3, optionalInt0, optionalFloat0, optionalBool0);
					break;
				}
				break;
			case AnimationType.ShakeScale:
				tween = tweenGO.transform.DOShakeScale(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case AnimationType.ShakeRotation:
				tween = tweenGO.transform.DOShakeRotation(duration, endValueV3, optionalInt0, optionalFloat0);
				break;
			case AnimationType.CameraAspect:
				tween = ((Camera)target).DOAspect(endValueFloat, duration);
				break;
			case AnimationType.CameraBackgroundColor:
				tween = ((Camera)target).DOColor(endValueColor, duration);
				break;
			case AnimationType.CameraFieldOfView:
				tween = ((Camera)target).DOFieldOfView(endValueFloat, duration);
				break;
			case AnimationType.CameraOrthoSize:
				tween = ((Camera)target).DOOrthoSize(endValueFloat, duration);
				break;
			case AnimationType.CameraPixelRect:
				tween = ((Camera)target).DOPixelRect(endValueRect, duration);
				break;
			case AnimationType.CameraRect:
				tween = ((Camera)target).DORect(endValueRect, duration);
				break;
			}
			if (tween == null)
			{
				return;
			}
			if (isFrom)
			{
				((Tweener)tween).From(isRelative);
			}
			else
			{
				tween.SetRelative(isRelative);
			}
			GameObject gameObject = ((targetIsSelf || !tweenTargetIsTargetGO) ? base.gameObject : targetGO);
			tween.SetTarget(gameObject).SetDelay(delay).SetLoops(loops, loopType)
				.SetAutoKill(autoKill)
				.OnKill(delegate
				{
					tween = null;
				});
			if (isSpeedBased)
			{
				tween.SetSpeedBased();
			}
			if (easeType == Ease.INTERNAL_Custom)
			{
				tween.SetEase(easeCurve);
			}
			else
			{
				tween.SetEase(easeType);
			}
			if (!string.IsNullOrEmpty(id))
			{
				tween.SetId(id);
			}
			tween.SetUpdate(isIndependentUpdate);
			if (hasOnStart)
			{
				if (onStart != null)
				{
					tween.OnStart(onStart.Invoke);
				}
			}
			else
			{
				onStart = null;
			}
			if (hasOnPlay)
			{
				if (onPlay != null)
				{
					tween.OnPlay(onPlay.Invoke);
				}
			}
			else
			{
				onPlay = null;
			}
			if (hasOnUpdate)
			{
				if (onUpdate != null)
				{
					tween.OnUpdate(onUpdate.Invoke);
				}
			}
			else
			{
				onUpdate = null;
			}
			if (hasOnStepComplete)
			{
				if (onStepComplete != null)
				{
					tween.OnStepComplete(onStepComplete.Invoke);
				}
			}
			else
			{
				onStepComplete = null;
			}
			if (hasOnComplete)
			{
				if (onComplete != null)
				{
					tween.OnComplete(onComplete.Invoke);
				}
			}
			else
			{
				onComplete = null;
			}
			if (hasOnRewind)
			{
				if (onRewind != null)
				{
					tween.OnRewind(onRewind.Invoke);
				}
			}
			else
			{
				onRewind = null;
			}
			if (autoPlay)
			{
				tween.Play();
			}
			else
			{
				tween.Pause();
			}
			if (hasOnTweenCreated && onTweenCreated != null)
			{
				onTweenCreated.Invoke();
			}
		}

		public override void DOPlay()
		{
			DOTween.Play(base.gameObject);
		}

		public override void DOPlayBackwards()
		{
			DOTween.PlayBackwards(base.gameObject);
		}

		public override void DOPlayForward()
		{
			DOTween.PlayForward(base.gameObject);
		}

		public override void DOPause()
		{
			DOTween.Pause(base.gameObject);
		}

		public override void DOTogglePause()
		{
			DOTween.TogglePause(base.gameObject);
		}

		public override void DORewind()
		{
			_playCount = -1;
			DOTweenAnimation[] components = base.gameObject.GetComponents<DOTweenAnimation>();
			for (int num = components.Length - 1; num > -1; num--)
			{
				Tween tween = components[num].tween;
				if (tween != null && tween.IsInitialized())
				{
					components[num].tween.Rewind();
				}
			}
		}

		public override void DORestart()
		{
			DORestart(fromHere: false);
		}

		public override void DORestart(bool fromHere)
		{
			_playCount = -1;
			if (tween == null)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 1)
				{
					DG.Tweening.Core.Debugger.LogNullTween(tween);
				}
				return;
			}
			if (fromHere && isRelative)
			{
				ReEvaluateRelativeTween();
			}
			DOTween.Restart(base.gameObject);
		}

		public override void DOComplete()
		{
			DOTween.Complete(base.gameObject);
		}

		public override void DOKill()
		{
			DOTween.Kill(base.gameObject);
			tween = null;
		}

		public void DOPlayById(string id)
		{
			DOTween.Play(base.gameObject, id);
		}

		public void DOPlayAllById(string id)
		{
			DOTween.Play(id);
		}

		public void DOPauseAllById(string id)
		{
			DOTween.Pause(id);
		}

		public void DOPlayBackwardsById(string id)
		{
			DOTween.PlayBackwards(base.gameObject, id);
		}

		public void DOPlayBackwardsAllById(string id)
		{
			DOTween.PlayBackwards(id);
		}

		public void DOPlayForwardById(string id)
		{
			DOTween.PlayForward(base.gameObject, id);
		}

		public void DOPlayForwardAllById(string id)
		{
			DOTween.PlayForward(id);
		}

		public void DOPlayNext()
		{
			DOTweenAnimation[] components = GetComponents<DOTweenAnimation>();
			while (_playCount < components.Length - 1)
			{
				_playCount++;
				DOTweenAnimation dOTweenAnimation = components[_playCount];
				if (dOTweenAnimation != null && dOTweenAnimation.tween != null && !dOTweenAnimation.tween.IsPlaying() && !dOTweenAnimation.tween.IsComplete())
				{
					dOTweenAnimation.tween.Play();
					break;
				}
			}
		}

		public void DORewindAndPlayNext()
		{
			_playCount = -1;
			DOTween.Rewind(base.gameObject);
			DOPlayNext();
		}

		public void DORewindAllById(string id)
		{
			_playCount = -1;
			DOTween.Rewind(id);
		}

		public void DORestartById(string id)
		{
			_playCount = -1;
			DOTween.Restart(base.gameObject, id);
		}

		public void DORestartAllById(string id)
		{
			_playCount = -1;
			DOTween.Restart(id);
		}

		public List<Tween> GetTweens()
		{
			List<Tween> list = new List<Tween>();
			DOTweenAnimation[] components = GetComponents<DOTweenAnimation>();
			foreach (DOTweenAnimation dOTweenAnimation in components)
			{
				list.Add(dOTweenAnimation.tween);
			}
			return list;
		}

		public static TargetType TypeToDOTargetType(Type t)
		{
			string text = t.ToString();
			int num = text.LastIndexOf(".");
			if (num != -1)
			{
				text = text.Substring(num + 1);
			}
			if (text.IndexOf("Renderer") != -1 && text != "SpriteRenderer")
			{
				text = "Renderer";
			}
			if (text == "RawImage")
			{
				text = "Image";
			}
			return (TargetType)Enum.Parse(typeof(TargetType), text);
		}

		public Tween CreateEditorPreview()
		{
			if (UnityEngine.Application.isPlaying)
			{
				return null;
			}
			CreateTween();
			return tween;
		}

		private GameObject GetTweenGO()
		{
			if (!targetIsSelf)
			{
				return targetGO;
			}
			return base.gameObject;
		}

		private void ReEvaluateRelativeTween()
		{
			GameObject tweenGO = GetTweenGO();
			if (tweenGO == null)
			{
				Debug.LogWarning($"{base.gameObject.name} :: This DOTweenAnimation's target/GameObject is unset: the tween will not be created.", base.gameObject);
			}
			else if (animationType == AnimationType.Move)
			{
				((Tweener)tween).ChangeEndValue(tweenGO.transform.position + endValueV3, snapStartValue: true);
			}
			else if (animationType == AnimationType.LocalMove)
			{
				((Tweener)tween).ChangeEndValue(tweenGO.transform.localPosition + endValueV3, snapStartValue: true);
			}
		}
	}
	public static class DOTweenAnimationExtensions
	{
		public static bool IsSameOrSubclassOf<T>(this Component t)
		{
			return t is T;
		}
	}
	public static class DOTweenProShortcuts
	{
		static DOTweenProShortcuts()
		{
			new SpiralPlugin();
		}

		public static Tweener DOSpiral(this Transform target, float duration, Vector3? axis = null, SpiralMode mode = SpiralMode.Expand, float speed = 1f, float frequency = 10f, float depth = 0f, bool snapping = false)
		{
			if (Mathf.Approximately(speed, 0f))
			{
				speed = 1f;
			}
			if (!axis.HasValue || axis == Vector3.zero)
			{
				axis = Vector3.forward;
			}
			TweenerCore<Vector3, Vector3, SpiralOptions> tweenerCore = DOTween.To(SpiralPlugin.Get(), () => target.localPosition, delegate(Vector3 x)
			{
				target.localPosition = x;
			}, axis.Value, duration).SetTarget(target);
			tweenerCore.plugOptions.mode = mode;
			tweenerCore.plugOptions.speed = speed;
			tweenerCore.plugOptions.frequency = frequency;
			tweenerCore.plugOptions.depth = depth;
			tweenerCore.plugOptions.snapping = snapping;
			return tweenerCore;
		}

		public static Tweener DOSpiral(this Rigidbody target, float duration, Vector3? axis = null, SpiralMode mode = SpiralMode.Expand, float speed = 1f, float frequency = 10f, float depth = 0f, bool snapping = false)
		{
			if (Mathf.Approximately(speed, 0f))
			{
				speed = 1f;
			}
			if (!axis.HasValue || axis == Vector3.zero)
			{
				axis = Vector3.forward;
			}
			TweenerCore<Vector3, Vector3, SpiralOptions> tweenerCore = DOTween.To(SpiralPlugin.Get(), () => target.position, target.MovePosition, axis.Value, duration).SetTarget(target);
			tweenerCore.plugOptions.mode = mode;
			tweenerCore.plugOptions.speed = speed;
			tweenerCore.plugOptions.frequency = frequency;
			tweenerCore.plugOptions.depth = depth;
			tweenerCore.plugOptions.snapping = snapping;
			return tweenerCore;
		}
	}
}
namespace FlyingWormConsole3
{
	public class ConsoleProRemoteServer : MonoBehaviour
	{
		public bool useNATPunch;

		public int port = 51000;

		public void Awake()
		{
			Debug.Log("Console Pro Remote Server is disabled in release mode, please use a Development build or define DEBUG to use it");
		}
	}
}
namespace OculusSampleFramework
{
	public class ColorGrabbable : OVRGrabbable
	{
		public static readonly Color COLOR_GRAB = new Color(1f, 0.5f, 0f, 1f);

		public static readonly Color COLOR_HIGHLIGHT = new Color(1f, 0f, 1f, 1f);

		private Color m_color = Color.black;

		private MeshRenderer[] m_meshRenderers;

		private bool m_highlight;

		public bool Highlight
		{
			get
			{
				return m_highlight;
			}
			set
			{
				m_highlight = value;
				UpdateColor();
			}
		}

		protected void UpdateColor()
		{
			if (base.isGrabbed)
			{
				SetColor(COLOR_GRAB);
			}
			else if (Highlight)
			{
				SetColor(COLOR_HIGHLIGHT);
			}
			else
			{
				SetColor(m_color);
			}
		}

		public override void GrabBegin(OVRGrabber hand, Collider grabPoint)
		{
			base.GrabBegin(hand, grabPoint);
			UpdateColor();
		}

		public override void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
		{
			base.GrabEnd(linearVelocity, angularVelocity);
			UpdateColor();
		}

		private void Awake()
		{
			if (m_grabPoints.Length == 0)
			{
				Collider component = GetComponent<Collider>();
				if (component == null)
				{
					throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
				}
				m_grabPoints = new Collider[1] { component };
				m_meshRenderers = new MeshRenderer[1];
				m_meshRenderers[0] = GetComponent<MeshRenderer>();
			}
			else
			{
				m_meshRenderers = GetComponentsInChildren<MeshRenderer>();
			}
			m_color = new Color(UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), 1f);
			SetColor(m_color);
		}

		private void SetColor(Color color)
		{
			for (int i = 0; i < m_meshRenderers.Length; i++)
			{
				MeshRenderer meshRenderer = m_meshRenderers[i];
				for (int j = 0; j < meshRenderer.materials.Length; j++)
				{
					meshRenderer.materials[j].color = color;
				}
			}
		}
	}
	public class DistanceGrabbable : OVRGrabbable
	{
		public string m_materialColorField;

		private GrabbableCrosshair m_crosshair;

		private GrabManager m_crosshairManager;

		private Renderer m_renderer;

		private MaterialPropertyBlock m_mpb;

		private bool m_inRange;

		private bool m_targeted;

		public bool InRange
		{
			get
			{
				return m_inRange;
			}
			set
			{
				m_inRange = value;
				RefreshCrosshair();
			}
		}

		public bool Targeted
		{
			get
			{
				return m_targeted;
			}
			set
			{
				m_targeted = value;
				RefreshCrosshair();
			}
		}

		protected override void Start()
		{
			base.Start();
			m_crosshair = base.gameObject.GetComponentInChildren<GrabbableCrosshair>();
			m_renderer = base.gameObject.GetComponent<Renderer>();
			m_crosshairManager = UnityEngine.Object.FindObjectOfType<GrabManager>();
			m_mpb = new MaterialPropertyBlock();
			RefreshCrosshair();
			m_renderer.SetPropertyBlock(m_mpb);
		}

		private void RefreshCrosshair()
		{
			if ((bool)m_crosshair)
			{
				if (base.isGrabbed)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else if (!InRange)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else
				{
					m_crosshair.SetState((!Targeted) ? GrabbableCrosshair.CrosshairState.Enabled : GrabbableCrosshair.CrosshairState.Targeted);
				}
			}
			if (m_materialColorField != null)
			{
				m_renderer.GetPropertyBlock(m_mpb);
				if (base.isGrabbed || !InRange)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorOutOfRange);
				}
				else if (Targeted)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorHighlighted);
				}
				else
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorInRange);
				}
				m_renderer.SetPropertyBlock(m_mpb);
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class DistanceGrabber : OVRGrabber
	{
		[SerializeField]
		private float m_spherecastRadius;

		[SerializeField]
		private float m_noSnapThreshhold = 0.05f;

		[SerializeField]
		private bool m_useSpherecast;

		[SerializeField]
		public bool m_preventGrabThroughWalls;

		[SerializeField]
		private float m_objectPullVelocity = 10f;

		private float m_objectPullMaxRotationRate = 360f;

		private bool m_movingObjectToHand;

		[SerializeField]
		private float m_maxGrabDistance;

		[SerializeField]
		private int m_grabObjectsInLayer;

		[SerializeField]
		private int m_obstructionLayer;

		private DistanceGrabber m_otherHand;

		protected DistanceGrabbable m_target;

		protected Collider m_targetCollider;

		public bool UseSpherecast
		{
			get
			{
				return m_useSpherecast;
			}
			set
			{
				m_useSpherecast = value;
				GrabVolumeEnable(!m_useSpherecast);
			}
		}

		protected override void Start()
		{
			base.Start();
			Collider componentInChildren = m_player.GetComponentInChildren<Collider>();
			if (componentInChildren != null)
			{
				m_maxGrabDistance = componentInChildren.bounds.size.z * 0.5f + 3f;
			}
			else
			{
				m_maxGrabDistance = 12f;
			}
			if (m_parentHeldObject)
			{
				Debug.LogError("m_parentHeldObject incompatible with DistanceGrabber. Setting to false.");
				m_parentHeldObject = false;
			}
			DistanceGrabber[] array = UnityEngine.Object.FindObjectsOfType<DistanceGrabber>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != this)
				{
					m_otherHand = array[i];
				}
			}
			Debug.Assert(m_otherHand != null);
		}

		public override void Update()
		{
			base.Update();
			Debug.DrawRay(base.transform.position, base.transform.forward, Color.red, 0.1f);
			FindTarget(out var dgOut, out var collOut);
			if (dgOut != m_target)
			{
				if (m_target != null)
				{
					m_target.Targeted = m_otherHand.m_target == m_target;
				}
				m_target = dgOut;
				m_targetCollider = collOut;
				if (m_target != null)
				{
					m_target.Targeted = true;
				}
			}
		}

		protected override void GrabBegin()
		{
			DistanceGrabbable target = m_target;
			Collider targetCollider = m_targetCollider;
			GrabVolumeEnable(enabled: false);
			if (!(target != null))
			{
				return;
			}
			if (target.isGrabbed)
			{
				((DistanceGrabber)target.grabbedBy).OffhandGrabbed(target);
			}
			m_grabbedObj = target;
			m_grabbedObj.GrabBegin(this, targetCollider);
			SetPlayerIgnoreCollision(m_grabbedObj.gameObject, ignore: true);
			m_movingObjectToHand = true;
			m_lastPos = base.transform.position;
			m_lastRot = base.transform.rotation;
			Vector3 vector = targetCollider.ClosestPointOnBounds(m_gripTransform.position);
			if (!m_grabbedObj.snapPosition && !m_grabbedObj.snapOrientation && m_noSnapThreshhold > 0f && (vector - m_gripTransform.position).magnitude < m_noSnapThreshhold)
			{
				Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
				m_movingObjectToHand = false;
				vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
				m_grabbedObjectPosOff = vector2;
				Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
				m_grabbedObjectRotOff = grabbedObjectRotOff;
				return;
			}
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}

		protected override void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
		{
			if (m_grabbedObj == null)
			{
				return;
			}
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 vector = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (m_movingObjectToHand)
			{
				float num = m_objectPullVelocity * Time.deltaTime;
				Vector3 vector2 = vector - m_grabbedObj.transform.position;
				if (num * num * 1.1f > vector2.sqrMagnitude)
				{
					m_movingObjectToHand = false;
				}
				else
				{
					vector2.Normalize();
					vector = m_grabbedObj.transform.position + vector2 * num;
					quaternion = Quaternion.RotateTowards(m_grabbedObj.transform.rotation, quaternion, m_objectPullMaxRotationRate * Time.deltaTime);
				}
			}
			grabbedRigidbody.MovePosition(vector);
			grabbedRigidbody.MoveRotation(quaternion);
		}

		private static DistanceGrabbable HitInfoToGrabbable(RaycastHit hitInfo)
		{
			if (hitInfo.collider != null)
			{
				GameObject gameObject = hitInfo.collider.gameObject;
				return gameObject.GetComponent<DistanceGrabbable>() ?? gameObject.GetComponentInParent<DistanceGrabbable>();
			}
			return null;
		}

		protected bool FindTarget(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			float num = float.MaxValue;
			foreach (OVRGrabbable key in m_grabCandidates.Keys)
			{
				DistanceGrabbable distanceGrabbable = key as DistanceGrabbable;
				bool flag = distanceGrabbable != null && distanceGrabbable.InRange && (!distanceGrabbable.isGrabbed || distanceGrabbable.allowOffhandGrab);
				if (flag && m_grabObjectsInLayer >= 0)
				{
					flag = distanceGrabbable.gameObject.layer == m_grabObjectsInLayer;
				}
				if (!flag)
				{
					continue;
				}
				for (int i = 0; i < distanceGrabbable.grabPoints.Length; i++)
				{
					Collider collider = distanceGrabbable.grabPoints[i];
					Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
					float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
					if (!(sqrMagnitude < num))
					{
						continue;
					}
					bool flag2 = true;
					if (m_preventGrabThroughWalls)
					{
						Ray ray = default(Ray);
						ray.direction = distanceGrabbable.transform.position - m_gripTransform.position;
						ray.origin = m_gripTransform.position;
						Debug.DrawRay(ray.origin, ray.direction, Color.red, 0.1f);
						if (Physics.Raycast(ray, out var hitInfo, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore) && (double)(collider.ClosestPointOnBounds(m_gripTransform.position) - m_gripTransform.position).magnitude > (double)hitInfo.distance * 1.1)
						{
							flag2 = false;
						}
					}
					if (flag2)
					{
						num = sqrMagnitude;
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
			}
			if (dgOut == null && m_useSpherecast)
			{
				return FindTargetWithSpherecast(out dgOut, out collOut);
			}
			return dgOut != null;
		}

		protected bool FindTargetWithSpherecast(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			Ray ray = new Ray(m_gripTransform.position, m_gripTransform.forward);
			int layerMask = ((m_grabObjectsInLayer == -1) ? (-1) : (1 << m_grabObjectsInLayer));
			if (Physics.SphereCast(ray, m_spherecastRadius, out var hitInfo, m_maxGrabDistance, layerMask))
			{
				DistanceGrabbable distanceGrabbable = null;
				Collider collider = null;
				if (hitInfo.collider != null)
				{
					distanceGrabbable = hitInfo.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
					collider = ((distanceGrabbable == null) ? null : hitInfo.collider);
					if ((bool)distanceGrabbable)
					{
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
				if (distanceGrabbable != null && m_preventGrabThroughWalls)
				{
					ray.direction = hitInfo.point - m_gripTransform.position;
					dgOut = distanceGrabbable;
					collOut = collider;
					if (Physics.Raycast(ray, out var hitInfo2, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore))
					{
						DistanceGrabbable distanceGrabbable2 = null;
						if (hitInfo.collider != null)
						{
							distanceGrabbable2 = hitInfo2.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
						}
						if (distanceGrabbable2 != distanceGrabbable && hitInfo2.distance < hitInfo.distance)
						{
							dgOut = null;
							collOut = null;
						}
					}
				}
			}
			return dgOut != null;
		}

		protected override void GrabVolumeEnable(bool enabled)
		{
			if (m_useSpherecast)
			{
				enabled = false;
			}
			base.GrabVolumeEnable(enabled);
		}

		protected override void OffhandGrabbed(OVRGrabbable grabbable)
		{
			base.OffhandGrabbed(grabbable);
		}
	}
	public class GrabManager : MonoBehaviour
	{
		private Collider m_grabVolume;

		public Color OutlineColorInRange;

		public Color OutlineColorHighlighted;

		public Color OutlineColorOutOfRange;

		private void OnTriggerEnter(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = true;
			}
		}

		private void OnTriggerExit(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = false;
			}
		}
	}
	public class GrabbableCrosshair : MonoBehaviour
	{
		public enum CrosshairState
		{
			Disabled,
			Enabled,
			Targeted
		}

		private CrosshairState m_state;

		private Transform m_centerEyeAnchor;

		[SerializeField]
		private GameObject m_targetedCrosshair;

		[SerializeField]
		private GameObject m_enabledCrosshair;

		private void Start()
		{
			m_centerEyeAnchor = GameObject.Find("CenterEyeAnchor").transform;
		}

		public void SetState(CrosshairState cs)
		{
			m_state = cs;
			switch (cs)
			{
			case CrosshairState.Disabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: false);
				break;
			case CrosshairState.Enabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: true);
				break;
			case CrosshairState.Targeted:
				m_targetedCrosshair.SetActive(value: true);
				m_enabledCrosshair.SetActive(value: false);
				break;
			}
		}

		private void Update()
		{
			if (m_state != 0)
			{
				base.transform.LookAt(m_centerEyeAnchor);
			}
		}
	}
	public class PauseOnInputLoss : MonoBehaviour
	{
		private void Start()
		{
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			Time.timeScale = 0f;
		}

		private void OnInputFocusAcquired()
		{
			Time.timeScale = 1f;
		}
	}
	public class BoneCapsuleTriggerLogic : MonoBehaviour
	{
		public InteractableToolTags ToolTags;

		public HashSet<ColliderZone> CollidersTouchingUs = new HashSet<ColliderZone>();

		private List<ColliderZone> _elementsToCleanUp = new List<ColliderZone>();

		private void OnDisable()
		{
			CollidersTouchingUs.Clear();
		}

		private void Update()
		{
			CleanUpDeadColliders();
		}

		private void OnTriggerEnter(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Add(component);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Remove(component);
			}
		}

		private void CleanUpDeadColliders()
		{
			_elementsToCleanUp.Clear();
			foreach (ColliderZone collidersTouchingU in CollidersTouchingUs)
			{
				if (!collidersTouchingU.Collider.gameObject.activeInHierarchy)
				{
					_elementsToCleanUp.Add(collidersTouchingU);
				}
			}
			foreach (ColliderZone item in _elementsToCleanUp)
			{
				CollidersTouchingUs.Remove(item);
			}
		}
	}
	public class ButtonController : Interactable
	{
		public enum ContactTest
		{
			PerpenTest,
			BackwardsPress
		}

		private const float ENTRY_DOT_THRESHOLD = 0.8f;

		private const float PERP_DOT_THRESHOLD = 0.5f;

		[SerializeField]
		private GameObject _proximityZone;

		[SerializeField]
		private GameObject _contactZone;

		[SerializeField]
		private GameObject _actionZone;

		[SerializeField]
		private ContactTest[] _contactTests;

		[SerializeField]
		private Transform _buttonPlaneCenter;

		[SerializeField]
		private bool _makeSureToolIsOnPositiveSide = true;

		[SerializeField]
		private Vector3 _localButtonDirection = Vector3.down;

		[SerializeField]
		private InteractableToolTags[] _allValidToolsTags = new InteractableToolTags[1] { InteractableToolTags.All };

		private int _toolTagsMask;

		private InteractableState _currentButtonState;

		private Dictionary<InteractableTool, InteractableState> _toolToState = new Dictionary<InteractableTool, InteractableState>();

		public override int ValidToolTagsMask => _toolTagsMask;

		public Vector3 LocalButtonDirection => _localButtonDirection;

		protected override void Awake()
		{
			base.Awake();
			InteractableToolTags[] allValidToolsTags = _allValidToolsTags;
			foreach (InteractableToolTags interactableToolTags in allValidToolsTags)
			{
				_toolTagsMask |= (int)interactableToolTags;
			}
			_proximityZoneCollider = _proximityZone.GetComponent<ColliderZone>();
			_contactZoneCollider = _contactZone.GetComponent<ColliderZone>();
			_actionZoneCollider = _actionZone.GetComponent<ColliderZone>();
		}

		private void FireInteractionEventsOnDepth(InteractableCollisionDepth oldDepth, InteractableTool collidingTool, InteractionType interactionType)
		{
			switch (oldDepth)
			{
			case InteractableCollisionDepth.Action:
				OnActionZoneEvent(new ColliderZoneArgs(base.ActionCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Contact:
				OnContactZoneEvent(new ColliderZoneArgs(base.ContactCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Proximity:
				OnProximityZoneEvent(new ColliderZoneArgs(base.ProximityCollider, Time.frameCount, collidingTool, interactionType));
				break;
			}
		}

		public override void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth)
		{
			bool isFarFieldTool = interactableTool.IsFarFieldTool;
			if (!isFarFieldTool && _toolToState.Keys.Count > 0 && !_toolToState.ContainsKey(interactableTool))
			{
				return;
			}
			InteractableState currentButtonState = _currentButtonState;
			Vector3 vector = base.transform.TransformDirection(_localButtonDirection);
			bool validContact = IsValidContact(interactableTool, vector) || interactableTool.IsFarFieldTool;
			bool toolIsInProximity = newCollisionDepth >= InteractableCollisionDepth.Proximity;
			bool flag = newCollisionDepth == InteractableCollisionDepth.Contact;
			bool flag2 = newCollisionDepth == InteractableCollisionDepth.Action;
			bool flag3 = oldCollisionDepth != newCollisionDepth;
			if (flag3)
			{
				FireInteractionEventsOnDepth(oldCollisionDepth, interactableTool, InteractionType.Exit);
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Enter);
			}
			else
			{
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Stay);
			}
			InteractableState interactableState = currentButtonState;
			if (interactableTool.IsFarFieldTool)
			{
				interactableState = (flag ? InteractableState.ContactState : (flag2 ? InteractableState.ActionState : InteractableState.Default));
			}
			else
			{
				Plane plane = new Plane(-vector, _buttonPlaneCenter.position);
				bool onPositiveSideOfInteractable = !_makeSureToolIsOnPositiveSide || plane.GetSide(interactableTool.InteractionPosition);
				interactableState = GetUpcomingStateNearField(currentButtonState, newCollisionDepth, flag2, flag, toolIsInProximity, validContact, onPositiveSideOfInteractable);
			}
			if (interactableState != 0)
			{
				_toolToState[interactableTool] = interactableState;
			}
			else
			{
				_toolToState.Remove(interactableTool);
			}
			if (isFarFieldTool)
			{
				foreach (InteractableState value in _toolToState.Values)
				{
					if (interactableState < value)
					{
						interactableState = value;
					}
				}
			}
			if (currentButtonState != interactableState)
			{
				_currentButtonState = interactableState;
				InteractionType interactionType = ((!flag3) ? InteractionType.Stay : ((newCollisionDepth == InteractableCollisionDepth.None) ? InteractionType.Exit : InteractionType.Enter));
				ColliderZone collider = ((_currentButtonState == InteractableState.ProximityState) ? base.ProximityCollider : ((_currentButtonState == InteractableState.ContactState) ? base.ContactCollider : ((_currentButtonState == InteractableState.ActionState) ? base.ActionCollider : null)));
				if (InteractableStateChanged != null)
				{
					InteractableStateChanged.Invoke(new InteractableStateArgs(this, interactableTool, _currentButtonState, currentButtonState, new ColliderZoneArgs(collider, Time.frameCount, interactableTool, interactionType)));
				}
			}
		}

		private InteractableState GetUpcomingStateNearField(InteractableState oldState, InteractableCollisionDepth newCollisionDepth, bool toolIsInActionZone, bool toolIsInContactZone, bool toolIsInProximity, bool validContact, bool onPositiveSideOfInteractable)
		{
			InteractableState result = oldState;
			switch (oldState)
			{
			case InteractableState.ActionState:
				if (!toolIsInActionZone)
				{
					result = ((!toolIsInContactZone) ? (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default) : InteractableState.ContactState);
				}
				break;
			case InteractableState.ContactState:
				if (newCollisionDepth < InteractableCollisionDepth.Contact)
				{
					result = (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default);
				}
				else if (toolIsInActionZone && validContact && onPositiveSideOfInteractable)
				{
					result = InteractableState.ActionState;
				}
				break;
			case InteractableState.ProximityState:
				if (newCollisionDepth < InteractableCollisionDepth.Proximity)
				{
					result = InteractableState.Default;
				}
				else if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				break;
			case InteractableState.Default:
				if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				else if (toolIsInProximity)
				{
					result = InteractableState.ProximityState;
				}
				break;
			}
			return result;
		}

		private bool IsValidContact(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (_contactTests == null || collidingTool.IsFarFieldTool)
			{
				return true;
			}
			ContactTest[] contactTests = _contactTests;
			foreach (ContactTest contactTest in contactTests)
			{
				if (contactTest == ContactTest.BackwardsPress)
				{
					if (!PassEntryTest(collidingTool, buttonDirection))
					{
						return false;
					}
				}
				else if (!PassPerpTest(collidingTool, buttonDirection))
				{
					return false;
				}
			}
			return true;
		}

		private bool PassEntryTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (Vector3.Dot(collidingTool.Velocity.normalized, buttonDirection) < 0.8f)
			{
				return false;
			}
			return true;
		}

		private bool PassPerpTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			Vector3 vector = collidingTool.ToolTransform.right;
			if (collidingTool.IsRightHandedTool)
			{
				vector = -vector;
			}
			if (Vector3.Dot(vector, buttonDirection) < 0.5f)
			{
				return false;
			}
			return true;
		}
	}
	public class ButtonTriggerZone : MonoBehaviour, ColliderZone
	{
		[SerializeField]
		private GameObject _parentInteractableObj;

		public Collider Collider { get; private set; }

		public Interactable ParentInteractable { get; private set; }

		public InteractableCollisionDepth CollisionDepth
		{
			get
			{
				if (ParentInteractable.ProximityCollider != this)
				{
					if (ParentInteractable.ContactCollider != this)
					{
						if (ParentInteractable.ActionCollider != this)
						{
							return InteractableCollisionDepth.None;
						}
						return InteractableCollisionDepth.Action;
					}
					return InteractableCollisionDepth.Contact;
				}
				return InteractableCollisionDepth.Proximity;
			}
		}

		private void Awake()
		{
			Collider = GetComponent<Collider>();
			ParentInteractable = _parentInteractableObj.GetComponent<Interactable>();
		}
	}
	public interface ColliderZone
	{
		Collider Collider { get; }

		Interactable ParentInteractable { get; }

		InteractableCollisionDepth CollisionDepth { get; }
	}
	public class ColliderZoneArgs : EventArgs
	{
		public readonly ColliderZone Collider;

		public readonly float FrameTime;

		public readonly InteractableTool CollidingTool;

		public readonly InteractionType InteractionT;

		public ColliderZoneArgs(ColliderZone collider, float frameTime, InteractableTool collidingTool, InteractionType interactionType)
		{
			Collider = collider;
			FrameTime = frameTime;
			CollidingTool = collidingTool;
			InteractionT = interactionType;
		}
	}
	public enum InteractionType
	{
		Enter,
		Stay,
		Exit
	}
	public class HandsManager : MonoBehaviour
	{
		public enum HandsVisualMode
		{
			Mesh,
			Skeleton,
			Both
		}

		private const string SKELETON_VISUALIZER_NAME = "SkeletonRenderer";

		[SerializeField]
		private GameObject _leftHand;

		[SerializeField]
		private GameObject _rightHand;

		public HandsVisualMode VisualMode;

		private OVRHand[] _hand = new OVRHand[2];

		private OVRSkeleton[] _handSkeleton = new OVRSkeleton[2];

		private OVRSkeletonRenderer[] _handSkeletonRenderer = new OVRSkeletonRenderer[2];

		private OVRMesh[] _handMesh = new OVRMesh[2];

		private OVRMeshRenderer[] _handMeshRenderer = new OVRMeshRenderer[2];

		private SkinnedMeshRenderer _leftMeshRenderer;

		private SkinnedMeshRenderer _rightMeshRenderer;

		private GameObject _leftSkeletonVisual;

		private GameObject _rightSkeletonVisual;

		private float _currentHandAlpha = 1f;

		private int HandAlphaId = Shader.PropertyToID("_HandAlpha");

		public OVRHand RightHand
		{
			get
			{
				return _hand[1];
			}
			private set
			{
				_hand[1] = value;
			}
		}

		public OVRSkeleton RightHandSkeleton
		{
			get
			{
				return _handSkeleton[1];
			}
			private set
			{
				_handSkeleton[1] = value;
			}
		}

		public OVRSkeletonRenderer RightHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[1];
			}
			private set
			{
				_handSkeletonRenderer[1] = value;
			}
		}

		public OVRMesh RightHandMesh
		{
			get
			{
				return _handMesh[1];
			}
			private set
			{
				_handMesh[1] = value;
			}
		}

		public OVRMeshRenderer RightHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[1];
			}
			private set
			{
				_handMeshRenderer[1] = value;
			}
		}

		public OVRHand LeftHand
		{
			get
			{
				return _hand[0];
			}
			private set
			{
				_hand[0] = value;
			}
		}

		public OVRSkeleton LeftHandSkeleton
		{
			get
			{
				return _handSkeleton[0];
			}
			private set
			{
				_handSkeleton[0] = value;
			}
		}

		public OVRSkeletonRenderer LeftHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[0];
			}
			private set
			{
				_handSkeletonRenderer[0] = value;
			}
		}

		public OVRMesh LeftHandMesh
		{
			get
			{
				return _handMesh[0];
			}
			private set
			{
				_handMesh[0] = value;
			}
		}

		public OVRMeshRenderer LeftHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[0];
			}
			private set
			{
				_handMeshRenderer[0] = value;
			}
		}

		public static HandsManager Instance { get; private set; }

		private void Awake()
		{
			if ((bool)Instance && Instance != this)
			{
				UnityEngine.Object.Destroy(this);
				return;
			}
			Instance = this;
			LeftHand = _leftHand.GetComponent<OVRHand>();
			LeftHandSkeleton = _leftHand.GetComponent<OVRSkeleton>();
			LeftHandSkeletonRenderer = _leftHand.GetComponent<OVRSkeletonRenderer>();
			LeftHandMesh = _leftHand.GetComponent<OVRMesh>();
			LeftHandMeshRenderer = _leftHand.GetComponent<OVRMeshRenderer>();
			RightHand = _rightHand.GetComponent<OVRHand>();
			RightHandSkeleton = _rightHand.GetComponent<OVRSkeleton>();
			RightHandSkeletonRenderer = _rightHand.GetComponent<OVRSkeletonRenderer>();
			RightHandMesh = _rightHand.GetComponent<OVRMesh>();
			RightHandMeshRenderer = _rightHand.GetComponent<OVRMeshRenderer>();
			_leftMeshRenderer = LeftHand.GetComponent<SkinnedMeshRenderer>();
			_rightMeshRenderer = RightHand.GetComponent<SkinnedMeshRenderer>();
			StartCoroutine(FindSkeletonVisualGameObjects());
		}

		private void Update()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
			case HandsVisualMode.Skeleton:
				_currentHandAlpha = 1f;
				break;
			case HandsVisualMode.Both:
				_currentHandAlpha = 0.6f;
				break;
			default:
				_currentHandAlpha = 1f;
				break;
			}
			_rightMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
			_leftMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
		}

		private IEnumerator FindSkeletonVisualGameObjects()
		{
			while (!_leftSkeletonVisual || !_rightSkeletonVisual)
			{
				if (!_leftSkeletonVisual)
				{
					Transform transform = LeftHand.transform.Find("SkeletonRenderer");
					if ((bool)transform)
					{
						_leftSkeletonVisual = transform.gameObject;
					}
				}
				if (!_rightSkeletonVisual)
				{
					Transform transform2 = RightHand.transform.Find("SkeletonRenderer");
					if ((bool)transform2)
					{
						_rightSkeletonVisual = transform2.gameObject;
					}
				}
				yield return null;
			}
			SetToCurrentVisualMode();
		}

		public void SwitchVisualization()
		{
			if ((bool)_leftSkeletonVisual && (bool)_rightSkeletonVisual)
			{
				VisualMode = (HandsVisualMode)((int)(VisualMode + 1) % 3);
				SetToCurrentVisualMode();
			}
		}

		private void SetToCurrentVisualMode()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: false);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: false);
				break;
			case HandsVisualMode.Skeleton:
				RightHandMeshRenderer.enabled = false;
				_rightMeshRenderer.enabled = false;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = false;
				_leftMeshRenderer.enabled = false;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			case HandsVisualMode.Both:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			}
		}

		public static List<OVRBoneCapsule> GetCapsulesPerBone(OVRSkeleton skeleton, OVRSkeleton.BoneId boneId)
		{
			List<OVRBoneCapsule> list = new List<OVRBoneCapsule>();
			IList<OVRBoneCapsule> capsules = skeleton.Capsules;
			for (int i = 0; i < capsules.Count; i++)
			{
				if (capsules[i].BoneIndex == (short)boneId)
				{
					list.Add(capsules[i]);
				}
			}
			return list;
		}

		public bool IsInitialized()
		{
			if ((bool)LeftHandSkeleton && LeftHandSkeleton.IsInitialized && (bool)RightHandSkeleton && RightHandSkeleton.IsInitialized && (bool)LeftHandMesh && LeftHandMesh.IsInitialized && (bool)RightHandMesh)
			{
				return RightHandMesh.IsInitialized;
			}
			return false;
		}
	}
	public abstract class Interactable : MonoBehaviour
	{
		[Serializable]
		public class InteractableStateArgsEvent : UnityEvent<InteractableStateArgs>
		{
		}

		protected ColliderZone _proximityZoneCollider;

		protected ColliderZone _contactZoneCollider;

		protected ColliderZone _actionZoneCollider;

		public InteractableStateArgsEvent InteractableStateChanged;

		public ColliderZone ProximityCollider => _proximityZoneCollider;

		public ColliderZone ContactCollider => _contactZoneCollider;

		public ColliderZone ActionCollider => _actionZoneCollider;

		public virtual int ValidToolTagsMask => -1;

		public event Action<ColliderZoneArgs> ProximityZoneEvent;

		public event Action<ColliderZoneArgs> ContactZoneEvent;

		public event Action<ColliderZoneArgs> ActionZoneEvent;

		protected virtual void OnProximityZoneEvent(ColliderZoneArgs args)
		{
			if (this.ProximityZoneEvent != null)
			{
				this.ProximityZoneEvent(args);
			}
		}

		protected virtual void OnContactZoneEvent(ColliderZoneArgs args)
		{
			if (this.ContactZoneEvent != null)
			{
				this.ContactZoneEvent(args);
			}
		}

		protected virtual void OnActionZoneEvent(ColliderZoneArgs args)
		{
			if (this.ActionZoneEvent != null)
			{
				this.ActionZoneEvent(args);
			}
		}

		public abstract void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth);

		protected virtual void Awake()
		{
			InteractableRegistry.RegisterInteractable(this);
		}

		protected virtual void OnDestroy()
		{
			InteractableRegistry.UnregisterInteractable(this);
		}
	}
	public enum InteractableCollisionDepth
	{
		None,
		Proximity,
		Contact,
		Action
	}
	public enum InteractableState
	{
		Default,
		ProximityState,
		ContactState,
		ActionState
	}
	public class InteractableStateArgs : EventArgs
	{
		public readonly Interactable Interactable;

		public readonly InteractableTool Tool;

		public readonly InteractableState OldInteractableState;

		public readonly InteractableState NewInteractableState;

		public readonly ColliderZoneArgs ColliderArgs;

		public InteractableStateArgs(Interactable interactable, InteractableTool tool, InteractableState newInteractableState, InteractableState oldState, ColliderZoneArgs colliderArgs)
		{
			Interactable = interactable;
			Tool = tool;
			NewInteractableState = newInteractableState;
			OldInteractableState = oldState;
			ColliderArgs = colliderArgs;
		}
	}
	public class InteractableRegistry : MonoBehaviour
	{
		public static HashSet<Interactable> _interactables = new HashSet<Interactable>();

		public static HashSet<Interactable> Interactables => _interactables;

		public static void RegisterInteractable(Interactable interactable)
		{
			Interactables.Add(interactable);
		}

		public static void UnregisterInteractable(Interactable interactable)
		{
			Interactables.Remove(interactable);
		}
	}
	public class InteractableToolsCreator : MonoBehaviour
	{
		[SerializeField]
		private Transform[] LeftHandTools;

		[SerializeField]
		private Transform[] RightHandTools;

		private void Awake()
		{
			if (LeftHandTools != null && LeftHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(LeftHandTools, isRightHand: false));
			}
			if (RightHandTools != null && RightHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(RightHandTools, isRightHand: true));
			}
		}

		private IEnumerator AttachToolsToHands(Transform[] toolObjects, bool isRightHand)
		{
			HandsManager handsManagerObj;
			while (true)
			{
				HandsManager instance;
				handsManagerObj = (instance = HandsManager.Instance);
				if (!(instance == null) && handsManagerObj.IsInitialized())
				{
					break;
				}
				yield return null;
			}
			HashSet<Transform> hashSet = new HashSet<Transform>();
			foreach (Transform transform in toolObjects)
			{
				hashSet.Add(transform.transform);
			}
			foreach (Transform toolObject in hashSet)
			{
				OVRSkeleton handSkeletonToAttachTo = (isRightHand ? handsManagerObj.RightHandSkeleton : handsManagerObj.LeftHandSkeleton);
				while (handSkeletonToAttachTo == null || handSkeletonToAttachTo.Bones == null)
				{
					yield return null;
				}
				AttachToolToHandTransform(toolObject, isRightHand);
			}
		}

		private void AttachToolToHandTransform(Transform tool, bool isRightHanded)
		{
			Transform obj = UnityEngine.Object.Instantiate(tool).transform;
			obj.localPosition = Vector3.zero;
			InteractableTool component = obj.GetComponent<InteractableTool>();
			component.IsRightHandedTool = isRightHanded;
			component.Initialize();
		}
	}
	public class InteractableToolsInputRouter : MonoBehaviour
	{
		private static InteractableToolsInputRouter _instance;

		private bool _leftPinch;

		private bool _rightPinch;

		private HashSet<InteractableTool> _leftHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _leftHandFarTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandFarTools = new HashSet<InteractableTool>();

		public static InteractableToolsInputRouter Instance
		{
			get
			{
				if (_instance == null)
				{
					InteractableToolsInputRouter[] array = UnityEngine.Object.FindObjectsOfType<InteractableToolsInputRouter>();
					if (array.Length != 0)
					{
						_instance = array[0];
						for (int i = 1; i < array.Length; i++)
						{
							UnityEngine.Object.Destroy(array[i].gameObject);
						}
					}
				}
				return _instance;
			}
		}

		public void RegisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Add(interactableTool);
				}
				else
				{
					_rightHandNearTools.Add(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Add(interactableTool);
			}
			else
			{
				_leftHandNearTools.Add(interactableTool);
			}
		}

		public void UnregisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Remove(interactableTool);
				}
				else
				{
					_rightHandNearTools.Remove(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Remove(interactableTool);
			}
			else
			{
				_leftHandNearTools.Remove(interactableTool);
			}
		}

		private void Update()
		{
			if (HandsManager.Instance.IsInitialized())
			{
				bool flag = HandsManager.Instance.LeftHand.IsTracked && HandsManager.Instance.LeftHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool flag2 = HandsManager.Instance.RightHand.IsTracked && HandsManager.Instance.RightHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool isPointerPoseValid = HandsManager.Instance.LeftHand.IsPointerPoseValid;
				bool isPointerPoseValid2 = HandsManager.Instance.RightHand.IsPointerPoseValid;
				bool flag3 = UpdateToolsAndEnableState(_leftHandNearTools, flag);
				UpdateToolsAndEnableState(_leftHandFarTools, !flag3 && flag && isPointerPoseValid);
				bool flag4 = UpdateToolsAndEnableState(_rightHandNearTools, flag2);
				UpdateToolsAndEnableState(_rightHandFarTools, !flag4 && flag2 && isPointerPoseValid2);
			}
		}

		private bool UpdateToolsAndEnableState(HashSet<InteractableTool> tools, bool toolsAreEnabledThisFrame)
		{
			bool result = UpdateTools(tools, !toolsAreEnabledThisFrame);
			ToggleToolsEnableState(tools, toolsAreEnabledThisFrame);
			return result;
		}

		private bool UpdateTools(HashSet<InteractableTool> tools, bool resetCollisionData = false)
		{
			bool flag = false;
			foreach (InteractableTool tool in tools)
			{
				List<InteractableCollisionInfo> nextIntersectingObjects = tool.GetNextIntersectingObjects();
				if (nextIntersectingObjects.Count > 0 && !resetCollisionData)
				{
					if (!flag)
					{
						flag = nextIntersectingObjects.Count > 0;
					}
					tool.UpdateCurrentCollisionsBasedOnDepth();
					if (tool.IsFarFieldTool)
					{
						KeyValuePair<Interactable, InteractableCollisionInfo> firstCurrentCollisionInfo = tool.GetFirstCurrentCollisionInfo();
						if (tool.ToolInputState == ToolInputState.PrimaryInputUp)
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ActionCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Action;
						}
						else
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ContactCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Contact;
						}
						tool.FocusOnInteractable(firstCurrentCollisionInfo.Key, firstCurrentCollisionInfo.Value.InteractableCollider);
					}
				}
				else
				{
					tool.DeFocus();
					tool.ClearAllCurrentCollisionInfos();
				}
				tool.UpdateLatestCollisionData();
			}
			return flag;
		}

		private void ToggleToolsEnableState(HashSet<InteractableTool> tools, bool enableState)
		{
			foreach (InteractableTool tool in tools)
			{
				if (tool.EnableState != enableState)
				{
					tool.EnableState = enableState;
				}
			}
		}
	}
	public class FingerTipPokeTool : InteractableTool
	{
		private const int NUM_VELOCITY_FRAMES = 10;

		[SerializeField]
		private FingerTipPokeToolView _fingerTipPokeToolView;

		[SerializeField]
		private OVRPlugin.HandFinger _fingerToFollow = OVRPlugin.HandFinger.Index;

		private Vector3[] _velocityFrames;

		private int _currVelocityFrame;

		private bool _sampledMaxFramesAlready;

		private Vector3 _position;

		private BoneCapsuleTriggerLogic[] _boneCapsuleTriggerLogic;

		private float _lastScale = 1f;

		private bool _isInitialized;

		private OVRBoneCapsule _capsuleToTrack;

		public override InteractableToolTags ToolTags => InteractableToolTags.Poke;

		public override ToolInputState ToolInputState => ToolInputState.Inactive;

		public override bool IsFarFieldTool => false;

		public override bool EnableState
		{
			get
			{
				return _fingerTipPokeToolView.gameObject.activeSelf;
			}
			set
			{
				_fingerTipPokeToolView.gameObject.SetActive(value);
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_fingerTipPokeToolView.InteractableTool = this;
			_velocityFrames = new Vector3[10];
			Array.Clear(_velocityFrames, 0, 10);
			StartCoroutine(AttachTriggerLogic());
		}

		private IEnumerator AttachTriggerLogic()
		{
			while (!HandsManager.Instance || !HandsManager.Instance.IsInitialized())
			{
				yield return null;
			}
			OVRSkeleton skeleton = (base.IsRightHandedTool ? HandsManager.Instance.RightHandSkeleton : HandsManager.Instance.LeftHandSkeleton);
			OVRSkeleton.BoneId boneId = _fingerToFollow switch
			{
				OVRPlugin.HandFinger.Thumb => OVRSkeleton.BoneId.Hand_Thumb3, 
				OVRPlugin.HandFinger.Index => OVRSkeleton.BoneId.Hand_Index3, 
				OVRPlugin.HandFinger.Middle => OVRSkeleton.BoneId.Hand_Middle3, 
				OVRPlugin.HandFinger.Ring => OVRSkeleton.BoneId.Hand_Ring3, 
				_ => OVRSkeleton.BoneId.Hand_Pinky3, 
			};
			List<BoneCapsuleTriggerLogic> list = new List<BoneCapsuleTriggerLogic>();
			List<OVRBoneCapsule> capsulesPerBone = HandsManager.GetCapsulesPerBone(skeleton, boneId);
			foreach (OVRBoneCapsule item in capsulesPerBone)
			{
				BoneCapsuleTriggerLogic boneCapsuleTriggerLogic = item.CapsuleRigidbody.gameObject.AddComponent<BoneCapsuleTriggerLogic>();
				item.CapsuleCollider.isTrigger = true;
				boneCapsuleTriggerLogic.ToolTags = ToolTags;
				list.Add(boneCapsuleTriggerLogic);
			}
			_boneCapsuleTriggerLogic = list.ToArray();
			if (capsulesPerBone.Count > 0)
			{
				_capsuleToTrack = capsulesPerBone[0];
			}
			_isInitialized = true;
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _isInitialized && _capsuleToTrack != null)
			{
				float handScale = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand).HandScale;
				Transform transform = _capsuleToTrack.CapsuleCollider.transform;
				Vector3 right = transform.right;
				Vector3 vector = transform.position + _capsuleToTrack.CapsuleCollider.height * 0.5f * right;
				Vector3 vector2 = handScale * _fingerTipPokeToolView.SphereRadius * right;
				Vector3 position = vector + vector2;
				base.transform.position = position;
				base.transform.rotation = transform.rotation;
				base.InteractionPosition = vector;
				UpdateAverageVelocity();
				CheckAndUpdateScale();
			}
		}

		private void UpdateAverageVelocity()
		{
			Vector3 position = _position;
			Vector3 position2 = base.transform.position;
			Vector3 vector = (position2 - position) / Time.deltaTime;
			_position = position2;
			_velocityFrames[_currVelocityFrame] = vector;
			_currVelocityFrame = (_currVelocityFrame + 1) % 10;
			base.Velocity = Vector3.zero;
			if (!_sampledMaxFramesAlready && _currVelocityFrame == 9)
			{
				_sampledMaxFramesAlready = true;
			}
			int num = (_sampledMaxFramesAlready ? 10 : (_currVelocityFrame + 1));
			for (int i = 0; i < num; i++)
			{
				base.Velocity += _velocityFrames[i];
			}
			base.Velocity /= (float)num;
		}

		private void CheckAndUpdateScale()
		{
			float num = (base.IsRightHandedTool ? HandsManager.Instance.RightHand.HandScale : HandsManager.Instance.LeftHand.HandScale);
			if (Mathf.Abs(num - _lastScale) > Mathf.Epsilon)
			{
				base.transform.localScale = new Vector3(num, num, num);
				_lastScale = num;
			}
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			_currentIntersectingObjects.Clear();
			BoneCapsuleTriggerLogic[] boneCapsuleTriggerLogic = _boneCapsuleTriggerLogic;
			for (int i = 0; i < boneCapsuleTriggerLogic.Length; i++)
			{
				foreach (ColliderZone collidersTouchingU in boneCapsuleTriggerLogic[i].CollidersTouchingUs)
				{
					_currentIntersectingObjects.Add(new InteractableCollisionInfo(collidersTouchingU, collidersTouchingU.CollisionDepth, this));
				}
			}
			return _currentIntersectingObjects;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
		}

		public override void DeFocus()
		{
		}
	}
	public class FingerTipPokeToolView : MonoBehaviour, InteractableToolView
	{
		[SerializeField]
		private MeshRenderer _sphereMeshRenderer;

		public InteractableTool InteractableTool { get; set; }

		public bool EnableState
		{
			get
			{
				return _sphereMeshRenderer.enabled;
			}
			set
			{
				_sphereMeshRenderer.enabled = value;
			}
		}

		public bool ToolActivateState { get; set; }

		public float SphereRadius { get; private set; }

		private void Awake()
		{
			SphereRadius = _sphereMeshRenderer.transform.localScale.z * 0.5f;
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
		}
	}
	[Flags]
	public enum InteractableToolTags
	{
		None = 0,
		Ray = 1,
		Poke = 4,
		All = -1
	}
	public enum ToolInputState
	{
		Inactive,
		PrimaryInputDown,
		PrimaryInputDownStay,
		PrimaryInputUp
	}
	public class InteractableCollisionInfo
	{
		public ColliderZone InteractableCollider;

		public InteractableCollisionDepth CollisionDepth;

		public InteractableTool CollidingTool;

		public InteractableCollisionInfo(ColliderZone collider, InteractableCollisionDepth collisionDepth, InteractableTool collidingTool)
		{
			InteractableCollider = collider;
			CollisionDepth = collisionDepth;
			CollidingTool = collidingTool;
		}
	}
	public abstract class InteractableTool : MonoBehaviour
	{
		protected List<InteractableCollisionInfo> _currentIntersectingObjects = new List<InteractableCollisionInfo>();

		private List<Interactable> _addedInteractables = new List<Interactable>();

		private List<Interactable> _removedInteractables = new List<Interactable>();

		private List<Interactable> _remainingInteractables = new List<Interactable>();

		private Dictionary<Interactable, InteractableCollisionInfo> _currInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		private Dictionary<Interactable, InteractableCollisionInfo> _prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		public Transform ToolTransform => base.transform;

		public bool IsRightHandedTool { get; set; }

		public abstract InteractableToolTags ToolTags { get; }

		public abstract ToolInputState ToolInputState { get; }

		public abstract bool IsFarFieldTool { get; }

		public Vector3 Velocity { get; protected set; }

		public Vector3 InteractionPosition { get; protected set; }

		public abstract bool EnableState { get; set; }

		public List<InteractableCollisionInfo> GetCurrentIntersectingObjects()
		{
			return _currentIntersectingObjects;
		}

		public abstract List<InteractableCollisionInfo> GetNextIntersectingObjects();

		public abstract void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone);

		public abstract void DeFocus();

		public abstract void Initialize();

		public KeyValuePair<Interactable, InteractableCollisionInfo> GetFirstCurrentCollisionInfo()
		{
			return _currInteractableToCollisionInfos.First();
		}

		public void ClearAllCurrentCollisionInfos()
		{
			_currInteractableToCollisionInfos.Clear();
		}

		public virtual void UpdateCurrentCollisionsBasedOnDepth()
		{
			_currInteractableToCollisionInfos.Clear();
			foreach (InteractableCollisionInfo currentIntersectingObject in _currentIntersectingObjects)
			{
				Interactable parentInteractable = currentIntersectingObject.InteractableCollider.ParentInteractable;
				InteractableCollisionDepth collisionDepth = currentIntersectingObject.CollisionDepth;
				InteractableCollisionInfo value = null;
				if (!_currInteractableToCollisionInfos.TryGetValue(parentInteractable, out value))
				{
					_currInteractableToCollisionInfos[parentInteractable] = currentIntersectingObject;
				}
				else if (value.CollisionDepth < collisionDepth)
				{
					value.InteractableCollider = currentIntersectingObject.InteractableCollider;
					value.CollisionDepth = collisionDepth;
				}
			}
		}

		public virtual void UpdateLatestCollisionData()
		{
			_addedInteractables.Clear();
			_removedInteractables.Clear();
			_remainingInteractables.Clear();
			foreach (Interactable key in _currInteractableToCollisionInfos.Keys)
			{
				if (!_prevInteractableToCollisionInfos.ContainsKey(key))
				{
					_addedInteractables.Add(key);
				}
				else
				{
					_remainingInteractables.Add(key);
				}
			}
			foreach (Interactable key2 in _prevInteractableToCollisionInfos.Keys)
			{
				if (!_currInteractableToCollisionInfos.ContainsKey(key2))
				{
					_removedInteractables.Add(key2);
				}
			}
			foreach (Interactable removedInteractable in _removedInteractables)
			{
				removedInteractable.UpdateCollisionDepth(this, _prevInteractableToCollisionInfos[removedInteractable].CollisionDepth, InteractableCollisionDepth.None);
			}
			foreach (Interactable addedInteractable in _addedInteractables)
			{
				InteractableCollisionDepth collisionDepth = _currInteractableToCollisionInfos[addedInteractable].CollisionDepth;
				addedInteractable.UpdateCollisionDepth(this, InteractableCollisionDepth.None, collisionDepth);
			}
			foreach (Interactable remainingInteractable in _remainingInteractables)
			{
				InteractableCollisionDepth collisionDepth2 = _currInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				InteractableCollisionDepth collisionDepth3 = _prevInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				remainingInteractable.UpdateCollisionDepth(this, collisionDepth3, collisionDepth2);
			}
			_prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>(_currInteractableToCollisionInfos);
		}
	}
	public interface InteractableToolView
	{
		InteractableTool InteractableTool { get; }

		bool EnableState { get; set; }

		bool ToolActivateState { get; set; }

		void SetFocusedInteractable(Interactable interactable);
	}
	public class PinchStateModule
	{
		private enum PinchState
		{
			None,
			PinchDown,
			PinchStay,
			PinchUp
		}

		private const float PINCH_STRENGTH_THRESHOLD = 1f;

		private PinchState _currPinchState;

		private Interactable _firstFocusedInteractable;

		public bool PinchUpAndDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchUp)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchSteadyOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchStay)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchDown)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public PinchStateModule()
		{
			_currPinchState = PinchState.None;
			_firstFocusedInteractable = null;
		}

		public void UpdateState(OVRHand hand, Interactable currFocusedInteractable)
		{
			float fingerPinchStrength = hand.GetFingerPinchStrength(OVRHand.HandFinger.Index);
			bool flag = Mathf.Abs(1f - fingerPinchStrength) < Mathf.Epsilon;
			switch (_currPinchState)
			{
			case PinchState.PinchUp:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					if (currFocusedInteractable != _firstFocusedInteractable)
					{
						_firstFocusedInteractable = null;
					}
				}
				else
				{
					_currPinchState = PinchState.None;
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchStay:
				if (!flag)
				{
					_currPinchState = PinchState.PinchUp;
				}
				if (currFocusedInteractable != _firstFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchDown:
				_currPinchState = (flag ? PinchState.PinchStay : PinchState.PinchUp);
				if (_firstFocusedInteractable != currFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			default:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					_firstFocusedInteractable = currFocusedInteractable;
				}
				break;
			}
		}
	}
	public class RayTool : InteractableTool
	{
		private const float MINIMUM_RAY_CAST_DISTANCE = 0.8f;

		private const float COLLIDER_RADIUS = 0.01f;

		private const int NUM_MAX_PRIMARY_HITS = 10;

		private const int NUM_MAX_SECONDARY_HITS = 25;

		private const int NUM_COLLIDERS_TO_TEST = 20;

		[SerializeField]
		private RayToolView _rayToolView;

		[Range(0f, 45f)]
		[SerializeField]
		private float _coneAngleDegrees = 20f;

		[SerializeField]
		private float _farFieldMaxDistance = 5f;

		private PinchStateModule _pinchStateModule = new PinchStateModule();

		private Interactable _focusedInteractable;

		private Collider[] _collidersOverlapped = new Collider[20];

		private Interactable _currInteractableCastedAgainst;

		private float _coneAngleReleaseDegrees;

		private RaycastHit[] _primaryHits = new RaycastHit[10];

		private Collider[] _secondaryOverlapResults = new Collider[25];

		private bool _initialized;

		public override InteractableToolTags ToolTags => InteractableToolTags.Ray;

		public override ToolInputState ToolInputState
		{
			get
			{
				if (_pinchStateModule.PinchDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDown;
				}
				if (_pinchStateModule.PinchSteadyOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDownStay;
				}
				if (_pinchStateModule.PinchUpAndDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputUp;
				}
				return ToolInputState.Inactive;
			}
		}

		public override bool IsFarFieldTool => true;

		public override bool EnableState
		{
			get
			{
				return _rayToolView.EnableState;
			}
			set
			{
				_rayToolView.EnableState = value;
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_rayToolView.InteractableTool = this;
			_coneAngleReleaseDegrees = _coneAngleDegrees * 1.2f;
			_initialized = true;
		}

		private void OnDestroy()
		{
			if (InteractableToolsInputRouter.Instance != null)
			{
				InteractableToolsInputRouter.Instance.UnregisterInteractableTool(this);
			}
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _initialized)
			{
				OVRHand oVRHand = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand);
				Transform pointerPose = oVRHand.PointerPose;
				base.transform.position = pointerPose.position;
				base.transform.rotation = pointerPose.rotation;
				Vector3 interactionPosition = base.InteractionPosition;
				Vector3 position = base.transform.position;
				base.Velocity = (position - interactionPosition) / Time.deltaTime;
				base.InteractionPosition = position;
				_pinchStateModule.UpdateState(oVRHand, _focusedInteractable);
				_rayToolView.ToolActivateState = _pinchStateModule.PinchSteadyOnFocusedObject || _pinchStateModule.PinchDownOnFocusedObject;
			}
		}

		private Vector3 GetRayCastOrigin()
		{
			return base.transform.position + 0.8f * base.transform.forward;
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			if (!_initialized)
			{
				return _currentIntersectingObjects;
			}
			if (_currInteractableCastedAgainst != null && HasRayReleasedInteractable(_currInteractableCastedAgainst))
			{
				_currInteractableCastedAgainst = null;
			}
			if (_currInteractableCastedAgainst == null)
			{
				_currentIntersectingObjects.Clear();
				_currInteractableCastedAgainst = FindTargetInteractable();
				if (_currInteractableCastedAgainst != null)
				{
					int num = Physics.OverlapSphereNonAlloc(_currInteractableCastedAgainst.transform.position, 0.01f, _collidersOverlapped);
					for (int i = 0; i < num; i++)
					{
						ColliderZone component = _collidersOverlapped[i].GetComponent<ColliderZone>();
						if (component != null)
						{
							Interactable parentInteractable = component.ParentInteractable;
							if (!(parentInteractable == null) && !(parentInteractable != _currInteractableCastedAgainst))
							{
								InteractableCollisionInfo item = new InteractableCollisionInfo(component, component.CollisionDepth, this);
								_currentIntersectingObjects.Add(item);
							}
						}
					}
					if (_currentIntersectingObjects.Count == 0)
					{
						_currInteractableCastedAgainst = null;
					}
				}
			}
			return _currentIntersectingObjects;
		}

		private bool HasRayReleasedInteractable(Interactable focusedInteractable)
		{
			Vector3 position = base.transform.position;
			Vector3 forward = base.transform.forward;
			float num = Mathf.Cos(_coneAngleReleaseDegrees * ((float)Math.PI / 180f));
			Vector3 lhs = focusedInteractable.transform.position - position;
			lhs.Normalize();
			return Vector3.Dot(lhs, forward) < num;
		}

		private Interactable FindTargetInteractable()
		{
			Vector3 rayCastOrigin = GetRayCastOrigin();
			Vector3 forward = base.transform.forward;
			Interactable interactable = null;
			interactable = FindPrimaryRaycastHit(rayCastOrigin, forward);
			if (interactable == null)
			{
				interactable = FindInteractableViaConeTest(rayCastOrigin, forward);
			}
			return interactable;
		}

		private Interactable FindPrimaryRaycastHit(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			int num = Physics.RaycastNonAlloc(new Ray(rayOrigin, rayDirection), _primaryHits, float.PositiveInfinity);
			float num2 = 0f;
			for (int i = 0; i < num; i++)
			{
				RaycastHit raycastHit = _primaryHits[i];
				ColliderZone component = raycastHit.transform.GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					float magnitude = (parentInteractable.transform.position - rayOrigin).magnitude;
					if (interactable == null || magnitude < num2)
					{
						interactable = parentInteractable;
						num2 = magnitude;
					}
				}
			}
			return interactable;
		}

		private Interactable FindInteractableViaConeTest(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			float num = 0f;
			float num2 = Mathf.Cos(_coneAngleDegrees * ((float)Math.PI / 180f));
			float num3 = Mathf.Tan((float)Math.PI / 180f * _coneAngleDegrees * 0.5f) * _farFieldMaxDistance;
			int num4 = Physics.OverlapBoxNonAlloc(rayOrigin + rayDirection * _farFieldMaxDistance * 0.5f, new Vector3(num3, num3, _farFieldMaxDistance * 0.5f), _secondaryOverlapResults, base.transform.rotation);
			for (int i = 0; i < num4; i++)
			{
				ColliderZone component = _secondaryOverlapResults[i].GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					Vector3 lhs = parentInteractable.transform.position - rayOrigin;
					float magnitude = lhs.magnitude;
					lhs /= magnitude;
					if (!(Vector3.Dot(lhs, rayDirection) < num2) && (interactable == null || magnitude < num))
					{
						interactable = parentInteractable;
						num = magnitude;
					}
				}
			}
			return interactable;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
			_rayToolView.SetFocusedInteractable(focusedInteractable);
			_focusedInteractable = focusedInteractable;
		}

		public override void DeFocus()
		{
			_rayToolView.SetFocusedInteractable(null);
			_focusedInteractable = null;
		}
	}
	public class RayToolView : MonoBehaviour, InteractableToolView
	{
		private const int NUM_RAY_LINE_POSITIONS = 25;

		private const float DEFAULT_RAY_CAST_DISTANCE = 3f;

		[SerializeField]
		private Transform _targetTransform;

		[SerializeField]
		private LineRenderer _lineRenderer;

		private bool _toolActivateState;

		private Transform _focusedTransform;

		private Vector3[] linePositions = new Vector3[25];

		private Gradient _oldColorGradient;

		private Gradient _highLightColorGradient;

		public bool EnableState
		{
			get
			{
				return _lineRenderer.enabled;
			}
			set
			{
				_targetTransform.gameObject.SetActive(value);
				_lineRenderer.enabled = value;
			}
		}

		public bool ToolActivateState
		{
			get
			{
				return _toolActivateState;
			}
			set
			{
				_toolActivateState = value;
				_lineRenderer.colorGradient = (_toolActivateState ? _highLightColorGradient : _oldColorGradient);
			}
		}

		public InteractableTool InteractableTool { get; set; }

		private void Awake()
		{
			_lineRenderer.positionCount = 25;
			_oldColorGradient = _lineRenderer.colorGradient;
			_highLightColorGradient = new Gradient();
			_highLightColorGradient.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 0f),
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(1f, 0f),
				new GradientAlphaKey(1f, 1f)
			});
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
			if (interactable == null)
			{
				_focusedTransform = null;
			}
			else
			{
				_focusedTransform = interactable.transform;
			}
		}

		private void Update()
		{
			Vector3 position = InteractableTool.ToolTransform.position;
			Vector3 forward = InteractableTool.ToolTransform.forward;
			Vector3 vector = ((_focusedTransform != null) ? _focusedTransform.position : (position + forward * 3f));
			float magnitude = (vector - position).magnitude;
			Vector3 p = position;
			Vector3 p2 = position + forward * magnitude * 0.3333333f;
			Vector3 p3 = position + forward * magnitude * (2f / 3f);
			Vector3 p4 = vector;
			for (int i = 0; i < 25; i++)
			{
				linePositions[i] = GetPointOnBezierCurve(p, p2, p3, p4, (float)i / 25f);
			}
			_lineRenderer.SetPositions(linePositions);
			_targetTransform.position = vector;
		}

		public static Vector3 GetPointOnBezierCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return num * num2 * p0 + 3f * num2 * t * p1 + 3f * num * num3 * p2 + t * num3 * p3;
		}
	}
	public class DistanceGrabberSample : MonoBehaviour
	{
		private bool useSpherecast;

		private bool allowGrabThroughWalls;

		[SerializeField]
		private DistanceGrabber[] m_grabbers;

		public bool UseSpherecast
		{
			get
			{
				return useSpherecast;
			}
			set
			{
				useSpherecast = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].UseSpherecast = useSpherecast;
				}
			}
		}

		public bool AllowGrabThroughWalls
		{
			get
			{
				return allowGrabThroughWalls;
			}
			set
			{
				allowGrabThroughWalls = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].m_preventGrabThroughWalls = !allowGrabThroughWalls;
				}
			}
		}

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("Distance Grab Sample");
			DebugUIBuilder.instance.AddToggle("Use Spherecasting", ToggleSphereCasting, useSpherecast);
			DebugUIBuilder.instance.AddToggle("Grab Through Walls", ToggleGrabThroughWalls, allowGrabThroughWalls);
			DebugUIBuilder.instance.Show();
			float displayFrequency = OVRManager.display.displayFrequency;
			if (displayFrequency > 0.1f)
			{
				Debug.Log("Setting Time.fixedDeltaTime to: " + 1f / displayFrequency);
				Time.fixedDeltaTime = 1f / displayFrequency;
			}
		}

		public void ToggleSphereCasting(Toggle t)
		{
			UseSpherecast = !UseSpherecast;
		}

		public void ToggleGrabThroughWalls(Toggle t)
		{
			AllowGrabThroughWalls = !AllowGrabThroughWalls;
		}
	}
	public class ControllerBoxController : MonoBehaviour
	{
		[SerializeField]
		private TrainLocomotive _locomotive;

		[SerializeField]
		private CowController _cowController;

		private void Awake()
		{
		}

		public void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.StartStopStateChanged();
			}
		}

		public void DecreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.DecreaseSpeedStateChanged();
			}
		}

		public void IncreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.IncreaseSpeedStateChanged();
			}
		}

		public void SmokeButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.SmokeButtonStateChanged();
			}
		}

		public void WhistleButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.WhistleButtonStateChanged();
			}
		}

		public void ReverseButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.ReverseButtonStateChanged();
			}
		}

		public void SwitchVisualization(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				HandsManager.Instance.SwitchVisualization();
			}
		}

		public void GoMoo(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_cowController.GoMooCowGo();
			}
		}
	}
	public class CowController : MonoBehaviour
	{
		[SerializeField]
		private Animation _cowAnimation;

		[SerializeField]
		private AudioSource _mooCowAudioSource;

		private void Start()
		{
		}

		public void PlayMooSound()
		{
			_mooCowAudioSource.timeSamples = 0;
			_mooCowAudioSource.Play();
		}

		public void GoMooCowGo()
		{
			_cowAnimation.Rewind();
			_cowAnimation.Play();
		}
	}
	public class PanelHMDFollower : MonoBehaviour
	{
		private const float TOTAL_DURATION = 3f;

		private const float HMD_MOVEMENT_THRESHOLD = 0.3f;

		[SerializeField]
		private float _maxDistance = 0.3f;

		[SerializeField]
		private float _minDistance = 0.05f;

		[SerializeField]
		private float _minZDistance = 0.05f;

		private OVRCameraRig _cameraRig;

		private Vector3 _panelInitialPosition = Vector3.zero;

		private Coroutine _coroutine;

		private Vector3 _prevPos = Vector3.zero;

		private Vector3 _lastMovedToPos = Vector3.zero;

		private void Awake()
		{
			_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			_panelInitialPosition = base.transform.position;
		}

		private void Update()
		{
			Vector3 position = _cameraRig.centerEyeAnchor.position;
			_ = base.transform.position;
			float num = Vector3.Distance(position, _lastMovedToPos);
			float num2 = (_cameraRig.centerEyeAnchor.position - _prevPos).magnitude / Time.deltaTime;
			Vector3 vector = base.transform.position - position;
			float magnitude = vector.magnitude;
			if ((num > _maxDistance || _minZDistance > vector.z || _minDistance > magnitude) && num2 < 0.3f && _coroutine == null && _coroutine == null)
			{
				_coroutine = StartCoroutine(LerpToHMD());
			}
			_prevPos = _cameraRig.centerEyeAnchor.position;
		}

		private Vector3 CalculateIdealAnchorPosition()
		{
			return _cameraRig.centerEyeAnchor.position + _panelInitialPosition;
		}

		private IEnumerator LerpToHMD()
		{
			Vector3 newPanelPosition = CalculateIdealAnchorPosition();
			_lastMovedToPos = _cameraRig.centerEyeAnchor.position;
			float startTime = Time.time;
			float endTime = Time.time + 3f;
			while (Time.time < endTime)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, newPanelPosition, (Time.time - startTime) / 3f);
				yield return null;
			}
			base.transform.position = newPanelPosition;
			_coroutine = null;
		}
	}
	public class SelectionCylinder : MonoBehaviour
	{
		public enum SelectionState
		{
			Off,
			Selected,
			Highlighted
		}

		[SerializeField]
		private MeshRenderer _selectionMeshRenderer;

		private static int _colorId = Shader.PropertyToID("_Color");

		private Material[] _selectionMaterials;

		private Color[] _defaultSelectionColors;

		private Color[] _highlightColors;

		private SelectionState _currSelectionState;

		public SelectionState CurrSelectionState
		{
			get
			{
				return _currSelectionState;
			}
			set
			{
				SelectionState currSelectionState = _currSelectionState;
				_currSelectionState = value;
				if (currSelectionState != _currSelectionState)
				{
					if (_currSelectionState > SelectionState.Off)
					{
						_selectionMeshRenderer.enabled = true;
						AffectSelectionColor((_currSelectionState == SelectionState.Selected) ? _defaultSelectionColors : _highlightColors);
					}
					else
					{
						_selectionMeshRenderer.enabled = false;
					}
				}
			}
		}

		private void Awake()
		{
			_selectionMaterials = _selectionMeshRenderer.materials;
			int num = _selectionMaterials.Length;
			_defaultSelectionColors = new Color[num];
			_highlightColors = new Color[num];
			for (int i = 0; i < num; i++)
			{
				_defaultSelectionColors[i] = _selectionMaterials[i].GetColor(_colorId);
				_highlightColors[i] = new Color(1f, 1f, 1f, _defaultSelectionColors[i].a);
			}
			CurrSelectionState = SelectionState.Off;
		}

		private void OnDestroy()
		{
			if (_selectionMaterials == null)
			{
				return;
			}
			Material[] selectionMaterials = _selectionMaterials;
			foreach (Material material in selectionMaterials)
			{
				if (material != null)
				{
					UnityEngine.Object.Destroy(material);
				}
			}
		}

		private void AffectSelectionColor(Color[] newColors)
		{
			int num = newColors.Length;
			for (int i = 0; i < num; i++)
			{
				_selectionMaterials[i].SetColor(_colorId, newColors[i]);
			}
		}
	}
	public class TrackSegment : MonoBehaviour
	{
		public enum SegmentType
		{
			Straight,
			LeftTurn,
			RightTurn,
			Switch
		}

		[SerializeField]
		private SegmentType _segmentType;

		[SerializeField]
		private MeshFilter _straight;

		[SerializeField]
		private MeshFilter _leftTurn;

		[SerializeField]
		private MeshFilter _rightTurn;

		private float _gridSize = 0.8f;

		private int _subDivCount = 20;

		private const float _originalGridSize = 0.8f;

		private const float _trackWidth = 0.15f;

		private GameObject _mesh;

		private Pose _p1 = new Pose();

		private Pose _p2 = new Pose();

		private Pose _endPose = new Pose();

		public float StartDistance { get; set; }

		public float GridSize
		{
			get
			{
				return _gridSize;
			}
			private set
			{
				_gridSize = value;
			}
		}

		public int SubDivCount
		{
			get
			{
				return _subDivCount;
			}
			set
			{
				_subDivCount = value;
			}
		}

		public SegmentType Type => _segmentType;

		public Pose EndPose
		{
			get
			{
				UpdatePose(SegmentLength, _endPose);
				return _endPose;
			}
		}

		public float Radius => 0.5f * GridSize;

		public float SegmentLength
		{
			get
			{
				switch (Type)
				{
				case SegmentType.Straight:
					return GridSize;
				case SegmentType.LeftTurn:
				case SegmentType.RightTurn:
					return (float)Math.PI / 2f * Radius;
				default:
					return 1f;
				}
			}
		}

		public float setGridSize(float size)
		{
			GridSize = size;
			return GridSize / 0.8f;
		}

		private void Awake()
		{
		}

		public void UpdatePose(float distanceIntoSegment, Pose pose)
		{
			if (Type == SegmentType.Straight)
			{
				pose.Position = base.transform.position + distanceIntoSegment * base.transform.forward;
				pose.Rotation = base.transform.rotation;
			}
			else if (Type == SegmentType.LeftTurn)
			{
				float num = distanceIntoSegment / SegmentLength;
				float num2 = (float)Math.PI / 2f * num;
				Vector3 position = new Vector3(Radius * Mathf.Cos(num2) - Radius, 0f, Radius * Mathf.Sin(num2));
				Quaternion quaternion = Quaternion.Euler(0f, (0f - num2) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position);
				pose.Rotation = base.transform.rotation * quaternion;
			}
			else if (Type == SegmentType.RightTurn)
			{
				float num3 = (float)Math.PI - (float)Math.PI / 2f * distanceIntoSegment / SegmentLength;
				Vector3 position2 = new Vector3(Radius * Mathf.Cos(num3) + Radius, 0f, Radius * Mathf.Sin(num3));
				Quaternion quaternion2 = Quaternion.Euler(0f, ((float)Math.PI - num3) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position2);
				pose.Rotation = base.transform.rotation * quaternion2;
			}
			else
			{
				pose.Position = Vector3.zero;
				pose.Rotation = Quaternion.identity;
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			UnityEngine.Object.Destroy(_mesh);
		}

		private void DrawDebugLines()
		{
			for (int i = 1; i < SubDivCount + 1; i++)
			{
				float num = SegmentLength / (float)SubDivCount;
				UpdatePose((float)(i - 1) * num, _p1);
				UpdatePose((float)i * num, _p2);
				float num2 = 0.075f;
				Debug.DrawLine(_p1.Position + num2 * (_p1.Rotation * Vector3.right), _p2.Position + num2 * (_p2.Rotation * Vector3.right));
				Debug.DrawLine(_p1.Position - num2 * (_p1.Rotation * Vector3.right), _p2.Position - num2 * (_p2.Rotation * Vector3.right));
			}
			Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right, Color.yellow);
			Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			Debug.DrawLine(base.transform.position + 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
		}

		public void RegenerateTrackAndMesh()
		{
			if (base.transform.childCount > 0 && !_mesh)
			{
				_mesh = base.transform.GetChild(0).gameObject;
			}
			if ((bool)_mesh)
			{
				UnityEngine.Object.DestroyImmediate(_mesh);
			}
			if (_segmentType == SegmentType.LeftTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_leftTurn.gameObject);
			}
			else if (_segmentType == SegmentType.RightTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_rightTurn.gameObject);
			}
			else
			{
				_mesh = UnityEngine.Object.Instantiate(_straight.gameObject);
			}
			_mesh.transform.SetParent(base.transform, worldPositionStays: false);
			_mesh.transform.position += GridSize / 2f * base.transform.forward;
			_mesh.transform.localScale = new Vector3(GridSize / 0.8f, GridSize / 0.8f, GridSize / 0.8f);
		}
	}
	public class TrainButtonVisualController : MonoBehaviour
	{
		private const float LERP_TO_OLD_POS_DURATION = 1f;

		private const float LOCAL_SIZE_HALVED = 0.5f;

		[SerializeField]
		private MeshRenderer _meshRenderer;

		[SerializeField]
		private MeshRenderer _glowRenderer;

		[SerializeField]
		private ButtonController _buttonController;

		[SerializeField]
		private Color _buttonContactColor = new Color(0.51f, 0.78f, 0.92f, 1f);

		[SerializeField]
		private Color _buttonActionColor = new Color(0.24f, 0.72f, 0.98f, 1f);

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _actionSoundEffect;

		[SerializeField]
		private Transform _buttonContactTransform;

		[SerializeField]
		private float _contactMaxDisplacementDistance = 0.0141f;

		private Material _buttonMaterial;

		private Color _buttonDefaultColor;

		private int _materialColorId;

		private bool _buttonInContactOrActionStates;

		private Coroutine _lerpToOldPositionCr;

		private Vector3 _oldPosition;

		private void Awake()
		{
			_materialColorId = Shader.PropertyToID("_Color");
			_buttonMaterial = _meshRenderer.material;
			_buttonDefaultColor = _buttonMaterial.GetColor(_materialColorId);
			_oldPosition = base.transform.localPosition;
		}

		private void OnDestroy()
		{
			if (_buttonMaterial != null)
			{
				UnityEngine.Object.Destroy(_buttonMaterial);
			}
		}

		private void OnEnable()
		{
			_buttonController.InteractableStateChanged.AddListener(InteractableStateChanged);
			_buttonController.ContactZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonController.ActionZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonInContactOrActionStates = false;
		}

		private void OnDisable()
		{
			if (_buttonController != null)
			{
				_buttonController.InteractableStateChanged.RemoveListener(InteractableStateChanged);
				_buttonController.ContactZoneEvent -= ActionOrInContactZoneStayEvent;
				_buttonController.ActionZoneEvent -= ActionOrInContactZoneStayEvent;
			}
		}

		private void ActionOrInContactZoneStayEvent(ColliderZoneArgs collisionArgs)
		{
			if (_buttonInContactOrActionStates && !collisionArgs.CollidingTool.IsFarFieldTool)
			{
				Vector3 localScale = _buttonContactTransform.localScale;
				Vector3 interactionPosition = collisionArgs.CollidingTool.InteractionPosition;
				float num = (_buttonContactTransform.InverseTransformPoint(interactionPosition) - 0.5f * Vector3.one).y * localScale.y;
				if (num > 0f - _contactMaxDisplacementDistance && num <= 0f)
				{
					base.transform.localPosition = new Vector3(_oldPosition.x, _oldPosition.y + num, _oldPosition.z);
				}
			}
		}

		private void InteractableStateChanged(InteractableStateArgs obj)
		{
			_buttonInContactOrActionStates = false;
			_glowRenderer.gameObject.SetActive(obj.NewInteractableState > InteractableState.Default);
			switch (obj.NewInteractableState)
			{
			case InteractableState.ContactState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonContactColor);
				_buttonInContactOrActionStates = true;
				break;
			case InteractableState.ProximityState:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			case InteractableState.ActionState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonActionColor);
				PlaySound(_actionSoundEffect);
				_buttonInContactOrActionStates = true;
				break;
			default:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			}
		}

		private void PlaySound(AudioClip clip)
		{
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}

		private void StopResetLerping()
		{
			if (_lerpToOldPositionCr != null)
			{
				StopCoroutine(_lerpToOldPositionCr);
			}
		}

		private void LerpToOldPosition()
		{
			if (!((base.transform.localPosition - _oldPosition).sqrMagnitude < Mathf.Epsilon))
			{
				StopResetLerping();
				_lerpToOldPositionCr = StartCoroutine(ResetPosition());
			}
		}

		private IEnumerator ResetPosition()
		{
			float startTime = Time.time;
			float endTime = Time.time + 1f;
			while (Time.time < endTime)
			{
				base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, _oldPosition, (Time.time - startTime) / 1f);
				yield return null;
			}
			base.transform.localPosition = _oldPosition;
			_lerpToOldPositionCr = null;
		}
	}
	public class TrainCar : TrainCarBase
	{
		[SerializeField]
		private TrainCarBase _parentLocomotive;

		[SerializeField]
		protected float _distanceBehindParent = 0.1f;

		public float DistanceBehindParentScaled => scale * _distanceBehindParent;

		protected override void Awake()
		{
			base.Awake();
		}

		public override void UpdatePosition()
		{
			base.Distance = _parentLocomotive.Distance - DistanceBehindParentScaled;
			UpdateCarPosition();
			RotateCarWheels();
		}
	}
	public abstract class TrainCarBase : MonoBehaviour
	{
		private static Vector3 OFFSET = new Vector3(0f, 0.0195f, 0f);

		private const float WHEEL_RADIUS = 0.027f;

		private const float TWO_PI = (float)Math.PI * 2f;

		[SerializeField]
		protected Transform _frontWheels;

		[SerializeField]
		protected Transform _rearWheels;

		[SerializeField]
		protected TrainTrack _trainTrack;

		[SerializeField]
		protected Transform[] _individualWheels;

		protected float scale = 1f;

		private Pose _frontPose = new Pose();

		private Pose _rearPose = new Pose();

		public float Distance { get; protected set; }

		public float Scale
		{
			get
			{
				return scale;
			}
			set
			{
				scale = value;
			}
		}

		protected virtual void Awake()
		{
		}

		public void UpdatePose(float distance, TrainCarBase train, Pose pose)
		{
			distance = (train._trainTrack.TrackLength + distance) % train._trainTrack.TrackLength;
			if (distance < 0f)
			{
				distance += train._trainTrack.TrackLength;
			}
			TrackSegment segment = train._trainTrack.GetSegment(distance);
			float distanceIntoSegment = distance - segment.StartDistance;
			segment.UpdatePose(distanceIntoSegment, pose);
		}

		protected void UpdateCarPosition()
		{
			UpdatePose(Distance + _frontWheels.transform.localPosition.z * scale, this, _frontPose);
			UpdatePose(Distance + _rearWheels.transform.localPosition.z * scale, this, _rearPose);
			Vector3 vector = 0.5f * (_frontPose.Position + _rearPose.Position);
			Vector3 forward = _frontPose.Position - _rearPose.Position;
			base.transform.position = vector + OFFSET;
			base.transform.rotation = Quaternion.LookRotation(forward, base.transform.up);
			_frontWheels.transform.rotation = _frontPose.Rotation;
			_rearWheels.transform.rotation = _rearPose.Rotation;
		}

		protected void RotateCarWheels()
		{
			float num = Distance / 0.027f % ((float)Math.PI * 2f);
			Transform[] individualWheels = _individualWheels;
			for (int i = 0; i < individualWheels.Length; i++)
			{
				individualWheels[i].localRotation = Quaternion.AngleAxis(57.29578f * num, Vector3.right);
			}
		}

		public abstract void UpdatePosition();
	}
	public class TrainCrossingController : MonoBehaviour
	{
		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip[] _crossingSounds;

		[SerializeField]
		private MeshRenderer _lightSide1Renderer;

		[SerializeField]
		private MeshRenderer _lightSide2Renderer;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private Material _lightsSide1Mat;

		private Material _lightsSide2Mat;

		private int _colorId = Shader.PropertyToID("_Color");

		private Coroutine _xingAnimationCr;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_lightsSide1Mat = _lightSide1Renderer.material;
			_lightsSide2Mat = _lightSide2Renderer.material;
		}

		private void OnDestroy()
		{
			if (_lightsSide1Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide1Mat);
			}
			if (_lightsSide2Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide2Mat);
			}
		}

		public void CrossingButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				ActivateTrainCrossing();
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}

		private void ActivateTrainCrossing()
		{
			int num = _crossingSounds.Length - 1;
			AudioClip audioClip = _crossingSounds[(int)(UnityEngine.Random.value * (float)num)];
			_audioSource.clip = audioClip;
			_audioSource.timeSamples = 0;
			_audioSource.Play();
			if (_xingAnimationCr != null)
			{
				StopCoroutine(_xingAnimationCr);
			}
			_xingAnimationCr = StartCoroutine(AnimateCrossing(audioClip.length * 0.75f));
		}

		private IEnumerator AnimateCrossing(float animationLength)
		{
			ToggleLightObjects(enableState: true);
			float animationEndTime = Time.time + animationLength;
			float lightBlinkDuration = animationLength * 0.1f;
			float lightBlinkStartTime = Time.time;
			float lightBlinkEndTime = Time.time + lightBlinkDuration;
			Material lightToBlinkOn = _lightsSide1Mat;
			Material lightToBlinkOff = _lightsSide2Mat;
			Color onColor = new Color(1f, 1f, 1f, 1f);
			Color offColor = new Color(1f, 1f, 1f, 0f);
			while (Time.time < animationEndTime)
			{
				float t = (Time.time - lightBlinkStartTime) / lightBlinkDuration;
				lightToBlinkOn.SetColor(_colorId, Color.Lerp(offColor, onColor, t));
				lightToBlinkOff.SetColor(_colorId, Color.Lerp(onColor, offColor, t));
				if (Time.time > lightBlinkEndTime)
				{
					Material material = lightToBlinkOn;
					lightToBlinkOn = lightToBlinkOff;
					lightToBlinkOff = material;
					lightBlinkStartTime = Time.time;
					lightBlinkEndTime = Time.time + lightBlinkDuration;
				}
				yield return null;
			}
			ToggleLightObjects(enableState: false);
		}

		private void AffectMaterials(Material[] materials, Color newColor)
		{
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].SetColor(_colorId, newColor);
			}
		}

		private void ToggleLightObjects(bool enableState)
		{
			_lightSide1Renderer.gameObject.SetActive(enableState);
			_lightSide2Renderer.gameObject.SetActive(enableState);
		}
	}
	public class TrainLocomotive : TrainCarBase
	{
		private enum EngineSoundState
		{
			Start,
			AccelerateOrSetProperSpeed,
			Stop
		}

		private const float MIN_SPEED = 0.2f;

		private const float MAX_SPEED = 2.7f;

		private const float SMOKE_SPEED_MULTIPLIER = 8f;

		private const int MAX_PARTICLES_MULTIPLIER = 3;

		[SerializeField]
		[Range(0.2f, 2.7f)]
		protected float _initialSpeed;

		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private GameObject _decreaseSpeedButton;

		[SerializeField]
		private GameObject _increaseSpeedButton;

		[SerializeField]
		private GameObject _smokeButton;

		[SerializeField]
		private GameObject _whistleButton;

		[SerializeField]
		private GameObject _reverseButton;

		[SerializeField]
		private AudioSource _whistleAudioSource;

		[SerializeField]
		private AudioClip _whistleSound;

		[SerializeField]
		private AudioSource _engineAudioSource;

		[SerializeField]
		private AudioClip[] _accelerationSounds;

		[SerializeField]
		private AudioClip[] _decelerationSounds;

		[SerializeField]
		private AudioClip _startUpSound;

		[SerializeField]
		private AudioSource _smokeStackAudioSource;

		[SerializeField]
		private AudioClip _smokeSound;

		[SerializeField]
		private ParticleSystem _smoke1;

		[SerializeField]
		private ParticleSystem _smoke2;

		[SerializeField]
		private TrainCarBase[] _childCars;

		private bool _isMoving = true;

		private bool _reverse;

		private float _currentSpeed;

		private float _speedDiv;

		private float _standardRateOverTimeMultiplier;

		private int _standardMaxParticles;

		private Coroutine _startStopTrainCr;

		private void Start()
		{
			_standardRateOverTimeMultiplier = _smoke1.emission.rateOverTimeMultiplier;
			_standardMaxParticles = _smoke1.main.maxParticles;
			base.Distance = 0f;
			_speedDiv = 2.5f / (float)_accelerationSounds.Length;
			_currentSpeed = _initialSpeed;
			UpdateCarPosition();
			_smoke1.Stop();
			_startStopTrainCr = StartCoroutine(StartStopTrain(startTrain: true));
		}

		private void Update()
		{
			UpdatePosition();
		}

		public override void UpdatePosition()
		{
			if (_isMoving)
			{
				if (_trainTrack != null)
				{
					UpdateDistance();
					UpdateCarPosition();
					RotateCarWheels();
				}
				TrainCarBase[] childCars = _childCars;
				for (int i = 0; i < childCars.Length; i++)
				{
					childCars[i].UpdatePosition();
				}
			}
		}

		public void StartStopStateChanged()
		{
			if (_startStopTrainCr == null)
			{
				_startStopTrainCr = StartCoroutine(StartStopTrain(!_isMoving));
			}
		}

		private IEnumerator StartStopTrain(bool startTrain)
		{
			float endSpeed = (startTrain ? _initialSpeed : 0f);
			float timePeriodForSpeedChange2;
			if (startTrain)
			{
				_smoke1.Play();
				_isMoving = true;
				ParticleSystem.EmissionModule emission = _smoke1.emission;
				ParticleSystem.MainModule main = _smoke1.main;
				emission.rateOverTimeMultiplier = _standardRateOverTimeMultiplier;
				main.maxParticles = _standardMaxParticles;
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Start);
			}
			else
			{
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Stop);
			}
			_engineAudioSource.loop = false;
			timePeriodForSpeedChange2 *= 0.9f;
			float startTime = Time.time;
			float endTime = Time.time + timePeriodForSpeedChange2;
			float startSpeed = _currentSpeed;
			while (Time.time < endTime)
			{
				float num = (Time.time - startTime) / timePeriodForSpeedChange2;
				_currentSpeed = startSpeed * (1f - num) + endSpeed * num;
				UpdateSmokeEmissionBasedOnSpeed();
				yield return null;
			}
			_currentSpeed = endSpeed;
			_startStopTrainCr = null;
			_isMoving = startTrain;
			if (!_isMoving)
			{
				_smoke1.Stop();
				yield break;
			}
			_engineAudioSource.loop = true;
			PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
		}

		private float PlayEngineSound(EngineSoundState engineSoundState)
		{
			AudioClip audioClip = null;
			if (engineSoundState == EngineSoundState.Start)
			{
				audioClip = _startUpSound;
			}
			else
			{
				AudioClip[] obj = ((engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed) ? _accelerationSounds : _decelerationSounds);
				int num = obj.Length;
				int value = (int)Mathf.Round((_currentSpeed - 0.2f) / _speedDiv);
				audioClip = obj[Mathf.Clamp(value, 0, num - 1)];
			}
			if (_engineAudioSource.clip == audioClip && _engineAudioSource.isPlaying && engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed)
			{
				return 0f;
			}
			_engineAudioSource.clip = audioClip;
			_engineAudioSource.timeSamples = 0;
			_engineAudioSource.Play();
			return audioClip.length;
		}

		private void UpdateDistance()
		{
			float num = (_reverse ? (0f - _currentSpeed) : _currentSpeed);
			base.Distance = (base.Distance + num * Time.deltaTime) % _trainTrack.TrackLength;
		}

		public void DecreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed - _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		public void IncreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed + _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		private void UpdateSmokeEmissionBasedOnSpeed()
		{
			ParticleSystem.EmissionModule emission = _smoke1.emission;
			emission.rateOverTimeMultiplier = GetCurrentSmokeEmission();
			ParticleSystem.MainModule main = _smoke1.main;
			main.maxParticles = (int)Mathf.Lerp(_standardMaxParticles, _standardMaxParticles * 3, _currentSpeed / 2.5f);
		}

		private float GetCurrentSmokeEmission()
		{
			return Mathf.Lerp(_standardRateOverTimeMultiplier, _standardRateOverTimeMultiplier * 8f, _currentSpeed / 2.5f);
		}

		public void SmokeButtonStateChanged()
		{
			if (_isMoving)
			{
				_smokeStackAudioSource.clip = _smokeSound;
				_smokeStackAudioSource.timeSamples = 0;
				_smokeStackAudioSource.Play();
				_smoke2.time = 0f;
				_smoke2.Play();
			}
		}

		public void WhistleButtonStateChanged()
		{
			if (_whistleSound != null)
			{
				_whistleAudioSource.clip = _whistleSound;
				_whistleAudioSource.timeSamples = 0;
				_whistleAudioSource.Play();
			}
		}

		public void ReverseButtonStateChanged()
		{
			_reverse = !_reverse;
		}
	}
	public class TrainTrack : MonoBehaviour
	{
		[SerializeField]
		private float _gridSize = 0.5f;

		[SerializeField]
		private int _subDivCount = 20;

		[SerializeField]
		private Transform _segmentParent;

		[SerializeField]
		private Transform _trainParent;

		[SerializeField]
		private bool _regnerateTrackMeshOnAwake;

		private float _trainLength = -1f;

		private TrackSegment[] _trackSegments;

		public float TrackLength
		{
			get
			{
				return _trainLength;
			}
			private set
			{
				_trainLength = value;
			}
		}

		private void Awake()
		{
			Regenerate();
		}

		public TrackSegment GetSegment(float distance)
		{
			int childCount = _segmentParent.childCount;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment = _trackSegments[i];
				TrackSegment trackSegment2 = _trackSegments[(i + 1) % childCount];
				if (distance >= trackSegment.StartDistance && (distance < trackSegment2.StartDistance || i == childCount - 1))
				{
					return trackSegment;
				}
			}
			return null;
		}

		public void Regenerate()
		{
			_trackSegments = _segmentParent.GetComponentsInChildren<TrackSegment>();
			TrackLength = 0f;
			int childCount = _segmentParent.childCount;
			TrackSegment trackSegment = null;
			float scale = 0f;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment2 = _trackSegments[i];
				trackSegment2.SubDivCount = _subDivCount;
				scale = trackSegment2.setGridSize(_gridSize);
				if (trackSegment != null)
				{
					Pose endPose = trackSegment.EndPose;
					trackSegment2.transform.position = endPose.Position;
					trackSegment2.transform.rotation = endPose.Rotation;
					trackSegment2.StartDistance = TrackLength;
				}
				if (_regnerateTrackMeshOnAwake)
				{
					trackSegment2.RegenerateTrackAndMesh();
				}
				TrackLength += trackSegment2.SegmentLength;
				trackSegment = trackSegment2;
			}
			SetScale(scale);
		}

		private void SetScale(float ratio)
		{
			_trainParent.localScale = new Vector3(ratio, ratio, ratio);
			TrainCar[] componentsInChildren = _trainParent.GetComponentsInChildren<TrainCar>();
			_trainParent.GetComponentInChildren<TrainLocomotive>().Scale = ratio;
			TrainCar[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Scale = ratio;
			}
		}
	}
	public class Pose
	{
		public Vector3 Position;

		public Quaternion Rotation;

		public Pose()
		{
			Position = Vector3.zero;
			Rotation = Quaternion.identity;
		}

		public Pose(Vector3 position, Quaternion rotation)
		{
			Position = position;
			Rotation = rotation;
		}
	}
	public class WindmillBladesController : MonoBehaviour
	{
		private const float MAX_TIME = 1f;

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _windMillRotationSound;

		[SerializeField]
		private AudioClip _windMillStartSound;

		[SerializeField]
		private AudioClip _windMillStopSound;

		private float _currentSpeed;

		private Coroutine _lerpSpeedCoroutine;

		private Coroutine _audioChangeCr;

		private Quaternion _originalRotation;

		private float _rotAngle;

		public bool IsMoving { get; private set; }

		private void Start()
		{
			_originalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			_rotAngle += _currentSpeed * Time.deltaTime;
			if (_rotAngle > 360f)
			{
				_rotAngle = 0f;
			}
			base.transform.localRotation = _originalRotation * Quaternion.AngleAxis(_rotAngle, Vector3.forward);
		}

		public void SetMoveState(bool newMoveState, float goalSpeed)
		{
			IsMoving = newMoveState;
			if (_lerpSpeedCoroutine != null)
			{
				StopCoroutine(_lerpSpeedCoroutine);
			}
			_lerpSpeedCoroutine = StartCoroutine(LerpToSpeed(goalSpeed));
		}

		private IEnumerator LerpToSpeed(float goalSpeed)
		{
			float totalTime = 0f;
			float startSpeed = _currentSpeed;
			if (_audioChangeCr != null)
			{
				StopCoroutine(_audioChangeCr);
			}
			if (IsMoving)
			{
				_audioChangeCr = StartCoroutine(PlaySoundDelayed(_windMillStartSound, _windMillRotationSound, _windMillStartSound.length * 0.95f));
			}
			else
			{
				PlaySound(_windMillStopSound);
			}
			for (float num = Mathf.Abs(_currentSpeed - goalSpeed); num > Mathf.Epsilon; num = Mathf.Abs(_currentSpeed - goalSpeed))
			{
				_currentSpeed = Mathf.Lerp(startSpeed, goalSpeed, totalTime / 1f);
				totalTime += Time.deltaTime;
				yield return null;
			}
			_lerpSpeedCoroutine = null;
		}

		private IEnumerator PlaySoundDelayed(AudioClip initial, AudioClip clip, float timeDelayAfterInitial)
		{
			PlaySound(initial);
			yield return new WaitForSeconds(timeDelayAfterInitial);
			PlaySound(clip, loop: true);
		}

		private void PlaySound(AudioClip clip, bool loop = false)
		{
			_audioSource.loop = loop;
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}
	}
	public class WindmillController : MonoBehaviour
	{
		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private float _maxSpeed = 10f;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private WindmillBladesController _bladesRotation;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_bladesRotation = GetComponentInChildren<WindmillBladesController>();
			_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
		}

		private void OnEnable()
		{
			_startStopButton.GetComponent<Interactable>().InteractableStateChanged.AddListener(StartStopStateChanged);
		}

		private void OnDisable()
		{
			if (_startStopButton != null)
			{
				_startStopButton.GetComponent<Interactable>().InteractableStateChanged.RemoveListener(StartStopStateChanged);
			}
		}

		private void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				if (_bladesRotation.IsMoving)
				{
					_bladesRotation.SetMoveState(newMoveState: false, 0f);
				}
				else
				{
					_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
				}
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}
	}
	public enum EUiDisplayType
	{
		EUDT_WorldGeoQuad,
		EUDT_OverlayQuad,
		EUDT_None,
		EUDT_MaxDislayTypes
	}
	public class OVROverlaySample : MonoBehaviour
	{
		private bool inMenu;

		private const string ovrOverlayID = "OVROverlayID";

		private const string applicationID = "ApplicationID";

		private const string noneID = "NoneID";

		private Toggle applicationRadioButton;

		private Toggle noneRadioButton;

		[Header("App vs Compositor Comparison Settings")]
		public GameObject mainCamera;

		public GameObject uiCamera;

		public GameObject uiGeoParent;

		public GameObject worldspaceGeoParent;

		public OVROverlay cameraRenderOverlay;

		public OVROverlay renderingLabelOverlay;

		public Texture applicationLabelTexture;

		public Texture compositorLabelTexture;

		[Header("Level Loading Sim Settings")]
		public GameObject prefabForLevelLoadSim;

		public OVROverlay cubemapOverlay;

		public OVROverlay loadingTextQuadOverlay;

		public float distanceFromCamToLoadText;

		public float cubeSpawnRadius;

		public float heightBetweenItems;

		public int numObjectsPerLevel;

		public int numLevels;

		public int numLoopsTrigger = 500000000;

		private List<GameObject> spawnedCubes = new List<GameObject>();

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("OVROverlay Sample");
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("Level Loading Example");
			DebugUIBuilder.instance.AddButton("Simulate Level Load", TriggerLoad);
			DebugUIBuilder.instance.AddButton("Destroy Cubes", TriggerUnload);
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("OVROverlay vs. Application Render Comparison");
			DebugUIBuilder.instance.AddRadio("OVROverlay", "group", delegate(Toggle t)
			{
				RadioPressed("OVROverlayID", "group", t);
			}).GetComponentInChildren<Toggle>();
			applicationRadioButton = DebugUIBuilder.instance.AddRadio("Application", "group", delegate(Toggle t)
			{
				RadioPressed("ApplicationID", "group", t);
			}).GetComponentInChildren<Toggle>();
			noneRadioButton = DebugUIBuilder.instance.AddRadio("None", "group", delegate(Toggle t)
			{
				RadioPressed("NoneID", "group", t);
			}).GetComponentInChildren<Toggle>();
			DebugUIBuilder.instance.Show();
			CameraAndRenderTargetSetup();
			cameraRenderOverlay.enabled = true;
			cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
			spawnedCubes.Capacity = numObjectsPerLevel * numLevels;
		}

		private void Update()
		{
			if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
			{
				if (inMenu)
				{
					DebugUIBuilder.instance.Hide();
				}
				else
				{
					DebugUIBuilder.instance.Show();
				}
				inMenu = !inMenu;
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				TriggerLoad();
			}
		}

		private void ActivateWorldGeo()
		{
			worldspaceGeoParent.SetActive(value: true);
			uiGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = applicationLabelTexture;
			Debug.Log("Switched to ActivateWorldGeo");
		}

		private void ActivateOVROverlay()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: true);
			cameraRenderOverlay.enabled = true;
			uiGeoParent.SetActive(value: true);
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = compositorLabelTexture;
			Debug.Log("Switched to ActivateOVROVerlay");
		}

		private void ActivateNone()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			uiGeoParent.SetActive(value: false);
			renderingLabelOverlay.enabled = false;
			Debug.Log("Switched to ActivateNone");
		}

		private void TriggerLoad()
		{
			StartCoroutine(WaitforOVROverlay());
		}

		private IEnumerator WaitforOVROverlay()
		{
			Transform transform = mainCamera.transform;
			Transform obj = loadingTextQuadOverlay.transform;
			Vector3 position = transform.position + transform.forward * distanceFromCamToLoadText;
			position.y = transform.position.y;
			obj.position = position;
			cubemapOverlay.enabled = true;
			loadingTextQuadOverlay.enabled = true;
			noneRadioButton.isOn = true;
			yield return new WaitForSeconds(0.1f);
			ClearObjects();
			SimulateLevelLoad();
			cubemapOverlay.enabled = false;
			loadingTextQuadOverlay.enabled = false;
			yield return null;
		}

		private void TriggerUnload()
		{
			ClearObjects();
			applicationRadioButton.isOn = true;
		}

		private void CameraAndRenderTargetSetup()
		{
			float x = cameraRenderOverlay.transform.localScale.x;
			float y = cameraRenderOverlay.transform.localScale.y;
			float z = cameraRenderOverlay.transform.localScale.z;
			float num = 1440f;
			float num2 = 2560f * 0.5f;
			float num3 = mainCamera.GetComponent<Camera>().fieldOfView / 2f;
			float num4 = 2f * z * Mathf.Tan((float)Math.PI / 180f * num3);
			float num5 = num / num4 * x;
			float num6 = 0f;
			float num7 = num4 * mainCamera.GetComponent<Camera>().aspect;
			num6 = num2 / num7 * x;
			float orthographicSize = y / 2f;
			float aspect = x / y;
			uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;
			uiCamera.GetComponent<Camera>().aspect = aspect;
			if (uiCamera.GetComponent<Camera>().targetTexture != null)
			{
				uiCamera.GetComponent<Camera>().targetTexture.Release();
			}
			RenderTexture renderTexture = new RenderTexture((int)num6 * 2, (int)num5 * 2, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
			Debug.Log("Created RT of resolution w: " + num6 + " and h: " + num5);
			renderTexture.hideFlags = HideFlags.DontSave;
			renderTexture.useMipMap = true;
			renderTexture.filterMode = FilterMode.Trilinear;
			renderTexture.anisoLevel = 4;
			renderTexture.autoGenerateMips = true;
			uiCamera.GetComponent<Camera>().targetTexture = renderTexture;
			cameraRenderOverlay.textures[0] = renderTexture;
		}

		private void SimulateLevelLoad()
		{
			int num = 0;
			for (int i = 0; i < numLoopsTrigger; i++)
			{
				num++;
			}
			Debug.Log("Finished " + num + " Loops");
			Vector3 position = mainCamera.transform.position;
			position.y = 0.5f;
			for (int j = 0; j < numLevels; j++)
			{
				for (int k = 0; k < numObjectsPerLevel; k++)
				{
					float f = (float)k * (float)Math.PI * 2f / (float)numObjectsPerLevel;
					float num2 = ((k % 2 == 0) ? 1.5f : 1f);
					Vector3 vector = new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * cubeSpawnRadius * num2;
					vector.y = (float)j * heightBetweenItems;
					GameObject gameObject = UnityEngine.Object.Instantiate(prefabForLevelLoadSim, vector + position, Quaternion.identity);
					Transform obj = gameObject.transform;
					obj.LookAt(position);
					Vector3 eulerAngles = obj.rotation.eulerAngles;
					eulerAngles.x = 0f;
					obj.rotation = Quaternion.Euler(eulerAngles);
					spawnedCubes.Add(gameObject);
				}
			}
		}

		private void ClearObjects()
		{
			for (int i = 0; i < spawnedCubes.Count; i++)
			{
				UnityEngine.Object.DestroyImmediate(spawnedCubes[i]);
			}
			spawnedCubes.Clear();
			GC.Collect();
		}

		public void RadioPressed(string radioLabel, string group, Toggle t)
		{
			if (string.Compare(radioLabel, "OVROverlayID") == 0)
			{
				ActivateOVROverlay();
			}
			else if (string.Compare(radioLabel, "ApplicationID") == 0)
			{
				ActivateWorldGeo();
			}
			else if (string.Compare(radioLabel, "NoneID") == 0)
			{
				ActivateNone();
			}
		}
	}
}
namespace OVRTouchSample
{
	[RequireComponent(typeof(OVRGrabber))]
	public class Hand : MonoBehaviour
	{
		public const string ANIM_LAYER_NAME_POINT = "Point Layer";

		public const string ANIM_LAYER_NAME_THUMB = "Thumb Layer";

		public const string ANIM_PARAM_NAME_FLEX = "Flex";

		public const string ANIM_PARAM_NAME_POSE = "Pose";

		public const float THRESH_COLLISION_FLEX = 0.9f;

		public const float INPUT_RATE_CHANGE = 20f;

		public const float COLLIDER_SCALE_MIN = 0.01f;

		public const float COLLIDER_SCALE_MAX = 1f;

		public const float COLLIDER_SCALE_PER_SECOND = 1f;

		public const float TRIGGER_DEBOUNCE_TIME = 0.05f;

		public const float THUMB_DEBOUNCE_TIME = 0.15f;

		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		[SerializeField]
		private HandPose m_defaultGrabPose;

		private Collider[] m_colliders;

		private bool m_collisionEnabled = true;

		private OVRGrabber m_grabber;

		private List<Renderer> m_showAfterInputFocusAcquired;

		private int m_animLayerIndexThumb = -1;

		private int m_animLayerIndexPoint = -1;

		private int m_animParamIndexFlex = -1;

		private int m_animParamIndexPose = -1;

		private bool m_isPointing;

		private bool m_isGivingThumbsUp;

		private float m_pointBlend;

		private float m_thumbsUpBlend;

		private bool m_restoreOnInputAcquired;

		private float m_collisionScaleCurrent;

		private void Awake()
		{
			m_grabber = GetComponent<OVRGrabber>();
		}

		private void Start()
		{
			m_showAfterInputFocusAcquired = new List<Renderer>();
			m_colliders = (from childCollider in GetComponentsInChildren<Collider>()
				where !childCollider.isTrigger
				select childCollider).ToArray();
			CollisionEnable(enabled: false);
			m_animLayerIndexPoint = m_animator.GetLayerIndex("Point Layer");
			m_animLayerIndexThumb = m_animator.GetLayerIndex("Thumb Layer");
			m_animParamIndexFlex = Animator.StringToHash("Flex");
			m_animParamIndexPose = Animator.StringToHash("Pose");
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnDestroy()
		{
			OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
			OVRManager.InputFocusLost -= OnInputFocusLost;
		}

		private void Update()
		{
			UpdateCapTouchStates();
			m_pointBlend = InputValueRateChange(m_isPointing, m_pointBlend);
			m_thumbsUpBlend = InputValueRateChange(m_isGivingThumbsUp, m_thumbsUpBlend);
			float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			bool flag = m_grabber.grabbedObject == null && num >= 0.9f;
			CollisionEnable(flag);
			UpdateAnimStates();
		}

		private void UpdateCapTouchStates()
		{
			m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);
			m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);
		}

		private void LateUpdate()
		{
			if (m_collisionEnabled && m_collisionScaleCurrent + Mathf.Epsilon < 1f)
			{
				m_collisionScaleCurrent = Mathf.Min(1f, m_collisionScaleCurrent + Time.deltaTime * 1f);
				for (int i = 0; i < m_colliders.Length; i++)
				{
					m_colliders[i].transform.localScale = new Vector3(m_collisionScaleCurrent, m_collisionScaleCurrent, m_collisionScaleCurrent);
				}
			}
		}

		private void OnInputFocusLost()
		{
			if (!base.gameObject.activeInHierarchy)
			{
				return;
			}
			m_showAfterInputFocusAcquired.Clear();
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].enabled)
				{
					componentsInChildren[i].enabled = false;
					m_showAfterInputFocusAcquired.Add(componentsInChildren[i]);
				}
			}
			CollisionEnable(enabled: false);
			m_restoreOnInputAcquired = true;
		}

		private void OnInputFocusAcquired()
		{
			if (!m_restoreOnInputAcquired)
			{
				return;
			}
			for (int i = 0; i < m_showAfterInputFocusAcquired.Count; i++)
			{
				if ((bool)m_showAfterInputFocusAcquired[i])
				{
					m_showAfterInputFocusAcquired[i].enabled = true;
				}
			}
			m_showAfterInputFocusAcquired.Clear();
			m_restoreOnInputAcquired = false;
		}

		private float InputValueRateChange(bool isDown, float value)
		{
			float num = Time.deltaTime * 20f;
			float num2 = (isDown ? 1f : (-1f));
			return Mathf.Clamp01(value + num * num2);
		}

		private void UpdateAnimStates()
		{
			bool num = m_grabber.grabbedObject != null;
			HandPose handPose = m_defaultGrabPose;
			if (num)
			{
				HandPose component = m_grabber.grabbedObject.GetComponent<HandPose>();
				if (component != null)
				{
					handPose = component;
				}
			}
			HandPoseId poseId = handPose.PoseId;
			m_animator.SetInteger(m_animParamIndexPose, (int)poseId);
			float value = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			m_animator.SetFloat(m_animParamIndexFlex, value);
			float weight = ((!num || handPose.AllowPointing) ? m_pointBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexPoint, weight);
			float weight2 = ((!num || handPose.AllowThumbsUp) ? m_thumbsUpBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexThumb, weight2);
			float value2 = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller);
			m_animator.SetFloat("Pinch", value2);
		}

		private void CollisionEnable(bool enabled)
		{
			if (m_collisionEnabled == enabled)
			{
				return;
			}
			m_collisionEnabled = enabled;
			if (enabled)
			{
				m_collisionScaleCurrent = 0.01f;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider obj = m_colliders[i];
					obj.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
					obj.enabled = true;
				}
			}
			else
			{
				m_collisionScaleCurrent = 1f;
				for (int j = 0; j < m_colliders.Length; j++)
				{
					Collider obj2 = m_colliders[j];
					obj2.enabled = false;
					obj2.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
				}
			}
		}
	}
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall,
		Controller
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;
	}
	public class TouchController : MonoBehaviour
	{
		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		private bool m_restoreOnInputAcquired;

		private void Update()
		{
			m_animator.SetFloat("Button 1", OVRInput.Get(OVRInput.Button.One, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Button 2", OVRInput.Get(OVRInput.Button.Two, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Joy X", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).x);
			m_animator.SetFloat("Joy Y", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).y);
			m_animator.SetFloat("Grip", OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller));
			m_animator.SetFloat("Trigger", OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller));
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			if (base.gameObject.activeInHierarchy)
			{
				base.gameObject.SetActive(value: false);
				m_restoreOnInputAcquired = true;
			}
		}

		private void OnInputFocusAcquired()
		{
			if (m_restoreOnInputAcquired)
			{
				base.gameObject.SetActive(value: true);
				m_restoreOnInputAcquired = false;
			}
		}
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
namespace Oculus.Avatar
{
	public static class AvatarLogger
	{
		public const string LogAvatar = "[Avatars] - ";

		public const string Tab = "    ";

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg)
		{
			Debug.Log("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg, UnityEngine.Object context)
		{
			Debug.Log("[Avatars] - " + logMsg, context);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_WARNING")]
		public static void LogWarning(string logMsg)
		{
			Debug.LogWarning("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg)
		{
			Debug.LogError("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg, UnityEngine.Object context)
		{
			Debug.LogError("[Avatars] - " + logMsg, context);
		}
	}
	public class CAPI
	{
		public delegate void LoggingDelegate(IntPtr str);

		public enum Result
		{
			Success = 0,
			Failure = -1000,
			Failure_InvalidParameter = -1001,
			Failure_NotInitialized = -1002,
			Failure_InvalidOperation = -1003,
			Failure_Unsupported = -1004,
			Failure_NotYetImplemented = -1005,
			Failure_OperationFailed = -1006,
			Failure_InsufficientSize = -1007
		}

		private static class OVRP_1_30_0
		{
			public static readonly Version version = new Version(1, 30, 0);

			[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
			public static extern Result ovrp_SendEvent2(string name, string param, string source);
		}

		private const string LibFile = "ovravatarloader";

		private static IntPtr nativeVisemeData = IntPtr.Zero;

		private static IntPtr nativeGazeTargetsData = IntPtr.Zero;

		private static IntPtr nativeAvatarLightsData = IntPtr.Zero;

		private static IntPtr DebugLineCountData = IntPtr.Zero;

		private static float[] scratchBufferFloat = new float[16];

		private static GameObject debugLineGo;

		private static string SDKRuntimePrefix = "[RUNTIME] - ";

		private const string ovrPluginDLL = "OVRPlugin";

		private static Version ovrPluginVersion;

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_InitializeAndroidUnity(string appID);

		public static void Initialize()
		{
			nativeVisemeData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarVisemes)));
			nativeGazeTargetsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarGazeTargets)));
			nativeAvatarLightsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarLights)));
			DebugLineCountData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			debugLineGo = new GameObject();
			debugLineGo.name = "AvatarSDKDebugDrawHelper";
		}

		public static void Shutdown()
		{
			Marshal.FreeHGlobal(nativeVisemeData);
			Marshal.FreeHGlobal(nativeGazeTargetsData);
			Marshal.FreeHGlobal(nativeAvatarLightsData);
			Marshal.FreeHGlobal(DebugLineCountData);
			debugLineGo = null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Shutdown();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarMessage_Pop();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMessageType ovrAvatarMessage_GetType(IntPtr msg);

		public static ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_GetAvatarSpecification(IntPtr msg)
		{
			return (ovrAvatarMessage_AvatarSpecification)Marshal.PtrToStructure(ovrAvatarMessage_GetAvatarSpecification_Native(msg), typeof(ovrAvatarMessage_AvatarSpecification));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAvatarSpecification")]
		private static extern IntPtr ovrAvatarMessage_GetAvatarSpecification_Native(IntPtr msg);

		public static ovrAvatarMessage_AssetLoaded ovrAvatarMessage_GetAssetLoaded(IntPtr msg)
		{
			return (ovrAvatarMessage_AssetLoaded)Marshal.PtrToStructure(ovrAvatarMessage_GetAssetLoaded_Native(msg), typeof(ovrAvatarMessage_AssetLoaded));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAssetLoaded")]
		private static extern IntPtr ovrAvatarMessage_GetAssetLoaded_Native(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarMessage_Free(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarSpecificationRequest_Create(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_Destroy(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetCombineMeshes(IntPtr specificationRequest, bool useCombinedMesh);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLevelOfDetail(IntPtr specificationRequest, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecification(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecificationFromSpecRequest(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetExpressiveFlag(IntPtr specificationRequest, bool enable);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatar_Create(IntPtr avatarSpecification, ovrAvatarCapabilities capabilities);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Destroy(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateBody(IntPtr avatar, ovrAvatarTransform headPose);

		public static void ovrAvatarPose_UpdateVoiceVisualization(IntPtr avatar, float[] pcmData)
		{
			ovrAvatarPose_UpdateVoiceVisualization_Native(avatar, (uint)pcmData.Length, pcmData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_UpdateVoiceVisualization")]
		private static extern void ovrAvatarPose_UpdateVoiceVisualization_Native(IntPtr avatar, uint pcmDataSize, [In] float[] pcmData);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHandsWithType(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight, ovrAvatarControllerType type);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Finalize(IntPtr avatar, float elapsedSeconds);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarComponent_Count(IntPtr avatar);

		public static void ovrAvatarComponent_Get(IntPtr avatar, uint index, bool includeName, ref ovrAvatarComponent component)
		{
			ovrAvatarComponent_Get(ovrAvatarComponent_Get_Native(avatar, index), includeName, ref component);
		}

		public static void ovrAvatarComponent_Get(IntPtr componentPtr, bool includeName, ref ovrAvatarComponent component)
		{
			Marshal.Copy(new IntPtr(componentPtr.ToInt64() + ovrAvatarComponent_Offsets.transform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.transform);
			component.renderPartCount = (uint)Marshal.ReadInt32(componentPtr, ovrAvatarComponent_Offsets.renderPartCount);
			component.renderParts = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.renderParts);
			if (includeName)
			{
				IntPtr ptr = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.name);
				component.name = Marshal.PtrToStringAnsi(ptr);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarComponent_Get")]
		public static extern IntPtr ovrAvatarComponent_Get_Native(IntPtr avatar, uint index);

		public static bool ovrAvatarPose_GetBaseComponent(IntPtr avatar, ref ovrAvatarBaseComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBaseComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarBaseComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBaseComponent")]
		private static extern IntPtr ovrAvatarPose_GetBaseComponent_Native(IntPtr avatar);

		public static IntPtr MarshalRenderComponent<T>(IntPtr ptr) where T : struct
		{
			return Marshal.ReadIntPtr(new IntPtr(ptr.ToInt64() + Marshal.OffsetOf(typeof(T), "renderComponent").ToInt64()));
		}

		public static bool ovrAvatarPose_GetBodyComponent(IntPtr avatar, ref ovrAvatarBodyComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBodyComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.leftEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.leftEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.rightEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.rightEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.centerEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.centerEyeTransform);
			component.renderComponent = MarshalRenderComponent<ovrAvatarBodyComponent>(intPtr);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBodyComponent")]
		private static extern IntPtr ovrAvatarPose_GetBodyComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftHandComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightHandComponent_Native(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarAsset_BeginLoading(ulong assetID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarAsset_BeginLoadingLOD(ulong assetId, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarAssetType ovrAvatarAsset_GetType(IntPtr assetHandle);

		public static ovrAvatarMeshAssetData ovrAvatarAsset_GetMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetData));
		}

		public static ovrAvatarMeshAssetDataV2 ovrAvatarAsset_GetCombinedMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetDataV2)Marshal.PtrToStructure(ovrAvatarAsset_GetCombinedMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetDataV2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetCombinedMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetMeshBlendShapeCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeName(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshLastIndex(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeVertices(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetAvatar(IntPtr assetHandle);

		public static ulong[] ovrAvatarAsset_GetCombinedMeshIDs(IntPtr assetHandle)
		{
			uint structure = 0u;
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshIDs_Native(assetHandle, intPtr);
			structure = (uint)Marshal.PtrToStructure(intPtr, typeof(uint));
			ulong[] array = new ulong[structure];
			for (int i = 0; i < structure; i++)
			{
				array[i] = (ulong)Marshal.ReadInt64(ptr, i * Marshal.SizeOf(typeof(ulong)));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshIDs")]
		public static extern IntPtr ovrAvatarAsset_GetCombinedMeshIDs_Native(IntPtr assetHandle, IntPtr count);

		public static void ovrAvatar_GetCombinedMeshAlphaData(IntPtr avatar, ref ulong textureID, ref Vector4 offset)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ulong)));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Vector4)));
			ovrAvatar_GetCombinedMeshAlphaData_Native(avatar, intPtr, intPtr2);
			textureID = (ulong)Marshal.PtrToStructure(intPtr, typeof(ulong));
			offset = (Vector4)Marshal.PtrToStructure(intPtr2, typeof(Vector4));
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetCombinedMeshAlphaData")]
		public static extern IntPtr ovrAvatar_GetCombinedMeshAlphaData_Native(IntPtr avatar, IntPtr textureIDPtr, IntPtr offsetPtr);

		public static ovrAvatarTextureAssetData ovrAvatarAsset_GetTextureData(IntPtr assetPtr)
		{
			return (ovrAvatarTextureAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetTextureData_Native(assetPtr), typeof(ovrAvatarTextureAssetData));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetTextureData")]
		private static extern IntPtr ovrAvatarAsset_GetTextureData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMaterialData")]
		private static extern IntPtr ovrAvatarAsset_GetMaterialData_Native(IntPtr assetPtr);

		public static ovrAvatarMaterialState ovrAvatarAsset_GetMaterialState(IntPtr assetPtr)
		{
			return (ovrAvatarMaterialState)Marshal.PtrToStructure(ovrAvatarAsset_GetMaterialData_Native(assetPtr), typeof(ovrAvatarMaterialState));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarRenderPartType ovrAvatarRenderPart_GetType(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRender ovrAvatarRenderPart_GetSkinnedMeshRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRender_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRender));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRender_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRender_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRenderPBSV2_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMaterialState ovrAvatarSkinnedMeshRender_GetMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarPBSMaterialState ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarExpressiveParameters ovrAvatar_GetExpressiveParameters(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRender_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitOnsetSpeed(IntPtr avatar, float onsetSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitFalloffSpeed(IntPtr avatar, float falloffSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetVisemeMultiplier(IntPtr avatar, float visemeMultiplier);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBS")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(IntPtr renderPart);

		public static void ovrAvatarSkinnedMeshRender_GetBlendShapeParams(IntPtr renderPart, ref ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr ptr = ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(renderPart);
			blendParams.blendShapeParamCount = (uint)Marshal.ReadInt32(ptr);
			Marshal.Copy(new IntPtr(ptr.ToInt64() + ovrAvatarBlendShapeParams_Offsets.blendShapeParams), blendParams.blendShapeParams, 0, (int)blendParams.blendShapeParamCount);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarSkinnedMeshRender_GetBlendShapeParams")]
		private static extern IntPtr ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_ProjectorRender ovrAvatarRenderPart_GetProjectorRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_ProjectorRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetProjectorRender_Native(renderPart), typeof(ovrAvatarRenderPart_ProjectorRender));
		}

		public static ovrAvatarPBSMaterialState[] ovrAvatar_GetBodyPBSMaterialStates(IntPtr renderPart)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			IntPtr intPtr2 = ovrAvatar_GetBodyPBSMaterialStates_Native(renderPart, intPtr);
			ovrAvatarPBSMaterialState[] array = new ovrAvatarPBSMaterialState[Marshal.ReadInt32(intPtr)];
			for (int i = 0; i < array.Length; i++)
			{
				IntPtr ptr = new IntPtr(intPtr2.ToInt64() + i * Marshal.SizeOf(typeof(ovrAvatarPBSMaterialState)));
				array[i] = (ovrAvatarPBSMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarPBSMaterialState));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetBodyPBSMaterialStates")]
		private static extern IntPtr ovrAvatar_GetBodyPBSMaterialStates_Native(IntPtr avatar, IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetProjectorRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetProjectorRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatar_GetReferencedAssetCount(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatar_GetReferencedAsset(IntPtr avatar, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdatePoseFromPacket(IntPtr avatar, IntPtr packet, float secondsFromStart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_BeginRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_EndRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarPacket_GetSize(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrAvatarPacket_GetDurationSeconds(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_Free(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarPacket_Write(IntPtr packet, uint bufferSize, [Out] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_Read(uint bufferSize, [In] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ovrAvatar_SetInternalForceASTCTextures(bool value);

		public static void ovrAvatar_SetForceASTCTextures(bool value)
		{
			ovrAvatar_SetInternalForceASTCTextures(value);
		}

		public static void ovrAvatar_OverrideExpressiveLogic(IntPtr avatar, ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarBlendShapeParams)));
			Marshal.StructureToPtr(blendParams, intPtr, fDeleteOld: false);
			ovrAvatar_OverrideExpressiveLogic_Native(avatar, intPtr);
			Marshal.FreeHGlobal(intPtr);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_OverrideExpressiveLogic")]
		private static extern void ovrAvatar_OverrideExpressiveLogic_Native(IntPtr avatar, IntPtr state);

		public static void ovrAvatar_SetVisemes(IntPtr avatar, ovrAvatarVisemes visemes)
		{
			Marshal.WriteInt32(nativeVisemeData, (int)visemes.visemeParamCount);
			Marshal.Copy(visemes.visemeParams, 0, new IntPtr(nativeVisemeData.ToInt64() + ovrAvatarVisemes_Offsets.visemeParams), (int)visemes.visemeParamCount);
			ovrAvatar_SetVisemes_Native(avatar, nativeVisemeData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_SetVisemes")]
		private static extern void ovrAvatar_SetVisemes_Native(IntPtr avatar, IntPtr visemes);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdateWorldTransform(IntPtr avatar, ovrAvatarTransform transform);

		public static void ovrAvatar_UpdateGazeTargets(ovrAvatarGazeTargets targets)
		{
			Marshal.WriteInt32(nativeGazeTargetsData, (int)targets.targetCount);
			long targets2 = ovrAvatarGazeTargets_Offsets.targets;
			for (uint num = 0u; num < targets.targetCount; num++)
			{
				long num2 = targets2 + num * Marshal.SizeOf(typeof(ovrAvatarGazeTarget));
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.id), (int)targets.targets[num].id);
				scratchBufferFloat[0] = targets.targets[num].worldPosition.x;
				scratchBufferFloat[1] = targets.targets[num].worldPosition.y;
				scratchBufferFloat[2] = targets.targets[num].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.worldPosition), 3);
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.type), (int)targets.targets[num].type);
			}
			ovrAvatar_UpdateGazeTargets_Native(nativeGazeTargetsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateGazeTargets")]
		private static extern void ovrAvatar_UpdateGazeTargets_Native(IntPtr targets);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveGazeTargets(uint targetCount, uint[] ids);

		public static void ovrAvatar_UpdateLights(ovrAvatarLights lights)
		{
			scratchBufferFloat[0] = lights.ambientIntensity;
			Marshal.Copy(scratchBufferFloat, 0, nativeAvatarLightsData, 1);
			Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64()), (int)lights.lightCount);
			long num = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
			for (uint num2 = 0u; num2 < lights.lightCount; num2++)
			{
				long num3 = num + num2 * Marshal.SizeOf(typeof(ovrAvatarLight));
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64()), (int)lights.lights[num2].id);
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64()), (int)lights.lights[num2].type);
				scratchBufferFloat[0] = lights.lights[num2].intensity;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].worldDirection.x;
				scratchBufferFloat[1] = lights.lights[num2].worldDirection.y;
				scratchBufferFloat[2] = lights.lights[num2].worldDirection.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].worldPosition.x;
				scratchBufferFloat[1] = lights.lights[num2].worldPosition.y;
				scratchBufferFloat[2] = lights.lights[num2].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].range;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].spotAngleDeg;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64()), 1);
			}
			ovrAvatar_UpdateLights_Native(nativeAvatarLightsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateLights")]
		private static extern void ovrAvatar_UpdateLights_Native(IntPtr lights);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveLights(uint lightCount, uint[] ids);

		[MonoPInvokeCallback(typeof(LoggingDelegate))]
		public static void LoggingCallback(IntPtr str)
		{
			Marshal.PtrToStringAnsi(str);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RegisterLoggingCallback(LoggingDelegate callback);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLoggingLevel(ovrAvatarLogLevel level);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugTransforms")]
		public static extern IntPtr ovrAvatar_GetDebugTransforms_Native(IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugLines")]
		public static extern IntPtr ovrAvatar_GetDebugLines_Native(IntPtr count);

		public static void ovrAvatar_DrawDebugLines()
		{
			IntPtr intPtr = ovrAvatar_GetDebugLines_Native(DebugLineCountData);
			int num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugLine ovrAvatarDebugLine = default(ovrAvatarDebugLine);
			for (int i = 0; i < num; i++)
			{
				int num2 = i * Marshal.SizeOf(typeof(ovrAvatarDebugLine));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num2), scratchBufferFloat, 0, 9);
				ovrAvatarDebugLine.startPoint.x = scratchBufferFloat[0];
				ovrAvatarDebugLine.startPoint.y = scratchBufferFloat[1];
				ovrAvatarDebugLine.startPoint.z = 0f - scratchBufferFloat[2];
				ovrAvatarDebugLine.endPoint.x = scratchBufferFloat[3];
				ovrAvatarDebugLine.endPoint.y = scratchBufferFloat[4];
				ovrAvatarDebugLine.endPoint.z = 0f - scratchBufferFloat[5];
				ovrAvatarDebugLine.color.x = scratchBufferFloat[6];
				ovrAvatarDebugLine.color.y = scratchBufferFloat[7];
				ovrAvatarDebugLine.color.z = scratchBufferFloat[8];
				ovrAvatarDebugLine.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "context").ToInt64()));
				ovrAvatarDebugLine.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "text").ToInt64()));
				Debug.DrawLine(ovrAvatarDebugLine.startPoint, ovrAvatarDebugLine.endPoint, new Color(ovrAvatarDebugLine.color.x, ovrAvatarDebugLine.color.y, ovrAvatarDebugLine.color.z));
			}
			intPtr = ovrAvatar_GetDebugTransforms_Native(DebugLineCountData);
			num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugTransform ovrAvatarDebugTransform = default(ovrAvatarDebugTransform);
			for (int j = 0; j < num; j++)
			{
				int num3 = j * Marshal.SizeOf(typeof(ovrAvatarDebugTransform));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num3), scratchBufferFloat, 0, 10);
				OvrAvatar.ConvertTransform(scratchBufferFloat, ref ovrAvatarDebugTransform.transform);
				OvrAvatar.ConvertTransform(ovrAvatarDebugTransform.transform, debugLineGo.transform);
				ovrAvatarDebugTransform.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "context").ToInt64()));
				ovrAvatarDebugTransform.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "text").ToInt64()));
				Vector3 vector = 0.1f * debugLineGo.transform.TransformVector(Vector3.up);
				Vector3 vector2 = 0.1f * debugLineGo.transform.TransformVector(Vector3.right);
				Vector3 vector3 = 0.1f * debugLineGo.transform.TransformVector(Vector3.forward);
				Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector, Color.green);
				Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector2, Color.red);
				Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector3, Color.blue);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetDebugDrawContext(uint context);

		public static bool SendEvent(string name, string param = "", string source = "")
		{
			try
			{
				if (ovrPluginVersion == null)
				{
					string text = ovrp_GetVersion();
					if (!string.IsNullOrEmpty(text))
					{
						ovrPluginVersion = new Version(text.Split('-')[0]);
					}
					else
					{
						ovrPluginVersion = new Version(0, 0, 0);
					}
				}
				if (ovrPluginVersion >= OVRP_1_30_0.version)
				{
					return OVRP_1_30_0.ovrp_SendEvent2(name, param, (source.Length == 0) ? "avatar_sdk" : source) == Result.Success;
				}
				return false;
			}
			catch (Exception)
			{
				return false;
			}
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}
	}
}
namespace OVR
{
	public class TestScript : MonoBehaviour
	{
		[InspectorNote("Sound Setup", "Press '1' to play testSound1 and '2' to play testSound2")]
		public SoundFXRef testSound1;

		public SoundFXRef testSound2;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				testSound1.PlaySoundAt(base.transform.position);
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				testSound2.PlaySoundAt(new Vector3(5f, 0f, 0f));
			}
		}
	}
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = UnityEngine.Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[UnityEngine.Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			if (maxPlayingSounds != 0)
			{
				return playingSoundCount < maxPlayingSounds;
			}
			return true;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization
		{
			get
			{
				if (!(theAudioManager != null))
				{
					return false;
				}
				return theAudioManager.enableSpatializedAudio;
			}
		}

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[maxSoundEmitters + 1];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < maxSoundEmitters + 1; i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			return theAudioManager.soundEmitters[idx].time = time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				Debug.LogError(string.Concat("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = ", priority, " TOO MANY PlaySound* calls!"));
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = (soundFX.ospProps.enableSpatialization ? 1f : 0.8f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = UnityEngine.Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, Action onFinished)
		{
			if (emitterIdx >= 0 && emitterIdx < theAudioManager.maxSoundEmitters)
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (emitterIdx >= 0 && emitterIdx < theAudioManager.maxSoundEmitters)
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			if (!(theAudioManager != null))
			{
				return null;
			}
			return theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length
		{
			get
			{
				if (!(audioSource.clip != null))
				{
					return 0f;
				}
				return audioSource.clip.length;
			}
		}

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType == Fade.In) ? 0f : defaultVolume);
			float end = ((fadeType == Fade.In) ? defaultVolume : 0f);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid
		{
			get
			{
				if (soundClips.Length != 0)
				{
					return soundClips[0] != null;
				}
				return false;
			}
		}

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride
		{
			get
			{
				if (soundGroup == null)
				{
					return 1f;
				}
				return soundGroup.volumeOverride;
			}
		}

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = UnityEngine.Random.Range(0, soundClips.Length); num == lastIdx; num = UnityEngine.Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				if (!(soundGroup.mixerGroup != null))
				{
					return defaultMixerGroup;
				}
				return soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return UnityEngine.Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
