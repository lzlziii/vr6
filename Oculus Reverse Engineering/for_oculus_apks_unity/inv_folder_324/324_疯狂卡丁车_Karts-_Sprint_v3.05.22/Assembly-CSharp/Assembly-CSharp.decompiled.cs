using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using CapturePanorama.Internals;
using DigitalOpus.MB.Core;
using ExitGames.Client.Photon;
using Ionic.Crc;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Utilities;
using Newtonsoft.Json.Utilities.LinqBridge;
using Oculus.Platform;
using Oculus.Platform.Models;
using Photon;
using PlayFab;
using PlayFab.ClientModels;
using PlayFab.Internal;
using PlayFab.Json;
using PlayFab.Json.Converters;
using PlayFab.Json.Linq;
using PlayFab.Json.Schema;
using PlayFab.Json.Serialization;
using PlayFab.Json.Utilities;
using PlayFab.UUnit;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.VR;
using UnityStandardAssets.CrossPlatformInput;

[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
namespace CapturePanorama
{
	public class CapturePanorama : UnityEngine.MonoBehaviour
	{
		public enum ImageFormat
		{
			PNG,
			JPEG,
			BMP
		}

		public enum AntiAliasing
		{
			_1 = 1,
			_2 = 2,
			_4 = 4,
			_8 = 8
		}

		public string panoramaName;

		public string qualitySetting;

		public KeyCode captureKey = KeyCode.P;

		public ImageFormat imageFormat;

		public bool captureStereoscopic;

		public float interpupillaryDistance = 0.0635f;

		public int numCirclePoints = 128;

		public int panoramaWidth = 8192;

		public AntiAliasing antiAliasing = AntiAliasing._8;

		public int ssaaFactor = 1;

		public string saveImagePath = string.Empty;

		public bool saveCubemap;

		public bool uploadImages;

		public bool useDefaultOrientation;

		public bool useGpuTransform = true;

		public float cpuMillisecondsPerFrame = 8.333333f;

		public bool captureEveryFrame;

		public int frameRate = 30;

		public int maxFramesToRecord;

		public int frameNumberDigits = 6;

		public AudioClip startSound;

		public AudioClip doneSound;

		public AudioClip failSound;

		public bool fadeDuringCapture = true;

		public float fadeTime = 0.25f;

		public UnityEngine.Color fadeColor = new UnityEngine.Color(0f, 0f, 0f, 1f);

		public Material fadeMaterial;

		public ComputeShader convertPanoramaShader;

		public ComputeShader convertPanoramaStereoShader;

		public ComputeShader textureToBufferShader;

		public bool enableDebugging;

		private string apiUrl = "http://alpha.vrchive.com/api/1/";

		private string apiKey = "0b26e4dca20793a83fd92ad83e3e859e";

		private GameObject[] camGos;

		private Camera cam;

		private ImageEffectCopyCamera copyCameraScript;

		private bool capturingEveryFrame;

		private bool usingGpuTransform;

		private CubemapFace[] faces;

		private int panoramaHeight;

		private int cameraWidth;

		private int cameraHeight;

		private RenderTexture cubemapRenderTexture;

		private Texture2D forceWaitTexture;

		private int convertPanoramaKernelIdx = -1;

		private int convertPanoramaYPositiveKernelIdx = -1;

		private int convertPanoramaYNegativeKernelIdx = -1;

		private int textureToBufferIdx = -1;

		private int renderStereoIdx = -1;

		private int[] convertPanoramaKernelIdxs;

		private byte[] imageFileBytes;

		private string videoBaseName = string.Empty;

		private int frameNumber;

		private const int ResultBufferSlices = 8;

		private float hFov = -1f;

		private float vFov = -1f;

		private float hFovAdjustDegrees = -1f;

		private float vFovAdjustDegrees = -1f;

		private float circleRadius = -1f;

		private int threadsX = 32;

		private int threadsY = 32;

		private int numCameras;

		private const int CamerasPerCirclePoint = 4;

		private uint[] cameraPixels;

		private uint[] resultPixels;

		private float tanHalfHFov;

		private float tanHalfVFov;

		private float hFovAdjust;

		private float vFovAdjust;

		private int overlapTextures;

		private bool initializeFailed = true;

		private AudioSource audioSource;

		private const uint BufferSentinelValue = 1419455993u;

		private int lastConfiguredPanoramaWidth;

		private int lastConfiguredNumCirclePoints;

		private int lastConfiguredSsaaFactor;

		private float lastConfiguredInterpupillaryDistance;

		private bool lastConfiguredCaptureStereoscopic;

		private bool lastConfiguredSaveCubemap;

		private bool lastConfiguredUseGpuTransform;

		private AntiAliasing lastConfiguredAntiAliasing = AntiAliasing._1;

		private static CapturePanorama instance;

		internal bool Capturing;

		private static List<Process> resizingProcessList = new List<Process>();

		private static List<string> resizingFilenames = new List<string>();

		private System.Drawing.Imaging.ImageFormat FormatToDrawingFormat(ImageFormat format)
		{
			return format switch
			{
				ImageFormat.PNG => System.Drawing.Imaging.ImageFormat.Png, 
				ImageFormat.JPEG => System.Drawing.Imaging.ImageFormat.Jpeg, 
				ImageFormat.BMP => System.Drawing.Imaging.ImageFormat.Bmp, 
				_ => System.Drawing.Imaging.ImageFormat.Png, 
			};
		}

		private string FormatMimeType(ImageFormat format)
		{
			return format switch
			{
				ImageFormat.PNG => "image/png", 
				ImageFormat.JPEG => "image/jpeg", 
				ImageFormat.BMP => "image/bmp", 
				_ => string.Empty, 
			};
		}

		private string FormatToExtension(ImageFormat format)
		{
			return format switch
			{
				ImageFormat.PNG => "png", 
				ImageFormat.JPEG => "jpg", 
				ImageFormat.BMP => "bmp", 
				_ => string.Empty, 
			};
		}

		public void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Debug.LogError("More than one CapturePanorama instance detected.");
			}
		}

		public void Start()
		{
			audioSource = base.gameObject.AddComponent<AudioSource>();
			audioSource.spatialBlend = 0f;
			audioSource.Play();
			Reinitialize();
		}

		private float IpdScaleFunction(float latitudeNormalized)
		{
			return 1.5819767f * Mathf.Exp((0f - latitudeNormalized) * latitudeNormalized) - 0.5819767f;
		}

		public void OnDestroy()
		{
			Cleanup();
		}

		private void Cleanup()
		{
			faces = null;
			UnityEngine.Object.Destroy(copyCameraScript);
			UnityEngine.Object.Destroy(cam);
			if (camGos != null)
			{
				for (int num = camGos.Length - 1; num >= 0; num--)
				{
					if (camGos[num] != null)
					{
						UnityEngine.Object.Destroy(camGos[num]);
					}
				}
			}
			camGos = null;
			numCameras = -1;
			hFov = (vFov = -1f);
			if (cubemapRenderTexture != null)
			{
				UnityEngine.Object.Destroy(cubemapRenderTexture);
			}
			cubemapRenderTexture = null;
			convertPanoramaKernelIdx = (renderStereoIdx = (textureToBufferIdx = -1));
			convertPanoramaKernelIdxs = null;
			resultPixels = (cameraPixels = null);
			if (forceWaitTexture != null)
			{
				UnityEngine.Object.Destroy(forceWaitTexture);
			}
			forceWaitTexture = new Texture2D(1, 1);
		}

		private void Reinitialize()
		{
			try
			{
				ReinitializeBody();
			}
			catch (Exception)
			{
				Cleanup();
				throw;
			}
		}

		private void ReinitializeBody()
		{
			Log("Settings changed, calling Reinitialize()");
			initializeFailed = true;
			if (!SystemInfo.supportsComputeShaders)
			{
				UnityEngine.Debug.LogWarning("CapturePanorama requires compute shaders. Your system does not support them. On PC, compute shaders require DirectX 11, Windows Vista or later, and a GPU capable of Shader Model 5.0.");
				return;
			}
			lastConfiguredCaptureStereoscopic = captureStereoscopic;
			lastConfiguredPanoramaWidth = panoramaWidth;
			lastConfiguredInterpupillaryDistance = interpupillaryDistance;
			lastConfiguredNumCirclePoints = numCirclePoints;
			lastConfiguredSsaaFactor = ssaaFactor;
			lastConfiguredAntiAliasing = antiAliasing;
			lastConfiguredSaveCubemap = saveCubemap;
			lastConfiguredUseGpuTransform = useGpuTransform;
			Cleanup();
			faces = new CubemapFace[6]
			{
				CubemapFace.PositiveX,
				CubemapFace.NegativeX,
				CubemapFace.PositiveY,
				CubemapFace.NegativeY,
				CubemapFace.PositiveZ,
				CubemapFace.NegativeZ
			};
			for (int i = 0; i < faces.Length; i++)
			{
			}
			panoramaHeight = panoramaWidth / 2;
			camGos = new GameObject[3];
			for (int j = 0; j < 3; j++)
			{
				camGos[j] = new GameObject("PanoramaCaptureCamera" + j);
				camGos[j].hideFlags = HideFlags.HideAndDontSave;
				if (j > 0)
				{
					camGos[j].transform.parent = camGos[j - 1].transform;
				}
			}
			camGos[2].AddComponent<Camera>();
			cam = camGos[2].GetComponent<Camera>();
			cam.enabled = false;
			camGos[2].AddComponent<ImageEffectCopyCamera>();
			copyCameraScript = camGos[2].GetComponent<ImageEffectCopyCamera>();
			copyCameraScript.enabled = false;
			numCameras = faces.Length;
			hFov = (vFov = 90f);
			if (captureStereoscopic)
			{
				float num = 360f / (float)numCirclePoints;
				float num2 = 0.001f;
				float b = 2f * ((float)Math.PI / 2f - Mathf.Acos(IpdScaleFunction(0.5f))) * 360f / ((float)Math.PI * 2f);
				hFov = Mathf.Max(90f + num, b) + num2;
				vFov = 90f;
				numCameras = 2 + numCirclePoints * 4;
				circleRadius = interpupillaryDistance / 2f;
				hFovAdjustDegrees = hFov / 2f;
				vFovAdjustDegrees = vFov / 2f;
			}
			double num3 = (double)panoramaWidth * 90.0 / 360.0;
			cameraWidth = (int)Math.Ceiling(Math.Tan(hFov * ((float)Math.PI * 2f) / 360f / 2f) * num3 * (double)ssaaFactor);
			cameraHeight = (int)Math.Ceiling(Math.Tan(vFov * ((float)Math.PI * 2f) / 360f / 2f) * num3 * (double)ssaaFactor);
			Log("Number of cameras: " + numCameras);
			Log("Camera dimensions: " + cameraWidth + "x" + cameraHeight);
			usingGpuTransform = useGpuTransform && convertPanoramaShader != null;
			cubemapRenderTexture = new RenderTexture(cameraWidth, cameraHeight, 24, RenderTextureFormat.ARGB32);
			cubemapRenderTexture.antiAliasing = (int)antiAliasing;
			cubemapRenderTexture.Create();
			if (usingGpuTransform)
			{
				convertPanoramaKernelIdx = convertPanoramaShader.FindKernel("CubeMapToEquirectangular");
				convertPanoramaYPositiveKernelIdx = convertPanoramaShader.FindKernel("CubeMapToEquirectangularPositiveY");
				convertPanoramaYNegativeKernelIdx = convertPanoramaShader.FindKernel("CubeMapToEquirectangularNegativeY");
				convertPanoramaKernelIdxs = new int[3] { convertPanoramaKernelIdx, convertPanoramaYPositiveKernelIdx, convertPanoramaYNegativeKernelIdx };
				convertPanoramaShader.SetInt("equirectangularWidth", panoramaWidth);
				convertPanoramaShader.SetInt("equirectangularHeight", panoramaHeight);
				convertPanoramaShader.SetInt("ssaaFactor", ssaaFactor);
				convertPanoramaShader.SetInt("cameraWidth", cameraWidth);
				convertPanoramaShader.SetInt("cameraHeight", cameraHeight);
				int num4 = (panoramaHeight + 8 - 1) / 8;
				int num5 = panoramaWidth;
				int num6 = ((!captureStereoscopic) ? num4 : (2 * panoramaHeight));
				resultPixels = new uint[num5 * num6 + 1];
			}
			textureToBufferIdx = textureToBufferShader.FindKernel("TextureToBuffer");
			textureToBufferShader.SetInt("width", cameraWidth);
			textureToBufferShader.SetInt("height", cameraHeight);
			textureToBufferShader.SetFloat("gamma", (QualitySettings.activeColorSpace != ColorSpace.Linear) ? 1f : 0.45454544f);
			renderStereoIdx = convertPanoramaStereoShader.FindKernel("RenderStereo");
			if ((saveCubemap || !usingGpuTransform) && (cameraPixels == null || cameraPixels.Length != numCameras * cameraWidth * cameraHeight))
			{
				cameraPixels = new uint[numCameras * cameraWidth * cameraHeight + 1];
			}
			tanHalfHFov = Mathf.Tan(hFov * ((float)Math.PI * 2f) / 360f / 2f);
			tanHalfVFov = Mathf.Tan(vFov * ((float)Math.PI * 2f) / 360f / 2f);
			hFovAdjust = hFovAdjustDegrees * ((float)Math.PI * 2f) / 360f;
			vFovAdjust = vFovAdjustDegrees * ((float)Math.PI * 2f) / 360f;
			if (captureStereoscopic && usingGpuTransform)
			{
				convertPanoramaStereoShader.SetFloat("tanHalfHFov", tanHalfHFov);
				convertPanoramaStereoShader.SetFloat("tanHalfVFov", tanHalfVFov);
				convertPanoramaStereoShader.SetFloat("hFovAdjust", hFovAdjust);
				convertPanoramaStereoShader.SetFloat("vFovAdjust", vFovAdjust);
				convertPanoramaStereoShader.SetFloat("interpupillaryDistance", interpupillaryDistance);
				convertPanoramaStereoShader.SetFloat("circleRadius", circleRadius);
				convertPanoramaStereoShader.SetInt("numCirclePoints", numCirclePoints);
				convertPanoramaStereoShader.SetInt("equirectangularWidth", panoramaWidth);
				convertPanoramaStereoShader.SetInt("equirectangularHeight", panoramaHeight);
				convertPanoramaStereoShader.SetInt("cameraWidth", cameraWidth);
				convertPanoramaStereoShader.SetInt("cameraHeight", cameraHeight);
				convertPanoramaStereoShader.SetInt("ssaaFactor", ssaaFactor);
			}
			initializeFailed = false;
		}

		private void Log(string s)
		{
			if (enableDebugging)
			{
				UnityEngine.Debug.Log(s, this);
			}
		}

		public void Update()
		{
			bool keyDown = Input.GetKeyDown(captureKey);
			if (initializeFailed || panoramaWidth < 4 || (captureStereoscopic && numCirclePoints < 8))
			{
				if (keyDown)
				{
					if (panoramaWidth < 4)
					{
						UnityEngine.Debug.LogError("Panorama Width must be at least 4. No panorama captured.");
					}
					if (captureStereoscopic && numCirclePoints < 8)
					{
						UnityEngine.Debug.LogError("Num Circle Points must be at least 8. No panorama captured.");
					}
					if (initializeFailed)
					{
						UnityEngine.Debug.LogError("Initialization of Capture Panorama script failed. Cannot capture content.");
					}
					if (failSound != null && Camera.main != null)
					{
						audioSource.PlayOneShot(failSound);
					}
				}
				return;
			}
			if (captureStereoscopic != lastConfiguredCaptureStereoscopic || panoramaWidth != lastConfiguredPanoramaWidth || interpupillaryDistance != lastConfiguredInterpupillaryDistance || numCirclePoints != lastConfiguredNumCirclePoints || ssaaFactor != lastConfiguredSsaaFactor || antiAliasing != lastConfiguredAntiAliasing || saveCubemap != lastConfiguredSaveCubemap || useGpuTransform != lastConfiguredUseGpuTransform)
			{
				Reinitialize();
			}
			if (capturingEveryFrame)
			{
				if ((captureKey != 0 && keyDown) || (maxFramesToRecord > 0 && frameNumber >= maxFramesToRecord))
				{
					StopCaptureEveryFrame();
					return;
				}
				CaptureScreenshotSync(videoBaseName + "_" + frameNumber.ToString(new string('0', frameNumberDigits)));
				frameNumber++;
			}
			else if (captureKey != 0 && keyDown && !Capturing)
			{
				if (captureEveryFrame)
				{
					StartCaptureEveryFrame();
					return;
				}
				string text = $"{panoramaName}_{DateTime.Now:yyyy-MM-dd_HH-mm-ss-fff}";
				Log("Panorama capture key pressed, capturing " + text);
				CaptureScreenshotAsync(text);
			}
		}

		public void StartCaptureEveryFrame()
		{
			Time.captureFramerate = frameRate;
			videoBaseName = $"{panoramaName}_{DateTime.Now:yyyy-MM-dd_HH-mm-ss-fff}";
			frameNumber = 0;
			capturingEveryFrame = true;
		}

		public void StopCaptureEveryFrame()
		{
			Time.captureFramerate = 0;
			capturingEveryFrame = false;
		}

		public void CaptureScreenshotSync(string filenameBase)
		{
			IEnumerator enumerator = CaptureScreenshotAsyncHelper(filenameBase, async: false);
			while (enumerator.MoveNext())
			{
			}
		}

		public void CaptureScreenshotAsync(string filenameBase)
		{
			StartCoroutine(CaptureScreenshotAsyncHelper(filenameBase, async: true));
		}

		private void SetFadersEnabled(IEnumerable<ScreenFadeControl> fadeControls, bool value)
		{
			foreach (ScreenFadeControl fadeControl in fadeControls)
			{
				fadeControl.enabled = value;
			}
		}

		public IEnumerator FadeOut(IEnumerable<ScreenFadeControl> fadeControls)
		{
			Log("Doing fade out");
			float elapsedTime = 0f;
			UnityEngine.Color color = fadeColor;
			color.a = 0f;
			fadeMaterial.color = color;
			SetFadersEnabled(fadeControls, value: true);
			while (elapsedTime < fadeTime)
			{
				yield return new WaitForEndOfFrame();
				elapsedTime += Time.deltaTime;
				color.a = Mathf.Clamp01(elapsedTime / fadeTime);
				fadeMaterial.color = color;
			}
		}

		public IEnumerator FadeIn(IEnumerable<ScreenFadeControl> fadeControls)
		{
			Log("Fading back in");
			float elapsedTime = 0f;
			UnityEngine.Color color2 = fadeColor;
			fadeMaterial.color = color2;
			UnityEngine.Color color = color2;
			while (elapsedTime < fadeTime)
			{
				yield return new WaitForEndOfFrame();
				elapsedTime += Time.deltaTime;
				color.a = 1f - Mathf.Clamp01(elapsedTime / fadeTime);
				fadeMaterial.color = color;
			}
			SetFadersEnabled(fadeControls, value: false);
		}

		public IEnumerator CaptureScreenshotAsyncHelper(string filenameBase, bool async)
		{
			if (async)
			{
				while (Capturing)
				{
					yield return null;
				}
			}
			Capturing = true;
			if (!OnCaptureStart())
			{
				audioSource.PlayOneShot(failSound);
				Capturing = false;
				yield break;
			}
			Camera[] cameras = GetCaptureCameras();
			Array.Sort(cameras, (Camera x, Camera y) => x.depth.CompareTo(y.depth));
			if (cameras.Length == 0)
			{
				UnityEngine.Debug.LogWarning("No cameras found to capture");
				audioSource.PlayOneShot(failSound);
				Capturing = false;
				yield break;
			}
			if (antiAliasing != AntiAliasing._1)
			{
				Camera[] array = cameras;
				foreach (Camera camera in array)
				{
					if (camera.actualRenderingPath == RenderingPath.DeferredLighting || camera.actualRenderingPath == RenderingPath.DeferredShading)
					{
						UnityEngine.Debug.LogWarning("CapturePanorama: Setting Anti Aliasing=1 because at least one camera in deferred mode. Use SSAA setting or Antialiasing image effect if needed.");
						antiAliasing = AntiAliasing._1;
						Reinitialize();
						break;
					}
				}
			}
			Log("Starting panorama capture");
			if (!captureEveryFrame && startSound != null && Camera.main != null)
			{
				audioSource.PlayOneShot(startSound);
			}
			List<ScreenFadeControl> fadeControls = new List<ScreenFadeControl>();
			Camera[] allCameras = Camera.allCameras;
			foreach (Camera camera2 in allCameras)
			{
				if (camera2.isActiveAndEnabled && camera2.targetTexture == null)
				{
					ScreenFadeControl screenFadeControl = camera2.gameObject.AddComponent<ScreenFadeControl>();
					screenFadeControl.fadeMaterial = fadeMaterial;
					fadeControls.Add(screenFadeControl);
				}
			}
			SetFadersEnabled(fadeControls, value: false);
			if (fadeDuringCapture && async)
			{
				yield return StartCoroutine(FadeOut(fadeControls));
			}
			for (int j = 0; j < 2; j++)
			{
				yield return new WaitForEndOfFrame();
			}
			ComputeBuffer convertPanoramaResultBuffer2 = null;
			ComputeBuffer forceWaitResultConvertPanoramaStereoBuffer = null;
			if (usingGpuTransform)
			{
				if (captureStereoscopic)
				{
					convertPanoramaResultBuffer2 = new ComputeBuffer(panoramaWidth * panoramaHeight * 2 + 1, 4);
					convertPanoramaStereoShader.SetBuffer(renderStereoIdx, "result", convertPanoramaResultBuffer2);
					forceWaitResultConvertPanoramaStereoBuffer = new ComputeBuffer(1, 4);
					convertPanoramaStereoShader.SetBuffer(renderStereoIdx, "forceWaitResultBuffer", forceWaitResultConvertPanoramaStereoBuffer);
				}
				else
				{
					int num = (panoramaHeight + 8 - 1) / 8;
					convertPanoramaResultBuffer2 = new ComputeBuffer(panoramaWidth * num + 1, 4);
					int[] array2 = convertPanoramaKernelIdxs;
					foreach (int kernelIndex in array2)
					{
						convertPanoramaShader.SetBuffer(kernelIndex, "result", convertPanoramaResultBuffer2);
					}
				}
			}
			int cameraPixelsBufferNumTextures = numCameras;
			overlapTextures = 0;
			int circlePointCircularBufferSize = 0;
			if (captureStereoscopic && usingGpuTransform)
			{
				overlapTextures = ((ssaaFactor == 1) ? 1 : 2);
				circlePointCircularBufferSize = 1 + overlapTextures;
				cameraPixelsBufferNumTextures = Math.Min(numCameras, 2 + 2 * circlePointCircularBufferSize);
			}
			ComputeBuffer cameraPixelsBuffer = new ComputeBuffer(cameraPixelsBufferNumTextures * cameraWidth * cameraHeight + 1, 4);
			textureToBufferShader.SetBuffer(textureToBufferIdx, "result", cameraPixelsBuffer);
			textureToBufferShader.SetInt("sentinelIdx", cameraPixelsBuffer.count - 1);
			if (usingGpuTransform && !captureStereoscopic)
			{
				convertPanoramaShader.SetInt("cameraPixelsSentinelIdx", cameraPixelsBuffer.count - 1);
				convertPanoramaShader.SetInt("sentinelIdx", convertPanoramaResultBuffer2.count - 1);
				int[] array3 = convertPanoramaKernelIdxs;
				foreach (int kernelIndex2 in array3)
				{
					convertPanoramaShader.SetBuffer(kernelIndex2, "cameraPixels", cameraPixelsBuffer);
				}
			}
			if (usingGpuTransform && captureStereoscopic)
			{
				convertPanoramaStereoShader.SetInt("cameraPixelsSentinelIdx", cameraPixelsBuffer.count - 1);
				convertPanoramaStereoShader.SetBuffer(renderStereoIdx, "cameraPixels", cameraPixelsBuffer);
			}
			ComputeBuffer forceWaitResultTextureToBufferBuffer = new ComputeBuffer(1, 4);
			textureToBufferShader.SetBuffer(textureToBufferIdx, "forceWaitResultBuffer", forceWaitResultTextureToBufferBuffer);
			float startTime = Time.realtimeSinceStartup;
			Quaternion headOrientation = Quaternion.identity;
			Log("Rendering camera views");
			Camera[] array4 = cameras;
			foreach (Camera camera3 in array4)
			{
				Log("Camera name: " + camera3.gameObject.name);
			}
			Dictionary<Camera, List<ImageEffectCopyCamera.InstanceMethodPair>> methodMap = new Dictionary<Camera, List<ImageEffectCopyCamera.InstanceMethodPair>>();
			Camera[] array5 = cameras;
			foreach (Camera camera4 in array5)
			{
				methodMap[camera4] = ImageEffectCopyCamera.GenerateMethodList(camera4);
			}
			string suffix = "." + FormatToExtension(imageFormat);
			string filePath = string.Empty;
			string imagePath = saveImagePath;
			if (imagePath == null || imagePath == string.Empty)
			{
				imagePath = UnityEngine.Application.dataPath + "/..";
			}
			convertPanoramaStereoShader.SetInt("circlePointCircularBufferSize", circlePointCircularBufferSize);
			int nextCirclePointCircularBufferStart = 0;
			int nextCirclePointStart = 0;
			int writeIdx = 0;
			int ilimit = ((!usingGpuTransform) ? numCameras : (numCameras + overlapTextures * 4));
			int leftRightPhaseEnd = (ilimit - 2) / 2 + 2;
			int circlePointsRendered = 0;
			int saveCubemapImageNum = 0;
			Log("Changing quality level");
			int saveQualityLevel = QualitySettings.GetQualityLevel();
			bool qualitySettingWasChanged = false;
			string[] qualitySettingNames = QualitySettings.names;
			if (qualitySetting != qualitySettingNames[saveQualityLevel])
			{
				for (int num4 = 0; num4 < qualitySettingNames.Length; num4++)
				{
					string text = qualitySettingNames[num4];
					if (text == qualitySetting)
					{
						QualitySettings.SetQualityLevel(num4, applyExpensiveChanges: false);
						qualitySettingWasChanged = true;
					}
				}
				if (qualitySetting != string.Empty && !qualitySettingWasChanged)
				{
					UnityEngine.Debug.LogError("Quality setting specified for CapturePanorama is invalid, ignoring.", this);
				}
			}
			BeforeRenderPanorama();
			RenderTexture.active = null;
			for (int num5 = 0; num5 < ilimit; num5++)
			{
				if (captureStereoscopic)
				{
					if (num5 < 2)
					{
						camGos[1].transform.localPosition = Vector3.zero;
						camGos[1].transform.localRotation = Quaternion.Euler((num5 != 0) ? (-90f) : 90f, 0f, 0f);
					}
					else
					{
						int num6;
						int num7;
						if (num5 < leftRightPhaseEnd)
						{
							num6 = num5 - 2;
							num7 = 0;
						}
						else
						{
							num6 = num5 - leftRightPhaseEnd;
							num7 = 2;
						}
						int num8 = num6 / 2 % numCirclePoints;
						int num9 = num6 % 2 + num7;
						float num10 = 360f * (float)num8 / (float)numCirclePoints;
						camGos[1].transform.localPosition = Quaternion.Euler(0f, num10, 0f) * Vector3.forward * circleRadius;
						if (num9 < 2)
						{
							camGos[1].transform.localRotation = Quaternion.Euler(0f, num10 + ((num9 != 0) ? hFovAdjustDegrees : (0f - hFovAdjustDegrees)), 0f);
						}
						else
						{
							camGos[1].transform.localRotation = Quaternion.Euler((num9 != 2) ? vFovAdjustDegrees : (0f - vFovAdjustDegrees), num10, 0f);
						}
						if (num9 == 1 || num9 == 3)
						{
							circlePointsRendered++;
						}
					}
				}
				else
				{
					switch ((CubemapFace)num5)
					{
					case CubemapFace.PositiveX:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
						break;
					case CubemapFace.NegativeX:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, -90f, 0f);
						break;
					case CubemapFace.PositiveY:
						camGos[1].transform.localRotation = Quaternion.Euler(90f, 0f, 0f);
						break;
					case CubemapFace.NegativeY:
						camGos[1].transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
						break;
					case CubemapFace.PositiveZ:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
						break;
					case CubemapFace.NegativeZ:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
						break;
					}
				}
				Camera[] array6 = cameras;
				foreach (Camera camera5 in array6)
				{
					camGos[2].transform.parent = null;
					cam.CopyFrom(camera5);
					camGos[0].transform.localPosition = cam.transform.localPosition;
					camGos[0].transform.localRotation = cam.transform.localRotation;
					camGos[2].transform.parent = camGos[1].transform;
					cam.transform.localPosition = Vector3.zero;
					cam.transform.localRotation = Quaternion.identity;
					copyCameraScript.enabled = methodMap[camera5].Count > 0;
					copyCameraScript.onRenderImageMethods = methodMap[camera5];
					cam.fieldOfView = vFov;
					camGos[0].transform.rotation *= Quaternion.Inverse(headOrientation);
					if (useDefaultOrientation)
					{
						camGos[0].transform.rotation = Quaternion.identity;
					}
					cam.targetTexture = cubemapRenderTexture;
					cam.ResetAspect();
					Vector3 position = camera5.transform.position;
					Quaternion rotation = camera5.transform.rotation;
					float fieldOfView = camera5.fieldOfView;
					RenderTexture targetTexture = camera5.targetTexture;
					camera5.transform.position = cam.transform.position;
					camera5.transform.rotation = cam.transform.rotation;
					camera5.fieldOfView = cam.fieldOfView;
					cam.Render();
					camera5.transform.position = position;
					camera5.transform.rotation = rotation;
					camera5.fieldOfView = fieldOfView;
					camera5.targetTexture = targetTexture;
				}
				RenderTexture.active = cubemapRenderTexture;
				forceWaitTexture.ReadPixels(new Rect(cameraWidth - 1, cameraHeight - 1, 1f, 1f), 0, 0);
				int num12 = 1000000 + num5;
				textureToBufferShader.SetInt("forceWaitValue", num12);
				textureToBufferShader.SetTexture(textureToBufferIdx, "source", cubemapRenderTexture);
				textureToBufferShader.SetInt("startIdx", writeIdx * cameraWidth * cameraHeight);
				textureToBufferShader.Dispatch(textureToBufferIdx, (cameraWidth + threadsX - 1) / threadsX, (cameraHeight + threadsY - 1) / threadsY, 1);
				uint[] array7 = new uint[1];
				forceWaitResultTextureToBufferBuffer.GetData(array7);
				if (array7[0] != num12)
				{
					UnityEngine.Debug.LogError("TextureToBufferShader: Unexpected forceWaitResult value " + array7[0] + ", should be " + num12);
				}
				if (saveCubemap && (num5 < 2 || (num5 >= 2 && num5 < 2 + numCirclePoints * 2) || (num5 >= leftRightPhaseEnd && num5 < leftRightPhaseEnd + numCirclePoints * 2)))
				{
					cameraPixelsBuffer.GetData(cameraPixels);
					if (cameraPixels[cameraPixelsBuffer.count - 1] != 1419455993)
					{
						ReportOutOfGraphicsMemory();
					}
					SaveCubemapImage(cameraPixels, filenameBase, suffix, imagePath, saveCubemapImageNum, writeIdx);
					saveCubemapImageNum++;
				}
				writeIdx++;
				if (writeIdx >= cameraPixelsBufferNumTextures)
				{
					writeIdx = 2;
				}
				if (captureStereoscopic && usingGpuTransform && (num5 - 2 + 1) % 2 == 0 && (circlePointsRendered - nextCirclePointStart >= circlePointCircularBufferSize || num5 + 1 == 2 + (ilimit - 2) / 2 || num5 + 1 == ilimit))
				{
					num12 = 2000000 + num5;
					convertPanoramaStereoShader.SetInt("forceWaitValue", num12);
					convertPanoramaStereoShader.SetInt("leftRightPass", (num5 < leftRightPhaseEnd) ? 1 : 0);
					convertPanoramaStereoShader.SetInt("circlePointStart", nextCirclePointStart);
					convertPanoramaStereoShader.SetInt("circlePointEnd", (cameraPixelsBufferNumTextures >= numCameras) ? (circlePointsRendered + 1) : circlePointsRendered);
					convertPanoramaStereoShader.SetInt("circlePointCircularBufferStart", nextCirclePointCircularBufferStart);
					convertPanoramaStereoShader.Dispatch(renderStereoIdx, (panoramaWidth + threadsX - 1) / threadsX, (panoramaHeight + threadsY - 1) / threadsY, 2);
					forceWaitResultConvertPanoramaStereoBuffer.GetData(array7);
					if (array7[0] != num12)
					{
						UnityEngine.Debug.LogError("ConvertPanoramaStereoShader: Unexpected forceWaitResult value " + array7[0] + ", should be " + num12);
					}
					if (num5 + 1 == leftRightPhaseEnd)
					{
						nextCirclePointCircularBufferStart = (nextCirclePointCircularBufferStart + circlePointCircularBufferSize) % circlePointCircularBufferSize;
						nextCirclePointStart = 0;
						circlePointsRendered = 0;
					}
					else
					{
						nextCirclePointStart = circlePointsRendered - overlapTextures;
						nextCirclePointCircularBufferStart = (nextCirclePointCircularBufferStart + circlePointCircularBufferSize - overlapTextures) % circlePointCircularBufferSize;
					}
				}
				RenderTexture.active = null;
			}
			AfterRenderPanorama();
			Log("Resetting quality level");
			if (qualitySettingWasChanged)
			{
				QualitySettings.SetQualityLevel(saveQualityLevel, applyExpensiveChanges: false);
			}
			if (saveCubemap || !usingGpuTransform)
			{
				cameraPixelsBuffer.GetData(cameraPixels);
				if (cameraPixels[cameraPixelsBuffer.count - 1] != 1419455993)
				{
					ReportOutOfGraphicsMemory();
				}
			}
			RenderTexture.active = null;
			if (saveCubemap && (!captureStereoscopic || !usingGpuTransform))
			{
				for (int num13 = 0; num13 < numCameras; num13++)
				{
					int bufferIdx = num13;
					SaveCubemapImage(cameraPixels, filenameBase, suffix, imagePath, num13, bufferIdx);
				}
			}
			for (int i = 0; i < 2; i++)
			{
				yield return new WaitForEndOfFrame();
			}
			if (async && !usingGpuTransform && fadeDuringCapture)
			{
				yield return StartCoroutine(FadeIn(fadeControls));
			}
			filePath = imagePath + "/" + filenameBase + suffix;
			bool producedImageSuccess2 = false;
			Bitmap bitmap = new Bitmap(panoramaWidth, panoramaHeight * ((!captureStereoscopic) ? 1 : 2), PixelFormat.Format32bppArgb);
			BitmapData bmpData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.WriteOnly, bitmap.PixelFormat);
			IntPtr ptr = bmpData.Scan0;
			byte[] pixelValues = new byte[Math.Abs(bmpData.Stride) * bitmap.Height];
			if (async)
			{
				yield return StartCoroutine(CubemapToEquirectangular(cameraPixelsBuffer, cameraPixels, convertPanoramaResultBuffer2, cameraWidth, cameraHeight, pixelValues, bmpData.Stride, panoramaWidth, panoramaHeight, ssaaFactor, async));
			}
			else
			{
				IEnumerator enumerator = CubemapToEquirectangular(cameraPixelsBuffer, cameraPixels, convertPanoramaResultBuffer2, cameraWidth, cameraHeight, pixelValues, bmpData.Stride, panoramaWidth, panoramaHeight, ssaaFactor, async);
				while (enumerator.MoveNext())
				{
				}
			}
			producedImageSuccess2 = pixelValues[3] == byte.MaxValue;
			yield return null;
			Marshal.Copy(pixelValues, 0, ptr, pixelValues.Length);
			bitmap.UnlockBits(bmpData);
			yield return null;
			Log("Time to take panorama screenshot: " + (Time.realtimeSinceStartup - startTime) + " sec");
			if (producedImageSuccess2)
			{
				Thread thread = new Thread((ThreadStart)delegate
				{
					Log("Saving equirectangular image");
					bitmap.Save(filePath, FormatToDrawingFormat(imageFormat));
				});
				thread.Start();
				while (thread.ThreadState == System.Threading.ThreadState.Running)
				{
					if (async)
					{
						yield return null;
					}
					else
					{
						Thread.Sleep(0);
					}
				}
			}
			bitmap.Dispose();
			ComputeBuffer[] array8 = new ComputeBuffer[4] { convertPanoramaResultBuffer2, cameraPixelsBuffer, forceWaitResultConvertPanoramaStereoBuffer, forceWaitResultTextureToBufferBuffer };
			for (int num14 = 0; num14 < array8.Length; num14++)
			{
				array8[num14]?.Release();
			}
			ComputeBuffer computeBuffer = null;
			convertPanoramaResultBuffer2 = computeBuffer;
			if (async && usingGpuTransform && fadeDuringCapture)
			{
				yield return StartCoroutine(FadeIn(fadeControls));
			}
			foreach (ScreenFadeControl item in fadeControls)
			{
				UnityEngine.Object.Destroy(item);
			}
			fadeControls.Clear();
			if (producedImageSuccess2 && uploadImages && !captureEveryFrame)
			{
				Log("Uploading image");
				imageFileBytes = File.ReadAllBytes(filePath);
				string mimeType = FormatMimeType(imageFormat);
				if (async)
				{
					yield return StartCoroutine(UploadImage(imageFileBytes, filenameBase + suffix, mimeType, async));
					yield break;
				}
				IEnumerator enumerator3 = UploadImage(imageFileBytes, filenameBase + suffix, mimeType, async);
				while (enumerator3.MoveNext())
				{
				}
				yield break;
			}
			if (!producedImageSuccess2)
			{
				if (failSound != null && Camera.main != null)
				{
					audioSource.PlayOneShot(failSound);
				}
			}
			else if (!captureEveryFrame && doneSound != null && Camera.main != null)
			{
				audioSource.PlayOneShot(doneSound);
			}
			Capturing = false;
		}

		public virtual bool OnCaptureStart()
		{
			return true;
		}

		public virtual Camera[] GetCaptureCameras()
		{
			Camera[] allCameras = Camera.allCameras;
			List<Camera> list = new List<Camera>();
			Camera[] array = allCameras;
			foreach (Camera item in array)
			{
				list.Add(item);
			}
			return list.ToArray();
		}

		public virtual void BeforeRenderPanorama()
		{
		}

		public virtual void AfterRenderPanorama()
		{
		}

		private static void ReportOutOfGraphicsMemory()
		{
			throw new OutOfMemoryException("Exhausted graphics memory while capturing panorama. Lower Panorama Width, increase Num Circle Points for stereoscopic images, disable Anti Aliasing, or disable Stereoscopic Capture.");
		}

		private void SaveCubemapImage(uint[] cameraPixels, string filenameBase, string suffix, string imagePath, int i, int bufferIdx)
		{
			Bitmap bitmap = new Bitmap(cameraWidth, cameraHeight, PixelFormat.Format32bppArgb);
			BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.WriteOnly, bitmap.PixelFormat);
			IntPtr scan = bitmapData.Scan0;
			byte[] array = new byte[Math.Abs(bitmapData.Stride) * bitmap.Height];
			int stride = bitmapData.Stride;
			int height = bitmapData.Height;
			int num = bufferIdx * cameraWidth * cameraHeight;
			for (int j = 0; j < cameraHeight; j++)
			{
				int num2 = stride * (height - 1 - j);
				for (int k = 0; k < cameraWidth; k++)
				{
					uint num3 = cameraPixels[num];
					array[num2] = (byte)(num3 & 0xFFu);
					array[num2 + 1] = (byte)((num3 >> 8) & 0xFFu);
					array[num2 + 2] = (byte)(num3 >> 16);
					array[num2 + 3] = byte.MaxValue;
					num2 += 4;
					num++;
				}
			}
			Marshal.Copy(array, 0, scan, array.Length);
			bitmap.UnlockBits(bitmapData);
			string text;
			if (captureStereoscopic)
			{
				text = i.ToString();
				Log("Saving lightfield camera image number " + text);
			}
			else
			{
				CubemapFace cubemapFace = (CubemapFace)i;
				text = cubemapFace.ToString();
				Log("Saving cubemap image " + text);
			}
			string filename = imagePath + "/" + filenameBase + "_" + text + suffix;
			bitmap.Save(filename, FormatToDrawingFormat(imageFormat));
			bitmap.Dispose();
		}

		private Color32 GetCameraPixelBilinear(uint[] cameraPixels, int cameraNum, float u, float v)
		{
			u *= (float)cameraWidth;
			v *= (float)cameraHeight;
			int num = (int)Math.Floor(u);
			int num2 = Math.Min(cameraWidth - 1, num + 1);
			int num3 = (int)Math.Floor(v);
			int num4 = Math.Min(cameraHeight - 1, num3 + 1);
			float t = u - (float)num;
			float t2 = v - (float)num3;
			int num5 = cameraNum * cameraWidth * cameraHeight;
			int num6 = num5 + num3 * cameraWidth;
			int num7 = num5 + num4 * cameraWidth;
			uint num8 = cameraPixels[num6 + num];
			uint num9 = cameraPixels[num6 + num2];
			uint num10 = cameraPixels[num7 + num];
			uint num11 = cameraPixels[num7 + num2];
			float num12 = Mathf.Lerp(Mathf.Lerp(num8 >> 16, num10 >> 16, t2), Mathf.Lerp(num9 >> 16, num11 >> 16, t2), t);
			float num13 = Mathf.Lerp(Mathf.Lerp((num8 >> 8) & 0xFFu, (num10 >> 8) & 0xFFu, t2), Mathf.Lerp((num9 >> 8) & 0xFFu, (num11 >> 8) & 0xFFu, t2), t);
			float num14 = Mathf.Lerp(Mathf.Lerp(num8 & 0xFFu, num10 & 0xFFu, t2), Mathf.Lerp(num9 & 0xFFu, num11 & 0xFFu, t2), t);
			return new UnityEngine.Color(num12 / 255f, num13 / 255f, num14 / 255f, 1f);
		}

		internal void ClearProcessQueue()
		{
			while (resizingProcessList.Count > 0)
			{
				resizingProcessList[0].WaitForExit();
				File.Delete(resizingFilenames[0]);
				resizingProcessList.RemoveAt(0);
				resizingFilenames.RemoveAt(0);
			}
		}

		private IEnumerator UploadImage(byte[] imageFileBytes, string filename, string mimeType, bool async)
		{
			float startTime = Time.realtimeSinceStartup;
			WWWForm form = new WWWForm();
			form.AddField("key", apiKey);
			form.AddField("action", "upload");
			form.AddBinaryData("source", imageFileBytes, filename, mimeType);
			WWW w = new WWW(apiUrl + "upload", form);
			yield return w;
			if (!string.IsNullOrEmpty(w.error))
			{
				UnityEngine.Debug.LogError("Panorama upload failed: " + w.error, this);
				if (failSound != null && Camera.main != null)
				{
					audioSource.PlayOneShot(failSound);
				}
			}
			else
			{
				Log("Time to upload panorama screenshot: " + (Time.realtimeSinceStartup - startTime) + " sec");
				if (!captureEveryFrame && doneSound != null && Camera.main != null)
				{
					audioSource.PlayOneShot(doneSound);
				}
			}
			Capturing = false;
		}

		private IEnumerator CubemapToEquirectangular(ComputeBuffer cameraPixelsBuffer, uint[] cameraPixels, ComputeBuffer convertPanoramaResultBuffer, int cameraWidth, int cameraHeight, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, bool async)
		{
			if (captureStereoscopic && usingGpuTransform)
			{
				convertPanoramaResultBuffer.GetData(resultPixels);
				if (resultPixels[convertPanoramaResultBuffer.count - 1] != 1419455993)
				{
					ReportOutOfGraphicsMemory();
				}
				writeOutputPixels(pixelValues, stride, panoramaWidth, panoramaHeight * 2, panoramaHeight * 2, 0);
			}
			else if (captureStereoscopic && !usingGpuTransform)
			{
				float startTime = Time.realtimeSinceStartup;
				float processingTimePerFrame = cpuMillisecondsPerFrame / 1000f;
				for (int y = 0; y < panoramaHeight; y++)
				{
					for (int x = 0; x < panoramaWidth; x++)
					{
						float xcoord = (float)x / (float)panoramaWidth;
						float ycoord = (float)y / (float)panoramaHeight;
						float latitude = (ycoord - 0.5f) * (float)Math.PI;
						float sinLat = Mathf.Sin(latitude);
						float cosLat = Mathf.Cos(latitude);
						float longitude = (xcoord * 2f - 1f) * (float)Math.PI;
						float sinLong = Mathf.Sin(longitude);
						float cosLong = Mathf.Cos(longitude);
						float latitudeNormalized = latitude / ((float)Math.PI / 2f);
						float ipdScale = IpdScaleFunction(latitudeNormalized);
						float scaledEyeRadius = ipdScale * interpupillaryDistance / 2f;
						float ipdScaleLerp = 1f - ipdScale * 5f;
						UnityEngine.Color colorCap = new UnityEngine.Color(0f, 0f, 0f, 0f);
						if (ipdScaleLerp > 0f)
						{
							Vector3 vector = new Vector3(cosLat * sinLong, sinLat, cosLat * cosLong);
							float num = 1f / vector.y;
							float u4 = vector.x * num;
							float v4 = vector.z * num;
							if (u4 * u4 <= 1f && v4 * v4 <= 1f)
							{
								int cameraNum2;
								if (vector.y > 0f)
								{
									cameraNum2 = 0;
								}
								else
								{
									u4 = 0f - u4;
									cameraNum2 = 1;
								}
								u4 = (u4 + 1f) * 0.5f;
								v4 = (v4 + 1f) * 0.5f;
								colorCap = GetCameraPixelBilinear(cameraPixels, cameraNum2, u4, v4);
							}
						}
						for (int i = 0; i < 2; i++)
						{
							Vector3 vector2 = new Vector3(sinLong, 0f, cosLong);
							float num2 = (float)Math.PI / 2f - Mathf.Acos(scaledEyeRadius / circleRadius);
							if (i == 0)
							{
								num2 = 0f - num2;
							}
							float num3 = longitude + num2;
							if (num3 < 0f)
							{
								num3 += (float)Math.PI * 2f;
							}
							if (num3 >= (float)Math.PI * 2f)
							{
								num3 -= (float)Math.PI * 2f;
							}
							float num4 = num3 / ((float)Math.PI * 2f) * (float)numCirclePoints;
							int num5 = (int)Mathf.Floor(num4) % numCirclePoints;
							UnityEngine.Color a = default(UnityEngine.Color);
							UnityEngine.Color b = default(UnityEngine.Color);
							for (int j = 0; j < 2; j++)
							{
								int num6 = ((j != 0) ? ((num5 + 1) % numCirclePoints) : num5);
								float f = (float)Math.PI * 2f * (float)num6 / (float)numCirclePoints;
								float num7 = Mathf.Sin(f);
								float num8 = Mathf.Cos(f);
								float num9 = Mathf.Sign(vector2.x * num8 - vector2.z * num7) * Mathf.Acos(vector2.z * num8 + vector2.x * num7);
								float num10 = Mathf.Cos(num9);
								float num11 = Mathf.Sin(num9);
								int cameraNum2 = 2 + num6 * 2 + ((num9 >= 0f) ? 1 : 0);
								float num12 = ((!(num9 >= 0f)) ? hFovAdjust : (0f - hFovAdjust));
								float f2 = num9 + num12;
								Vector3 vector3 = new Vector3(cosLat * Mathf.Sin(f2), sinLat, cosLat * Mathf.Cos(f2));
								float u4 = vector3.x / vector3.z / tanHalfHFov;
								float v4 = (0f - vector3.y) / vector3.z / tanHalfVFov;
								if (!(vector3.z > 0f) || !(u4 * u4 <= 1f) || !(v4 * v4 <= 0.9f))
								{
									cameraNum2 = 2 + numCirclePoints * 2 + num6 * 2 + ((latitude >= 0f) ? 1 : 0);
									float f3 = ((!(latitude >= 0f)) ? (0f - vFovAdjust) : vFovAdjust);
									float num13 = Mathf.Cos(f3);
									float num14 = Mathf.Sin(f3);
									vector3 = new Vector3(cosLat * num11, num13 * sinLat - cosLat * num10 * num14, num14 * sinLat + cosLat * num10 * num13);
									u4 = vector3.x / vector3.z / tanHalfHFov;
									v4 = (0f - vector3.y) / vector3.z / tanHalfVFov;
								}
								u4 = (u4 + 1f) * 0.5f;
								v4 = (v4 + 1f) * 0.5f;
								UnityEngine.Color color = GetCameraPixelBilinear(cameraPixels, cameraNum2, u4, v4);
								if (j == 0)
								{
									a = color;
								}
								else
								{
									b = color;
								}
							}
							Color32 color2 = UnityEngine.Color.Lerp(a, b, num4 - Mathf.Floor(num4));
							if (colorCap.a > 0f && ipdScaleLerp > 0f)
							{
								color2 = UnityEngine.Color.Lerp(color2, colorCap, ipdScaleLerp);
							}
							int num15 = stride * (y + panoramaHeight * i) + x * 4;
							pixelValues[num15] = color2.b;
							pixelValues[num15 + 1] = color2.g;
							pixelValues[num15 + 2] = color2.r;
							pixelValues[num15 + 3] = byte.MaxValue;
						}
						if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
						{
							yield return null;
							startTime = Time.realtimeSinceStartup;
						}
					}
				}
			}
			else if (!captureStereoscopic && usingGpuTransform)
			{
				int num16 = (panoramaHeight + 8 - 1) / 8;
				Log("Invoking GPU shader for equirectangular reprojection");
				int num17 = (int)Mathf.Floor((float)panoramaHeight * 0.25f);
				int num18 = (int)Mathf.Ceil((float)panoramaHeight * 0.75f);
				for (int k = 0; k < 8; k++)
				{
					int num19 = k * num16;
					int num20 = Math.Min(num19 + num16, panoramaHeight);
					convertPanoramaShader.SetInt("startY", k * num16);
					convertPanoramaShader.SetInt("sliceHeight", num20 - num19);
					if (num20 <= num17)
					{
						convertPanoramaShader.Dispatch(convertPanoramaYNegativeKernelIdx, (panoramaWidth + threadsX - 1) / threadsX, (num16 + threadsY - 1) / threadsY, 1);
					}
					else if (num19 >= num18)
					{
						convertPanoramaShader.Dispatch(convertPanoramaYPositiveKernelIdx, (panoramaWidth + threadsX - 1) / threadsX, (num16 + threadsY - 1) / threadsY, 1);
					}
					else
					{
						convertPanoramaShader.Dispatch(convertPanoramaKernelIdx, (panoramaWidth + threadsX - 1) / threadsX, (panoramaHeight + threadsY - 1) / threadsY, 1);
					}
					convertPanoramaResultBuffer.GetData(resultPixels);
					if (resultPixels[convertPanoramaResultBuffer.count - 1] != 1419455993)
					{
						ReportOutOfGraphicsMemory();
					}
					writeOutputPixels(pixelValues, stride, panoramaWidth, num16, panoramaHeight, num19);
				}
			}
			else if (async)
			{
				yield return StartCoroutine(CubemapToEquirectangularCpu(cameraPixels, cameraWidth, cameraHeight, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, async));
			}
			else
			{
				IEnumerator enumerator = CubemapToEquirectangularCpu(cameraPixels, cameraWidth, cameraHeight, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, async);
				while (enumerator.MoveNext())
				{
				}
			}
		}

		private void writeOutputPixels(byte[] pixelValues, int stride, int bitmapWidth, int inHeight, int outHeight, int yStart)
		{
			int num = 0;
			for (int i = yStart; i < yStart + inHeight && i < outHeight; i++)
			{
				int num2 = stride * i;
				for (int j = 0; j < bitmapWidth; j++)
				{
					uint num3 = resultPixels[num];
					pixelValues[num2] = (byte)((num3 >> 0) & 0xFFu);
					pixelValues[num2 + 1] = (byte)((num3 >> 8) & 0xFFu);
					pixelValues[num2 + 2] = (byte)((num3 >> 16) & 0xFFu);
					pixelValues[num2 + 3] = byte.MaxValue;
					num2 += 4;
					num++;
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpu(uint[] cameraPixels, int cameraWidth, int cameraHeight, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, bool async)
		{
			Log("Converting to equirectangular");
			yield return null;
			float startTime = Time.realtimeSinceStartup;
			float processingTimePerFrame = cpuMillisecondsPerFrame / 1000f;
			float maxWidth = 1f - 1f / (float)cameraWidth;
			float maxHeight = 1f - 1f / (float)cameraHeight;
			int numPixelsAveraged = ssaaFactor * ssaaFactor;
			int endYPositive = (int)Mathf.Floor((float)panoramaHeight * 0.25f);
			int startYNegative = (int)Mathf.Ceil((float)panoramaHeight * 0.75f);
			int endTopMixedRegion = (int)Mathf.Ceil((float)panoramaHeight * 0.30408698f);
			int startBottomMixedRegion = (int)Mathf.Floor((float)panoramaHeight * 0.695913f);
			int startXNegative = (int)Mathf.Ceil((float)panoramaWidth * 1f / 8f);
			int endXNegative = (int)Mathf.Floor((float)panoramaWidth * 3f / 8f);
			int startZPositive = (int)Mathf.Ceil((float)panoramaWidth * 3f / 8f);
			int endZPositive = (int)Mathf.Floor((float)panoramaWidth * 5f / 8f);
			int startXPositive = (int)Mathf.Ceil((float)panoramaWidth * 5f / 8f);
			int endXPositive = (int)Mathf.Floor((float)panoramaWidth * 7f / 8f);
			int startZNegative = (int)Mathf.Ceil((float)panoramaWidth * 7f / 8f);
			int endZNegative = (int)Mathf.Floor((float)panoramaWidth * 1f / 8f);
			if (async)
			{
				yield return StartCoroutine(CubemapToEquirectangularCpuPositiveY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, 0, panoramaWidth, endYPositive));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, startYNegative, panoramaWidth, panoramaHeight));
				yield return StartCoroutine(CubemapToEquirectangularCpuPositiveX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXPositive, endTopMixedRegion, endXPositive, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXNegative, endTopMixedRegion, endXNegative, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuPositiveZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZPositive, endTopMixedRegion, endZPositive, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZNegative, endTopMixedRegion, panoramaWidth, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, endTopMixedRegion, endZNegative, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, endYPositive, panoramaWidth, endTopMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, startBottomMixedRegion, panoramaWidth, startYNegative));
				if (endZNegative < startXNegative)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZNegative, endTopMixedRegion, startXNegative, startBottomMixedRegion));
				}
				if (endXNegative < startZPositive)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXNegative, endTopMixedRegion, startZPositive, startBottomMixedRegion));
				}
				if (endZPositive < startXPositive)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZPositive, endTopMixedRegion, startXPositive, startBottomMixedRegion));
				}
				if (endXPositive < startZNegative)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXPositive, endTopMixedRegion, startZNegative, startBottomMixedRegion));
				}
			}
			else
			{
				IEnumerator enumerator = CubemapToEquirectangularCpuPositiveY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, 0, panoramaWidth, endYPositive);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, startYNegative, panoramaWidth, panoramaHeight);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuPositiveX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXPositive, endTopMixedRegion, endXPositive, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXNegative, endTopMixedRegion, endXNegative, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuPositiveZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZPositive, endTopMixedRegion, endZPositive, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZNegative, endTopMixedRegion, panoramaWidth, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, endTopMixedRegion, endZNegative, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, endYPositive, panoramaWidth, endTopMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, startBottomMixedRegion, panoramaWidth, startYNegative);
				while (enumerator.MoveNext())
				{
				}
				if (endZNegative < startXNegative)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZNegative, endTopMixedRegion, startXNegative, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
				if (endXNegative < startZPositive)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXNegative, endTopMixedRegion, startZPositive, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
				if (endZPositive < startXPositive)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZPositive, endTopMixedRegion, startXPositive, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
				if (endXPositive < startZNegative)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXPositive, endTopMixedRegion, startZNegative, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
			}
			yield return null;
		}

		private IEnumerator CubemapToEquirectangularCpuPositiveY(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.y;
							float num5 = vector.x * num4;
							float num6 = vector.z * num4;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 2, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuNegativeY(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.y;
							float num5 = vector.x * num4;
							float num6 = vector.z * num4;
							num5 = 0f - num5;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 3, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuPositiveX(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.x;
							float num5 = (0f - vector.z) * num4;
							float num6 = vector.y * num4;
							num6 = 0f - num6;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 0, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuNegativeX(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.x;
							float num5 = (0f - vector.z) * num4;
							float num6 = vector.y * num4;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 1, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuPositiveZ(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.z;
							float num5 = vector.x * num4;
							float num6 = vector.y * num4;
							num6 = 0f - num6;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 4, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuNegativeZ(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.z;
							float num5 = vector.x * num4;
							float num6 = vector.y * num4;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 5, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuGeneralCase(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, float maxWidth, float maxHeight, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.y;
							float num5 = vector.x * num4;
							float num6 = vector.z * num4;
							CubemapFace cameraNum;
							if (vector.y > 0f)
							{
								cameraNum = CubemapFace.PositiveY;
							}
							else
							{
								cameraNum = CubemapFace.NegativeY;
								num5 = 0f - num5;
							}
							if (Mathf.Abs(num5) > 1f || Mathf.Abs(num6) > 1f)
							{
								num4 = 1f / vector.x;
								num5 = (0f - vector.z) * num4;
								num6 = vector.y * num4;
								if (vector.x > 0f)
								{
									cameraNum = CubemapFace.PositiveX;
									num6 = 0f - num6;
								}
								else
								{
									cameraNum = CubemapFace.NegativeX;
								}
							}
							if (Mathf.Abs(num5) > 1f || Mathf.Abs(num6) > 1f)
							{
								num4 = 1f / vector.z;
								num5 = vector.x * num4;
								num6 = vector.y * num4;
								if (vector.z > 0f)
								{
									cameraNum = CubemapFace.PositiveZ;
									num6 = 0f - num6;
								}
								else
								{
									cameraNum = CubemapFace.NegativeZ;
								}
							}
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							num5 = Mathf.Min(num5, maxWidth);
							num6 = Mathf.Min(num6, maxHeight);
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, (int)cameraNum, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}
	}
	public static class Icosphere
	{
		public static Mesh BuildIcosphere(float radius, int iterations)
		{
			Mesh mesh = BuildIcosahedron(radius);
			for (int i = 0; i < iterations; i++)
			{
				Refine(mesh);
			}
			return mesh;
		}

		public static Mesh BuildIcosahedron(float radius)
		{
			Mesh mesh = new Mesh();
			float num = (float)((1.0 + Math.Sqrt(5.0)) / 2.0);
			Vector3[] array = new Vector3[12]
			{
				new Vector3(-1f, num, 0f),
				new Vector3(1f, num, 0f),
				new Vector3(-1f, 0f - num, 0f),
				new Vector3(1f, 0f - num, 0f),
				new Vector3(0f, -1f, num),
				new Vector3(0f, 1f, num),
				new Vector3(0f, -1f, 0f - num),
				new Vector3(0f, 1f, 0f - num),
				new Vector3(num, 0f, -1f),
				new Vector3(num, 0f, 1f),
				new Vector3(0f - num, 0f, -1f),
				new Vector3(0f - num, 0f, 1f)
			};
			float num2 = radius / new Vector3(1f, num, 0f).magnitude;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] *= num2;
			}
			mesh.vertices = array;
			mesh.triangles = new int[60]
			{
				0, 11, 5, 0, 5, 1, 0, 1, 7, 0,
				7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
				4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
				3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
				6, 8, 3, 8, 9, 4, 9, 5, 2, 4,
				11, 6, 2, 10, 8, 6, 7, 9, 8, 1
			};
			return mesh;
		}

		private static void Refine(Mesh m)
		{
			throw new Exception("TODO");
		}
	}
}
namespace CapturePanorama.Internals
{
	internal class ImageEffectCopyCamera : UnityEngine.MonoBehaviour
	{
		public struct InstanceMethodPair
		{
			public object Instance;

			public MethodInfo Method;
		}

		public List<InstanceMethodPair> onRenderImageMethods = new List<InstanceMethodPair>();

		private RenderTexture[] temp = new RenderTexture[2];

		public static List<InstanceMethodPair> GenerateMethodList(Camera camToCopy)
		{
			List<InstanceMethodPair> list = new List<InstanceMethodPair>();
			UnityEngine.MonoBehaviour[] components = camToCopy.gameObject.GetComponents<UnityEngine.MonoBehaviour>();
			foreach (UnityEngine.MonoBehaviour monoBehaviour in components)
			{
				if (monoBehaviour.enabled)
				{
					Type type = monoBehaviour.GetType();
					MethodInfo method = type.GetMethod("OnRenderImage", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
					{
						typeof(RenderTexture),
						typeof(RenderTexture)
					}, null);
					if (method != null)
					{
						InstanceMethodPair item = default(InstanceMethodPair);
						item.Instance = monoBehaviour;
						item.Method = method;
						list.Add(item);
					}
				}
			}
			return list;
		}

		private void OnDestroy()
		{
			for (int i = 0; i < temp.Length; i++)
			{
				if (temp[i] != null)
				{
					UnityEngine.Object.Destroy(temp[i]);
				}
				temp[i] = null;
			}
		}

		private void OnRenderImage(RenderTexture src, RenderTexture dest)
		{
			int num = Math.Max(src.depth, dest.depth);
			for (int i = 0; i < temp.Length; i++)
			{
				if (onRenderImageMethods.Count > i + 1)
				{
					if (temp[i] != null && (temp[i].width != dest.width || temp[i].height != dest.height || temp[i].depth != num || temp[i].format != dest.format))
					{
						UnityEngine.Object.Destroy(temp[i]);
						temp[i] = null;
					}
					if (temp[i] == null)
					{
						temp[i] = new RenderTexture(dest.width, dest.height, num, dest.format);
					}
				}
			}
			List<RenderTexture> list = new List<RenderTexture>();
			list.Add(src);
			for (int j = 0; j < onRenderImageMethods.Count - 1; j++)
			{
				list.Add((j % 2 != 0) ? temp[1] : temp[0]);
			}
			list.Add(dest);
			for (int k = 0; k < onRenderImageMethods.Count; k++)
			{
				onRenderImageMethods[k].Method.Invoke(onRenderImageMethods[k].Instance, new object[2]
				{
					list[k],
					list[k + 1]
				});
			}
		}
	}
}
namespace CapturePanorama
{
	public class ReadPanoConfig : UnityEngine.MonoBehaviour
	{
		public string iniPath;

		private void Start()
		{
			if (UnityEngine.Application.isEditor)
			{
				return;
			}
			CapturePanorama component = GetComponent<CapturePanorama>();
			string text = iniPath;
			if (text == string.Empty)
			{
				string text2 = "CapturePanorama.ini";
				text = UnityEngine.Application.dataPath + "/" + text2;
			}
			if (!File.Exists(text))
			{
				WriteConfig(text, component);
				return;
			}
			string[] array = File.ReadAllLines(text);
			foreach (string text3 in array)
			{
				if (!(text3.Trim() == string.Empty))
				{
					string[] array2 = text3.Split(new char[1] { '=' }, 2);
					string text4 = array2[0].Trim();
					string text5 = array2[1].Trim();
					switch (text4)
					{
					case "Panorama Name":
						component.panoramaName = text5;
						break;
					case "Capture Key":
						component.captureKey = (KeyCode)Enum.Parse(typeof(KeyCode), text5);
						break;
					case "Image Format":
						component.imageFormat = (CapturePanorama.ImageFormat)Enum.Parse(typeof(CapturePanorama.ImageFormat), text5);
						break;
					case "Capture Stereoscopic":
						component.captureStereoscopic = bool.Parse(text5);
						break;
					case "Interpupillary Distance":
						component.interpupillaryDistance = float.Parse(text5);
						break;
					case "Num Circle Points":
						component.numCirclePoints = int.Parse(text5);
						break;
					case "Panorama Width":
						component.panoramaWidth = int.Parse(text5);
						break;
					case "Anti Aliasing":
						component.antiAliasing = (CapturePanorama.AntiAliasing)int.Parse(text5);
						break;
					case "Ssaa Factor":
						component.ssaaFactor = int.Parse(text5);
						break;
					case "Save Image Path":
						component.saveImagePath = text5;
						break;
					case "Save Cubemap":
						component.saveCubemap = bool.Parse(text5);
						break;
					case "Upload Images":
						component.uploadImages = bool.Parse(text5);
						break;
					case "Use Default Orientation":
						component.useDefaultOrientation = bool.Parse(text5);
						break;
					case "Use Gpu Transform":
						component.useGpuTransform = bool.Parse(text5);
						break;
					case "Cpu Milliseconds Per Frame":
						component.cpuMillisecondsPerFrame = (float)double.Parse(text5);
						break;
					case "Capture Every Frame":
						component.captureEveryFrame = bool.Parse(text5);
						break;
					case "Frame Rate":
						component.frameRate = int.Parse(text5);
						break;
					case "Max Frames To Record":
						component.maxFramesToRecord = ((!(text5 == string.Empty)) ? int.Parse(text5) : 0);
						break;
					case "Frame Number Digits":
						component.frameNumberDigits = int.Parse(text5);
						break;
					case "Fade During Capture":
						component.fadeDuringCapture = bool.Parse(text5);
						break;
					case "Fade Time":
						component.fadeTime = float.Parse(text5);
						break;
					case "Enable Debugging":
						component.enableDebugging = bool.Parse(text5);
						break;
					default:
						UnityEngine.Debug.LogError("Unrecognized key in line in CapturePanorama.ini: " + text3);
						break;
					}
				}
			}
		}

		private void WriteConfig(string path, CapturePanorama pano)
		{
			using StreamWriter streamWriter = new StreamWriter(path);
			streamWriter.WriteLine("Panorama Name=" + pano.panoramaName);
			streamWriter.WriteLine("Capture Key=" + pano.captureKey);
			streamWriter.WriteLine("Image Format=" + pano.imageFormat);
			streamWriter.WriteLine("Capture Stereoscopic=" + pano.captureStereoscopic);
			streamWriter.WriteLine("Interpupillary Distance=" + pano.interpupillaryDistance);
			streamWriter.WriteLine("Num Circle Points=" + pano.numCirclePoints);
			streamWriter.WriteLine("Panorama Width=" + pano.panoramaWidth);
			streamWriter.WriteLine("Anti Aliasing=" + (int)pano.antiAliasing);
			streamWriter.WriteLine("Ssaa Factor=" + pano.ssaaFactor);
			streamWriter.WriteLine("Save Image Path=" + pano.saveImagePath);
			streamWriter.WriteLine("Save Cubemap=" + pano.saveCubemap);
			streamWriter.WriteLine("Upload Images=" + pano.uploadImages);
			streamWriter.WriteLine("Use Default Orientation=" + pano.useDefaultOrientation);
			streamWriter.WriteLine("Use Gpu Transform=" + pano.useGpuTransform);
			streamWriter.WriteLine("Cpu Milliseconds Per Frame=" + pano.cpuMillisecondsPerFrame);
			streamWriter.WriteLine("Capture Every Frame=" + pano.captureEveryFrame);
			streamWriter.WriteLine("Frame Rate=" + pano.frameRate);
			streamWriter.WriteLine("Max Frames To Record=" + pano.maxFramesToRecord);
			streamWriter.WriteLine("Frame Number Digits=" + pano.frameNumberDigits);
			streamWriter.WriteLine("Fade During Capture=" + pano.fadeDuringCapture);
			streamWriter.WriteLine("Fade Time=" + pano.fadeTime);
			streamWriter.WriteLine("Enable Debugging=" + pano.enableDebugging);
		}
	}
}
namespace CapturePanorama.Internals
{
	public class ScreenFadeControl : UnityEngine.MonoBehaviour
	{
		public Material fadeMaterial;

		private void OnCustomPostRender()
		{
			fadeMaterial.SetPass(0);
			GL.PushMatrix();
			GL.LoadOrtho();
			GL.Color(fadeMaterial.color);
			GL.Begin(7);
			GL.Vertex3(0f, 0f, -12f);
			GL.Vertex3(0f, 1f, -12f);
			GL.Vertex3(1f, 1f, -12f);
			GL.Vertex3(1f, 0f, -12f);
			GL.End();
			GL.PopMatrix();
		}
	}
}
public static class GPGSIds
{
	public const string event_testevent = "CgkI2-eA1PAZEAIQAQ";
}
public class WaveGen : UnityEngine.MonoBehaviour
{
	public float scale = 1f;

	public float speed = 1f;

	public float noiseStrength = 1f;

	public float noiseWalk = 1f;

	private Vector3[] baseHeight;

	private void Update()
	{
		Mesh mesh = GetComponent<MeshFilter>().mesh;
		if (baseHeight == null)
		{
			baseHeight = mesh.vertices;
		}
		Vector3[] array = new Vector3[baseHeight.Length];
		for (int i = 0; i < array.Length; i++)
		{
			Vector3 vector = baseHeight[i];
			vector.y += Mathf.Sin(Time.time * speed + baseHeight[i].x + baseHeight[i].y + baseHeight[i].z) * scale;
			vector.y += Mathf.PerlinNoise(baseHeight[i].x + noiseWalk, baseHeight[i].y + Mathf.Sin(Time.time * 0.1f)) * noiseStrength;
			array[i] = vector;
		}
		mesh.vertices = array;
		mesh.RecalculateNormals();
		MeshCollider component = GetComponent<MeshCollider>();
		component.sharedMesh = null;
		component.sharedMesh = mesh;
	}
}
[RequireComponent(typeof(Light))]
public class CFX_LightIntensityFade : UnityEngine.MonoBehaviour
{
	public float duration = 1f;

	public float delay;

	public float finalIntensity;

	private float baseIntensity;

	public bool autodestruct;

	private float p_lifetime;

	private float p_delay;

	private void Start()
	{
		baseIntensity = GetComponent<Light>().intensity;
	}

	private void OnEnable()
	{
		p_lifetime = 0f;
		p_delay = delay;
		if (delay > 0f)
		{
			GetComponent<Light>().enabled = false;
		}
	}

	private void Update()
	{
		if (p_delay > 0f)
		{
			p_delay -= Time.deltaTime;
			if (p_delay <= 0f)
			{
				GetComponent<Light>().enabled = true;
			}
		}
		else if (p_lifetime / duration < 1f)
		{
			GetComponent<Light>().intensity = Mathf.Lerp(baseIntensity, finalIntensity, p_lifetime / duration);
			p_lifetime += Time.deltaTime;
		}
		else if (autodestruct)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class BSOD : UnityEngine.MonoBehaviour
{
	private class BSODUpdater : UnityEngine.MonoBehaviour
	{
		private void Update()
		{
			if (Input.GetButtonDown("joystick button 0") || OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				SceneManager.LoadScene(0);
			}
		}
	}

	[SerializeField]
	private GameObject m_BSODPrefab;

	private static bool s_hasFired;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnDestroy()
	{
		UnityEngine.Application.logMessageReceived -= LogCallback;
	}

	private void LogCallback(string condition, string stackTrace, LogType type)
	{
		if (type != LogType.Exception || !base.gameObject.activeInHierarchy || s_hasFired)
		{
			return;
		}
		s_hasFired = true;
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		GameObject[] array2 = array;
		foreach (GameObject gameObject in array2)
		{
			gameObject.SetActive(value: false);
		}
		GameObject gameObject2 = UnityEngine.Object.Instantiate(m_BSODPrefab);
		string empty = string.Empty;
		try
		{
			string[] array3 = stackTrace.Split('\n');
			string text = array3[0].Substring(0, array3[0].IndexOf('.'));
			while (true)
			{
				Type type2 = Type.GetType(text);
				if (type2 != null)
				{
				}
				int num = text.LastIndexOf('+');
				if (num <= 0)
				{
					break;
				}
				text = text.Substring(0, num);
			}
		}
		catch (Exception)
		{
		}
		gameObject2.GetComponentInChildren<BSODDisplay>().Text = string.Format("{0}\n{2}\n\n{1}", condition, stackTrace, empty);
		gameObject2.SetActive(value: true);
		gameObject2.AddComponent<BSODUpdater>();
	}
}
public class BSODDisplay : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Text m_display;

	public string Text
	{
		set
		{
			m_display.text = value;
		}
	}
}
public class DrawCallRecorder : UnityEngine.MonoBehaviour
{
	private struct RecordedData
	{
		public float time;

		public int batches;

		public int triCount;

		public int vertCount;

		public Vector3 pos;

		public Vector3 dir;
	}

	[SerializeField]
	private string MainFileName;

	[SerializeField]
	private float UpdateTimePeriod = 0.5f;

	[SerializeField]
	private bool ShowAltDisplay;

	private float m_nextUpdateTime;

	private StreamWriter m_writer;

	private bool m_recording;

	private List<RecordedData> m_recordedData = new List<RecordedData>();

	public void LoadFile(string filename)
	{
		string path = "Assets\\Game\\Resources\\DrawCallRecordings\\" + filename + ".txt";
		string text = File.ReadAllText(path);
		text = text.Replace("\r\n", "\t");
		string[] array = text.Split("\t"[0]);
		m_recordedData.Clear();
		int num = 0;
		do
		{
			RecordedData item = default(RecordedData);
			item.time = float.Parse(array[num++]);
			item.batches = int.Parse(array[num++]);
			item.triCount = int.Parse(array[num++]);
			item.pos.x = float.Parse(array[num++]);
			item.pos.y = float.Parse(array[num++]);
			item.pos.z = float.Parse(array[num++]);
			item.dir.x = float.Parse(array[num++]);
			item.dir.y = float.Parse(array[num++]);
			item.dir.z = float.Parse(array[num++]);
			m_recordedData.Add(item);
		}
		while (num < array.Length - 1);
	}

	private void Update()
	{
		if (!m_recording)
		{
			if (!Gameplay.Instance || !Gameplay.Instance.RaceStarted())
			{
				return;
			}
			m_recording = true;
			string empty = string.Empty;
			empty = UnityEngine.Application.persistentDataPath + "/" + MainFileName + "_" + DateTime.Now.ToFileTime() + ".txt";
			m_writer = File.CreateText(empty);
		}
		if (m_writer != null)
		{
			if (GameTime.Instance.CurrentTime() > m_nextUpdateTime)
			{
				m_nextUpdateTime = GameTime.Instance.CurrentTime() + UpdateTimePeriod;
			}
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_Y))
			{
				m_recording = false;
				m_writer.Close();
				base.enabled = false;
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = UnityEngine.Color.magenta;
		Vector3 vector = Vector3.zero;
		if (m_recordedData == null || m_recordedData.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < m_recordedData.Count; i++)
		{
			RecordedData recordedData = m_recordedData[i];
			if (recordedData.triCount > 100000 || recordedData.batches > 100)
			{
				Gizmos.color = UnityEngine.Color.red;
			}
			else
			{
				Gizmos.color = UnityEngine.Color.green;
			}
			if (ShowAltDisplay)
			{
				if (i == 0)
				{
					vector = recordedData.pos;
					continue;
				}
				Vector3 normalized = (recordedData.pos - vector).normalized;
				Vector3 vector2 = Vector3.Cross(normalized, Vector3.up);
				Gizmos.DrawLine(vector, recordedData.pos);
				Gizmos.DrawLine(vector + vector2 * 0.05f, recordedData.pos + vector2 * 0.05f);
				Gizmos.DrawLine(vector - vector2 * 0.05f, recordedData.pos - vector2 * 0.05f);
				vector = recordedData.pos;
			}
			else
			{
				Gizmos.DrawWireSphere(recordedData.pos, 0.5f);
				Gizmos.DrawLine(recordedData.pos, recordedData.pos + recordedData.dir * 2f);
			}
		}
	}
}
public class PerformanceTest : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject[] CubeTest;

	[SerializeField]
	private GameObject RootObject;

	[SerializeField]
	private Vector2 CubeRandomOffset;

	private int m_cubeIndex;

	private int m_testType;

	private void Start()
	{
		FadeManager.Instance.FadeIn();
	}

	private void Update()
	{
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Weapon))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(CubeTest[m_testType]);
			gameObject.transform.parent = RootObject.transform;
			gameObject.transform.position = new Vector3(UnityEngine.Random.Range(0f - CubeRandomOffset.x, CubeRandomOffset.x), UnityEngine.Random.Range(0f - CubeRandomOffset.y, CubeRandomOffset.y), 6f);
			m_cubeIndex++;
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.SpeedBoost))
		{
			m_cubeIndex = 0;
			m_testType = (m_testType + 1) % CubeTest.Length;
			for (int i = 0; i < RootObject.transform.childCount; i++)
			{
				UnityEngine.Object.Destroy(RootObject.transform.GetChild(i).gameObject);
			}
		}
		GameDebug.Instance.SetDebugText(0, "Count = " + m_cubeIndex + " Type = " + m_testType);
	}
}
public class ControlSprite : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private bool m_forPad;

	private SpriteRenderer m_sprite;

	private UnityEngine.UI.Image m_image;

	private void Start()
	{
		m_sprite = GetComponent<SpriteRenderer>();
		m_image = GetComponent<UnityEngine.UI.Image>();
	}

	private void Update()
	{
		if (!m_sprite && !m_image)
		{
			base.enabled = false;
		}
		else if ((m_forPad && InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl) || (!m_forPad && InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController))
		{
			if ((bool)m_sprite && !m_sprite.enabled)
			{
				m_sprite.enabled = true;
			}
			else if ((bool)m_image && !m_image.enabled)
			{
				m_image.enabled = true;
			}
		}
		else if ((bool)m_sprite && m_sprite.enabled)
		{
			m_sprite.enabled = false;
		}
		else if ((bool)m_image && m_image.enabled)
		{
			m_image.enabled = false;
		}
	}
}
public class ControllerDemoTilt : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float m_speed = 4f;

	[SerializeField]
	private float m_maxTilt = 10f;

	private float m_currentAngle;

	private void Update()
	{
		m_currentAngle += m_speed * GameTime.Instance.DeltaTime();
		m_currentAngle %= 360f;
		float angle = Mathf.Sin(m_currentAngle) * m_maxTilt;
		base.transform.localRotation = Quaternion.AngleAxis(angle, Vector3.up);
	}
}
public class ControllerDialog : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject MenuObject;

	private bool m_delayShowingScreen = true;

	private FollowPlayerMenu m_followPlayerMenu;

	private void Start()
	{
		m_followPlayerMenu = GetComponent<FollowPlayerMenu>();
		m_delayShowingScreen = true;
		MenuObject.SetActive(value: false);
	}

	private void Update()
	{
		if (m_delayShowingScreen)
		{
			if (((bool)GameEntry.Instance && !Gameplay.Instance && !FEMManager.Instance) || !FadeManager.Instance.FinishedFading())
			{
				return;
			}
			m_delayShowingScreen = false;
		}
		if (((bool)GameSystem.Instance && GameSystem.Instance.GamepadConnected()) || InputRemapper.Instance.RemoteConnected)
		{
			if (MenuObject.gameObject.activeInHierarchy)
			{
				MenuObject.SetActive(value: false);
			}
		}
		else if (!MenuObject.gameObject.activeInHierarchy)
		{
			m_followPlayerMenu.ForceUpdatePosition();
			MenuObject.SetActive(value: true);
			MenuObject.transform.localPosition = new Vector3(0f, 0f, 0.8f);
			MenuObject.transform.localRotation = Quaternion.identity;
		}
	}
}
public class ControllerSpot : UnityEngine.MonoBehaviour
{
	private void Update()
	{
		base.transform.rotation = InputRemapper.Instance.GetControllerOrientation();
		Vector3 vector = new Vector3(0f, 0f, 1f);
		Quaternion controllerOrientation = InputRemapper.Instance.GetControllerOrientation();
		Vector3 position = controllerOrientation * vector;
		position += CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.position;
		base.transform.position = position;
	}
}
public class Credits : UnityEngine.MonoBehaviour
{
	public struct CreditData
	{
		public string title0;

		public string title1;

		public string title2;

		public string name;
	}

	[SerializeField]
	private TextMesh Title0;

	[SerializeField]
	private TextMesh Title1;

	[SerializeField]
	private TextMesh Title2;

	[SerializeField]
	private TextMesh Title2_Name1;

	[SerializeField]
	private TextMesh Title2_Name2;

	[SerializeField]
	private float ScrollSpeed = 0.2f;

	[SerializeField]
	private Vector2 m_extents = new Vector2(-0.5f, 0.5f);

	[SerializeField]
	private float Spacer = 0.05f;

	private int m_textIndex;

	private List<TextMesh> m_textList = new List<TextMesh>();

	private List<CreditData> m_creditList = new List<CreditData>();

	private bool m_firstTextEntry = true;

	private void Start()
	{
		GameCamera cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.Credits);
		cameraByType.transform.parent = base.transform.parent.transform;
		cameraByType.transform.localPosition = new Vector3(0f, 0f, -3f);
		cameraByType.transform.localRotation = Quaternion.identity;
		LoadCreditsXML();
		CreateText();
	}

	private void OnEnable()
	{
		if (CameraManager.Instance != null)
		{
			GameCamera cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.Credits);
			cameraByType.transform.parent = base.transform.parent.transform;
			cameraByType.transform.localPosition = new Vector3(0f, 0f, -3f);
		}
	}

	private void LoadCreditsXML()
	{
		TextAsset textAsset = (TextAsset)Resources.Load("Credits");
		if (textAsset == null)
		{
			return;
		}
		XmlDocument xmlDocument = new XmlDocument();
		xmlDocument.LoadXml(textAsset.text);
		XmlNodeList xmlNodeList = xmlDocument.SelectNodes("Credits");
		xmlNodeList = xmlNodeList[0].ChildNodes;
		for (int i = 0; i < xmlNodeList.Count; i++)
		{
			CreditData item = default(CreditData);
			if (xmlNodeList[i].Attributes["Title0"] != null)
			{
				item.title0 = xmlNodeList[i].Attributes["Title0"].Value;
			}
			if (xmlNodeList[i].Attributes["Title1"] != null)
			{
				item.title1 = xmlNodeList[i].Attributes["Title1"].Value;
			}
			if (xmlNodeList[i].Attributes["Title2"] != null)
			{
				item.title2 = xmlNodeList[i].Attributes["Title2"].Value;
			}
			if (xmlNodeList[i].Attributes["Name"] != null)
			{
				item.name = xmlNodeList[i].Attributes["Name"].Value;
			}
			m_creditList.Add(item);
		}
	}

	public void ResetCamera()
	{
		if (CameraManager.Instance != null)
		{
			GameCamera cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.Credits);
			cameraByType.transform.parent = base.transform.parent.transform;
			cameraByType.transform.localPosition = new Vector3(0f, 0f, -3f);
			cameraByType.transform.localRotation = Quaternion.identity;
		}
	}

	private void Update()
	{
		for (int i = 0; i < m_textList.Count; i++)
		{
			float y = m_textList[i].transform.localPosition.y;
			y += ScrollSpeed * Time.deltaTime;
			if (y > m_extents.y)
			{
				TextMesh textMesh = m_textList[i];
				m_textList.RemoveAt(i);
				UnityEngine.Object.Destroy(textMesh.gameObject);
			}
			else
			{
				m_textList[i].transform.localPosition = new Vector3(m_textList[i].transform.localPosition.x, y, m_textList[i].transform.localPosition.z);
			}
		}
		if (m_textList.Count > 0)
		{
			float num = ((!m_firstTextEntry) ? m_extents.x : (-3f));
			if (m_textList[m_textList.Count - 1].transform.localPosition.y > num + Spacer)
			{
				CreateText();
			}
		}
	}

	private void CreateText()
	{
		if (m_textIndex >= m_creditList.Count)
		{
			m_textIndex = 0;
			m_firstTextEntry = false;
		}
		float y = ((!m_firstTextEntry) ? m_extents.x : (-3f));
		if (m_creditList[m_textIndex].title1 == null)
		{
			if (m_creditList[m_textIndex].title0 != null)
			{
				TextMesh textMesh = UnityEngine.Object.Instantiate(Title0);
				textMesh.text = m_creditList[m_textIndex].title0;
				m_textList.Add(textMesh);
				textMesh.transform.parent = base.transform;
				textMesh.transform.localPosition = new Vector3(0f, y, -0.1f);
				textMesh.gameObject.SetActive(value: true);
				textMesh.transform.GetChild(0).GetComponent<TextMesh>().text = textMesh.text;
			}
			else if (m_creditList[m_textIndex].name == null)
			{
				TextMesh textMesh = UnityEngine.Object.Instantiate(Title2);
				textMesh.text = m_creditList[m_textIndex].title2;
				m_textList.Add(textMesh);
				textMesh.transform.parent = base.transform;
				textMesh.transform.localPosition = new Vector3(0f, y, -0.1f);
				textMesh.gameObject.SetActive(value: true);
				textMesh.transform.GetChild(0).GetComponent<TextMesh>().text = textMesh.text;
			}
			else
			{
				TextMesh textMesh = UnityEngine.Object.Instantiate(Title2_Name1);
				textMesh.text = m_creditList[m_textIndex].title2;
				m_textList.Add(textMesh);
				textMesh.transform.parent = base.transform;
				textMesh.transform.localPosition = new Vector3(-0.01f, y, -0.1f);
				textMesh.gameObject.SetActive(value: true);
				textMesh.transform.GetChild(0).GetComponent<TextMesh>().text = textMesh.text;
				TextMesh textMesh2 = UnityEngine.Object.Instantiate(Title2_Name2);
				textMesh2.text = m_creditList[m_textIndex].name;
				m_textList.Add(textMesh2);
				textMesh2.transform.parent = base.transform;
				textMesh2.transform.localPosition = new Vector3(0.01f, y, -0.1f);
				textMesh2.gameObject.SetActive(value: true);
				textMesh2.transform.GetChild(0).GetComponent<TextMesh>().text = textMesh2.text;
			}
		}
		else
		{
			TextMesh textMesh = UnityEngine.Object.Instantiate(Title1);
			textMesh.text = m_creditList[m_textIndex].title1;
			m_textList.Add(textMesh);
			textMesh.transform.parent = base.transform;
			textMesh.transform.localPosition = new Vector3(0f, y, -0.1f);
			textMesh.gameObject.SetActive(value: true);
			textMesh.transform.GetChild(0).GetComponent<TextMesh>().text = textMesh.text;
		}
		m_textIndex++;
	}
}
public class ColourMenuOption : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Text OptionText;

	[SerializeField]
	private UnityEngine.UI.Image OptionColour;

	[SerializeField]
	private GameObject Outline;

	private const float FlashSpeed = 0.5f;

	private bool m_flashing;

	private float m_flashTimer;

	public void SetFlashing(bool flash)
	{
		m_flashing = flash;
		if (!flash && !OptionText.gameObject.activeSelf)
		{
			OptionText.gameObject.SetActive(value: true);
		}
		if (Outline.activeSelf != m_flashing)
		{
			Outline.SetActive(m_flashing);
		}
	}

	public void SetColour(UnityEngine.Color col)
	{
		OptionColour.color = col;
	}

	private void Update()
	{
		if (m_flashing)
		{
			m_flashTimer += GameTime.Instance.DeltaTime();
			if (m_flashTimer >= 0.5f)
			{
				m_flashTimer = 0f;
				OptionText.gameObject.SetActive(!OptionText.gameObject.activeSelf);
			}
		}
	}
}
public class ConfirmDialog : UnityEngine.MonoBehaviour
{
	public enum DialogType
	{
		None,
		PurchaseGame,
		PurchaseCurrency,
		PurchaseSuccessful,
		PurchaseFailed,
		Checkout,
		CheckoutSuccessful,
		CheckoutFailed
	}

	private DialogType m_type;

	[SerializeField]
	private Text DialogText;

	[SerializeField]
	private Text ErrorCodeText;

	[SerializeField]
	private UnityEngine.UI.Image ConfirmOption;

	[SerializeField]
	private UnityEngine.UI.Image DeclineOption;

	[SerializeField]
	private UnityEngine.UI.Image OKOption;

	[SerializeField]
	private GameObject ConfirmObject;

	[SerializeField]
	private GameObject DeclineObject;

	[SerializeField]
	private GameObject OKObject;

	private bool m_confirm;

	private bool m_decline;

	private bool m_ok;

	public bool IsActive()
	{
		return base.gameObject.activeSelf;
	}

	private void OnEnable()
	{
		m_confirm = false;
		ConfirmOption.enabled = false;
		DeclineOption.enabled = false;
	}

	private void Update()
	{
		Transform controllerSpot = FEMManager.Instance.GetControllerSpot();
		Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
		m_confirm = false;
		m_decline = false;
		m_ok = false;
		Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
		if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("UI")))
		{
			if (hitInfo.collider.gameObject == ConfirmObject.gameObject)
			{
				m_confirm = true;
			}
			else if (hitInfo.collider.gameObject == DeclineObject.gameObject)
			{
				m_decline = true;
			}
			else if (hitInfo.collider.gameObject == OKObject.gameObject)
			{
				m_ok = true;
			}
			if (InputRemapper.Instance.GetButtonUp(InputRemapper.ControllerMapping.Button_A))
			{
				SetConfirmation(m_confirm);
			}
		}
		ConfirmOption.enabled = m_confirm;
		DeclineOption.enabled = m_decline;
		OKOption.enabled = m_ok;
	}

	public void EnableDialog(bool enable, DialogType type, string errorStr)
	{
		EnableDialog(enable, type);
		ErrorCodeText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ErrorCode", convertToUpperCase: true) + " " + errorStr;
	}

	public void EnableDialog(bool enable, DialogType type)
	{
		m_type = type;
		base.gameObject.SetActive(enable);
		ErrorCodeText.text = string.Empty;
		switch (m_type)
		{
		default:
			m_confirm = false;
			break;
		case DialogType.PurchaseGame:
			DialogText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PurchaseFullGame", convertToUpperCase: true);
			ConfirmObject.SetActive(value: true);
			DeclineObject.SetActive(value: true);
			OKObject.SetActive(value: false);
			break;
		case DialogType.Checkout:
			DialogText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PurchaseItems", convertToUpperCase: true);
			ConfirmObject.SetActive(value: true);
			DeclineObject.SetActive(value: true);
			OKObject.SetActive(value: false);
			break;
		case DialogType.PurchaseCurrency:
			DialogText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PurchaseCurrency", convertToUpperCase: true);
			ConfirmObject.SetActive(value: true);
			DeclineObject.SetActive(value: true);
			OKObject.SetActive(value: false);
			break;
		case DialogType.CheckoutSuccessful:
			DialogText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PurchaseSuccessful", convertToUpperCase: true);
			ConfirmObject.SetActive(value: false);
			DeclineObject.SetActive(value: false);
			OKObject.SetActive(value: true);
			break;
		case DialogType.CheckoutFailed:
			DialogText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PurchaseFailed", convertToUpperCase: true);
			ConfirmObject.SetActive(value: false);
			DeclineObject.SetActive(value: false);
			OKObject.SetActive(value: true);
			ErrorCodeText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ErrorCode", convertToUpperCase: true) + " " + GameSystem.Instance.GetMarket().GetLastErrorCode();
			break;
		case DialogType.PurchaseSuccessful:
			DialogText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PurchaseSuccessful", convertToUpperCase: true);
			ConfirmObject.SetActive(value: false);
			DeclineObject.SetActive(value: false);
			OKObject.SetActive(value: true);
			break;
		case DialogType.PurchaseFailed:
			DialogText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PurchaseFailed", convertToUpperCase: true);
			ConfirmObject.SetActive(value: false);
			DeclineObject.SetActive(value: false);
			OKObject.SetActive(value: true);
			break;
		}
	}

	public void SetConfirmation(bool confirmation)
	{
		base.gameObject.SetActive(value: false);
		if (confirmation)
		{
			switch (m_type)
			{
			case DialogType.Checkout:
				ExtraCustomisation.Instance.ShoppingList.Checkout();
				break;
			case DialogType.PurchaseCurrency:
				ExtraCustomisation.Instance.ShoppingList.PurchaseCurrency();
				break;
			}
		}
	}
}
public class CustomisePlayer : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Vector3 PlayerHeadAngle = new Vector3(30f, 45f, 30f);

	[SerializeField]
	private Transform HelmetTransform;

	[SerializeField]
	private MeshRenderer HelmetRenderer;

	[SerializeField]
	private SkinnedMeshRenderer RacerRenderer;

	[SerializeField]
	private MeshRenderer KartRenderer;

	[SerializeField]
	private MeshRenderer KartRenderer2;

	[SerializeField]
	private Locator DashboardCamLocator;

	private AudioSource m_audioSource;

	private GameObject m_currentHelmetProp;

	private GameObject m_currentVisorProp;

	private GameObject m_currentDashboardProp;

	private GameObject m_currentDashboardStyle;

	private string m_currentHornID = string.Empty;

	private bool m_dashboardCam;

	private bool m_waitForFade;

	public void PlayHornAudio(int hornIndex)
	{
		CustomisedObjectManager.Instance.PlayHornByIndex(hornIndex, ref m_audioSource);
	}

	public void PlayHornAudio(string filename)
	{
		CustomisedObjectManager.Instance.PlayHornByID(filename, ref m_audioSource);
	}

	public void UpdateColoursOnKart()
	{
		ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(0);
		if ((bool)RacerRenderer)
		{
			UnityEngine.Color racerPrimary = playerData.m_playerColours.RacerPrimary;
			RacerRenderer.material.SetColor("_Color1", racerPrimary);
			racerPrimary = playerData.m_playerColours.RacerSecondary;
			RacerRenderer.material.SetColor("_Color2", racerPrimary);
		}
		if ((bool)KartRenderer)
		{
			UnityEngine.Color kartPrimary = playerData.m_playerColours.KartPrimary;
			KartRenderer.material.SetColor("_Color1", kartPrimary);
			kartPrimary = playerData.m_playerColours.KartSecondary;
			KartRenderer.material.SetColor("_Color2", kartPrimary);
		}
		if ((bool)KartRenderer2)
		{
			UnityEngine.Color kartPrimary2 = playerData.m_playerColours.KartPrimary;
			KartRenderer2.material.SetColor("_Color5", kartPrimary2);
			kartPrimary2 = playerData.m_playerColours.KartSecondary;
			KartRenderer2.material.SetColor("_Color6", kartPrimary2);
		}
		if ((bool)HelmetRenderer)
		{
			Material material = ((HelmetRenderer.materials.Length <= 1) ? HelmetRenderer.material : HelmetRenderer.materials[1]);
			UnityEngine.Color helmetPrimary = playerData.m_playerColours.HelmetPrimary;
			material.SetColor("_Color3", helmetPrimary);
			helmetPrimary = playerData.m_playerColours.HelmetSecondary;
			material.SetColor("_Color4", helmetPrimary);
		}
	}

	public void TryOutHorn(string ID)
	{
		m_currentHornID = ID;
	}

	public void TryOutHelmetProp(ref CustomisedObject obj)
	{
		if ((bool)m_currentHelmetProp)
		{
			UnityEngine.Object.Destroy(m_currentHelmetProp);
		}
		if (obj == null)
		{
			m_currentHelmetProp = null;
			return;
		}
		GameObject meshRoot = obj.GetMeshRoot();
		m_currentHelmetProp = UnityEngine.Object.Instantiate(meshRoot);
		m_currentHelmetProp.transform.parent = GetComponent<AccessoryLocator>().GetLocatorByType(obj.CustomiseObject.LocatorID);
		m_currentHelmetProp.transform.localPosition = Vector3.zero;
		m_currentHelmetProp.transform.localRotation = Quaternion.identity;
		m_currentHelmetProp.transform.localScale = Vector3.one;
		m_currentHelmetProp.gameObject.SetActive(value: true);
	}

	public void TryOutVisorProp(ref CustomisedObject obj)
	{
		if ((bool)m_currentVisorProp)
		{
			UnityEngine.Object.Destroy(m_currentVisorProp);
		}
		if (obj == null)
		{
			m_currentVisorProp = null;
			return;
		}
		GameObject meshRoot = obj.GetMeshRoot();
		m_currentVisorProp = UnityEngine.Object.Instantiate(meshRoot);
		m_currentVisorProp.transform.parent = GetComponent<AccessoryLocator>().GetLocatorByType(obj.CustomiseObject.LocatorID);
		m_currentVisorProp.transform.localPosition = Vector3.zero;
		m_currentVisorProp.transform.localRotation = Quaternion.identity;
		m_currentVisorProp.transform.localScale = Vector3.one;
		m_currentVisorProp.gameObject.SetActive(value: true);
	}

	public void TryOutDashboardProp(ref CustomisedObject obj)
	{
		if ((bool)m_currentDashboardProp)
		{
			UnityEngine.Object.Destroy(m_currentDashboardProp);
		}
		if (obj == null)
		{
			m_currentDashboardProp = null;
			return;
		}
		GameObject meshRoot = obj.GetMeshRoot();
		m_currentDashboardProp = UnityEngine.Object.Instantiate(meshRoot);
		m_currentDashboardProp.transform.parent = GetComponent<AccessoryLocator>().GetLocatorByType(obj.CustomiseObject.LocatorID);
		m_currentDashboardProp.transform.localPosition = Vector3.zero;
		m_currentDashboardProp.transform.localRotation = Quaternion.identity;
		m_currentDashboardProp.transform.localScale = Vector3.one;
		m_currentDashboardProp.gameObject.SetActive(value: true);
	}

	public void TryOutDashboardStyle(ref CustomisedObject obj)
	{
		if ((bool)m_currentDashboardStyle)
		{
			UnityEngine.Object.Destroy(m_currentDashboardStyle);
		}
		if (obj == null)
		{
			m_currentDashboardStyle = null;
			return;
		}
		GameObject meshRoot = obj.GetMeshRoot();
		m_currentDashboardStyle = UnityEngine.Object.Instantiate(meshRoot);
		m_currentDashboardStyle.transform.parent = GetComponent<AccessoryLocator>().GetLocatorByType(obj.CustomiseObject.LocatorID);
		m_currentDashboardStyle.transform.localPosition = Vector3.zero;
		m_currentDashboardStyle.transform.localRotation = Quaternion.identity;
		m_currentDashboardStyle.transform.localScale = Vector3.one;
		m_currentDashboardStyle.gameObject.SetActive(value: true);
	}

	private void Start()
	{
		m_audioSource = GetComponent<AudioSource>();
		m_dashboardCam = false;
		m_waitForFade = false;
	}

	private void Update()
	{
		UpdateHeadRotation();
		UpdateHorn();
	}

	private void UpdateHeadRotation()
	{
		Vector3 localEulerAngles = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.localEulerAngles;
		if (localEulerAngles.y < 180f && localEulerAngles.y > PlayerHeadAngle.y)
		{
			localEulerAngles.y = PlayerHeadAngle.y;
		}
		if (localEulerAngles.y > 180f && localEulerAngles.y < 360f - PlayerHeadAngle.y)
		{
			localEulerAngles.y = 360f - PlayerHeadAngle.y;
		}
		if (localEulerAngles.x < 180f && localEulerAngles.x > PlayerHeadAngle.x)
		{
			localEulerAngles.x = PlayerHeadAngle.x;
		}
		if (localEulerAngles.x > 180f && localEulerAngles.x < 360f - PlayerHeadAngle.x)
		{
			localEulerAngles.x = 360f - PlayerHeadAngle.x;
		}
		if (localEulerAngles.z < 180f && localEulerAngles.z > PlayerHeadAngle.z)
		{
			localEulerAngles.z = PlayerHeadAngle.z;
		}
		if (localEulerAngles.z > 180f && localEulerAngles.z < 360f - PlayerHeadAngle.z)
		{
			localEulerAngles.z = 360f - PlayerHeadAngle.z;
		}
		HelmetTransform.localEulerAngles = localEulerAngles;
	}

	private void UpdateHorn()
	{
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_X) && m_currentHornID != string.Empty)
		{
			PlayHornAudio(m_currentHornID);
		}
	}

	private void UpdateDashboardCam()
	{
		if (!m_dashboardCam && !ExtraCustomisation.Instance.MenuActive() && (InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Acceleration) > 0.8f || InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Acceleration) < -0.8f))
		{
			m_waitForFade = true;
			m_dashboardCam = true;
			FadeManager.Instance.FadeOut(0.25f);
		}
		else if (m_dashboardCam && InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Acceleration) < 0.8f && InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Acceleration) > -0.8f)
		{
			m_waitForFade = true;
			m_dashboardCam = false;
			FadeManager.Instance.FadeOut(0.25f);
		}
		if (!m_waitForFade || !FadeManager.Instance.FinishedFading())
		{
			return;
		}
		if (m_dashboardCam)
		{
			HelmetRenderer.gameObject.layer = 12;
			if (m_currentHelmetProp != null)
			{
				m_currentHelmetProp.layer = 12;
				MeshRenderer[] componentsInChildren = m_currentHelmetProp.GetComponentsInChildren<MeshRenderer>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].gameObject.layer = 12;
				}
			}
			if (m_currentVisorProp != null)
			{
				m_currentVisorProp.layer = 12;
				MeshRenderer[] componentsInChildren2 = m_currentVisorProp.GetComponentsInChildren<MeshRenderer>();
				for (int j = 0; j < componentsInChildren2.Length; j++)
				{
					componentsInChildren2[j].gameObject.layer = 12;
				}
			}
			CameraManager.Instance.SetNewTransform(DashboardCamLocator.transform);
		}
		else
		{
			HelmetRenderer.gameObject.layer = 0;
			if (m_currentHelmetProp != null)
			{
				m_currentHelmetProp.layer = 12;
				MeshRenderer[] componentsInChildren3 = m_currentHelmetProp.GetComponentsInChildren<MeshRenderer>();
				for (int k = 0; k < componentsInChildren3.Length; k++)
				{
					componentsInChildren3[k].gameObject.layer = 0;
				}
			}
			if (m_currentVisorProp != null)
			{
				m_currentVisorProp.layer = 0;
				MeshRenderer[] componentsInChildren4 = m_currentVisorProp.GetComponentsInChildren<MeshRenderer>();
				for (int l = 0; l < componentsInChildren4.Length; l++)
				{
					componentsInChildren4[l].gameObject.layer = 0;
				}
			}
			CameraManager.Instance.SetNewTransform(ExtraCustomisation.Instance.CameraLocator.transform);
		}
		m_waitForFade = false;
		FadeManager.Instance.FadeIn();
	}
}
public class CustomiseSaveData : UnityEngine.MonoBehaviour
{
	private static readonly int KeyLength = 24;

	private static readonly int IVLength = 8;

	private TripleDES algorithm;

	private TripleDESCryptoServiceProvider serviceProvider;

	private string m_customiseFile = string.Empty;

	public void SaveData()
	{
		List<MarketCatalogue.CatalogueData> allCatalogueData = GameSystem.Instance.GetMarket().GetAllCatalogueData();
		List<MarketCatalogue.ItemData> itemList = new List<MarketCatalogue.ItemData>();
		float currency = 0f;
		GameSystem.Instance.GetMarket().GetAllItemData(ref itemList, ref currency);
		using FileStream stream = new FileStream(m_customiseFile, FileMode.Create, FileAccess.Write);
		using CryptoStream cryptoStream = new CryptoStream(stream, serviceProvider.CreateEncryptor(algorithm.Key, algorithm.IV), CryptoStreamMode.Write);
		using StreamWriter streamWriter = new StreamWriter(cryptoStream);
		streamWriter.WriteLine(ProfileManager.SHOP_VERSION_NO);
		string text = currency + "|" + allCatalogueData.Count + "|";
		for (int i = 0; i < allCatalogueData.Count; i++)
		{
			string text2 = text;
			text = text2 + allCatalogueData[i].displayName + "|" + allCatalogueData[i].itemID + "|" + allCatalogueData[i].type.ToString() + "|" + allCatalogueData[i].cost + "|" + allCatalogueData[i].filename.ToString() + "|";
		}
		streamWriter.WriteLine(text);
		text = itemList.Count + "|";
		for (int j = 0; j < itemList.Count; j++)
		{
			text = text + itemList[j].itemID + "|";
		}
		streamWriter.WriteLine(text);
		text = string.Empty;
		for (int k = 0; k < ExtraCustomisation.Instance.MenuData.Length; k++)
		{
			for (int l = 0; l < 6; l++)
			{
				text = text + ExtraCustomisation.Instance.MenuData[k].m_storedLevel[l] + "|";
				text = text + ExtraCustomisation.Instance.MenuData[k].m_storedItem[l].x + "|";
				text = text + ExtraCustomisation.Instance.MenuData[k].m_storedItem[l].y + "|";
			}
		}
		streamWriter.WriteLine(text);
		streamWriter.Flush();
		cryptoStream.FlushFinalBlock();
	}

	public void LoadData()
	{
		try
		{
			string empty = string.Empty;
			List<MarketCatalogue.CatalogueData> list = new List<MarketCatalogue.CatalogueData>();
			List<MarketCatalogue.ItemData> list2 = new List<MarketCatalogue.ItemData>();
			int num = 2;
			if (!File.Exists(m_customiseFile))
			{
				return;
			}
			float currency = 0f;
			using FileStream stream = new FileStream(m_customiseFile, FileMode.Open, FileAccess.Read);
			using CryptoStream stream2 = new CryptoStream(stream, serviceProvider.CreateDecryptor(algorithm.Key, algorithm.IV), CryptoStreamMode.Read);
			using StreamReader streamReader = new StreamReader(stream2);
			empty = streamReader.ReadLine();
			if (ProfileManager.SHOP_VERSION_NO != empty)
			{
				return;
			}
			empty = streamReader.ReadLine();
			if (GameSystem.Instance.GetMarket().GetAllCatalogueData().Count == 0)
			{
				string[] array = empty.Split("|"[0]);
				currency = float.Parse(array[0]);
				for (int i = 0; i < int.Parse(array[1]); i++)
				{
					MarketCatalogue.CatalogueData item = default(MarketCatalogue.CatalogueData);
					item.displayName = array[num++];
					item.itemID = array[num++];
					switch (array[num++])
					{
					default:
						UnityEngine.Debug.LogError("Unknown catalogue type");
						break;
					case "Unknown":
						item.type = MarketCatalogue.ItemType.Unknown;
						break;
					case "HelmetProp":
						item.type = MarketCatalogue.ItemType.HelmetProp;
						break;
					case "VisorProp":
						item.type = MarketCatalogue.ItemType.VisorProp;
						break;
					case "DashboardProp":
						item.type = MarketCatalogue.ItemType.DashboardProp;
						break;
					case "DashboardStyle":
						item.type = MarketCatalogue.ItemType.DashboardStyle;
						break;
					case "HornSFX":
						item.type = MarketCatalogue.ItemType.HornSFX;
						break;
					}
					item.cost = float.Parse(array[num++]);
					item.filename = array[num++];
					list.Add(item);
				}
			}
			empty = streamReader.ReadLine();
			num = 1;
			if (GameSystem.Instance.GetMarket().GetAllCatalogueData().Count == 0)
			{
				string[] array2 = empty.Split("|"[0]);
				for (int j = 0; j < int.Parse(array2[0]); j++)
				{
					MarketCatalogue.ItemData item2 = default(MarketCatalogue.ItemData);
					item2.itemID = array2[num++];
					list2.Add(item2);
				}
				GameSystem.Instance.GetMarket().SetAllCatalogueData(list);
				GameSystem.Instance.GetMarket().SetAllItemData(list2, currency);
			}
			empty = streamReader.ReadLine();
			string[] array3 = empty.Split("|"[0]);
			num = 0;
			for (int k = 0; k < ExtraCustomisation.Instance.MenuData.Length; k++)
			{
				for (int l = 0; l < 6; l++)
				{
					ExtraCustomisation.Instance.MenuData[k].m_storedLevel[l] = int.Parse(array3[num++]);
					ExtraCustomisation.Instance.MenuData[k].m_storedItem[l].x = float.Parse(array3[num++]);
					ExtraCustomisation.Instance.MenuData[k].m_storedItem[l].y = float.Parse(array3[num++]);
				}
			}
		}
		catch (Exception)
		{
			UnityEngine.Debug.Log("Customise load error");
		}
	}

	private void Awake()
	{
		m_customiseFile = UnityEngine.Application.persistentDataPath + "/SaveData_GearVR_2.bin";
		string input = SystemInfo.deviceUniqueIdentifier + " vpg_vrkarts_cust_GearVR";
		algorithm = TripleDES.Create();
		algorithm.Key = MakeKey(input);
		algorithm.IV = MakeIV(input);
		serviceProvider = new TripleDESCryptoServiceProvider();
	}

	private byte[] MakeKey(string input)
	{
		string s = input.PadRight(KeyLength, '0').Substring(0, KeyLength);
		return Encoding.ASCII.GetBytes(s);
	}

	private byte[] MakeIV(string input)
	{
		string s = input.PadRight(IVLength, '0').Substring(0, IVLength);
		return Encoding.ASCII.GetBytes(s);
	}
}
public class ExtraCustomisation : UnityEngine.MonoBehaviour
{
	public struct MenuOptionData
	{
		public int[] m_storedLevel;

		public Vector2[] m_storedItem;
	}

	[SerializeField]
	public Locator CameraLocator;

	[SerializeField]
	public MenuCustomisation[] MenuObjects;

	[SerializeField]
	private MenuHint MenuHintObject;

	[SerializeField]
	private Collider[] MenuCollider;

	[SerializeField]
	private Collider[] MenuHoldCollider;

	[SerializeField]
	private Collider DialogCollider;

	[SerializeField]
	private Collider QuitCollider;

	[SerializeField]
	private GameObject Scenery;

	[SerializeField]
	private GameObject QuitPad;

	[SerializeField]
	private GameObject QuitGearRemote;

	[SerializeField]
	private GameObject[] Lines;

	[SerializeField]
	private GameObject[] VerticalArrows;

	[SerializeField]
	private GameObject[] HorizontalArrows;

	public static ExtraCustomisation Instance;

	public CustomisePlayer CustomisedPlayer;

	public ShoppingList ShoppingList;

	public GameObject HighlightedUIObject;

	private bool m_menuEnabled;

	private CustomiseSaveData m_saveData;

	private ShoppingList m_shoppingList;

	private AudioSource m_audioSource;

	public MenuOptionData[] MenuData;

	public bool HitDialog { get; private set; }

	public bool HitQuit { get; private set; }

	public bool ColoursEnabled { get; set; }

	public bool HitDownArrow { get; private set; }

	public bool HitUpArrow { get; private set; }

	public bool CustomisationActive()
	{
		return m_menuEnabled;
	}

	public bool MenuActive()
	{
		return MenuObjects[0].MenuInFocus() || MenuObjects[1].MenuInFocus();
	}

	public void EnableVerticalArrows(bool enable)
	{
		for (int i = 0; i < VerticalArrows.Length; i++)
		{
			VerticalArrows[i].SetActive(enable);
		}
	}

	public void EnableCustomisation(bool enable)
	{
		if (enable)
		{
			MenuHintObject.gameObject.SetActive(value: true);
			CustomisedPlayer.gameObject.SetActive(value: true);
			Scenery.gameObject.SetActive(value: true);
			CameraManager.Instance.GetCurrentCamera().transform.rotation = CameraLocator.transform.rotation;
			CameraManager.Instance.SetNewTransform(CameraLocator.transform);
			CameraManager.Instance.UpdateFollow(CameraLocator.transform.gameObject);
			FadeManager.Instance.FadeIn();
			BeginMenu();
			FEMManager.Instance.GetControllerSpot().transform.parent = CameraLocator.transform;
			FEMManager.Instance.GetControllerSpot().transform.position = Vector3.zero;
			FEMManager.Instance.GetControllerSpot().transform.rotation = Quaternion.identity;
			MenuObjects[0].EnableMenu(enable: true);
			bool flag = InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController;
			for (int i = 0; i < Lines.Length; i++)
			{
				Lines[i].SetActive(!flag);
			}
			for (int j = 0; j < VerticalArrows.Length; j++)
			{
				VerticalArrows[j].SetActive(value: false);
			}
			for (int k = 0; k < HorizontalArrows.Length; k++)
			{
				HorizontalArrows[k].SetActive(!flag);
			}
		}
		else
		{
			MenuHintObject.gameObject.SetActive(value: false);
			CustomisedPlayer.gameObject.SetActive(value: false);
			Scenery.gameObject.SetActive(value: false);
		}
	}

	public void AssignProp(MenuCustomisation.CurrentCustomisation customisation, string filename)
	{
		ProfileManager.PlayerData data = ProfileManager.Instance.GetPlayerData(0);
		switch (customisation)
		{
		default:
			UnityEngine.Debug.LogError("Unsupported customised type");
			break;
		case MenuCustomisation.CurrentCustomisation.Horn:
			data.m_customisationData.m_horn = filename;
			break;
		case MenuCustomisation.CurrentCustomisation.HelmetProp:
			data.m_customisationData.m_helmetProp = filename;
			break;
		case MenuCustomisation.CurrentCustomisation.VisorProp:
			data.m_customisationData.m_visorProp = filename;
			break;
		case MenuCustomisation.CurrentCustomisation.DashboardProp:
			data.m_customisationData.m_dashProp = filename;
			break;
		case MenuCustomisation.CurrentCustomisation.DashboardStyle:
			data.m_customisationData.m_dashStyle = filename;
			break;
		}
		ProfileManager.Instance.SetPlayerData(0, ref data);
	}

	public void TryOutProp(MenuCustomisation.CurrentCustomisation customisation, string filename)
	{
		switch (customisation)
		{
		default:
			UnityEngine.Debug.LogError("Unsupported customised type");
			break;
		case MenuCustomisation.CurrentCustomisation.Horn:
			CustomisedPlayer.TryOutHorn(filename);
			break;
		case MenuCustomisation.CurrentCustomisation.HelmetProp:
		{
			CustomisedObject obj4 = CustomisedObjectManager.Instance.GetHelmetPropByID(filename);
			if ((bool)obj4 || filename == string.Empty)
			{
				CustomisedPlayer.TryOutHelmetProp(ref obj4);
			}
			break;
		}
		case MenuCustomisation.CurrentCustomisation.VisorProp:
		{
			CustomisedObject obj2 = CustomisedObjectManager.Instance.GetVisorPropByID(filename);
			if ((bool)obj2 || filename == string.Empty)
			{
				CustomisedPlayer.TryOutVisorProp(ref obj2);
			}
			break;
		}
		case MenuCustomisation.CurrentCustomisation.DashboardProp:
		{
			CustomisedObject obj3 = CustomisedObjectManager.Instance.GetDashboardPropByID(filename);
			if ((bool)obj3 || filename == string.Empty)
			{
				CustomisedPlayer.TryOutDashboardProp(ref obj3);
			}
			break;
		}
		case MenuCustomisation.CurrentCustomisation.DashboardStyle:
		{
			CustomisedObject obj = CustomisedObjectManager.Instance.GetDashboardStyleByID(filename);
			if ((bool)obj || filename == string.Empty)
			{
				CustomisedPlayer.TryOutDashboardStyle(ref obj);
			}
			break;
		}
		}
	}

	private void BeginMenu()
	{
		m_menuEnabled = true;
		MenuObjects[0].ForceUpdate = true;
		MenuObjects[1].ForceUpdate = true;
		MenuCollider[0].gameObject.SetActive(value: true);
		MenuCollider[1].gameObject.SetActive(value: true);
		MenuHoldCollider[0].gameObject.SetActive(value: false);
		MenuHoldCollider[1].gameObject.SetActive(value: false);
		UpdateColoursOnKart();
		ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(0);
		TryOutProp(MenuCustomisation.CurrentCustomisation.HelmetProp, playerData.m_customisationData.m_helmetProp);
		TryOutProp(MenuCustomisation.CurrentCustomisation.VisorProp, playerData.m_customisationData.m_visorProp);
		TryOutProp(MenuCustomisation.CurrentCustomisation.DashboardProp, playerData.m_customisationData.m_dashProp);
		TryOutProp(MenuCustomisation.CurrentCustomisation.DashboardStyle, playerData.m_customisationData.m_dashStyle);
		TryOutProp(MenuCustomisation.CurrentCustomisation.Horn, playerData.m_customisationData.m_horn);
	}

	public void EndMenu()
	{
		m_menuEnabled = false;
		MenuObjects[0].EndMenu();
		MenuObjects[1].EndMenu();
	}

	public void FinishedWithCustomisation()
	{
		TryOutProp(MenuCustomisation.CurrentCustomisation.HelmetProp, string.Empty);
		TryOutProp(MenuCustomisation.CurrentCustomisation.VisorProp, string.Empty);
		TryOutProp(MenuCustomisation.CurrentCustomisation.DashboardProp, string.Empty);
		TryOutProp(MenuCustomisation.CurrentCustomisation.DashboardStyle, string.Empty);
	}

	public void UpdateColoursOnKart()
	{
		CustomisedPlayer.UpdateColoursOnKart();
	}

	public void PlayClip(AudioClip clip)
	{
		m_audioSource.clip = clip;
		m_audioSource.Play();
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		m_audioSource = GetComponent<AudioSource>();
		MenuData = new MenuOptionData[MenuObjects.Length];
		for (int i = 0; i < MenuObjects.Length; i++)
		{
			MenuData[i].m_storedLevel = new int[6];
			MenuData[i].m_storedItem = new Vector2[6];
			MenuObjects[i].MenuIndex = i;
		}
		ColoursEnabled = false;
		m_menuEnabled = false;
		m_saveData = GetComponent<CustomiseSaveData>();
		m_saveData.LoadData();
	}

	private void Update()
	{
		if (!m_menuEnabled)
		{
			return;
		}
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
		{
			if (QuitGearRemote.gameObject.activeSelf)
			{
				QuitGearRemote.gameObject.SetActive(value: false);
			}
			if (!QuitPad.gameObject.activeSelf)
			{
				QuitPad.gameObject.SetActive(value: true);
			}
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_Y))
			{
				if ((bool)FEMManager.Instance)
				{
					PlayClip(FEMManager.Instance.MenuClosed);
				}
				EndMenu();
				FEMManager.Instance.EndCustomisation();
				FadeManager.Instance.FadeOut();
				return;
			}
		}
		else if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			if (!QuitGearRemote.gameObject.activeSelf)
			{
				QuitGearRemote.gameObject.SetActive(value: true);
			}
			if (QuitPad.gameObject.activeSelf)
			{
				QuitPad.gameObject.SetActive(value: false);
			}
		}
		MenuHintObject.transform.position = CameraManager.Instance.GetCurrentCamera().transform.position;
		MenuHintObject.transform.position += CameraManager.Instance.GetCurrentCamera().transform.forward;
		if (HitQuit && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			if ((bool)FEMManager.Instance)
			{
				PlayClip(FEMManager.Instance.MenuClosed);
			}
			m_saveData.SaveData();
			EndMenu();
			FEMManager.Instance.EndCustomisation();
			FadeManager.Instance.FadeOut();
			return;
		}
		bool flag = (bool)NetworkLogin.Instance && NetworkLogin.Instance.ConnectedToMaster();
		MenuObjects[1].SetOnline(flag);
		HitDialog = false;
		HitQuit = false;
		HitUpArrow = false;
		HitDownArrow = false;
		Transform controllerSpot = FEMManager.Instance.GetControllerSpot();
		Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
		Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
		RaycastHit[] array = Physics.RaycastAll(ray, 1000f, LayerMask.GetMask("UI", "ShopPanel", "ColourPanel"));
		if (array.Length > 0)
		{
			MenuHintObject.SetHighlight(set: true);
			for (int i = 0; i < array.Length; i++)
			{
				RaycastHit raycastHit = array[i];
				if (raycastHit.collider == QuitCollider || (MenuCollider[0].gameObject.activeSelf && raycastHit.collider.gameObject == MenuCollider[0].gameObject))
				{
					if (raycastHit.collider == QuitCollider)
					{
						HitQuit = true;
					}
					MenuCollider[0].gameObject.SetActive(value: false);
					MenuHoldCollider[0].gameObject.SetActive(value: true);
					if (!MenuObjects[1].MenuInFocus())
					{
					}
				}
				else if (flag && MenuCollider[1].gameObject.activeSelf && raycastHit.collider.gameObject == MenuCollider[1].gameObject)
				{
					MenuCollider[1].gameObject.SetActive(value: false);
					MenuHoldCollider[1].gameObject.SetActive(value: true);
					if (!MenuObjects[0].MenuInFocus())
					{
					}
				}
				else if (raycastHit.collider == DialogCollider)
				{
					HitDialog = true;
				}
				else if (!ColoursEnabled && raycastHit.collider.gameObject.layer == LayerMask.NameToLayer("UI"))
				{
					HighlightedUIObject = raycastHit.collider.gameObject;
				}
				else if (ColoursEnabled && raycastHit.collider.gameObject.layer == LayerMask.NameToLayer("ColourPanel"))
				{
					HighlightedUIObject = raycastHit.collider.gameObject;
				}
			}
		}
		if (HighlightedUIObject == VerticalArrows[0].gameObject)
		{
			HitUpArrow = true;
		}
		else if (HighlightedUIObject == VerticalArrows[1].gameObject)
		{
			HitDownArrow = true;
		}
		UpdateArrowScale();
		if (array.Length != 0 && !HitQuit)
		{
			return;
		}
		MenuHintObject.SetHighlight(set: false);
		for (int j = 0; j < MenuObjects.Length; j++)
		{
			if (MenuObjects[j].MenuInFocus())
			{
			}
		}
		if (!MenuCollider[0].gameObject.activeSelf)
		{
			MenuCollider[0].gameObject.SetActive(value: true);
			MenuHoldCollider[0].gameObject.SetActive(value: false);
		}
		if (!MenuCollider[1].gameObject.activeSelf)
		{
			MenuCollider[1].gameObject.SetActive(value: true);
			MenuHoldCollider[1].gameObject.SetActive(value: false);
		}
	}

	private void UpdateArrowScale()
	{
		if (HitUpArrow)
		{
			VerticalArrows[0].gameObject.transform.localScale = Vector3.Lerp(VerticalArrows[0].gameObject.transform.localScale, new Vector3(-1.2f, 1.2f, 1.2f), 6f * GameTime.Instance.DeltaTime());
		}
		else
		{
			VerticalArrows[0].gameObject.transform.localScale = Vector3.Lerp(VerticalArrows[0].gameObject.transform.localScale, new Vector3(-1f, 1f, 1f), 6f * GameTime.Instance.DeltaTime());
		}
		if (HitDownArrow)
		{
			VerticalArrows[1].gameObject.transform.localScale = Vector3.Lerp(VerticalArrows[1].gameObject.transform.localScale, new Vector3(-1.2f, 1.2f, 1.2f), 6f * GameTime.Instance.DeltaTime());
		}
		else
		{
			VerticalArrows[1].gameObject.transform.localScale = Vector3.Lerp(VerticalArrows[1].gameObject.transform.localScale, new Vector3(-1f, 1f, 1f), 6f * GameTime.Instance.DeltaTime());
		}
	}
}
public abstract class MenuCustomisation : UnityEngine.MonoBehaviour
{
	public enum CurrentCustomisation
	{
		HelmetProp,
		Colours,
		DashboardProp,
		DashboardStyle,
		Horn,
		VisorProp,
		Max
	}

	[SerializeField]
	private Text CustomisationTitle;

	[SerializeField]
	private Text CustomisationPrice;

	[SerializeField]
	protected CurrentCustomisation[] OptionsAvailable;

	[SerializeField]
	private string[] OptionsAvailableText;

	[SerializeField]
	private MenuIcon[] MenuIconList;

	[SerializeField]
	protected ShopTile[] Tiles;

	[SerializeField]
	protected Vector2 StartPosition;

	[SerializeField]
	protected Vector2 SeparatorSize;

	[SerializeField]
	private RawImage GreyOut;

	[SerializeField]
	private Text NoItemsText;

	[SerializeField]
	private Text NotOnlineText;

	[SerializeField]
	private Sprite NoneImage;

	[SerializeField]
	private GameObject SelectOption;

	protected Vector2 m_currentTilePosition = new Vector2(0f, 0f);

	protected int m_currentLevel;

	private int m_currentHighlightedTile;

	private int m_mainMenuIndex;

	private int m_currentItem;

	protected bool m_menuInFocus;

	protected bool m_ignoreBaseMenuControls;

	private MarketCatalogue.CatalogueData m_currentDataItem;

	private List<MarketCatalogue.CatalogueData> m_catalogueList;

	private bool m_waitForShopItems = true;

	protected CurrentCustomisation m_currentCustomisation;

	public bool ColourMenuActive { get; set; }

	public bool ForceUpdate { get; set; }

	public int MenuIndex { get; set; }

	private void Start()
	{
		m_waitForShopItems = true;
		m_currentTilePosition = new Vector2(0f, 0f);
		m_currentLevel = 0;
	}

	public abstract void EndMenu();

	protected abstract List<MarketCatalogue.CatalogueData> GetCatalogueData();

	protected abstract void CheckForItemSelection();

	protected abstract void OnSelectedItem();

	public void SetOnline(bool online)
	{
		if (!online)
		{
			if (NotOnlineText != null && !NotOnlineText.gameObject.activeSelf)
			{
				NotOnlineText.gameObject.SetActive(value: true);
				NotOnlineText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_StoreOnline", convertToUpperCase: true);
			}
		}
		else if (NotOnlineText.gameObject.activeSelf)
		{
			NotOnlineText.gameObject.SetActive(value: false);
		}
	}

	public void EnableMenu(bool enable)
	{
		m_mainMenuIndex = 0;
		m_menuInFocus = enable;
		m_currentLevel = 0;
		InitMenus();
		EnableMenuOption(m_currentCustomisation);
	}

	public bool MenuInFocus()
	{
		return m_menuInFocus;
	}

	public bool AddToShoppingList()
	{
		if (!ExtraCustomisation.Instance.ShoppingList.ItemExists(m_currentDataItem.itemID))
		{
			ExtraCustomisation.Instance.ShoppingList.AddShoppingItem(m_currentDataItem.itemID);
			return true;
		}
		return false;
	}

	protected void AssignItem()
	{
		if (m_currentItem >= 0 && (m_currentDataItem.itemID == null || GameSystem.Instance.GetMarket().IsItemOwnedByUser(m_currentDataItem.itemID)))
		{
			ExtraCustomisation.Instance.AssignProp(m_currentCustomisation, m_currentDataItem.filename);
		}
	}

	protected virtual void InitMenus()
	{
		m_currentCustomisation = OptionsAvailable[0];
		if ((bool)CustomisationPrice)
		{
			CustomisationPrice.text = $"{GameSystem.Instance.GetMarket().GetCurrency().ToString():f2}";
		}
		MenuIconList[0].SetEnabled(enable: true);
		for (int i = 1; i < MenuIconList.Length; i++)
		{
			MenuIconList[i].SetEnabled(enable: false);
		}
		UpdateCurrentMenuOption();
	}

	protected virtual void EnableMenuOption(CurrentCustomisation customisation)
	{
	}

	protected virtual void UpdateMenus()
	{
		if (ExtraCustomisation.Instance.HitQuit)
		{
			return;
		}
		if (ForceUpdate)
		{
			UpdateCurrentMenuOption();
		}
		UpdateFocus();
		if (m_menuInFocus)
		{
			if (m_waitForShopItems && GameSystem.Instance.GetMarket().HasValidCatalogue())
			{
				m_waitForShopItems = false;
				UpdateShopItems();
			}
			if (!m_ignoreBaseMenuControls)
			{
				UpdateMenu();
			}
		}
	}

	private void UpdateFocus()
	{
		if (ColourMenuActive)
		{
			GreyOut.gameObject.SetActive(value: true);
		}
		else if (m_menuInFocus == GreyOut.gameObject.activeSelf)
		{
			GreyOut.gameObject.SetActive(!m_menuInFocus);
		}
		if (m_menuInFocus)
		{
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, Vector3.one, 4f * GameTime.Instance.DeltaTime());
		}
		else
		{
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, new Vector3(0.8f, 0.8f, 0.8f), 4f * GameTime.Instance.DeltaTime());
		}
	}

	private void UpdateMenu()
	{
		if (ForceUpdate)
		{
			UpdateShopTile();
			StorePreviousMenuOption();
			return;
		}
		for (int i = 0; i < MenuIconList.Length; i++)
		{
			if (i != m_mainMenuIndex && MenuIconList[i].gameObject.activeSelf && ExtraCustomisation.Instance.HighlightedUIObject == MenuIconList[i].gameObject && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				if ((bool)FEMManager.Instance)
				{
					ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
				}
				StorePreviousMenuOption();
				MenuIconList[m_mainMenuIndex].SetEnabled(enable: false);
				m_mainMenuIndex = i;
				UpdateCurrentMenuOption();
			}
		}
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Shop_Left))
		{
			if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			StorePreviousMenuOption();
			MenuIconList[m_mainMenuIndex].SetEnabled(enable: false);
			m_mainMenuIndex--;
			if (m_mainMenuIndex < 0)
			{
				m_mainMenuIndex = 0;
			}
			UpdateCurrentMenuOption();
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Shop_Right))
		{
			if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			StorePreviousMenuOption();
			MenuIconList[m_mainMenuIndex].SetEnabled(enable: false);
			m_mainMenuIndex++;
			if (m_mainMenuIndex > OptionsAvailable.Length - 1)
			{
				m_mainMenuIndex = OptionsAvailable.Length - 1;
			}
			UpdateCurrentMenuOption();
		}
		if (m_catalogueList != null)
		{
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				UpdatePadInput();
			}
			else
			{
				UpdateRemoteInput();
			}
		}
		if (m_currentDataItem.itemID == null || (m_currentDataItem.itemID.Length > 0 && m_currentDataItem.filename != string.Empty))
		{
			CheckForItemSelection();
		}
	}

	private void UpdatePadInput()
	{
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
		{
			if (m_currentCustomisation != CurrentCustomisation.Horn && (bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			m_currentTilePosition.x -= 1f;
			if (m_currentTilePosition.x < 0f)
			{
				m_currentTilePosition.x = 0f;
			}
			UpdateShopTile();
			StorePreviousMenuOption();
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
		{
			if (m_currentCustomisation != CurrentCustomisation.Horn && (bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			m_currentTilePosition.x += 1f;
			if (m_currentTilePosition.x > 2f)
			{
				m_currentTilePosition.x = 2f;
			}
			int tileIndexFromCoordinates = GetTileIndexFromCoordinates((int)m_currentTilePosition.x, (int)m_currentTilePosition.y);
			if (tileIndexFromCoordinates >= m_catalogueList.Count)
			{
				m_currentTilePosition.x -= 1f;
			}
			UpdateShopTile();
			StorePreviousMenuOption();
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
		{
			if (m_currentCustomisation != CurrentCustomisation.Horn && (bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			if (m_currentHighlightedTile < 3)
			{
				m_currentLevel--;
				if (m_currentLevel < 0)
				{
					m_currentLevel = 0;
				}
			}
			m_currentTilePosition.y -= 1f;
			if (m_currentTilePosition.y < 0f)
			{
				m_currentTilePosition.y = 0f;
			}
			UpdateShopTile();
			StorePreviousMenuOption();
		}
		else
		{
			if (!InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
			{
				return;
			}
			if (m_currentCustomisation != CurrentCustomisation.Horn && (bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			if (m_catalogueList.Count > 3)
			{
				if (m_currentHighlightedTile > 2)
				{
					m_currentLevel++;
				}
				m_currentTilePosition.y += 1f;
				int coX = 0;
				int coY = 0;
				GetCoordinatesFromTileIndex(m_catalogueList.Count, ref coX, ref coY);
				if (m_currentTilePosition.y > (float)coY)
				{
					m_currentTilePosition.y = coY;
				}
				m_currentLevel = Mathf.CeilToInt(m_currentTilePosition.y / 2f);
				UpdateShopTile();
				StorePreviousMenuOption();
			}
		}
	}

	private void UpdateRemoteInput()
	{
		Vector2 currentTilePosition = m_currentTilePosition;
		for (int i = 0; i < Tiles.Length; i++)
		{
			if (ExtraCustomisation.Instance.HighlightedUIObject == Tiles[i].gameObject && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				int coX = 0;
				int coY = 0;
				GetCoordinatesFromTileIndex(i, ref coX, ref coY);
				if (coX < 0)
				{
					coX = 0;
				}
				if (coY < 0)
				{
					coY = 0;
				}
				m_currentTilePosition.x = coX;
				m_currentTilePosition.y = coY + m_currentLevel;
				break;
			}
		}
		if (currentTilePosition.x != m_currentTilePosition.x || currentTilePosition.y != m_currentTilePosition.y)
		{
			UpdateShopTile();
			StorePreviousMenuOption();
		}
		if (ExtraCustomisation.Instance.HitUpArrow && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			if (m_currentTilePosition.y % 2f != 0f)
			{
				m_currentTilePosition.y -= 2f;
			}
			else
			{
				m_currentTilePosition.y -= 1f;
			}
			if (m_currentTilePosition.y < 0f)
			{
				m_currentTilePosition.y = 0f;
			}
			m_currentLevel = Mathf.CeilToInt(m_currentTilePosition.y / 2f);
			UpdateShopTile();
			StorePreviousMenuOption();
		}
		else
		{
			if (!ExtraCustomisation.Instance.HitDownArrow || !InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				return;
			}
			if (m_currentCustomisation != CurrentCustomisation.Horn && (bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			if (m_catalogueList.Count >= 3)
			{
				if (m_currentTilePosition.y % 2f != 0f)
				{
					m_currentTilePosition.y += 1f;
				}
				else
				{
					m_currentTilePosition.y += 2f;
				}
				int coX2 = 0;
				int coY2 = 0;
				GetCoordinatesFromTileIndex(m_catalogueList.Count, ref coX2, ref coY2);
				if (m_currentTilePosition.y > (float)coY2)
				{
					m_currentTilePosition.y = coY2;
				}
				m_currentLevel = Mathf.CeilToInt(m_currentTilePosition.y / 2f);
				UpdateShopTile();
				StorePreviousMenuOption();
			}
		}
	}

	private void StorePreviousMenuOption()
	{
		ExtraCustomisation.Instance.MenuData[MenuIndex].m_storedLevel[(int)m_currentCustomisation] = m_currentLevel;
		ref Vector2 reference = ref ExtraCustomisation.Instance.MenuData[MenuIndex].m_storedItem[(int)m_currentCustomisation];
		reference = m_currentTilePosition;
	}

	private void UpdateCurrentMenuOption()
	{
		m_currentCustomisation = OptionsAvailable[m_mainMenuIndex];
		MenuIconList[m_mainMenuIndex].SetEnabled(enable: true);
		m_currentLevel = ExtraCustomisation.Instance.MenuData[MenuIndex].m_storedLevel[(int)m_currentCustomisation];
		m_currentTilePosition = ExtraCustomisation.Instance.MenuData[MenuIndex].m_storedItem[(int)m_currentCustomisation];
		EnableMenuOption(m_currentCustomisation);
		UpdateShopItems();
		CustomisationTitle.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(OptionsAvailableText[m_mainMenuIndex], convertToUpperCase: true);
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			ExtraCustomisation.Instance.EnableVerticalArrows(m_currentCustomisation != CurrentCustomisation.Colours);
		}
	}

	private void UpdateShopItems()
	{
		m_catalogueList = null;
		m_catalogueList = GetCatalogueData();
		NoItemsText.gameObject.SetActive(m_catalogueList != null && m_catalogueList.Count == 0);
		if (NoItemsText.gameObject.activeSelf)
		{
			if (SelectOption.activeSelf)
			{
				SelectOption.SetActive(value: false);
			}
			if (MenuIndex == 0)
			{
				NoItemsText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_BoughtItems", convertToUpperCase: true);
			}
			else
			{
				NoItemsText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_NewStock", convertToUpperCase: true);
			}
		}
		if (m_catalogueList != null && m_catalogueList.Count > 0)
		{
			bool flag = false;
			Vector2 vector = new Vector3(StartPosition.x, StartPosition.y);
			for (int i = 0; i < m_catalogueList.Count; i++)
			{
				if (i < Tiles.Length)
				{
					if (!Tiles[i].gameObject.activeSelf)
					{
						Tiles[i].gameObject.SetActive(value: true);
					}
					ShopTile shopTile = Tiles[i];
					if (m_catalogueList.Count > 0 && i == 0)
					{
						shopTile.NameText.text = string.Empty;
						shopTile.ImageObject.sprite = NoneImage;
						if ((bool)shopTile.PriceText)
						{
							shopTile.PriceText.text = "--";
						}
					}
					else
					{
						shopTile.InternalName = m_catalogueList[i].displayName;
						if (m_catalogueList[i].type == MarketCatalogue.ItemType.HornSFX)
						{
							shopTile.ImageObject.transform.localScale = new Vector3(0.6534972f, 0.6534972f, 0.6534972f);
							shopTile.ImageObject.transform.localPosition = new Vector3(shopTile.ImageObject.transform.localPosition.x, -9.7f, shopTile.ImageObject.transform.localPosition.z);
							shopTile.NameText.text = "#" + i;
						}
						else
						{
							shopTile.ImageObject.transform.localScale = new Vector3(0.9087826f, 0.9087826f, 0.9087826f);
							shopTile.ImageObject.transform.localPosition = new Vector3(shopTile.ImageObject.transform.localPosition.x, 0f, shopTile.ImageObject.transform.localPosition.z);
							shopTile.NameText.text = string.Empty;
						}
						CustomisedObject customisedObject = null;
						customisedObject = ((m_catalogueList[i].type != MarketCatalogue.ItemType.HornSFX) ? CustomisedObjectManager.Instance.GetObjectByID(m_catalogueList[i].itemID) : CustomisedObjectManager.Instance.GetObjectByID(m_catalogueList[i].filename));
						if (customisedObject != null)
						{
							shopTile.ImageObject.sprite = customisedObject.GetDisplayImage();
						}
						if ((bool)shopTile.PriceText)
						{
							shopTile.PriceText.text = $"{m_catalogueList[i].cost.ToString():f2}";
						}
					}
				}
				if ((i + 1) % 3 == 0)
				{
					vector.x = StartPosition.x;
					vector.y += SeparatorSize.y;
					flag = true;
					continue;
				}
				vector.x += SeparatorSize.x;
				if (flag)
				{
					flag = false;
				}
			}
		}
		if (m_catalogueList == null || m_catalogueList.Count < Tiles.Length)
		{
			for (int j = ((m_catalogueList != null) ? m_catalogueList.Count : 0); j < Tiles.Length; j++)
			{
				Tiles[j].gameObject.SetActive(value: false);
			}
		}
		UpdateShopTile();
	}

	private int GetTileIndexFromCoordinates(int coX, int coY)
	{
		return coY * 3 + coX;
	}

	private void GetCoordinatesFromTileIndex(int tileIndex, ref int coX, ref int coY)
	{
		coX = tileIndex % 3;
		if (coX < 0)
		{
			coX = 2;
		}
		int num = tileIndex % 3;
		if (num > 0)
		{
			num = 3 - num;
		}
		coY = (3 - tileIndex % 3 + tileIndex) / 3 - 1;
	}

	private void UpdateShopTile()
	{
		if (m_catalogueList == null || m_catalogueList.Count == 0)
		{
			m_currentDataItem.itemID = string.Empty;
			return;
		}
		int num = 0;
		for (int i = 3 * m_currentLevel; i < m_catalogueList.Count; i++)
		{
			if (num >= Tiles.Length)
			{
				continue;
			}
			if (!Tiles[num].gameObject.activeSelf)
			{
				Tiles[num].gameObject.SetActive(value: true);
			}
			ShopTile shopTile = Tiles[num];
			if (m_catalogueList.Count > 0 && i == 0)
			{
				shopTile.NameText.text = string.Empty;
				shopTile.InternalName = shopTile.NameText.text;
				shopTile.ImageObject.sprite = NoneImage;
				shopTile.ImageObject.transform.localScale = new Vector3(0.9087826f, 0.9087826f, 0.9087826f);
				shopTile.ImageObject.transform.localPosition = new Vector3(shopTile.ImageObject.transform.localPosition.x, 0f, shopTile.ImageObject.transform.localPosition.z);
				if ((bool)shopTile.PriceText)
				{
					shopTile.PriceText.text = "--";
				}
			}
			else
			{
				shopTile.InternalName = m_catalogueList[i].displayName;
				if (m_catalogueList[i].type == MarketCatalogue.ItemType.HornSFX)
				{
					shopTile.ImageObject.transform.localScale = new Vector3(0.6534972f, 0.6534972f, 0.6534972f);
					shopTile.ImageObject.transform.localPosition = new Vector3(shopTile.ImageObject.transform.localPosition.x, -9.7f, shopTile.ImageObject.transform.localPosition.z);
					shopTile.NameText.text = "#" + i;
				}
				else
				{
					shopTile.ImageObject.transform.localScale = new Vector3(0.9087826f, 0.9087826f, 0.9087826f);
					shopTile.ImageObject.transform.localPosition = new Vector3(shopTile.ImageObject.transform.localPosition.x, 0f, shopTile.ImageObject.transform.localPosition.z);
					shopTile.NameText.text = string.Empty;
				}
				CustomisedObject objectByID = CustomisedObjectManager.Instance.GetObjectByID(m_catalogueList[i].itemID);
				if (objectByID != null)
				{
					shopTile.ImageObject.sprite = objectByID.GetDisplayImage();
				}
				if ((bool)shopTile.PriceText)
				{
					shopTile.PriceText.text = $"{m_catalogueList[i].cost.ToString():f2}";
				}
			}
			shopTile.SetHighlight(highlight: false);
			num++;
		}
		if (num < Tiles.Length)
		{
			for (int j = num; j < Tiles.Length; j++)
			{
				Tiles[j].gameObject.SetActive(value: false);
			}
		}
		int tileIndexFromCoordinates = GetTileIndexFromCoordinates((int)m_currentTilePosition.x, (int)m_currentTilePosition.y);
		if (tileIndexFromCoordinates >= m_catalogueList.Count)
		{
			m_currentTilePosition.x = 0f;
			m_currentTilePosition.y = 0f;
			tileIndexFromCoordinates = GetTileIndexFromCoordinates((int)m_currentTilePosition.x, (int)m_currentTilePosition.y);
		}
		for (int k = 0; k < 6; k++)
		{
			if (tileIndexFromCoordinates == 0 || Tiles[k].InternalName == m_catalogueList[tileIndexFromCoordinates].displayName)
			{
				m_currentHighlightedTile = k;
				Tiles[k].SetHighlight(highlight: true);
				break;
			}
		}
		if (!ForceUpdate && m_menuInFocus)
		{
			ExtraCustomisation.Instance.TryOutProp(m_currentCustomisation, m_catalogueList[tileIndexFromCoordinates].filename);
			if (m_currentCustomisation == CurrentCustomisation.Horn)
			{
				ExtraCustomisation.Instance.CustomisedPlayer.PlayHornAudio(m_catalogueList[tileIndexFromCoordinates].filename);
			}
		}
		m_currentDataItem = m_catalogueList[tileIndexFromCoordinates];
		OnSelectedItem();
	}
}
public class MenuIcon : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Image SelectedOverlay;

	public void SetEnabled(bool enable)
	{
		if (SelectedOverlay.gameObject.activeSelf != enable)
		{
			SelectedOverlay.gameObject.SetActive(enable);
		}
	}
}
public class MirrorControl : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Camera MirrorCamera;

	[SerializeField]
	private Locator KartPivot;

	[SerializeField]
	private float Radius = 2.85f;

	[SerializeField]
	private float YOffset = -0.54f;

	private float m_angle;

	private float m_targetAngle;

	private const float MovementSpeed = 10f;

	public bool EnableControls { get; set; }

	private void Start()
	{
		EnableControls = false;
	}

	private void Update()
	{
		if (EnableControls)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
			{
				m_targetAngle -= 4f;
				if (m_targetAngle < 0f)
				{
					m_angle += 360f;
					m_targetAngle += 360f;
				}
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
			{
				m_targetAngle += 4f;
				if (m_targetAngle > 360f)
				{
					m_angle -= 360f;
					m_targetAngle -= 360f;
				}
			}
		}
		m_angle = Mathf.Lerp(m_angle, m_targetAngle, 10f * GameTime.Instance.DeltaTime());
		Vector3 vector = Vector3.forward * Radius;
		vector = Quaternion.AngleAxis(m_angle, Vector3.up) * vector;
		vector += KartPivot.transform.position;
		vector += Vector3.up * YOffset;
		MirrorCamera.transform.position = vector;
		MirrorCamera.transform.LookAt(KartPivot.transform);
		Vector3 forward = MirrorCamera.transform.forward;
		forward.y = 0f;
		MirrorCamera.transform.forward = forward;
	}
}
public class PersonalCustomisation : MenuCustomisation
{
	[SerializeField]
	private GameObject ColourPopup;

	[SerializeField]
	private GameObject ColourOptionParent;

	[SerializeField]
	private ColourMenuOption[] ColourOption;

	[SerializeField]
	private GameObject ColourSelection;

	[SerializeField]
	private GameObject[] ColourPalette;

	private int m_currentColourOption;

	private Vector2 m_colourCoordinate = Vector2.zero;

	private bool m_selectedItem;

	private void Start()
	{
		ColourPopup.SetActive(value: false);
		base.ColourMenuActive = false;
		InitMenus();
	}

	private void Update()
	{
		if (ExtraCustomisation.Instance.CustomisationActive() && (base.ForceUpdate || !ExtraCustomisation.Instance.ShoppingList.DialogObject.IsActive()))
		{
			if (base.ForceUpdate)
			{
				m_menuInFocus = true;
				base.ForceUpdate = false;
			}
			UpdateMenus();
		}
	}

	protected override void InitMenus()
	{
		base.InitMenus();
		if (ColourPopup.gameObject.activeSelf)
		{
			ColourPopup.SetActive(value: false);
			base.ColourMenuActive = false;
		}
		SetupColours();
	}

	protected override void UpdateMenus()
	{
		m_ignoreBaseMenuControls = ColourPopup.activeSelf;
		base.UpdateMenus();
		if (m_menuInFocus && m_currentCustomisation == CurrentCustomisation.Colours)
		{
			UpdateColours();
		}
	}

	protected override List<MarketCatalogue.CatalogueData> GetCatalogueData()
	{
		List<MarketCatalogue.CatalogueData> list = new List<MarketCatalogue.CatalogueData>();
		List<MarketCatalogue.ItemData> personalInventory = GameSystem.Instance.GetMarket().GetPersonalInventory();
		if (m_currentCustomisation == CurrentCustomisation.HelmetProp || m_currentCustomisation == CurrentCustomisation.VisorProp || m_currentCustomisation == CurrentCustomisation.DashboardProp || m_currentCustomisation == CurrentCustomisation.DashboardStyle)
		{
			for (int i = 0; i < personalInventory.Count; i++)
			{
				MarketCatalogue.CatalogueData data = default(MarketCatalogue.CatalogueData);
				if (!GameSystem.Instance.GetMarket().GetCatalogueDataItemByID(personalInventory[i].itemID, ref data))
				{
					continue;
				}
				switch (m_currentCustomisation)
				{
				case CurrentCustomisation.HelmetProp:
					if (data.type == MarketCatalogue.ItemType.HelmetProp)
					{
						list.Add(data);
					}
					break;
				case CurrentCustomisation.VisorProp:
					if (data.type == MarketCatalogue.ItemType.VisorProp)
					{
						list.Add(data);
					}
					break;
				case CurrentCustomisation.DashboardProp:
					if (data.type == MarketCatalogue.ItemType.DashboardProp)
					{
						list.Add(data);
					}
					break;
				case CurrentCustomisation.DashboardStyle:
					if (data.type == MarketCatalogue.ItemType.DashboardStyle)
					{
						list.Add(data);
					}
					break;
				}
			}
			if (list.Count > 0)
			{
				MarketCatalogue.CatalogueData item = default(MarketCatalogue.CatalogueData);
				item.available = true;
				item.filename = string.Empty;
				item.cost = 0f;
				list.Insert(0, item);
			}
			return list;
		}
		if (m_currentCustomisation == CurrentCustomisation.Horn)
		{
			MarketCatalogue.CatalogueData catalogueData = default(MarketCatalogue.CatalogueData);
			MarketCatalogue.CatalogueData item2 = default(MarketCatalogue.CatalogueData);
			item2.available = true;
			item2.filename = string.Empty;
			item2.cost = 0f;
			list.Add(item2);
			for (int j = 0; j < CustomisedObjectManager.Instance.GetTotalHorns(); j++)
			{
				if (CustomisedObjectManager.Instance.IsHornAvailableToPlayer(j))
				{
					catalogueData = default(MarketCatalogue.CatalogueData);
					catalogueData.displayName = CustomisedObjectManager.Instance.GetHornDisplayNameByIndex(j);
					catalogueData.cost = 0f;
					catalogueData.type = MarketCatalogue.ItemType.HornSFX;
					catalogueData.itemID = "Internal_" + catalogueData.displayName;
					catalogueData.filename = CustomisedObjectManager.Instance.GetHornIdentifierByIndex(j);
					list.Add(catalogueData);
				}
			}
			for (int k = 0; k < personalInventory.Count; k++)
			{
				MarketCatalogue.CatalogueData data2 = default(MarketCatalogue.CatalogueData);
				if (GameSystem.Instance.GetMarket().GetCatalogueDataItemByID(personalInventory[k].itemID, ref data2) && data2.type == MarketCatalogue.ItemType.HornSFX)
				{
					list.Add(data2);
				}
			}
			return list;
		}
		return null;
	}

	protected override void EnableMenuOption(CurrentCustomisation customisation)
	{
		ColourOptionParent.SetActive(customisation == CurrentCustomisation.Colours);
	}

	protected override void OnSelectedItem()
	{
		m_selectedItem = false;
	}

	protected override void CheckForItemSelection()
	{
		if (!m_selectedItem)
		{
			m_selectedItem = true;
			AssignItem();
		}
	}

	public override void EndMenu()
	{
		if (ColourPopup.gameObject.activeSelf)
		{
			ColourPopup.SetActive(value: false);
			base.ColourMenuActive = false;
		}
	}

	private void SetupColours()
	{
		m_currentColourOption = 0;
		ColourOption[0].SetFlashing(m_menuInFocus);
		for (int i = 1; i < ColourOption.Length; i++)
		{
			ColourOption[i].SetFlashing(flash: false);
		}
		ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(0);
		ColourOption[0].SetColour(playerData.m_playerColours.HelmetPrimary);
		ColourOption[1].SetColour(playerData.m_playerColours.HelmetSecondary);
		ColourOption[2].SetColour(playerData.m_playerColours.RacerPrimary);
		ColourOption[3].SetColour(playerData.m_playerColours.RacerSecondary);
		ColourOption[4].SetColour(playerData.m_playerColours.KartPrimary);
		ColourOption[5].SetColour(playerData.m_playerColours.KartSecondary);
		ColourOption[6].SetColour(playerData.m_playerColours.BoostTrail);
	}

	private void UpdateColours()
	{
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			if (ColourPopup.activeSelf)
			{
				int num = 4 * (int)m_colourCoordinate.x + (int)m_colourCoordinate.y;
				for (int i = 0; i < ColourPalette.Length; i++)
				{
					if (num != i && ExtraCustomisation.Instance.HighlightedUIObject == ColourPalette[i].gameObject)
					{
						if ((bool)FEMManager.Instance)
						{
							ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
						}
						m_colourCoordinate.x = i / 4;
						m_colourCoordinate.y = i % 4;
						UpdateColourSelection();
						break;
					}
				}
			}
			else
			{
				for (int j = 0; j < ColourOption.Length; j++)
				{
					if (m_currentColourOption != j && ExtraCustomisation.Instance.HighlightedUIObject == ColourOption[j].gameObject)
					{
						if ((bool)FEMManager.Instance)
						{
							ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
						}
						ColourOption[m_currentColourOption].SetFlashing(flash: false);
						m_currentColourOption = j;
						ColourOption[m_currentColourOption].SetFlashing(flash: true);
						break;
					}
				}
			}
			if (QuitMenu.Instance.InProgress())
			{
				return;
			}
			bool flag = false;
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				if (ColourPopup.activeSelf)
				{
					flag = true;
				}
				else
				{
					for (int k = 0; k < ColourOption.Length; k++)
					{
						if (ExtraCustomisation.Instance.HighlightedUIObject == ColourOption[k].gameObject)
						{
							flag = true;
							break;
						}
					}
				}
			}
			if (flag)
			{
				ColourPopup.SetActive(!ColourPopup.activeSelf);
				base.ColourMenuActive = ColourPopup.activeSelf;
				ExtraCustomisation.Instance.ColoursEnabled = ColourPopup.activeSelf;
				if ((bool)FEMManager.Instance)
				{
					ExtraCustomisation.Instance.PlayClip((!ColourPopup.activeSelf) ? FEMManager.Instance.MenuClosed : FEMManager.Instance.OptionSelect);
				}
				int num2 = ProfileManager.Instance.GetPlayerData(0).m_colourIndex[m_currentColourOption];
				m_colourCoordinate.x = num2 / 4;
				m_colourCoordinate.y = num2 % 4;
				ColourSelection.transform.position = ColourPalette[num2].transform.position;
			}
		}
		else if (ColourPopup.activeSelf && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
		{
			if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			m_colourCoordinate.x -= 1f;
			if (m_colourCoordinate.x < 0f)
			{
				m_colourCoordinate.x = 0f;
			}
			UpdateColourSelection();
		}
		else if (ColourPopup.activeSelf && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
		{
			if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			m_colourCoordinate.x += 1f;
			if (m_colourCoordinate.x > 8f)
			{
				m_colourCoordinate.x = 8f;
			}
			UpdateColourSelection();
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
		{
			if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			if (ColourPopup.activeSelf)
			{
				m_colourCoordinate.y += 1f;
				if (m_colourCoordinate.y > 3f)
				{
					m_colourCoordinate.y = 3f;
				}
				UpdateColourSelection();
				return;
			}
			ColourOption[m_currentColourOption].SetFlashing(flash: false);
			m_currentColourOption++;
			if (m_currentColourOption > ColourOption.Length - 1)
			{
				m_currentColourOption = ColourOption.Length - 1;
			}
			ColourOption[m_currentColourOption].SetFlashing(flash: true);
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
		{
			if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionHighlight);
			}
			if (ColourPopup.activeSelf)
			{
				m_colourCoordinate.y -= 1f;
				if (m_colourCoordinate.y < 0f)
				{
					m_colourCoordinate.y = 0f;
				}
				UpdateColourSelection();
				return;
			}
			ColourOption[m_currentColourOption].SetFlashing(flash: false);
			m_currentColourOption--;
			if (m_currentColourOption < 0)
			{
				m_currentColourOption = 0;
			}
			ColourOption[m_currentColourOption].SetFlashing(flash: true);
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			ColourPopup.SetActive(!ColourPopup.activeSelf);
			base.ColourMenuActive = ColourPopup.activeSelf;
			if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip((!ColourPopup.activeSelf) ? FEMManager.Instance.MenuClosed : FEMManager.Instance.OptionSelect);
			}
			int num3 = ProfileManager.Instance.GetPlayerData(0).m_colourIndex[m_currentColourOption];
			m_colourCoordinate.x = num3 / 4;
			m_colourCoordinate.y = num3 % 4;
			ColourSelection.transform.position = ColourPalette[num3].transform.position;
		}
	}

	private void UpdateColourSelection()
	{
		int num = 4 * (int)m_colourCoordinate.x + (int)m_colourCoordinate.y;
		ProfileManager.PlayerData data = ProfileManager.Instance.GetPlayerData(0);
		data.m_colourIndex[m_currentColourOption] = num;
		ProfileManager.Instance.SetPlayerData(0, ref data);
		ProfileManager.Instance.UpdateColours(0, m_currentColourOption);
		ColourSelection.transform.position = ColourPalette[num].transform.position;
		ExtraCustomisation.Instance.UpdateColoursOnKart();
		ColourOption[m_currentColourOption].SetColour(ProfileManager.Instance.GetPlayerColourByIndex(num));
	}
}
public class ShopQuit : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Graphic[] GraphicSet;

	[SerializeField]
	private float InActiveAlpha;

	[SerializeField]
	private float ActiveAlpha;

	private float m_currentAlpha;

	private float m_targetAlpha;

	private void Update()
	{
		if (ExtraCustomisation.Instance.HitQuit)
		{
			m_targetAlpha = ActiveAlpha;
		}
		else
		{
			m_targetAlpha = InActiveAlpha;
		}
		m_currentAlpha = Mathf.Lerp(m_currentAlpha, m_targetAlpha, 6f * GameTime.Instance.DeltaTime());
		for (int i = 0; i < GraphicSet.Length; i++)
		{
			GraphicSet[i].color = new UnityEngine.Color(1f, 1f, 1f, m_currentAlpha);
		}
	}
}
public class ShopTile : UnityEngine.MonoBehaviour
{
	public Text PriceText;

	public Text NameText;

	public UnityEngine.UI.Image ImageObject;

	public string InternalName;

	private const float NotSelectedScale = 1f;

	private const float SelectedScale = 1.15f;

	public void SetHighlight(bool highlight)
	{
		base.transform.localScale = ((!highlight) ? new Vector3(1f, 1f, 1f) : new Vector3(1.15f, 1.15f, 1.15f));
	}
}
public class ShoppingList : UnityEngine.MonoBehaviour
{
	[SerializeField]
	public ConfirmDialog DialogObject;

	private List<string> m_shoppingItems = new List<string>();

	private float m_currentTotal;

	private float m_totalAfterPurchase;

	private MenuCustomisation.CurrentCustomisation m_currentCust = MenuCustomisation.CurrentCustomisation.Max;

	public void AddShoppingItem(string ID)
	{
		m_shoppingItems.Add(ID);
		UpdateShoppingList();
	}

	public void RemoveShoppingItem(string ID)
	{
		m_shoppingItems.Remove(ID);
		UpdateShoppingList();
	}

	public bool ItemExists(string ID)
	{
		for (int i = 0; i < m_shoppingItems.Count; i++)
		{
			if (m_shoppingItems[i] == ID)
			{
				return true;
			}
		}
		return false;
	}

	public void BeginPurchaseCurrency()
	{
		DialogObject.EnableDialog(enable: true, ConfirmDialog.DialogType.PurchaseCurrency);
	}

	public void PurchaseCurrency()
	{
	}

	public bool BeginCheckout(MenuCustomisation.CurrentCustomisation currentCust)
	{
		m_currentCust = currentCust;
		m_totalAfterPurchase = GameSystem.Instance.GetMarket().GetCurrency() - m_currentTotal;
		if (m_totalAfterPurchase < 0f)
		{
			return false;
		}
		DialogObject.EnableDialog(enable: true, ConfirmDialog.DialogType.Checkout);
		return true;
	}

	public void Checkout()
	{
		for (int i = 0; i < m_shoppingItems.Count; i++)
		{
			GameSystem.Instance.GetMarket().PurchaseItem(m_shoppingItems[i], this, CheckoutSuccessful, CheckoutFailed);
		}
	}

	public void CheckoutSuccessful()
	{
		DialogObject.EnableDialog(enable: true, ConfirmDialog.DialogType.CheckoutSuccessful);
		ref Vector2 reference = ref ExtraCustomisation.Instance.MenuData[1].m_storedItem[(int)m_currentCust];
		reference = Vector2.zero;
		ExtraCustomisation.Instance.MenuData[1].m_storedLevel[(int)m_currentCust] = 0;
		ExtraCustomisation.Instance.MenuObjects[1].ForceUpdate = true;
	}

	public void CheckoutFailed()
	{
		DialogObject.EnableDialog(enable: true, ConfirmDialog.DialogType.CheckoutFailed);
	}

	public void PurchaseSuccessful()
	{
	}

	public void PurchaseFailed()
	{
	}

	public void ClearShoppingItems()
	{
		m_shoppingItems.Clear();
		UpdateShoppingList();
	}

	public List<string> GetShoppingList()
	{
		return m_shoppingItems;
	}

	private void Start()
	{
		DialogObject.gameObject.SetActive(value: false);
		ClearShoppingItems();
	}

	private void Update()
	{
	}

	private void UpdateShoppingList()
	{
		m_currentTotal = 0f;
		for (int i = 0; i < m_shoppingItems.Count; i++)
		{
			if (m_shoppingItems.Count > 0)
			{
				MarketCatalogue.CatalogueData data = default(MarketCatalogue.CatalogueData);
				if (GameSystem.Instance.GetMarket().GetCatalogueDataItemByID(m_shoppingItems[i], ref data))
				{
					m_currentTotal += data.cost;
				}
			}
		}
	}
}
public class StoreCustomisation : MenuCustomisation
{
	[SerializeField]
	private AudioClip NoCheckoutClip;

	private void Start()
	{
		InitMenus();
	}

	protected override void InitMenus()
	{
		base.InitMenus();
	}

	private void Update()
	{
		if (ExtraCustomisation.Instance.CustomisationActive() && (base.ForceUpdate || !ExtraCustomisation.Instance.ShoppingList.DialogObject.IsActive()))
		{
			if (base.ForceUpdate)
			{
				m_menuInFocus = true;
			}
			UpdateMenus();
			if (base.ForceUpdate)
			{
				base.ForceUpdate = false;
			}
		}
	}

	protected override void EnableMenuOption(CurrentCustomisation customisation)
	{
	}

	protected override List<MarketCatalogue.CatalogueData> GetCatalogueData()
	{
		List<MarketCatalogue.CatalogueData> list = null;
		List<MarketCatalogue.CatalogueData> list2 = new List<MarketCatalogue.CatalogueData>();
		switch (m_currentCustomisation)
		{
		default:
			UnityEngine.Debug.LogError("Unknown customisation type");
			break;
		case CurrentCustomisation.HelmetProp:
			list = GameSystem.Instance.GetMarket().GetCatalogueDataByType(MarketCatalogue.ItemType.HelmetProp);
			break;
		case CurrentCustomisation.VisorProp:
			list = GameSystem.Instance.GetMarket().GetCatalogueDataByType(MarketCatalogue.ItemType.VisorProp);
			break;
		case CurrentCustomisation.DashboardProp:
			list = GameSystem.Instance.GetMarket().GetCatalogueDataByType(MarketCatalogue.ItemType.DashboardProp);
			break;
		case CurrentCustomisation.DashboardStyle:
			list = GameSystem.Instance.GetMarket().GetCatalogueDataByType(MarketCatalogue.ItemType.DashboardStyle);
			break;
		case CurrentCustomisation.Horn:
			list = GameSystem.Instance.GetMarket().GetCatalogueDataByType(MarketCatalogue.ItemType.HornSFX);
			break;
		}
		if (list != null)
		{
			for (int i = 0; i < list.Count; i++)
			{
				if (!GameSystem.Instance.GetMarket().IsItemOwnedByUser(list[i].itemID))
				{
					list2.Add(list[i]);
				}
			}
			if (list2.Count > 0)
			{
				MarketCatalogue.CatalogueData item = default(MarketCatalogue.CatalogueData);
				item.available = true;
				item.filename = string.Empty;
				item.cost = 0f;
				list2.Insert(0, item);
			}
		}
		return list2;
	}

	protected override void OnSelectedItem()
	{
		ExtraCustomisation.Instance.ShoppingList.ClearShoppingItems();
		AddToShoppingList();
	}

	protected override void CheckForItemSelection()
	{
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			if (!ExtraCustomisation.Instance.ShoppingList.BeginCheckout(m_currentCustomisation))
			{
				ExtraCustomisation.Instance.PlayClip(NoCheckoutClip);
			}
			else if ((bool)FEMManager.Instance)
			{
				ExtraCustomisation.Instance.PlayClip(FEMManager.Instance.OptionSelect);
			}
		}
	}

	public override void EndMenu()
	{
	}
}
public class EnvList : UnityEngine.MonoBehaviour
{
	public struct EnvData
	{
		public string EnvIndex;

		public string EnvName;
	}

	private List<EnvData> m_environmentList = new List<EnvData>();

	public static void CreateEnvironmentsForEditor(ref List<TrackList.TrackData> tracks, ref List<EnvData> enviroList)
	{
		ParseEnvs(ref enviroList);
		for (int i = 0; i < tracks.Count; i++)
		{
			bool flag = false;
			for (int j = 0; j < enviroList.Count; j++)
			{
				if (enviroList[j].EnvIndex == tracks[i].Env)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				EnvData item = default(EnvData);
				item.EnvIndex = tracks[i].Env;
				enviroList.Add(item);
			}
		}
	}

	public static void CreateEnvironmentList(ref List<EnvData> enviroList)
	{
		FileStream fileStream = new FileStream("Assets\\Game\\Resources\\Environments.xml", FileMode.Create);
		XmlTextWriter xmlTextWriter = new XmlTextWriter(fileStream, Encoding.UTF8);
		xmlTextWriter.Formatting = System.Xml.Formatting.Indented;
		xmlTextWriter.Indentation = 4;
		xmlTextWriter.WriteStartDocument();
		xmlTextWriter.WriteStartElement("EnvList");
		foreach (EnvData enviro in enviroList)
		{
			xmlTextWriter.WriteStartElement("Env");
			xmlTextWriter.WriteAttributeString("Index", enviro.EnvIndex);
			xmlTextWriter.WriteAttributeString("Name", enviro.EnvName);
			xmlTextWriter.WriteEndElement();
		}
		xmlTextWriter.WriteEndElement();
		xmlTextWriter.Flush();
		fileStream.Close();
	}

	public void ParseEnvironments()
	{
		ParseEnvs(ref m_environmentList);
	}

	public static void ParseEnvs(ref List<EnvData> enviroList)
	{
		string path = "Environments";
		TextAsset textAsset = (TextAsset)Resources.Load(path);
		if (!(textAsset == null))
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.LoadXml(textAsset.text);
			XmlNodeList xmlNodeList = xmlDocument.SelectNodes("EnvList");
			xmlNodeList = xmlNodeList[0].ChildNodes;
			for (int i = 0; i < xmlNodeList.Count; i++)
			{
				EnvData item = default(EnvData);
				item.EnvIndex = xmlNodeList[i].Attributes["Index"].Value;
				item.EnvName = xmlNodeList[i].Attributes["Name"].Value;
				enviroList.Add(item);
			}
		}
	}

	public EnvData GetEnvByName(string name)
	{
		for (int i = 0; i < m_environmentList.Count; i++)
		{
			if (m_environmentList[i].EnvName == name)
			{
				return m_environmentList[i];
			}
		}
		return m_environmentList[0];
	}

	public EnvData GetEnvByIndex(int index)
	{
		return m_environmentList[index];
	}

	public int GetTotalEnvironments()
	{
		return m_environmentList.Count;
	}
}
public class FEMConfigControls : UnityEngine.MonoBehaviour
{
	private int m_inputIndex;

	private bool m_inputReceived;

	public string GetControlText()
	{
		if (m_inputIndex == -1)
		{
			return "----";
		}
		return GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(InputRemapper.Instance.GetInputText((InputRemapper.InputConfigType)m_inputIndex), convertToUpperCase: true);
	}

	private void OnEnable()
	{
		m_inputIndex = -1;
		m_inputReceived = true;
	}

	private void Awake()
	{
		base.enabled = false;
		m_inputReceived = true;
	}

	private void Start()
	{
	}

	private void Update()
	{
		InputRemapper.JoypadInput joypadInput = InputRemapper.JoypadInput.None;
		if (m_inputReceived)
		{
			if (!InputRemapper.Instance.GetAnyInput())
			{
				m_inputReceived = false;
				m_inputIndex++;
				if (m_inputIndex >= 11)
				{
					m_inputIndex = -1;
					m_inputReceived = true;
					base.enabled = false;
				}
			}
		}
		else if (InputRemapper.Instance.WaitForInput((InputRemapper.InputConfigType)m_inputIndex))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
			m_inputReceived = true;
		}
	}
}
public class FEMIAPOption : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject BuyText;

	[SerializeField]
	private GameObject[] TVObjects;

	[SerializeField]
	private Vector2 MinMaxSize;

	[SerializeField]
	private ConfirmDialog Dialog;

	public Collider IAPCollider;

	private bool m_objectSelected;

	private float m_currentScale = 1f;

	private float m_targetScale = 1f;

	public bool DialogEnabled => Dialog.gameObject.activeSelf;

	public ConfirmDialog GetDialog()
	{
		return Dialog;
	}

	public void ObjectSelected(bool select)
	{
		m_objectSelected = select;
		m_targetScale = ((!m_objectSelected) ? MinMaxSize.x : MinMaxSize.y);
	}

	public bool IsObjectSelected()
	{
		return m_objectSelected;
	}

	public void DisableOption()
	{
		for (int i = 0; i < TVObjects.Length; i++)
		{
			TVObjects[i].gameObject.SetActive(value: true);
		}
		base.gameObject.SetActive(value: false);
	}

	public void EnableOption()
	{
		for (int i = 0; i < TVObjects.Length; i++)
		{
			TVObjects[i].gameObject.SetActive(value: false);
		}
		base.gameObject.SetActive(value: true);
	}

	private void Start()
	{
		m_targetScale = MinMaxSize.x;
		m_currentScale = m_targetScale;
	}

	private void Update()
	{
		if (m_objectSelected && NetworkLogin.Instance.AllowedToSaveToCloud() && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			ObjectSelected(select: false);
			Dialog.gameObject.SetActive(value: true);
			Dialog.EnableDialog(enable: true, ConfirmDialog.DialogType.PurchaseGame);
		}
		m_currentScale = Mathf.Lerp(m_currentScale, m_targetScale, 6f * GameTime.Instance.DeltaTime());
		BuyText.transform.localScale = new Vector3(m_currentScale, m_currentScale, m_currentScale);
	}
}
public class FEMLeaderboard : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Text Title;

	[SerializeField]
	private Text TitleOnlinePoints;

	[SerializeField]
	private RawImage[] BackgroundTexture;

	[SerializeField]
	private Text[] PositionEntry;

	[SerializeField]
	private Text[] NameEntry;

	[SerializeField]
	private Text[] TimeEntry;

	[SerializeField]
	private Text[] PositionNonTop10Entry;

	[SerializeField]
	private Text[] NameEntryNonTop10Entry;

	[SerializeField]
	private Text[] TimeEntryNonTop10Entry;

	[SerializeField]
	private Text[] PositionEntryOnlinePoints;

	[SerializeField]
	private Text[] NameEntryOnlinePoints;

	[SerializeField]
	private Text[] TimeEntryOnlinePoints;

	[SerializeField]
	private Text[] PositionNonTop10EntryOnlinePoints;

	[SerializeField]
	private Text[] NameEntryNonTop10EntryOnlinePoints;

	[SerializeField]
	private Text[] TimeEntryNonTop10EntryOnlinePoints;

	[SerializeField]
	private float TimeBeforeUpdate = 0.2f;

	[SerializeField]
	private float TimeBeforeLeaderboardUpdate = 5f;

	[SerializeField]
	private GameObject LeaderboardEnvRoot;

	[SerializeField]
	private GameObject LeaderboardRoot;

	[SerializeField]
	private GameObject OnlineboardRoot;

	[SerializeField]
	private Text[] EnvText;

	[SerializeField]
	private Text LeftText;

	[SerializeField]
	private Text RightText;

	[SerializeField]
	private GameObject LeaderboardTop10Root;

	[SerializeField]
	private GameObject LeaderboardOutOfTop10Root;

	[SerializeField]
	private GameObject OnlinePointsTop10Root;

	[SerializeField]
	private GameObject OnlinePointsOutOfTop10Root;

	[SerializeField]
	private Text[] FilterLeft;

	[SerializeField]
	private Text[] FilterRight;

	[SerializeField]
	private Vector2 MinMaxArrowSize = new Vector2(0.66f, 1f);

	[SerializeField]
	private Vector2 MinMaxFilterSize = new Vector2(0.66f, 1f);

	private NetworkLeaderboards.LeaderboardType m_currentLeaderboardType;

	private int m_currentTrackIndex;

	private int m_currentEnvIndex;

	private int m_currentEnvMenuIndex;

	private bool m_pickingEnv = true;

	private bool m_forceShowEnvText = true;

	private bool m_setLeaderboardAroundPlayer;

	private bool m_showingLeaderboardAroundPlayer;

	private bool m_setLeaderboardAroundFriends;

	private bool m_showingLeaderboardAroundFriends;

	private bool m_waitForNoInput;

	private const float MenuSelectionPulseSpeed = 8f;

	private const float MenuSelectionPulseTime = 1.5f;

	private float m_menuSelectionPulseAngle;

	private float m_menuSelectionScaleTimer;

	private int m_numPulsesDone;

	private int m_numPulsesRequired = 1;

	private const float HighlightedTextScale = 1.5f;

	private const float ExtraPulseScale = 0.25f;

	private float m_currentLeftTextScale = 0.66f;

	private float m_currentRightTextScale = 0.66f;

	private float m_targetLeftTextScale = 0.66f;

	private float m_targetRightTextScale = 0.66f;

	private Vector2 m_filterLeftScale = new Vector2(1f, 2f);

	private Vector2 m_filterRightScale = new Vector2(1f, 2f);

	private List<TrackList.TrackData> m_tracks = new List<TrackList.TrackData>();

	private float m_timeOnLeaderboardPane;

	public void SetType(NetworkLeaderboards.LeaderboardType type)
	{
		m_currentLeaderboardType = type;
	}

	public NetworkLeaderboards.LeaderboardType GetLeaderboardType()
	{
		return m_currentLeaderboardType;
	}

	private void OnEnable()
	{
		if (GameSystem.Instance != null)
		{
			m_pickingEnv = true;
			m_forceShowEnvText = true;
			ClearLeaderboard();
		}
		m_setLeaderboardAroundPlayer = false;
		m_showingLeaderboardAroundPlayer = false;
		m_setLeaderboardAroundFriends = false;
		m_showingLeaderboardAroundFriends = false;
		m_waitForNoInput = true;
	}

	private void OnDisable()
	{
	}

	public void ClearLeaderboard()
	{
		m_timeOnLeaderboardPane = 0f;
		m_tracks.Clear();
		if ((bool)Title)
		{
			Title.text = string.Empty;
		}
		for (int i = 0; i < NameEntry.Length; i++)
		{
			NameEntry[i].text = string.Empty;
			TimeEntry[i].text = string.Empty;
		}
		m_currentTrackIndex = 0;
	}

	private void PopulateLeaderboard()
	{
		if (m_tracks.Count != 0)
		{
			Title.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(m_tracks[m_currentTrackIndex].Name, convertToUpperCase: true);
			for (int i = 0; i < NameEntry.Length; i++)
			{
				NameEntry[i].text = string.Empty;
				TimeEntry[i].text = string.Empty;
				PositionEntry[i].text = string.Empty;
				PositionNonTop10Entry[i].text = string.Empty;
				NameEntryNonTop10Entry[i].text = string.Empty;
				TimeEntryNonTop10Entry[i].text = string.Empty;
				PositionEntryOnlinePoints[i].text = string.Empty;
				NameEntryOnlinePoints[i].text = string.Empty;
				TimeEntryOnlinePoints[i].text = string.Empty;
				PositionNonTop10EntryOnlinePoints[i].text = string.Empty;
				NameEntryNonTop10EntryOnlinePoints[i].text = string.Empty;
				TimeEntryNonTop10EntryOnlinePoints[i].text = string.Empty;
			}
		}
	}

	public void SetupLeaderboardWithCurrentEnv()
	{
		ClearLeaderboard();
		GameSystem.Instance.GetTrackListing().GetTracksByEnv(ref m_tracks, FEMManager.Instance.GetEnvList().GetEnvByIndex(m_currentEnvIndex).EnvIndex);
		m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + TimeBeforeUpdate;
		PopulateLeaderboard();
		UpdateBackground();
	}

	private void Start()
	{
		m_currentLeftTextScale = MinMaxArrowSize.x;
		m_currentRightTextScale = MinMaxArrowSize.x;
		m_targetLeftTextScale = MinMaxArrowSize.x;
		m_targetRightTextScale = MinMaxArrowSize.x;
		m_filterLeftScale.x = MinMaxFilterSize.x;
		m_filterLeftScale.y = MinMaxFilterSize.y;
		m_filterRightScale.x = MinMaxFilterSize.x;
		m_filterRightScale.y = MinMaxFilterSize.y;
	}

	private void Update()
	{
		if (NetworkLogin.Instance.JoinedRoom())
		{
			return;
		}
		switch (m_currentLeaderboardType)
		{
		case NetworkLeaderboards.LeaderboardType.QuickPlay:
			if (LeaderboardEnvRoot.activeSelf != m_pickingEnv)
			{
				LeaderboardEnvRoot.SetActive(m_pickingEnv);
			}
			if (LeaderboardRoot.activeSelf == m_pickingEnv)
			{
				LeaderboardRoot.SetActive(!m_pickingEnv);
			}
			if (OnlineboardRoot.activeSelf)
			{
				OnlineboardRoot.SetActive(value: false);
			}
			if (m_pickingEnv)
			{
				UpdateEnvironment();
			}
			else
			{
				UpdateTrack();
			}
			break;
		case NetworkLeaderboards.LeaderboardType.OnlinePoints:
			if (!OnlineboardRoot.activeSelf)
			{
				OnlineboardRoot.SetActive(value: true);
			}
			if (LeaderboardEnvRoot.activeSelf)
			{
				LeaderboardEnvRoot.SetActive(value: false);
			}
			if (LeaderboardRoot.activeSelf)
			{
				LeaderboardRoot.SetActive(value: false);
			}
			UpdateOnlinePoints();
			break;
		}
		UpdateFilters();
	}

	private void UpdateFilters()
	{
		for (int i = 0; i < FilterRight.Length; i++)
		{
			if (m_showingLeaderboardAroundPlayer)
			{
				FilterRight[i].text = "(" + GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Global", convertToUpperCase: true) + ")";
			}
			else
			{
				FilterRight[i].text = "(" + GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Top10", convertToUpperCase: true) + ")";
			}
		}
		GameObject lastSelectedObject = FEMManager.Instance.TabletObj.GetLastSelectedObject();
		if (lastSelectedObject == FilterLeft[0].gameObject || lastSelectedObject == FilterLeft[1].gameObject)
		{
			m_filterRightScale.y = MinMaxFilterSize.x;
			m_filterLeftScale.y = MinMaxFilterSize.y;
		}
		else if (lastSelectedObject == FilterRight[0].gameObject || lastSelectedObject == FilterRight[1].gameObject)
		{
			m_filterLeftScale.y = MinMaxFilterSize.x;
			m_filterRightScale.y = MinMaxFilterSize.y;
		}
		else
		{
			m_filterLeftScale.y = MinMaxFilterSize.x;
			m_filterRightScale.y = MinMaxFilterSize.x;
		}
		m_filterLeftScale.x = Mathf.Lerp(m_filterLeftScale.x, m_filterLeftScale.y, 6f * GameTime.Instance.DeltaTime());
		m_filterRightScale.x = Mathf.Lerp(m_filterRightScale.x, m_filterRightScale.y, 6f * GameTime.Instance.DeltaTime());
		FilterLeft[0].transform.localScale = new Vector3(m_filterLeftScale.x, m_filterLeftScale.x, m_filterLeftScale.x);
		FilterLeft[1].transform.localScale = new Vector3(m_filterLeftScale.x, m_filterLeftScale.x, m_filterLeftScale.x);
		FilterRight[0].transform.localScale = new Vector3(m_filterRightScale.x, m_filterRightScale.x, m_filterRightScale.x);
		FilterRight[1].transform.localScale = new Vector3(m_filterRightScale.x, m_filterRightScale.x, m_filterRightScale.x);
	}

	private void UpdateEnvironment()
	{
		bool flag = false;
		if (m_waitForNoInput && !InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.Button_A))
		{
			m_waitForNoInput = false;
		}
		UpdateHighlightOption();
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			for (int i = 0; i < EnvText.Length; i++)
			{
				if (m_currentEnvIndex != i && FEMManager.Instance.TabletObj.GetLastSelectedObject() == EnvText[i].gameObject)
				{
					FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
					flag = true;
					m_currentEnvIndex = i;
					m_currentEnvMenuIndex = i;
					ResetMenuIndex(m_currentEnvMenuIndex);
					break;
				}
			}
		}
		else if (!m_waitForNoInput && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
			flag = true;
			if (m_currentEnvIndex > 0)
			{
				m_currentEnvIndex--;
				if (GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(FEMManager.Instance.GetEnvList().GetEnvByIndex(m_currentEnvIndex).EnvIndex) <= 0)
				{
					m_currentEnvIndex--;
				}
			}
			else
			{
				m_currentEnvIndex = 0;
			}
			m_currentEnvMenuIndex--;
			if (m_currentEnvMenuIndex < 0)
			{
				m_currentEnvMenuIndex = 0;
			}
			else
			{
				ResetMenuIndex(m_currentEnvMenuIndex);
			}
		}
		else if (!m_waitForNoInput && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
			flag = true;
			int num = 0;
			for (int j = 0; j < FEMManager.Instance.GetEnvList().GetTotalEnvironments(); j++)
			{
				if (GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(FEMManager.Instance.GetEnvList().GetEnvByIndex(j).EnvIndex) > 0)
				{
					num++;
				}
			}
			if (m_currentEnvIndex < FEMManager.Instance.GetEnvList().GetTotalEnvironments() - 1)
			{
				m_currentEnvIndex++;
				if (GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(FEMManager.Instance.GetEnvList().GetEnvByIndex(m_currentEnvIndex).EnvIndex) <= 0)
				{
					m_currentEnvIndex++;
				}
			}
			m_currentEnvMenuIndex++;
			if (m_currentEnvMenuIndex > num - 1)
			{
				m_currentEnvMenuIndex = num - 1;
			}
			else
			{
				ResetMenuIndex(m_currentEnvMenuIndex);
			}
		}
		if (!m_waitForNoInput && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
			{
				bool flag2 = false;
				for (int k = 0; k < EnvText.Length; k++)
				{
					if (FEMManager.Instance.TabletObj.GetLastSelectedObject() == EnvText[k].gameObject)
					{
						flag2 = true;
						break;
					}
				}
				if (!flag2)
				{
					return;
				}
			}
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
			m_pickingEnv = false;
			SetupLeaderboardWithCurrentEnv();
		}
		if (LeaderboardEnvRoot.activeSelf && (bool)FEMManager.Instance.GetEnvList())
		{
			int num2 = 0;
			for (int l = 0; l < FEMManager.Instance.GetEnvList().GetTotalEnvironments(); l++)
			{
				if (GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(FEMManager.Instance.GetEnvList().GetEnvByIndex(l).EnvIndex) > 0)
				{
					if (m_currentEnvMenuIndex == num2)
					{
						float num3 = Mathf.Sin(m_menuSelectionPulseAngle) * 0.25f;
						EnvText[num2].transform.localScale = new Vector3(1.5f + num3, 1.5f + num3, 1.5f + num3);
						EnvText[num2].color = new UnityEngine.Color(49f / 51f, 49f / 51f, 49f / 51f);
					}
					else
					{
						EnvText[num2].transform.localScale = new Vector3(1.5f, 1.5f, 1.5f);
						EnvText[num2].color = new UnityEngine.Color(0.7058824f, 0.7058824f, 0.7058824f);
					}
					EnvText[num2].text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(FEMManager.Instance.GetEnvList().GetEnvByIndex(l).EnvName, convertToUpperCase: true);
					num2++;
				}
			}
		}
		if (flag || m_forceShowEnvText)
		{
			m_forceShowEnvText = false;
			if ((bool)FEMManager.Instance.GetEnvList())
			{
				Title.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(FEMManager.Instance.GetEnvList().GetEnvByIndex(m_currentEnvIndex).EnvName, convertToUpperCase: true);
			}
		}
	}

	private void ResetMenuIndex(int index)
	{
		m_menuSelectionScaleTimer = 0f;
		m_numPulsesDone = 0;
		m_numPulsesRequired = 1;
		m_menuSelectionPulseAngle = 0f;
	}

	private void UpdateHighlightOption()
	{
		if (m_menuSelectionScaleTimer > 0f)
		{
			m_menuSelectionScaleTimer -= GameTime.Instance.DeltaTime();
			if (m_menuSelectionScaleTimer <= 0f)
			{
				m_menuSelectionScaleTimer = 0f;
			}
			return;
		}
		m_menuSelectionPulseAngle += GameTime.Instance.DeltaTime() * 8f;
		if (m_menuSelectionPulseAngle >= (float)Math.PI)
		{
			m_menuSelectionPulseAngle = 0f;
			m_numPulsesDone++;
			if (m_numPulsesDone >= m_numPulsesRequired)
			{
				m_numPulsesDone = 0;
				m_numPulsesRequired = 2;
				m_menuSelectionScaleTimer = 1.5f;
			}
		}
	}

	private void UpdateTrack()
	{
		GameObject lastSelectedObject = FEMManager.Instance.TabletObj.GetLastSelectedObject();
		if (lastSelectedObject == LeftText.gameObject)
		{
			m_targetRightTextScale = MinMaxArrowSize.x;
			m_targetLeftTextScale = MinMaxArrowSize.y;
		}
		else if (lastSelectedObject == RightText.gameObject)
		{
			m_targetLeftTextScale = MinMaxArrowSize.x;
			m_targetRightTextScale = MinMaxArrowSize.y;
		}
		else
		{
			m_targetLeftTextScale = MinMaxArrowSize.x;
			m_targetRightTextScale = MinMaxArrowSize.x;
		}
		m_currentLeftTextScale = Mathf.Lerp(m_currentLeftTextScale, m_targetLeftTextScale, 6f * GameTime.Instance.DeltaTime());
		m_currentRightTextScale = Mathf.Lerp(m_currentRightTextScale, m_targetRightTextScale, 6f * GameTime.Instance.DeltaTime());
		LeftText.transform.localScale = new Vector3(m_currentLeftTextScale, m_currentLeftTextScale, m_currentLeftTextScale);
		RightText.transform.localScale = new Vector3(m_currentRightTextScale, m_currentRightTextScale, m_currentRightTextScale);
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			m_waitForNoInput = true;
			if (lastSelectedObject == LeftText.gameObject)
			{
				FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
				m_currentTrackIndex--;
				if (m_currentTrackIndex < 0)
				{
					m_currentTrackIndex = m_tracks.Count - 1;
				}
				UpdateBackground();
				m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + TimeBeforeUpdate;
				PopulateLeaderboard();
			}
			else if (lastSelectedObject == RightText.gameObject)
			{
				FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
				m_currentTrackIndex++;
				if (m_currentTrackIndex > m_tracks.Count - 1)
				{
					m_currentTrackIndex = 0;
				}
				UpdateBackground();
				m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + TimeBeforeUpdate;
				PopulateLeaderboard();
			}
			else if (lastSelectedObject == FilterLeft[0].gameObject)
			{
				FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
				m_setLeaderboardAroundFriends = !m_setLeaderboardAroundFriends;
				if (m_timeOnLeaderboardPane - GameTime.Instance.CurrentTime() > 1f)
				{
					m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + 1f;
				}
			}
			else if (lastSelectedObject == FilterRight[0].gameObject)
			{
				FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
				m_setLeaderboardAroundPlayer = !m_setLeaderboardAroundPlayer;
				if (m_timeOnLeaderboardPane - GameTime.Instance.CurrentTime() > 1f)
				{
					m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + 1f;
				}
			}
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.MenuBack);
			m_pickingEnv = true;
			m_forceShowEnvText = true;
			ClearLeaderboard();
			return;
		}
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
			{
				FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
				m_currentTrackIndex--;
				if (m_currentTrackIndex < 0)
				{
					m_currentTrackIndex = m_tracks.Count - 1;
				}
				UpdateBackground();
				m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + TimeBeforeUpdate;
				PopulateLeaderboard();
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
			{
				FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
				m_currentTrackIndex++;
				if (m_currentTrackIndex > m_tracks.Count - 1)
				{
					m_currentTrackIndex = 0;
				}
				UpdateBackground();
				m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + TimeBeforeUpdate;
				PopulateLeaderboard();
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_Y))
			{
				FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
				m_setLeaderboardAroundPlayer = !m_setLeaderboardAroundPlayer;
				if (m_timeOnLeaderboardPane - GameTime.Instance.CurrentTime() > 1f)
				{
					m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + 1f;
				}
			}
		}
		if (GameTime.Instance.PrevTime() < m_timeOnLeaderboardPane && GameTime.Instance.CurrentTime() >= m_timeOnLeaderboardPane)
		{
			GetLeaderboardData();
		}
	}

	private void UpdateBackground()
	{
		Texture textureByName = GameSystem.Instance.GetThumbnailManager().GetTextureByName(m_tracks[m_currentTrackIndex].ThumbNailPath);
		if ((bool)textureByName)
		{
			for (int i = 0; i < BackgroundTexture.Length; i++)
			{
				BackgroundTexture[i].texture = textureByName;
			}
		}
	}

	private void UpdateOnlinePoints()
	{
		TitleOnlinePoints.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_OnlinePoints", convertToUpperCase: true);
		GameObject lastSelectedObject = FEMManager.Instance.TabletObj.GetLastSelectedObject();
		if (lastSelectedObject == FilterRight[1].gameObject && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
			m_setLeaderboardAroundPlayer = !m_setLeaderboardAroundPlayer;
			if (m_timeOnLeaderboardPane - GameTime.Instance.CurrentTime() > 1f)
			{
				m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + 1f;
			}
		}
		bool flag = false;
		if (m_showingLeaderboardAroundPlayer != m_setLeaderboardAroundPlayer)
		{
			flag = true;
			m_showingLeaderboardAroundPlayer = m_setLeaderboardAroundPlayer;
		}
		if (m_showingLeaderboardAroundFriends != m_setLeaderboardAroundFriends)
		{
			flag = true;
			m_showingLeaderboardAroundFriends = m_setLeaderboardAroundFriends;
		}
		if ((bool)NetworkLogin.Instance && GameTime.Instance.CurrentTime() > m_timeOnLeaderboardPane)
		{
			if (!flag && m_timeOnLeaderboardPane <= 0f)
			{
				OnLeaderboardInfo(NetworkLogin.Instance.GetNetworkLeaderboards().GetOnlinePointsLeaderboard());
			}
			m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + TimeBeforeLeaderboardUpdate;
			NetworkLogin.Instance.GetNetworkLeaderboards().GetOnlinePointsLeaderboard(OnLeaderboardInfo, m_showingLeaderboardAroundPlayer, m_showingLeaderboardAroundFriends);
		}
	}

	private void GetLeaderboardData()
	{
		bool flag = false;
		if (m_showingLeaderboardAroundPlayer != m_setLeaderboardAroundPlayer)
		{
			flag = true;
			m_showingLeaderboardAroundPlayer = m_setLeaderboardAroundPlayer;
		}
		if (m_showingLeaderboardAroundFriends != m_setLeaderboardAroundFriends)
		{
			flag = true;
			m_showingLeaderboardAroundFriends = m_setLeaderboardAroundFriends;
		}
		if (!(NetworkLogin.Instance == null))
		{
			NetworkLeaderboards.Leaderboard leaderboardByTrackName = NetworkLogin.Instance.GetNetworkLeaderboards().GetLeaderboardByTrackName(m_tracks[m_currentTrackIndex].Scene);
			if (!flag && leaderboardByTrackName != null && GameTime.Instance.CurrentTime() - leaderboardByTrackName.updateTime < TimeBeforeLeaderboardUpdate)
			{
				OnLeaderboardInfo(leaderboardByTrackName);
			}
			else
			{
				NetworkLogin.Instance.GetNetworkLeaderboards().GetLeaderboard(m_tracks[m_currentTrackIndex].Scene, OnLeaderboardInfo, m_showingLeaderboardAroundPlayer, m_showingLeaderboardAroundFriends);
			}
			m_timeOnLeaderboardPane = GameTime.Instance.CurrentTime() + TimeBeforeLeaderboardUpdate;
		}
	}

	private void OnLeaderboardInfo(NetworkLeaderboards.Leaderboard currentLeaderboard)
	{
		if ((bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Frontend)
		{
			return;
		}
		if (currentLeaderboard == null)
		{
			if (m_currentLeaderboardType == NetworkLeaderboards.LeaderboardType.QuickPlay)
			{
				LeaderboardTop10Root.SetActive(value: false);
				LeaderboardOutOfTop10Root.SetActive(value: true);
			}
			else
			{
				OnlinePointsTop10Root.SetActive(value: false);
				OnlinePointsOutOfTop10Root.SetActive(value: true);
			}
		}
		else
		{
			if (m_currentLeaderboardType == NetworkLeaderboards.LeaderboardType.QuickPlay && m_tracks.Count > 0 && m_tracks[m_currentTrackIndex].Scene != currentLeaderboard.trackName)
			{
				return;
			}
			bool flag = currentLeaderboard.entry.Length > 0 && currentLeaderboard.entry[0].position == 0;
			if (m_currentLeaderboardType == NetworkLeaderboards.LeaderboardType.QuickPlay)
			{
				LeaderboardTop10Root.SetActive(flag);
				LeaderboardOutOfTop10Root.SetActive(!flag);
				OnlinePointsTop10Root.SetActive(value: false);
				OnlinePointsOutOfTop10Root.SetActive(value: false);
			}
			else
			{
				OnlinePointsTop10Root.SetActive(flag);
				OnlinePointsOutOfTop10Root.SetActive(!flag);
				LeaderboardTop10Root.SetActive(value: false);
				LeaderboardOutOfTop10Root.SetActive(value: false);
			}
			if (m_currentLeaderboardType == NetworkLeaderboards.LeaderboardType.OnlinePoints)
			{
				for (int i = 0; i < currentLeaderboard.entry.Length; i++)
				{
					if (flag)
					{
						if (!NetworkLeaderboards.USE_LEADERBOARDS)
						{
							NameEntryOnlinePoints[i].text = string.Empty;
							TimeEntryOnlinePoints[i].text = string.Empty;
						}
						else
						{
							NameEntryOnlinePoints[i].text = currentLeaderboard.entry[i].displayName;
							TimeEntryOnlinePoints[i].text = currentLeaderboard.entry[i].time;
						}
						if (currentLeaderboard.entry[i].position.ToString() == ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true))
						{
							NameEntryOnlinePoints[i].color = new UnityEngine.Color(0f, 0.7921569f, 1f, 1f);
						}
						else
						{
							NameEntryOnlinePoints[i].color = new UnityEngine.Color(47f / 51f, 47f / 51f, 47f / 51f, 1f);
						}
						if (NetworkLeaderboards.USE_LEADERBOARDS && currentLeaderboard.entry[i].displayName != string.Empty)
						{
							PositionEntryOnlinePoints[i].text = currentLeaderboard.entry[i].position + 1 + ".";
						}
						else
						{
							PositionEntryOnlinePoints[i].text = string.Empty;
						}
						TimeEntryOnlinePoints[i].text = TimeEntryOnlinePoints[i].text.Replace("-", string.Empty);
					}
					else
					{
						if (!NetworkLeaderboards.USE_LEADERBOARDS)
						{
							NameEntryOnlinePoints[i].text = string.Empty;
							TimeEntryOnlinePoints[i].text = string.Empty;
						}
						else
						{
							NameEntryNonTop10EntryOnlinePoints[i].text = currentLeaderboard.entry[i].displayName;
							TimeEntryNonTop10EntryOnlinePoints[i].text = currentLeaderboard.entry[i].time;
						}
						if (currentLeaderboard.entry[i].position.ToString() == ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true))
						{
							NameEntryNonTop10EntryOnlinePoints[i].color = new UnityEngine.Color(0f, 0.7921569f, 1f, 1f);
						}
						else
						{
							NameEntryNonTop10EntryOnlinePoints[i].color = new UnityEngine.Color(47f / 51f, 47f / 51f, 47f / 51f, 1f);
						}
						if (NetworkLeaderboards.USE_LEADERBOARDS && currentLeaderboard.entry[i].displayName != string.Empty)
						{
							PositionNonTop10EntryOnlinePoints[i].text = currentLeaderboard.entry[i].position + 1 + ".";
						}
						else
						{
							PositionNonTop10EntryOnlinePoints[i].text = string.Empty;
						}
						TimeEntryNonTop10EntryOnlinePoints[i].text = TimeEntryNonTop10EntryOnlinePoints[i].text.Replace("-", string.Empty);
					}
				}
				return;
			}
			for (int j = 0; j < currentLeaderboard.entry.Length; j++)
			{
				if (flag)
				{
					if (!NetworkLeaderboards.USE_LEADERBOARDS)
					{
						NameEntryOnlinePoints[j].text = string.Empty;
						TimeEntryOnlinePoints[j].text = string.Empty;
					}
					else
					{
						NameEntry[j].text = currentLeaderboard.entry[j].displayName;
						TimeEntry[j].text = currentLeaderboard.entry[j].time;
					}
					if (currentLeaderboard.entry[j].position.ToString() == ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true))
					{
						NameEntry[j].color = new UnityEngine.Color(0f, 0.7921569f, 1f, 1f);
					}
					else
					{
						NameEntry[j].color = new UnityEngine.Color(47f / 51f, 47f / 51f, 47f / 51f, 1f);
					}
					if (NetworkLeaderboards.USE_LEADERBOARDS && currentLeaderboard.entry[j].displayName != string.Empty)
					{
						PositionEntry[j].text = currentLeaderboard.entry[j].position + 1 + ".";
					}
					else
					{
						PositionEntry[j].text = string.Empty;
					}
					TimeEntry[j].text = TimeEntry[j].text.Replace("-", string.Empty);
				}
				else
				{
					if (!NetworkLeaderboards.USE_LEADERBOARDS)
					{
						NameEntryOnlinePoints[j].text = string.Empty;
						TimeEntryOnlinePoints[j].text = string.Empty;
					}
					else
					{
						NameEntryNonTop10Entry[j].text = currentLeaderboard.entry[j].displayName;
						TimeEntryNonTop10Entry[j].text = currentLeaderboard.entry[j].time;
					}
					if (currentLeaderboard.entry[j].position.ToString() == ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true))
					{
						NameEntryNonTop10Entry[j].color = new UnityEngine.Color(0f, 0.7921569f, 1f, 1f);
					}
					else
					{
						NameEntryNonTop10Entry[j].color = new UnityEngine.Color(47f / 51f, 47f / 51f, 47f / 51f, 1f);
					}
					if (NetworkLeaderboards.USE_LEADERBOARDS && currentLeaderboard.entry[j].displayName != string.Empty)
					{
						PositionNonTop10Entry[j].text = currentLeaderboard.entry[j].position + 1 + ".";
					}
					else
					{
						PositionNonTop10Entry[j].text = string.Empty;
					}
					TimeEntryNonTop10Entry[j].text = TimeEntryNonTop10Entry[j].text.Replace("-", string.Empty);
				}
			}
		}
	}
}
public class FEMManager : UnityEngine.MonoBehaviour
{
	public enum FEMOption
	{
		None = -1,
		Online,
		Settings,
		Race,
		TV,
		PlayerConfig,
		Championship,
		ChampTypeSelect,
		TrophySelect,
		EnvSelect,
		TrackSelect,
		SpeedSelect,
		OnlineWait,
		Results,
		Extra_Customisation_Enter,
		Extra_Customisation_Wait,
		Extra_Customisation_Exit,
		QuickRaceType,
		Championship_SpeedSelect
	}

	public enum FEMOnlineState
	{
		None,
		WaitingForRoom,
		EnteringRoom,
		InRoom,
		EnteringHoldingRoom,
		InHoldingRoom,
		LeavingHoldingRoom,
		ResettingHoldingRoom,
		WaitForFade,
		WaitForFade_Back
	}

	public enum FEMAudioClip
	{
		MenuPopUp,
		MenuClosed,
		OptionHighlight,
		OptionSelect,
		MenuBack,
		LetsRaceClip,
		Welcome_Short
	}

	public enum PlayerVote
	{
		Vote_None,
		Vote_Track1,
		Vote_Track2
	}

	public enum OnlineSigninState
	{
		None,
		WaitingForSignIn,
		ReadyForOnline
	}

	private enum TVChannel
	{
		FTUE,
		Credits,
		Replay,
		None,
		Max
	}

	[HideInInspector]
	public PlayerVote[] PlayerVotes = new PlayerVote[8];

	private FEMOption m_currentOption = FEMOption.None;

	private string m_selectedEnv;

	private bool m_selectedArrowOnThisFrame;

	private int PlayerForOnlineGame = 2;

	private ChampionshipMode.TrophyGroupingType m_selectedChampGrouping;

	private bool m_arrowUp;

	private bool m_arrowDown;

	private const float MenuSelectionPulseSpeed = 8f;

	private const float MenuSelectionPulseTime = 1.5f;

	private const int SinglePlayerOnlineCountMax = 3;

	[SerializeField]
	private string CustomiseSceneName;

	[SerializeField]
	private GameObject NetworkingSystemPrefab;

	[SerializeField]
	private BoxCollider ChampionshipObject;

	[SerializeField]
	private BoxCollider OnlineObject;

	[SerializeField]
	private BoxCollider SettingsObject;

	[SerializeField]
	private BoxCollider RaceObject;

	[SerializeField]
	private BoxCollider ReplayObject;

	[SerializeField]
	private BoxCollider PlayerConfigObject;

	[SerializeField]
	private BoxCollider ChampionshipObject_Hold;

	[SerializeField]
	private BoxCollider OnlineObject_Hold;

	[SerializeField]
	private BoxCollider SettingsObject_Hold;

	[SerializeField]
	private BoxCollider RaceObject_Hold;

	[SerializeField]
	private BoxCollider ReplayObject_Hold;

	[SerializeField]
	private BoxCollider PlayerConfigObject_Hold;

	[SerializeField]
	private Locator[] OptionLocators;

	[SerializeField]
	private MenuPlane MenuOnline;

	[SerializeField]
	private MenuPlane MenuTrophy;

	[SerializeField]
	private MenuPlane MenuPlayerConfig;

	[SerializeField]
	private MenuPlane MenuChampionship;

	[SerializeField]
	private MenuPlane SettingsMenuPlane;

	[SerializeField]
	private Locator LeaderboardLocator;

	[SerializeField]
	private GameObject TVBlankObject;

	[SerializeField]
	private GameObject TVLogo;

	[SerializeField]
	private GameObject SpeedTitle;

	[SerializeField]
	private GameObject[] SettingsMenuOptions;

	[SerializeField]
	private TextMesh ProfileNameText;

	[SerializeField]
	private Keyboard KeyBoardObj;

	[SerializeField]
	private Text KeyBoardText;

	[SerializeField]
	private GameObject OnlineRoom;

	[SerializeField]
	private Locator[] OnlineRoomLocators;

	[SerializeField]
	private GameObject OnlineScreen;

	[SerializeField]
	private GameObject PlayersOnlineNotification;

	[SerializeField]
	private float TimeForMenu = 0.5f;

	[SerializeField]
	public GameObject CreditsRoot;

	[SerializeField]
	public GameObject FTUERoot;

	[SerializeField]
	private GameObject SceneryRoot;

	[SerializeField]
	private Locator CameraLocator;

	[SerializeField]
	private Locator CameraLocatorSteam;

	[SerializeField]
	public AudioClip MenuPopUp;

	[SerializeField]
	public AudioClip MenuClosed;

	[SerializeField]
	public AudioClip OptionHighlight;

	[SerializeField]
	public AudioClip OptionSelect;

	[SerializeField]
	public AudioClip SendMessageClip;

	[SerializeField]
	public AudioClip ReceiveMessageClip;

	[SerializeField]
	private AudioClip MenuBack;

	[SerializeField]
	private AudioClip LetsRaceClip;

	[SerializeField]
	private AudioClip[] WelcomeBackClips;

	[SerializeField]
	public AudioSource TVAudioSource;

	[SerializeField]
	public Transform HelmetTransform;

	[SerializeField]
	private AudioSource m_FEMSpeechSource;

	[SerializeField]
	private MenuHint MenuHintObj;

	[SerializeField]
	public Subtitles SubtitleUI;

	[SerializeField]
	private TextMesh ExtraCustomisationOption;

	[SerializeField]
	private Text NameText;

	[SerializeField]
	private TextMesh NameTitle;

	[SerializeField]
	private TextMesh ConfigureTitle;

	[SerializeField]
	private TextMesh ConfigureInput;

	[SerializeField]
	private GameObject ConfigurePressToConfirmRoot;

	[SerializeField]
	private TextMesh MusicVolumeText;

	[SerializeField]
	private TextMesh SFXVolumeText;

	[SerializeField]
	private TextMesh SetupConfigText;

	[SerializeField]
	private TextMesh ResetConfigText;

	[SerializeField]
	private TextMesh VersionNo;

	[SerializeField]
	private float LeaderboardRefreshTime = 5f;

	[SerializeField]
	private Transform SettingsTextOffset;

	[SerializeField]
	public Tablet TabletObj;

	[SerializeField]
	private GameObject[] ChampModeRosettes = new GameObject[3];

	private const string FTUE_Track = "STR_Track10_Env1";

	private const string Demo_Track = "STR_Track13_Env1";

	public UnityEngine.Color DisabledColour = new UnityEngine.Color(0.35686275f, 0.35686275f, 0.35686275f);

	private UnityEngine.AsyncOperation m_loadingStatus;

	private bool m_waitingForCustomiseScene = true;

	private GameObject m_extraCustomiseRoot;

	private OnlineTrackScreen m_onlineTrackScreen;

	private AudioSource m_FEMAudioSource;

	private List<GameObject> m_menuTextOptions = new List<GameObject>();

	private float m_menuSelectionPulseAngle;

	private float m_menuSelectionScaleTimer;

	private float m_lookTime;

	private int m_numPulsesDone;

	private int m_numPulsesRequired = 1;

	private int m_flashOptionIndex = -1;

	private int m_avoidArrowIndex = -1;

	private bool m_customisationChange;

	private bool m_volumeChange;

	private bool m_volumeOptions;

	private List<TrackList.TrackData> m_trackItems = new List<TrackList.TrackData>();

	private int m_minScrollItem;

	private int m_scrollBarItem;

	private int m_currentScrollItem;

	private const int NumItemsToScroll = 3;

	private bool m_keyboardEnabled;

	private bool m_storeNewProfileName;

	private bool m_configureInputEnabled;

	private bool m_configureOption;

	private bool m_ftueConfigureInput;

	private float m_savingTimer;

	private float m_attractTimer;

	private int m_singlePlayerOnlineSearchCount;

	private EnvList m_envList;

	private GameObject m_FEMRoot;

	private FEMConfigControls m_femConfigControls;

	private FEMOnlineState m_femOnlineState;

	private float m_holdingTimer = 30f;

	private float m_searchingForPlayersTimer = 10f;

	private float m_prevHoldingTimer;

	private string m_onlineTrackName = string.Empty;

	private int m_humanOnlineIndex;

	private bool m_doorsAreLocked;

	private bool m_readyToSetName = true;

	private bool m_chooseVotingTracks;

	private int m_onlineTrackIndex;

	private bool m_waitForPlayersToBeDestroyed = true;

	private Player[] m_playerObject;

	private bool[] m_playerAppears;

	private List<Player> m_playingPlayersInHolding = new List<Player>();

	private bool m_allowedToJoinNetworkGame;

	private bool m_gameIsLoading;

	private float m_failSafeTimer;

	private bool m_waitForStart = true;

	private int m_falseFrameWait;

	private string m_levelToLoad = string.Empty;

	private const float k_LevelLoadWaitTime = 0.6f;

	private float m_levelLoadTime;

	private bool m_waitForFullBuild = true;

	private float m_leaderboardRefreshTime;

	private bool m_enterOnlineNow;

	private float m_tempOnlineTimer = 8f;

	public Transform GrabbedVolumeHandle;

	public static FEMManager Instance;

	private TVChannel m_channel;

	private float DefaultTextScale = 0.05f;

	private float HighlightedTextScale = 0.065f;

	private float ExtraPulseScale = 0.01f;

	private float NonInteractiveTextScale = 0.06f;

	public FEMOption CurrentOption => m_currentOption;

	public int NumPlayersForOnlineGame => PlayerForOnlineGame;

	public bool SetArrowUp
	{
		get
		{
			return m_arrowUp;
		}
		set
		{
			m_arrowUp = value;
			m_selectedArrowOnThisFrame = true;
		}
	}

	public bool SetArrowDown
	{
		get
		{
			return m_arrowDown;
		}
		set
		{
			m_arrowDown = value;
			m_selectedArrowOnThisFrame = true;
		}
	}

	public MenuHint MenuHintObject => MenuHintObj;

	public bool InHoldingState { get; set; }

	public bool ReadyToStartFEM()
	{
		return m_falseFrameWait >= 10;
	}

	public bool EnteredFrontendMenus()
	{
		switch (m_currentOption)
		{
		case FEMOption.Online:
		case FEMOption.Race:
		case FEMOption.TV:
		case FEMOption.PlayerConfig:
		case FEMOption.Championship:
		case FEMOption.Extra_Customisation_Enter:
		case FEMOption.Extra_Customisation_Wait:
		case FEMOption.Extra_Customisation_Exit:
			return false;
		case FEMOption.Settings:
			if (!VolumeOptionsEnabled() && !ConfigureDialogEnabled() && !ConfigureOptionEnabled() && !ConfigurePressToConfirmRoot.activeSelf)
			{
				return false;
			}
			return true;
		default:
			return true;
		}
	}

	public bool VolumeOptionsEnabled()
	{
		return m_volumeOptions;
	}

	public bool ConfigureDialogEnabled()
	{
		return m_configureInputEnabled;
	}

	public bool ConfigureOptionEnabled()
	{
		return m_configureOption;
	}

	public bool KeyboardEnabled()
	{
		return m_keyboardEnabled;
	}

	public bool WaitingForVoteSelection()
	{
		return m_onlineTrackScreen.WaitingForVoteSelection();
	}

	public Player GetFrontendPlayer(int playerIndex)
	{
		if (m_playerObject != null && m_playerObject.Length > 0)
		{
			return m_playerObject[playerIndex];
		}
		return null;
	}

	public EnvList GetEnvList()
	{
		return m_envList;
	}

	public void AddPlayingPlayerInHolding(Player player)
	{
		m_playingPlayersInHolding.Add(player);
	}

	public void RemovePlayingPlayerInHolding(int ID)
	{
		for (int i = 0; i < m_playingPlayersInHolding.Count; i++)
		{
			if (m_playingPlayersInHolding[i].OnlinePlayerIndex == ID)
			{
				NetworkLogin.Instance.GetServer().RemovePlayerConnection(m_playingPlayersInHolding[i].OnlinePlayerIndex, m_playingPlayersInHolding[i].SeatIndex);
				NetworkLogin.Instance.GetClient().ResetCharacterList(m_playingPlayersInHolding[i].SeatIndex);
				m_playingPlayersInHolding.RemoveAt(i);
			}
		}
	}

	public void AddHoldingPlayer(string name, int ID)
	{
		m_onlineTrackScreen.AddHoldingPlayer(name, ID);
	}

	public List<Player> GetPlayingPlayersInHolding()
	{
		return m_playingPlayersInHolding;
	}

	public float GetCurrentHoldingTimer()
	{
		return m_holdingTimer;
	}

	public void SetCurrentHoldingTimer(float time)
	{
		m_holdingTimer = time;
	}

	public Player[] GetFrontendPlayerList()
	{
		return m_playerObject;
	}

	public void PlayAudio(FEMAudioClip audioType)
	{
		switch (audioType)
		{
		default:
			UnityEngine.Debug.Log("ERROR - UNKNOWN CLIP");
			break;
		case FEMAudioClip.MenuPopUp:
			m_FEMAudioSource.clip = MenuPopUp;
			break;
		case FEMAudioClip.MenuClosed:
			m_FEMAudioSource.clip = MenuClosed;
			break;
		case FEMAudioClip.OptionHighlight:
			m_FEMAudioSource.clip = OptionHighlight;
			break;
		case FEMAudioClip.OptionSelect:
			m_FEMAudioSource.clip = OptionSelect;
			break;
		case FEMAudioClip.MenuBack:
			m_FEMAudioSource.clip = MenuBack;
			break;
		case FEMAudioClip.LetsRaceClip:
			m_FEMAudioSource.clip = LetsRaceClip;
			break;
		case FEMAudioClip.Welcome_Short:
			m_FEMSpeechSource.clip = WelcomeBackClips[UnityEngine.Random.Range(0, WelcomeBackClips.Length)];
			m_FEMSpeechSource.Play();
			SubtitleUI.SetText(m_FEMSpeechSource.clip, m_FEMSpeechSource);
			return;
		}
		m_FEMAudioSource.Play();
	}

	public FEMOnlineState GetOnlineState()
	{
		return m_femOnlineState;
	}

	public void ResetStates()
	{
		m_currentOption = FEMOption.None;
		m_femOnlineState = FEMOnlineState.None;
	}

	public void SavingEnabled()
	{
		m_savingTimer = GameTime.Instance.CurrentTime() + 1f;
	}

	public Transform GetControllerSpot()
	{
		if (!MenuHintObj)
		{
			return null;
		}
		return MenuHintObj.transform;
	}

	public void SetOptionSelected(int optionIndex)
	{
		if (m_currentOption == FEMOption.Settings)
		{
			optionIndex++;
		}
		SetFlashIndex(optionIndex);
	}

	public void HumanPlayerLeft()
	{
		NetworkLogin.Instance.GetClient().SetCharacterListEvent(m_humanOnlineIndex, NetworkClient.EventMask.LeftRoom);
		NetworkLogin.Instance.GetClient().ResetCharacterList(m_humanOnlineIndex);
	}

	public void SetCurrentRoomCount()
	{
		for (int i = 0; i < m_playerObject.Length; i++)
		{
			if (m_playerObject[i] != null)
			{
				NetworkLogin.Instance.IncludeOnlinePlayer(m_playerObject[i].OnlinePlayerIndex);
			}
		}
	}

	public void EndCustomisation()
	{
		m_currentOption = FEMOption.Extra_Customisation_Exit;
		MenuHintObj.transform.parent = CameraLocator.transform;
		MenuHintObj.transform.position = Vector3.zero;
		MenuHintObj.transform.rotation = Quaternion.identity;
	}

	private void UpdatePlayersInRoom()
	{
		int[] playerIDList = NetworkLogin.Instance.GetPlayerIDList();
		int num = 0;
		int num2 = 0;
		if (m_playerObject == null)
		{
			return;
		}
		for (num = 0; num < m_playerObject.Length; num++)
		{
			int num3 = 0;
			if (m_playerObject[num] != null)
			{
				num2++;
				for (num3 = 0; num3 < playerIDList.Length && m_playerObject[num].OnlinePlayerIndex != playerIDList[num3]; num3++)
				{
				}
				if (num3 == playerIDList.Length)
				{
					RemoveNetworkPlayer(m_playerObject[num].OnlinePlayerIndex);
				}
			}
		}
		for (int i = 0; i < playerIDList.Length; i++)
		{
			for (num = 0; num < m_playerObject.Length && (!(m_playerObject[num] != null) || m_playerObject[num].OnlinePlayerIndex != playerIDList[i]); num++)
			{
			}
			if (Instance.InHoldingState && NetworkLogin.Instance.IsPlayerLocal(playerIDList[i]))
			{
				AddPlayerToRoom(playerIDList[i]);
			}
			else if (!m_doorsAreLocked && num == m_playerObject.Length)
			{
				AddPlayerToRoom(playerIDList[i]);
			}
		}
		if (!m_doorsAreLocked && (bool)NetworkLogin.Instance && NetworkLogin.Instance.IsRoomInRace() && NetworkLogin.Instance.IsMasterPlayer() && num2 == playerIDList.Length)
		{
			UnlockDoors();
		}
		if (!m_waitForPlayersToBeDestroyed || !NetworkLogin.Instance.IsMasterPlayer())
		{
			return;
		}
		int num4 = 0;
		for (num = 0; num < m_playerObject.Length; num++)
		{
			if (m_playerObject[num] != null && m_playerObject[num].gameObject.activeSelf)
			{
				num4++;
			}
		}
		if (num4 == NetworkLogin.Instance.GetActualRoomPlayerCount())
		{
			m_waitForPlayersToBeDestroyed = false;
			PhotonNetwork.DestroyAll();
		}
	}

	public void AddPlayerToRoom(int photonPlayerID)
	{
		for (int i = 0; i < m_playerObject.Length; i++)
		{
			if (m_playerObject[i] == null)
			{
				if (i == 0)
				{
					m_playerObject[i] = KartManager.Instance.CreateKart(KartManager.KartType.FEM, Player.PlayerType.Human, -1, string.Empty, 0, -1, string.Empty, Vector3.zero, Quaternion.identity);
				}
				else
				{
					m_playerObject[i] = KartManager.Instance.CreateKart(KartManager.KartType.FEM, Player.PlayerType.FEM, -1, string.Empty, 0, -1, string.Empty, Vector3.zero, Quaternion.identity);
					m_playerObject[i].gameObject.SetActive(value: false);
				}
				m_playerObject[i].transform.parent = base.transform;
				m_playerObject[i].GetComponent<Rigidbody>().useGravity = false;
				m_playerObject[i].OnlinePlayerIndex = photonPlayerID;
				if (i > 0)
				{
					m_playerObject[i].gameObject.SetActive(value: false);
					break;
				}
				int num = 0;
				m_humanOnlineIndex = m_playerObject[num].SeatIndex;
				m_onlineTrackScreen.SetPlayerPosition(m_playerObject[num].transform);
				ProfileManager.Instance.SetColoursOnPlayer(ref m_playerObject[num], num);
				NetworkLogin.Instance.GetServer().SetPlayerConnection(photonPlayerID, m_humanOnlineIndex);
				m_playerObject[num].SetupCustomisationProps(m_playerObject[num].LocalPlayerIndex);
				break;
			}
		}
	}

	public void RemoveNetworkPlayer(int photonPlayerID)
	{
		for (int i = 0; i < m_playerObject.Length; i++)
		{
			if (m_playerObject[i] != null && m_playerObject[i].OnlinePlayerIndex == photonPlayerID)
			{
				m_playerAppears[i] = false;
				if (!InHoldingState)
				{
					GameSystem.Instance.GetPuffParticles().DoPuff(m_playerObject[i].transform.position);
				}
				NetworkLogin.Instance.GetServer().RemovePlayerConnection(m_playerObject[i].OnlinePlayerIndex, m_playerObject[i].SeatIndex);
				NetworkLogin.Instance.GetClient().ResetCharacterList(m_playerObject[i].SeatIndex);
				UnityEngine.Object.Destroy(m_playerObject[i].gameObject);
				m_playerObject[i] = null;
				GameSystem.Instance.GetPositionChooser().FreeUpSeat(photonPlayerID);
				break;
			}
		}
	}

	public void EnableOption(FEMOption option, bool enable)
	{
		switch (option)
		{
		case FEMOption.Championship:
			if (ChampionshipObject != null)
			{
				ChampionshipObject.enabled = enable;
			}
			break;
		case FEMOption.Online:
			if (OnlineObject != null)
			{
				OnlineObject.enabled = enable;
			}
			break;
		case FEMOption.Settings:
			if (SettingsObject != null)
			{
				SettingsObject.enabled = enable;
			}
			break;
		case FEMOption.Race:
			RaceObject.enabled = enable;
			break;
		case FEMOption.PlayerConfig:
			PlayerConfigObject.enabled = enable;
			break;
		case FEMOption.TV:
			ReplayObject.enabled = enable;
			break;
		}
	}

	public void LockDoors()
	{
		m_doorsAreLocked = true;
		if (!NetworkLogin.Instance.IsRoomInRace())
		{
			NetworkLogin.Instance.SetRoomInRace(openRoom: true);
		}
		NetworkLogin.Instance.GetServer().SendFrontendDetails(send: false);
	}

	private void UnlockDoors()
	{
		m_doorsAreLocked = false;
		NetworkLogin.Instance.SetRoomInRace(openRoom: false);
		NetworkLogin.Instance.GetServer().ResetFrontendDetails();
		if (NetworkLogin.Instance.IsMasterPlayer())
		{
			PhotonNetwork.DestroyAll();
		}
	}

	public void RandomiseGridPositions()
	{
		if (!NetworkLogin.Instance.IsMasterPlayer())
		{
			return;
		}
		int num = 0;
		int roomPlayerCount = NetworkLogin.Instance.GetRoomPlayerCount();
		for (int i = 0; i < m_playerObject.Length; i++)
		{
			if (!(m_playerObject[i] == null))
			{
				int num2 = 0;
				do
				{
					num2 = UnityEngine.Random.Range(0, roomPlayerCount);
				}
				while ((num & (1 << num2)) != 0);
				num |= 1 << num2;
				m_playerObject[i].NewGridPosition = num2;
			}
		}
	}

	private void OnDestroy()
	{
		if (CameraManager.Instance != null)
		{
			DisableFEM();
		}
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		m_femConfigControls = GetComponent<FEMConfigControls>();
	}

	private void Start()
	{
		VersionNo.text = "v. " + ProfileManager.PUBLIC_VERSION_NO;
		if (CustomiseSceneName != null)
		{
			m_waitingForCustomiseScene = true;
		}
		m_onlineTrackScreen = OnlineScreen.GetComponent<OnlineTrackScreen>();
		if ((bool)NetworkLogin.Instance)
		{
			NetworkLogin.Instance.GetNetworkLeaderboards().GetOnlinePointsLeaderboard(null, showLeaderboardAroundUser: false, showLeaderboardAroundFriends: false);
		}
	}

	private void SetTVChannel(TVChannel channel)
	{
		m_channel = channel;
		switch (m_channel)
		{
		case TVChannel.None:
			if (CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.Credits))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.Credits, enableCam: false, enableListener: false);
			}
			if (CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.SwitchAbleCameras))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.SwitchAbleCameras, enableCam: false, enableListener: false);
			}
			break;
		case TVChannel.FTUE:
			if (!CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.Credits))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.Credits, enableCam: true, enableListener: false);
			}
			if (CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.SwitchAbleCameras))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.SwitchAbleCameras, enableCam: false, enableListener: false);
			}
			break;
		case TVChannel.Credits:
			if (!CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.Credits))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.Credits, enableCam: true, enableListener: false);
			}
			if (CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.SwitchAbleCameras))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.SwitchAbleCameras, enableCam: false, enableListener: false);
			}
			break;
		case TVChannel.Replay:
			if (!CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.SwitchAbleCameras))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.SwitchAbleCameras, enableCam: true, enableListener: false);
			}
			if (CameraManager.Instance.IsCameraEnabled(CameraManager.CameraType.Credits))
			{
				CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.Credits, enableCam: false, enableListener: false);
			}
			break;
		}
		if ((bool)TVBlankObject)
		{
			TVBlankObject.SetActive(m_channel == TVChannel.None);
		}
		if ((bool)CreditsRoot)
		{
			CreditsRoot.SetActive(m_channel == TVChannel.Credits);
		}
		if ((bool)FTUERoot)
		{
			FTUERoot.SetActive(m_channel == TVChannel.FTUE);
		}
		if ((bool)TVLogo)
		{
			TVLogo.SetActive(m_channel == TVChannel.Replay);
		}
	}

	private void EnteringOnlineRoom()
	{
		GameEntry.Instance.DestroyGame();
		CreditsRoot.gameObject.SetActive(value: false);
		m_extraCustomiseRoot.gameObject.SetActive(value: false);
	}

	public void EnableFEM(bool enableOnlineRoom)
	{
		if (enableOnlineRoom && QuitMenu.Instance.WasKickedOut())
		{
			enableOnlineRoom = false;
		}
		GameSystem.Instance.FTUERoot.gameObject.SetActive(value: true);
		GameSystem.Instance.ReducedPowerMode(enable: true);
		if ((bool)NetworkLogin.Instance)
		{
			NetworkLogin.Instance.SetReadyToAuthenticate();
			string googleDisplayName = NetworkLogin.Instance.GetGoogleDisplayName();
			if (googleDisplayName != string.Empty)
			{
				ProfileManager.Instance.SetPlayerName(0, googleDisplayName);
			}
			else
			{
				ProfileManager.Instance.SetPlayerName(0, "Player");
			}
		}
		else
		{
			ProfileManager.Instance.SetPlayerName(0, "Player");
		}
		m_readyToSetName = true;
		ProfileNameText.text = string.Empty;
		MenuHintObj.Saving(enable: false);
		m_savingTimer = 0f;
		GameSystem.Instance.EnableTimeTrialMode = false;
		GameSystem.Instance.PlayingGame = false;
		GameSystem.Instance.FrameReferenceManager.ResetFrameReferences();
		GameSystem.Instance.WasInOnlineRoom = false;
		ProfileManager.Instance.ClearProfileData();
		m_gameIsLoading = false;
		GameSystem.Instance.ResetLevelMusic();
		GameSystem.Instance.ResetLevelMusic();
		QuitMenu.Instance.Reset();
		Player refPlayer = null;
		if (PlayerManager.Instance != null && PlayerManager.Instance.GetHumanPlayer(ref refPlayer))
		{
			PlayerManager.Instance.GetPlayerList().Remove(refPlayer);
			UnityEngine.Object.Destroy(refPlayer.gameObject, 0.5f);
		}
		m_FEMRoot.SetActive(value: true);
		CameraManager.Instance.GetCurrentCamera().transform.rotation = CameraLocator.transform.rotation;
		CameraManager.Instance.SetNewTransform(CameraLocator.transform);
		CameraManager.Instance.UpdateFollow(CameraLocator.transform.gameObject);
		if (ProfileManager.Instance.FTUE == 1)
		{
			SetTVChannel(TVChannel.FTUE);
		}
		else if (ReplaySystem.Instance != null && ReplaySystem.Instance.enabled)
		{
			SetTVChannel(TVChannel.Replay);
		}
		else
		{
			SetTVChannel(TVChannel.Credits);
		}
		if (OnlineRoom != null)
		{
			if (enableOnlineRoom)
			{
				m_currentOption = FEMOption.OnlineWait;
				m_femOnlineState = FEMOnlineState.EnteringRoom;
				m_onlineTrackName = string.Empty;
				NetworkLogin.Instance.GetServer().ResetPlayerConnections();
				NetworkLogin.Instance.GetClient().ResetAllCharacterLists();
				NetworkLogin.Instance.ClearAllOnlinePlayers();
				GameSystem.Instance.GetPositionChooser().ClearAllSeats();
			}
			else
			{
				OnlineRoom.SetActive(value: false);
				if (Gameplay.Instance != null)
				{
					CameraManager.Instance.GetCurrentCamera().transform.rotation = CameraLocator.transform.rotation;
					CameraManager.Instance.SetNewTransform(CameraLocator.transform);
					CameraManager.Instance.UpdateFollow(CameraLocator.transform.gameObject);
					Player mainHumanPlayer = Gameplay.Instance.GetMainHumanPlayer();
					if (mainHumanPlayer != null)
					{
						mainHumanPlayer.transform.parent = Gameplay.Instance.gameObject.transform;
					}
				}
				KartManager.Instance.PreCacheKart(KartManager.KartType.FEM);
			}
		}
		for (int i = 0; i < CameraManager.Instance.GetCurrentCamera().m_cameraArray.Length; i++)
		{
			CameraManager.Instance.GetCurrentCamera().m_cameraArray[i].cullingMask &= -16385;
			CameraManager.Instance.GetCurrentCamera().m_cameraArray[i].cullingMask &= -33554433;
		}
		CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.TabletCamera, enableCam: true, enableListener: false);
		if ((bool)Gameplay.Instance)
		{
			Gameplay.Instance.FEMNowEnabled();
		}
		if ((bool)FTUE.Instance)
		{
			FTUE.Instance.FinishedGame();
		}
		ProfileManager.Instance.SaveProfileData();
		GameSystem.Instance.RecentreHeadsetPosition();
	}

	private void DisableFEM()
	{
		m_gameIsLoading = false;
		if ((bool)QuitMenu.Instance)
		{
			QuitMenu.Instance.Reset();
		}
		for (int i = 0; i < CameraManager.Instance.GetCurrentCamera().m_cameraArray.Length; i++)
		{
			CameraManager.Instance.GetCurrentCamera().m_cameraArray[i].cullingMask |= 16384;
			CameraManager.Instance.GetCurrentCamera().m_cameraArray[i].cullingMask |= 33554432;
		}
		CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.SwitchAbleCameras, enableCam: false, enableListener: false);
		CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.Credits, enableCam: false, enableListener: false);
		CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.TabletCamera, enableCam: false, enableListener: false);
	}

	public string GetOnlineTrackName()
	{
		return m_onlineTrackName;
	}

	public int GetOnlineTrackIndex()
	{
		return m_onlineTrackIndex;
	}

	public void SetOnlineTrack(int trackIndex)
	{
		m_onlineTrackIndex = trackIndex;
		m_onlineTrackName = GameSystem.Instance.GetTrackListing().GetTrackByIndex(trackIndex).Name;
	}

	public void RemoveFEMPlayers()
	{
		if (!NetworkLogin.Instance)
		{
			return;
		}
		CameraManager.Instance.GetCurrentCamera().transform.parent = null;
		CameraManager.Instance.GetCurrentCamera().transform.localPosition = Vector3.zero;
		for (int i = 0; i < m_playerObject.Length; i++)
		{
			if ((bool)m_playerObject[i])
			{
				UnityEngine.Object.Destroy(m_playerObject[i].gameObject);
				m_playerObject[i] = null;
			}
		}
	}

	private void Update()
	{
		if ((bool)GameEntry.Instance && !GameEntry.Instance.FinishedLoading())
		{
			return;
		}
		if (m_levelToLoad.Length > 0)
		{
			WaitForSafeLevelLoading();
			return;
		}
		if (m_waitingForCustomiseScene && m_FEMRoot != null)
		{
			m_waitingForCustomiseScene = false;
			m_extraCustomiseRoot = GameObject.Find("CustomiseRoot");
			if ((bool)m_extraCustomiseRoot)
			{
				m_extraCustomiseRoot.transform.parent = m_FEMRoot.transform;
				m_extraCustomiseRoot.GetComponent<ExtraCustomisation>().EnableCustomisation(enable: false);
				m_extraCustomiseRoot.SetActive(value: false);
			}
		}
		if (m_waitForStart)
		{
			if (GameEntry.Instance == null || GameEntry.Instance.FinishedLoading())
			{
				m_waitForStart = false;
				if (NetworkLogin.Instance == null || !NetworkLogin.Instance.JoinedRoom())
				{
					FadeManager.Instance.FadeIn();
				}
				m_FEMRoot = GameObject.Find("FEMRoot");
				m_FEMAudioSource = GetComponent<AudioSource>();
				m_envList = GetComponent<EnvList>();
				m_envList.ParseEnvironments();
				TurnOffAllMenus();
				if ((bool)NetworkLogin.Instance)
				{
					m_playerObject = new Player[NetworkLogin.Instance.MaxPlayersInRoom];
					m_playerAppears = new bool[NetworkLogin.Instance.MaxPlayersInRoom];
				}
				bool enableOnlineRoom = NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom();
				EnableFEM(enableOnlineRoom);
				if (ProfileManager.Instance.FTUE == 1)
				{
					m_ftueConfigureInput = true;
					GameSystem.WaitForWelcome = false;
				}
			}
			return;
		}
		if (m_playerObject != null)
		{
			for (int i = 0; i < m_playerObject.Length; i++)
			{
				if (m_playerObject[i] != null)
				{
					m_playerObject[i].GetComponent<Rigidbody>().velocity = Vector3.zero;
					m_playerObject[i].transform.position = new Vector3(m_playerObject[i].transform.position.x, OnlineRoomLocators[0].transform.position.y, m_playerObject[i].transform.position.z);
					m_playerObject[i].transform.rotation = OnlineRoomLocators[m_playerObject[i].SeatIndex].transform.rotation;
				}
			}
		}
		CheckForName();
		if ((QuitMenu.Instance.InProgress() && m_femOnlineState == FEMOnlineState.None) || (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Frontend))
		{
			return;
		}
		if (m_falseFrameWait <= 10)
		{
			int falseFrameWait = m_falseFrameWait;
			m_falseFrameWait++;
			if (falseFrameWait < 10 && m_falseFrameWait >= 10)
			{
				FadeManager.Instance.FadeIn();
			}
		}
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady && NetworkLogin.Instance.GetConnectionStatus() == NetworkLogin.ServerConnectionState.NotConnected)
		{
			m_leaderboardRefreshTime = 0f;
			NetworkLogin.Instance.ConnectToServer();
		}
		else if (GameTime.Instance.CurrentTime() > m_leaderboardRefreshTime && NetworkLogin.Instance != null && NetworkLogin.Instance.AuthenticatedAndReady)
		{
			NetworkLogin.Instance.GetNetworkLeaderboards().RefreshLeaderboards();
			NetworkLogin.Instance.GetUserData(NetworkLogin.Instance.PlayFabPlayerID);
			m_leaderboardRefreshTime = GameTime.Instance.CurrentTime() + LeaderboardRefreshTime;
		}
		if (m_falseFrameWait <= 10)
		{
			m_falseFrameWait++;
			return;
		}
		if (GameSystem.WaitForWelcome && FadeManager.Instance.FinishedFading())
		{
			GameSystem.WaitForWelcome = false;
			PlayAudio(FEMAudioClip.Welcome_Short);
		}
		bool allowedToJoinNetworkGame = m_allowedToJoinNetworkGame;
		m_allowedToJoinNetworkGame = (bool)NetworkLogin.Instance && NetworkLogin.Instance.ConnectedToMaster();
		if (m_allowedToJoinNetworkGame && m_currentOption == FEMOption.Online && allowedToJoinNetworkGame != m_allowedToJoinNetworkGame)
		{
			SetupOption(m_currentOption);
		}
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Frontend)
		{
			return;
		}
		if (!NetworkLogin.Instance || !NetworkLogin.Instance.JoinedRoom())
		{
			if (GameSystem.Instance.HMDConnected() || CameraManager.Instance.GetCurrentType() == CameraManager.CameraType.FP)
			{
				UpdateOptions();
			}
			UpdateTVChannels();
			UpdateMenuHint();
		}
		UpdateNameTags();
		UpdateRosettes();
		if (PlayersOnlineNotification != null && m_allowedToJoinNetworkGame)
		{
			bool flag = (bool)NetworkLogin.Instance && NetworkLogin.Instance.GetServerPlayerCount() > 0;
			if (PlayersOnlineNotification.activeSelf != flag)
			{
				PlayersOnlineNotification.SetActive(flag);
			}
			if (m_currentOption == FEMOption.Online && m_menuTextOptions.Count > 3)
			{
				if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.GetServerPlayerCount() > 0)
				{
					SetOptionText(3, "(" + GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_PlayersOnline", convertToUpperCase: true) + ")");
				}
				else
				{
					SetOptionText(3, string.Empty);
				}
			}
		}
		else if (PlayersOnlineNotification.activeSelf)
		{
			PlayersOnlineNotification.SetActive(value: false);
		}
		if (((bool)GetCurrentMenu(m_currentOption).LockedQuad && GetCurrentMenu(m_currentOption).LockedQuad.activeSelf) || GameSystem.Instance.ApplicationPaused)
		{
			return;
		}
		if (m_currentOption == FEMOption.Online || m_enterOnlineNow)
		{
			if ((!GetCurrentMenu(m_currentOption).LockedQuad.activeSelf || m_enterOnlineNow) && (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A) || m_enterOnlineNow) && m_allowedToJoinNetworkGame && NetworkLogin.Instance.ConnectedToMaster())
			{
				m_enterOnlineNow = false;
				SetOptionText(3, string.Empty);
				PlayAudio(FEMAudioClip.OptionSelect);
				if (m_allowedToJoinNetworkGame)
				{
					NetworkLogin.Instance.GetServer().ResetPlayerConnections();
					NetworkLogin.Instance.GetClient().ResetAllCharacterLists();
					for (int j = 0; j < PlayerVotes.Length; j++)
					{
						PlayerVotes[j] = PlayerVote.Vote_None;
					}
					GameSystem.Instance.NumWins = 0;
					m_femOnlineState = FEMOnlineState.WaitingForRoom;
					NetworkLogin.Instance.ConnectOnline();
					m_currentOption = FEMOption.OnlineWait;
				}
			}
		}
		else if (m_currentOption == FEMOption.OnlineWait)
		{
			if (m_femOnlineState == FEMOnlineState.WaitingForRoom)
			{
				SetOptionText(2, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_SearchForRace", convertToUpperCase: true) + "..");
				if (NetworkLogin.Instance.JoinedRoom())
				{
					FadeManager.Instance.FadeOut();
					InHoldingState = NetworkLogin.Instance.IsRoomInRace();
					m_failSafeTimer = 0f;
					m_femOnlineState = FEMOnlineState.EnteringRoom;
				}
				else
				{
					UpdateFailSafe();
				}
			}
			else if (m_femOnlineState == FEMOnlineState.EnteringRoom)
			{
				if (FadeManager.Instance.FinishedFading())
				{
					EnteringOnlineRoom();
					if ((bool)OnlineRoom)
					{
						OnlineRoom.SetActive(value: true);
						TurnOffAllMenus();
						NetworkLogin.Instance.GetServer().SendFrontendDetails(send: true);
						if (m_playerObject[0] != null && m_femOnlineState != FEMOnlineState.ResettingHoldingRoom)
						{
							CameraManager.Instance.GetCurrentCamera().transform.position = m_playerObject[0].CameraLocator.position;
							CameraManager.Instance.GetCurrentCamera().transform.rotation = m_playerObject[0].CameraLocator.rotation;
							CameraManager.Instance.SetNewTransform(m_playerObject[0].CameraLocator);
							CameraManager.Instance.UpdateFollow(m_playerObject[0].CameraLocator.gameObject);
						}
					}
					UpdatePlayersInRoom();
					FadeManager.Instance.FadeIn();
					m_femOnlineState = FEMOnlineState.InRoom;
					GameSystem.Instance.WasInOnlineRoom = true;
					m_onlineTrackName = string.Empty;
					GameSystem.Instance.WaitingForOnlineTrackSelection = true;
					m_onlineTrackScreen.ResetVoting();
					if (InHoldingState)
					{
						m_femOnlineState = FEMOnlineState.EnteringHoldingRoom;
					}
					else
					{
						m_femOnlineState = FEMOnlineState.InRoom;
					}
					m_holdingTimer = m_onlineTrackScreen.VotingTime + m_onlineTrackScreen.NextUpDisplayTime;
					m_searchingForPlayersTimer = m_onlineTrackScreen.SearchingForPlayersTimeout;
					m_chooseVotingTracks = false;
				}
			}
			else if (m_femOnlineState == FEMOnlineState.EnteringHoldingRoom)
			{
				if (!NetworkLogin.Instance.JoinedRoom())
				{
					QuitMenu.Instance.Kickout();
				}
				CameraManager.Instance.SetNewTransform(base.transform.root);
				m_playerObject[0].GetComponent<Rigidbody>().velocity = Vector3.zero;
				m_playerObject[0].transform.position = OnlineRoomLocators[0].transform.position;
				m_playerObject[0].transform.rotation = OnlineRoomLocators[0].transform.rotation;
				m_playerObject[0].gameObject.SetActive(value: true);
				if ((bool)m_playerObject[0].GetKartGeometry().KartShadow)
				{
					m_playerObject[0].GetKartGeometry().KartShadow.SetActive(value: false);
				}
				m_onlineTrackScreen.SetPlayerPosition(m_playerObject[0].transform);
				m_femOnlineState = FEMOnlineState.InHoldingRoom;
			}
			else if (m_femOnlineState == FEMOnlineState.InHoldingRoom)
			{
				m_playerObject[0].GetComponent<Rigidbody>().velocity = Vector3.zero;
				CameraManager.Instance.SetNewTransform(m_playerObject[0].CameraLocator);
				if (NetworkLogin.Instance.IsMasterPlayer() || !NetworkLogin.Instance.IsRoomInRace() || m_playerObject[0].MasterIsHappy)
				{
					FadeManager.Instance.FadeOut(0.5f);
					m_femOnlineState = FEMOnlineState.LeavingHoldingRoom;
				}
			}
			else if (m_femOnlineState == FEMOnlineState.LeavingHoldingRoom)
			{
				if (FadeManager.Instance.FinishedFading())
				{
					CameraManager.Instance.SetNewTransform(base.transform.root);
					m_femOnlineState = FEMOnlineState.ResettingHoldingRoom;
				}
			}
			else if (m_femOnlineState == FEMOnlineState.ResettingHoldingRoom)
			{
				RemoveNetworkPlayer(m_playerObject[0].OnlinePlayerIndex);
				InHoldingState = false;
				GameSystem.Instance.HumanSeatIndex = -1;
				m_playingPlayersInHolding.Clear();
				m_femOnlineState = FEMOnlineState.EnteringRoom;
				EnteringOnlineRoom();
				if (NetworkLogin.Instance.IsMasterPlayer())
				{
					PhotonNetwork.DestroyAll();
				}
			}
			else if (m_femOnlineState == FEMOnlineState.InRoom)
			{
				if ((bool)m_playerObject[0] && CameraManager.Instance.GetCurrentCamera().transform.parent != m_playerObject[0].CameraLocator)
				{
					CameraManager.Instance.GetCurrentCamera().transform.position = m_playerObject[0].CameraLocator.position;
					CameraManager.Instance.GetCurrentCamera().transform.rotation = m_playerObject[0].CameraLocator.rotation;
					CameraManager.Instance.SetNewTransform(m_playerObject[0].CameraLocator);
					CameraManager.Instance.UpdateFollow(m_playerObject[0].CameraLocator.gameObject);
				}
				if (FadeManager.Instance.FinishedFading() && (bool)SceneryRoot && SceneryRoot.activeSelf)
				{
					SceneryRoot.SetActive(value: false);
				}
				if (!NetworkLogin.Instance.JoinedRoom())
				{
					QuitMenu.Instance.Kickout();
				}
				UpdatePlayersInRoom();
				UpdateVoting();
				int actualRoomPlayerCount = NetworkLogin.Instance.GetActualRoomPlayerCount();
				if (GameSystem.Instance.HumanSeatIndex != -1 && actualRoomPlayerCount >= NumPlayersForOnlineGame)
				{
					m_onlineTrackScreen.EnableCannotFindPlayers(enable: false);
					m_holdingTimer -= Time.deltaTime;
				}
				else if (actualRoomPlayerCount == 1)
				{
					float num = m_onlineTrackScreen.VotingTime + m_onlineTrackScreen.NextUpDisplayTime;
					if (m_holdingTimer < num)
					{
						m_holdingTimer = num;
						m_searchingForPlayersTimer = m_onlineTrackScreen.SearchingForPlayersTimeout;
						m_chooseVotingTracks = false;
						GameSystem.Instance.LastSelectedOnlineTrack1 = -1;
						GameSystem.Instance.LastSelectedOnlineTrack2 = -1;
						GameSystem.Instance.WaitingForOnlineTrackSelection = true;
						m_onlineTrackScreen.ResetVoting();
						UnlockDoors();
					}
					else
					{
						float searchingForPlayersTimer = m_searchingForPlayersTimer;
						m_searchingForPlayersTimer -= GameTime.Instance.DeltaTime();
						if (searchingForPlayersTimer > 0f && m_searchingForPlayersTimer <= 0f)
						{
							m_onlineTrackScreen.EnableCannotFindPlayers(enable: true);
						}
						else if (searchingForPlayersTimer > -5f && m_searchingForPlayersTimer <= -5f)
						{
							m_searchingForPlayersTimer = m_onlineTrackScreen.SearchingForPlayersTimeout;
							m_onlineTrackScreen.EnableCannotFindPlayers(enable: false);
							int singlePlayerOnlineSearchCount = m_singlePlayerOnlineSearchCount;
							m_singlePlayerOnlineSearchCount++;
							if (singlePlayerOnlineSearchCount < 3 && m_singlePlayerOnlineSearchCount >= 3)
							{
								QuitMenu.Instance.OnlineSearchDropout();
							}
						}
					}
				}
				m_onlineTrackScreen.SetHoldingTime(m_holdingTimer, m_prevHoldingTimer);
				for (int k = 0; k < m_playerObject.Length; k++)
				{
					if (!(m_playerObject[k] != null))
					{
						continue;
					}
					int num2 = GameSystem.Instance.GetPositionChooser().FindSeatPosition(m_playerObject[k].OnlinePlayerIndex);
					if (num2 == -1)
					{
						if (!NetworkLogin.Instance.IsMasterPlayer())
						{
							UpdateFailSafe();
							continue;
						}
						num2 = GameSystem.Instance.GetPositionChooser().AllocateSeat(m_playerObject[k].OnlinePlayerIndex);
						m_playerObject[k].SeatIndex = num2;
						NetworkLogin.Instance.GetServer().SetPlayerConnection(m_playerObject[k].OnlinePlayerIndex, num2);
						if (k == 0 && !CameraManager.Instance.SetNewTransform(m_playerObject[0].CameraLocator))
						{
							CameraManager.Instance.UpdateFollow(m_playerObject[0].CameraLocator.gameObject);
							CameraManager.Instance.GetCurrentCamera().gameObject.SetActive(value: true);
						}
					}
					else if (m_playerObject[k].GetPlayerType() == Player.PlayerType.Human)
					{
						GameSystem.Instance.HumanSeatIndex = num2;
						GameSystem.Instance.GetPositionChooser().SetStoredOnlinePoints(num2, ProfileManager.Instance.CurrentOnlinePoints);
						if (!(MenuHintObj.transform.parent != m_playerObject[k].CameraLocator.transform))
						{
						}
					}
					Vector3 position = OnlineRoomLocators[num2].transform.position;
					m_playerObject[k].transform.position = position;
					m_playerObject[k].transform.rotation = OnlineRoomLocators[num2].transform.rotation;
					if (!m_playerAppears[k] && m_playerObject[k].GetDisplayName() != string.Empty && m_playerObject[k].GetPlayerType() != 0 && !m_playerObject[k].gameObject.activeSelf)
					{
						GameSystem.Instance.GetPuffParticles().DoPuff(m_playerObject[k].transform.position);
						m_playerAppears[k] = true;
						m_playerObject[k].gameObject.SetActive(value: true);
						if ((bool)m_playerObject[k].GetKartGeometry().KartShadow)
						{
							m_playerObject[k].GetKartGeometry().KartShadow.SetActive(value: false);
						}
					}
					if (k == 0)
					{
						m_onlineTrackScreen.SetPlayerPosition(m_playerObject[k].transform);
					}
				}
				if (m_holdingTimer <= 0f)
				{
					FadeManager.Instance.FadeOut();
					m_femOnlineState = FEMOnlineState.WaitForFade;
				}
				m_prevHoldingTimer = m_holdingTimer;
			}
			else if (m_femOnlineState == FEMOnlineState.WaitForFade)
			{
				if (FadeManager.Instance.FinishedFading())
				{
					for (int l = 0; l < m_playerObject.Length; l++)
					{
						if ((bool)m_playerObject[l])
						{
							GameSystem.Instance.GetPositionChooser().SetGridPosition(m_playerObject[l].OnlinePlayerIndex, m_playerObject[l].NewGridPosition);
						}
					}
					LoadLevel(GetOnlineTrackName());
				}
			}
			else if (m_femOnlineState == FEMOnlineState.WaitForFade_Back && FadeManager.Instance.FinishedFading())
			{
				if (NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom())
				{
					NetworkLogin.Instance.LeaveRoom();
					m_currentOption = FEMOption.None;
					m_femOnlineState = FEMOnlineState.None;
					OnlineRoom.SetActive(value: false);
				}
				RemoveFEMPlayers();
				GameEntry.Instance.LoadFEM();
			}
		}
		else if (m_currentOption == FEMOption.Race)
		{
			if (!m_gameIsLoading && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				if (FTUE.Instance.State == FTUE.FTUEState.ReadyForPractice)
				{
					PlayAudio(FEMAudioClip.LetsRaceClip);
					LoadLevel("STR_Track10_Env1");
				}
				else
				{
					PlayAudio(FEMAudioClip.OptionSelect);
					ResetOptionVisibility();
					SetupOption(FEMOption.QuickRaceType);
					m_currentOption = FEMOption.QuickRaceType;
				}
			}
		}
		else if (m_currentOption == FEMOption.QuickRaceType)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				int num3 = (ProfileManager.LOCKOUT_TIME_TRIAL ? 1 : 2);
				if (GetFlashIndex() < num3)
				{
					if (!ProfileManager.LOCKOUT_TIME_TRIAL)
					{
						GameSystem.Instance.EnableTimeTrialMode = GetFlashIndex() == 1;
					}
					if (!m_allowedToJoinNetworkGame && GetFlashIndex() == 1)
					{
						GameSystem.Instance.EnableTimeTrialMode = false;
					}
					else
					{
						PlayAudio(FEMAudioClip.OptionSelect);
						SetFlashIndex(0);
						ResetOptionVisibility();
						if (!GameSystem.Instance.EnableTimeTrialMode)
						{
							SetupOption(FEMOption.SpeedSelect);
							m_currentOption = FEMOption.SpeedSelect;
						}
						else
						{
							SetupOption(FEMOption.EnvSelect);
							m_currentOption = FEMOption.EnvSelect;
						}
					}
				}
				else if (GetFlashIndex() != 10)
				{
					ProfileManager.Instance.AlreadyPlayedFTUE = true;
					FTUE.Instance.State = FTUE.FTUEState.ReadyForPractice;
					PlayAudio(FEMAudioClip.LetsRaceClip);
					LoadLevel("STR_Track10_Env1");
				}
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
			{
				PlayAudio(FEMAudioClip.MenuBack);
				SetFlashIndex(0);
				ResetOptionVisibility();
				SetupOption(FEMOption.Race);
				m_currentOption = FEMOption.Race;
			}
			else if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
				{
					int num4 = m_menuTextOptions.Count - 1;
					if (ProfileManager.LOCKOUT_TIME_TRIAL)
					{
						num4--;
					}
					if (GetFlashIndex() < num4)
					{
						SetFlashIndex(GetFlashIndex() + 1);
						ResetOptionVisibility();
						PlayAudio(FEMAudioClip.OptionHighlight);
					}
				}
				else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up) && GetFlashIndex() > 0)
				{
					SetFlashIndex(GetFlashIndex() - 1);
					ResetOptionVisibility();
					PlayAudio(FEMAudioClip.OptionHighlight);
				}
			}
		}
		else if (m_currentOption == FEMOption.SpeedSelect)
		{
			if ((m_flashOptionIndex == 0 || ProfileManager.Instance.PlayedProCup) && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				ProfileManager.Instance.Speed = ((m_flashOptionIndex != 0) ? ProfileManager.PlayerSpeed.Turbo : ProfileManager.PlayerSpeed.Normal);
				PlayAudio(FEMAudioClip.OptionSelect);
				SetFlashIndex(0);
				ResetOptionVisibility();
				SetupOption(FEMOption.EnvSelect);
				m_currentOption = FEMOption.EnvSelect;
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
			{
				PlayAudio(FEMAudioClip.MenuBack);
				SetFlashIndex(0);
				ResetOptionVisibility();
				SetupOption(FEMOption.QuickRaceType);
				m_currentOption = FEMOption.QuickRaceType;
			}
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
				{
					if (ProfileManager.Instance.PlayedProCup)
					{
						int num5 = m_menuTextOptions.Count - 1;
						if (GetFlashIndex() < num5 - 1)
						{
							SetFlashIndex(GetFlashIndex() + 1);
							ResetOptionVisibility();
						}
					}
				}
				else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up) && GetFlashIndex() > 0)
				{
					SetFlashIndex(GetFlashIndex() - 1);
					ResetOptionVisibility();
				}
			}
		}
		else if (m_currentOption == FEMOption.EnvSelect)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				PlayAudio(FEMAudioClip.OptionSelect);
				m_scrollBarItem = 0;
				m_currentScrollItem = 0;
				string optionText = GetOptionText(GetFlashIndex());
				optionText = RemoveMenuOptionHighlight(optionText);
				int num6 = GetFlashIndex();
				if (GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(m_envList.GetEnvByIndex(num6).EnvIndex) <= 0)
				{
					num6++;
				}
				m_selectedEnv = m_envList.GetEnvByIndex(num6).EnvIndex;
				SelectTracks();
				SetArrowUp = false;
				SetArrowDown = false;
				SetFlashIndex(0);
				ResetOptionVisibility();
				SetupOption(FEMOption.TrackSelect);
				m_currentOption = FEMOption.TrackSelect;
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
			{
				PlayAudio(FEMAudioClip.MenuBack);
				SetFlashIndex(0);
				ResetOptionVisibility();
				if (!GameSystem.Instance.EnableTimeTrialMode && ProfileManager.Instance.PlayedProCup)
				{
					m_currentOption = FEMOption.SpeedSelect;
					SetupOption(FEMOption.SpeedSelect);
				}
				else
				{
					m_currentOption = FEMOption.QuickRaceType;
					SetupOption(FEMOption.QuickRaceType);
				}
			}
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
				{
					if (GetFlashIndex() > 0)
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						SetFlashIndex(GetFlashIndex() - 1);
						ResetOptionVisibility();
					}
				}
				else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down) && GetFlashIndex() < m_menuTextOptions.Count - 1 && m_menuTextOptions[GetFlashIndex() + 1].GetComponent<TextMesh>().text != string.Empty)
				{
					PlayAudio(FEMAudioClip.OptionHighlight);
					SetFlashIndex(GetFlashIndex() + 1);
					ResetOptionVisibility();
				}
			}
		}
		else if (m_currentOption == FEMOption.TrackSelect)
		{
			if (m_selectedArrowOnThisFrame)
			{
				m_selectedArrowOnThisFrame = false;
				return;
			}
			if (!m_gameIsLoading && (bool)GameEntry.Instance && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				if (m_currentScrollItem + GetFlashIndex() < m_trackItems.Count)
				{
					PlayAudio(FEMAudioClip.LetsRaceClip);
					string levelName = m_trackItems[m_currentScrollItem + GetFlashIndex()].Name;
					LoadLevel(levelName);
				}
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
			{
				PlayAudio(FEMAudioClip.MenuBack);
				SetFlashIndex(0);
				ResetOptionVisibility();
				m_currentOption = FEMOption.EnvSelect;
				SetupOption(FEMOption.EnvSelect);
			}
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
				{
					if (GetFlashIndex() < m_menuTextOptions.Count - 1 && m_menuTextOptions[GetFlashIndex() + 1].GetComponent<TextMesh>().text != string.Empty)
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						SetFlashIndex(GetFlashIndex() + 1);
						ResetOptionVisibility();
						if (GetFlashIndex() > m_menuTextOptions.Count - 1)
						{
							SetFlashIndex(m_menuTextOptions.Count - 1);
						}
					}
					else
					{
						int count = m_trackItems.Count;
						if (count > 3 && m_currentScrollItem + 3 < count)
						{
							m_currentScrollItem++;
							m_scrollBarItem++;
							SetupOption(m_currentOption);
							SetFlashIndex(GetFlashIndex());
							PlayAudio(FEMAudioClip.OptionHighlight);
						}
					}
				}
				else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
				{
					if (GetFlashIndex() > 0)
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						SetFlashIndex(GetFlashIndex() - 1);
						ResetOptionVisibility();
					}
					else if (m_currentScrollItem > m_minScrollItem)
					{
						m_currentScrollItem--;
						m_scrollBarItem--;
						SetupOption(m_currentOption);
						SetFlashIndex(GetFlashIndex());
						PlayAudio(FEMAudioClip.OptionHighlight);
					}
				}
			}
			else if (SetArrowDown)
			{
				SetArrowDown = false;
				int flashIndex = GetFlashIndex();
				int currentScrollItem = m_currentScrollItem;
				int scrollBarItem = m_scrollBarItem;
				bool flag2 = false;
				int num7 = m_currentScrollItem % 3;
				m_currentScrollItem = m_currentScrollItem - num7 + 2;
				m_scrollBarItem = m_currentScrollItem;
				SetFlashIndex(2);
				if (GetFlashIndex() < m_menuTextOptions.Count - 1 && m_menuTextOptions[m_flashOptionIndex + 1].GetComponent<TextMesh>().text != string.Empty)
				{
					PlayAudio(FEMAudioClip.OptionHighlight);
					ResetOptionVisibility();
					flag2 = true;
				}
				else
				{
					int count2 = m_trackItems.Count;
					if (count2 > 3 && m_currentScrollItem < count2 - 1)
					{
						flag2 = true;
						m_currentScrollItem++;
						m_scrollBarItem++;
						SetupOption(m_currentOption);
						PlayAudio(FEMAudioClip.OptionHighlight);
					}
				}
				if (!flag2)
				{
					m_currentScrollItem = currentScrollItem;
					m_scrollBarItem = scrollBarItem;
				}
				SetFlashIndex(flashIndex);
			}
			else if (SetArrowUp)
			{
				SetArrowUp = false;
				if (m_currentScrollItem > 0)
				{
					int flashIndex2 = GetFlashIndex();
					int num8 = m_currentScrollItem % 3;
					m_currentScrollItem = m_currentScrollItem - num8 - 2;
					m_scrollBarItem = m_currentScrollItem;
					SetFlashIndex(0);
					if (GetFlashIndex() > 0)
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						ResetOptionVisibility();
					}
					else if (m_currentScrollItem > m_minScrollItem)
					{
						m_currentScrollItem--;
						m_scrollBarItem--;
						SetupOption(m_currentOption);
						PlayAudio(FEMAudioClip.OptionHighlight);
					}
					SetFlashIndex(flashIndex2);
				}
			}
		}
		else if (m_currentOption == FEMOption.TV)
		{
			if (ProfileManager.Instance.FTUE == 0 && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				PlayAudio(FEMAudioClip.OptionSelect);
				int channel = (int)m_channel;
				channel = (channel + 1) % 4;
				if (channel == 2 && (ReplaySystem.Instance == null || !ReplaySystem.Instance.enabled))
				{
					channel = (channel + 1) % 4;
				}
				else if (channel == 0 && ProfileManager.Instance.FTUE == 0)
				{
					channel = (channel + 1) % 4;
				}
				SetTVChannel((TVChannel)channel);
			}
		}
		else if (m_currentOption == FEMOption.Settings)
		{
			if (!m_volumeOptions && !m_configureOption)
			{
				if (!m_keyboardEnabled && SettingsMenuPlane.GetState() == MenuPlane.TransitionState.Visible && !ConfigureDialogEnabled() && !ConfigurePressToConfirmRoot.activeSelf)
				{
					ProfileNameText.text = ProfileManager.Instance.GetPlayerName(0, useSwearFilter: false);
					if (ProfileNameText.text.Length > ProfileManager.MaxNameLength + 2)
					{
						ProfileNameText.text = ProfileNameText.text.Substring(0, ProfileManager.MaxNameLength);
						ProfileNameText.text += "..";
					}
				}
				if (!m_keyboardEnabled && !m_configureInputEnabled)
				{
					if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
					{
						if (GetFlashIndex() > 0 && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
						{
							PlayAudio(FEMAudioClip.OptionHighlight);
							SetFlashIndex(GetFlashIndex() - 1);
							if (GetFlashIndex() == 2)
							{
								SetFlashIndex(GetFlashIndex() - 1);
							}
							ResetOptionVisibility();
						}
						else if (m_flashOptionIndex < m_menuTextOptions.Count - 1 && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
						{
							PlayAudio(FEMAudioClip.OptionHighlight);
							SetFlashIndex(GetFlashIndex() + 1);
							if (GetFlashIndex() == 2)
							{
								SetFlashIndex(GetFlashIndex() + 1);
							}
							ResetOptionVisibility();
						}
					}
					if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl && InputRemapper.Instance.GetButtonUp(InputRemapper.ControllerMapping.Button_A) && GetFlashIndex() == 0)
					{
						PlayAudio(FEMAudioClip.OptionSelect);
						m_configureOption = true;
						SetFlashIndex(0);
						ProfileNameText.text = string.Empty;
						NameTitle.gameObject.SetActive(value: false);
						MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
						for (int m = 0; m < SettingsMenuPlane.Arrows.Length; m++)
						{
							currentMenu.Arrows[m].SetActive(value: false);
						}
						for (int n = 0; n < SettingsMenuPlane.ExtraText.Length; n++)
						{
							SettingsMenuPlane.ExtraText[n].gameObject.SetActive(value: false);
						}
					}
					else if (!InputRemapper.Instance.GetButtonUp(InputRemapper.ControllerMapping.Button_A) || GetFlashIndex() != 2)
					{
						if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A) && GetFlashIndex() == 3)
						{
							m_volumeOptions = true;
							MenuPlane currentMenu2 = GetCurrentMenu(m_currentOption);
							Vector3 localPosition = currentMenu2.SliderObject[0].GetComponent<Slider>().SliderLevel.transform.localPosition;
							currentMenu2.SliderObject[0].GetComponent<Slider>().SliderLevel.transform.localPosition = new Vector3(currentMenu2.SliderExtents * 2f * ProfileManager.Instance.MusicVolume - currentMenu2.SliderExtents, localPosition.y, localPosition.z);
							localPosition = currentMenu2.SliderObject[1].GetComponent<Slider>().SliderLevel.transform.localPosition;
							currentMenu2.SliderObject[1].GetComponent<Slider>().SliderLevel.transform.localPosition = new Vector3(currentMenu2.SliderExtents * 2f * ProfileManager.Instance.SFXVolume - currentMenu2.SliderExtents, localPosition.y, localPosition.z);
							PlayAudio(FEMAudioClip.OptionSelect);
							if (currentMenu2.SliderObject.Length > 0)
							{
								currentMenu2.SliderObject[0].gameObject.SetActive(value: true);
								currentMenu2.SliderObject[1].gameObject.SetActive(value: true);
							}
							ProfileNameText.text = string.Empty;
							NameTitle.gameObject.SetActive(value: false);
							for (int num9 = 0; num9 < SettingsMenuPlane.Arrows.Length; num9++)
							{
								currentMenu2.Arrows[num9].SetActive(value: false);
							}
							for (int num10 = 0; num10 < SettingsMenuPlane.ExtraText.Length; num10++)
							{
								SettingsMenuPlane.ExtraText[num10].gameObject.SetActive(value: false);
							}
							MusicVolumeText.gameObject.SetActive(value: true);
							SFXVolumeText.gameObject.SetActive(value: true);
							m_flashOptionIndex = 0;
						}
						else if (GetFlashIndex() == 4)
						{
							if (!ConfigurePressToConfirmRoot.activeSelf)
							{
								if (InputRemapper.Instance.GetButtonUp(InputRemapper.ControllerMapping.Button_A))
								{
									EnableControllerGroup(enable: false);
									PlayAudio(FEMAudioClip.OptionSelect);
									ConfigurePressToConfirmRoot.SetActive(value: true);
									for (int num11 = 0; num11 < SettingsMenuPlane.ExtraText.Length; num11++)
									{
										SettingsMenuPlane.ExtraText[num11].gameObject.SetActive(value: false);
									}
								}
							}
							else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_Y))
							{
								EnableControllerGroup(enable: true);
								PlayAudio(FEMAudioClip.OptionSelect);
								ProfileManager.Instance.ResetProfile();
								ProfileManager.Instance.SaveProfileData();
								ConfigurePressToConfirmRoot.SetActive(value: false);
								EnableOption(FEMOption.Settings, enable: true);
								EnableOption(FEMOption.Race, enable: true);
								EnableOption(FEMOption.Online, enable: false);
								EnableOption(FEMOption.PlayerConfig, enable: false);
								EnableOption(FEMOption.Championship, enable: false);
								FTUE.Instance.State = FTUE.FTUEState.ReadyForPractice;
							}
							else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
							{
								EnableControllerGroup(enable: true);
								PlayAudio(FEMAudioClip.MenuBack);
								m_configureOption = false;
								ConfigurePressToConfirmRoot.SetActive(value: false);
								SetupConfigText.gameObject.SetActive(value: false);
								ResetConfigText.gameObject.SetActive(value: false);
								SetFlashIndex(4);
							}
						}
						else if (GetFlashIndex() == 1)
						{
							if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
							{
								if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
								{
									if (GetFlashIndex() == 1)
									{
										PlayAudio(FEMAudioClip.OptionHighlight);
										ProfileManager.Instance.NumLaps--;
										if (ProfileManager.Instance.NumLaps < 1)
										{
											ProfileManager.Instance.NumLaps = 5;
										}
										SetOptionText(1, ProfileManager.Instance.NumLaps.ToString());
										m_customisationChange = true;
									}
								}
								else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right) && GetFlashIndex() == 1)
								{
									PlayAudio(FEMAudioClip.OptionHighlight);
									ProfileManager.Instance.NumLaps = Mathf.Clamp((ProfileManager.Instance.NumLaps + 1) % 6, 1, 5);
									SetOptionText(1, ProfileManager.Instance.NumLaps.ToString());
									m_customisationChange = true;
								}
							}
							else if (SetArrowUp)
							{
								SetArrowUp = false;
								PlayAudio(FEMAudioClip.OptionHighlight);
								ProfileManager.Instance.NumLaps--;
								if (ProfileManager.Instance.NumLaps < 1)
								{
									ProfileManager.Instance.NumLaps = 5;
								}
								SetOptionText(1, ProfileManager.Instance.NumLaps.ToString());
								m_customisationChange = true;
							}
							else if (SetArrowDown)
							{
								SetArrowDown = false;
								PlayAudio(FEMAudioClip.OptionHighlight);
								ProfileManager.Instance.NumLaps = Mathf.Clamp((ProfileManager.Instance.NumLaps + 1) % 6, 1, 5);
								SetOptionText(1, ProfileManager.Instance.NumLaps.ToString());
								m_customisationChange = true;
							}
						}
					}
				}
			}
			else if (m_configureOption)
			{
				if (GetFlashIndex() > 0 && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
				{
					PlayAudio(FEMAudioClip.OptionHighlight);
					SetFlashIndex(GetFlashIndex() - 1);
					if (GetFlashIndex() < 0)
					{
						SetFlashIndex(0);
					}
				}
				else if (GetFlashIndex() < 2 && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
				{
					PlayAudio(FEMAudioClip.OptionHighlight);
					SetFlashIndex(GetFlashIndex() + 1);
					if (GetFlashIndex() > 1)
					{
						SetFlashIndex(1);
					}
				}
				else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
				{
					PlayAudio(FEMAudioClip.MenuBack);
					m_configureOption = false;
					SetupConfigText.gameObject.SetActive(value: false);
					ResetConfigText.gameObject.SetActive(value: false);
					SetFlashIndex(0);
				}
				else if (InputRemapper.Instance.GetButtonUp(InputRemapper.ControllerMapping.Button_A))
				{
					if (GetFlashIndex() == 0)
					{
						InputRemapper.Instance.UpdateBlacklist(InputRemapper.JoypadInput.joystick_button_0);
						PlayAudio(FEMAudioClip.OptionSelect);
						SetupConfigText.gameObject.SetActive(value: false);
						ResetConfigText.gameObject.SetActive(value: false);
						m_configureOption = false;
						m_configureInputEnabled = true;
						m_femConfigControls.enabled = false;
						EnableControllerGroup(enable: false);
						ConfigureTitle.gameObject.SetActive(value: true);
						ConfigureInput.gameObject.SetActive(value: true);
						m_femConfigControls.enabled = true;
					}
					else
					{
						PlayAudio(FEMAudioClip.OptionSelect);
						InputRemapper.Instance.ResetAllInputs();
						m_configureOption = false;
						SetupConfigText.gameObject.SetActive(value: false);
						ResetConfigText.gameObject.SetActive(value: false);
						SetFlashIndex(1);
					}
				}
			}
			else if (m_volumeOptions)
			{
				if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
				{
					if (m_flashOptionIndex > 0 && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						SetFlashIndex(GetFlashIndex() - 1);
						if (GetFlashIndex() < 0)
						{
							SetFlashIndex(0);
						}
					}
					else if (m_flashOptionIndex < 2 && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						SetFlashIndex(GetFlashIndex() + 1);
						if (GetFlashIndex() > 1)
						{
							SetFlashIndex(1);
						}
					}
					else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						if (GetFlashIndex() == 0)
						{
							ProfileManager.Instance.MusicVolume -= 0.1f;
							ProfileManager.Instance.MusicVolume = Mathf.Clamp(ProfileManager.Instance.MusicVolume, 0f, 1f);
							m_volumeChange = true;
						}
						else
						{
							ProfileManager.Instance.SFXVolume -= 0.1f;
							ProfileManager.Instance.SFXVolume = Mathf.Clamp(ProfileManager.Instance.SFXVolume, 0f, 1f);
							m_volumeChange = true;
						}
					}
					else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						if (GetFlashIndex() == 0)
						{
							ProfileManager.Instance.MusicVolume += 0.1f;
							ProfileManager.Instance.MusicVolume = Mathf.Clamp(ProfileManager.Instance.MusicVolume, 0f, 1f);
						}
						else
						{
							ProfileManager.Instance.SFXVolume += 0.1f;
							ProfileManager.Instance.SFXVolume = Mathf.Clamp(ProfileManager.Instance.SFXVolume, 0f, 1f);
						}
					}
					MenuPlane currentMenu3 = GetCurrentMenu(m_currentOption);
					Vector3 localPosition2 = currentMenu3.SliderObject[0].GetComponent<Slider>().SliderLevel.transform.localPosition;
					currentMenu3.SliderObject[0].GetComponent<Slider>().SliderLevel.transform.localPosition = new Vector3(currentMenu3.SliderExtents * 2f * ProfileManager.Instance.MusicVolume - currentMenu3.SliderExtents, localPosition2.y, localPosition2.z);
					localPosition2 = currentMenu3.SliderObject[1].GetComponent<Slider>().SliderLevel.transform.localPosition;
					currentMenu3.SliderObject[1].GetComponent<Slider>().SliderLevel.transform.localPosition = new Vector3(currentMenu3.SliderExtents * 2f * ProfileManager.Instance.SFXVolume - currentMenu3.SliderExtents, localPosition2.y, localPosition2.z);
				}
				else if ((bool)GrabbedVolumeHandle)
				{
					if (InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.Button_A))
					{
						Transform controllerSpot = Instance.GetControllerSpot();
						Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
						Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
						if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("VolumeDetection")))
						{
							MenuPlane currentMenu4 = GetCurrentMenu(m_currentOption);
							Vector3 localPosition3 = GrabbedVolumeHandle.localPosition;
							GrabbedVolumeHandle.position = hitInfo.point;
							Vector3 localPosition4 = GrabbedVolumeHandle.localPosition;
							localPosition4.x = Mathf.Clamp(localPosition4.x, 0f - currentMenu4.SliderExtents, currentMenu4.SliderExtents);
							localPosition4.y = localPosition3.y;
							localPosition4.z = localPosition3.z;
							GrabbedVolumeHandle.localPosition = localPosition4;
							if (GetFlashIndex() == 0)
							{
								float musicVolume = (localPosition4.x + currentMenu4.SliderExtents) / (currentMenu4.SliderExtents * 2f);
								ProfileManager.Instance.MusicVolume = musicVolume;
								ProfileManager.Instance.MusicVolume = Mathf.Clamp(ProfileManager.Instance.MusicVolume, 0f, 1f);
							}
							else if (GetFlashIndex() == 1)
							{
								float sFXVolume = (localPosition4.x + currentMenu4.SliderExtents) / (currentMenu4.SliderExtents * 2f);
								ProfileManager.Instance.SFXVolume = sFXVolume;
								ProfileManager.Instance.SFXVolume = Mathf.Clamp(ProfileManager.Instance.SFXVolume, 0f, 1f);
							}
						}
						else
						{
							GrabbedVolumeHandle = null;
							SetFlashIndex(-1);
							m_volumeChange = true;
						}
					}
					else
					{
						GrabbedVolumeHandle = null;
						SetFlashIndex(-1);
						m_volumeChange = true;
					}
				}
				if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
				{
					if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						if (GetFlashIndex() == 0)
						{
							ProfileManager.Instance.MusicVolume -= 0.1f;
							ProfileManager.Instance.MusicVolume = Mathf.Clamp(ProfileManager.Instance.MusicVolume, 0f, 1f);
							m_volumeChange = true;
						}
						else
						{
							ProfileManager.Instance.SFXVolume -= 0.1f;
							ProfileManager.Instance.SFXVolume = Mathf.Clamp(ProfileManager.Instance.SFXVolume, 0f, 1f);
							m_volumeChange = true;
						}
					}
					else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						if (GetFlashIndex() == 0)
						{
							ProfileManager.Instance.MusicVolume += 0.1f;
							ProfileManager.Instance.MusicVolume = Mathf.Clamp(ProfileManager.Instance.MusicVolume, 0f, 1f);
						}
						else
						{
							ProfileManager.Instance.SFXVolume += 0.1f;
							ProfileManager.Instance.SFXVolume = Mathf.Clamp(ProfileManager.Instance.SFXVolume, 0f, 1f);
						}
					}
				}
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
				{
					PlayAudio(FEMAudioClip.MenuBack);
					m_volumeOptions = false;
					if (SettingsMenuPlane.SliderObject.Length > 0)
					{
						SettingsMenuPlane.SliderObject[0].gameObject.SetActive(value: false);
						SettingsMenuPlane.SliderObject[1].gameObject.SetActive(value: false);
					}
					MusicVolumeText.gameObject.SetActive(value: false);
					SFXVolumeText.gameObject.SetActive(value: false);
					m_customisationChange = true;
					SetFlashIndex(3);
				}
			}
			else if (m_configureOption)
			{
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
				{
					PlayAudio(FEMAudioClip.MenuBack);
					m_configureOption = false;
					SetupConfigText.gameObject.SetActive(value: false);
					ResetConfigText.gameObject.SetActive(value: false);
					SetFlashIndex(1);
				}
				else if (InputRemapper.Instance.GetButtonUp(InputRemapper.ControllerMapping.Button_A))
				{
					if (GetFlashIndex() == 0)
					{
						PlayAudio(FEMAudioClip.OptionSelect);
						SetupConfigText.gameObject.SetActive(value: false);
						ResetConfigText.gameObject.SetActive(value: false);
						m_configureOption = false;
						m_configureInputEnabled = true;
						EnableControllerGroup(enable: false);
						ConfigureTitle.gameObject.SetActive(value: true);
						ConfigureInput.gameObject.SetActive(value: true);
					}
					else
					{
						PlayAudio(FEMAudioClip.OptionSelect);
						ProfileManager.Instance.SaveProfileData();
						m_configureOption = false;
						SetupConfigText.gameObject.SetActive(value: false);
						ResetConfigText.gameObject.SetActive(value: false);
						SetFlashIndex(1);
					}
				}
			}
		}
		else if (m_currentOption == FEMOption.Championship)
		{
			if (!GetCurrentMenu(m_currentOption).LockedQuad.activeSelf && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				PlayAudio(FEMAudioClip.OptionSelect);
				SetFlashIndex(1);
				ResetOptionVisibility();
				SetupOption(FEMOption.ChampTypeSelect);
				m_currentOption = FEMOption.ChampTypeSelect;
			}
		}
		else if (m_currentOption == FEMOption.ChampTypeSelect)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
			{
				PlayAudio(FEMAudioClip.MenuBack);
				SetFlashIndex(1);
				ResetOptionVisibility();
				m_currentOption = FEMOption.Championship;
				SetupOption(FEMOption.Championship);
			}
			else
			{
				if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
				{
					if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
					{
						if (m_flashOptionIndex < m_menuTextOptions.Count - 1 && m_menuTextOptions[m_flashOptionIndex + 1].GetComponent<TextMesh>().text != string.Empty)
						{
							PlayAudio(FEMAudioClip.OptionHighlight);
							SetFlashIndex(GetFlashIndex() + 1);
							ResetOptionVisibility();
							if (m_flashOptionIndex > m_menuTextOptions.Count - 1)
							{
								m_flashOptionIndex = m_menuTextOptions.Count - 1;
							}
						}
					}
					else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up) && GetFlashIndex() > 0)
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						SetFlashIndex(GetFlashIndex() - 1);
						ResetOptionVisibility();
					}
				}
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
				{
					ProfileManager.Instance.CurrentChampType = (ChampionshipMode.TrophyChampionshipType)m_flashOptionIndex;
					if (ProfileManager.Instance.CurrentChampType == ChampionshipMode.TrophyChampionshipType.Random)
					{
						ChampionshipMode.TrophyGroupingType trophyType = ChampionshipMode.TrophyGroupingType.MaxUserLevels;
						string levelName2 = GameSystem.Instance.GetChampionshipMode().StartChampionshipMode(trophyType);
						LoadLevel(levelName2);
						PlayAudio(FEMAudioClip.LetsRaceClip);
					}
					else
					{
						PlayAudio(FEMAudioClip.OptionSelect);
						SetFlashIndex(1);
						ResetOptionVisibility();
						SetupOption(FEMOption.TrophySelect);
						m_currentOption = FEMOption.TrophySelect;
					}
				}
			}
		}
		else if (m_currentOption == FEMOption.TrophySelect)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
			{
				PlayAudio(FEMAudioClip.MenuBack);
				SetFlashIndex(1);
				ResetOptionVisibility();
				m_currentOption = FEMOption.ChampTypeSelect;
				SetupOption(FEMOption.ChampTypeSelect);
			}
			else
			{
				if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
				{
					if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
					{
						if (m_flashOptionIndex < m_menuTextOptions.Count - 1 && m_menuTextOptions[m_flashOptionIndex + 1].GetComponent<TextMesh>().text != string.Empty && ProfileManager.Instance.WonChampMode((ChampionshipMode.TrophyGroupingType)(m_flashOptionIndex + 1)))
						{
							PlayAudio(FEMAudioClip.OptionHighlight);
							SetFlashIndex(GetFlashIndex() + 1);
							ResetOptionVisibility();
							if (m_flashOptionIndex > m_menuTextOptions.Count - 1)
							{
								m_flashOptionIndex = m_menuTextOptions.Count - 1;
							}
						}
					}
					else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up) && GetFlashIndex() > 0)
					{
						PlayAudio(FEMAudioClip.OptionHighlight);
						SetFlashIndex(GetFlashIndex() - 1);
						ResetOptionVisibility();
					}
				}
				if (!m_gameIsLoading && !GetCurrentMenu(m_currentOption).LockedQuad.activeSelf && (m_flashOptionIndex == 0 || (m_flashOptionIndex != -1 && m_flashOptionIndex < 4 && ProfileManager.Instance.WonChampMode((ChampionshipMode.TrophyGroupingType)m_flashOptionIndex))) && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
				{
					m_selectedChampGrouping = (ChampionshipMode.TrophyGroupingType)(m_flashOptionIndex + 1);
					PlayAudio(FEMAudioClip.OptionSelect);
					SetFlashIndex(0);
					m_currentOption = FEMOption.Championship_SpeedSelect;
					SetupOption(FEMOption.Championship_SpeedSelect);
				}
			}
		}
		else if (m_currentOption == FEMOption.Championship_SpeedSelect)
		{
			if ((m_flashOptionIndex == 0 || ProfileManager.Instance.PlayedProCup) && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				ProfileManager.Instance.Speed = ((m_flashOptionIndex != 0) ? ProfileManager.PlayerSpeed.Turbo : ProfileManager.PlayerSpeed.Normal);
				string levelName3 = GameSystem.Instance.GetChampionshipMode().StartChampionshipMode(m_selectedChampGrouping);
				LoadLevel(levelName3);
				PlayAudio(FEMAudioClip.LetsRaceClip);
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
			{
				PlayAudio(FEMAudioClip.MenuBack);
				SetFlashIndex(0);
				ResetOptionVisibility();
				SetupOption(FEMOption.TrophySelect);
				m_currentOption = FEMOption.TrophySelect;
			}
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
				{
					if (ProfileManager.Instance.PlayedProCup)
					{
						int num12 = m_menuTextOptions.Count - 1;
						if (GetFlashIndex() < num12 - 1)
						{
							SetFlashIndex(GetFlashIndex() + 1);
							ResetOptionVisibility();
						}
					}
				}
				else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up) && GetFlashIndex() > 0)
				{
					SetFlashIndex(GetFlashIndex() - 1);
					ResetOptionVisibility();
				}
			}
		}
		else if (m_currentOption == FEMOption.PlayerConfig && !GetCurrentMenu(m_currentOption).LockedQuad.activeSelf && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			PlayAudio(FEMAudioClip.OptionSelect);
			m_extraCustomiseRoot.SetActive(value: true);
			m_currentOption = FEMOption.Extra_Customisation_Enter;
			FadeManager.Instance.FadeOut();
		}
		if (!m_volumeOptions && !m_configureOption)
		{
			if (m_keyboardEnabled || m_configureInputEnabled)
			{
				if (!KeyBoardObj.gameObject.activeInHierarchy)
				{
					if (m_configureInputEnabled)
					{
						if (m_femConfigControls.enabled)
						{
							ConfigureInput.text = m_femConfigControls.GetControlText();
						}
						else
						{
							if (!InputRemapper.Instance.GetAnyInput() && !ConfigurePressToConfirmRoot.activeSelf)
							{
								ConfigurePressToConfirmRoot.SetActive(value: true);
								ConfigureTitle.gameObject.SetActive(value: false);
								ConfigureInput.gameObject.SetActive(value: false);
							}
							if (ConfigurePressToConfirmRoot.activeSelf)
							{
								if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_Y))
								{
									PlayAudio(FEMAudioClip.OptionSelect);
									InputRemapper.Instance.StoreNewInputs();
									m_ftueConfigureInput = false;
									m_customisationChange = true;
									ConfigurePressToConfirmRoot.SetActive(value: false);
									RemoveConfigureInput();
								}
								else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
								{
									PlayAudio(FEMAudioClip.OptionSelect);
									m_ftueConfigureInput = false;
									m_customisationChange = true;
									ConfigurePressToConfirmRoot.SetActive(value: false);
									RemoveConfigureInput();
								}
							}
						}
					}
					if (SpeedTitle.activeSelf)
					{
						for (int num13 = 1; num13 < SettingsMenuOptions.Length; num13++)
						{
							SettingsMenuOptions[num13].SetActive(value: false);
						}
						if (m_configureInputEnabled)
						{
							ProfileNameText.text = string.Empty;
							NameTitle.gameObject.SetActive(value: false);
							ConfigureTitle.gameObject.SetActive(value: true);
							ConfigureInput.gameObject.SetActive(value: true);
						}
						SpeedTitle.SetActive(value: false);
						for (int num14 = 0; num14 < SettingsMenuPlane.Arrows.Length; num14++)
						{
							SettingsMenuPlane.Arrows[num14].SetActive(value: false);
						}
						for (int num15 = 0; num15 < SettingsMenuPlane.ExtraText.Length; num15++)
						{
							SettingsMenuPlane.ExtraText[num15].gameObject.SetActive(value: false);
						}
						SetFlashIndex(-1);
						ResetOptionVisibility();
						for (int num16 = 0; num16 < SettingsMenuPlane.MenuText.Length; num16++)
						{
							SettingsMenuPlane.MenuText[num16].gameObject.SetActive(value: false);
						}
						if (m_keyboardEnabled)
						{
							KeyBoardObj.EnableKeyboard(ref KeyBoardText, enable: true);
							m_customisationChange = true;
							EnableControllerGroup(enable: true, 1);
						}
					}
				}
				if (m_keyboardEnabled)
				{
					if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_B))
					{
						PlayAudio(FEMAudioClip.MenuBack);
						m_customisationChange = true;
						RemoveActiveKeyboard();
					}
					else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_Y))
					{
						PlayAudio(FEMAudioClip.MenuBack);
						m_customisationChange = true;
						m_storeNewProfileName = true;
						RemoveActiveKeyboard();
					}
				}
			}
			else if (!SpeedTitle.activeSelf && !ConfigurePressToConfirmRoot.activeSelf)
			{
				for (int num17 = 1; num17 < SettingsMenuOptions.Length; num17++)
				{
					if (InputRemapper.Instance.GetControlSystem() != InputRemapper.ControlSystem.GearVRController || SettingsMenuOptions[num17].gameObject != SettingsMenuPlane.OptionHeadingText[0].gameObject)
					{
						SettingsMenuOptions[num17].SetActive(value: true);
					}
				}
				SpeedTitle.SetActive(value: true);
				ProfileNameText.text = ProfileManager.Instance.GetPlayerName(0, useSwearFilter: false);
				if (ProfileNameText.text.Length > ProfileManager.MaxNameLength + 2)
				{
					ProfileNameText.text = ProfileNameText.text.Substring(0, ProfileManager.MaxNameLength);
					ProfileNameText.text += "..";
				}
				NameTitle.gameObject.SetActive(value: true);
				if (ConfigureTitle.gameObject.activeSelf)
				{
					ConfigureTitle.gameObject.SetActive(value: false);
					ConfigureInput.gameObject.SetActive(value: false);
					ConfigurePressToConfirmRoot.gameObject.SetActive(value: false);
				}
				for (int num18 = 1; num18 < SettingsMenuPlane.MenuText.Length; num18++)
				{
					if (InputRemapper.Instance.GetControlSystem() != InputRemapper.ControlSystem.GearVRController || SettingsMenuPlane.MenuText[num18].gameObject != SettingsMenuPlane.OptionHeadingText[0].gameObject)
					{
						SettingsMenuPlane.MenuText[num18].gameObject.SetActive(value: true);
					}
				}
				SettingsMenuPlane.MenuText[0].gameObject.SetActive(value: false);
				for (int num19 = 0; num19 < SettingsMenuPlane.Arrows.Length; num19++)
				{
					SettingsMenuPlane.Arrows[num19].SetActive(value: true);
				}
				for (int num20 = 0; num20 < SettingsMenuPlane.ExtraText.Length; num20++)
				{
					if (InputRemapper.Instance.GetControlSystem() != InputRemapper.ControlSystem.GearVRController || SettingsMenuPlane.ExtraText[num20].gameObject != SettingsMenuPlane.OptionHeadingText[0].gameObject)
					{
						SettingsMenuPlane.ExtraText[num20].gameObject.SetActive(value: true);
					}
				}
				KeyBoardObj.EnableKeyboard(ref KeyBoardText, enable: false);
				EnableControllerGroup(enable: true);
			}
		}
		UpdateHighlightOption();
	}

	private void UpdateVoting()
	{
		int actualRoomPlayerCount = NetworkLogin.Instance.GetActualRoomPlayerCount();
		if (actualRoomPlayerCount >= NumPlayersForOnlineGame && NetworkLogin.Instance.IsMasterPlayer() && !m_chooseVotingTracks)
		{
			m_chooseVotingTracks = true;
			ChooseVotingTracks();
		}
	}

	private void UpdateFailSafe()
	{
		m_failSafeTimer += GameTime.Instance.DeltaTime();
		if (m_failSafeTimer > 20f)
		{
			m_failSafeTimer = 0f;
			FadeManager.Instance.FadeOut();
			m_femOnlineState = FEMOnlineState.WaitForFade_Back;
		}
	}

	private void CheckForName()
	{
		if (m_readyToSetName)
		{
			string text = ((!NetworkLogin.Instance) ? string.Empty : NetworkLogin.Instance.GetGoogleDisplayName());
			if (text != string.Empty)
			{
				ProfileManager.Instance.SetPlayerName(0, text);
				m_readyToSetName = false;
			}
		}
	}

	private void ChooseVotingTracks()
	{
		int num;
		TrackList.TrackData trackByIndex;
		do
		{
			num = UnityEngine.Random.Range(0, GameSystem.Instance.GetTrackListing().GetTotalTracks());
			trackByIndex = GameSystem.Instance.GetTrackListing().GetTrackByIndex(num);
		}
		while (trackByIndex.HideTrack || !trackByIndex.AllowedOnline || num == GameSystem.Instance.LastSelectedOnlineTrack1 || num == GameSystem.Instance.LastSelectedOnlineTrack2 || trackByIndex.BombTrack);
		int num2;
		TrackList.TrackData trackByIndex2;
		do
		{
			num2 = UnityEngine.Random.Range(0, GameSystem.Instance.GetTrackListing().GetTotalTracks());
			trackByIndex2 = GameSystem.Instance.GetTrackListing().GetTrackByIndex(num2);
		}
		while (trackByIndex2.HideTrack || !trackByIndex2.AllowedOnline || num2 == GameSystem.Instance.LastSelectedOnlineTrack1 || num2 == GameSystem.Instance.LastSelectedOnlineTrack2 || trackByIndex2.BombTrack || num2 == num);
		GameSystem.Instance.LastSelectedOnlineTrack1 = num;
		GameSystem.Instance.LastSelectedOnlineTrack2 = num2;
		GameSystem.Instance.WaitingForOnlineTrackSelection = false;
	}

	public void SetFlashIndex(int index)
	{
		if (CurrentOption != FEMOption.TrophySelect || index <= 0 || index == -1 || index >= 4 || ProfileManager.Instance.WonChampMode((ChampionshipMode.TrophyGroupingType)index))
		{
			m_flashOptionIndex = index;
			m_menuSelectionScaleTimer = 0f;
			m_numPulsesDone = 0;
			m_numPulsesRequired = 1;
			m_menuSelectionPulseAngle = 0f;
		}
	}

	private int GetFlashIndex()
	{
		return m_flashOptionIndex;
	}

	private void UpdateHighlightOption()
	{
		if (m_menuSelectionScaleTimer > 0f)
		{
			m_menuSelectionScaleTimer -= GameTime.Instance.DeltaTime();
			if (m_menuSelectionScaleTimer <= 0f)
			{
				m_menuSelectionScaleTimer = 0f;
			}
		}
		else
		{
			m_menuSelectionPulseAngle += GameTime.Instance.DeltaTime() * 8f;
			if (m_menuSelectionPulseAngle >= (float)Math.PI)
			{
				m_menuSelectionPulseAngle = 0f;
				m_numPulsesDone++;
				if (m_numPulsesDone >= m_numPulsesRequired)
				{
					m_numPulsesDone = 0;
					m_numPulsesRequired = 2;
					m_menuSelectionScaleTimer = 1.5f;
				}
			}
		}
		if (m_flashOptionIndex >= 0 && m_menuTextOptions.Count > 0)
		{
			if (m_volumeOptions)
			{
				if (m_flashOptionIndex == 0)
				{
					GameObject textObject = MusicVolumeText.gameObject;
					GameObject textObject2 = SFXVolumeText.gameObject;
					SetTextHighlight(ref textObject, setScale: true, setColour: true);
					SetTextHighlight(ref textObject2, setScale: false, setColour: false);
					textObject.SetActive(value: true);
					textObject2.SetActive(value: true);
				}
				else if (m_flashOptionIndex == 1)
				{
					GameObject textObject3 = MusicVolumeText.gameObject;
					GameObject textObject4 = SFXVolumeText.gameObject;
					SetTextHighlight(ref textObject4, setScale: true, setColour: true);
					SetTextHighlight(ref textObject3, setScale: false, setColour: false);
					textObject3.SetActive(value: true);
					textObject4.SetActive(value: true);
				}
				return;
			}
			if (m_configureOption)
			{
				if (m_flashOptionIndex == 0)
				{
					GameObject textObject5 = SetupConfigText.gameObject;
					GameObject textObject6 = ResetConfigText.gameObject;
					SetTextHighlight(ref textObject5, setScale: true, setColour: true);
					SetTextHighlight(ref textObject6, setScale: false, setColour: false);
					textObject5.SetActive(value: true);
					textObject6.SetActive(value: true);
				}
				else
				{
					GameObject textObject7 = SetupConfigText.gameObject;
					GameObject textObject8 = ResetConfigText.gameObject;
					SetTextHighlight(ref textObject8, setScale: true, setColour: true);
					SetTextHighlight(ref textObject7, setScale: false, setColour: false);
					textObject7.SetActive(value: true);
					textObject8.SetActive(value: true);
				}
				return;
			}
		}
		else if (m_flashOptionIndex == -1 && m_volumeOptions)
		{
			GameObject textObject9 = MusicVolumeText.gameObject;
			GameObject textObject10 = SFXVolumeText.gameObject;
			SetTextHighlight(ref textObject9, setScale: false, setColour: false);
			SetTextHighlight(ref textObject10, setScale: false, setColour: false);
		}
		if (m_menuTextOptions.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < m_menuTextOptions.Count; i++)
		{
			if (i == m_flashOptionIndex)
			{
				GameObject textObject11 = m_menuTextOptions[i];
				if (CurrentOption == FEMOption.QuickRaceType && m_flashOptionIndex == 1 && !NetworkLogin.Instance.ConnectedToMaster())
				{
					SetTextHighlight(ref textObject11, setScale: true, setColour: false, 0f, ghosted: true);
				}
				else if ((CurrentOption == FEMOption.SpeedSelect || CurrentOption == FEMOption.Championship_SpeedSelect) && i == 1 && !ProfileManager.Instance.PlayedProCup)
				{
					SetTextHighlight(ref textObject11, setScale: false, setColour: false);
				}
				else
				{
					SetTextHighlight(ref textObject11, setScale: true, setColour: true);
				}
				continue;
			}
			GameObject textObject12 = m_menuTextOptions[i];
			if (m_flashOptionIndex == -1)
			{
				SetTextHighlight(ref textObject12, setScale: false, setColour: true, NonInteractiveTextScale);
				continue;
			}
			if (CurrentOption == FEMOption.TrophySelect)
			{
				SetTextHighlight(ref textObject12, setScale: false, setColour: false, 0f, i != 0 && !ProfileManager.Instance.WonChampMode((ChampionshipMode.TrophyGroupingType)i));
			}
			else if (CurrentOption == FEMOption.SpeedSelect || CurrentOption == FEMOption.Championship_SpeedSelect)
			{
				SetTextHighlight(ref textObject12, setScale: false, setColour: false, 0f, i != 0 && !ProfileManager.Instance.PlayedProCup);
			}
			if (CurrentOption == FEMOption.QuickRaceType && i == 1 && !NetworkLogin.Instance.ConnectedToMaster())
			{
				SetTextHighlight(ref textObject12, setScale: false, setColour: false, 0f, ghosted: true);
			}
			else
			{
				SetTextHighlight(ref textObject12, setScale: false, setColour: false);
			}
		}
		if (m_flashOptionIndex == -1)
		{
			UpdateJoinText();
		}
		else
		{
			UpdateOptionHeadings();
		}
	}

	private void UpdateJoinText()
	{
		MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
		if (currentMenu != null && currentMenu.JoinGroup != null)
		{
			GameObject textObject = currentMenu.JoinGroup.gameObject;
			SetTextHighlight(ref textObject, setScale: true, setColour: true);
		}
	}

	private void UpdateOptionHeadings()
	{
		MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
		if (!(currentMenu != null) || currentMenu.OptionHeadingText == null || currentMenu.OptionHeadingText.Length <= 0)
		{
			return;
		}
		for (int i = 0; i < currentMenu.OptionHeadingText.Length; i++)
		{
			if (!(currentMenu.OptionHeadingText[i] != null))
			{
				continue;
			}
			if (m_flashOptionIndex == i)
			{
				GameObject textObject = currentMenu.OptionHeadingText[i].gameObject;
				SetTextHighlight(ref textObject, setScale: true, setColour: true);
				if (currentMenu.Arrows != null && m_flashOptionIndex == 1)
				{
					for (int j = 0; j < currentMenu.Arrows.Length; j++)
					{
						GameObject textObject2 = currentMenu.Arrows[j].gameObject;
						SetTextHighlight(ref textObject2, setScale: true, setColour: true);
					}
				}
				continue;
			}
			GameObject textObject3 = currentMenu.OptionHeadingText[i].gameObject;
			SetTextHighlight(ref textObject3, setScale: false, setColour: false);
			if (currentMenu.Arrows != null && m_flashOptionIndex != 1)
			{
				for (int k = 0; k < currentMenu.Arrows.Length; k++)
				{
					GameObject textObject4 = currentMenu.Arrows[k].gameObject;
					SetTextHighlight(ref textObject4, setScale: false, setColour: false);
				}
			}
		}
	}

	private void SetTextHighlight(ref GameObject textObject, bool setScale, bool setColour, float textScaleOverride = 0f, bool ghosted = false)
	{
		if (setScale)
		{
			float num = ((textScaleOverride == 0f) ? HighlightedTextScale : textScaleOverride);
			float num2 = Mathf.Sin(m_menuSelectionPulseAngle) * ExtraPulseScale;
			textObject.transform.localScale = new Vector3(num + num2, num + num2, num + num2);
		}
		else
		{
			float num3 = ((textScaleOverride == 0f) ? DefaultTextScale : textScaleOverride);
			textObject.transform.localScale = new Vector3(num3, num3, num3);
		}
		if ((bool)textObject.GetComponent<Renderer>())
		{
			if (setColour)
			{
				textObject.GetComponent<Renderer>().material.SetColor("_Color", new UnityEngine.Color(49f / 51f, 49f / 51f, 49f / 51f));
			}
			else if (ghosted)
			{
				textObject.GetComponent<Renderer>().material.SetColor("_Color", DisabledColour);
			}
			else
			{
				textObject.GetComponent<Renderer>().material.SetColor("_Color", new UnityEngine.Color(0.7058824f, 0.7058824f, 0.7058824f));
			}
		}
	}

	private MenuPlane GetCurrentMenu(FEMOption option)
	{
		switch (option)
		{
		case FEMOption.Online:
			return MenuOnline;
		case FEMOption.Race:
			return MenuTrophy;
		case FEMOption.Settings:
			return SettingsMenuPlane;
		case FEMOption.PlayerConfig:
			return MenuPlayerConfig;
		case FEMOption.Championship:
		case FEMOption.TrophySelect:
			return MenuChampionship;
		default:
			return MenuTrophy;
		}
	}

	private void SelectTracks()
	{
		m_trackItems.Clear();
		GameSystem.Instance.GetTrackListing().GetTracksByEnv(ref m_trackItems, m_selectedEnv);
	}

	private void TurnOffAllMenus()
	{
		if (MenuTrophy.gameObject.activeSelf && MenuTrophy.GetState() != MenuPlane.TransitionState.Shrink && (bool)MenuTrophy.LockedQuad)
		{
			MenuTrophy.LockedQuad.gameObject.SetActive(value: false);
			MenuTrophy.ShrinkDown();
		}
		if (MenuOnline.gameObject.activeSelf && MenuOnline.GetState() != MenuPlane.TransitionState.Shrink && (bool)MenuOnline.LockedQuad)
		{
			MenuOnline.LockedQuad.gameObject.SetActive(value: false);
			MenuOnline.ShrinkDown();
		}
		if (MenuPlayerConfig.gameObject.activeSelf && MenuPlayerConfig.GetState() != MenuPlane.TransitionState.Shrink && (bool)MenuPlayerConfig.LockedQuad)
		{
			MenuPlayerConfig.LockedQuad.gameObject.SetActive(value: false);
			MenuPlayerConfig.ShrinkDown();
		}
		if (SettingsMenuPlane.gameObject.activeSelf && SettingsMenuPlane.GetState() != MenuPlane.TransitionState.Shrink && (bool)SettingsMenuPlane.LockedQuad)
		{
			SettingsMenuPlane.LockedQuad.gameObject.SetActive(value: false);
			SettingsMenuPlane.ShrinkDown();
		}
		if (MenuChampionship.gameObject.activeSelf && MenuChampionship.GetState() != MenuPlane.TransitionState.Shrink && (bool)SettingsMenuPlane.LockedQuad)
		{
			MenuChampionship.LockedQuad.gameObject.SetActive(value: false);
			MenuChampionship.ShrinkDown();
		}
	}

	private void LoadLevel(string levelName)
	{
		m_levelLoadTime = Time.time;
		m_levelToLoad = levelName;
	}

	private void WaitForSafeLevelLoading()
	{
		if (Time.time > m_levelLoadTime + 0.6f)
		{
			TVAudioSource.Stop();
			int index = 0;
			TrackList.TrackData trackByString = GameSystem.Instance.GetTrackListing().GetTrackByString(m_levelToLoad, ref index);
			RemoveFEMPlayers();
			ProfileManager.Instance.SaveProfileData();
			GameSystem.Instance.SetTrackToLoad(trackByString);
			GameEntry.Instance.LoadGame();
			m_gameIsLoading = true;
			m_levelToLoad = string.Empty;
		}
	}

	private void CheckForSave()
	{
		if ((m_currentOption == FEMOption.Settings && m_customisationChange) || m_volumeChange)
		{
			ProfileManager.Instance.SaveProfileData();
			m_customisationChange = false;
			m_volumeChange = false;
		}
	}

	private void RemoveActiveKeyboard()
	{
		if (m_keyboardEnabled)
		{
			if (m_storeNewProfileName && KeyBoardText.text.Length > 0)
			{
				ProfileManager.Instance.SetPlayerName(0, KeyBoardText.text);
				m_storeNewProfileName = false;
			}
			m_keyboardEnabled = false;
			SetFlashIndex(0);
			EnableControllerGroup(enable: true);
		}
	}

	private void RemoveConfigureInput()
	{
		m_configureInputEnabled = false;
		SetFlashIndex(0);
		EnableControllerGroup(enable: true);
	}

	private void UpdateOptions()
	{
		if (!CameraManager.Instance)
		{
			return;
		}
		if (m_currentOption == FEMOption.Extra_Customisation_Enter || m_currentOption == FEMOption.Extra_Customisation_Wait || m_currentOption == FEMOption.Extra_Customisation_Exit)
		{
			UpdateExtraCustomisation();
			return;
		}
		if (m_currentOption != FEMOption.Settings || ConfigureDialogEnabled() || ConfigurePressToConfirmRoot.activeSelf)
		{
			ProfileNameText.text = string.Empty;
		}
		if (m_currentOption != FEMOption.None && m_currentOption != FEMOption.Settings && m_flashOptionIndex >= 0 && m_flashOptionIndex != m_avoidArrowIndex)
		{
			for (int i = 0; i < m_menuTextOptions.Count; i++)
			{
				TextMesh component = m_menuTextOptions[i].GetComponent<TextMesh>();
				if ((bool)component)
				{
					if (i == m_flashOptionIndex)
					{
						component.text = AddMenuOptionHighlight(component.text);
					}
					else
					{
						component.text = RemoveMenuOptionHighlight(component.text);
					}
					continue;
				}
				Text component2 = m_menuTextOptions[i].GetComponent<Text>();
				if (i == m_flashOptionIndex)
				{
					component2.text = AddMenuOptionHighlight(component2.text);
				}
				else
				{
					component2.text = RemoveMenuOptionHighlight(component2.text);
				}
			}
		}
		UpdateScrollBar();
		UpdateColliders();
		if (m_currentOption == FEMOption.OnlineWait)
		{
			return;
		}
		Vector3 direction = base.transform.TransformDirection(CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward);
		Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, direction);
		if (!m_gameIsLoading && Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("FrontendScenery")))
		{
			if ((OnlineObject_Hold.enabled && hitInfo.collider == OnlineObject_Hold) || (OnlineObject.enabled && hitInfo.collider == OnlineObject))
			{
				UpdateLookAtObject(hitInfo.collider, FEMOption.Online);
				return;
			}
			if ((SettingsObject_Hold.enabled && hitInfo.collider == SettingsObject_Hold) || (SettingsObject.enabled && hitInfo.collider == SettingsObject))
			{
				UpdateLookAtObject(hitInfo.collider, FEMOption.Settings);
				return;
			}
			if ((RaceObject_Hold.enabled && hitInfo.collider == RaceObject_Hold) || (RaceObject.enabled && hitInfo.collider == RaceObject))
			{
				if (m_currentOption != FEMOption.TrackSelect && m_currentOption != FEMOption.EnvSelect && m_currentOption != FEMOption.QuickRaceType && m_currentOption != FEMOption.SpeedSelect)
				{
					UpdateLookAtObject(hitInfo.collider, FEMOption.Race);
				}
				return;
			}
			if ((ReplayObject_Hold.enabled && hitInfo.collider == ReplayObject_Hold) || (ReplayObject.enabled && hitInfo.collider == ReplayObject))
			{
				UpdateLookAtObject(hitInfo.collider, FEMOption.TV);
				return;
			}
			if ((PlayerConfigObject_Hold.enabled && hitInfo.collider == PlayerConfigObject_Hold) || (PlayerConfigObject.enabled && hitInfo.collider == PlayerConfigObject))
			{
				UpdateLookAtObject(hitInfo.collider, FEMOption.PlayerConfig);
				return;
			}
			if ((ChampionshipObject_Hold.enabled && hitInfo.collider == ChampionshipObject_Hold) || (ChampionshipObject.enabled && hitInfo.collider == ChampionshipObject))
			{
				if (m_currentOption != FEMOption.TrophySelect && m_currentOption != FEMOption.Championship_SpeedSelect && m_currentOption != FEMOption.ChampTypeSelect)
				{
					UpdateLookAtObject(hitInfo.collider, FEMOption.Championship);
				}
				return;
			}
		}
		else
		{
			CheckForSave();
			RemoveActiveKeyboard();
		}
		m_lookTime = Time.time;
		m_currentOption = FEMOption.None;
		TurnOffAllMenus();
	}

	private string AddMenuOptionHighlight(string text)
	{
		return text;
	}

	private string RemoveMenuOptionHighlight(string text)
	{
		return text;
	}

	private void UpdateExtraCustomisation()
	{
		switch (m_currentOption)
		{
		case FEMOption.Extra_Customisation_Enter:
			if (FadeManager.Instance.FinishedFading())
			{
				if ((bool)SceneryRoot && SceneryRoot.activeSelf)
				{
					SceneryRoot.SetActive(value: false);
				}
				m_extraCustomiseRoot.GetComponent<ExtraCustomisation>().EnableCustomisation(enable: true);
				m_currentOption = FEMOption.Extra_Customisation_Wait;
			}
			break;
		case FEMOption.Extra_Customisation_Exit:
			if (FadeManager.Instance.FinishedFading())
			{
				if ((bool)SceneryRoot && !SceneryRoot.activeSelf)
				{
					m_extraCustomiseRoot.SetActive(value: false);
					SceneryRoot.SetActive(value: true);
				}
				ExtraCustomisation.Instance.FinishedWithCustomisation();
				ProfileManager.Instance.SaveProfileData();
				m_extraCustomiseRoot.GetComponent<ExtraCustomisation>().EnableCustomisation(enable: false);
				CameraManager.Instance.GetCurrentCamera().transform.rotation = CameraLocator.transform.rotation;
				CameraManager.Instance.SetNewTransform(CameraLocator.transform);
				CameraManager.Instance.UpdateFollow(CameraLocator.transform.gameObject);
				FadeManager.Instance.FadeIn();
				m_currentOption = FEMOption.PlayerConfig;
			}
			break;
		}
	}

	private void UpdateScrollBar()
	{
		MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
		if (m_currentOption == FEMOption.TrackSelect && GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(m_selectedEnv) > 3)
		{
			if (!currentMenu.ScrollBar.activeSelf)
			{
				currentMenu.ScrollBar.SetActive(value: true);
			}
			int num = GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(m_selectedEnv) - m_minScrollItem - 1;
			float num2 = currentMenu.MaxScrollLimit * 2f / (float)num;
			int num3 = m_scrollBarItem + GetFlashIndex();
			if (num3 >= m_trackItems.Count)
			{
				num3 = m_trackItems.Count - 1;
			}
			float num4 = num2 * (float)num3 - currentMenu.MaxScrollLimit;
			Vector3 localPosition = currentMenu.ScrollBar.transform.GetChild(0).transform.localPosition;
			localPosition.y = 0f - num4;
			currentMenu.ScrollBar.transform.GetChild(0).transform.localPosition = localPosition;
		}
		else if ((bool)currentMenu.ScrollBar && currentMenu.ScrollBar.activeSelf)
		{
			currentMenu.ScrollBar.SetActive(value: false);
		}
	}

	private void UpdateColliders()
	{
		OnlineObject.gameObject.SetActive(m_currentOption != FEMOption.Online);
		OnlineObject_Hold.gameObject.SetActive(m_currentOption == FEMOption.Online);
		SettingsObject.gameObject.SetActive(m_currentOption != FEMOption.Settings);
		SettingsObject_Hold.gameObject.SetActive(m_currentOption == FEMOption.Settings);
		RaceObject.gameObject.SetActive(m_currentOption != FEMOption.Race && m_currentOption != FEMOption.EnvSelect && m_currentOption != FEMOption.TrackSelect && m_currentOption != FEMOption.QuickRaceType && m_currentOption != FEMOption.SpeedSelect);
		RaceObject_Hold.gameObject.SetActive(m_currentOption == FEMOption.Race || m_currentOption == FEMOption.EnvSelect || m_currentOption == FEMOption.TrackSelect || m_currentOption == FEMOption.QuickRaceType || m_currentOption == FEMOption.SpeedSelect);
		ReplayObject.gameObject.SetActive(m_currentOption != FEMOption.TV);
		ReplayObject_Hold.gameObject.SetActive(m_currentOption == FEMOption.TV);
		PlayerConfigObject.gameObject.SetActive(m_currentOption != FEMOption.PlayerConfig);
		PlayerConfigObject_Hold.gameObject.SetActive(m_currentOption == FEMOption.PlayerConfig);
		ChampionshipObject.gameObject.SetActive(m_currentOption != FEMOption.Championship && m_currentOption != FEMOption.Championship_SpeedSelect);
		ChampionshipObject_Hold.gameObject.SetActive(m_currentOption == FEMOption.Championship || m_currentOption == FEMOption.Championship_SpeedSelect);
	}

	private void UpdateLookAtObject(Collider collider, FEMOption option)
	{
		MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
		if (m_currentOption != option)
		{
			CheckForSave();
			RemoveActiveKeyboard();
			RemoveConfigureInput();
			m_volumeOptions = false;
			m_configureOption = false;
			m_lookTime = Time.time;
			currentMenu.ShrinkDown();
			SFXVolumeText.gameObject.SetActive(value: false);
			MusicVolumeText.gameObject.SetActive(value: false);
			SetupConfigText.gameObject.SetActive(value: false);
			ResetConfigText.gameObject.SetActive(value: false);
			m_currentOption = option;
		}
		else
		{
			if (currentMenu.gameObject.activeInHierarchy || !(Time.time - m_lookTime >= TimeForMenu))
			{
				return;
			}
			RemoveActiveKeyboard();
			RemoveConfigureInput();
			m_volumeOptions = false;
			m_configureOption = false;
			SetFlashIndex(-1);
			m_currentScrollItem = m_minScrollItem;
			m_scrollBarItem = 0;
			ResetOptionVisibility();
			SFXVolumeText.gameObject.SetActive(value: false);
			MusicVolumeText.gameObject.SetActive(value: false);
			SetupConfigText.gameObject.SetActive(value: false);
			ResetConfigText.gameObject.SetActive(value: false);
			m_menuTextOptions.Clear();
			if (option == FEMOption.Settings)
			{
				SettingsMenuPlane.GrowUp();
				SettingsMenuPlane.transform.position = OptionLocators[(int)option].transform.position;
				SettingsMenuPlane.transform.rotation = OptionLocators[(int)option].transform.rotation;
				for (int i = 0; i < SettingsMenuOptions.Length; i++)
				{
					m_menuTextOptions.Add(SettingsMenuOptions[i].gameObject);
				}
			}
			else
			{
				currentMenu.GrowUp();
				currentMenu.transform.position = OptionLocators[(int)option].transform.position;
				currentMenu.transform.rotation = OptionLocators[(int)option].transform.rotation;
				for (int j = 0; j < currentMenu.MenuText.Length; j++)
				{
					m_menuTextOptions.Add(currentMenu.MenuText[j].gameObject);
				}
			}
			if (currentMenu.SliderObject.Length > 0)
			{
				currentMenu.SliderObject[0].gameObject.SetActive(value: false);
				currentMenu.SliderObject[1].gameObject.SetActive(value: false);
			}
			if (option == FEMOption.Championship)
			{
				GetCurrentMenu(option).LockedQuad.SetActive(value: false);
			}
			SetupOption(option);
			if (option != FEMOption.None && option != FEMOption.TV)
			{
				PlayAudio(FEMAudioClip.MenuPopUp);
			}
		}
	}

	public void EnableFullGame(bool enableFTUE)
	{
		EnableOption(FEMOption.PlayerConfig, enable: true);
		EnableOption(FEMOption.Online, enable: true);
		EnableOption(FEMOption.Settings, enable: true);
		EnableOption(FEMOption.Championship, enable: true);
		MenuTrophy.LockedQuad.gameObject.SetActive(value: false);
		MenuOnline.LockedQuad.gameObject.SetActive(value: false);
		MenuPlayerConfig.LockedQuad.gameObject.SetActive(value: false);
		SettingsMenuPlane.LockedQuad.gameObject.SetActive(value: false);
		MenuChampionship.LockedQuad.gameObject.SetActive(value: false);
		EnableOption(FEMOption.Race, enable: true);
		string text = ((!(NetworkLogin.Instance == null)) ? NetworkLogin.Instance.GetGoogleDisplayName() : string.Empty);
		if (text != string.Empty)
		{
			ProfileManager.Instance.SetPlayerName(0, text);
		}
		else
		{
			ProfileManager.Instance.SetPlayerName(0, "Player");
		}
		ProfileManager.Instance.SaveProfileData();
	}

	private void SetupOption(FEMOption option)
	{
		ResetOptionVisibility();
		EnableJoinGroup(enable: false);
		EnableControllerGroup(enable: true);
		for (int i = 0; i < m_menuTextOptions.Count; i++)
		{
			SetOptionText(i, string.Empty);
		}
		switch (option)
		{
		case FEMOption.Results:
		case FEMOption.Extra_Customisation_Enter:
		case FEMOption.Extra_Customisation_Wait:
		case FEMOption.Extra_Customisation_Exit:
			break;
		case FEMOption.Online:
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_OnlineMultiplayer", convertToUpperCase: true));
			if (GetCurrentMenu(option).LockedQuad.activeSelf)
			{
				EnableControllerGroup(enable: false);
				SetFlashIndex(-1);
				break;
			}
			if (!m_allowedToJoinNetworkGame)
			{
				SetOptionText(2, "< " + GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_NotConnected", convertToUpperCase: true) + " >");
			}
			EnableJoinGroup(m_allowedToJoinNetworkGame);
			m_avoidArrowIndex = 2;
			break;
		case FEMOption.OnlineWait:
			SetFlashIndex(-1);
			break;
		case FEMOption.Settings:
			SetOptionText(1, ProfileManager.Instance.NumLaps.ToString());
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				SetOptionText(2, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_SetupControls", convertToUpperCase: true));
				SettingsTextOffset.localPosition = Vector3.zero;
			}
			else
			{
				SettingsTextOffset.localPosition = new Vector3(0f, 0.39f, 0f);
			}
			SetOptionText(3, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_SetupAudio", convertToUpperCase: true));
			SetOptionText(4, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ResetProfile", convertToUpperCase: true));
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				SetFlashIndex(0);
			}
			else
			{
				SetFlashIndex(1);
			}
			m_avoidArrowIndex = 1;
			ConfigurePressToConfirmRoot.SetActive(value: false);
			break;
		case FEMOption.Race:
			EnableControllerGroup(enable: false);
			if (ProfileManager.Instance.FTUE == 1)
			{
				SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_TestDrive", convertToUpperCase: true));
			}
			else
			{
				SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_QuickRace", convertToUpperCase: true));
			}
			EnableJoinGroup(enable: true);
			SetFlashIndex(-1);
			m_avoidArrowIndex = 2;
			break;
		case FEMOption.SpeedSelect:
		case FEMOption.Championship_SpeedSelect:
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ChooseSpeed", convertToUpperCase: true));
			SetOptionText(0, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_DefaultMode", convertToUpperCase: true));
			SetOptionText(1, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_TurboMode", convertToUpperCase: true));
			SetFlashIndex((ProfileManager.Instance.PlayedProCup && ProfileManager.Instance.Speed != 0) ? 1 : 0);
			break;
		case FEMOption.Championship:
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Champ", convertToUpperCase: true));
			EnableControllerGroup(enable: false);
			EnableJoinGroup(enable: true);
			SetFlashIndex(-1);
			break;
		case FEMOption.ChampTypeSelect:
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ChampType_Select", convertToUpperCase: true));
			SetOptionText(0, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ChampType_1", convertToUpperCase: true));
			SetOptionText(1, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ChampType_2", convertToUpperCase: true));
			SetOptionText(2, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ChampType_Random", convertToUpperCase: true));
			SetOptionText(3, string.Empty);
			SetFlashIndex(0);
			break;
		case FEMOption.TrophySelect:
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_SelectACup", convertToUpperCase: true));
			SetOptionText(0, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_RookieCup", convertToUpperCase: true));
			SetOptionText(1, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_AmateurCup", convertToUpperCase: true));
			SetOptionText(2, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ProCup", convertToUpperCase: true));
			SetOptionText(3, string.Empty);
			SetFlashIndex(0);
			break;
		case FEMOption.TV:
			TurnOffAllMenus();
			break;
		case FEMOption.QuickRaceType:
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_RaceType", convertToUpperCase: true));
			EnableControllerGroup(enable: true);
			SetOptionText(0, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_SingleRace", convertToUpperCase: true));
			if (ProfileManager.LOCKOUT_TIME_TRIAL)
			{
				SetOptionText(1, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Tutorial", convertToUpperCase: true));
			}
			else
			{
				SetOptionText(1, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_TimeTrial", convertToUpperCase: true));
				SetOptionText(2, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Tutorial", convertToUpperCase: true));
			}
			SetFlashIndex(0);
			break;
		case FEMOption.EnvSelect:
		{
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Environment", convertToUpperCase: true));
			int num2 = 0;
			for (int k = 0; k < m_envList.GetTotalEnvironments(); k++)
			{
				if (GameSystem.Instance.GetTrackListing().GetNumTracksByEnv(m_envList.GetEnvByIndex(k).EnvIndex) > 0)
				{
					SetOptionText(num2++, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(m_envList.GetEnvByIndex(k).EnvName, convertToUpperCase: true));
				}
			}
			break;
		}
		case FEMOption.TrackSelect:
		{
			SetTitleText(GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ChooseTrack", convertToUpperCase: true));
			int num = 0;
			for (int j = m_currentScrollItem; j < m_trackItems.Count; j++)
			{
				TrackList.TrackData trackData = m_trackItems[j];
				if (num <= m_menuTextOptions.Count - 1)
				{
					SetOptionText(num++, GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(trackData.Name, convertToUpperCase: true));
				}
			}
			break;
		}
		case FEMOption.PlayerConfig:
			EnableJoinGroup(enable: true);
			break;
		}
	}

	private void SetOptionText(int index, string text, bool resizable = false)
	{
		if (m_menuTextOptions != null && m_menuTextOptions.Count != 0 && m_menuTextOptions.Count > index)
		{
			TextMesh component = m_menuTextOptions[index].GetComponent<TextMesh>();
			if (!component)
			{
				Text component2 = m_menuTextOptions[index].GetComponent<Text>();
				component2.text = text;
			}
			else
			{
				component.text = text;
			}
		}
	}

	private void SetTitleText(string text)
	{
		MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
		if ((bool)currentMenu && currentMenu.Title != null)
		{
			currentMenu.Title.text = text;
		}
	}

	private void EnableJoinGroup(bool enable)
	{
		MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
		if ((bool)currentMenu)
		{
			currentMenu.EnableJoinGroup(enable);
		}
	}

	private void EnableControllerGroup(bool enable, int index = 0)
	{
		MenuPlane currentMenu = GetCurrentMenu(m_currentOption);
		if ((bool)currentMenu)
		{
			currentMenu.EnableControllerGroup(enable, index);
		}
	}

	private string GetOptionText(int index)
	{
		if (m_menuTextOptions.Count == 0 || m_menuTextOptions.Count < index)
		{
			return string.Empty;
		}
		TextMesh component = m_menuTextOptions[index].GetComponent<TextMesh>();
		if (!component)
		{
			Text component2 = m_menuTextOptions[index].GetComponent<Text>();
			return component2.text;
		}
		return component.text;
	}

	private void ResetOptionVisibility()
	{
		m_avoidArrowIndex = -1;
		for (int i = 0; i < m_menuTextOptions.Count; i++)
		{
			m_menuTextOptions[i].SetActive(value: true);
		}
	}

	private void UpdateTVChannels()
	{
	}

	private void UpdateMenuHint()
	{
		if ((bool)MenuHintObj)
		{
			if (m_currentOption != FEMOption.None && m_currentOption != FEMOption.OnlineWait && m_currentOption != FEMOption.TV)
			{
				MenuHintObj.SetHighlight(set: true);
			}
			else
			{
				MenuHintObj.SetHighlight(set: false);
			}
			MenuHintObj.Saving(GameTime.Instance.CurrentTime() < m_savingTimer);
		}
	}

	private void UpdateNameTags()
	{
		if (m_playerObject == null)
		{
			return;
		}
		for (int i = 0; i < m_playerObject.Length; i++)
		{
			if (!m_playerObject[i])
			{
				continue;
			}
			Vector3 vector = m_playerObject[i].transform.position - CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.position;
			Vector3 forward = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward;
			float sqrMagnitude = vector.sqrMagnitude;
			if (sqrMagnitude < 6400f)
			{
				float num = Vector3.Angle(forward, vector.normalized);
				if (num < 40f)
				{
					m_playerObject[i].NameBadge.SetState(NameBadge.NameState.Grow);
					continue;
				}
			}
			m_playerObject[i].NameBadge.SetState(NameBadge.NameState.Shrink);
		}
	}

	private void UpdateRosettes()
	{
		if (ChampModeRosettes.Length <= 0)
		{
			return;
		}
		for (int i = 0; i < ChampModeRosettes.Length; i++)
		{
			if (ChampModeRosettes[i].activeSelf != ProfileManager.Instance.WonChampMode((ChampionshipMode.TrophyGroupingType)(i + 1)))
			{
				ChampModeRosettes[i].SetActive(ProfileManager.Instance.WonChampMode((ChampionshipMode.TrophyGroupingType)(i + 1)));
			}
		}
	}

	private void UpdateAttractMode()
	{
		if ((bool)GameEntry.Instance && !m_gameIsLoading && GameTime.Instance.PrevTime() < m_attractTimer && GameTime.Instance.CurrentTime() > m_attractTimer)
		{
			GameSystem.Instance.EnableAttractMode = true;
			PlayAudio(FEMAudioClip.LetsRaceClip);
			LoadLevel("STR_Track2_Env3");
		}
	}

	public float HorizontalUsed()
	{
		return 0f;
	}
}
public class FTUE : UnityEngine.MonoBehaviour
{
	public enum FTUEState
	{
		None,
		WaitForPrompt,
		InitialPrompt,
		Welcome,
		ReadyForPractice,
		Practice1,
		Practice2,
		Practice2a,
		Practice3,
		Practice4,
		End_Practice,
		FinishFTUE
	}

	[SerializeField]
	private float TimeBeforeInitialPrompt = 5f;

	[SerializeField]
	private float MinTimeBeforeNextPrompt = 2f;

	[SerializeField]
	private float MaxTimeBeforeNextPrompt = 5f;

	[SerializeField]
	private AudioClip[] PromptAudio;

	[SerializeField]
	private AudioClip WelcomeFullGameAudio;

	[SerializeField]
	private AudioClip EndPractice2Audio_1;

	[SerializeField]
	private AudioClip EndPractice2Audio_2;

	[SerializeField]
	public AudioClip StartYourEngines;

	[SerializeField]
	private AudioClip Practice1_Audio;

	[SerializeField]
	private AudioClip Practice2_Audio;

	[SerializeField]
	private AudioClip Practice2a_Audio;

	[SerializeField]
	private AudioClip Practice3_Audio;

	[SerializeField]
	private AudioClip Practice4_Audio;

	[SerializeField]
	public AudioClip[] Weapons_Audio;

	[SerializeField]
	public AudioClip Practice_Success;

	[SerializeField]
	public AudioClip Practice_Fail;

	[SerializeField]
	private Transform FTUETargets;

	private Vector3 m_headAngle = Vector3.zero;

	private float m_stateTimer;

	private int m_index;

	private bool m_playingAudioPart1;

	private bool m_playingAudioPart2;

	private bool m_waitingForEndOfPractice = true;

	private FTUEState m_ftueState;

	public static FTUE Instance;

	private List<Player> m_playerList;

	private Player m_mainPlayer;

	private bool m_waitForReadyToStart;

	private FTUETargets m_ftueTargets;

	public FTUEState State
	{
		get
		{
			return m_ftueState;
		}
		set
		{
			m_ftueState = value;
		}
	}

	public void FinishedGame()
	{
		EnableFTUE();
		if (m_ftueState == FTUEState.None)
		{
			return;
		}
		m_playerList = null;
		m_mainPlayer = null;
		m_waitForReadyToStart = false;
		if (m_ftueState == FTUEState.End_Practice)
		{
			if (ProfileManager.Instance.AlreadyPlayedFTUE)
			{
				m_ftueState = FTUEState.None;
				ProfileManager.Instance.FTUE = 0;
				return;
			}
			FEMManager.Instance.EnableOption(FEMManager.FEMOption.Settings, enable: true);
			FEMManager.Instance.EnableOption(FEMManager.FEMOption.Online, enable: false);
			FEMManager.Instance.EnableOption(FEMManager.FEMOption.PlayerConfig, enable: false);
			FEMManager.Instance.EnableOption(FEMManager.FEMOption.Race, enable: false);
			FEMManager.Instance.EnableOption(FEMManager.FEMOption.Championship, enable: false);
			MoveOntoNextState();
		}
	}

	public bool WaitingToStart()
	{
		return m_waitForReadyToStart;
	}

	public bool IsPlayingAudio()
	{
		return (bool)FEMManager.Instance && FEMManager.Instance.TVAudioSource.isPlaying;
	}

	private void PlayAudio(AudioClip clip)
	{
		if ((bool)FEMManager.Instance)
		{
			FEMManager.Instance.TVAudioSource.clip = clip;
			FEMManager.Instance.TVAudioSource.Play();
			FEMManager.Instance.SubtitleUI.SetText(clip, FEMManager.Instance.TVAudioSource);
		}
	}

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
	}

	private void OnEnable()
	{
		StartFTUESequence();
	}

	public void StartFTUESequence()
	{
		EnableFTUE();
		if ((bool)ProfileManager.Instance && ProfileManager.Instance.FTUE == 0)
		{
			if (ProfileManager.Instance.Version == 0f)
			{
				ProfileManager.Instance.FTUE = 1;
				ProfileManager.Instance.Version = float.Parse(ProfileManager.FTUE_VERSION_NO);
				SetFTUEState(FTUEState.WaitForPrompt);
			}
			else
			{
				SetFTUEState(FTUEState.None);
			}
		}
		else
		{
			SetFTUEState(FTUEState.WaitForPrompt);
		}
		if (GameEntry.Instance == null)
		{
			SetFTUEState(FTUEState.ReadyForPractice);
		}
	}

	private void EnableFTUE()
	{
		m_headAngle = Vector3.zero;
		if ((bool)ProfileManager.Instance && ProfileManager.Instance.FTUE == 1 && CameraManager.Instance != null && (bool)FEMManager.Instance)
		{
			GameCamera cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.Credits);
			cameraByType.transform.parent = FEMManager.Instance.FTUERoot.transform;
			cameraByType.transform.localPosition = new Vector3(0f, 0f, -1f);
			cameraByType.transform.localRotation = Quaternion.identity;
			CameraManager.Instance.EnableRenderTargetCamera(CameraManager.CameraType.Credits, enableCam: true, enableListener: false);
		}
	}

	public void MoveOntoNextState()
	{
		SetFTUEState(m_ftueState + 1);
	}

	private void Start()
	{
		CheckOptionsToEnable();
	}

	private void CheckOptionsToEnable()
	{
		switch (m_ftueState)
		{
		case FTUEState.WaitForPrompt:
			if ((bool)FEMManager.Instance)
			{
				FEMManager.Instance.EnableOption(FEMManager.FEMOption.Settings, enable: true);
				FEMManager.Instance.EnableOption(FEMManager.FEMOption.Online, enable: false);
				FEMManager.Instance.EnableOption(FEMManager.FEMOption.PlayerConfig, enable: false);
				FEMManager.Instance.EnableOption(FEMManager.FEMOption.Championship, enable: false);
				FEMManager.Instance.EnableOption(FEMManager.FEMOption.Race, enable: false);
			}
			break;
		}
	}

	private void Update()
	{
		if (m_ftueState == FTUEState.None)
		{
			return;
		}
		if (m_waitForReadyToStart && FadeManager.Instance.FinishedFading())
		{
			ContinueWithStart();
		}
		if (!(FEMManager.Instance == null) && (!GameEntry.Instance || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend))
		{
			if (FEMManager.Instance.TVAudioSource.isPlaying)
			{
				UpdateHeadBob();
			}
			else
			{
				m_headAngle = Vector3.zero;
			}
			if (m_ftueState != 0)
			{
				SetHeadRotation();
				UpdateFTUEState();
			}
		}
	}

	private void UpdateHeadBob()
	{
		m_headAngle.x += UnityEngine.Random.Range(2f, 40f) * GameTime.Instance.DeltaTime();
		m_headAngle.y += UnityEngine.Random.Range(2f, 40f) * GameTime.Instance.DeltaTime();
		m_headAngle.z += UnityEngine.Random.Range(2f, 40f) * GameTime.Instance.DeltaTime();
		m_headAngle.x %= (float)Math.PI * 2f;
		m_headAngle.y %= (float)Math.PI * 2f;
		m_headAngle.z %= (float)Math.PI * 2f;
	}

	private void SetHeadRotation()
	{
		Quaternion quaternion = Quaternion.AngleAxis(Mathf.Sin(m_headAngle.y) * 5f, Vector3.up);
		Quaternion quaternion2 = Quaternion.AngleAxis(Mathf.Sin(m_headAngle.x) * 5f, Vector3.right);
		Quaternion quaternion3 = Quaternion.AngleAxis(Mathf.Sin(m_headAngle.z) * 5f, Vector3.forward);
		Quaternion quaternion4 = Quaternion.LookRotation(-Vector3.forward);
		quaternion4 = quaternion4 * quaternion * quaternion2 * quaternion3;
		FEMManager.Instance.HelmetTransform.rotation = Quaternion.Slerp(FEMManager.Instance.HelmetTransform.rotation, quaternion4, 4f * GameTime.Instance.DeltaTime());
	}

	private void SetFTUEState(FTUEState state)
	{
		m_ftueState = state;
		m_stateTimer = Time.time;
		switch (m_ftueState)
		{
		case FTUEState.None:
			if ((bool)FEMManager.Instance)
			{
				FEMManager.Instance.CreditsRoot.gameObject.SetActive(value: true);
				FEMManager.Instance.CreditsRoot.transform.GetChild(0).transform.GetComponent<Credits>().ResetCamera();
				FEMManager.Instance.FTUERoot.gameObject.SetActive(value: false);
			}
			break;
		case FTUEState.InitialPrompt:
			m_stateTimer = 0.01f;
			m_index = 0;
			break;
		case FTUEState.Practice2:
			m_mainPlayer.PlayAudio(Practice2_Audio);
			break;
		case FTUEState.Practice2a:
			m_mainPlayer.PlayAudio(Practice2a_Audio);
			break;
		}
		CheckOptionsToEnable();
	}

	private void UpdateFTUEState()
	{
		if (!FadeManager.Instance.FinishedFading())
		{
			return;
		}
		switch (m_ftueState)
		{
		case FTUEState.None:
			break;
		case FTUEState.WaitForPrompt:
			if (FadeManager.Instance.FinishedFading() && (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend) && Time.time > m_stateTimer + TimeBeforeInitialPrompt)
			{
				MoveOntoNextState();
			}
			break;
		case FTUEState.InitialPrompt:
			if ((bool)FEMManager.Instance && FEMManager.Instance.CurrentOption == FEMManager.FEMOption.TV)
			{
				MoveOntoNextState();
				break;
			}
			if (m_stateTimer > 0f && Time.time > m_stateTimer)
			{
				PlayAudio(PromptAudio[m_index]);
				m_index = (m_index + 1) % PromptAudio.Length;
				m_stateTimer = 0f;
			}
			if ((bool)FEMManager.Instance && !FEMManager.Instance.TVAudioSource.isPlaying && m_stateTimer == 0f)
			{
				m_stateTimer = Time.time + UnityEngine.Random.Range(MinTimeBeforeNextPrompt, MaxTimeBeforeNextPrompt);
			}
			break;
		case FTUEState.Welcome:
			PlayAudio(WelcomeFullGameAudio);
			MoveOntoNextState();
			break;
		case FTUEState.ReadyForPractice:
			if (m_waitingForEndOfPractice && !FEMManager.Instance.TVAudioSource.isPlaying)
			{
				m_waitingForEndOfPractice = false;
				if ((bool)FEMManager.Instance)
				{
					FEMManager.Instance.EnableOption(FEMManager.FEMOption.Race, enable: true);
				}
			}
			break;
		case FTUEState.FinishFTUE:
			if (!FadeManager.Instance.FinishedFading())
			{
				break;
			}
			if (!m_playingAudioPart1)
			{
				m_playingAudioPart1 = true;
				PlayAudio(EndPractice2Audio_1);
			}
			else
			{
				if (FEMManager.Instance.TVAudioSource.isPlaying)
				{
					break;
				}
				if (!m_playingAudioPart2)
				{
					m_playingAudioPart2 = true;
					PlayAudio(EndPractice2Audio_2);
					break;
				}
				ProfileManager.Instance.FTUE = 0;
				ProfileManager.Instance.SaveProfileData();
				SetFTUEState(FTUEState.None);
				if ((bool)FEMManager.Instance)
				{
					FEMManager.Instance.EnableOption(FEMManager.FEMOption.Settings, enable: true);
					FEMManager.Instance.EnableOption(FEMManager.FEMOption.Online, enable: true);
					FEMManager.Instance.EnableOption(FEMManager.FEMOption.Race, enable: true);
					FEMManager.Instance.EnableOption(FEMManager.FEMOption.PlayerConfig, enable: true);
					FEMManager.Instance.EnableOption(FEMManager.FEMOption.Championship, enable: true);
				}
			}
			break;
		case FTUEState.Practice1:
		case FTUEState.Practice2:
		case FTUEState.Practice2a:
		case FTUEState.Practice3:
		case FTUEState.Practice4:
		case FTUEState.End_Practice:
			break;
		}
	}

	public void HitBalloon()
	{
		m_ftueTargets.Hit();
	}

	public void ReadyToStart()
	{
		Gameplay.Instance.ResetWrongWay();
		if (m_playerList == null)
		{
			m_playerList = PlayerManager.Instance.GetPlayerList();
		}
		if (m_ftueState == FTUEState.ReadyForPractice)
		{
			m_waitForReadyToStart = false;
			ContinueWithStart();
		}
		else
		{
			m_waitForReadyToStart = true;
			FadeManager.Instance.FadeOut(2f);
		}
	}

	private void ContinueWithStart()
	{
		if (m_mainPlayer == null)
		{
			PlayerManager.Instance.GetHumanPlayer(ref m_mainPlayer);
		}
		m_waitForReadyToStart = false;
		MoveOntoNextState();
		if (m_ftueState >= FTUEState.End_Practice)
		{
			return;
		}
		Gameplay.Instance.ShowBoard();
		if (m_ftueState == FTUEState.Practice1)
		{
			m_mainPlayer.PlayAudio(Practice1_Audio);
			HideAICars(hide: true);
		}
		else if (m_ftueState == FTUEState.Practice2)
		{
			HideAICars(hide: false);
		}
		else if (m_ftueState == FTUEState.Practice3)
		{
			m_mainPlayer.PlayAudio(Practice3_Audio);
			if ((bool)FTUETargets && m_ftueTargets == null)
			{
				Transform transform = UnityEngine.Object.Instantiate(FTUETargets);
				transform.parent = Gameplay.Instance.SceneryRoot.transform;
				m_ftueTargets = transform.GetComponent<FTUETargets>();
			}
			HideAICars(hide: true);
		}
		else if (m_ftueState == FTUEState.Practice4)
		{
			m_mainPlayer.PlayAudio(Practice4_Audio);
			HideAICars(hide: false);
		}
		FadeManager.Instance.FadeIn(2f);
	}

	private void HideAICars(bool hide)
	{
		for (int i = 0; i < m_playerList.Count; i++)
		{
			m_playerList[i].transform.position = PlayerManager.Instance.GridStartPositions[m_playerList[i].NewGridPosition].transform.position;
			m_playerList[i].transform.rotation = PlayerManager.Instance.GridStartPositions[m_playerList[i].NewGridPosition].transform.rotation;
			m_playerList[i].GetComponent<Rigidbody>().velocity = Vector3.zero;
			m_playerList[i].ResetWayPoints();
			m_playerList[i].ResetIgnition();
			if (m_playerList[i].GetPlayerType() != 0)
			{
				m_playerList[i].GetComponent<VRCarAIControl>().enabled = !hide;
				m_playerList[i].GetComponent<VRWaypointProgressTracker>().enabled = !hide;
				if (hide)
				{
					m_playerList[i].transform.position = new Vector3(0f, -10f, 0f);
					continue;
				}
				m_playerList[i].GetKartGeometry().ParentRenderingObject.SetActive(value: true);
				if ((bool)m_playerList[i].GetKartGeometry().RacerRenderer)
				{
					m_playerList[i].GetKartGeometry().RacerRenderer.enabled = true;
				}
				continue;
			}
			m_playerList[i].GetComponent<KartUserControl>().ResetStartBoost();
			if (hide)
			{
				int num = ((m_ftueState == FTUEState.Practice3) ? 2 : 0);
				m_playerList[i].transform.position = PlayerManager.Instance.GridStartPositions[num].transform.position;
				m_playerList[i].transform.rotation = PlayerManager.Instance.GridStartPositions[num].transform.rotation;
			}
			if (m_ftueState == FTUEState.Practice3)
			{
				m_playerList[i].GivePlayerWeapon(WeaponManager.WeaponType.Missile);
				m_ftueTargets.SetPlayer(m_playerList[i]);
			}
		}
	}
}
public class HMDConnection : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject MenuObject;

	private bool m_hmdConnected = true;

	private bool m_delayShowingScreen = true;

	private FollowPlayerMenu m_followPlayerMenu;

	private void Start()
	{
		m_followPlayerMenu = GetComponent<FollowPlayerMenu>();
		m_delayShowingScreen = true;
		MenuObject.SetActive(value: false);
	}

	private void Update()
	{
		if (m_delayShowingScreen)
		{
			if (((bool)GameEntry.Instance && !Gameplay.Instance && !FEMManager.Instance) || !FadeManager.Instance.FinishedFading())
			{
				return;
			}
			m_delayShowingScreen = false;
		}
		m_hmdConnected = GameSystem.Instance.HMDConnected() || CameraManager.Instance.GetCurrentType() == CameraManager.CameraType.FP;
		if (m_hmdConnected)
		{
			if (MenuObject.gameObject.activeInHierarchy)
			{
				MenuObject.SetActive(value: false);
			}
		}
		else if (!MenuObject.gameObject.activeInHierarchy)
		{
			m_followPlayerMenu.ForceUpdatePosition();
			MenuObject.SetActive(value: true);
			MenuObject.transform.localPosition = new Vector3(0f, 0f, 0.8f);
			MenuObject.transform.localRotation = Quaternion.identity;
		}
	}
}
public class Highlight : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject HighlightedObject;

	[SerializeField]
	private Material HighlightMaterial;

	[SerializeField]
	private float Speed = 1f;

	[SerializeField]
	private float MaxBrightness = 1.8f;

	private UnityEngine.Color m_defaultColour;

	private float m_angle;

	private void Start()
	{
		if (HighlightMaterial.HasProperty("_Color"))
		{
			m_defaultColour = HighlightMaterial.color;
		}
		m_angle = UnityEngine.Random.Range(0f, (float)Math.PI * 2f);
	}

	private void Update()
	{
		m_angle += GameTime.Instance.DeltaTime() * Speed;
		if (m_angle > (float)Math.PI * 2f)
		{
			m_angle -= (float)Math.PI * 2f;
		}
		Transform[] componentsInChildren = HighlightedObject.GetComponentsInChildren<Transform>();
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (!(transform.GetComponent<Renderer>() != null))
			{
				continue;
			}
			for (int j = 0; j < transform.GetComponent<Renderer>().materials.Length; j++)
			{
				if (transform.GetComponent<Renderer>().material.name.Contains(HighlightMaterial.name))
				{
					transform.GetComponent<Renderer>().materials[j].color = m_defaultColour * (1f + Mathf.Abs(Mathf.Sin(m_angle) * (MaxBrightness - 1f)));
				}
			}
		}
	}
}
public class Keyboard : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject[] Row;

	[SerializeField]
	private GameObject KeyHighlighter;

	private string[,] m_rowLower = new string[5, 13]
	{
		{
			"1", "2", "3", "4", "5", "6", "7", "8", "9", "0",
			"-", "=", "`"
		},
		{
			"q", "w", "e", "r", "t", "y", "u", "i", "o", "p",
			"[", "]", "\\"
		},
		{
			"a",
			"s",
			"d",
			"f",
			"g",
			"h",
			"j",
			"k",
			"l",
			";",
			"'",
			string.Empty,
			string.Empty
		},
		{
			"z",
			"x",
			"c",
			"v",
			"b",
			"n",
			"m",
			",",
			".",
			"/",
			string.Empty,
			string.Empty,
			string.Empty
		},
		{
			"Space",
			"Bksp",
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty
		}
	};

	private string[,] m_rowUpper = new string[5, 13]
	{
		{
			"1", "2", "3", "4", "5", "6", "7", "8", "9", "0",
			"-", "=", "`"
		},
		{
			"Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P",
			"[", "]", "\\"
		},
		{
			"A",
			"S",
			"D",
			"F",
			"G",
			"H",
			"J",
			"K",
			"L",
			";",
			"'",
			string.Empty,
			string.Empty
		},
		{
			"Z",
			"X",
			"C",
			"V",
			"B",
			"N",
			"M",
			",",
			".",
			"/",
			string.Empty,
			string.Empty,
			string.Empty
		},
		{
			"SPACE",
			"BKSP",
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty,
			string.Empty
		}
	};

	private Vector3 m_currentHighlightPosition;

	private bool m_isLowerCase;

	private Text m_strToChange;

	private int m_currentRow;

	private int m_currentColumn;

	private float m_flashTime;

	private float FlashTimeSpeed = 0.5f;

	private GameObject m_lastKey;

	private GameObject m_prevKey;

	private Ray m_keyboardRay;

	private bool m_goStraightToHighlight = true;

	private const float SnapDistance = 0.004f;

	private const float HighlighterSpeed = 6f;

	private const int MaxUserNameLength = 32;

	public void EnableKeyboard(ref Text textToChange, bool enable)
	{
		m_goStraightToHighlight = true;
		base.gameObject.SetActive(enable);
		GameObject[] row = Row;
		foreach (GameObject gameObject in row)
		{
			gameObject.SetActive(enable);
		}
		m_strToChange = textToChange;
	}

	private void Start()
	{
		SetupKeyboard(lowerCase: false);
	}

	private void OnEnable()
	{
		SetupKeyboard(lowerCase: false);
	}

	private void Update()
	{
		UpdateKeyHighlighter();
		UpdateKeyboardMovement();
		FlashKey();
		CheckForKeyInput();
	}

	private void UpdateHeadTracking()
	{
		m_prevKey = m_lastKey;
		Vector3 normalized = (FEMManager.Instance.MenuHintObject.transform.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
		m_keyboardRay = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
		if (Physics.Raycast(m_keyboardRay, out var hitInfo, float.PositiveInfinity, LayerMask.GetMask("Keyboard")))
		{
			GameObject gameObject = hitInfo.collider.gameObject;
			m_lastKey = gameObject.transform.GetChild(0).gameObject;
			m_currentHighlightPosition = gameObject.gameObject.transform.position;
		}
	}

	private void UpdateKeyHighlighter()
	{
		Vector3 position = KeyHighlighter.transform.position;
		position = Vector3.Lerp(position, m_currentHighlightPosition, 6f * Time.deltaTime);
		if (m_goStraightToHighlight)
		{
			position = m_currentHighlightPosition;
			m_goStraightToHighlight = false;
		}
		if ((position - m_currentHighlightPosition).sqrMagnitude < 0.004f)
		{
			position = m_currentHighlightPosition;
		}
		KeyHighlighter.transform.position = position;
	}

	private void OnDrawGizmos()
	{
		Gizmos.DrawRay(m_keyboardRay);
	}

	private void UpdateKeyboardMovement()
	{
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_X))
		{
			SelectDeleteKey();
		}
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Down))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
			m_currentColumn++;
			CheckColumnRowBounds();
			UpdateRow(m_currentColumn - 1);
			m_lastKey.SetActive(value: true);
			m_lastKey = null;
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Up))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
			m_currentColumn--;
			CheckColumnRowBounds();
			UpdateRow(m_currentColumn + 1);
			m_lastKey.SetActive(value: true);
			m_lastKey = null;
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
			m_currentRow--;
			CheckColumnRowBounds();
			m_lastKey.SetActive(value: true);
			m_lastKey = null;
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
			m_currentRow++;
			CheckColumnRowBounds();
			m_lastKey.SetActive(value: true);
			m_lastKey = null;
		}
		if (m_lastKey == null)
		{
			GameObject gameObject = Row[m_currentColumn].transform.GetChild(m_currentRow).gameObject;
			m_lastKey = gameObject.transform.GetChild(0).gameObject;
		}
	}

	private void CheckColumnRowBounds()
	{
		if (m_currentColumn < 0)
		{
			m_currentColumn = 0;
		}
		if (m_currentColumn > Row.Length - 1)
		{
			m_currentColumn = Row.Length - 1;
		}
		if (m_currentRow < 0)
		{
			m_currentRow = 0;
		}
		if (m_currentRow > Row[m_currentColumn].transform.childCount - 1)
		{
			m_currentRow = Row[m_currentColumn].transform.childCount - 1;
		}
	}

	private void UpdateRow(int previousColumn)
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < m_rowLower.GetLength(1); i++)
		{
			if (m_rowLower[previousColumn, i] != string.Empty)
			{
				num++;
			}
		}
		for (int j = 0; j < m_rowLower.GetLength(1); j++)
		{
			if (m_rowLower[m_currentColumn, j] != string.Empty)
			{
				num2++;
			}
		}
		float num3 = (float)m_currentRow / (float)num;
		m_currentRow = (int)((float)num2 * num3);
	}

	private void FlashKey()
	{
		if ((bool)m_prevKey && m_prevKey != m_lastKey)
		{
			m_prevKey.SetActive(value: true);
			m_prevKey = null;
		}
		m_flashTime += Time.deltaTime;
		if (m_flashTime > FlashTimeSpeed)
		{
			if (m_lastKey != null)
			{
				m_lastKey.SetActive(!m_lastKey.activeInHierarchy);
			}
			m_flashTime = 0f;
		}
		if (m_lastKey != null)
		{
			m_currentHighlightPosition = m_lastKey.gameObject.transform.position;
			m_currentHighlightPosition -= m_lastKey.gameObject.transform.forward * 0.001f;
		}
	}

	private void CheckForKeyInput()
	{
		if (m_lastKey == null || !InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			return;
		}
		string text = m_lastKey.GetComponent<TextMesh>().text;
		switch (text)
		{
		case "CAPS":
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
			SetupKeyboard(!m_isLowerCase);
			return;
		case "Bksp":
		case "BKSP":
			SelectDeleteKey();
			return;
		}
		ProfileManager.PlayerData data = ProfileManager.Instance.GetPlayerData(0);
		if (data.m_enteredName == 0)
		{
			data.m_enteredName = 1;
			ProfileManager.Instance.SetPlayerData(0, ref data);
		}
		FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionSelect);
		if (m_strToChange.text.Length < 32)
		{
			if (text == "Space" || text == "SPACE")
			{
				text = " ";
			}
			m_strToChange.text += text;
		}
	}

	private void SelectDeleteKey()
	{
		if (!(m_lastKey == null) && m_strToChange.text.Length > 0)
		{
			FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.MenuBack);
			if (ProfileManager.Instance.GetPlayerData(0).m_enteredName == 0)
			{
				m_strToChange.text = string.Empty;
			}
			else
			{
				m_strToChange.text = m_strToChange.text.Remove(m_strToChange.text.Length - 1);
			}
		}
	}

	private void SetupKeyboard(bool lowerCase)
	{
		m_isLowerCase = lowerCase;
		if (lowerCase)
		{
			for (int i = 0; i < Row.Length; i++)
			{
				for (int j = 0; j < Row[i].transform.childCount; j++)
				{
					GameObject gameObject = Row[i].transform.GetChild(j).gameObject;
					gameObject.transform.GetChild(0).gameObject.GetComponent<TextMesh>().text = m_rowLower[i, j];
				}
			}
		}
		else
		{
			for (int k = 0; k < Row.Length; k++)
			{
				for (int l = 0; l < Row[k].transform.childCount; l++)
				{
					GameObject gameObject2 = Row[k].transform.GetChild(l).gameObject;
					gameObject2.transform.GetChild(0).gameObject.GetComponent<TextMesh>().text = m_rowUpper[k, l];
				}
			}
		}
		m_currentHighlightPosition = Row[0].transform.gameObject.transform.position;
		m_currentHighlightPosition -= Row[0].transform.forward * 0.001f;
	}
}
public class MenuHint : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float ZOffset = 2f;

	[SerializeField]
	private UnityEngine.Color HighlightColour = UnityEngine.Color.green;

	[SerializeField]
	private UnityEngine.Color NonHighlightColour = UnityEngine.Color.white;

	[SerializeField]
	private float MinZ = 6f;

	[SerializeField]
	private float MaxZ = 13f;

	[SerializeField]
	private float MinScale = 0.03f;

	[SerializeField]
	private float MaxScale = 0.08f;

	[SerializeField]
	private float HintScaleOverride = 0.1f;

	[SerializeField]
	private float MinZDistance = 0.5f;

	[SerializeField]
	private MeshRenderer SaveSpinner;

	[SerializeField]
	private MeshCollider BackWindowCollider;

	[SerializeField]
	private float OnlineZOffset = 2.9f;

	[SerializeField]
	private float OnlineScale = 0.2f;

	private bool m_hintOverride;

	private float m_currentZ;

	private MeshRenderer m_mesh;

	private float m_currentAlpha = 1f;

	private float m_targetAlpha = 1f;

	private bool m_hitBackWindow;

	private Vector3 m_originalScale;

	private bool m_highlightSet;

	private const float SpotOffset = 15f;

	public void SetHighlight(bool set)
	{
		m_highlightSet = set;
		if (set || m_hintOverride)
		{
			GetComponent<Renderer>().material.color = new UnityEngine.Color(HighlightColour.r, HighlightColour.g, HighlightColour.b, m_currentAlpha);
		}
		else
		{
			GetComponent<Renderer>().material.color = new UnityEngine.Color(NonHighlightColour.r, NonHighlightColour.g, NonHighlightColour.b, m_currentAlpha);
		}
	}

	public bool IsHighlighted()
	{
		return m_highlightSet;
	}

	public void Saving(bool enable)
	{
		SaveSpinner.gameObject.SetActive(enable);
	}

	private void Start()
	{
		m_originalScale = base.transform.localScale;
		m_mesh = GetComponent<MeshRenderer>();
		m_currentZ = ZOffset;
	}

	private void Update()
	{
		Transform transform = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform;
		Vector3 vector = Quaternion.Euler(0f, base.transform.parent.eulerAngles.y, 0f) * Vector3.forward;
		Vector3 vector2 = InputRemapper.Instance.GetControllerOrientation() * vector;
		float b = ZOffset;
		if ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() != 0)
		{
			b = OnlineZOffset;
		}
		Ray ray = new Ray(transform.position, vector2);
		m_hintOverride = false;
		m_hitBackWindow = false;
		if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("UI", "MenuHint")))
		{
			b = (hitInfo.point - transform.position).magnitude;
			if (hitInfo.collider.gameObject.name == "Quad-Tablet")
			{
				m_hintOverride = true;
			}
			else if (hitInfo.collider == BackWindowCollider)
			{
				m_hitBackWindow = true;
			}
		}
		m_currentZ = Mathf.Lerp(m_currentZ, b, 20f * GameTime.Instance.DeltaTime());
		base.transform.position = transform.position;
		if ((bool)CameraManager.Instance.GetCurrentCamera().transform.parent)
		{
			vector2 = Quaternion.Euler(0f, CameraManager.Instance.GetCurrentCamera().transform.parent.eulerAngles.y, 0f) * vector2;
		}
		vector2.Normalize();
		base.transform.position += vector2 * m_currentZ;
		base.transform.LookAt(transform.position);
		float num = (MaxZ - MinZ) / (MaxScale - MinScale);
		float a = (base.transform.localPosition.z - MinZ) / num + MinScale;
		if (m_hintOverride)
		{
			SetHighlight(set: true);
			a = HintScaleOverride;
		}
		a = Mathf.Max(a, 0.001f);
		if ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() != 0)
		{
			a = OnlineScale;
		}
		base.transform.localScale = new Vector3(a, a, a);
		CheckAlpha();
		UpdateAlpha();
	}

	private void CheckAlpha()
	{
		if (m_hitBackWindow || ((bool)FEMManager.Instance && FEMManager.Instance.KeyboardEnabled()))
		{
			m_targetAlpha = 0f;
		}
		else
		{
			m_targetAlpha = 1f;
		}
	}

	private void UpdateAlpha()
	{
		m_currentAlpha = Mathf.Lerp(m_currentAlpha, m_targetAlpha, 6f * GameTime.Instance.DeltaTime());
	}

	private bool CheckForOnlineRoom()
	{
		if ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() != 0)
		{
			if (m_mesh.enabled)
			{
				m_mesh.enabled = false;
			}
			return true;
		}
		if (!m_mesh.enabled)
		{
			m_mesh.enabled = true;
		}
		return false;
	}
}
public class MenuPlane : UnityEngine.MonoBehaviour
{
	public enum TransitionState
	{
		None,
		Shrink,
		Grow,
		Visible
	}

	public TextMesh[] MenuText;

	public TextMesh[] OptionHeadingText;

	public TextMesh Title;

	public GameObject JoinGroup;

	public GameObject[] ControllerGroup;

	public Slider[] SliderObject;

	public GameObject LockedQuad;

	public GameObject ScrollBar;

	public GameObject[] Arrows;

	public TextMesh[] ExtraText;

	public float MaxScrollLimit = 0.45f;

	public float SliderExtents = 0.45f;

	public float SliderScale = 20f;

	[SerializeField]
	private float TransitionSpeed = 12f;

	[SerializeField]
	private GameObject ArrowUp;

	[SerializeField]
	private GameObject ArrowDown;

	[SerializeField]
	private Vector2 ArrowScaleMinMax;

	private Vector2 m_ArrowUpScale;

	private Vector2 m_ArrowDownScale;

	private TransitionState m_state;

	public void EnableJoinGroup(bool enable)
	{
		if ((bool)JoinGroup)
		{
			JoinGroup.SetActive(enable);
		}
	}

	public void EnableControllerGroup(bool enable, int index = 0)
	{
		if (ControllerGroup != null && ControllerGroup.Length > 0)
		{
			for (int i = 0; i < ControllerGroup.Length; i++)
			{
				ControllerGroup[i].SetActive(index == i && enable);
			}
		}
	}

	public TransitionState GetState()
	{
		return m_state;
	}

	public void ShrinkDown()
	{
		if (m_state != TransitionState.Shrink)
		{
			m_state = TransitionState.Shrink;
		}
	}

	public void GrowUp()
	{
		if (m_state != TransitionState.Grow)
		{
			base.gameObject.SetActive(value: true);
			m_state = TransitionState.Grow;
		}
	}

	private void Start()
	{
		m_ArrowUpScale.y = ArrowScaleMinMax.x;
		m_ArrowUpScale.x = m_ArrowUpScale.y;
		m_ArrowDownScale.y = ArrowScaleMinMax.x;
		m_ArrowDownScale.x = m_ArrowDownScale.y;
	}

	private void Update()
	{
		if (base.gameObject.activeSelf)
		{
			if ((bool)ArrowDown)
			{
				UpdateArrows();
			}
			UpdateTransitions();
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
			{
				UpdateOptionSelect();
			}
		}
	}

	private void UpdateArrows()
	{
		if (FEMManager.Instance.CurrentOption == FEMManager.FEMOption.TrackSelect)
		{
			if (!ArrowDown.gameObject.activeSelf)
			{
				ArrowDown.gameObject.SetActive(value: true);
				ArrowUp.gameObject.SetActive(value: true);
			}
		}
		else if (Arrows.Length == 0 || (ArrowDown.gameObject != Arrows[0].gameObject && ArrowDown != Arrows[1].gameObject && ArrowDown.gameObject.activeSelf))
		{
			ArrowDown.gameObject.SetActive(value: false);
			ArrowUp.gameObject.SetActive(value: false);
		}
		m_ArrowUpScale.x = Mathf.Lerp(m_ArrowUpScale.x, m_ArrowUpScale.y, 6f * GameTime.Instance.DeltaTime());
		m_ArrowDownScale.x = Mathf.Lerp(m_ArrowDownScale.x, m_ArrowDownScale.y, 6f * GameTime.Instance.DeltaTime());
		ArrowUp.transform.localScale = new Vector3(m_ArrowUpScale.x, m_ArrowUpScale.x, m_ArrowUpScale.x);
		ArrowDown.transform.localScale = new Vector3(m_ArrowDownScale.x, m_ArrowDownScale.x, m_ArrowDownScale.x);
	}

	private void UpdateTransitions()
	{
		switch (m_state)
		{
		case TransitionState.Shrink:
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, Vector3.zero, TransitionSpeed * Time.deltaTime);
			if (base.transform.localScale.x <= 0.02f)
			{
				base.gameObject.SetActive(value: false);
				m_state = TransitionState.None;
			}
			break;
		case TransitionState.Grow:
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, Vector3.one, TransitionSpeed * Time.deltaTime);
			if (base.transform.localScale.x >= 0.99f)
			{
				base.transform.localScale = new Vector3(1f, 1f, 1f);
				m_state = TransitionState.Visible;
			}
			break;
		}
	}

	private void UpdateOptionSelect()
	{
		Transform controllerSpot = FEMManager.Instance.GetControllerSpot();
		bool flag = false;
		bool flag2 = false;
		if (!controllerSpot)
		{
			return;
		}
		Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
		if (Vector3.Angle(normalized, CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward) < 30f)
		{
			Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
			RaycastHit[] array = Physics.RaycastAll(ray, 1000f, LayerMask.GetMask("UI"));
			if (array.Length > 0)
			{
				for (int i = 0; i < array.Length; i++)
				{
					if (!array[i].collider.gameObject.activeSelf)
					{
						continue;
					}
					if (FEMManager.Instance.VolumeOptionsEnabled())
					{
						if (!InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
						{
							continue;
						}
						FEMManager.Instance.GrabbedVolumeHandle = array[i].collider.gameObject.transform;
						for (int j = 0; j < SliderObject.Length; j++)
						{
							if (SliderObject[j].SliderLevel.gameObject == array[i].collider.gameObject)
							{
								FEMManager.Instance.SetFlashIndex(j);
								break;
							}
						}
						continue;
					}
					if ((bool)ArrowUp && array[i].collider.gameObject == ArrowUp.gameObject)
					{
						m_ArrowUpScale.y = ArrowScaleMinMax.y;
						flag = true;
						if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
						{
							FEMManager.Instance.SetArrowUp = true;
						}
						continue;
					}
					if ((bool)ArrowDown && array[i].collider.gameObject == ArrowDown.gameObject)
					{
						m_ArrowDownScale.y = ArrowScaleMinMax.y;
						flag2 = true;
						if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
						{
							FEMManager.Instance.SetArrowDown = true;
						}
						continue;
					}
					for (int k = 0; k < MenuText.Length; k++)
					{
						if (array[i].collider.gameObject == MenuText[k].gameObject)
						{
							if (MenuText[k].GetComponent<Renderer>().material.GetColor("_Color") != FEMManager.Instance.DisabledColour)
							{
								FEMManager.Instance.SetOptionSelected(k);
							}
							else
							{
								FEMManager.Instance.SetOptionSelected(10);
							}
						}
					}
				}
			}
		}
		if (!flag)
		{
			m_ArrowUpScale.y = ArrowScaleMinMax.x;
		}
		if (!flag2)
		{
			m_ArrowDownScale.y = ArrowScaleMinMax.x;
		}
	}
}
public class ChatDialog : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Player CurrentPlayer;

	[SerializeField]
	private Text[] TextField;

	[SerializeField]
	private Text ChatSelection;

	[SerializeField]
	private UnityEngine.UI.Image LeftArrow;

	[SerializeField]
	private UnityEngine.UI.Image RightArrow;

	[SerializeField]
	private UnityEngine.Color SelectionUnLockedColour;

	[SerializeField]
	private UnityEngine.Color SelectionLockedColour;

	[SerializeField]
	private float SelectionLockedTime = 0.2f;

	[SerializeField]
	private string[] ChatPresets;

	[SerializeField]
	private GameObject ToolTips;

	[SerializeField]
	private Vector2 SelectToChatMinMax;

	[SerializeField]
	private Vector2 ArrowMinMax;

	[SerializeField]
	private Vector2 ChatMsgMinMax;

	[SerializeField]
	private Vector2 ChatImageMsgMinMax;

	[SerializeField]
	private UnityEngine.UI.Image ChatImage;

	[SerializeField]
	private Text ChatImage_Pad;

	[SerializeField]
	private UnityEngine.UI.Image ExitImage;

	private int m_currentIndex;

	private int m_currentSelection;

	private bool m_selectionEnabled;

	private float m_selectionLocked;

	private float m_receiveSFXTimer;

	private Vector2 m_leftArrowScale;

	private Vector2 m_rightArrowScale;

	private Vector2 m_selectToChatScale;

	private Vector2 m_chatMsgScale;

	private Vector2 m_chatImageScale;

	private Vector2 m_chatImageAlpha;

	private Vector2 m_exitImageAlpha;

	private Vector2 m_exitImageScale;

	private const string DefaultText = "Select to Chat";

	private void Start()
	{
		if (CurrentPlayer != null && CurrentPlayer.GetPlayerType() != 0)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		for (int i = 0; i < TextField.Length; i++)
		{
			TextField[i].text = string.Empty;
		}
		ChatSelection.gameObject.SetActive(value: false);
		ChatSelection.color = SelectionUnLockedColour;
		LeftArrow.gameObject.SetActive(value: false);
		RightArrow.gameObject.SetActive(value: false);
		m_leftArrowScale.x = ArrowMinMax.x;
		m_leftArrowScale.y = ArrowMinMax.x;
		m_rightArrowScale.x = ArrowMinMax.x;
		m_rightArrowScale.y = ArrowMinMax.x;
		m_selectToChatScale.x = SelectToChatMinMax.x;
		m_selectToChatScale.y = SelectToChatMinMax.x;
		m_chatMsgScale.x = ChatMsgMinMax.x;
		m_chatMsgScale.y = ChatMsgMinMax.x;
		m_chatImageScale.x = ChatImageMsgMinMax.x;
		m_chatImageScale.y = ChatImageMsgMinMax.x;
		m_exitImageScale.x = ChatImageMsgMinMax.x;
		m_exitImageScale.y = ChatImageMsgMinMax.x;
		m_chatImageAlpha.x = 0f;
		m_chatImageAlpha.y = 0f;
		m_exitImageAlpha.x = 1f;
		m_exitImageAlpha.y = 1f;
		ChatImage.color = new UnityEngine.Color(ChatImage.color.r, ChatImage.color.g, ChatImage.color.b, m_chatImageAlpha.x);
		ChatImage_Pad.color = new UnityEngine.Color(ChatImage_Pad.color.r, ChatImage_Pad.color.g, ChatImage_Pad.color.b, m_chatImageAlpha.x);
	}

	private void Update()
	{
		int num = (NetworkLogin.Instance ? NetworkLogin.Instance.GetActualRoomPlayerCount() : 0);
		if (num < FEMManager.Instance.NumPlayersForOnlineGame && ChatSelection.gameObject.activeSelf)
		{
			CloseChat();
			m_chatImageAlpha.y = 0f;
		}
		UpdateScales();
		UpdateAlpha();
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			if (ChatImage_Pad.gameObject.activeSelf)
			{
				ChatImage_Pad.gameObject.SetActive(value: false);
			}
		}
		else if (ChatImage.gameObject.activeSelf)
		{
			ChatImage.gameObject.SetActive(value: false);
		}
		if (FEMManager.Instance.WaitingForVoteSelection())
		{
			if (ChatSelection.gameObject.activeSelf)
			{
				ChatSelection.gameObject.SetActive(value: false);
				ToolTips.SetActive(value: false);
				for (int i = 0; i < TextField.Length; i++)
				{
					TextField[i].text = string.Empty;
				}
			}
		}
		else if (!ChatSelection.gameObject.activeSelf)
		{
			m_chatImageAlpha.y = 1f;
			ChatSelection.gameObject.SetActive(value: true);
			ChatSelection.text = string.Empty;
		}
		string[] chatOutput = NetworkLogin.Instance.GetChat().GetChatOutput();
		if (chatOutput.Length > 0)
		{
			for (int j = 0; j < chatOutput.Length; j++)
			{
				AddChatString(chatOutput[j]);
			}
		}
		if (m_selectionLocked <= 0f)
		{
			UpdateUserInput();
			return;
		}
		m_selectionLocked -= GameTime.Instance.DeltaTime();
		if (m_selectionLocked <= 0f)
		{
			NetworkLogin.Instance.GetChat().SendString(ChatPresets[m_currentSelection]);
			FEMManager.Instance.GetFrontendPlayer(0).PlayAudio(FEMManager.Instance.SendMessageClip, forceNoUI: true);
			m_receiveSFXTimer = GameTime.Instance.CurrentTime();
			m_selectionLocked = 0f;
			m_selectionEnabled = false;
			m_currentSelection = 0;
			ChatSelection.color = SelectionUnLockedColour;
			ChatSelection.text = string.Empty;
			ChatSelection.gameObject.SetActive(value: false);
			ToolTips.SetActive(value: false);
			ResetScales();
			m_exitImageAlpha.y = 1f;
			m_chatImageAlpha.y = 1f;
			LeftArrow.gameObject.SetActive(value: false);
			RightArrow.gameObject.SetActive(value: false);
		}
	}

	private void ResetScales()
	{
		m_leftArrowScale.x = ArrowMinMax.x;
		m_leftArrowScale.y = ArrowMinMax.x;
		m_rightArrowScale.x = ArrowMinMax.x;
		m_rightArrowScale.y = ArrowMinMax.x;
		m_selectToChatScale.x = SelectToChatMinMax.x;
		m_selectToChatScale.y = SelectToChatMinMax.x;
		m_chatMsgScale.x = ChatMsgMinMax.x;
		m_chatMsgScale.y = ChatMsgMinMax.x;
		m_chatImageScale.x = ChatImageMsgMinMax.x;
		m_chatImageScale.y = ChatImageMsgMinMax.x;
		m_exitImageScale.x = ChatImageMsgMinMax.x;
		m_exitImageScale.y = ChatImageMsgMinMax.x;
	}

	private void AddChatString(string chatText)
	{
		if (m_currentIndex < TextField.Length)
		{
			TextField[m_currentIndex++].text = chatText;
		}
		else
		{
			for (int i = 0; i < TextField.Length - 1; i++)
			{
				TextField[i].text = TextField[i + 1].text;
			}
			TextField[TextField.Length - 1].text = chatText;
		}
		if (GameTime.Instance.CurrentTime() - m_receiveSFXTimer > 0.55f)
		{
			m_receiveSFXTimer = GameTime.Instance.CurrentTime();
			FEMManager.Instance.GetFrontendPlayer(0).PlayAudio(FEMManager.Instance.ReceiveMessageClip, forceNoUI: true);
		}
	}

	private void UpdateUserInput()
	{
		GameObject gameObject = null;
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			Transform controllerSpot = FEMManager.Instance.GetControllerSpot();
			Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
			Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
			if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("UI")))
			{
				gameObject = hitInfo.collider.gameObject;
				if (m_chatImageAlpha.y < 0.1f && gameObject == ChatImage.gameObject)
				{
					gameObject = null;
				}
				else if (m_exitImageAlpha.y < 0.1f && gameObject == ExitImage.gameObject)
				{
					gameObject = null;
				}
				else
				{
					FEMManager.Instance.MenuHintObject.SetHighlight(set: true);
				}
			}
			if (gameObject == LeftArrow.gameObject)
			{
				m_leftArrowScale.y = ArrowMinMax.y;
			}
			else
			{
				m_leftArrowScale.y = ArrowMinMax.x;
			}
			if (gameObject == RightArrow.gameObject)
			{
				m_rightArrowScale.y = ArrowMinMax.y;
			}
			else
			{
				m_rightArrowScale.y = ArrowMinMax.x;
			}
			if (gameObject == ChatSelection.gameObject)
			{
				m_chatMsgScale.y = ChatMsgMinMax.y;
			}
			else
			{
				m_chatMsgScale.y = ChatMsgMinMax.x;
			}
			if (gameObject == ChatImage.gameObject)
			{
				m_chatImageScale.y = ChatImageMsgMinMax.y;
			}
			else
			{
				m_chatImageScale.y = ChatImageMsgMinMax.x;
			}
			if (gameObject == ExitImage.gameObject)
			{
				m_exitImageScale.y = ChatImageMsgMinMax.y;
			}
			else
			{
				m_exitImageScale.y = ChatImageMsgMinMax.x;
			}
			if (gameObject == ChatImage.gameObject)
			{
				m_selectToChatScale.y = SelectToChatMinMax.y;
			}
			else
			{
				m_selectToChatScale.y = SelectToChatMinMax.x;
			}
			if (!InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
			{
				return;
			}
			if (gameObject == ChatImage.gameObject)
			{
				PushToChat();
			}
			else if (gameObject == ExitImage.gameObject)
			{
				m_chatImageAlpha.y = 0f;
				QuitMenu.Instance.QuitNow();
			}
			if (m_selectionEnabled)
			{
				if (gameObject == LeftArrow.gameObject)
				{
					MoveLeft();
				}
				if (gameObject == RightArrow.gameObject)
				{
					MoveRight();
				}
				else if (gameObject == ChatSelection.gameObject)
				{
					SelectChat();
				}
			}
			return;
		}
		if (ExitImage.gameObject.activeSelf)
		{
			ExitImage.gameObject.SetActive(value: false);
		}
		if (ChatImage.gameObject.activeSelf)
		{
			ChatImage.gameObject.SetActive(value: false);
		}
		if (!m_selectionEnabled)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_Y))
			{
				PushToChat();
			}
			return;
		}
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
		{
			MoveLeft();
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
		{
			MoveRight();
		}
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			SelectChat();
		}
	}

	private void PushToChat()
	{
		if (!m_selectionEnabled)
		{
			m_selectionEnabled = true;
			m_currentSelection = 0;
			ChatSelection.color = SelectionUnLockedColour;
			string translationByIdentifier = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(ChatPresets[m_currentSelection]);
			ChatSelection.text = translationByIdentifier;
			ChatSelection.gameObject.SetActive(value: true);
			LeftArrow.gameObject.SetActive(value: true);
			RightArrow.gameObject.SetActive(value: true);
			ToolTips.SetActive(value: true);
			m_chatImageAlpha.y = 0f;
		}
		else
		{
			CloseChat();
		}
	}

	private void MoveLeft()
	{
		m_currentSelection--;
		if (m_currentSelection < 0)
		{
			m_currentSelection = ChatPresets.Length - 1;
		}
		ChatSelection.color = SelectionUnLockedColour;
		string translationByIdentifier = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(ChatPresets[m_currentSelection]);
		ChatSelection.text = translationByIdentifier;
		FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
	}

	private void MoveRight()
	{
		m_currentSelection++;
		if (m_currentSelection >= ChatPresets.Length)
		{
			m_currentSelection = 0;
		}
		ChatSelection.color = SelectionUnLockedColour;
		string translationByIdentifier = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(ChatPresets[m_currentSelection]);
		ChatSelection.text = translationByIdentifier;
		FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
	}

	private void SelectChat()
	{
		m_selectionLocked = SelectionLockedTime;
		ChatSelection.color = SelectionLockedColour;
	}

	private void CloseChat()
	{
		m_selectionEnabled = false;
		ChatSelection.color = SelectionUnLockedColour;
		ChatSelection.text = string.Empty;
		ChatSelection.gameObject.SetActive(value: false);
		ToolTips.SetActive(value: false);
		LeftArrow.gameObject.SetActive(value: false);
		RightArrow.gameObject.SetActive(value: false);
	}

	private void UpdateScales()
	{
		m_leftArrowScale.x = Mathf.Lerp(m_leftArrowScale.x, m_leftArrowScale.y, 6f * GameTime.Instance.DeltaTime());
		m_rightArrowScale.x = Mathf.Lerp(m_rightArrowScale.x, m_rightArrowScale.y, 6f * GameTime.Instance.DeltaTime());
		m_selectToChatScale.x = Mathf.Lerp(m_selectToChatScale.x, m_selectToChatScale.y, 6f * GameTime.Instance.DeltaTime());
		m_chatMsgScale.x = Mathf.Lerp(m_chatMsgScale.x, m_chatMsgScale.y, 6f * GameTime.Instance.DeltaTime());
		m_chatImageScale.x = Mathf.Lerp(m_chatImageScale.x, m_chatImageScale.y, 6f * GameTime.Instance.DeltaTime());
		m_exitImageScale.x = Mathf.Lerp(m_exitImageScale.x, m_exitImageScale.y, 6f * GameTime.Instance.DeltaTime());
		LeftArrow.transform.localScale = new Vector3(m_leftArrowScale.x, m_leftArrowScale.x, m_leftArrowScale.x);
		RightArrow.transform.localScale = new Vector3(m_rightArrowScale.x, m_rightArrowScale.x, m_rightArrowScale.x);
		ChatSelection.transform.localScale = new Vector3(m_chatMsgScale.x, m_chatMsgScale.x, m_chatMsgScale.x);
		ChatImage.transform.localScale = new Vector3(m_chatImageScale.x, m_chatImageScale.x, m_chatImageScale.x);
		ChatImage_Pad.transform.localScale = new Vector3(m_chatImageScale.x, m_chatImageScale.x, m_chatImageScale.x);
		ExitImage.transform.localScale = new Vector3(m_exitImageScale.x, m_exitImageScale.x, m_exitImageScale.x);
	}

	private void UpdateAlpha()
	{
		float x = m_chatImageAlpha.x;
		m_chatImageAlpha.x = Mathf.Lerp(m_chatImageAlpha.x, m_chatImageAlpha.y, 6f * GameTime.Instance.DeltaTime());
		ChatImage.color = new UnityEngine.Color(ChatImage.color.r, ChatImage.color.g, ChatImage.color.b, m_chatImageAlpha.x);
		ChatImage_Pad.color = new UnityEngine.Color(ChatImage_Pad.color.r, ChatImage_Pad.color.g, ChatImage_Pad.color.b, m_chatImageAlpha.x);
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			if (ChatImage.gameObject.activeSelf && m_chatImageAlpha.x < 0.01f)
			{
				ChatImage.gameObject.SetActive(value: false);
			}
			else if (!ChatImage.gameObject.activeSelf && m_chatImageAlpha.x > 0.01f)
			{
				ChatImage.gameObject.SetActive(value: true);
			}
		}
		else
		{
			if (ChatImage_Pad.gameObject.activeSelf && m_chatImageAlpha.x < 0.01f)
			{
				ChatImage_Pad.gameObject.SetActive(value: false);
			}
			else if (!ChatImage_Pad.gameObject.activeSelf && m_chatImageAlpha.x > 0.01f)
			{
				ChatImage_Pad.gameObject.SetActive(value: true);
			}
			if (x < m_chatImageAlpha.x && !ChatImage_Pad.transform.GetChild(0).gameObject.activeSelf && m_chatImageAlpha.x > 0f)
			{
				ChatImage_Pad.transform.GetChild(0).gameObject.SetActive(value: true);
			}
			else if (x > m_chatImageAlpha.x && ChatImage_Pad.transform.GetChild(0).gameObject.activeSelf && m_chatImageAlpha.x < 1f)
			{
				ChatImage_Pad.transform.GetChild(0).gameObject.SetActive(value: false);
			}
		}
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController && !ExitImage.gameObject.activeSelf && m_exitImageAlpha.x > 0.01f)
		{
			ExitImage.gameObject.SetActive(value: true);
		}
	}
}
public class OnlineQuitOption : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Graphic[] GraphicSet;

	[SerializeField]
	private Collider QuitCollider;

	[SerializeField]
	private float InActiveAlpha = 0.25f;

	[SerializeField]
	private float ActiveAlpha = 0.8f;

	private float m_currentAlpha;

	private float m_targetAlpha;

	private void Update()
	{
		Transform controllerSpot = FEMManager.Instance.GetControllerSpot();
		Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
		Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
		if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("UI")))
		{
			if (hitInfo.collider == QuitCollider)
			{
				m_targetAlpha = ActiveAlpha;
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
				{
					QuitMenu.Instance.QuitNow();
				}
			}
		}
		else
		{
			m_targetAlpha = InActiveAlpha;
		}
		m_currentAlpha = Mathf.Lerp(m_currentAlpha, m_targetAlpha, 6f * GameTime.Instance.DeltaTime());
		for (int i = 0; i < GraphicSet.Length; i++)
		{
			GraphicSet[i].color = new UnityEngine.Color(1f, 1f, 1f, m_currentAlpha);
		}
	}
}
public class OnlineTrackScreen : UnityEngine.MonoBehaviour
{
	[Serializable]
	public struct VotingTrackData
	{
		public Transform Root;

		public Text TrackName;

		public RawImage Thumbnail;

		public RawImage AlphaQuad;

		public SpriteRenderer ConfirmTick;
	}

	private struct HoldingPlayerData
	{
		public string name;

		public int ID;
	}

	[SerializeField]
	public TrackThumbnails ThumbNailManager;

	[SerializeField]
	private GameObject VotingRoot;

	[SerializeField]
	private VotingTrackData VotingTrack1;

	[SerializeField]
	private VotingTrackData VotingTrack2;

	[SerializeField]
	private VotingTrackData VotingTrackCentre;

	[SerializeField]
	private TextureFrame VotingSpinner;

	[SerializeField]
	private Text CountdownTimer;

	[SerializeField]
	private GameObject TrackInfoRoot;

	[SerializeField]
	private Text WaitingForVotesText;

	[SerializeField]
	private GameObject CannotFindPlayersText;

	[SerializeField]
	private Text[] HoldingScreenText;

	[SerializeField]
	private GameObject HoldingScreenBoard;

	[SerializeField]
	private UnityEngine.Color RacingColour = new UnityEngine.Color(0f, 44f / 51f, 1f, 1f);

	[SerializeField]
	private UnityEngine.Color HoldingColour = new UnityEngine.Color(44f / 51f, 0.23529412f, 1f, 1f);

	[SerializeField]
	private GameObject WaitingForPlayersObject;

	[SerializeField]
	private GameObject WaitingForPlayersIcon;

	[SerializeField]
	private GameObject Globe;

	[SerializeField]
	private Text LapNumberText;

	[SerializeField]
	private AudioSource MenuAudioSource;

	[SerializeField]
	private AudioClip NextTrackClip;

	[SerializeField]
	private AudioClip TrackToggleClip;

	[SerializeField]
	private AudioClip ZoomInClip;

	[SerializeField]
	private AudioClip ZoomOutClip;

	[SerializeField]
	private AudioClip CountdownClip;

	private const float HoldingScreenUpdateInterval = 0.5f;

	private const float VotePanelSelectScale = 1f;

	private const float VotePanelUnSelectScale = 0.8f;

	private const float VotePanelUnSelectedAlpha = 0.4f;

	private const float VotePanelFinishedVotingAlpha = 0.7f;

	public float VotingTime = 20f;

	public float NextUpDisplayTime = 10f;

	public float TrackDisplayTime = 12f;

	public float SearchingForPlayersTimeout = 10f;

	private float m_prevHoldingTime;

	private float m_holdingTimer = float.PositiveInfinity;

	private float m_prevDisplayCount;

	private Transform m_playerTransform;

	private bool m_updateRequired;

	private List<PlayerManager.PositionData> m_positionData = new List<PlayerManager.PositionData>();

	private List<HoldingPlayerData> m_holdingPlayerData = new List<HoldingPlayerData>();

	private float m_angle;

	private bool m_setupPlayers;

	private bool m_votingForTrack1 = true;

	private bool m_waitingForVoteSelection = true;

	private float m_targetScaleVote1 = 1f;

	private float m_targetScaleVote2 = 0.8f;

	private float m_targetAlphaVote1;

	private float m_targetAlphaVote2;

	private float m_targetScaleVoteCentre;

	private float m_updateTime;

	private GameObject m_selectedUIObject;

	public float TimeToDisplayLevelName { get; set; }

	public bool WaitingForVoteSelection()
	{
		return m_waitingForVoteSelection;
	}

	public void EnableCannotFindPlayers(bool enable)
	{
		if (CannotFindPlayersText.activeSelf != enable)
		{
			CannotFindPlayersText.SetActive(enable);
		}
	}

	public void ResetVoting()
	{
		VotingRoot.SetActive(value: false);
		TrackInfoRoot.SetActive(value: false);
		VotingSpinner.gameObject.SetActive(value: false);
		m_waitingForVoteSelection = true;
		VotingTrack1.Root.localScale = new Vector3(1f, 1f, 1f);
		VotingTrack2.Root.localScale = new Vector3(0.8f, 0.8f, 0.8f);
		VotingTrack1.AlphaQuad.color = new UnityEngine.Color(0f, 0f, 0f, 0f);
		VotingTrack2.AlphaQuad.color = new UnityEngine.Color(0f, 0f, 0f, 0f);
		VotingTrack1.ConfirmTick.gameObject.SetActive(value: false);
		VotingTrack2.ConfirmTick.gameObject.SetActive(value: false);
		m_targetAlphaVote1 = 0f;
		m_targetAlphaVote2 = 0.4f;
		m_targetScaleVote1 = 1f;
		m_targetScaleVote2 = 0.8f;
		m_targetScaleVoteCentre = 0f;
		VotingTrackCentre.Root.localScale = Vector3.zero;
		VotingTrackCentre.Root.gameObject.SetActive(value: false);
		EnableCannotFindPlayers(enable: false);
	}

	public void SetHoldingTime(float time, float prevTime)
	{
		m_holdingTimer = time;
		m_prevHoldingTime = prevTime;
	}

	public void SetPlayerPosition(Transform transform)
	{
		m_playerTransform = transform;
		m_updateRequired = true;
	}

	public void AddHoldingPlayer(string name, int ID)
	{
		if (!IsHoldingPlayerPresent(ID))
		{
			HoldingPlayerData item = default(HoldingPlayerData);
			item.ID = ID;
			item.name = name;
			m_holdingPlayerData.Add(item);
		}
	}

	private bool IsHoldingPlayerPresent(int ID)
	{
		for (int i = 0; i < m_holdingPlayerData.Count; i++)
		{
			if (m_holdingPlayerData[i].ID == ID)
			{
				return true;
			}
		}
		return false;
	}

	private void Awake()
	{
		m_holdingPlayerData.Clear();
		m_setupPlayers = false;
	}

	private void OnEnable()
	{
		m_holdingTimer = float.PositiveInfinity;
		m_setupPlayers = false;
		m_updateTime = 0f;
		WaitingForVotesText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ChooseATrack", convertToUpperCase: true);
	}

	private void UpdateSelectedUIObject()
	{
		if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
		{
			Transform controllerSpot = FEMManager.Instance.GetControllerSpot();
			if ((bool)controllerSpot)
			{
				Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
				Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
				if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("UI")))
				{
					FEMManager.Instance.MenuHintObject.SetHighlight(set: true);
					m_selectedUIObject = hitInfo.collider.gameObject;
				}
			}
		}
		else if (m_waitingForVoteSelection && !GameSystem.Instance.WaitingForOnlineTrackSelection)
		{
			if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Left))
			{
				m_selectedUIObject = VotingTrack1.Root.gameObject;
			}
			else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.DPad_Right))
			{
				m_selectedUIObject = VotingTrack2.Root.gameObject;
			}
		}
	}

	private void UpdateHoldingScreen()
	{
		if (!FEMManager.Instance.InHoldingState)
		{
			if (HoldingScreenBoard.activeSelf)
			{
				HoldingScreenBoard.SetActive(value: false);
			}
			return;
		}
		if (!HoldingScreenBoard.activeSelf)
		{
			HoldingScreenBoard.SetActive(value: true);
			ResetVoting();
		}
		if (GameTime.Instance.CurrentTime() < m_updateTime)
		{
			return;
		}
		int num = 0;
		List<Player> playingPlayersInHolding = FEMManager.Instance.GetPlayingPlayersInHolding();
		NetworkClient.CharacterData[] characterList = NetworkLogin.Instance.GetClient().GetCharacterList();
		m_positionData.Clear();
		for (int i = 0; i < characterList.Length; i++)
		{
			if (characterList[i].playerIndex != -1)
			{
				PlayerManager.PositionData positionData = new PlayerManager.PositionData();
				positionData.index = characterList[i].playerIndex;
				positionData.position = 0f - characterList[i].pointOnTrack;
				m_positionData.Add(positionData);
			}
		}
		m_positionData.Sort();
		m_updateTime = GameTime.Instance.CurrentTime() + 0.5f;
		for (int j = 0; j < m_positionData.Count; j++)
		{
			for (int k = 0; k < playingPlayersInHolding.Count; k++)
			{
				if (playingPlayersInHolding[k].SeatIndex == m_positionData[j].index)
				{
					HoldingScreenText[j].text = playingPlayersInHolding[k].GetDisplayName();
					HoldingScreenText[j].color = RacingColour;
					SetRacingText(j, racing: true);
					num++;
					break;
				}
			}
		}
		HoldingScreenText[num].text = ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true);
		if (HoldingScreenText[num].text.Length > ProfileManager.MaxNameLength + 2)
		{
			HoldingScreenText[num].text = HoldingScreenText[num].text.Substring(0, ProfileManager.MaxNameLength);
			HoldingScreenText[num].text += "..";
		}
		HoldingScreenText[num].color = HoldingColour;
		SetRacingText(num, racing: false);
		num++;
		for (int l = 0; l < m_holdingPlayerData.Count; l++)
		{
			HoldingScreenText[num].text = m_holdingPlayerData[l].name;
			HoldingScreenText[num].color = HoldingColour;
			SetRacingText(num, racing: false);
			num++;
		}
		CheckForMissingPlayers();
		for (int m = num; m < HoldingScreenText.Length; m++)
		{
			HoldingScreenText[m].text = "--------------";
			HoldingScreenText[m].color = UnityEngine.Color.white;
			HoldingScreenText[m].gameObject.transform.GetChild(0).gameObject.SetActive(value: false);
			HoldingScreenText[m].gameObject.transform.GetChild(1).gameObject.SetActive(value: false);
		}
		int num2 = NetworkLogin.Instance.GetCurrentLap();
		if (num2 < 1)
		{
			num2 = 1;
		}
		LapNumberText.text = num2.ToString();
	}

	private void UpdateVoting()
	{
		if (WaitingForPlayersObject.gameObject.activeSelf || FEMManager.Instance.InHoldingState)
		{
			return;
		}
		float num = m_prevHoldingTime - NextUpDisplayTime;
		float num2 = m_holdingTimer - NextUpDisplayTime;
		if (NetworkLogin.Instance.IsMasterPlayer() && num > 0f && num2 <= 0f)
		{
			CountUpVotes();
		}
		if (m_holdingTimer <= NextUpDisplayTime)
		{
			if (m_waitingForVoteSelection)
			{
				DisableVotingDialog();
			}
			if (m_holdingTimer <= TrackDisplayTime)
			{
				if (!TrackInfoRoot.activeSelf)
				{
					TrackInfoRoot.SetActive(value: true);
					VotingSpinner.gameObject.SetActive(value: false);
					VotingRoot.SetActive(value: false);
					VotingTrackCentre.Root.gameObject.SetActive(value: true);
					m_targetScaleVoteCentre = 1f;
					MenuAudioSource.clip = NextTrackClip;
					MenuAudioSource.Play();
				}
				num2 = m_holdingTimer;
				int num3 = (int)num2;
				CountdownTimer.text = num3.ToString();
				if ((float)num3 != m_prevDisplayCount)
				{
					m_prevDisplayCount = num3;
					if (!MenuAudioSource.isPlaying)
					{
						MenuAudioSource.clip = CountdownClip;
						MenuAudioSource.Play();
					}
				}
				VotingTrackCentre.Root.localScale = Vector3.Lerp(VotingTrackCentre.Root.localScale, new Vector3(m_targetScaleVoteCentre, m_targetScaleVoteCentre, m_targetScaleVoteCentre), 6f * GameTime.Instance.DeltaTime());
			}
			else
			{
				WaitingForVotesText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_NextUp", convertToUpperCase: true) + "..";
				m_targetScaleVote1 = 0f;
				m_targetScaleVote2 = 0f;
				if (VotingSpinner.gameObject.activeSelf)
				{
					VotingSpinner.gameObject.SetActive(value: false);
				}
			}
		}
		else
		{
			float num4 = NextUpDisplayTime + 5f;
			if (m_prevHoldingTime > num4 && m_holdingTimer <= num4)
			{
				FEMManager.Instance.LockDoors();
			}
			if (!VotingSpinner.gameObject.activeSelf)
			{
				VotingSpinner.gameObject.SetActive(value: true);
			}
			float num5 = (m_holdingTimer - NextUpDisplayTime) / VotingTime * 8f;
			VotingSpinner.SetIndex(8 - (int)num5);
		}
		if (VotingRoot.activeSelf)
		{
			VotingTrack1.Root.localScale = Vector3.Lerp(VotingTrack1.Root.localScale, new Vector3(m_targetScaleVote1, m_targetScaleVote1, m_targetScaleVote1), 6f * GameTime.Instance.DeltaTime());
			VotingTrack2.Root.localScale = Vector3.Lerp(VotingTrack2.Root.localScale, new Vector3(m_targetScaleVote2, m_targetScaleVote2, m_targetScaleVote2), 6f * GameTime.Instance.DeltaTime());
			float a = VotingTrack1.AlphaQuad.color.a;
			float a2 = VotingTrack2.AlphaQuad.color.a;
			a = Mathf.Lerp(a, m_targetAlphaVote1, 6f * GameTime.Instance.DeltaTime());
			a2 = Mathf.Lerp(a2, m_targetAlphaVote2, 6f * GameTime.Instance.DeltaTime());
			VotingTrack1.AlphaQuad.color = new UnityEngine.Color(0f, 0f, 0f, a);
			VotingTrack2.AlphaQuad.color = new UnityEngine.Color(0f, 0f, 0f, a2);
		}
		if (!m_waitingForVoteSelection || GameSystem.Instance.WaitingForOnlineTrackSelection)
		{
			return;
		}
		if (!VotingRoot.activeSelf)
		{
			VotingRoot.SetActive(value: true);
			TrackList.TrackData trackByIndex = GameSystem.Instance.GetTrackListing().GetTrackByIndex(GameSystem.Instance.LastSelectedOnlineTrack1);
			TrackList.TrackData trackByIndex2 = GameSystem.Instance.GetTrackListing().GetTrackByIndex(GameSystem.Instance.LastSelectedOnlineTrack2);
			VotingTrack1.TrackName.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(trackByIndex.Name, convertToUpperCase: true);
			VotingTrack2.TrackName.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(trackByIndex2.Name, convertToUpperCase: true);
			Texture textureByName = GameSystem.Instance.GetThumbnailManager().GetTextureByName(trackByIndex.ThumbNailPath);
			if ((bool)textureByName)
			{
				VotingTrack1.Thumbnail.texture = textureByName;
			}
			Texture textureByName2 = GameSystem.Instance.GetThumbnailManager().GetTextureByName(trackByIndex2.ThumbNailPath);
			if ((bool)textureByName2)
			{
				VotingTrack2.Thumbnail.texture = textureByName2;
			}
		}
		if (!m_votingForTrack1 && m_selectedUIObject == VotingTrack1.Root.gameObject)
		{
			m_targetScaleVote1 = 1f;
			m_targetScaleVote2 = 0.8f;
			m_targetAlphaVote1 = 0f;
			m_targetAlphaVote2 = 0.4f;
			MenuAudioSource.clip = ZoomInClip;
			MenuAudioSource.Play();
			m_votingForTrack1 = true;
		}
		else if (m_votingForTrack1 && m_selectedUIObject == VotingTrack2.Root.gameObject)
		{
			m_targetScaleVote1 = 0.8f;
			m_targetScaleVote2 = 1f;
			m_targetAlphaVote1 = 0.4f;
			m_targetAlphaVote2 = 0f;
			MenuAudioSource.clip = ZoomInClip;
			MenuAudioSource.Play();
			m_votingForTrack1 = false;
		}
		else if ((InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl || FEMManager.Instance.MenuHintObject.IsHighlighted()) && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
		{
			FEMManager.Instance.PlayerVotes[FEMManager.Instance.GetFrontendPlayer(0).SeatIndex] = (m_votingForTrack1 ? FEMManager.PlayerVote.Vote_Track1 : FEMManager.PlayerVote.Vote_Track2);
			MenuAudioSource.clip = TrackToggleClip;
			MenuAudioSource.Play();
			if (m_votingForTrack1)
			{
				VotingTrack1.ConfirmTick.gameObject.SetActive(value: true);
			}
			else
			{
				VotingTrack2.ConfirmTick.gameObject.SetActive(value: true);
			}
			DisableVotingDialog();
		}
	}

	private void DisableVotingDialog()
	{
		m_waitingForVoteSelection = false;
		m_targetScaleVote1 = 0.8f;
		m_targetScaleVote2 = 0.8f;
		m_targetAlphaVote1 = 0.7f;
		m_targetAlphaVote2 = 0.7f;
		WaitingForVotesText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_WaitingForVotes", convertToUpperCase: true);
	}

	private void CountUpVotes()
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		for (int i = 0; i < FEMManager.Instance.PlayerVotes.Length; i++)
		{
			if (FEMManager.Instance.PlayerVotes[i] == FEMManager.PlayerVote.Vote_Track1)
			{
				num++;
			}
			else if (FEMManager.Instance.PlayerVotes[i] == FEMManager.PlayerVote.Vote_Track2)
			{
				num2++;
			}
		}
		num3 = ((num > num2) ? GameSystem.Instance.LastSelectedOnlineTrack1 : ((num2 <= num) ? ((!(UnityEngine.Random.Range(0f, 1f) < 0.5f)) ? GameSystem.Instance.LastSelectedOnlineTrack2 : GameSystem.Instance.LastSelectedOnlineTrack1) : GameSystem.Instance.LastSelectedOnlineTrack2));
		FEMManager.Instance.SetOnlineTrack(num3);
	}

	private void SetRacingText(int textIndex, bool racing)
	{
		HoldingScreenText[textIndex].gameObject.transform.GetChild((!racing) ? 1 : 0).gameObject.SetActive(value: true);
		HoldingScreenText[textIndex].gameObject.transform.GetChild(racing ? 1 : 0).gameObject.SetActive(value: false);
	}

	private void CheckForMissingPlayers()
	{
		int[] playerIDList = NetworkLogin.Instance.GetPlayerIDList();
		for (int i = 0; i < m_holdingPlayerData.Count; i++)
		{
			int num = 0;
			for (num = 0; num < playerIDList.Length && playerIDList[num] != m_holdingPlayerData[i].ID; num++)
			{
			}
			if (num == playerIDList.Length)
			{
				m_holdingPlayerData.RemoveAt(i);
			}
		}
	}

	private void Update()
	{
		UpdateSelectedUIObject();
		UpdateHoldingScreen();
		UpdateVoting();
		if (m_updateRequired)
		{
			m_updateRequired = false;
			base.transform.LookAt(m_playerTransform.position);
		}
		if (FEMManager.Instance.InHoldingState)
		{
			EnableWaitingNotification(enable: false);
			EnableGlobe(enable: false);
			return;
		}
		int num = (NetworkLogin.Instance ? NetworkLogin.Instance.GetActualRoomPlayerCount() : 0);
		if (num < FEMManager.Instance.NumPlayersForOnlineGame)
		{
			EnableWaitingNotification(enable: true);
			EnableGlobe(enable: true);
			m_angle += 200f * GameTime.Instance.DeltaTime();
			m_angle %= 360f;
			WaitingForPlayersIcon.transform.localEulerAngles = new Vector3(0f, 0f, m_angle);
		}
		else
		{
			EnableWaitingNotification(enable: false);
			EnableGlobe(enable: true);
		}
		if (!m_setupPlayers && m_holdingTimer < NextUpDisplayTime)
		{
			m_setupPlayers = true;
			FEMManager.Instance.SetCurrentRoomCount();
			FEMManager.Instance.RandomiseGridPositions();
		}
		if (m_holdingTimer < NextUpDisplayTime)
		{
			string onlineTrackName = FEMManager.Instance.GetOnlineTrackName();
			int onlineTrackIndex = FEMManager.Instance.GetOnlineTrackIndex();
			VotingTrackCentre.TrackName.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(onlineTrackName, convertToUpperCase: true);
			if (onlineTrackIndex == GameSystem.Instance.LastSelectedOnlineTrack1)
			{
				VotingTrackCentre.Thumbnail.texture = VotingTrack1.Thumbnail.texture;
			}
			else
			{
				VotingTrackCentre.Thumbnail.texture = VotingTrack2.Thumbnail.texture;
			}
		}
		else
		{
			VotingTrackCentre.TrackName.text = string.Empty;
		}
	}

	private void EnableGlobe(bool enable)
	{
		if (Globe.activeSelf != enable)
		{
			Globe.SetActive(enable);
		}
	}

	private void EnableWaitingNotification(bool enable)
	{
		if (WaitingForPlayersObject.activeSelf != enable)
		{
			WaitingForPlayersObject.SetActive(enable);
			WaitingForPlayersIcon.SetActive(enable);
			ResetVoting();
		}
	}
}
public class TrackThumbnails : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Texture[] Thumbnails;

	public Texture GetTextureByName(string name)
	{
		for (int i = 0; i < Thumbnails.Length; i++)
		{
			if (Thumbnails[i].name == name)
			{
				return Thumbnails[i];
			}
		}
		return null;
	}
}
public class Radio : UnityEngine.MonoBehaviour
{
	private void Update()
	{
		if (ProfileManager.Instance.FTUE == 1)
		{
			GetComponent<GameMusic3D>().OverrideDefaultVolume(0.25f);
		}
	}
}
public class ResultsBoard : UnityEngine.MonoBehaviour
{
	public class ChampionData : IComparable
	{
		public float numPoints;

		public int index;

		public int CompareTo(object obj)
		{
			ChampionData championData = obj as ChampionData;
			return numPoints.CompareTo(championData.numPoints);
		}
	}

	[SerializeField]
	private GameObject PosObj;

	[SerializeField]
	private GameObject DriverObj;

	[SerializeField]
	private GameObject TimeObj;

	[SerializeField]
	private GameObject AvgObj;

	[SerializeField]
	private GameObject ChampionPointsObj;

	[SerializeField]
	private GameObject WinnerObj;

	[SerializeField]
	private GameObject OnlineDriverObj;

	[SerializeField]
	private GameObject OnlinePointsObj;

	[SerializeField]
	private GameObject TimeTrialLapsObj;

	[SerializeField]
	private GameObject TimeTrialTimesObj;

	[SerializeField]
	private Canvas CanvasObj;

	[SerializeField]
	private MeshRenderer[] ColourIndicator;

	[SerializeField]
	private GameObject TracksRemainingObj;

	[SerializeField]
	private Renderer ScreenRenderer;

	private const float SwitchInfoTime = 6f;

	private List<ChampionData> m_championDataList = new List<ChampionData>();

	private List<Player> m_playerList;

	private float m_infoSwitchTimer;

	private bool m_showWinner;

	private bool m_bringInOtherPlayers;

	private double[] m_totalTime = new double[8];

	private double[] m_totalAvgTime = new double[8];

	public void StoreTimes(int index, double totalTime, double totalAvgTime)
	{
		m_totalTime[index] = totalTime;
		m_totalAvgTime[index] = totalAvgTime;
	}

	private void Start()
	{
		CanvasObj.gameObject.SetActive(value: false);
		if ((bool)TracksRemainingObj)
		{
			TracksRemainingObj.SetActive(value: false);
		}
		for (int i = 1; i < DriverObj.transform.childCount; i++)
		{
			if (i <= PlayerManager.Instance.MaxPlayers)
			{
				if ((bool)DriverObj)
				{
					DriverObj.transform.GetChild(i).GetComponent<Text>().text = "- - - - - - -";
				}
				if ((bool)TimeObj)
				{
					TimeObj.transform.GetChild(i).GetComponent<Text>().text = "- - - - - - -";
				}
				if ((bool)AvgObj)
				{
					AvgObj.transform.GetChild(i).GetComponent<Text>().text = "- - - - - - -";
				}
				if ((bool)PosObj)
				{
					PosObj.transform.GetChild(i).gameObject.SetActive(value: true);
				}
			}
			else
			{
				if ((bool)DriverObj)
				{
					DriverObj.transform.GetChild(i).GetComponent<Text>().text = string.Empty;
				}
				if ((bool)TimeObj)
				{
					TimeObj.transform.GetChild(i).GetComponent<Text>().text = string.Empty;
				}
				if ((bool)AvgObj)
				{
					AvgObj.transform.GetChild(i).GetComponent<Text>().text = string.Empty;
				}
				if ((bool)ChampionPointsObj)
				{
					ChampionPointsObj.transform.GetChild(i).GetComponent<Text>().text = string.Empty;
				}
				if ((bool)PosObj)
				{
					PosObj.transform.GetChild(i).gameObject.SetActive(value: false);
				}
			}
			if (ColourIndicator != null && ColourIndicator.Length > 0 && (bool)ColourIndicator[i - 1])
			{
				ColourIndicator[i - 1].gameObject.SetActive(value: false);
			}
		}
		for (int j = 0; j < OnlineDriverObj.transform.childCount; j++)
		{
			if ((bool)OnlineDriverObj)
			{
				OnlineDriverObj.transform.GetChild(j).gameObject.SetActive(value: false);
			}
			if ((bool)OnlinePointsObj)
			{
				OnlinePointsObj.transform.GetChild(j).gameObject.SetActive(value: false);
			}
		}
		if ((bool)TimeTrialLapsObj)
		{
			TimeTrialLapsObj.gameObject.SetActive(value: false);
		}
		if ((bool)TimeTrialTimesObj)
		{
			TimeTrialTimesObj.gameObject.SetActive(value: false);
		}
	}

	private void OnEnable()
	{
		ChampionPointsObj.SetActive(value: false);
		WinnerObj.SetActive(value: false);
		m_bringInOtherPlayers = false;
		TrackList.TrackData trackData = ((!(GameEntry.Instance == null)) ? GameSystem.Instance.GetLoadedTrack() : GameSystem.Instance.GetTrackListing().GetTrackBySceneName(UnityEngine.Application.loadedLevelName));
		Texture textureByName = GameSystem.Instance.GetThumbnailManager().GetTextureByName(trackData.ThumbNailPath);
		if (ScreenRenderer != null && textureByName != null)
		{
			ScreenRenderer.material.SetTexture("_MainTex", textureByName);
		}
	}

	private void OnDisable()
	{
		CanvasObj.gameObject.SetActive(value: false);
		for (int i = 1; i < DriverObj.transform.childCount; i++)
		{
			if ((bool)DriverObj && DriverObj.transform.childCount > i)
			{
				DriverObj.transform.GetChild(i).GetComponent<Text>().color = UnityEngine.Color.white;
			}
			if ((bool)TimeObj && TimeObj.transform.childCount > i)
			{
				TimeObj.transform.GetChild(i).GetComponent<Text>().color = UnityEngine.Color.white;
			}
			if ((bool)AvgObj && AvgObj.transform.childCount > i)
			{
				AvgObj.transform.GetChild(i).GetComponent<Text>().color = UnityEngine.Color.white;
			}
			if ((bool)ChampionPointsObj && ChampionPointsObj.transform.childCount > i)
			{
				ChampionPointsObj.transform.GetChild(i).GetComponent<Text>().color = new UnityEngine.Color(4f / 85f, 0.8980392f, 26f / 51f, 1f);
			}
		}
	}

	private void Update()
	{
		if (!Gameplay.Instance || !Gameplay.Instance.RaceFinished() || ((bool)GameEntry.Instance && GameEntry.Instance.IsLoading()))
		{
			return;
		}
		if (!CanvasObj.gameObject.activeSelf)
		{
			CanvasObj.gameObject.SetActive(value: true);
			m_infoSwitchTimer = GameTime.Instance.CurrentTime() + 6f;
		}
		if (GameSystem.Instance.EnableTimeTrialMode)
		{
			if ((bool)PosObj)
			{
				PosObj.gameObject.SetActive(value: false);
			}
			if ((bool)DriverObj)
			{
				DriverObj.gameObject.SetActive(value: false);
			}
			if ((bool)TimeObj)
			{
				TimeObj.gameObject.SetActive(value: false);
			}
			if ((bool)AvgObj)
			{
				AvgObj.gameObject.SetActive(value: false);
			}
			if ((bool)ChampionPointsObj)
			{
				ChampionPointsObj.gameObject.SetActive(value: false);
			}
			if ((bool)WinnerObj)
			{
				WinnerObj.gameObject.SetActive(value: false);
			}
			if ((bool)OnlineDriverObj)
			{
				OnlineDriverObj.gameObject.SetActive(value: false);
			}
			if ((bool)OnlinePointsObj)
			{
				OnlinePointsObj.gameObject.SetActive(value: false);
			}
			if ((bool)TracksRemainingObj)
			{
				TracksRemainingObj.gameObject.SetActive(value: false);
			}
			if (ColourIndicator != null && ColourIndicator.Length > 0)
			{
				for (int i = 1; i < DriverObj.transform.childCount; i++)
				{
					if ((bool)ColourIndicator[i - 1])
					{
						ColourIndicator[i - 1].gameObject.SetActive(value: false);
					}
				}
			}
			if ((bool)TimeTrialLapsObj && !TimeTrialLapsObj.gameObject.activeSelf)
			{
				TimeTrialLapsObj.gameObject.SetActive(value: true);
			}
			if (!TimeTrialTimesObj)
			{
				return;
			}
			Player mainHumanPlayer = Gameplay.Instance.GetMainHumanPlayer();
			if (!TimeTrialTimesObj.gameObject.activeSelf)
			{
				TimeTrialTimesObj.gameObject.SetActive(value: true);
			}
			for (int j = 1; j < TimeTrialTimesObj.transform.childCount; j++)
			{
				int mins = 0;
				int secs = 0;
				int tenths = 0;
				if (j - 1 == LapManager.Instance.TimeTrialBestLapIndex)
				{
					TimeTrialTimesObj.transform.GetChild(j).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
				}
				else
				{
					TimeTrialTimesObj.transform.GetChild(j).GetComponent<Text>().color = UnityEngine.Color.white;
				}
				GameTime.Instance.ConvertTime(mainHumanPlayer.LapDataEntry.lapTime[j - 1], ref mins, ref secs, ref tenths);
				TimeTrialTimesObj.transform.GetChild(j).GetComponent<Text>().text = mins.ToString("00") + ":" + secs.ToString("00") + ":" + tenths.ToString("00");
			}
		}
		else if (!GameSystem.Instance.GetChampionshipMode().ModeInProgress())
		{
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				if (GameTime.Instance.CurrentTime() < m_infoSwitchTimer)
				{
					UpdateRaceStats();
					return;
				}
				ResultsManager.Instance.UpdateOnlinePoints();
				UpdateOnlineStats();
			}
			else
			{
				UpdateRaceStats();
			}
		}
		else if (!m_showWinner)
		{
			if (Time.time < m_infoSwitchTimer)
			{
				UpdateRaceStats();
				return;
			}
			UpdateChampionStats();
			if (!GameSystem.Instance.GetChampionshipMode().ShouldMoveOn() && Time.time > m_infoSwitchTimer + 4f)
			{
				m_showWinner = true;
			}
		}
		else
		{
			UpdateWinner();
		}
	}

	private void UpdateRaceStats()
	{
		m_playerList = PlayerManager.Instance.GetPlayerList();
		int num = 0;
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player player = m_playerList[i];
			if ((bool)player && player.PlayerFinishState == Player.PlayerFinishedState.InResults)
			{
				num++;
			}
		}
		Player mainHumanPlayer = Gameplay.Instance.GetMainHumanPlayer();
		int mins = 0;
		int secs = 0;
		int tenths = 0;
		int mins2 = 0;
		int secs2 = 0;
		int tenths2 = 0;
		for (int j = 0; j < m_playerList.Count; j++)
		{
			Player player2 = m_playerList[j];
			if (!player2 || player2.PlayerFinishState != Player.PlayerFinishedState.InResults)
			{
				continue;
			}
			GameTime.Instance.ConvertTime(m_totalTime[player2.SeatIndex], ref mins, ref secs, ref tenths);
			GameTime.Instance.ConvertTime(m_totalAvgTime[player2.SeatIndex], ref mins2, ref secs2, ref tenths2);
			if (mainHumanPlayer != player2 || player2.GetDisplayName().Length < ProfileManager.MaxNameLength)
			{
				if ((bool)DriverObj)
				{
					DriverObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().text = player2.GetDisplayName();
				}
			}
			else
			{
				DriverObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().text = player2.GetDisplayName().Substring(0, ProfileManager.MaxNameLength);
				DriverObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().text += "..";
			}
			if (ColourIndicator != null && ColourIndicator.Length > 0 && (bool)ColourIndicator[player2.FinalPosition])
			{
				ColourIndicator[player2.FinalPosition].gameObject.SetActive(value: true);
				ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(player2.LocalPlayerIndex);
				UnityEngine.Color value = ((player2.GetPlayerType() == Player.PlayerType.Human) ? playerData.m_playerColours.HelmetPrimary : ((player2.GetPlayerType() != Player.PlayerType.Network) ? playerData.m_playerColours.HelmetPrimary : ProfileManager.CustomisationColours[player2.ResultsCol1]));
				ColourIndicator[player2.FinalPosition].material.SetColor("_Color3", value);
				value = ((player2.GetPlayerType() == Player.PlayerType.Human) ? playerData.m_playerColours.HelmetSecondary : ((player2.GetPlayerType() != Player.PlayerType.Network) ? playerData.m_playerColours.HelmetSecondary : ProfileManager.CustomisationColours[player2.ResultsCol2]));
				ColourIndicator[player2.FinalPosition].material.SetColor("_Color4", value);
			}
			if ((bool)TimeObj)
			{
				TimeObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().text = mins.ToString("00") + ":" + secs.ToString("00") + ":" + tenths.ToString("00");
			}
			if ((bool)AvgObj)
			{
				AvgObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().text = mins2.ToString("00") + ":" + secs2.ToString("00") + ":" + tenths2.ToString("00");
			}
			if (player2 == mainHumanPlayer)
			{
				if ((bool)DriverObj)
				{
					DriverObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
				}
				if ((bool)TimeObj)
				{
					TimeObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
				}
				if ((bool)AvgObj)
				{
					AvgObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
				}
			}
			else
			{
				if ((bool)DriverObj)
				{
					DriverObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().color = UnityEngine.Color.white;
				}
				if ((bool)TimeObj)
				{
					TimeObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().color = UnityEngine.Color.white;
				}
				if ((bool)AvgObj)
				{
					AvgObj.transform.GetChild(player2.FinalPosition + 1).GetComponent<Text>().color = UnityEngine.Color.white;
				}
			}
		}
	}

	private void UpdateOnlineStats()
	{
		if ((bool)ChampionPointsObj)
		{
			ChampionPointsObj.SetActive(value: true);
		}
		if ((bool)TimeObj)
		{
			TimeObj.SetActive(value: false);
		}
		if ((bool)AvgObj)
		{
			AvgObj.SetActive(value: false);
		}
		if ((bool)PosObj)
		{
			PosObj.SetActive(value: false);
		}
		if ((bool)DriverObj)
		{
			DriverObj.SetActive(value: false);
		}
		if ((bool)ChampionPointsObj)
		{
			ChampionPointsObj.SetActive(value: false);
		}
		if ((bool)OnlineDriverObj)
		{
			OnlineDriverObj.transform.GetChild(0).gameObject.SetActive(value: false);
		}
		if ((bool)OnlinePointsObj)
		{
			OnlinePointsObj.transform.GetChild(0).gameObject.SetActive(value: false);
		}
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player player = m_playerList[i];
			if (player == null)
			{
				continue;
			}
			ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(player.LocalPlayerIndex);
			if (player.PlayerFinishState == Player.PlayerFinishedState.InResults)
			{
				OnlineDriverObj.transform.GetChild(i + 1).gameObject.SetActive(value: true);
				OnlinePointsObj.transform.GetChild(i + 1).gameObject.SetActive(value: true);
				if (i == 0)
				{
					OnlineDriverObj.transform.GetChild(i + 1).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
					OnlinePointsObj.transform.GetChild(i + 1).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
				}
				else
				{
					OnlineDriverObj.transform.GetChild(i + 1).GetComponent<Text>().color = UnityEngine.Color.white;
					OnlinePointsObj.transform.GetChild(i + 1).GetComponent<Text>().color = UnityEngine.Color.white;
				}
				OnlineDriverObj.transform.GetChild(i + 1).GetComponent<Text>().text = player.OnlineID;
				UnityEngine.Color value = ((player.GetPlayerType() == Player.PlayerType.Human) ? playerData.m_playerColours.HelmetPrimary : ((player.GetPlayerType() != Player.PlayerType.Network) ? playerData.m_playerColours.HelmetPrimary : ProfileManager.CustomisationColours[player.ResultsCol1]));
				if (ColourIndicator[i] != null)
				{
					ColourIndicator[i].gameObject.SetActive(value: true);
					ColourIndicator[i].material.SetColor("_Color3", value);
					value = ((player.GetPlayerType() == Player.PlayerType.Human) ? playerData.m_playerColours.HelmetSecondary : ((player.GetPlayerType() != Player.PlayerType.Network) ? playerData.m_playerColours.HelmetSecondary : ProfileManager.CustomisationColours[player.ResultsCol2]));
					ColourIndicator[i].material.SetColor("_Color4", value);
				}
				OnlinePointsObj.transform.GetChild(i + 1).GetComponent<Text>().text = ResultsManager.Instance.GetOnlinePoints(player.OnlineID).ToString();
			}
		}
	}

	private void UpdateChampionStats()
	{
		if (!m_bringInOtherPlayers)
		{
			m_bringInOtherPlayers = true;
			ResultsManager.Instance.EndAllPlayersRace();
		}
		else
		{
			if (!ResultsManager.Instance.ChampPointsCountedUp)
			{
				return;
			}
			if ((bool)ChampionPointsObj)
			{
				ChampionPointsObj.SetActive(value: true);
			}
			if ((bool)TimeObj)
			{
				TimeObj.SetActive(value: false);
			}
			if ((bool)AvgObj)
			{
				AvgObj.SetActive(value: false);
			}
			if ((bool)PosObj)
			{
				PosObj.SetActive(value: false);
			}
			if ((bool)DriverObj)
			{
				DriverObj.transform.GetChild(0).gameObject.SetActive(value: false);
			}
			if ((bool)TracksRemainingObj)
			{
				int num = GameSystem.Instance.GetChampionshipMode().TracksRemaining();
				if (num > 0)
				{
					TracksRemainingObj.SetActive(value: true);
					TracksRemainingObj.GetComponent<Text>().text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_TracksRemaining", convertToUpperCase: true) + " : " + num;
				}
				else
				{
					TracksRemainingObj.SetActive(value: false);
				}
			}
			m_championDataList.Clear();
			for (int i = 0; i < m_playerList.Count; i++)
			{
				if (!(m_playerList[i] == null))
				{
					int championPoints = ProfileManager.Instance.GetPlayerData(i).m_championPoints;
					if (championPoints != 0)
					{
						ChampionData championData = new ChampionData();
						championData.index = i;
						championData.numPoints = -championPoints;
						m_championDataList.Add(championData);
					}
				}
			}
			m_championDataList.Sort();
			Player mainHumanPlayer = Gameplay.Instance.GetMainHumanPlayer();
			for (int j = 0; j < m_championDataList.Count; j++)
			{
				Player player = m_playerList[m_championDataList[j].index];
				GameSystem.Instance.GetChampionshipMode().SetLastDriverPosition(player.GetDisplayName(), j);
				if (player == mainHumanPlayer)
				{
					DriverObj.transform.GetChild(j + 1).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
					ChampionPointsObj.transform.GetChild(j + 1).GetComponent<Text>().color = new UnityEngine.Color(0.12156863f, 0.6f, 0.9372549f);
				}
				else
				{
					DriverObj.transform.GetChild(j + 1).GetComponent<Text>().color = UnityEngine.Color.white;
					ChampionPointsObj.transform.GetChild(j + 1).GetComponent<Text>().color = new UnityEngine.Color(4f / 85f, 0.8980392f, 26f / 51f, 1f);
				}
				DriverObj.transform.GetChild(j + 1).GetComponent<Text>().text = player.GetDisplayName();
				if ((bool)ColourIndicator[j])
				{
					ColourIndicator[j].gameObject.SetActive(value: true);
					ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(player.LocalPlayerIndex);
					UnityEngine.Color helmetPrimary = playerData.m_playerColours.HelmetPrimary;
					ColourIndicator[j].material.SetColor("_Color3", helmetPrimary);
					helmetPrimary = playerData.m_playerColours.HelmetSecondary;
					ColourIndicator[j].material.SetColor("_Color4", helmetPrimary);
				}
				ChampionPointsObj.transform.GetChild(j + 1).GetComponent<Text>().text = (0f - m_championDataList[j].numPoints).ToString();
			}
		}
	}

	private void UpdateWinner()
	{
		if (WinnerObj.activeSelf)
		{
			return;
		}
		for (int i = 0; i < ColourIndicator.Length; i++)
		{
			if ((bool)ColourIndicator[i])
			{
				ColourIndicator[i].gameObject.SetActive(value: false);
			}
		}
		ChampionPointsObj.SetActive(value: false);
		DriverObj.SetActive(value: false);
		PosObj.SetActive(value: false);
		if ((bool)TracksRemainingObj && TracksRemainingObj.activeSelf)
		{
			TracksRemainingObj.SetActive(value: false);
		}
		ResultsManager.Instance.SetWinner(m_playerList[m_championDataList[0].index]);
		WinnerObj.SetActive(value: true);
		WinnerObj.transform.GetChild(1).GetComponent<Text>().text = m_playerList[m_championDataList[0].index].GetDisplayName();
	}
}
public class ResultsTimer : UnityEngine.MonoBehaviour
{
	private float m_cutOff = 1f;

	private void Update()
	{
		base.gameObject.GetComponent<Renderer>().material.SetFloat("_Cutoff", m_cutOff);
	}

	public void SetTime(float time)
	{
		time = Mathf.Clamp(time, 0.05f, 1f);
		m_cutOff = time;
	}
}
public class Slider : UnityEngine.MonoBehaviour
{
	public GameObject SliderLevel;
}
public class Subtitles : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Text Textfield;

	[SerializeField]
	private UnityEngine.UI.Image Background;

	private StringTable m_stringTable;

	private string m_currentTranslation = string.Empty;

	private AudioSource m_currentAudioSource;

	private bool m_waitingForSpeech;

	public void SetText(AudioClip sfxClip, AudioSource sfxSource)
	{
		if ((bool)m_stringTable)
		{
			m_currentTranslation = m_stringTable.GetTranslationByIdentifier(sfxClip.name, convertToUpperCase: true);
			m_currentAudioSource = sfxSource;
			m_waitingForSpeech = true;
		}
	}

	private void Start()
	{
		m_stringTable = GameSystem.Instance.GetStringTable();
		Textfield.text = string.Empty;
		if ((bool)Background)
		{
			Background.gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (!m_currentAudioSource)
		{
			return;
		}
		if (m_waitingForSpeech)
		{
			if (m_currentAudioSource.isPlaying)
			{
				Textfield.text = m_currentTranslation;
				if ((bool)Background)
				{
					Background.gameObject.SetActive(value: true);
				}
				m_waitingForSpeech = false;
			}
		}
		else if (!m_currentAudioSource.isPlaying)
		{
			Textfield.text = string.Empty;
			if ((bool)Background)
			{
				Background.gameObject.SetActive(value: false);
			}
			m_currentTranslation = string.Empty;
			m_currentAudioSource = null;
		}
	}
}
public class Tablet : UnityEngine.MonoBehaviour
{
	private enum TabletState
	{
		None = -1,
		Intructions,
		OnlinePoints,
		Leaderboards
	}

	[SerializeField]
	private GameObject TabletObject;

	[SerializeField]
	private GameObject TabletScreen;

	[SerializeField]
	private GameObject TabletScreenPad;

	[SerializeField]
	private GameObject TabletScreenGo;

	[SerializeField]
	private Material TabletViveMat;

	[SerializeField]
	private FEMLeaderboard LeaderboardScreen;

	[SerializeField]
	private MeshRenderer LeftArrow;

	[SerializeField]
	private MeshRenderer RightArrow;

	[SerializeField]
	private float ScreenWidth = 1.14f;

	[SerializeField]
	private float InstructionYOffset;

	[SerializeField]
	private int MaxScreens = 2;

	[SerializeField]
	private float ScrollSpeed = 2f;

	[SerializeField]
	private Text ClockText;

	[SerializeField]
	private GameObject[] GreyOutTab;

	[SerializeField]
	private GameObject[] MenuShadowTab;

	[SerializeField]
	private GameObject[] PropMenuIconTab;

	[SerializeField]
	private GameObject[] MenuIcons;

	[SerializeField]
	private Transform UIScrollRoot;

	[SerializeField]
	private GameObject LeaderboardRoot;

	[SerializeField]
	private GameObject OnlinePointRoot;

	[SerializeField]
	private UnityEngine.UI.Image BatteryLevel;

	[SerializeField]
	private Text BatteryText;

	private Vector2 ButtonScaleMinMax = new Vector2(0.8091f, 0.89001f);

	private Vector2 ButtonPosMinMax = new Vector2(-11f, -14f);

	private TabletState m_state = TabletState.None;

	private int m_screenIndex = 1;

	private float m_originalXPos;

	private float m_currentXPos;

	private float m_leftArrowTargetAlpha = 1f;

	private float m_rightArrowTargetAlpha = 1f;

	private float m_leftArrowCurrentAlpha = 1f;

	private float m_rightArrowCurrentAlpha = 1f;

	private float m_waitForInitTimer = 2f;

	private bool m_inTransition;

	private float[] m_currentTabScale = new float[3];

	private float[] m_targetTabScale = new float[3];

	private float[] m_currentTabPosition = new float[3];

	private float[] m_targetTabPosition = new float[3];

	private GameObject m_lastSelectedObject;

	public GameObject GetLastSelectedObject()
	{
		return m_lastSelectedObject;
	}

	public void ResetLastSelectedObject()
	{
		m_lastSelectedObject = null;
	}

	private void OnEnable()
	{
		TabletState state = m_state;
		m_state = TabletState.None;
		SetState(state);
	}

	private void Start()
	{
		CameraManager.Instance.GetCameraByType(CameraManager.CameraType.TabletCamera).transform.parent = base.transform;
		CameraManager.Instance.GetCameraByType(CameraManager.CameraType.TabletCamera).transform.localPosition = Vector3.zero;
		m_screenIndex = 1;
		m_originalXPos = UIScrollRoot.transform.localPosition.x;
		m_currentXPos = m_originalXPos + (0f - ScreenWidth) * (float)m_screenIndex;
		if (m_screenIndex == 0)
		{
			m_leftArrowTargetAlpha = 1f;
			m_rightArrowTargetAlpha = 0f;
		}
		else if (m_screenIndex == MaxScreens - 1)
		{
			m_leftArrowTargetAlpha = 0f;
			m_rightArrowTargetAlpha = 1f;
		}
		else
		{
			m_leftArrowTargetAlpha = 1f;
			m_rightArrowTargetAlpha = 1f;
		}
		for (int i = 0; i < 3; i++)
		{
			m_currentTabScale[i] = ((i != 0) ? ButtonScaleMinMax.x : ButtonScaleMinMax.y);
			m_targetTabScale[i] = ((i != 0) ? ButtonScaleMinMax.x : ButtonScaleMinMax.y);
			m_currentTabPosition[i] = ((i != 0) ? ButtonPosMinMax.y : ButtonPosMinMax.x);
			m_targetTabPosition[i] = ((i != 0) ? ButtonPosMinMax.y : ButtonPosMinMax.x);
		}
		SetState(TabletState.Intructions);
	}

	private void SetState(TabletState state)
	{
		if (m_state != state)
		{
			m_state = state;
			switch (m_state)
			{
			case TabletState.Intructions:
				m_inTransition = true;
				m_screenIndex = 0;
				break;
			case TabletState.OnlinePoints:
				m_inTransition = true;
				m_screenIndex = 1;
				LeaderboardScreen.SetType(NetworkLeaderboards.LeaderboardType.OnlinePoints);
				LeaderboardScreen.ClearLeaderboard();
				break;
			case TabletState.Leaderboards:
				m_inTransition = true;
				m_screenIndex = 2;
				LeaderboardScreen.SetType(NetworkLeaderboards.LeaderboardType.QuickPlay);
				LeaderboardScreen.SetupLeaderboardWithCurrentEnv();
				break;
			}
			if (MenuShadowTab.Length > 0)
			{
				MenuShadowTab[0].SetActive(m_state == TabletState.Intructions);
				MenuShadowTab[1].SetActive(m_state == TabletState.OnlinePoints);
				MenuShadowTab[2].SetActive(m_state == TabletState.Leaderboards);
			}
			if (m_targetTabScale.Length > 0)
			{
				m_targetTabScale[0] = ((m_state != 0) ? ButtonScaleMinMax.x : ButtonScaleMinMax.y);
				m_targetTabScale[1] = ((m_state != TabletState.OnlinePoints) ? ButtonScaleMinMax.x : ButtonScaleMinMax.y);
				m_targetTabScale[2] = ((m_state != TabletState.Leaderboards) ? ButtonScaleMinMax.x : ButtonScaleMinMax.y);
			}
			if (m_targetTabPosition.Length > 0)
			{
				m_targetTabPosition[0] = ((m_state != 0) ? ButtonPosMinMax.y : ButtonPosMinMax.x);
				m_targetTabPosition[1] = ((m_state != TabletState.OnlinePoints) ? ButtonPosMinMax.y : ButtonPosMinMax.x);
				m_targetTabPosition[2] = ((m_state != TabletState.Leaderboards) ? ButtonPosMinMax.y : ButtonPosMinMax.x);
			}
		}
	}

	private void Update()
	{
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		if (m_waitForInitTimer > 0f && FadeManager.Instance.FinishedFading())
		{
			m_waitForInitTimer -= GameTime.Instance.DeltaTime();
			if (m_waitForInitTimer <= 0f)
			{
				if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.ConnectedToMaster() && (bool)ProfileManager.Instance && ProfileManager.Instance.FTUE == 0)
				{
					SetState(TabletState.OnlinePoints);
				}
				else
				{
					SetState(TabletState.Intructions);
				}
			}
		}
		if (m_inTransition)
		{
			float num = (m_currentXPos = m_originalXPos + (0f - ScreenWidth) * (float)m_screenIndex);
			m_inTransition = false;
			if (Mathf.Abs(num - m_currentXPos) < 0.1f)
			{
				m_currentXPos = num;
				m_inTransition = false;
			}
			UIScrollRoot.transform.localPosition = new Vector3(m_currentXPos, InstructionYOffset, 1f);
		}
		if (m_state == TabletState.Intructions)
		{
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.PadControl)
			{
				if (!TabletScreenPad.activeSelf)
				{
					TabletScreenPad.SetActive(value: true);
					TabletScreen.SetActive(value: false);
					TabletScreenGo.SetActive(value: false);
				}
			}
			else if (GameSystem.Instance.IsOculusGo())
			{
				if (!TabletScreenGo.activeSelf)
				{
					TabletScreenGo.SetActive(value: true);
					TabletScreen.SetActive(value: false);
					TabletScreenPad.SetActive(value: false);
				}
			}
			else if (!TabletScreen.activeSelf)
			{
				TabletScreen.SetActive(value: true);
				TabletScreenPad.SetActive(value: false);
				TabletScreenGo.SetActive(value: false);
			}
		}
		else
		{
			if (TabletScreen.activeSelf)
			{
				TabletScreen.SetActive(value: false);
			}
			if (TabletScreenPad.activeSelf)
			{
				TabletScreenPad.SetActive(value: false);
			}
			if (TabletScreenGo.activeSelf)
			{
				TabletScreenGo.SetActive(value: false);
			}
		}
		switch (m_state)
		{
		case TabletState.Intructions:
			if (!m_inTransition)
			{
				if (LeaderboardScreen.gameObject.activeSelf)
				{
					LeaderboardScreen.gameObject.SetActive(value: false);
				}
				if (LeaderboardRoot.activeSelf)
				{
					LeaderboardRoot.SetActive(value: false);
				}
				if (OnlinePointRoot.activeSelf)
				{
					OnlinePointRoot.SetActive(value: false);
				}
			}
			break;
		case TabletState.OnlinePoints:
		case TabletState.Leaderboards:
			if (!LeaderboardScreen.gameObject.activeSelf)
			{
				LeaderboardScreen.gameObject.SetActive(value: true);
			}
			if (m_inTransition)
			{
				break;
			}
			if (TabletScreen.activeSelf)
			{
				TabletScreen.SetActive(value: false);
			}
			if (TabletScreenPad.activeSelf)
			{
				TabletScreenPad.SetActive(value: false);
			}
			if (TabletScreenGo.activeSelf)
			{
				TabletScreenGo.SetActive(value: false);
			}
			if (m_state == TabletState.OnlinePoints)
			{
				if (LeaderboardRoot.activeSelf)
				{
					LeaderboardRoot.SetActive(value: false);
				}
				if (!OnlinePointRoot.activeSelf)
				{
					OnlinePointRoot.SetActive(value: true);
				}
			}
			else if (m_state == TabletState.Leaderboards)
			{
				if (!LeaderboardRoot.activeSelf)
				{
					LeaderboardRoot.SetActive(value: true);
				}
				if (OnlinePointRoot.activeSelf)
				{
					OnlinePointRoot.SetActive(value: false);
				}
			}
			break;
		}
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.ConnectedToMaster() && (bool)ProfileManager.Instance && ProfileManager.Instance.FTUE == 0 && IsTabletVisible())
		{
			if (InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
			{
				UpdatePointer();
			}
			else
			{
				UpdatePadControls();
			}
		}
		UpdateUI();
		UpdateArrows();
		UpdateUIText();
		UpdateBatteryLevel();
	}

	private void UpdatePointer()
	{
		Transform controllerSpot = FEMManager.Instance.GetControllerSpot();
		if (!controllerSpot)
		{
			return;
		}
		Vector3 normalized = (controllerSpot.position - CameraManager.Instance.GetCurrentCamera().transform.position).normalized;
		Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, normalized);
		if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("UI")))
		{
			int num = 0;
			for (num = 0; num < MenuIcons.Length; num++)
			{
				if (!(hitInfo.collider.gameObject == MenuIcons[num]))
				{
					continue;
				}
				if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
				{
					FEMManager.Instance.PlayAudio(FEMManager.FEMAudioClip.OptionHighlight);
					switch (num)
					{
					case 0:
						SetState(TabletState.Intructions);
						break;
					case 1:
						SetState(TabletState.OnlinePoints);
						break;
					case 2:
						SetState(TabletState.Leaderboards);
						break;
					}
				}
				break;
			}
			if (num == MenuIcons.Length)
			{
				m_lastSelectedObject = hitInfo.collider.gameObject;
			}
			else
			{
				m_lastSelectedObject = null;
			}
		}
		else
		{
			m_lastSelectedObject = null;
		}
	}

	private void UpdatePadControls()
	{
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Shop_Left))
		{
			if (m_state == TabletState.Leaderboards)
			{
				SetState(TabletState.OnlinePoints);
			}
			else if (m_state == TabletState.OnlinePoints)
			{
				SetState(TabletState.Intructions);
			}
		}
		else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Shop_Right))
		{
			if (m_state == TabletState.Intructions)
			{
				SetState(TabletState.OnlinePoints);
			}
			else if (m_state == TabletState.OnlinePoints)
			{
				SetState(TabletState.Leaderboards);
			}
		}
	}

	private void UpdateUI()
	{
		if ((bool)NetworkLogin.Instance && !NetworkLogin.Instance.ConnectedToMaster())
		{
			if (PropMenuIconTab[0].gameObject.activeSelf)
			{
				for (int i = 0; i < 3; i++)
				{
					PropMenuIconTab[i].gameObject.SetActive(value: false);
				}
			}
		}
		else if (!PropMenuIconTab[0].gameObject.activeSelf)
		{
			for (int j = 0; j < 3; j++)
			{
				PropMenuIconTab[j].gameObject.SetActive(value: true);
			}
		}
		if (PropMenuIconTab.Length > 0)
		{
			for (int k = 0; k < 3; k++)
			{
				m_currentTabScale[k] = Mathf.Lerp(m_currentTabScale[k], m_targetTabScale[k], 8f * GameTime.Instance.DeltaTime());
				PropMenuIconTab[k].transform.localScale = new Vector3(m_currentTabScale[k], m_currentTabScale[k], m_currentTabScale[k]);
				m_currentTabPosition[k] = Mathf.Lerp(m_currentTabPosition[k], m_targetTabPosition[k], 8f * GameTime.Instance.DeltaTime());
				PropMenuIconTab[k].transform.localPosition = new Vector3(PropMenuIconTab[k].transform.localPosition.x, m_currentTabPosition[k], PropMenuIconTab[k].transform.localPosition.z);
			}
		}
	}

	private void UpdateArrows()
	{
	}

	private bool IsTabletVisible()
	{
		Vector3 direction = base.transform.TransformDirection(CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward);
		Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().transform.position, direction);
		if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("FrontendScenery")))
		{
			return hitInfo.collider == TabletObject.GetComponent<BoxCollider>();
		}
		return false;
	}

	private void UpdateUIText()
	{
		ClockText.text = DateTime.Now.Hour.ToString("00") + ":" + DateTime.Now.Minute.ToString("00");
	}

	private void UpdateBatteryLevel()
	{
		float batteryLevel = OVRManager.batteryLevel;
		BatteryText.text = (int)(batteryLevel * 100f) + "%";
		BatteryLevel.transform.localScale = new Vector3(batteryLevel * 7.7f, BatteryLevel.transform.localScale.y, BatteryLevel.transform.localScale.z);
	}
}
public class ToyKartColours : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private MeshRenderer Driver;

	[SerializeField]
	private MeshRenderer Kart;

	[SerializeField]
	private MeshRenderer PlayerRacer;

	[SerializeField]
	private MeshRenderer RacerLegs;

	private UnityEngine.Color m_helmetPrimaryCol;

	private UnityEngine.Color m_helmetSecondaryCol;

	private UnityEngine.Color m_driverPrimaryCol;

	private UnityEngine.Color m_driverSecondaryCol;

	private UnityEngine.Color m_kartPrimaryCol;

	private UnityEngine.Color m_kartSecondaryCol;

	private void Update()
	{
		UpdateColours();
	}

	public void UpdateColours()
	{
		ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(0);
		if ((bool)Driver)
		{
			if (m_helmetPrimaryCol != playerData.m_playerColours.HelmetPrimary)
			{
				m_helmetPrimaryCol = playerData.m_playerColours.HelmetPrimary;
				Driver.material.SetColor("_Color3", m_helmetPrimaryCol);
			}
			if (m_helmetSecondaryCol != playerData.m_playerColours.HelmetSecondary)
			{
				m_helmetSecondaryCol = playerData.m_playerColours.HelmetSecondary;
				Driver.material.SetColor("_Color4", m_helmetSecondaryCol);
			}
			if (m_driverPrimaryCol != playerData.m_playerColours.RacerPrimary)
			{
				m_driverPrimaryCol = playerData.m_playerColours.RacerPrimary;
				Driver.material.SetColor("_Color1", m_driverPrimaryCol);
				if ((bool)PlayerRacer)
				{
					PlayerRacer.material.SetColor("_Color1", m_driverPrimaryCol);
				}
				if ((bool)RacerLegs)
				{
					RacerLegs.material.SetColor("_Color1", m_driverPrimaryCol);
				}
			}
			if (m_driverSecondaryCol != playerData.m_playerColours.RacerSecondary)
			{
				m_driverSecondaryCol = playerData.m_playerColours.RacerSecondary;
				Driver.material.SetColor("_Color2", m_driverSecondaryCol);
				if ((bool)PlayerRacer)
				{
					PlayerRacer.material.SetColor("_Color2", m_driverSecondaryCol);
				}
				if ((bool)RacerLegs)
				{
					RacerLegs.material.SetColor("_Color2", m_driverSecondaryCol);
				}
			}
		}
		if ((bool)Kart)
		{
			if (m_kartPrimaryCol != playerData.m_playerColours.KartPrimary)
			{
				m_kartPrimaryCol = playerData.m_playerColours.KartPrimary;
				Kart.material.SetColor("_Color5", m_kartPrimaryCol);
			}
			if (m_kartSecondaryCol != playerData.m_playerColours.KartSecondary)
			{
				m_kartSecondaryCol = playerData.m_playerColours.KartSecondary;
				Kart.material.SetColor("_Color6", m_kartSecondaryCol);
			}
		}
	}
}
public class TrackList : UnityEngine.MonoBehaviour
{
	public enum WeatherType
	{
		Sunny,
		Snowy,
		Rainy,
		Blizzard
	}

	public struct TrackData
	{
		public string Name;

		public string EnglishName;

		public string ThumbNailPath;

		public string Env;

		public string Scene;

		public bool HideTrack;

		public bool EnableHeadlights;

		public int ChampionshipType;

		public int TrophyGrouping;

		public int TrophyIndex;

		public bool BombTrack;

		public bool AllowedOnline;

		public int AISpeedIncrease;

		public string NormalAIKartSpeed;

		public string TurboAIKartSpeed;

		public WeatherType TrackWeather;
	}

	public static string[] WeatherTypeText = new string[4] { "Sunny", "Snowy", "Rainy", "Blizzard" };

	private const float DefaultNormalKartSpeed = 70f;

	private const float DefaultTurboKartSpeed = 95f;

	private List<TrackData> m_trackDataList = new List<TrackData>();

	private bool m_getEnglishNames;

	private void Update()
	{
		if (!m_getEnglishNames)
		{
			m_getEnglishNames = true;
			for (int i = 0; i < m_trackDataList.Count; i++)
			{
				TrackData value = m_trackDataList[i];
				value.EnglishName = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(m_trackDataList[i].Name);
				m_trackDataList[i] = value;
			}
		}
	}

	public static void CreateTracksForEditor(string filePath, ref List<TrackData> tracks)
	{
		bool flag = false;
		int num = 1;
		ParseTracks(ref tracks);
		do
		{
			string text = "\\Env" + num;
			flag = Directory.Exists(filePath + text);
			if (!flag)
			{
				continue;
			}
			DirectoryInfo directoryInfo = new DirectoryInfo(filePath + text);
			FileInfo[] files = directoryInfo.GetFiles();
			if (files.Length > 0)
			{
				FileInfo[] array = files;
				foreach (FileInfo fileInfo in array)
				{
					if (fileInfo.Extension == ".unity")
					{
						string text2 = fileInfo.Name;
						text2 = text2.Remove(text2.Length - fileInfo.Extension.Length);
						int num2 = 0;
						for (num2 = 0; num2 < tracks.Count && !(tracks[num2].Scene == text2); num2++)
						{
						}
						if (num2 == tracks.Count)
						{
							TrackData item = default(TrackData);
							item.Name = text2;
							item.Scene = text2;
							item.ThumbNailPath = string.Empty;
							item.Env = "Env" + num;
							item.HideTrack = false;
							item.EnableHeadlights = true;
							item.ChampionshipType = 0;
							item.TrophyGrouping = 0;
							item.TrophyIndex = 0;
							item.BombTrack = false;
							item.AllowedOnline = false;
							item.NormalAIKartSpeed = 70f.ToString();
							item.TurboAIKartSpeed = 95f.ToString();
							item.TrackWeather = WeatherType.Sunny;
							item.AISpeedIncrease = 0;
							tracks.Add(item);
						}
					}
				}
			}
			num++;
		}
		while (flag);
	}

	public static void CreateTrackList(ref List<TrackData> tracks)
	{
		FileStream fileStream = new FileStream("Assets\\Game\\Resources\\Tracks.xml", FileMode.Create);
		XmlTextWriter xmlTextWriter = new XmlTextWriter(fileStream, Encoding.UTF8);
		xmlTextWriter.Formatting = System.Xml.Formatting.Indented;
		xmlTextWriter.Indentation = 4;
		xmlTextWriter.WriteStartDocument();
		xmlTextWriter.WriteStartElement("TrackList");
		foreach (TrackData track in tracks)
		{
			xmlTextWriter.WriteStartElement("Track");
			xmlTextWriter.WriteAttributeString("Name", track.Name);
			xmlTextWriter.WriteAttributeString("Scene", track.Scene);
			xmlTextWriter.WriteAttributeString("Env", track.Env);
			xmlTextWriter.WriteAttributeString("ThumbNail", track.ThumbNailPath);
			xmlTextWriter.WriteAttributeString("HideTrack", (!track.HideTrack) ? "0" : "1");
			xmlTextWriter.WriteAttributeString("EnableHeadlights", (!track.EnableHeadlights) ? "0" : "1");
			int championshipType = track.ChampionshipType;
			xmlTextWriter.WriteAttributeString("ChampionshipType", championshipType.ToString());
			int trophyGrouping = track.TrophyGrouping;
			xmlTextWriter.WriteAttributeString("TrophyGrouping", trophyGrouping.ToString());
			xmlTextWriter.WriteAttributeString("TrophyIndex", track.TrophyIndex.ToString());
			xmlTextWriter.WriteAttributeString("BombTrack", (!track.BombTrack) ? "0" : "1");
			xmlTextWriter.WriteAttributeString("AllowedOnline", (!track.AllowedOnline) ? "0" : "1");
			xmlTextWriter.WriteAttributeString("AISpeedIncrease", track.AISpeedIncrease.ToString());
			xmlTextWriter.WriteAttributeString("NormalAIKartSpeed", track.NormalAIKartSpeed.ToString());
			xmlTextWriter.WriteAttributeString("TurboAIKartSpeed", track.TurboAIKartSpeed.ToString());
			int trackWeather = (int)track.TrackWeather;
			xmlTextWriter.WriteAttributeString("TrackWeather", trackWeather.ToString());
			xmlTextWriter.WriteEndElement();
		}
		xmlTextWriter.WriteEndElement();
		xmlTextWriter.Flush();
		fileStream.Close();
	}

	public void ParseTracksIntoTracklist()
	{
		if (m_trackDataList.Count <= 0)
		{
			ParseTracks(ref m_trackDataList);
		}
	}

	public static void ParseTracks(ref List<TrackData> trackList)
	{
		string path = "Tracks";
		TextAsset textAsset = (TextAsset)Resources.Load(path);
		int num = 0;
		if (textAsset == null)
		{
			return;
		}
		XmlDocument xmlDocument = new XmlDocument();
		xmlDocument.LoadXml(textAsset.text);
		XmlNodeList xmlNodeList = xmlDocument.SelectNodes("TrackList");
		xmlNodeList = xmlNodeList[0].ChildNodes;
		for (int i = 0; i < xmlNodeList.Count; i++)
		{
			TrackData item = default(TrackData);
			int num2 = 0;
			item.Name = xmlNodeList[i].Attributes["Name"].Value;
			item.Env = xmlNodeList[i].Attributes["Env"].Value;
			item.Scene = xmlNodeList[i].Attributes["Scene"].Value;
			item.ThumbNailPath = string.Empty;
			if (xmlNodeList[i].Attributes["ThumbNail"] != null)
			{
				item.ThumbNailPath = xmlNodeList[i].Attributes["ThumbNail"].Value;
			}
			item.HideTrack = false;
			if (xmlNodeList[i].Attributes["HideTrack"] != null)
			{
				item.HideTrack = xmlNodeList[i].Attributes["HideTrack"].Value == "1";
			}
			item.EnableHeadlights = false;
			if (xmlNodeList[i].Attributes["EnableHeadlights"] != null)
			{
				item.EnableHeadlights = xmlNodeList[i].Attributes["EnableHeadlights"].Value == "1";
			}
			item.TrophyGrouping = 0;
			if (xmlNodeList[i].Attributes["ChampionshipType"] != null)
			{
				int championshipType = int.Parse(xmlNodeList[i].Attributes["ChampionshipType"].Value);
				item.ChampionshipType = championshipType;
			}
			item.TrophyGrouping = 0;
			if (xmlNodeList[i].Attributes["TrophyGrouping"] != null)
			{
				int trophyGrouping = int.Parse(xmlNodeList[i].Attributes["TrophyGrouping"].Value);
				item.TrophyGrouping = trophyGrouping;
				num2++;
			}
			if (xmlNodeList[i].Attributes["TrophyIndex"] != null)
			{
				int trophyIndex = int.Parse(xmlNodeList[i].Attributes["TrophyIndex"].Value);
				item.TrophyIndex = trophyIndex;
				num2++;
			}
			item.BombTrack = false;
			if (xmlNodeList[i].Attributes["BombTrack"] != null)
			{
				item.BombTrack = xmlNodeList[i].Attributes["BombTrack"].Value == "1";
			}
			item.AllowedOnline = false;
			if (xmlNodeList[i].Attributes["AllowedOnline"] != null)
			{
				item.AllowedOnline = xmlNodeList[i].Attributes["AllowedOnline"].Value == "1";
			}
			item.AISpeedIncrease = 0;
			if (xmlNodeList[i].Attributes["AISpeedIncrease"] != null)
			{
				item.AISpeedIncrease = int.Parse(xmlNodeList[i].Attributes["AISpeedIncrease"].Value);
			}
			if ((bool)GameSystem.Instance && (bool)GameSystem.Instance.GetChampionshipMode())
			{
				if (!item.HideTrack && num2 == 2 && item.TrophyGrouping != 0)
				{
					GameSystem.Instance.GetChampionshipMode().AddLevelName((ChampionshipMode.TrophyChampionshipType)item.ChampionshipType, (ChampionshipMode.TrophyGroupingType)item.TrophyGrouping, item.TrophyIndex, item.Name);
				}
				else if (!item.HideTrack && !item.BombTrack)
				{
					GameSystem.Instance.GetChampionshipMode().AddLevelName((ChampionshipMode.TrophyChampionshipType)item.ChampionshipType, ChampionshipMode.TrophyGroupingType.MaxUserLevels, num++, item.Name);
				}
			}
			item.NormalAIKartSpeed = 70f.ToString();
			if (xmlNodeList[i].Attributes["NormalAIKartSpeed"] != null)
			{
				item.NormalAIKartSpeed = xmlNodeList[i].Attributes["NormalAIKartSpeed"].Value;
			}
			item.TurboAIKartSpeed = 95f.ToString();
			if (xmlNodeList[i].Attributes["TurboAIKartSpeed"] != null)
			{
				item.TurboAIKartSpeed = xmlNodeList[i].Attributes["TurboAIKartSpeed"].Value;
			}
			item.TrackWeather = WeatherType.Sunny;
			if (xmlNodeList[i].Attributes["TrackWeather"] != null)
			{
				int trackWeather = int.Parse(xmlNodeList[i].Attributes["TrackWeather"].Value);
				item.TrackWeather = (WeatherType)trackWeather;
			}
			trackList.Add(item);
		}
	}

	public TrackData GetTrackByString(string title)
	{
		foreach (TrackData trackData in m_trackDataList)
		{
			if (trackData.Name == title)
			{
				return trackData;
			}
		}
		return m_trackDataList[0];
	}

	public int GetNumTracksByEnv(string envString)
	{
		int num = 0;
		for (int i = 0; i < m_trackDataList.Count; i++)
		{
			if (m_trackDataList[i].Env == envString && !m_trackDataList[i].HideTrack && !m_trackDataList[i].BombTrack)
			{
				num++;
			}
		}
		return num;
	}

	public void GetTracksByEnv(ref List<TrackData> tracks, string envString)
	{
		for (int i = 0; i < m_trackDataList.Count; i++)
		{
			if (m_trackDataList[i].Env == envString && !m_trackDataList[i].HideTrack && !m_trackDataList[i].BombTrack)
			{
				tracks.Add(m_trackDataList[i]);
			}
		}
	}

	public TrackData GetTrackByString(string title, ref int index)
	{
		for (int i = 0; i < m_trackDataList.Count; i++)
		{
			if (m_trackDataList[i].Name == title)
			{
				index = i;
				return m_trackDataList[i];
			}
		}
		index = -1;
		return m_trackDataList[0];
	}

	public TrackData GetTrackBySceneName(string title)
	{
		if (m_trackDataList.Count == 0)
		{
			ParseTracksIntoTracklist();
		}
		foreach (TrackData trackData in m_trackDataList)
		{
			if (trackData.Scene == title)
			{
				return trackData;
			}
		}
		return m_trackDataList[0];
	}

	public int GetTrackIndexBySceneName(string title)
	{
		for (int i = 0; i < m_trackDataList.Count; i++)
		{
			if (m_trackDataList[i].Scene == title)
			{
				return i;
			}
		}
		return 0;
	}

	public TrackData GetTrackByIndex(int index)
	{
		return m_trackDataList[index];
	}

	public int GetTotalTracks()
	{
		return m_trackDataList.Count;
	}
}
public class GameEntry : UnityEngine.MonoBehaviour
{
	public enum GameState
	{
		None = -1,
		Splash,
		Frontend,
		Game,
		Loading
	}

	private enum FinishedLoadingStatus
	{
		WaitForLoad,
		Loading,
		FalseWait,
		Activation_PreWait,
		Activation,
		WaitForActivationEnd,
		Finished,
		Deactivate
	}

	public static GameEntry Instance;

	[SerializeField]
	public string FEMRootName = "FEMRoot";

	[SerializeField]
	public string GameRootName = "GameRoot";

	[SerializeField]
	public string SplashRootName = "SplashRoot";

	[SerializeField]
	private GameObject LoadingRoom;

	public float FalseWaitTime = 2.5f;

	[SerializeField]
	private float FalseWaitTimeDemo = 4f;

	[SerializeField]
	private Texture SteamVRLoadingScreenTexture;

	[SerializeField]
	private GameObject SteamVRLoadingScreenPlacement;

	private GameState m_gameState = GameState.None;

	private GameState m_pendingState = GameState.None;

	private GameState m_lastState = GameState.None;

	private LaunchDetails m_launchDetails;

	private string m_deeplinkMessage = string.Empty;

	private UnityEngine.AsyncOperation m_loadingStatus;

	private int m_loadingDelay = -1;

	private bool m_loadingLevelBegin;

	private float m_falseWaitTime;

	private bool m_waitForResults;

	private bool m_loadingSteamLevel;

	private FinishedLoadingStatus m_finishStatus = FinishedLoadingStatus.Finished;

	public bool FinishedLoading()
	{
		return m_finishStatus == FinishedLoadingStatus.Finished || m_finishStatus == FinishedLoadingStatus.Deactivate;
	}

	public bool IsLoading()
	{
		return m_gameState == GameState.Loading;
	}

	public GameState GetCurrentState()
	{
		if (m_gameState == GameState.Loading)
		{
			return m_lastState;
		}
		return m_gameState;
	}

	public GameState GetPendingState()
	{
		return m_pendingState;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		Screen.fullScreen = true;
		LoadSplash();
		m_launchDetails = new LaunchDetails(CAPI.ovr_ApplicationLifecycle_GetLaunchDetails());
		if (m_launchDetails.LaunchType == LaunchType.Deeplink)
		{
			m_deeplinkMessage = m_launchDetails.DeeplinkMessage;
		}
		UnityEngine.Application.runInBackground = true;
		if (!UnityEngine.Application.isEditor)
		{
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
		}
	}

	private void Update()
	{
		switch (m_finishStatus)
		{
		case FinishedLoadingStatus.WaitForLoad:
			if ((m_loadingStatus != null || m_loadingSteamLevel) && m_loadingLevelBegin)
			{
				m_finishStatus = FinishedLoadingStatus.Loading;
			}
			break;
		case FinishedLoadingStatus.Loading:
			if (m_waitForResults && m_loadingStatus != null && m_loadingStatus.isDone)
			{
				m_waitForResults = false;
				StartCoroutine(LoadLevel(GameSystem.Instance.GetLoadedTrack().Scene, allowActivation: false));
			}
			if (m_loadingStatus != null && !m_loadingStatus.allowSceneActivation && m_loadingStatus.progress >= 0.9f)
			{
				StartLoadingRoom();
				m_finishStatus = FinishedLoadingStatus.FalseWait;
				m_falseWaitTime = FalseWaitTime;
				GameSystem.Instance.WasInGame = false;
				if (m_gameState == GameState.Frontend && (((bool)FTUE.Instance && FTUE.Instance.State != 0) || ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())))
				{
					DestroyGame();
				}
			}
			break;
		case FinishedLoadingStatus.FalseWait:
			if (LoadingRoom.GetComponent<LoadingRoom>().IsFinished() && FadeManager.Instance.FinishedFading())
			{
				m_falseWaitTime -= Time.deltaTime;
				if (m_falseWaitTime <= 0f)
				{
					FadeManager.Instance.FadeOut();
					m_falseWaitTime = 0.5f;
					m_finishStatus = FinishedLoadingStatus.Activation_PreWait;
				}
			}
			break;
		case FinishedLoadingStatus.Activation_PreWait:
			if (FadeManager.Instance.FinishedFading())
			{
				m_falseWaitTime -= Time.deltaTime;
				if (m_falseWaitTime <= 0f)
				{
					m_finishStatus = FinishedLoadingStatus.Activation;
				}
			}
			break;
		case FinishedLoadingStatus.Activation:
			if (FadeManager.Instance.FinishedFading())
			{
				m_loadingStatus.allowSceneActivation = true;
				m_finishStatus = FinishedLoadingStatus.WaitForActivationEnd;
			}
			break;
		case FinishedLoadingStatus.WaitForActivationEnd:
			if (LoadingRoom != null && LoadingRoom.activeSelf && m_loadingStatus != null && m_loadingStatus.isDone)
			{
				m_finishStatus = FinishedLoadingStatus.Finished;
			}
			break;
		case FinishedLoadingStatus.Finished:
			CameraManager.Instance.GetCurrentCamera().transform.parent = null;
			CameraManager.Instance.GetCurrentCamera().transform.localPosition = Vector3.zero;
			LoadingRoom.gameObject.SetActive(value: false);
			m_finishStatus = FinishedLoadingStatus.Deactivate;
			break;
		}
		GameState gameState = m_gameState;
		if (gameState != GameState.Loading || !FadeManager.Instance.FinishedFading())
		{
			return;
		}
		if (m_loadingDelay == -1)
		{
			if (CameraManager.Instance != null)
			{
				m_loadingLevelBegin = false;
				m_loadingDelay = 6;
				CameraManager.Instance.ResetAllCameras();
				if (m_pendingState == GameState.Splash)
				{
					m_finishStatus = FinishedLoadingStatus.Deactivate;
				}
				else
				{
					m_finishStatus = FinishedLoadingStatus.WaitForLoad;
				}
			}
		}
		else
		{
			m_loadingDelay--;
			if (m_loadingDelay == 0)
			{
				m_loadingDelay = -1;
				GC.Collect();
				SetGameState(m_pendingState);
				SetPendingState(GameState.None);
			}
		}
	}

	private void SetPendingState(GameState state)
	{
		m_pendingState = state;
	}

	private void SetGameState(GameState state)
	{
		m_lastState = m_gameState;
		m_gameState = state;
		switch (state)
		{
		case GameState.Loading:
			FadeManager.Instance.FadeOut();
			break;
		case GameState.Splash:
			StartCoroutine(LoadLevel("Splash", allowActivation: true));
			break;
		case GameState.Frontend:
			DestroySplash();
			DestroyCurrentScenes();
			StartCoroutine(LoadLevel("FEMMain", allowActivation: false));
			break;
		case GameState.Game:
			DestroyCurrentScenes();
			m_waitForResults = true;
			StartCoroutine(LoadLevel("Results", allowActivation: true));
			break;
		}
	}

	public void LoadSplash()
	{
		if (m_pendingState == GameState.None && m_gameState != GameState.Loading)
		{
			SetGameState(GameState.Loading);
			SetPendingState(GameState.Splash);
		}
	}

	public void LoadFEM()
	{
		if (m_pendingState == GameState.None && m_gameState != GameState.Loading)
		{
			SetGameState(GameState.Loading);
			SetPendingState(GameState.Frontend);
			GameSystem.Instance.PlayingGame = false;
		}
	}

	public void LoadGame()
	{
		if (m_pendingState == GameState.None && m_gameState != GameState.Loading)
		{
			SetGameState(GameState.Loading);
			SetPendingState(GameState.Game);
			GameSystem.Instance.PlayingGame = true;
		}
	}

	private void DestroySplash()
	{
		GameObject gameObject = GameObject.Find(SplashRootName);
		if ((bool)gameObject)
		{
			UnityEngine.Object.Destroy(gameObject);
			SceneManager.UnloadScene(gameObject.scene);
		}
	}

	private void DestroyCurrentScenes()
	{
		DestroyFEM();
		DestroyGame();
		LightmapSettings.lightmaps = new LightmapData[0];
		Resources.UnloadUnusedAssets();
	}

	private void DestroyFEM()
	{
		GameObject gameObject = GameObject.Find(FEMRootName);
		if ((bool)gameObject)
		{
			UnityEngine.Object.Destroy(gameObject);
			SceneManager.UnloadScene(gameObject.scene);
		}
	}

	private void StartLoadingRoom()
	{
		LoadingRoom.gameObject.SetActive(value: true);
		LoadingRoom.GetComponent<LoadingRoom>().InitialiseLoading();
		CameraManager.Instance.SetNewTransform(LoadingRoom.transform);
	}

	public void DestroyGame()
	{
		GameObject gameObject = GameObject.Find(GameRootName);
		if ((bool)gameObject)
		{
			UnityEngine.Object.Destroy(gameObject);
			SceneManager.UnloadScene(gameObject.scene);
		}
	}

	private IEnumerator LoadLevel(string levelName, bool allowActivation)
	{
		m_loadingLevelBegin = true;
		m_loadingStatus = UnityEngine.Application.LoadLevelAdditiveAsync(levelName);
		m_loadingStatus.allowSceneActivation = allowActivation;
		yield return m_loadingStatus;
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		GameSystem.Instance.ApplicationPaused = pauseStatus;
		if (pauseStatus && (bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			PhotonNetwork.Disconnect();
		}
	}
}
public class Animate : UnityEngine.MonoBehaviour
{
	private float bounce;

	public Texture2D texture;

	public readonly UnityEngine.Color color = UnityEngine.Color.yellow;

	public Vector3 Position => new Vector3(base.transform.position.x, base.transform.position.y + bounce, base.transform.position.z);

	private void Start()
	{
		GetComponent<Renderer>().material.color = color;
	}

	private void Update()
	{
		float f = Time.time * 3f + Position.x * -0.75f;
		bounce = Mathf.Sin(f) * 0.0001f * (float)texture.height;
		base.transform.position = Position;
	}
}
public class AnimateTiledTexture : UnityEngine.MonoBehaviour
{
	public delegate void VoidEvent();

	public int _columns = 2;

	public int _rows = 2;

	public Vector2 _scale = new Vector3(1f, 1f);

	public Vector2 _offset = Vector2.zero;

	public Vector2 _buffer = Vector2.zero;

	public float _framesPerSecond = 10f;

	public bool _playOnce;

	public bool _disableUponCompletion;

	public bool _enableEvents;

	public bool _playOnEnable = true;

	public bool _newMaterialInstance;

	private int _index;

	private Vector2 _textureSize = Vector2.zero;

	private Material _materialInstance;

	private bool _hasMaterialInstance;

	private bool _isPlaying;

	private List<VoidEvent> _voidEventCallbackList;

	public void RegisterCallback(VoidEvent cbFunction)
	{
		if (_enableEvents)
		{
			_voidEventCallbackList.Add(cbFunction);
		}
		else
		{
			UnityEngine.Debug.LogWarning("AnimateTiledTexture: You are attempting to register a callback but the events of this object are not enabled!");
		}
	}

	public void UnRegisterCallback(VoidEvent cbFunction)
	{
		if (_enableEvents)
		{
			_voidEventCallbackList.Remove(cbFunction);
		}
		else
		{
			UnityEngine.Debug.LogWarning("AnimateTiledTexture: You are attempting to un-register a callback but the events of this object are not enabled!");
		}
	}

	public void Play()
	{
		if (_isPlaying)
		{
			StopCoroutine("updateTiling");
			_isPlaying = false;
		}
		GetComponent<Renderer>().enabled = true;
		_index = _columns;
		StartCoroutine(updateTiling());
	}

	public void ChangeMaterial(Material newMaterial, bool newInstance = false)
	{
		if (newInstance)
		{
			if (_hasMaterialInstance)
			{
				UnityEngine.Object.Destroy(GetComponent<Renderer>().sharedMaterial);
			}
			_materialInstance = new Material(newMaterial);
			GetComponent<Renderer>().sharedMaterial = _materialInstance;
			_hasMaterialInstance = true;
		}
		else
		{
			GetComponent<Renderer>().sharedMaterial = newMaterial;
		}
		CalcTextureSize();
		if ((bool)GetComponent<Renderer>() && (bool)GetComponent<Renderer>().sharedMaterial)
		{
			GetComponent<Renderer>().sharedMaterial.SetTextureScale("_MainTex", _textureSize);
		}
	}

	private void Awake()
	{
		if (_enableEvents)
		{
			_voidEventCallbackList = new List<VoidEvent>();
		}
		ChangeMaterial(GetComponent<Renderer>().sharedMaterial, _newMaterialInstance);
	}

	private void OnDestroy()
	{
		if (_hasMaterialInstance)
		{
			UnityEngine.Object.Destroy(GetComponent<Renderer>().sharedMaterial);
			_hasMaterialInstance = false;
		}
	}

	private void HandleCallbacks(List<VoidEvent> cbList)
	{
		for (int i = 0; i < cbList.Count; i++)
		{
			cbList[i]();
		}
	}

	private void OnEnable()
	{
		CalcTextureSize();
		if (_playOnEnable)
		{
			Play();
		}
	}

	private void CalcTextureSize()
	{
		_textureSize = new Vector2(1f / (float)_columns, 1f / (float)_rows);
		_textureSize.x /= _scale.x;
		_textureSize.y /= _scale.y;
		_textureSize -= _buffer;
	}

	private IEnumerator updateTiling()
	{
		_isPlaying = true;
		int checkAgainst = _rows * _columns;
		while (true)
		{
			if (_index >= checkAgainst)
			{
				_index = 0;
				if (_playOnce)
				{
					if (checkAgainst == _columns)
					{
						break;
					}
					checkAgainst = _columns;
				}
			}
			ApplyOffset();
			_index++;
			yield return new WaitForSeconds(1f / _framesPerSecond);
		}
		if (_enableEvents)
		{
			HandleCallbacks(_voidEventCallbackList);
		}
		if (_disableUponCompletion)
		{
			base.gameObject.GetComponent<Renderer>().enabled = false;
		}
		_isPlaying = false;
	}

	private void ApplyOffset()
	{
		Vector2 value = new Vector2((float)_index / (float)_columns - (float)(_index / _columns), 1f - (float)(_index / _columns) / (float)_rows);
		if (value.y == 1f)
		{
			value.y = 0f;
		}
		value.x += (1f / (float)_columns - _textureSize.x) / 2f;
		value.y += (1f / (float)_rows - _textureSize.y) / 2f;
		value.x += _offset.x;
		value.y += _offset.y;
		if ((bool)GetComponent<Renderer>() && (bool)GetComponent<Renderer>().sharedMaterial)
		{
			GetComponent<Renderer>().sharedMaterial.SetTextureOffset("_MainTex", value);
		}
	}
}
public class PlayerFX : UnityEngine.MonoBehaviour
{
	[Serializable]
	public struct FXType
	{
		public TrackList.WeatherType m_weatherType;

		public GameObject m_fx;

		public ParticleSystem[] m_currentSystems;
	}

	[SerializeField]
	private FXType[] m_playerFX;

	private void Start()
	{
		Player component = GetComponent<Player>();
		if (component.GetPlayerType() != Player.PlayerType.AI)
		{
			TrackList.WeatherType trackWeather = GameSystem.Instance.GetLoadedTrack().TrackWeather;
			for (int i = 0; i < m_playerFX.Length; i++)
			{
				m_playerFX[i].m_currentSystems = m_playerFX[i].m_fx.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
			}
			switch (trackWeather)
			{
			case TrackList.WeatherType.Sunny:
				EnableSnow(enable: false);
				EnableBlizzard(enable: false);
				break;
			case TrackList.WeatherType.Snowy:
				EnableSnow(enable: true);
				EnableBlizzard(enable: false);
				break;
			case TrackList.WeatherType.Rainy:
				EnableSnow(enable: false);
				EnableBlizzard(enable: false);
				break;
			case TrackList.WeatherType.Blizzard:
				EnableSnow(enable: false);
				EnableBlizzard(enable: true);
				break;
			}
		}
	}

	private void GetWeatherSystem(TrackList.WeatherType weatherType, ref ParticleSystem[] weatherSystems, ref GameObject fxObject)
	{
		for (int i = 0; i < m_playerFX.Length; i++)
		{
			if (m_playerFX[i].m_weatherType == weatherType)
			{
				fxObject = m_playerFX[i].m_fx;
				weatherSystems = m_playerFX[i].m_currentSystems;
				break;
			}
		}
	}

	public void KillAllFX()
	{
		EnableBlizzard(enable: false);
		EnableSnow(enable: false);
	}

	public void EnableSnow(bool enable)
	{
		ParticleSystem[] weatherSystems = null;
		GameObject fxObject = null;
		GetWeatherSystem(TrackList.WeatherType.Snowy, ref weatherSystems, ref fxObject);
		if (weatherSystems == null)
		{
			return;
		}
		if ((bool)fxObject && fxObject.activeSelf != enable)
		{
			fxObject.SetActive(enable);
		}
		for (int i = 0; i < weatherSystems.Length; i++)
		{
			if (enable)
			{
				weatherSystems[i].Play();
			}
			else
			{
				weatherSystems[i].Stop();
			}
		}
	}

	public void EnableBlizzard(bool enable)
	{
		ParticleSystem[] weatherSystems = null;
		GameObject fxObject = null;
		GetWeatherSystem(TrackList.WeatherType.Blizzard, ref weatherSystems, ref fxObject);
		if (weatherSystems == null)
		{
			return;
		}
		if ((bool)fxObject && fxObject.activeSelf != enable)
		{
			fxObject.SetActive(value: false);
		}
		for (int i = 0; i < weatherSystems.Length; i++)
		{
			if (enable)
			{
				weatherSystems[i].Play();
			}
			else
			{
				weatherSystems[i].Stop();
			}
		}
	}
}
public class PlayerSnow : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject m_snowPrefab;

	[SerializeField]
	private float m_maxZValue = 4f;

	[SerializeField]
	private float m_minYValue = 4f;

	[SerializeField]
	private float m_maxLifeTime = 1f;

	[SerializeField]
	private float m_minLifeTime = 5f;

	[SerializeField]
	private float m_maxVelocityMultiplier = -2f;

	[SerializeField]
	private float m_minVelocityMultiplier = -1f;

	[SerializeField]
	private float m_speedForMaxValues = 50f;

	private GameObject m_snowParticle;

	private ParticleSystem[] m_mainParticles;

	private float m_minSimSpeed = 1f;

	private KartController m_playerController;

	private void Start()
	{
		m_snowParticle = UnityEngine.Object.Instantiate(m_snowPrefab);
		m_snowParticle.transform.parent = base.transform;
		m_snowParticle.transform.localPosition = Vector3.zero;
		m_snowParticle.transform.localRotation = Quaternion.identity;
		m_mainParticles = m_snowParticle.GetComponentsInChildren<ParticleSystem>();
		m_minSimSpeed = m_mainParticles[0].main.simulationSpeed;
		Player refPlayer = null;
		PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		if ((bool)refPlayer)
		{
			m_playerController = refPlayer.GetComponent<KartController>();
		}
	}

	private void Update()
	{
		float num = m_playerController.CurrentSpeed / m_speedForMaxValues;
		ParticleSystem.MainModule main = m_mainParticles[0].main;
		main.startLifetime = m_maxLifeTime + (m_minLifeTime - m_maxLifeTime) * num;
		ParticleSystem.VelocityOverLifetimeModule velocityOverLifetime = m_mainParticles[0].velocityOverLifetime;
		velocityOverLifetime.yMultiplier = m_minVelocityMultiplier + (m_maxVelocityMultiplier - m_minVelocityMultiplier) * num;
		m_snowParticle.transform.localPosition = new Vector3(0f, m_minYValue * num, m_maxZValue * num);
	}
}
public class GameMusic2D : UnityEngine.MonoBehaviour
{
	private AudioSource m_audioSource;

	private float m_defaultVolume;

	private float m_targetDefaultVolume;

	private bool m_waitForPlay = true;

	private float m_newVolume = -1f;

	private int m_lowVolRefCount;

	private bool m_overrideVolume;

	public void OverrideDefaultVolume(float vol)
	{
		m_overrideVolume = true;
		m_defaultVolume = vol;
	}

	public void SetLowVolume(bool enable)
	{
		if (enable)
		{
			m_lowVolRefCount++;
		}
		else if (m_lowVolRefCount > 0)
		{
			m_lowVolRefCount--;
		}
		m_newVolume = ((m_lowVolRefCount <= 0) ? (-1f) : 0.1f);
	}

	public float GetVolume()
	{
		return m_defaultVolume;
	}

	private void Awake()
	{
		m_audioSource = GetComponent<AudioSource>();
		if ((bool)m_audioSource)
		{
			m_audioSource.ignoreListenerVolume = true;
			m_audioSource.volume = 0f;
			if ((bool)ProfileManager.Instance)
			{
				m_defaultVolume = ProfileManager.Instance.MusicVolume;
			}
			else
			{
				m_defaultVolume = 1f;
			}
		}
		m_targetDefaultVolume = m_defaultVolume;
	}

	private void Start()
	{
		UpdateVolumes();
	}

	private void Update()
	{
		if (m_waitForPlay && !m_audioSource.isPlaying && m_audioSource.volume > 0.2f)
		{
			m_waitForPlay = false;
			m_audioSource.Play();
		}
		UpdateVolumes();
	}

	private void UpdateVolumes()
	{
		if (!(ProfileManager.Instance == null))
		{
			if (m_newVolume != -1f && FadeManager.Instance.GetFadeState() != FadeManager.FadeState.FadeIn)
			{
				m_defaultVolume = m_newVolume;
			}
			else if (!m_overrideVolume && Mathf.Abs(m_audioSource.volume - ProfileManager.Instance.MusicVolume) > 0.001f && FadeManager.Instance.FinishedFading())
			{
				m_defaultVolume = ProfileManager.Instance.MusicVolume;
			}
			m_targetDefaultVolume = Mathf.Lerp(m_targetDefaultVolume, m_defaultVolume, 4f * GameTime.Instance.DeltaTime());
			m_audioSource.volume = m_targetDefaultVolume * (1f - FadeManager.Instance.GetFadeAlpha()) * 0.8f;
			m_overrideVolume = false;
		}
	}
}
public class GameMusic3D : UnityEngine.MonoBehaviour
{
	private AudioSource m_audioSource;

	private float m_originalMinDistance;

	private float m_defaultVolume;

	private bool m_waitForPlay = true;

	public void OverrideDefaultVolume(float vol)
	{
		m_defaultVolume = vol;
	}

	private void Awake()
	{
		m_audioSource = GetComponent<AudioSource>();
		if ((bool)m_audioSource)
		{
			m_audioSource.ignoreListenerVolume = true;
			m_originalMinDistance = m_audioSource.minDistance;
			m_audioSource.volume = 0f;
			if ((bool)ProfileManager.Instance && ProfileManager.Instance.Loaded)
			{
				m_defaultVolume = ProfileManager.Instance.MusicVolume;
			}
			else
			{
				m_defaultVolume = 1f;
			}
		}
	}

	private void OnEnable()
	{
		m_waitForPlay = true;
	}

	private void Start()
	{
		UpdateVolumes();
	}

	private void Update()
	{
		if ((bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend && m_waitForPlay && !m_audioSource.isPlaying && m_audioSource.volume >= 0.2f)
		{
			m_waitForPlay = false;
			m_audioSource.Play();
		}
		UpdateVolumes();
	}

	private void UpdateVolumes()
	{
		if (!(ProfileManager.Instance == null))
		{
			float num = m_originalMinDistance * ProfileManager.Instance.MusicVolume;
			if (Mathf.Abs(m_audioSource.minDistance - num) > 0.001f)
			{
				m_audioSource.minDistance = num;
				m_defaultVolume = ProfileManager.Instance.MusicVolume;
			}
			m_audioSource.volume = m_defaultVolume * (1f - FadeManager.Instance.GetFadeAlpha()) * 0.8f;
		}
	}
}
public class BombheadMode : UnityEngine.MonoBehaviour
{
	private enum RuleState
	{
		None,
		ChooseBombPlayer,
		WaitForExplosion,
		Results,
		WaitForFinish
	}

	public static BombheadMode Instance;

	private RuleState m_ruleState;

	private List<Player> m_playerList;

	public void BombExploded(Player player)
	{
		m_ruleState = RuleState.Results;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		m_playerList = PlayerManager.Instance.GetPlayerList();
	}

	private void Update()
	{
		if (!NetworkLogin.Instance || !NetworkLogin.Instance.IsMasterPlayer())
		{
			return;
		}
		switch (m_ruleState)
		{
		default:
			if (FadeManager.Instance.FinishedFading() && Gameplay.Instance.RaceStarted())
			{
				m_ruleState = RuleState.ChooseBombPlayer;
			}
			break;
		case RuleState.ChooseBombPlayer:
		{
			int index = UnityEngine.Random.Range(0, m_playerList.Count);
			Gameplay.Instance.FireWeapon(m_playerList[0], m_playerList[index], WeaponManager.WeaponType.Bombhead);
			if (NetworkLogin.Instance != null)
			{
				NetworkLogin.Instance.GetServer().SetGameplayEvent(m_playerList[0].SeatIndex, NetworkClient.GameplayEvent.Bombhead);
				GameSystem.Instance.WeaponTargetIndex = m_playerList[index].OnlinePlayerIndex;
			}
			m_ruleState = RuleState.WaitForExplosion;
			break;
		}
		case RuleState.WaitForExplosion:
			break;
		case RuleState.Results:
			FadeManager.Instance.FadeOut();
			m_ruleState = RuleState.WaitForFinish;
			break;
		case RuleState.WaitForFinish:
			if (FadeManager.Instance.FinishedFading())
			{
				FadeManager.Instance.FadeIn();
				m_ruleState = RuleState.None;
			}
			break;
		}
	}
}
public class ChampionshipMode : UnityEngine.MonoBehaviour
{
	public enum TrophyChampionshipType
	{
		Championship1,
		Championship2,
		Random,
		Max
	}

	public enum TrophyGroupingType
	{
		None = 0,
		Rookie = 1,
		Amateur = 2,
		Pro = 3,
		MaxUserLevels = 4,
		Random = 4,
		Max = 5
	}

	private struct TrophyTrackData
	{
		public string[] LevelName;

		public int NumTracks;

		public int CRC;
	}

	public static int MaxLevelsPerTrophy = 4;

	private const int TracksPerTrophy = 4;

	private const int ExtraRandomTracks = 20;

	private bool m_modeInProgress;

	private int m_currentTrackIndex;

	private int[] m_randomTrackCRC = new int[4];

	private TrophyGroupingType m_currentTrophyType;

	private TrophyTrackData[] m_trophyTrackData = new TrophyTrackData[10];

	private string[] m_prevWinnerList = new string[8];

	public static string[] GetChampionshipName()
	{
		return new string[2] { "Championship 1", "Championship 2" };
	}

	public static string[] GetName()
	{
		return new string[4] { "None", "Rookie", "Amateur", "Pro" };
	}

	public static string[] GetTrophyIndex()
	{
		return new string[4] { "1", "2", "3", "4" };
	}

	public void AddLevelName(TrophyChampionshipType cupType, TrophyGroupingType trophyType, int index, string levelName)
	{
		int num = (int)(4 * (int)cupType + trophyType);
		if (m_trophyTrackData[num].LevelName[index] == string.Empty)
		{
			m_trophyTrackData[num].LevelName[index] = levelName;
			m_trophyTrackData[num].NumTracks++;
			m_trophyTrackData[num].CRC = m_trophyTrackData[num].LevelName[index].GetHashCode();
		}
	}

	public string GetLevelName(TrophyChampionshipType cupType, TrophyGroupingType trophyType, int index)
	{
		if (trophyType == TrophyGroupingType.MaxUserLevels)
		{
			int num3;
			TrophyTrackData trophyTrackData;
			do
			{
				int num = UnityEngine.Random.Range(0, 2);
				int num2 = UnityEngine.Random.Range(1, 5);
				num3 = UnityEngine.Random.Range(0, MaxLevelsPerTrophy);
				trophyTrackData = m_trophyTrackData[4 * num + num2];
			}
			while (trophyTrackData.LevelName[num3].Length == 0 || TrackAlreadyPlayed(trophyTrackData.LevelName[num3]));
			SetTrackPlayed(trophyTrackData.LevelName[num3]);
			return trophyTrackData.LevelName[num3];
		}
		return m_trophyTrackData[(int)(4 * (int)cupType + trophyType)].LevelName[index];
	}

	private bool TrackAlreadyPlayed(string levelStr)
	{
		int hashCode = levelStr.GetHashCode();
		for (int i = 0; i < m_randomTrackCRC.Length; i++)
		{
			if (m_randomTrackCRC[i] == hashCode)
			{
				return true;
			}
		}
		return false;
	}

	private void SetTrackPlayed(string levelStr)
	{
		int hashCode = levelStr.GetHashCode();
		for (int i = 0; i < m_randomTrackCRC.Length; i++)
		{
			if (m_randomTrackCRC[i] == 0)
			{
				m_randomTrackCRC[i] = hashCode;
				break;
			}
		}
	}

	private void ClearAllTracksPlayed()
	{
		for (int i = 0; i < m_randomTrackCRC.Length; i++)
		{
			m_randomTrackCRC[i] = 0;
		}
	}

	public bool ModeInProgress()
	{
		return m_modeInProgress;
	}

	public void EndChampionshipMode()
	{
		m_modeInProgress = false;
	}

	public TrophyGroupingType GetTrophyType()
	{
		return m_currentTrophyType;
	}

	public string StartChampionshipMode(TrophyGroupingType trophyType)
	{
		m_modeInProgress = true;
		m_currentTrackIndex = 0;
		m_currentTrophyType = trophyType;
		ClearAllTracksPlayed();
		return GetLevelName(ProfileManager.Instance.CurrentChampType, m_currentTrophyType, m_currentTrackIndex);
	}

	public int CurrentTrackProgress()
	{
		return m_currentTrackIndex;
	}

	public string MoveOntoNextTrack()
	{
		m_currentTrackIndex++;
		return GetLevelName(ProfileManager.Instance.CurrentChampType, m_currentTrophyType, m_currentTrackIndex);
	}

	public bool ShouldMoveOn()
	{
		return m_currentTrackIndex < GetTracksPerTrophy() - 1;
	}

	public int TracksRemaining()
	{
		return GetTracksPerTrophy() - 1 - m_currentTrackIndex;
	}

	private int GetTracksPerTrophy()
	{
		if (ProfileManager.Instance.CurrentChampType == TrophyChampionshipType.Random)
		{
			return 3;
		}
		int num = 0;
		TrophyTrackData trophyTrackData = m_trophyTrackData[(int)(4 * (int)ProfileManager.Instance.CurrentChampType + m_currentTrophyType)];
		return trophyTrackData.NumTracks;
	}

	public void SetLastDriverPosition(string driverName, int pos)
	{
		m_prevWinnerList[pos] = driverName;
	}

	public bool FindDriverPosition(string driverName, ref int pos)
	{
		for (pos = 0; pos < m_prevWinnerList.Length; pos++)
		{
			if (driverName == m_prevWinnerList[pos])
			{
				return true;
			}
		}
		return false;
	}

	private void Awake()
	{
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 5; j++)
			{
				int num = 4 * i + j;
				m_trophyTrackData[num].LevelName = new string[4];
				for (int k = 0; k < m_trophyTrackData[j].LevelName.Length; k++)
				{
					m_trophyTrackData[num].LevelName[k] = string.Empty;
				}
			}
		}
	}
}
public class ConfettiTrigger : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject ConfettiRoot;

	private void Start()
	{
		if (ConfettiRoot != null && ConfettiRoot.activeSelf)
		{
			ConfettiRoot.SetActive(value: false);
		}
	}

	private void OnTriggerEnter(Collider col)
	{
		if (!(ConfettiRoot != null) || ConfettiRoot.activeSelf)
		{
			return;
		}
		Transform parent = col.transform;
		Player player = null;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if ((bool)parent)
		{
			player = parent.GetComponent<Player>();
			if (player != null && player.GetPlayerType() == Player.PlayerType.Human && player.GetCurrentLap() == LapManager.Instance.GetNumLaps() - 1)
			{
				ConfettiRoot.SetActive(value: true);
				PlayerManager.Instance.ConfettiEnabled = true;
			}
		}
	}
}
[ExecuteInEditMode]
public class DriftZone : UnityEngine.MonoBehaviour
{
	public static bool ShowAllDriftZones;

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider col)
	{
		SetInDriftZone(col, set: true);
	}

	private void OnTriggerExit(Collider col)
	{
		SetInDriftZone(col, set: false);
	}

	private void SetInDriftZone(Collider col, bool set)
	{
		Transform parent = col.transform;
		while (parent != null && parent.gameObject.GetComponent<KartUserControl>() == null)
		{
			parent = parent.parent;
		}
		if ((bool)parent)
		{
			parent.gameObject.GetComponent<KartUserControl>().EnableDrift(set);
		}
	}
}
public class FTUETargets : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject[] Targets;

	[SerializeField]
	private float UpwardsAmount = 0.2f;

	[SerializeField]
	private float UpwardsSpeed = 4f;

	[SerializeField]
	private float SidewaysAmount = 3f;

	[SerializeField]
	private float SidewaysSpeed = 1f;

	[SerializeField]
	private float BalloonDelay = 1f;

	private int m_currentIndex = -1;

	private float m_upwardsAngle;

	private float m_sidewaysAngle;

	private float m_delayBetweenBalloon;

	private bool m_waitForAudio;

	private int m_weaponAudioIndex;

	private Player m_player;

	public void SetPlayer(Player player)
	{
		m_player = player;
	}

	public void Hit()
	{
		DisableTarget(m_currentIndex);
		m_currentIndex++;
		m_waitForAudio = true;
		if (m_weaponAudioIndex <= 4)
		{
			m_player.PlayAudio(FTUE.Instance.Weapons_Audio[m_weaponAudioIndex++]);
		}
		if (m_currentIndex < Targets.Length)
		{
			m_player.GivePlayerWeapon(WeaponManager.WeaponType.Missile);
			m_delayBetweenBalloon = BalloonDelay;
		}
		else
		{
			base.enabled = false;
			FTUE.Instance.ReadyToStart();
		}
	}

	private void Start()
	{
		m_currentIndex = -1;
		for (int i = 0; i < Targets.Length; i++)
		{
			Targets[i].SetActive(value: false);
		}
	}

	private void Update()
	{
		if (m_delayBetweenBalloon > 0f)
		{
			m_delayBetweenBalloon -= GameTime.Instance.DeltaTime();
			if (m_delayBetweenBalloon < 0f)
			{
				m_delayBetweenBalloon = 0f;
			}
		}
		else
		{
			if (Gameplay.Instance.RaceStarted() && m_currentIndex == -1)
			{
				m_waitForAudio = true;
				m_currentIndex++;
			}
			UpdateBalloon();
		}
		if (m_delayBetweenBalloon <= 0f && m_waitForAudio && !m_player.IsPlayingAudio())
		{
			m_waitForAudio = false;
			if (m_weaponAudioIndex <= 3)
			{
				m_player.PlayAudio(FTUE.Instance.Weapons_Audio[m_weaponAudioIndex++]);
				m_waitForAudio = true;
			}
			else
			{
				EnableTarget(m_currentIndex);
			}
		}
	}

	private void EnableTarget(int index)
	{
		GameSystem.Instance.GetPuffParticles().DoPuff(Targets[index].transform.position);
		Targets[index].SetActive(value: true);
	}

	private void DisableTarget(int index)
	{
		GameSystem.Instance.GetPuffParticles().DoPuff(Targets[index].transform.position);
		Targets[index].SetActive(value: false);
	}

	private void UpdateBalloon()
	{
		if (m_currentIndex >= 0)
		{
			m_upwardsAngle += UpwardsSpeed * GameTime.Instance.DeltaTime();
			m_upwardsAngle %= 360f;
			if (m_currentIndex == Targets.Length - 1)
			{
				m_sidewaysAngle += SidewaysSpeed * GameTime.Instance.DeltaTime();
				m_sidewaysAngle %= 360f;
			}
			Targets[m_currentIndex].transform.localPosition = Targets[m_currentIndex].transform.right * (Mathf.Sin(m_upwardsAngle) * UpwardsAmount);
			Targets[m_currentIndex].transform.localPosition += Targets[m_currentIndex].transform.up * (Mathf.Sin(m_sidewaysAngle) * SidewaysAmount);
		}
	}
}
[ExecuteInEditMode]
public class FogZone : UnityEngine.MonoBehaviour
{
	public static bool ShowAlFogZones;

	[Range(-1000f, 1000f)]
	[SerializeField]
	private int SceneLayerOffset = 10;

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider col)
	{
		SetInFogZone(col, entered: true);
	}

	private void OnTriggerExit(Collider col)
	{
		SetInFogZone(col, entered: false);
	}

	private void SetInFogZone(Collider col, bool entered)
	{
		Transform parent = col.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if ((bool)parent && parent.GetComponent<Player>().GetPlayerType() == Player.PlayerType.Human)
		{
			GameSystem.Instance.InFogZone(entered, base.gameObject.transform.position, SceneLayerOffset);
		}
	}
}
public class Gameplay : UnityEngine.MonoBehaviour
{
	public enum GameplayState
	{
		None,
		Initialising,
		FadeIn,
		WaitForFade,
		LevelIntro
	}

	public enum HitByType
	{
		None,
		NormalWeapon,
		Toxic
	}

	[SerializeField]
	public GridLights[] GridLightObjects = new GridLights[3];

	[SerializeField]
	private AudioSource[] GridStartAudio = new AudioSource[2];

	public AudioClip FinalLapClip;

	[SerializeField]
	private GameObject WeaponPrefab;

	[SerializeField]
	private GameObject MinePrefab;

	[SerializeField]
	private Vector2 WeaponOffset;

	[SerializeField]
	private AudioSource[] LevelAudio;

	[SerializeField]
	private GameObject SceneryRootObject;

	[SerializeField]
	public Light LenFlareObject;

	[SerializeField]
	private GameObject WaitingForPlayersBoardObject;

	public static Gameplay Instance;

	private GameplayState m_gameplayState;

	public bool InitKillGameTime;

	private float GridHoldingTime = 5f;

	private bool m_proceedWithGridLights = true;

	private float m_totalRaceStartTime = 3f;

	private float m_raceStartTimer;

	private bool m_playAllAudio = true;

	private bool m_inFinishMode;

	private float m_wrongWayTime;

	private float m_wrongWayOffsetX = 10f;

	private float m_wrongWayOffsetY = 2f;

	private float m_wrongWayFlashTimer = 2f;

	private bool m_onlineStartTimeSet;

	private float m_onlineStartTimer;

	private float m_wrongWayTimer;

	private Player m_mainHumanPlayer;

	private VRWaypointCircuit m_circuitPath;

	private GameObject m_resultsRoot;

	private GameObject m_gameRoot;

	private GameObject m_waitingForPlayerBoard;

	private bool m_onlineStatsRetrieval;

	private bool m_killEnabled;

	private float m_onlineFailSafeTimeOut;

	private Scene m_resultsScene;

	private float m_gcCollectionTime;

	private const float GCCollectionUpdate = 5f;

	public List<Mine_Proximity> MineList { get; set; }

	public List<StingerWeapon> StingerList { get; set; }

	public GameObject SceneryRoot => SceneryRootObject;

	public float KillGameTime { get; set; }

	public bool GoingWrongWay { get; set; }

	public float RaceStartTime { get; set; }

	public int ToxicRefCount { get; set; }

	public double StartTimeOfRace { get; set; }

	public GameplayState GetGameplayState()
	{
		return m_gameplayState;
	}

	public Player GetMainHumanPlayer()
	{
		return m_mainHumanPlayer;
	}

	public bool RaceStarted()
	{
		return m_raceStartTimer <= 0f;
	}

	public bool RaceFinished()
	{
		return m_inFinishMode;
	}

	public float PreRaceStartTimer()
	{
		return m_raceStartTimer;
	}

	public bool ProceedWithGridLights()
	{
		return m_proceedWithGridLights;
	}

	public void SetRaceFinished()
	{
		m_inFinishMode = true;
		SetKillEnabled(enabled: false);
		FadeManager.Instance.FadeOut(2f);
		if ((bool)NetworkLogin.Instance)
		{
			NetworkLogin.Instance.GetServer().ForceNetworkUpdate();
		}
	}

	public void Horn(Player player)
	{
		ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(player.LocalPlayerIndex);
		player.SetHornClip(CustomisedObjectManager.Instance.GetHornClip(playerData.m_customisationData.m_horn));
	}

	public WeaponManager GetWeaponManager()
	{
		return WeaponManager.Instance;
	}

	public bool IsKillEnabled()
	{
		return m_killEnabled;
	}

	public void SetKillEnabled(bool enabled)
	{
		m_killEnabled = enabled;
	}

	public void FireWeapon(Player player, Player target, WeaponManager.WeaponType weaponType)
	{
		if (WeaponPrefab == null || MinePrefab == null || (ResultsManager.Instance != null && ResultsManager.Instance.ResultsActive()) || player.PlayerFinishState != 0 || RaceFinished())
		{
			return;
		}
		switch (weaponType)
		{
		case WeaponManager.WeaponType.Missile:
		case WeaponManager.WeaponType.Reverse:
		case WeaponManager.WeaponType.Bombhead:
		{
			if (player == null || target == null)
			{
				return;
			}
			Vector3 position = player.transform.position;
			position += player.transform.forward * WeaponOffset.x;
			position += player.transform.up * WeaponOffset.y;
			GameObject gameObject = null;
			switch (weaponType)
			{
			case WeaponManager.WeaponType.Missile:
				gameObject = GetWeaponManager().GetMissile();
				gameObject.GetComponent<WeaponFiring>().SetPlayer(player, target);
				break;
			case WeaponManager.WeaponType.Reverse:
				gameObject = GetWeaponManager().GetReverse();
				gameObject.GetComponent<WeaponFiring>().SetPlayer(player, target);
				break;
			case WeaponManager.WeaponType.Bombhead:
				gameObject = GetWeaponManager().GetBombhead();
				gameObject.GetComponent<BombheadWeapon>().SetPlayer(player, target);
				position += player.transform.up * 2f;
				break;
			}
			gameObject.transform.position = position;
			gameObject.transform.rotation = Quaternion.identity;
			if ((bool)m_gameRoot)
			{
				gameObject.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		case WeaponManager.WeaponType.Mine:
		{
			Vector3 position3 = player.transform.position;
			GameObject mine = WeaponManager.Instance.GetMine();
			mine.transform.position = position3;
			mine.transform.rotation = player.transform.rotation;
			mine.GetComponent<Mine_Proximity>().SetPlayer(player);
			MineList.Add(mine.GetComponent<Mine_Proximity>());
			if ((bool)m_gameRoot)
			{
				mine.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		case WeaponManager.WeaponType.Stinger:
		{
			Vector3 position2 = player.transform.position;
			GameObject stinger = WeaponManager.Instance.GetStinger();
			stinger.transform.position = position2;
			stinger.transform.rotation = Quaternion.identity;
			stinger.GetComponent<StingerWeapon>().SetPlayer(player);
			StingerList.Add(stinger.GetComponent<StingerWeapon>());
			if ((bool)m_gameRoot)
			{
				stinger.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		case WeaponManager.WeaponType.Toxic:
		{
			GameObject toxic = WeaponManager.Instance.GetToxic();
			toxic.GetComponent<ToxicWeapon>().SetPlayer(player);
			if ((bool)m_gameRoot)
			{
				toxic.transform.parent = m_gameRoot.transform;
			}
			WeaponManager.Instance.PlayToxicFireAudio();
			break;
		}
		case WeaponManager.WeaponType.Shield:
		{
			GameObject shield = WeaponManager.Instance.GetShield();
			shield.GetComponent<ShieldWeapon>().SetPlayer(player);
			if ((bool)m_gameRoot)
			{
				shield.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		case WeaponManager.WeaponType.RadiusBomb:
		{
			GameObject radiusBomb = WeaponManager.Instance.GetRadiusBomb();
			radiusBomb.GetComponent<RadiusBomb>().SetPlayer(player);
			if ((bool)m_gameRoot)
			{
				radiusBomb.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		case WeaponManager.WeaponType.Nitro:
		{
			GameObject nitro = WeaponManager.Instance.GetNitro();
			nitro.GetComponent<NitroWeapon>().SetPlayer(player);
			if ((bool)m_gameRoot)
			{
				nitro.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		case WeaponManager.WeaponType.Portal:
		{
			GameObject portal = WeaponManager.Instance.GetPortal();
			portal.GetComponent<PortalWeapon>().SetPlayer(player);
			if ((bool)m_gameRoot)
			{
				portal.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		case WeaponManager.WeaponType.Bees:
		{
			if (player == null || target == null)
			{
				return;
			}
			GameObject beehive = WeaponManager.Instance.GetBeehive();
			beehive.GetComponent<BeeWeapon>().SetPlayer(player, target);
			if ((bool)m_gameRoot)
			{
				beehive.transform.parent = m_gameRoot.transform;
			}
			break;
		}
		}
		player.EnableWeapon(enable: false);
	}

	public VRWaypointCircuit GetCircuitPath()
	{
		return m_circuitPath;
	}

	public void SetPlayerToAI(Player player)
	{
		player.SetPlayerType(Player.PlayerType.AI);
		AssignAICircuit(player);
		player.GetComponent<KartSelfRighting>().enabled = true;
		player.GetComponent<VRCarAIControl>().enabled = true;
		player.GetComponent<VRWaypointProgressTracker>().enabled = true;
		player.GetComponent<KartController>().enabled = true;
	}

	public void AssignAICircuit(Player player)
	{
		if ((bool)m_circuitPath)
		{
			player.SetAITarget(m_circuitPath);
			player.GetComponent<KartController>().OverrideMaxSpeed(ReplaySystem.Instance.PlayerCarSpeedForReplay);
		}
	}

	public void SnapPlayerOnTrack(Player mainPlayer)
	{
		Vector3 direction = Vector3.zero;
		Vector3 routePosition = m_circuitPath.GetRoutePosition(0f);
		mainPlayer.transform.position = routePosition;
		Vector3 position = mainPlayer.GetComponent<VRCarAIControl>().ChooseDestinationPath(ref direction);
		mainPlayer.transform.position = position;
		mainPlayer.transform.LookAt(routePosition - direction);
	}

	public void HumanPlayerLeft()
	{
		Player refPlayer = null;
		if (PlayerManager.Instance.GetHumanPlayer(ref refPlayer))
		{
			NetworkLogin.Instance.GetClient().SetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.LeftRoom);
		}
	}

	public void RemoveNetworkPlayer(int onlinePlayerID)
	{
		List<Player> playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < playerList.Count; i++)
		{
			Player player = playerList[i];
			if (player != null && player.OnlinePlayerIndex == onlinePlayerID)
			{
				NetworkLogin.Instance.GetServer().RemovePlayerConnection(player.OnlinePlayerIndex, player.SeatIndex);
				NetworkLogin.Instance.GetClient().ResetCharacterList(player.SeatIndex);
				NetworkLogin.Instance.RemoveOnlinePlayer(onlinePlayerID);
				GameSystem.Instance.GetPuffParticles().DoPuff(player.transform.position);
				PlayerManager.Instance.DestroyPlayer(ref player);
				break;
			}
		}
	}

	public void FEMNowEnabled()
	{
		if (LevelAudio == null || LevelAudio.Length <= 0)
		{
			return;
		}
		for (int i = 0; i < LevelAudio.Length; i++)
		{
			if (LevelAudio[i] != null)
			{
				UnityEngine.Object.Destroy(LevelAudio[i].gameObject);
			}
		}
	}

	public void SetLowEnvAudio(bool enable)
	{
		if ((bool)LevelAudio[0])
		{
			LevelAudio[0].GetComponent<GameMusic2D>().SetLowVolume(enable);
		}
	}

	public void RemoveResultsScene()
	{
		if (m_resultsScene.IsValid())
		{
			SceneManager.UnloadScene(m_resultsScene);
		}
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		m_resultsRoot = GameObject.Find("ResultsRoot");
		if ((bool)m_resultsRoot)
		{
			m_resultsScene = m_resultsRoot.scene;
			m_resultsRoot.transform.parent = base.gameObject.transform;
			if ((bool)ResultsManager.Instance && (bool)ResultsManager.Instance.GetResultsScenery)
			{
				ResultsManager.Instance.GetResultsScenery.SetActive(value: false);
			}
		}
		else
		{
			StartCoroutine(LoadResults());
		}
	}

	private void Start()
	{
		if (!GameEntry.Instance)
		{
			ProfileManager.Instance.FTUE = 0;
		}
		KillGameTime = 0f;
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.IsMasterPlayer())
		{
			NetworkLogin.Instance.GetServer().SetKillGameTime(0f);
		}
		m_gameplayState = GameplayState.Initialising;
		string sceneName = ((!(GameEntry.Instance == null)) ? GameSystem.Instance.GetLoadedTrack().Scene : UnityEngine.Application.loadedLevelName);
		if (GetComponent<OcclusionZoneManager>().enabled)
		{
			GetComponent<OcclusionZoneManager>().LoadOcclusionZones(sceneName);
		}
		m_circuitPath = UnityEngine.Object.FindObjectOfType<VRWaypointCircuit>();
		if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.ReadyForPractice)
		{
			m_raceStartTimer = m_totalRaceStartTime;
			m_proceedWithGridLights = false;
		}
		else if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			m_raceStartTimer = m_totalRaceStartTime;
		}
		else
		{
			m_raceStartTimer = m_totalRaceStartTime + GridHoldingTime;
		}
		ResetWrongWay();
		m_inFinishMode = false;
		m_mainHumanPlayer = null;
		RaceStartTime = 0f;
		ToxicRefCount = 0;
		MineList = new List<Mine_Proximity>();
		StingerList = new List<StingerWeapon>();
		if (GameEntry.Instance != null)
		{
			m_gameRoot = GameObject.Find(GameEntry.Instance.GameRootName);
		}
		if ((bool)WaitingForPlayersBoardObject && (((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom()) || ((bool)FTUE.Instance && FTUE.Instance.State != 0)))
		{
			m_waitingForPlayerBoard = UnityEngine.Object.Instantiate(WaitingForPlayersBoardObject);
			m_waitingForPlayerBoard.transform.parent = GridLightObjects[0].transform.parent.transform;
			if (GameSystem.Instance.GetLoadedTrack().Env.Contains("Env3"))
			{
				m_waitingForPlayerBoard.transform.localPosition = new Vector3(0f, -8.5f, 2f);
				m_waitingForPlayerBoard.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
				m_waitingForPlayerBoard.transform.localScale = new Vector3(0.9f, 0.9f, 0.9f);
			}
			else
			{
				m_waitingForPlayerBoard.transform.localPosition = new Vector3(0f, 0f, -12f);
				m_waitingForPlayerBoard.transform.localEulerAngles = new Vector3(180f, -90f, -90f);
				m_waitingForPlayerBoard.transform.localScale = Vector3.one;
			}
			m_waitingForPlayerBoard.gameObject.SetActive(value: true);
		}
		GameSystem.Instance.SetupLevelMusic(LevelAudio[1]);
	}

	private void CheckKillGameTime()
	{
		if (m_onlineFailSafeTimeOut > 0f && GameTime.Instance.CurrentTime() > m_onlineFailSafeTimeOut)
		{
			m_onlineFailSafeTimeOut = 0f;
			Player refPlayer = null;
			if (PlayerManager.Instance.GetHumanPlayer(ref refPlayer) && refPlayer.PlayerFinishState == Player.PlayerFinishedState.None)
			{
				QuitMenu.Instance.OnlineTooSlowKickout();
			}
		}
		else
		{
			if (!(ResultsManager.Instance != null) || !ResultsManager.Instance.AnyResultsShown())
			{
				return;
			}
			if (!InitKillGameTime)
			{
				KillGameTime = 20f;
				InitKillGameTime = true;
			}
			else if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && NetworkLogin.Instance.IsMasterPlayer())
			{
				NetworkLogin.Instance.GetServer().SetKillGameTime(KillGameTime + 0.5f);
			}
			float num = ((!NetworkLogin.Instance || !NetworkLogin.Instance.IsMasterPlayer()) ? (-3f) : 0f);
			if (!QuitMenu.Instance.InProgress() && KillGameTime <= num)
			{
				Player refPlayer2 = null;
				if (PlayerManager.Instance.GetHumanPlayer(ref refPlayer2) && refPlayer2.PlayerFinishState == Player.PlayerFinishedState.None)
				{
					QuitMenu.Instance.OnlineTooSlowKickout();
				}
			}
			KillGameTime -= GameTime.Instance.DeltaTime();
		}
	}

	private void UpdateGarbageCollection()
	{
		if (GameTime.Instance.CurrentTime() > m_gcCollectionTime)
		{
			m_gcCollectionTime = GameTime.Instance.CurrentTime() + 5f;
			GC.Collect();
		}
	}

	private void Update()
	{
		UpdateGarbageCollection();
		Player refPlayer = null;
		PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		CheckKillGameTime();
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Game)
		{
			if (GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend && m_resultsRoot != null)
			{
				UnityEngine.Object.Destroy(m_resultsRoot);
				SceneManager.UnloadScene(m_resultsRoot.scene);
				m_resultsRoot = null;
			}
			m_inFinishMode = false;
			return;
		}
		if (m_gameplayState == GameplayState.Initialising)
		{
			if (GameEntry.Instance != null && !GameEntry.Instance.FinishedLoading())
			{
				return;
			}
			CameraManager.Instance.UpdateFollow(refPlayer.gameObject);
			ResultsManager.Instance.InitResults();
			m_gameplayState = GameplayState.FadeIn;
		}
		else if (m_gameplayState == GameplayState.FadeIn)
		{
			if (GetComponent<OcclusionZoneManager>().enabled && GetComponent<OcclusionZoneManager>().FirstTimeThrough < 2)
			{
				return;
			}
			GameSystem.Instance.ReducedPowerMode(enable: false);
			if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
			{
				FTUE.Instance.ReadyToStart();
			}
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				m_onlineFailSafeTimeOut = GameTime.Instance.CurrentTime() + 600f;
			}
			FadeManager.Instance.FadeIn();
			m_gameplayState = GameplayState.WaitForFade;
		}
		else if (m_gameplayState == GameplayState.WaitForFade)
		{
			if (FadeManager.Instance.FinishedFading() && (bool)refPlayer && !refPlayer.IsPlayingAudio())
			{
				if (!FTUE.Instance || FTUE.Instance.State == FTUE.FTUEState.None)
				{
					GameSystem.Instance.LevelIntro.gameObject.SetActive(value: true);
					m_gameplayState = GameplayState.LevelIntro;
				}
				else
				{
					m_gameplayState = GameplayState.None;
				}
				if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice1 && (bool)refPlayer)
				{
					AudioSource component = refPlayer.GetComponent<AudioSource>();
					component.clip = FTUE.Instance.StartYourEngines;
					component.Play();
				}
			}
		}
		else if (m_gameplayState == GameplayState.LevelIntro && !GameSystem.Instance.LevelIntro.isPlaying)
		{
			GameSystem.Instance.LevelIntro.gameObject.SetActive(value: false);
			m_gameplayState = GameplayState.None;
		}
		if (m_playAllAudio && (bool)FadeManager.Instance && FadeManager.Instance.FinishedFading() && m_gameplayState == GameplayState.None)
		{
			if (LevelAudio != null && LevelAudio.Length > 0)
			{
				for (int i = 0; i < LevelAudio.Length; i++)
				{
					if ((bool)LevelAudio[i] && !LevelAudio[i].isPlaying)
					{
						LevelAudio[i].Play();
					}
				}
			}
			m_playAllAudio = false;
		}
		if (m_raceStartTimer >= 0f)
		{
			List<Player> playerList = PlayerManager.Instance.GetPlayerList();
			int j = 0;
			int num = playerList.Count;
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && NetworkLogin.Instance.GetRoomPlayerCount() > 0)
			{
				num = NetworkLogin.Instance.GetRoomPlayerCount();
			}
			if (num <= playerList.Count)
			{
				for (j = 0; j < num && (!(playerList[j] != null) || playerList[j].PlacedOnGrid()); j++)
				{
				}
			}
			if (j == num || ((bool)FTUE.Instance && FTUE.Instance.State != 0 && GetGameplayState() == GameplayState.None))
			{
				if ((bool)m_waitingForPlayerBoard && (((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom()) || ((bool)FTUE.Instance && FTUE.Instance.State != 0 && m_raceStartTimer < m_totalRaceStartTime)))
				{
					m_waitingForPlayerBoard.GetComponent<WaitingForPlayersBoard>().HideBoard();
				}
				UpdateGridLights();
			}
			else if ((bool)m_waitingForPlayerBoard && (bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				m_waitingForPlayerBoard.GetComponent<WaitingForPlayersBoard>().ShowBoard();
			}
		}
		else if (RaceStartTime == 0f)
		{
			RaceStartTime = GameTime.Instance.CurrentTime();
		}
		if (RaceFinished() && (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game))
		{
			if ((bool)refPlayer && m_mainHumanPlayer == null)
			{
				m_mainHumanPlayer = refPlayer;
			}
			else if ((bool)ResultsManager.Instance && ResultsManager.Instance.GetResultsScenery != null && !ResultsManager.Instance.GetResultsScenery.activeSelf && FadeManager.Instance.FinishedFading())
			{
				CleanUpEndOfRace(quitting: false);
			}
		}
		else if (GameEntry.Instance != null && GameEntry.Instance.IsLoading() && FadeManager.Instance.GetFadeAlpha() == 1f)
		{
			CleanUpEndOfRace(quitting: true);
		}
		if ((!RaceStarted() && (!ResultsManager.Instance || !ResultsManager.Instance.ResultsActive())) || ((bool)FTUE.Instance && FTUE.Instance.State != 0 && refPlayer.IsPlayingAudio()))
		{
			for (int k = 0; k < LevelAudio.Length; k++)
			{
				if (LevelAudio[k] != null && (bool)LevelAudio[k].GetComponent<GameMusic2D>())
				{
					LevelAudio[k].GetComponent<GameMusic2D>().OverrideDefaultVolume(0.2f);
				}
			}
		}
		CheckForOnlineStats();
		UpdateOnlineKickout();
		CheckForWrongWay();
	}

	private void LateUpdate()
	{
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetClient().ResetGameplayEvents();
		}
	}

	public void CleanUpEndOfRace(bool quitting)
	{
		if ((bool)ForceFeedback.Instance)
		{
			ForceFeedback.Instance.ResetFeedback();
		}
		if (!quitting)
		{
			ResultsManager.Instance.GetResultsScenery.SetActive(value: true);
		}
		Player refPlayer = null;
		PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		if ((bool)refPlayer)
		{
			PlayerFX component = refPlayer.GetComponent<PlayerFX>();
			if ((bool)component)
			{
				component.KillAllFX();
			}
		}
		WeaponManager.Instance.RepoolAllObjects();
		if (LevelAudio == null || LevelAudio.Length <= 0)
		{
			return;
		}
		for (int i = 0; i < LevelAudio.Length; i++)
		{
			if ((bool)LevelAudio[i])
			{
				UnityEngine.Object.Destroy(LevelAudio[i].gameObject);
			}
		}
	}

	public void EnableReplay(Player mainPlayer = null)
	{
		ReplaySystem.Instance.enabled = true;
		if (mainPlayer != null)
		{
			ReplaySystem.Instance.SetTarget(mainPlayer.gameObject);
			if (mainPlayer.GetPlayerType() == Player.PlayerType.Human)
			{
				SetPlayerToAI(mainPlayer);
			}
		}
		else
		{
			ReplaySystem.Instance.SetTarget(PlayerManager.Instance.GetPlayerList()[0].gameObject);
		}
	}

	public void SetStartTime(float startTime)
	{
		m_onlineStartTimer = startTime;
		m_onlineStartTimeSet = true;
	}

	private void UpdateGridLights()
	{
		Player refPlayer = null;
		PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0 && refPlayer.IsPlayingAudio())
		{
			return;
		}
		if (!m_proceedWithGridLights)
		{
			if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice1 && (bool)refPlayer && refPlayer.GetComponent<KartUserControl>().GetAcceleration() > 0.25f)
			{
				m_proceedWithGridLights = true;
				if ((bool)m_waitingForPlayerBoard)
				{
					m_waitingForPlayerBoard.GetComponent<WaitingForPlayersBoard>().HideBoard();
				}
			}
			return;
		}
		if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice2)
		{
			FTUE.Instance.MoveOntoNextState();
			return;
		}
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			if (!m_onlineStartTimeSet)
			{
				if (!NetworkLogin.Instance.IsMasterPlayer())
				{
					return;
				}
				NetworkLogin.Instance.GetServer().SetStartTime(4f);
				SetStartTime(4f);
			}
			if (m_onlineStartTimer > 0f)
			{
				m_raceStartTimer = 2.01f;
				m_onlineStartTimer -= GameTime.Instance.DeltaTime();
				if (NetworkLogin.Instance.IsMasterPlayer())
				{
					NetworkLogin.Instance.GetServer().SetStartTime(m_onlineStartTimer);
				}
				return;
			}
		}
		float num = 0f;
		float num2 = 0f;
		num = m_totalRaceStartTime - m_raceStartTimer;
		m_raceStartTimer -= GameTime.Instance.DeltaTime();
		num2 = m_totalRaceStartTime - m_raceStartTimer;
		if (num < m_totalRaceStartTime && num2 >= m_totalRaceStartTime)
		{
			for (int i = 0; i < GridLightObjects.Length; i++)
			{
				GridLightObjects[i].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Green, enable: true);
				GridLightObjects[i].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Red, enable: false);
				GridLightObjects[i].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Amber, enable: false);
			}
			GridStartAudio[1].Play();
			InputRemapper.Instance.ResetWaitForAccelerate();
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				StartTimeOfRace = GameTime.Instance.GetServerTimeInTicks();
			}
			else
			{
				StartTimeOfRace = GameTime.Instance.GetTimeInTicks();
			}
		}
		else if (num < m_totalRaceStartTime - 1f && num2 >= m_totalRaceStartTime - 1f)
		{
			for (int j = 0; j < GridLightObjects.Length; j++)
			{
				GridLightObjects[j].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Amber, enable: true);
				GridLightObjects[j].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Red, enable: false);
				GridLightObjects[j].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Green, enable: false);
			}
			GridStartAudio[0].Play();
		}
		else if (num < m_totalRaceStartTime - 2f && num2 >= m_totalRaceStartTime - 2f)
		{
			for (int k = 0; k < GridLightObjects.Length; k++)
			{
				GridLightObjects[k].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Red, enable: true);
				GridLightObjects[k].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Amber, enable: false);
				GridLightObjects[k].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Green, enable: false);
			}
			GridStartAudio[0].Play();
		}
	}

	private void CheckForWrongWay()
	{
		Player refPlayer = null;
		SplitLane lane = null;
		float num = 0f;
		if (!PlayerManager.Instance.GetHumanPlayer(ref refPlayer) || refPlayer.PlayerFinishState != 0 || refPlayer.PlayerFinishState != 0 || refPlayer.WrongWayObj == null)
		{
			return;
		}
		bool flag = false;
		if (refPlayer.InSplitLane(ref lane))
		{
			int wayPoint = 0;
			int wayPoint2 = 0;
			lane.GetClosestPointOnTrack(refPlayer.transform.position, ref wayPoint, ref wayPoint2);
			num = Vector3.Angle(refPlayer.transform.forward, (lane.Waypoints[wayPoint2].position - lane.Waypoints[wayPoint].position).normalized);
			if (num > 120f)
			{
				flag = true;
			}
		}
		else if (Vector3.Angle(refPlayer.transform.forward, refPlayer.ClosestDirOnTrack) > 120f)
		{
			flag = true;
		}
		if (flag && m_wrongWayTimer == 0f)
		{
			m_wrongWayTimer = 1.5f;
		}
		if (m_wrongWayTimer > 0f)
		{
			m_wrongWayTimer -= GameTime.Instance.DeltaTime();
			if (m_wrongWayTimer <= 0f)
			{
				GoingWrongWay = true;
				m_wrongWayTimer = 0f;
			}
		}
		if (!GoingWrongWay)
		{
			return;
		}
		if (refPlayer.InSplitLane(ref lane))
		{
			if (num < 90f)
			{
				ResetWrongWay();
				return;
			}
		}
		else if (refPlayer.PointOnTrack() > refPlayer.LastPointOnTrack())
		{
			ResetWrongWay();
			return;
		}
		if (!refPlayer.WrongWayObj.activeInHierarchy && !refPlayer.ShouldRemoveWrongWay())
		{
			refPlayer.WrongWayObj.SetActive(value: true);
		}
		m_wrongWayTime += m_wrongWayFlashTimer * GameTime.Instance.DeltaTime();
		m_wrongWayTime %= (float)Math.PI * 2f;
		UnityEngine.Color color = refPlayer.WrongWayObj.GetComponent<Renderer>().material.color;
		color.a = Mathf.Abs(Mathf.Sin(m_wrongWayTime));
		refPlayer.WrongWayObj.GetComponent<Renderer>().material.color = color;
	}

	private void CheckForOnlineStats()
	{
		if (!NetworkLogin.Instance || !RaceStarted() || m_onlineStatsRetrieval)
		{
			return;
		}
		m_onlineStatsRetrieval = true;
		foreach (Player player in PlayerManager.Instance.GetPlayerList())
		{
			if (player != null)
			{
				ResultsManager.Instance.AddOnlinePoints(player.OnlineID, GameSystem.Instance.GetPositionChooser().GetStoredOnlinePoints(player.SeatIndex));
			}
		}
	}

	private void UpdateOnlineKickout()
	{
		if (RaceStarted() && (bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && NetworkLogin.Instance.GetRoomPlayerCount() == 1)
		{
			QuitMenu.Instance.OnlineDropOut();
		}
	}

	public void ResetWrongWay()
	{
		Player refPlayer = null;
		if ((bool)PlayerManager.Instance)
		{
			PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
			if ((bool)refPlayer)
			{
				refPlayer.WrongWayObj.SetActive(value: false);
			}
		}
		GoingWrongWay = false;
		m_wrongWayTimer = 0f;
	}

	private IEnumerator LoadResults()
	{
		yield return UnityEngine.Application.LoadLevelAdditiveAsync("Results");
		m_resultsRoot = GameObject.Find("ResultsRoot");
		if ((bool)m_resultsRoot)
		{
			m_resultsScene = m_resultsRoot.scene;
			m_resultsRoot.transform.parent = base.gameObject.transform;
			if ((bool)ResultsManager.Instance && (bool)ResultsManager.Instance.GetResultsScenery)
			{
				ResultsManager.Instance.GetResultsScenery.SetActive(value: false);
			}
		}
	}

	public void ShowBoard()
	{
		if ((bool)m_waitingForPlayerBoard)
		{
			m_waitingForPlayerBoard.gameObject.SetActive(value: true);
			m_waitingForPlayerBoard.GetComponent<WaitingForPlayersBoard>().ShowBoard();
		}
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
		{
			m_raceStartTimer = m_totalRaceStartTime + 2f;
			RaceStartTime = 0f;
		}
		for (int i = 0; i < GridLightObjects.Length; i++)
		{
			GridLightObjects[i].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Red, enable: false);
			GridLightObjects[i].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Amber, enable: false);
			GridLightObjects[i].GetComponent<GridLights>().EnableLight(GridLights.LightColour.Green, enable: false);
		}
	}
}
public class GridLights : UnityEngine.MonoBehaviour
{
	public enum LightColour
	{
		Red,
		Amber,
		Green
	}

	[SerializeField]
	private GameObject[] LightsOff = new GameObject[3];

	[SerializeField]
	private GameObject[] LightsOn = new GameObject[3];

	public void EnableLight(LightColour lightCol, bool enable)
	{
		if (LightsOn.Length > (int)lightCol)
		{
			LightsOn[(int)lightCol].gameObject.SetActive(enable);
		}
		if (LightsOff.Length > (int)lightCol)
		{
			LightsOff[(int)lightCol].gameObject.SetActive(!enable);
		}
	}
}
[ExecuteInEditMode]
public class KillBox : UnityEngine.MonoBehaviour
{
	public static bool ShowAllKillBoxes;

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider col)
	{
		if (!Gameplay.Instance || !Gameplay.Instance.IsKillEnabled())
		{
			Transform parent = col.transform;
			while (parent != null && parent.gameObject.GetComponent<Player>() == null)
			{
				parent = parent.parent;
			}
			if ((bool)parent && parent.gameObject.GetComponent<Player>().GetPlayerType() == Player.PlayerType.Human)
			{
				Gameplay.Instance.SetKillEnabled(enabled: true);
			}
		}
	}
}
public class LapManager : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private TextMesh[] LapNoticeText;

	[SerializeField]
	private TextMesh[] TimingNoticeText;

	[SerializeField]
	private TextMesh[] PositionNoticeText;

	[SerializeField]
	private StartLine StartLineObject;

	[SerializeField]
	private MidLine MidLineObject;

	[HideInInspector]
	public int NumLaps = 3;

	private int m_nextLocatorIndex;

	public static LapManager Instance;

	public StartLine GetStartLineObject => StartLineObject;

	public MidLine GetMidLineObject => MidLineObject;

	public float StartLinePoint { get; private set; }

	public float MidLinePoint { get; private set; }

	public int TimeTrialBestLapIndex { get; set; }

	public bool SetNewLapRecord { get; set; }

	public int GetNumLaps()
	{
		return NumLaps;
	}

	public int GetTotalFinishedPlayers()
	{
		return m_nextLocatorIndex;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		StartLinePoint = -1f;
		MidLinePoint = -1f;
		m_nextLocatorIndex = 0;
	}

	private void Update()
	{
		Player refPlayer = null;
		PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		if ((bool)Gameplay.Instance.GetCircuitPath())
		{
			if (StartLineObject != null && StartLinePoint == -1f)
			{
				int wayPoint = 0;
				int wayPoint2 = 0;
				StartLinePoint = Gameplay.Instance.GetCircuitPath().GetClosestPointOnTrack(StartLineObject.transform.position, ref wayPoint, ref wayPoint2);
			}
			if (MidLineObject != null && MidLinePoint == -1f)
			{
				int wayPoint3 = 0;
				int wayPoint4 = 0;
				MidLinePoint = Gameplay.Instance.GetCircuitPath().GetClosestPointOnTrack(MidLineObject.transform.position, ref wayPoint3, ref wayPoint4);
			}
		}
		if (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			CheckForEndOfRace();
		}
	}

	private void CheckForEndOfRace()
	{
		List<Player> playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < playerList.Count; i++)
		{
			Player player = playerList[i];
			if (player == null || player.LapDataEntry.count < NumLaps)
			{
				continue;
			}
			if (player.GetPlayerType() == Player.PlayerType.Human && !Gameplay.Instance.RaceFinished())
			{
				AudioSource component = Instance.GetStartLineObject.GetComponent<AudioSource>();
				if (component != null)
				{
					component.Play();
				}
				if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice4)
				{
					FTUE.Instance.ReadyToStart();
				}
				Gameplay.Instance.SetRaceFinished();
				GameSystem.Instance.PlayOneShot2DClip(GameSystem.Instance.RaceFinishedClip);
			}
			bool flag = NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom();
			if (player.PlayerFinishState != 0 || (flag && player.GetPlayerType() != 0))
			{
				continue;
			}
			player.PlayerFinishState = Player.PlayerFinishedState.ReadyForResults;
			if (player.GetPlayerType() == Player.PlayerType.Human)
			{
				if (flag)
				{
					NetworkLogin.Instance.GetServer().StoreFinalTimes(player.LapDataEntry.totalTime, player.LapDataEntry.totalAvgTime);
				}
				if (GameSystem.Instance.EnableTimeTrialMode)
				{
					int lapIndex = 0;
					SetNewLapRecord = player.CalculateAndSendLeaderboardResults(ref lapIndex);
					TimeTrialBestLapIndex = lapIndex;
				}
			}
		}
	}
}
public class MidLine : UnityEngine.MonoBehaviour
{
	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.red;
		float num = 0f;
		for (int i = 0; i < 3; i++)
		{
			DrawLine(base.transform.position + new Vector3(-20f, num, 0f), base.transform.position + new Vector3(20f, num, 0f));
			DrawLine(base.transform.position + new Vector3(0f, num, 0f), base.transform.position + new Vector3(0f, num, 5f));
			DrawLine(base.transform.position + new Vector3(0f, num, 5f), base.transform.position + new Vector3(1f, num, 4f));
			DrawLine(base.transform.position + new Vector3(0f, num, 5f), base.transform.position + new Vector3(-1f, num, 4f));
			num += 1f;
		}
	}

	private void DrawLine(Vector3 vec1, Vector3 vec2)
	{
		vec1 -= base.transform.position;
		vec1 = base.transform.rotation * vec1;
		vec1 += base.transform.position;
		vec2 -= base.transform.position;
		vec2 = base.transform.rotation * vec2;
		vec2 += base.transform.position;
		Gizmos.DrawLine(vec1, vec2);
	}
}
[ExecuteInEditMode]
public class NoOffroad : UnityEngine.MonoBehaviour
{
	public static bool ShowAllOffroadZones;

	[SerializeField]
	private PlayerManager.GroundParticleType GroundParticleOverride = PlayerManager.GroundParticleType.None;

	[SerializeField]
	private bool EnableVibration;

	[SerializeField]
	private bool RemoveSign;

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider col)
	{
		SetIgnoreOffroad(col, set: true, RemoveSign);
	}

	private void OnTriggerExit(Collider col)
	{
		SetIgnoreOffroad(col, set: false, RemoveSign);
	}

	private void SetIgnoreOffroad(Collider col, bool set, bool removeSign)
	{
		Transform parent = col.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if (!parent)
		{
			return;
		}
		parent.gameObject.GetComponent<Player>().SetIgnoreOffroad(set, removeSign);
		if (EnableVibration)
		{
			parent.gameObject.GetComponent<Player>().SetVibrationOverride(set);
		}
		if (GroundParticleOverride != PlayerManager.GroundParticleType.None)
		{
			if (set)
			{
				parent.gameObject.GetComponent<KartController>().OverrideGroundParticle(GroundParticleOverride);
			}
			else if (!parent.gameObject.GetComponent<Player>().ShouldIgnoreOffroad())
			{
				parent.gameObject.GetComponent<KartController>().ResetGroundParticleOverride();
			}
		}
	}
}
public class ObjectSwap : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject DefaultObject;

	[SerializeField]
	private GameObject SwapObject;

	private ObjectSwapCollision m_swapCollision;

	private void Start()
	{
		if (!DefaultObject.activeSelf)
		{
			DefaultObject.SetActive(value: true);
		}
		if (SwapObject.activeSelf)
		{
			SwapObject.SetActive(value: false);
		}
	}

	public void OnCollision(ref ObjectSwapCollision swapCollision)
	{
		m_swapCollision = swapCollision;
		DefaultObject.SetActive(value: false);
		SwapObject.SetActive(value: true);
	}
}
public class ObjectSwapCollision : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float MinCollisionSpeed = -1f;

	private ObjectSwap m_objectSwapObj;

	private void Start()
	{
		m_objectSwapObj = base.transform.parent.GetComponent<ObjectSwap>();
		if (m_objectSwapObj == null)
		{
			UnityEngine.Debug.LogError("Object Swap issue (" + base.gameObject.name + ") : Cannot find object swap script from object swap collision");
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		Transform parent = other.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if ((bool)parent)
		{
			KartController component = parent.GetComponent<KartController>();
			if (MinCollisionSpeed < 0f || ((bool)component && component.CurrentSpeed > MinCollisionSpeed))
			{
				base.gameObject.SetActive(value: false);
				ObjectSwapCollision swapCollision = this;
				m_objectSwapObj.OnCollision(ref swapCollision);
			}
		}
	}
}
public class ScenerySpline : UnityEngine.MonoBehaviour
{
	[Serializable]
	public struct RotationData
	{
		[SerializeField]
		public bool RotateOnAxis_X;

		[SerializeField]
		public bool RotateOnAxis_Y;

		[SerializeField]
		public bool RotateOnAxis_Z;

		[SerializeField]
		public float SpeedOfRotation;
	}

	[Serializable]
	public class ScenerySplinePointList
	{
		public ScenerySpline circuit;

		public Transform[] items = new Transform[0];
	}

	public struct SceneryRoutePoint
	{
		public Vector3 position;

		public Vector3 direction;

		public SceneryRoutePoint(Vector3 position, Vector3 direction)
		{
			this.position = position;
			this.direction = direction;
		}
	}

	[SerializeField]
	private GameObject SceneryObject;

	[SerializeField]
	private float ObjectSpeed;

	[SerializeField]
	private bool RotateWithDirection;

	[SerializeField]
	private RotationData RotationConfig;

	[SerializeField]
	[Tooltip("Attach to the target point rather than follow to target")]
	private bool AttachToTarget;

	[SerializeField]
	private UnityEngine.Color SplineColor = UnityEngine.Color.magenta;

	[SerializeField]
	[Tooltip("Angle to bank around corners with")]
	private float MaxBankAngle;

	[SerializeField]
	[Tooltip("Show additional information on spline knots")]
	private bool EnableDebugInformation;

	public ScenerySplinePointList waypointList = new ScenerySplinePointList();

	private int numPoints;

	private Vector3[] points;

	private float[] distances;

	private float editorVisualisationSubsteps = 100f;

	private int p0n;

	private int p1n;

	private int p2n;

	private int p3n;

	private float i;

	private Vector3 P0;

	private Vector3 P1;

	private Vector3 P2;

	private Vector3 P3;

	private float lookAheadForTargetFactor = 0.1f;

	private float lookAheadForTargetOffset = 5f;

	private Vector3 targetPosition;

	private float TargetMult = 8f;

	private float progressDistance;

	private Vector3 lastPosition;

	private float speed;

	private bool m_start;

	private float m_distanceToTarget;

	private int m_wayPointIndex;

	private Quaternion m_bankRotation = Quaternion.identity;

	public float Length { get; private set; }

	public Transform[] Waypoints => waypointList.items;

	private void Awake()
	{
		if (Waypoints.Length > 1)
		{
			CachePositionsAndDistances();
		}
		numPoints = Waypoints.Length;
		Length = distances[distances.Length - 1];
	}

	private void Start()
	{
		m_start = false;
		progressDistance = 20f;
		lastPosition = Waypoints[0].transform.position;
		if (SceneryObject != null)
		{
			SceneryObject.transform.position = Waypoints[0].transform.position;
		}
	}

	private void Update()
	{
		if (SceneryObject != null)
		{
			Vector3 vector = targetPosition - SceneryObject.transform.position;
			m_distanceToTarget = vector.sqrMagnitude;
			if (GameTime.Instance.DeltaTime() > 0f)
			{
				speed = Mathf.Lerp(speed, (lastPosition - SceneryObject.transform.position).magnitude / GameTime.Instance.DeltaTime(), GameTime.Instance.DeltaTime());
			}
			float dist = progressDistance + lookAheadForTargetOffset + lookAheadForTargetFactor * speed;
			SceneryRoutePoint routePoint = GetRoutePoint(dist);
			Vector3 position = routePoint.position;
			targetPosition = position;
			if (!m_start)
			{
				m_start = true;
				SceneryObject.transform.position = Waypoints[0].transform.position;
			}
			else if (AttachToTarget)
			{
				SceneryObject.transform.position = targetPosition - routePoint.direction * 0.1f;
			}
			else
			{
				SceneryObject.transform.position = Vector3.Lerp(SceneryObject.transform.position, targetPosition, ObjectSpeed * Time.deltaTime);
			}
			if (RotateWithDirection)
			{
				if (vector.normalized.sqrMagnitude > 0f)
				{
					SceneryObject.transform.rotation = Quaternion.LookRotation(vector.normalized);
				}
			}
			else if (RotationConfig.SpeedOfRotation != 0f)
			{
				Quaternion quaternion = Quaternion.AngleAxis(RotationConfig.SpeedOfRotation * GameTime.Instance.DeltaTime(), new Vector3((!RotationConfig.RotateOnAxis_X) ? 0f : 1f, (!RotationConfig.RotateOnAxis_Y) ? 0f : 1f, (!RotationConfig.RotateOnAxis_Z) ? 0f : 1f));
				SceneryObject.transform.rotation *= quaternion;
			}
			if (!Mathf.Approximately(MaxBankAngle, 0f))
			{
				int wayPointIndex = 0;
				float wayPointIndexFromDistance = GetWayPointIndexFromDistance(dist, ref wayPointIndex);
				int num = wayPointIndex - 1;
				if (num < 0)
				{
					num = distances.Length - 1;
				}
				SceneryRoutePoint routePoint2 = GetRoutePoint(distances[num]);
				SceneryRoutePoint routePoint3 = GetRoutePoint(wayPointIndexFromDistance);
				float num2 = Vector3.Angle(routePoint2.direction, routePoint3.direction);
				Vector3 lhs = Vector3.Cross(routePoint3.direction, Vector3.up);
				if (Vector3.Dot(lhs, routePoint2.direction) < 0f)
				{
					num2 = 0f - num2;
				}
				num2 /= 45f;
				num2 *= MaxBankAngle;
				Quaternion b = Quaternion.AngleAxis(0f - num2, Vector3.forward);
				m_bankRotation = Quaternion.Slerp(m_bankRotation, b, 2f * GameTime.Instance.DeltaTime());
				SceneryObject.transform.rotation *= m_bankRotation;
			}
			lastPosition = SceneryObject.transform.position;
		}
		float num3 = ObjectSpeed * TargetMult;
		if (m_distanceToTarget > 100f)
		{
			num3 *= 0.5f;
		}
		else if (m_distanceToTarget > 4f)
		{
			num3 *= 2f;
		}
		progressDistance += num3 * Time.deltaTime;
	}

	public SceneryRoutePoint GetRoutePoint(float dist)
	{
		Vector3 routePosition = GetRoutePosition(dist);
		Vector3 routePosition2 = GetRoutePosition(dist + 0.1f);
		return new SceneryRoutePoint(routePosition, (routePosition2 - routePosition).normalized);
	}

	public float GetWayPointIndexFromDistance(float dist, ref int wayPointIndex)
	{
		int i = 0;
		if (Length == 0f)
		{
			Length = distances[distances.Length - 1];
		}
		for (dist = Mathf.Repeat(dist, Length); distances[i] < dist; i++)
		{
		}
		wayPointIndex = i;
		return distances[i];
	}

	public Vector3 GetRoutePosition(float dist)
	{
		int i = 0;
		if (Length == 0f)
		{
			Length = distances[distances.Length - 1];
		}
		for (dist = Mathf.Repeat(dist, Length); distances[i] < dist; i++)
		{
		}
		p1n = (i - 1 + numPoints) % numPoints;
		p2n = i;
		this.i = Mathf.InverseLerp(distances[p1n], distances[p2n], dist);
		p0n = (i - 2 + numPoints) % numPoints;
		p3n = (i + 1) % numPoints;
		p2n %= numPoints;
		P0 = points[p0n];
		P1 = points[p1n];
		P2 = points[p2n];
		P3 = points[p3n];
		return CatmullRom(P0, P1, P2, P3, this.i);
	}

	public Vector3 GetRoutePositionByIndex(float distance, int pathIndex)
	{
		Vector3 routePosition = GetRoutePosition(distance);
		Vector3 routePosition2 = GetRoutePosition(distance + 0.2f);
		(routePosition - routePosition2).Normalize();
		return routePosition;
	}

	private Vector3 CatmullRom(Vector3 _P0, Vector3 _P1, Vector3 _P2, Vector3 _P3, float _i)
	{
		return 0.5f * (2f * _P1 + (-_P0 + _P2) * _i + (2f * _P0 - 5f * _P1 + 4f * _P2 - _P3) * _i * _i + (-_P0 + 3f * _P1 - 3f * _P2 + _P3) * _i * _i * _i);
	}

	private void CachePositionsAndDistances()
	{
		points = new Vector3[Waypoints.Length + 1];
		distances = new float[Waypoints.Length + 1];
		float num = 0f;
		for (int i = 0; i < points.Length; i++)
		{
			Transform transform = Waypoints[i % Waypoints.Length];
			Transform transform2 = Waypoints[(i + 1) % Waypoints.Length];
			if (transform != null && transform2 != null)
			{
				Vector3 position = transform.position;
				Vector3 position2 = transform2.position;
				ref Vector3 reference = ref points[i];
				reference = Waypoints[i % Waypoints.Length].position;
				distances[i] = num;
				num += (position - position2).magnitude;
			}
		}
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(selected: false);
	}

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(selected: true);
	}

	private void DrawGizmos(bool selected)
	{
		waypointList.circuit = this;
		Gizmos.DrawSphere(targetPosition, 1f);
		if (Waypoints.Length <= 1)
		{
			return;
		}
		numPoints = Waypoints.Length;
		CachePositionsAndDistances();
		Length = distances[distances.Length - 1];
		Vector3 from = Waypoints[0].position;
		Gizmos.color = SplineColor;
		for (float num = 0f; num < Length; num += Length / editorVisualisationSubsteps)
		{
			Vector3 routePosition = GetRoutePosition(num + 1f);
			Gizmos.DrawLine(from, routePosition);
			from = routePosition;
		}
		Gizmos.DrawLine(from, Waypoints[0].position);
		if (selected && EnableDebugInformation)
		{
			Gizmos.color = UnityEngine.Color.cyan;
			for (int i = 0; i < Waypoints.Length; i++)
			{
				SceneryRoutePoint routePoint = GetRoutePoint(distances[i]);
				Gizmos.DrawLine(Waypoints[i].position, Waypoints[i].position + routePoint.direction * 25f);
				Gizmos.DrawCube(Waypoints[i].position, new Vector3(5f, 5f, 5f));
			}
		}
	}
}
[ExecuteInEditMode]
public class SplitLaneZone : UnityEngine.MonoBehaviour
{
	public static bool ShowAllSplitZones;

	private SplitLane m_splitLane;

	public void SetSplitLane(ref SplitLane lane)
	{
		m_splitLane = lane;
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider col)
	{
		SetInSplitLane(col, set: true);
	}

	private void OnTriggerExit(Collider col)
	{
		SetInSplitLane(col, set: false);
	}

	private void SetInSplitLane(Collider col, bool set)
	{
		Transform parent = col.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if ((bool)parent)
		{
			parent.gameObject.GetComponent<Player>().SetInSplitLane(set, ref m_splitLane);
		}
	}
}
public class StartLine : UnityEngine.MonoBehaviour
{
	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.green;
		float num = 0f;
		for (int i = 0; i < 3; i++)
		{
			DrawLine(base.transform.position + new Vector3(-20f, num, 0f), base.transform.position + new Vector3(20f, num, 0f));
			DrawLine(base.transform.position + new Vector3(0f, num, 0f), base.transform.position + new Vector3(0f, num, 5f));
			DrawLine(base.transform.position + new Vector3(0f, num, 5f), base.transform.position + new Vector3(1f, num, 4f));
			DrawLine(base.transform.position + new Vector3(0f, num, 5f), base.transform.position + new Vector3(-1f, num, 4f));
			num += 1f;
		}
	}

	private void DrawLine(Vector3 vec1, Vector3 vec2)
	{
		vec1 -= base.transform.position;
		vec1 = base.transform.rotation * vec1;
		vec1 += base.transform.position;
		vec2 -= base.transform.position;
		vec2 = base.transform.rotation * vec2;
		vec2 += base.transform.position;
		Gizmos.DrawLine(vec1, vec2);
	}
}
public class WaitingForPlayersBoard : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private TextMesh[] DisplayText;

	private const float ShowTime = 2f;

	private bool m_showing;

	private float m_currentScale;

	private string textToDisplay = string.Empty;

	public void ShowBoard()
	{
		if (!m_showing)
		{
			SetupText();
			m_showing = true;
			m_currentScale = 0f;
		}
	}

	public void HideBoard()
	{
		m_showing = false;
	}

	private void SetupText()
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
		{
			if (FTUE.Instance.State == FTUE.FTUEState.Practice1)
			{
				textToDisplay = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Complete1Lap", convertToUpperCase: true);
			}
			else if (FTUE.Instance.State == FTUE.FTUEState.Practice2)
			{
				textToDisplay = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_RaceWithOthers", convertToUpperCase: true);
			}
			else if (FTUE.Instance.State == FTUE.FTUEState.Practice3)
			{
				textToDisplay = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_HitBalloons", convertToUpperCase: true);
			}
			else if (FTUE.Instance.State == FTUE.FTUEState.Practice4)
			{
				textToDisplay = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_RaceAndFire", convertToUpperCase: true);
			}
		}
		else
		{
			textToDisplay = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_WaitingForPlayers", convertToUpperCase: true);
		}
		for (int i = 0; i < DisplayText.Length; i++)
		{
			DisplayText[i].text = textToDisplay;
		}
	}

	private void Update()
	{
		if (m_showing)
		{
			if (m_currentScale < 1f)
			{
				m_currentScale += 2f * GameTime.Instance.DeltaTime();
				if (m_currentScale >= 1f)
				{
					m_currentScale = 1f;
				}
			}
		}
		else if (m_currentScale > 0f)
		{
			m_currentScale -= 2f * GameTime.Instance.DeltaTime();
			if (m_currentScale <= 0f)
			{
				base.gameObject.SetActive(value: false);
			}
		}
		base.transform.localScale = new Vector3(1f, m_currentScale, 1f);
	}
}
public class DisruptArrows : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private KartUserControl Kart;

	[SerializeField]
	private MeshRenderer[] Arrows;

	[SerializeField]
	private float MinAlpha;

	[SerializeField]
	private float MaxAlpha;

	[SerializeField]
	private float MinSpeed;

	[SerializeField]
	private float MaxSpeed;

	private float[] m_currentAlpha = new float[2];

	private float[] m_targetAlpha = new float[2];

	private float[] m_currentSpeed = new float[2];

	private float[] m_targetSpeed = new float[2];

	private void OnEnable()
	{
		m_currentAlpha[0] = MinAlpha;
		m_targetAlpha[0] = MinAlpha;
		m_currentAlpha[1] = MinAlpha;
		m_targetAlpha[1] = MinAlpha;
		m_currentSpeed[0] = MinSpeed;
		m_targetSpeed[0] = MinSpeed;
		m_currentSpeed[1] = MinSpeed;
		m_targetSpeed[1] = MinSpeed;
	}

	private void Update()
	{
		UpdateAlpha();
		UpdateMovement();
	}

	private void UpdateAlpha()
	{
		float steeringAngle = Kart.GetSteeringAngle();
		if (steeringAngle < -0.02f)
		{
			m_targetAlpha[0] = (MaxAlpha - MinAlpha) * Mathf.Abs(steeringAngle) + MinAlpha;
			m_targetAlpha[1] = MinAlpha;
		}
		else if (steeringAngle > 0.02f)
		{
			m_targetAlpha[0] = MinAlpha;
			m_targetAlpha[1] = (MaxAlpha - MinAlpha) * Mathf.Abs(steeringAngle) + MinAlpha;
		}
		else
		{
			m_targetAlpha[0] = MinAlpha;
			m_targetAlpha[1] = MinAlpha;
		}
		m_currentAlpha[0] = Mathf.Lerp(m_currentAlpha[0], m_targetAlpha[0], 4f * GameTime.Instance.DeltaTime());
		m_currentAlpha[1] = Mathf.Lerp(m_currentAlpha[1], m_targetAlpha[1], 4f * GameTime.Instance.DeltaTime());
		UnityEngine.Color color = Arrows[0].material.color;
		color.a = m_currentAlpha[0];
		Arrows[0].material.color = color;
		color = Arrows[1].material.color;
		color.a = m_currentAlpha[1];
		Arrows[1].material.color = color;
	}

	private void UpdateMovement()
	{
		float steeringAngle = Kart.GetSteeringAngle();
		if (steeringAngle < -0.02f)
		{
			m_targetSpeed[0] = (MaxSpeed - MinSpeed) * Mathf.Abs(steeringAngle) + MinSpeed;
			m_targetSpeed[1] = MinSpeed;
		}
		else if (steeringAngle > 0.02f)
		{
			m_targetSpeed[0] = MinSpeed;
			m_targetSpeed[1] = (MaxSpeed - MinSpeed) * Mathf.Abs(steeringAngle) + MinSpeed;
		}
		else
		{
			m_targetSpeed[0] = MinSpeed;
			m_targetSpeed[1] = MinSpeed;
		}
		m_currentSpeed[0] = Mathf.Lerp(m_currentSpeed[0], m_targetSpeed[0], 4f * GameTime.Instance.DeltaTime());
		m_currentSpeed[1] = Mathf.Lerp(m_currentSpeed[1], m_targetSpeed[1], 4f * GameTime.Instance.DeltaTime());
		Quaternion quaternion = Quaternion.AngleAxis(0f - m_currentSpeed[0], Vector3.forward);
		Arrows[0].transform.localRotation *= quaternion;
		Quaternion quaternion2 = Quaternion.AngleAxis(m_currentSpeed[1], Vector3.forward);
		Arrows[1].transform.localRotation *= quaternion2;
	}
}
[ExecuteInEditMode]
public class HeadlightDetection : UnityEngine.MonoBehaviour
{
	public static bool ShowAlHeadlightZones;

	[SerializeField]
	private bool EnableHeadlights = true;

	[SerializeField]
	private bool EnableReverb;

	[SerializeField]
	private bool DuckEnvAudio;

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider col)
	{
		SetInHeadlightZone(col, entered: true, EnableHeadlights);
	}

	private void OnTriggerExit(Collider col)
	{
		SetInHeadlightZone(col, entered: false, EnableHeadlights);
	}

	private void SetInHeadlightZone(Collider col, bool entered, bool enableLights)
	{
		Transform parent = col.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if (!parent)
		{
			return;
		}
		Player player = parent.GetComponent<Player>();
		bool entered2 = player.InHeadlightZone(entered, base.gameObject.transform.position, enableLights);
		if (player.GetPlayerType() == Player.PlayerType.Human)
		{
			if (EnableReverb)
			{
				CameraManager.Instance.EnableReverbFilter(entered);
			}
			if (DuckEnvAudio)
			{
				Gameplay.Instance.SetLowEnvAudio(entered);
			}
			ToggleEnvFX(ref player, entered2);
		}
	}

	private void ToggleEnvFX(ref Player player, bool entered)
	{
		PlayerFX component = player.GetComponent<PlayerFX>();
		if ((bool)component)
		{
			switch (GameSystem.Instance.GetLoadedTrack().TrackWeather)
			{
			case TrackList.WeatherType.Snowy:
				component.EnableSnow(!entered);
				break;
			case TrackList.WeatherType.Blizzard:
				component.EnableBlizzard(!entered);
				break;
			}
		}
	}
}
public class KartBoostTrail : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private KartController MainPlayer;

	[SerializeField]
	private float TransitionTime = 1f;

	private TrailRenderer m_trailRendererer;

	private bool m_endingTrail;

	private UnityEngine.Color m_colourToSet;

	private bool m_readyToSetColour;

	public void SetColour(UnityEngine.Color col)
	{
		if (m_trailRendererer != null)
		{
			m_trailRendererer.material.SetColor("_TintColor", col);
			return;
		}
		m_colourToSet = col;
		m_readyToSetColour = true;
	}

	private void Awake()
	{
		m_trailRendererer = GetComponent<TrailRenderer>();
		m_trailRendererer.enabled = false;
	}

	private void Start()
	{
		Player component = MainPlayer.GetComponent<Player>();
		UnityEngine.Color value = ((!m_readyToSetColour) ? ProfileManager.Instance.GetPlayerData(component.LocalPlayerIndex).m_playerColours.BoostTrail : m_colourToSet);
		m_trailRendererer.material.SetColor("_TintColor", value);
	}

	private void Update()
	{
		if (m_trailRendererer.enabled && MainPlayer.GetComponent<Player>().PlayerFinishState == Player.PlayerFinishedState.InResults)
		{
			m_trailRendererer.time = 0f;
			m_endingTrail = false;
			m_trailRendererer.enabled = false;
			return;
		}
		if (MainPlayer.IsBoostEnabled())
		{
			if (m_trailRendererer.time < 1f)
			{
				m_endingTrail = false;
				m_trailRendererer.time = 1f;
				UnityEngine.Color color = m_trailRendererer.material.GetColor("_TintColor");
				color.a = 1f;
				m_trailRendererer.material.SetColor("_TintColor", color);
				if (!m_trailRendererer.enabled)
				{
					m_trailRendererer.enabled = true;
				}
			}
		}
		else if (!MainPlayer.IsBoostEnabled() && !m_endingTrail)
		{
			m_endingTrail = true;
		}
		if (m_endingTrail)
		{
			UnityEngine.Color color2 = m_trailRendererer.material.GetColor("_TintColor");
			color2.a -= TransitionTime * GameTime.Instance.DeltaTime();
			if (color2.a < 0f)
			{
				color2.a = 0f;
			}
			m_trailRendererer.material.SetColor("_TintColor", color2);
			m_trailRendererer.time -= TransitionTime * GameTime.Instance.DeltaTime();
			if (m_trailRendererer.time < 0f)
			{
				m_trailRendererer.time = 0f;
				m_endingTrail = false;
				m_trailRendererer.enabled = false;
			}
		}
	}
}
public class KartBufferZone : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float MinSpeedToHit = 20f;

	[SerializeField]
	private float MaxSpeedToHit = 50f;

	[SerializeField]
	private float NormalisedImpulseScale = 50f;

	[SerializeField]
	private float VelocityKillScale = 0.5f;

	private KartController m_player;

	private void Start()
	{
		Transform parent = base.transform;
		while (parent != null && parent.gameObject.GetComponent<KartController>() == null)
		{
			parent = parent.parent;
		}
		if ((bool)parent)
		{
			m_player = parent.GetComponent<KartController>();
		}
	}

	private void OnTriggerEnter(Collider col)
	{
		CollisionDetected(col);
	}

	private void CollisionDetected(Collider col)
	{
		if (col.gameObject.layer == 22)
		{
			Transform parent = col.transform;
			while (parent != null && parent.gameObject.GetComponent<KartController>() == null)
			{
				parent = parent.parent;
			}
			if ((bool)parent)
			{
				PushAway(parent.GetComponent<KartController>());
			}
		}
	}

	private void PushAway(KartController kart)
	{
		kart.GetComponent<Rigidbody>().velocity *= VelocityKillScale;
		float currentSpeed = kart.CurrentSpeed;
		currentSpeed = Mathf.Clamp(currentSpeed, MinSpeedToHit, MaxSpeedToHit);
		Vector3 normalized = (m_player.transform.position - kart.transform.position).normalized;
		kart.GetComponent<Rigidbody>().AddForce(normalized * (currentSpeed * NormalisedImpulseScale), ForceMode.Impulse);
	}
}
public class KartCollision : UnityEngine.MonoBehaviour
{
	private void OnTriggerEnter(Collider col)
	{
		Transform parent = base.transform;
		Transform parent2 = col.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		while (parent2 != null && parent2.gameObject.GetComponent<Player>() == null)
		{
			parent2 = parent2.parent;
		}
		parent.gameObject.GetComponent<Player>().GetComponent<Rigidbody>().AddForce(-Vector3.up * 100f);
		parent2.gameObject.GetComponent<Player>().GetComponent<Rigidbody>().AddForce(-Vector3.up * 100f);
	}

	private void OnTriggerStay(Collider col)
	{
		Transform parent = base.transform;
		Transform parent2 = col.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		while (parent2 != null && parent2.gameObject.GetComponent<Player>() == null)
		{
			parent2 = parent2.parent;
		}
		parent.gameObject.GetComponent<Player>().GetComponent<Rigidbody>().AddForce(Vector3.up * 100f);
		parent2.gameObject.GetComponent<Player>().GetComponent<Rigidbody>().AddForce(Vector3.up * 100f);
	}
}
internal enum CarDriveType
{
	FrontWheelDrive,
	RearWheelDrive,
	FourWheelDrive
}
internal enum SpeedType
{
	MPH,
	KPH
}
public class KartController : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private CarDriveType m_CarDriveType = CarDriveType.FourWheelDrive;

	[SerializeField]
	private WheelCollider[] m_WheelColliders = new WheelCollider[4];

	[SerializeField]
	private GameObject[] m_WheelMeshes = new GameObject[4];

	[SerializeField]
	private Vector3 m_CentreOfMassOffset;

	[Range(0f, 1f)]
	[SerializeField]
	private float m_SteerHelper;

	[Range(0f, 1f)]
	[SerializeField]
	private float m_TractionControl;

	[SerializeField]
	private float m_FullTorqueOverAllWheels;

	[SerializeField]
	private float m_ReverseTorque;

	[SerializeField]
	private float m_MaxHandbrakeTorque;

	[SerializeField]
	private float m_Downforce = 100f;

	[SerializeField]
	private SpeedType m_SpeedType;

	[HideInInspector]
	private float m_Topspeed = 55f;

	[SerializeField]
	private static int NoOfGears = 1;

	[SerializeField]
	private float m_RevRangeBoundary = 1f;

	[SerializeField]
	private float m_SlipLimit;

	[SerializeField]
	private float m_BrakeTorque;

	[SerializeField]
	private float noAccelDragVal = 0.5f;

	[HideInInspector]
	public float m_topSpeedLimit;

	[SerializeField]
	private ParticleSystem SpeedStreaks;

	[SerializeField]
	private ParticleSystem SpeedBoostLines;

	[SerializeField]
	private float maxExtraSpeedPickup = 10f;

	[SerializeField]
	private float maxSlowSteerAngle = 28f;

	[SerializeField]
	private float maxSteerAngle = 28f;

	[SerializeField]
	private float maxSlowSpeedForSlowAngle = 20f;

	[SerializeField]
	private float speedForMaxSteeringAngle = 25f;

	[SerializeField]
	public float SteeringScaleFactor = 1.5f;

	[SerializeField]
	public float MinWheelAngle = 1.5f;

	[SerializeField]
	public float WheelSteeringScaleMultiplier = 6f;

	[SerializeField]
	private float SlopeBoost = 6000f;

	[SerializeField]
	public float SteeringScale = 1f;

	[NonSerialized]
	public float DefaultSteeringScale = 1f;

	private bool m_onSlope;

	private float m_lastSteerInput;

	private Quaternion[] m_WheelMeshLocalRotations;

	private Vector3 m_Prevpos;

	private Vector3 m_Pos;

	private float m_SteerAngle;

	private int m_GearNum;

	private float m_GearFactor;

	private float m_OldRotation;

	private float m_CurrentTorque;

	private Rigidbody m_Rigidbody;

	private const float k_ReversingThreshold = 0.01f;

	private float m_reverseControls;

	private float m_tempDisableReverse;

	private float m_originalDragVal;

	private float currentSteeringAngle;

	private bool m_slipstreamEnabled;

	private float m_storedNoAccelDrag;

	private float m_speedPickupAmount;

	private bool m_speedBoost;

	private bool m_speedStreakVisuals;

	private float m_disableControlProbability = 0.05f;

	private float FullTorqueCached;

	private CarDriveType m_prevCarDriveType = CarDriveType.RearWheelDrive;

	private PlayerManager.GroundParticleType m_offroadOverride = PlayerManager.GroundParticleType.None;

	public float LastSteerInput => m_lastSteerInput;

	public bool Skidding { get; private set; }

	public float BrakeInput { get; private set; }

	public float CurrentSteerAngle => m_SteerAngle;

	public float CurrentSpeed => (!m_Rigidbody) ? 0f : (m_Rigidbody.velocity.magnitude * 2.2369363f);

	public float MaxSpeed
	{
		get
		{
			return m_topSpeedLimit;
		}
		set
		{
			m_topSpeedLimit = value;
		}
	}

	public float Revs { get; private set; }

	public float AccelInput { get; private set; }

	public float PreviousSpeed { get; set; }

	public float MaxSteerAngle => currentSteeringAngle;

	public float ScaledMaxSteeringAngle { get; set; }

	public bool IsReplayKart { get; set; }

	private void Awake()
	{
		IsReplayKart = false;
		m_topSpeedLimit = m_Topspeed;
		m_originalDragVal = GetComponent<Rigidbody>().drag;
		FullTorqueCached = m_FullTorqueOverAllWheels;
		DefaultSteeringScale = SteeringScale;
	}

	private void Start()
	{
		m_WheelMeshLocalRotations = new Quaternion[4];
		for (int i = 0; i < m_WheelMeshes.Length; i++)
		{
			ref Quaternion reference = ref m_WheelMeshLocalRotations[i];
			reference = m_WheelMeshes[i].transform.localRotation;
		}
		if (m_WheelColliders.Length > 0)
		{
			m_WheelColliders[0].attachedRigidbody.centerOfMass = m_CentreOfMassOffset;
		}
		m_MaxHandbrakeTorque = float.MaxValue;
		m_Rigidbody = GetComponent<Rigidbody>();
		m_CurrentTorque = m_FullTorqueOverAllWheels;
	}

	private void Update()
	{
		Player component = GetComponent<Player>();
		if (ReverseControlsEnabled() && component.GetPlayerType() == Player.PlayerType.AI && UnityEngine.Random.Range(0f, 1f) < m_disableControlProbability)
		{
			TemporaryReverseDisable(disable: true);
		}
		if (m_reverseControls > 0f)
		{
			m_reverseControls -= GameTime.Instance.DeltaTime();
			if (m_reverseControls <= 0f)
			{
				component.EnableReverseDisrupt(enable: false);
			}
		}
		if (m_tempDisableReverse > 0f)
		{
			m_tempDisableReverse -= GameTime.Instance.DeltaTime();
		}
		if (component.GetPlayerType() == Player.PlayerType.Human && NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom())
		{
			if (m_speedStreakVisuals)
			{
				NetworkLogin.Instance.GetClient().SetCharacterListEvent(component.SeatIndex, NetworkClient.EventMask.Boost);
			}
			else if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(component.SeatIndex, NetworkClient.EventMask.Boost))
			{
				NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(component.SeatIndex, NetworkClient.EventMask.Boost);
			}
		}
		else if (component.GetPlayerType() == Player.PlayerType.Network)
		{
			bool characterListEvent = NetworkLogin.Instance.GetClient().GetCharacterListEvent(component.SeatIndex, NetworkClient.EventMask.Boost);
			if (m_speedStreakVisuals != characterListEvent)
			{
				EnableSpeedBoost(characterListEvent, visualsOnly: true);
			}
		}
	}

	private void LimitKartAngle()
	{
		Vector3 zero = Vector3.zero;
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < m_WheelColliders.Length; i++)
		{
			Quaternion identity = Quaternion.identity;
			if (m_WheelColliders[i].GetGroundHit(out var hit))
			{
				zero = Quaternion.FromToRotation(Vector3.up, hit.normal).eulerAngles;
				num = zero.x - 5f;
				if (num < 0f)
				{
					num += 360f;
				}
				num2 = zero.x + 5f;
				num2 %= 360f;
				break;
			}
		}
		bool flag = false;
		Vector3 localEulerAngles = base.transform.localEulerAngles;
		localEulerAngles.z = 0f;
		if (localEulerAngles.x > 180f && localEulerAngles.x < num)
		{
			flag = true;
			localEulerAngles.x = num;
		}
		else if (localEulerAngles.x < 180f && localEulerAngles.x > num2)
		{
			flag = true;
			localEulerAngles.x = num2;
		}
		if (flag)
		{
			base.transform.localRotation = Quaternion.Slerp(base.transform.localRotation, Quaternion.Euler(localEulerAngles), 4f * GameTime.Instance.DeltaTime());
		}
	}

	private void CheckForSlopes()
	{
		float x = base.transform.localEulerAngles.x;
		m_onSlope = x > 180f && x < 359f;
		if (m_onSlope)
		{
			m_FullTorqueOverAllWheels = SlopeBoost;
			m_prevCarDriveType = m_CarDriveType;
			m_CarDriveType = CarDriveType.FourWheelDrive;
			return;
		}
		if (m_CarDriveType == CarDriveType.FourWheelDrive)
		{
			m_CarDriveType = m_prevCarDriveType;
		}
		m_FullTorqueOverAllWheels = FullTorqueCached;
	}

	private void FixedUpdate()
	{
		Vector3 velocity = GetComponent<Rigidbody>().velocity;
		if (velocity.y > 1f)
		{
			velocity.y = 1f;
		}
		GetComponent<Rigidbody>().velocity = velocity;
		GetComponent<Rigidbody>().angularVelocity = new Vector3(0f, GetComponent<Rigidbody>().angularVelocity.y, 0f);
		if (GetComponent<Player>().GetPlayerType() == Player.PlayerType.Human && AccelInput == 0f)
		{
			GetComponent<Rigidbody>().drag = noAccelDragVal;
		}
		else
		{
			GetComponent<Rigidbody>().drag = m_originalDragVal;
		}
	}

	public void Reset()
	{
		GetComponent<Player>().ImmobilizeTime = 0f;
	}

	public PlayerManager.GroundParticleType GetGroundOverride()
	{
		return m_offroadOverride;
	}

	public bool IsReversing()
	{
		if (!m_Rigidbody)
		{
			return false;
		}
		return base.transform.InverseTransformDirection(m_Rigidbody.velocity).z < 0f;
	}

	private void GearChanging()
	{
		float num = Mathf.Abs(CurrentSpeed / MaxSpeed);
		float num2 = 1f / (float)NoOfGears * (float)(m_GearNum + 1);
		float num3 = 1f / (float)NoOfGears * (float)m_GearNum;
		if (m_GearNum > 0 && num < num3)
		{
			m_GearNum--;
		}
		if (num > num2 && m_GearNum < NoOfGears - 1)
		{
			m_GearNum++;
		}
	}

	private static float CurveFactor(float factor)
	{
		return 1f - (1f - factor) * (1f - factor);
	}

	private static float ULerp(float from, float to, float value)
	{
		return (1f - value) * from + value * to;
	}

	private void CalculateGearFactor()
	{
		float num = 1f / (float)NoOfGears;
		float b = Mathf.InverseLerp(num * (float)m_GearNum, num * (float)(m_GearNum + 1), Mathf.Abs(CurrentSpeed / MaxSpeed));
		m_GearFactor = Mathf.Lerp(m_GearFactor, b, Time.deltaTime * 5f);
	}

	private void CalculateRevs()
	{
		CalculateGearFactor();
		float num = (float)m_GearNum / (float)NoOfGears;
		float from = ULerp(0f, m_RevRangeBoundary, CurveFactor(num));
		float to = ULerp(m_RevRangeBoundary, 1f, num);
		Revs = ULerp(from, to, m_GearFactor);
	}

	public void Move(float steering, float accel, float footbrake, float handbrake)
	{
		if (!IsReplayKart && (bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Game)
		{
			return;
		}
		PreviousSpeed = CurrentSpeed;
		if (ReverseControlsEnabled())
		{
			steering = 0f - steering;
		}
		m_lastSteerInput = steering;
		if (GetComponent<Player>().ImmobilizeTime > 0f)
		{
			accel = 0f;
			footbrake = 0f;
		}
		if (!Gameplay.Instance.RaceStarted() || !GetComponent<Player>().GridTimerIsGo())
		{
			accel = 0f;
			footbrake = 0f;
			if (GetComponent<Player>().GetPlayerType() == Player.PlayerType.AI)
			{
				m_SteerAngle = 0f;
				if ((bool)m_Rigidbody)
				{
					m_Rigidbody.velocity = Vector3.zero;
				}
				return;
			}
		}
		if (GetComponent<Player>() == Gameplay.Instance.GetMainHumanPlayer() && GetComponent<Player>().PlayerFinishState == Player.PlayerFinishedState.InResults)
		{
			GetComponent<Rigidbody>().velocity = Vector3.zero;
			m_WheelColliders[0].steerAngle = 0f;
			m_WheelColliders[1].steerAngle = 0f;
		}
		else
		{
			if (GetComponent<Player>().GetPlayerType() == Player.PlayerType.Network || GetComponent<Player>().GetPlayerType() == Player.PlayerType.FEM)
			{
				return;
			}
			for (int i = 0; i < m_WheelMeshes.Length; i++)
			{
				m_WheelColliders[i].GetWorldPose(out var _, out var quat);
				m_WheelMeshes[i].transform.rotation = quat;
			}
			steering = Mathf.Clamp(steering, -1f, 1f);
			AccelInput = (accel = Mathf.Clamp(accel, 0f, 1f));
			BrakeInput = (footbrake = -1f * Mathf.Clamp(footbrake, -1f, 0f));
			handbrake = Mathf.Clamp(handbrake, 0f, 1f);
			if (CurrentSpeed <= maxSlowSpeedForSlowAngle)
			{
				currentSteeringAngle = maxSlowSteerAngle;
			}
			else if (CurrentSpeed > speedForMaxSteeringAngle)
			{
				currentSteeringAngle = maxSteerAngle;
			}
			else
			{
				float num = speedForMaxSteeringAngle - maxSlowSpeedForSlowAngle;
				float num2 = (CurrentSpeed - maxSlowSpeedForSlowAngle) / num;
				if (num2 > 1f)
				{
					num2 = 1f;
				}
				currentSteeringAngle = Mathf.Lerp(maxSlowSteerAngle, maxSteerAngle, num2);
			}
			ScaledMaxSteeringAngle = maxSlowSteerAngle;
			m_SteerAngle = steering * currentSteeringAngle;
			m_WheelColliders[0].steerAngle = m_SteerAngle * SteeringScale;
			m_WheelColliders[1].steerAngle = m_SteerAngle * SteeringScale;
			SteerHelper();
			ApplyDrive(accel, footbrake);
			CapSpeed();
			if (handbrake > 0f)
			{
				float brakeTorque = handbrake * m_MaxHandbrakeTorque;
				m_WheelColliders[2].brakeTorque = brakeTorque;
				m_WheelColliders[3].brakeTorque = brakeTorque;
			}
			CalculateRevs();
			GearChanging();
			AddDownForce();
			CheckForWheelSpin();
			TractionControl();
		}
	}

	private void CapSpeed()
	{
		if (!m_Rigidbody)
		{
			return;
		}
		float magnitude = m_Rigidbody.velocity.magnitude;
		switch (m_SpeedType)
		{
		case SpeedType.MPH:
			magnitude *= 2.2369363f;
			if (magnitude > MaxSpeed)
			{
				m_Rigidbody.velocity = MaxSpeed / 2.2369363f * m_Rigidbody.velocity.normalized;
			}
			break;
		case SpeedType.KPH:
			magnitude *= 3.6f;
			if (magnitude > MaxSpeed)
			{
				m_Rigidbody.velocity = MaxSpeed / 3.6f * m_Rigidbody.velocity.normalized;
			}
			break;
		}
	}

	private void ApplyDrive(float accel, float footbrake)
	{
		switch (m_CarDriveType)
		{
		case CarDriveType.FourWheelDrive:
		{
			float motorTorque = accel * (m_CurrentTorque / 4f);
			for (int j = 0; j < m_WheelColliders.Length; j++)
			{
				m_WheelColliders[j].motorTorque = motorTorque;
			}
			break;
		}
		case CarDriveType.FrontWheelDrive:
		{
			float motorTorque = accel * (m_CurrentTorque / 2f);
			m_WheelColliders[0].motorTorque = motorTorque;
			m_WheelColliders[1].motorTorque = motorTorque;
			for (int i = 2; i < m_WheelColliders.Length; i++)
			{
				m_WheelColliders[i].motorTorque = 0f;
			}
			break;
		}
		case CarDriveType.RearWheelDrive:
		{
			float motorTorque = accel * (m_CurrentTorque / 2f);
			m_WheelColliders[2].motorTorque = motorTorque;
			m_WheelColliders[3].motorTorque = motorTorque;
			m_WheelColliders[0].motorTorque = 0f;
			m_WheelColliders[1].motorTorque = 0f;
			break;
		}
		}
		if (GetComponent<Player>().ImmobilizeTime > 0f)
		{
			for (int k = 0; k < m_WheelColliders.Length; k++)
			{
				m_WheelColliders[k].motorTorque = 0f;
			}
		}
		if (IsBoostEnabled())
		{
			KartUserControl component = GetComponent<KartUserControl>();
			for (int l = 0; l < m_WheelColliders.Length; l++)
			{
				m_WheelColliders[l].motorTorque *= component.SpeedBoostTorqueMultiplier;
			}
		}
		for (int m = 0; m < m_WheelColliders.Length; m++)
		{
			if (CurrentSpeed > 5f && Vector3.Angle(base.transform.forward, m_Rigidbody.velocity) < 50f)
			{
				m_WheelColliders[m].brakeTorque = m_BrakeTorque * footbrake;
			}
			else if (footbrake > 0f)
			{
				m_WheelColliders[m].brakeTorque = 0f;
				m_WheelColliders[m].motorTorque = (0f - m_ReverseTorque) * footbrake;
			}
		}
	}

	private void SteerHelper()
	{
		for (int i = 0; i < m_WheelColliders.Length; i++)
		{
			m_WheelColliders[i].GetGroundHit(out var hit);
			if (hit.normal == Vector3.zero)
			{
				return;
			}
		}
		if (Mathf.Abs(m_OldRotation - base.transform.eulerAngles.y) < 10f)
		{
			float angle = (base.transform.eulerAngles.y - m_OldRotation) * m_SteerHelper;
			Quaternion quaternion = Quaternion.AngleAxis(angle, Vector3.up);
			m_Rigidbody.velocity = quaternion * m_Rigidbody.velocity;
		}
		m_OldRotation = base.transform.eulerAngles.y;
	}

	private void AddDownForce()
	{
		m_WheelColliders[0].attachedRigidbody.AddForce(-base.transform.up * m_Downforce * m_WheelColliders[0].attachedRigidbody.velocity.magnitude);
	}

	private void CheckForWheelSpin()
	{
	}

	private void TractionControl()
	{
		WheelHit hit;
		switch (m_CarDriveType)
		{
		case CarDriveType.FourWheelDrive:
		{
			for (int i = 0; i < m_WheelColliders.Length; i++)
			{
				m_WheelColliders[i].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
			}
			break;
		}
		case CarDriveType.RearWheelDrive:
			m_WheelColliders[2].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			m_WheelColliders[3].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			break;
		case CarDriveType.FrontWheelDrive:
			m_WheelColliders[0].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			m_WheelColliders[1].GetGroundHit(out hit);
			AdjustTorque(hit.forwardSlip);
			break;
		}
	}

	private void AdjustTorque(float forwardSlip)
	{
		if (forwardSlip >= m_SlipLimit && m_CurrentTorque >= 0f)
		{
			m_CurrentTorque -= 10f * m_TractionControl;
			return;
		}
		m_CurrentTorque += 10f * m_TractionControl;
		if (m_CurrentTorque > m_FullTorqueOverAllWheels)
		{
			m_CurrentTorque = m_FullTorqueOverAllWheels;
		}
	}

	private bool AnySkidSoundPlaying()
	{
		return false;
	}

	public void TemporaryReverseDisable(bool disable)
	{
		m_tempDisableReverse = ((!disable) ? 0f : 0.2f);
	}

	public void EnableSpeedBoost(bool enable, bool visualsOnly = false)
	{
		m_speedStreakVisuals = enable;
		if (GetComponent<Player>().GetPlayerType() == Player.PlayerType.Human)
		{
			if ((bool)SpeedStreaks)
			{
				if (enable)
				{
					SpeedStreaks.Play();
				}
				else
				{
					SpeedStreaks.Stop();
				}
			}
		}
		else if ((bool)SpeedBoostLines)
		{
			SpeedBoostLines.gameObject.SetActive(enable);
		}
		if (!visualsOnly)
		{
			m_speedBoost = enable;
			UpdateTopSpeed();
		}
	}

	public bool IsBoostEnabled()
	{
		return m_speedBoost || m_speedStreakVisuals;
	}

	private void UpdateTopSpeed()
	{
		m_topSpeedLimit = m_Topspeed + m_speedPickupAmount;
		if (m_slipstreamEnabled)
		{
			m_topSpeedLimit += PlayerManager.Instance.SlipstreamSpeedIncrease;
		}
		KartUserControl component = GetComponent<KartUserControl>();
		if (m_speedBoost && (bool)component)
		{
			if (GetComponent<Player>().GetPlayerType() == Player.PlayerType.Human)
			{
				float num = Mathf.Clamp(CurrentSpeed / component.TopSpeedForBoostBonus, 0f, 1f);
				num = 1f - num;
				m_topSpeedLimit += component.AdditionalBoostSpeed + component.SpeedBoostBonus * num;
			}
			else
			{
				m_topSpeedLimit += component.AdditionalBoostSpeed;
			}
		}
	}

	public void OverrideGroundParticle(PlayerManager.GroundParticleType type)
	{
		m_offroadOverride = type;
		for (int i = 0; i < m_WheelColliders.Length; i++)
		{
			m_WheelColliders[i].GetComponent<KartWheel>().OverrideGroundParticle(type);
		}
	}

	public void ResetGroundParticleOverride()
	{
		m_offroadOverride = PlayerManager.GroundParticleType.None;
		for (int i = 0; i < m_WheelColliders.Length; i++)
		{
			m_WheelColliders[i].GetComponent<KartWheel>().ResetGroundParticleOverride();
		}
	}

	public void SlipStreamEnable(bool enable)
	{
		m_slipstreamEnabled = enable;
		UpdateTopSpeed();
	}

	public void IncreaseSpeedPickupAmount(float amount)
	{
		m_speedPickupAmount += amount;
		if (m_speedPickupAmount > maxExtraSpeedPickup)
		{
			m_speedPickupAmount = maxExtraSpeedPickup;
		}
		UpdateTopSpeed();
	}

	public float GetTopSpeed()
	{
		return m_topSpeedLimit;
	}

	public float GetDefaultSpeed()
	{
		return m_Topspeed;
	}

	public void SetDefaultSpeed(float speed)
	{
		m_Topspeed = speed;
	}

	public void StopAllParticles()
	{
		for (int i = 0; i < m_WheelColliders.Length; i++)
		{
			m_WheelColliders[i].GetComponent<KartWheel>().StopAllParticles(PlayerManager.GroundParticleType.Grass);
			m_WheelColliders[i].GetComponent<KartWheel>().StopAllParticles(PlayerManager.GroundParticleType.Sand);
			m_WheelColliders[i].GetComponent<KartWheel>().StopAllParticles(PlayerManager.GroundParticleType.Mud);
			m_WheelColliders[i].GetComponent<KartWheel>().StopAllParticles(PlayerManager.GroundParticleType.Rain);
			m_WheelColliders[i].GetComponent<KartWheel>().StopAllParticles(PlayerManager.GroundParticleType.Rock);
			m_WheelColliders[i].GetComponent<KartWheel>().StopAllParticles(PlayerManager.GroundParticleType.Snow);
		}
	}

	public void TurnOffWheelEffects()
	{
		StopAllParticles();
		for (int i = 0; i < m_WheelColliders.Length; i++)
		{
			m_WheelColliders[i].GetComponent<KartWheel>().TurnOffWheelEffects();
		}
	}

	public void Immobilize(float duration, Gameplay.HitByType hitType)
	{
		Player player = GetComponent<Player>();
		ProfileManager.Instance.SetImmobolizeExhaust(ref player, set: true, hitType);
		if (m_storedNoAccelDrag == 0f)
		{
			m_storedNoAccelDrag = noAccelDragVal;
			noAccelDragVal = 0.5f;
		}
		player.Immobilize(duration);
	}

	public void ResetMaxSpeed()
	{
		noAccelDragVal = m_storedNoAccelDrag;
		m_storedNoAccelDrag = 0f;
	}

	public void OverrideMaxSpeed(float speed)
	{
		MaxSpeed = speed;
		SetDefaultSpeed(speed);
	}

	public bool ReverseControlsEnabled()
	{
		return m_reverseControls > 0f && m_tempDisableReverse <= 0f;
	}

	public void DisableReverseControls()
	{
		m_reverseControls = 0f;
		m_tempDisableReverse = 0f;
	}

	public void EnableReverseControls(float disableControlsProbability = 0.05f)
	{
		m_disableControlProbability = disableControlsProbability;
		m_reverseControls = WeaponManager.Instance.ReverseControlsTime;
	}
}
public class KartDashboard : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject SpeedoNeedle;

	[SerializeField]
	private GameObject PickupBar;

	[SerializeField]
	private UnityEngine.UI.Image PickupLightBar;

	[SerializeField]
	private GameObject WarningLight;

	[SerializeField]
	private GameObject WeaponLight;

	[SerializeField]
	private GameObject WeaponIconDetail;

	[SerializeField]
	private TextMesh InfoText;

	[SerializeField]
	private float LightSpeed = 10f;

	[SerializeField]
	private AudioSource WarningAudio;

	[SerializeField]
	private AudioSource WeaponAudio;

	[SerializeField]
	private AudioClip WeaponScrollClip;

	[SerializeField]
	private AudioClip WeaponSelectClip;

	private float m_currentUV;

	private float[] WeaponUV = new float[11]
	{
		1f, 0.0615f, 0.1245f, 0.1865f, 0.249f, 0.313f, 0.374f, 0.4362f, 0.498f, 0.95f,
		0.624f
	};

	private KartController m_kartController;

	private Player m_player;

	private float m_targetAngle;

	private int m_totalCars;

	private const float k_AngleSpeed = 6f;

	private float m_warningLightTimer;

	private float m_weaponUVOffset;

	private bool m_scrollingWeapon;

	private const float ScrollMultiplier = 1f;

	private const float LerpToTarget = 2f;

	private const float DashboardPitchOffset = 1f;

	private static float PickupMovementSpeed = 1f;

	private string m_str1 = string.Empty;

	private string m_str2 = string.Empty;

	public bool ScrollingWeapon()
	{
		return m_scrollingWeapon;
	}

	public void HideAllPickups()
	{
		m_currentUV = 0f;
		SetLightBarUV(0f);
	}

	public void ResetPickups()
	{
		m_currentUV = 0f;
		SetLightBarUV(0f);
	}

	public void EnableDashboard()
	{
		PickupBar.gameObject.SetActive(value: true);
		SpeedoNeedle.gameObject.SetActive(value: true);
		PickupLightBar.gameObject.SetActive(value: true);
		InfoText.gameObject.SetActive(value: true);
	}

	public void DisableDashboard()
	{
		PickupBar.gameObject.SetActive(value: false);
		SpeedoNeedle.gameObject.SetActive(value: false);
		PickupLightBar.gameObject.SetActive(value: false);
		InfoText.gameObject.SetActive(value: false);
	}

	private void Awake()
	{
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && (bool)GetComponent<PhotonView>() && !GetComponent<PhotonView>().isMine)
		{
			base.enabled = false;
		}
	}

	private void Start()
	{
		m_player = GetComponent<Player>();
		m_kartController = GetComponent<KartController>();
		ResetPickups();
		if ((bool)PlayerManager.Instance)
		{
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				m_totalCars = NetworkLogin.Instance.GetRoomPlayerCount();
			}
			else
			{
				m_totalCars = PlayerManager.Instance.GetPlayerList().Count;
			}
		}
	}

	private void Update()
	{
		if (m_player.PlayerFinishState != Player.PlayerFinishedState.InResults)
		{
			UpdateNeedle();
			UpdateLights();
			UpdateSpeedo();
			return;
		}
		if (WeaponAudio.isPlaying)
		{
			WeaponAudio.Stop();
		}
		if (WarningAudio.isPlaying)
		{
			WarningAudio.Stop();
		}
	}

	private void UpdateNeedle()
	{
		if (!(SpeedoNeedle == null))
		{
			float num = m_kartController.CurrentSpeed / 100f * 185f;
			if (num < 0f)
			{
				num = 0f;
			}
			num -= 5f;
			m_targetAngle = Mathf.LerpAngle(m_targetAngle, num, 6f * GameTime.Instance.DeltaTime());
			SpeedoNeedle.transform.localEulerAngles = new Vector3(SpeedoNeedle.transform.localEulerAngles.x, SpeedoNeedle.transform.localEulerAngles.y, 0f - m_targetAngle);
		}
	}

	private void UpdateLights()
	{
		if ((ResultsManager.Instance != null && ResultsManager.Instance.ResultsActive()) || ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() > FEMManager.FEMOnlineState.None))
		{
			if (WarningAudio.isPlaying)
			{
				WarningAudio.Stop();
			}
			WeaponLight.SetActive(value: false);
			WeaponIconDetail.SetActive(value: false);
			WarningLight.SetActive(value: false);
			SetLightBarUV(0f);
			return;
		}
		float speedPickupAmount = m_player.GetSpeedPickupAmount();
		if (!Mathf.Approximately(m_currentUV, speedPickupAmount))
		{
			if (m_currentUV > speedPickupAmount)
			{
				if (m_player.MeterFillAudioSource != null)
				{
					if (!m_player.MeterFillAudioSource.isPlaying)
					{
						m_player.MeterFillAudioSource.Play();
					}
					else
					{
						m_player.MeterFillAudioSource.pitch = m_currentUV + 1f;
					}
				}
				m_currentUV -= PickupMovementSpeed * GameTime.Instance.DeltaTime();
				if (m_currentUV < speedPickupAmount)
				{
					m_currentUV = speedPickupAmount;
					if (m_player.MeterFillAudioSource != null && m_player.MeterFillAudioSource.isPlaying)
					{
						m_player.MeterFillAudioSource.Stop();
					}
				}
			}
			else if (m_currentUV < speedPickupAmount)
			{
				if (m_player.MeterFillAudioSource != null)
				{
					if (!m_player.MeterFillAudioSource.isPlaying)
					{
						m_player.MeterFillAudioSource.Play();
					}
					else
					{
						m_player.MeterFillAudioSource.pitch = m_currentUV + 1f;
					}
				}
				m_currentUV += PickupMovementSpeed * GameTime.Instance.DeltaTime();
				if (m_currentUV > speedPickupAmount)
				{
					m_currentUV = speedPickupAmount;
					if (m_player.MeterFillAudioSource != null && m_player.MeterFillAudioSource.isPlaying)
					{
						m_player.MeterFillAudioSource.Stop();
					}
				}
			}
		}
		SetLightBarUV(m_currentUV);
		WeaponLight.SetActive(m_player.WeaponEnabled());
		WeaponIconDetail.SetActive(m_player.WeaponEnabled());
		if (m_player.WeaponEnabled())
		{
			bool flag = false;
			if (m_player.WeaponTypeTimer > 0f)
			{
				m_scrollingWeapon = true;
				flag = true;
			}
			if (m_scrollingWeapon || !Mathf.Approximately(m_weaponUVOffset, WeaponUV[(int)m_player.WeaponTypeToRender]))
			{
				float num = WeaponUV[(int)m_player.WeaponTypeToRender];
				if (m_weaponUVOffset > num)
				{
					flag = true;
				}
				else if (Mathf.Abs(m_weaponUVOffset - num) < 0.4f)
				{
					m_weaponUVOffset = Mathf.Lerp(m_weaponUVOffset, num, 2f * GameTime.Instance.DeltaTime());
					if (Mathf.Abs(m_weaponUVOffset - num) < 0.02f)
					{
						m_weaponUVOffset = num;
						m_scrollingWeapon = false;
					}
				}
				else
				{
					flag = true;
				}
			}
			if (flag || m_player.WeaponTypeTimer > 0f || m_scrollingWeapon)
			{
				m_weaponUVOffset = (m_weaponUVOffset + GameTime.Instance.DeltaTime() * (Mathf.Max(m_player.WeaponTypeTimer, 0.6f) * 1f)) % 1f;
				if (WeaponAudio.clip != WeaponScrollClip && !WeaponAudio.isPlaying)
				{
					WeaponAudio.clip = WeaponScrollClip;
					WeaponAudio.loop = true;
					WeaponAudio.Play();
				}
			}
			else if (WeaponAudio.clip == WeaponScrollClip)
			{
				WeaponAudio.Stop();
				WeaponAudio.clip = WeaponSelectClip;
				WeaponAudio.loop = false;
				WeaponAudio.Play();
			}
			if (GameSystem.Instance.BombHeadMode && m_player.WeaponType == WeaponManager.WeaponType.Bombhead)
			{
				m_weaponUVOffset = WeaponUV[(int)m_player.WeaponTypeToRender];
			}
			WeaponIconDetail.GetComponent<Renderer>().material.SetTextureOffset("_MainTex", new Vector2(m_weaponUVOffset, 0f));
		}
		if (m_player.IsImmobilized())
		{
			if (!WarningAudio.isPlaying)
			{
				WarningAudio.Play();
			}
			m_warningLightTimer += LightSpeed * GameTime.Instance.DeltaTime();
			WarningLight.SetActive(Mathf.Sin(m_warningLightTimer) > 0f);
			return;
		}
		if (WarningLight.activeSelf)
		{
			WarningLight.SetActive(value: false);
		}
		if (WarningAudio.isPlaying)
		{
			WarningAudio.Stop();
		}
	}

	private void UpdateSpeedo()
	{
		if (Time.frameCount % 5 != 0)
		{
			return;
		}
		if ((ResultsManager.Instance != null && ResultsManager.Instance.ResultsActive()) || m_player.PlayerFinishState != 0 || ((bool)FTUE.Instance && FTUE.Instance.State != 0))
		{
			InfoText.text = string.Empty;
			return;
		}
		if (((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() == FEMManager.FEMOnlineState.InRoom) || ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() == FEMManager.FEMOnlineState.InHoldingRoom))
		{
			if (m_player.GetPlayerType() == Player.PlayerType.Human)
			{
				if (m_str1.Length == 0)
				{
					m_str1 = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Wins", convertToUpperCase: true);
				}
				if (m_str2.Length == 0)
				{
					m_str2 = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Points", convertToUpperCase: true);
				}
				InfoText.text = m_str1 + " " + GameSystem.Instance.NumWins + "\n" + m_str2 + " " + ProfileManager.Instance.CurrentOnlinePoints;
			}
			return;
		}
		if (m_player.GetPlayerType() == Player.PlayerType.Human)
		{
			if (m_str1.Length == 0)
			{
				m_str1 = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Pos", convertToUpperCase: true);
			}
			if (m_str2.Length == 0)
			{
				m_str2 = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Lap", convertToUpperCase: true);
			}
			InfoText.text = m_str1 + "  " + m_str2 + "\n" + GameSystem.Instance.NumWins + "   " + ProfileManager.Instance.CurrentOnlinePoints;
		}
		if (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			int num = 0;
			int totalCars = m_totalCars;
			num = m_player.CurrentRaceOrder;
			int num2 = m_player.GetCurrentLap() + 1;
			if (num2 > LapManager.Instance.GetNumLaps())
			{
				num2 = LapManager.Instance.GetNumLaps();
			}
			if (m_str1.Length == 0)
			{
				m_str1 = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Pos", convertToUpperCase: true);
			}
			if (m_str2.Length == 0)
			{
				m_str2 = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Lap", convertToUpperCase: true);
			}
			InfoText.text = m_str1 + "  " + m_str2 + "\n" + (num + 1) + "/" + totalCars + "   " + num2 + "/" + LapManager.Instance.GetNumLaps();
		}
	}

	private void SetLightBarUV(float uvSetting)
	{
		if ((bool)PickupLightBar)
		{
			PickupLightBar.fillAmount = uvSetting;
		}
	}
}
public class KartExhaust : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private ParticleSystem[] IdleExhaustList;

	[SerializeField]
	private ParticleSystem[] DrivingExhaustList;

	[SerializeField]
	private ParticleSystem[] BadSmokeExhaustList;

	[SerializeField]
	private ParticleSystem[] ToxicSmokeExhaustList;

	private bool m_InIdle = true;

	private bool m_badSmokeEnabled;

	private bool m_toxicSmokeEnabled;

	private float m_exhaustTimeout;

	private const float ExhaustTimeoutAmount = 4f;

	public Player Owner { private get; set; }

	public void StartExhaust()
	{
		if (!NetworkLogin.Instance || !NetworkLogin.Instance.JoinedRoom())
		{
			for (int i = 0; i < BadSmokeExhaustList.Length; i++)
			{
				BadSmokeExhaustList[i].Play();
			}
			for (int j = 0; j < ToxicSmokeExhaustList.Length; j++)
			{
				ToxicSmokeExhaustList[j].Play();
			}
		}
	}

	public void StopExhaust()
	{
		for (int i = 0; i < IdleExhaustList.Length; i++)
		{
			IdleExhaustList[i].Stop();
		}
		for (int j = 0; j < DrivingExhaustList.Length; j++)
		{
			DrivingExhaustList[j].Stop();
		}
		for (int k = 0; k < BadSmokeExhaustList.Length; k++)
		{
			BadSmokeExhaustList[k].Stop();
		}
		for (int l = 0; l < Owner.PlayerBadExhaustRoot.Length; l++)
		{
			Owner.PlayerBadExhaustRoot[l].Stop();
		}
		for (int m = 0; m < Owner.PlayerToxicExhaustRoot.Length; m++)
		{
			Owner.PlayerToxicExhaustRoot[m].Stop();
		}
		for (int n = 0; n < ToxicSmokeExhaustList.Length; n++)
		{
			ToxicSmokeExhaustList[n].Stop();
		}
	}

	public void EnableBadSmoke(bool enable, Gameplay.HitByType hitType)
	{
		if ((bool)NetworkLogin.Instance && (bool)NetworkLogin.Instance && Owner.GetPlayerType() == Player.PlayerType.Human)
		{
			if (!enable)
			{
				NetworkLogin.Instance.GetClient().SetCharacterListEvent(Owner.SeatIndex, NetworkClient.EventMask.NoExhaust);
			}
			else
			{
				switch (hitType)
				{
				case Gameplay.HitByType.NormalWeapon:
					NetworkLogin.Instance.GetClient().SetCharacterListEvent(Owner.SeatIndex, NetworkClient.EventMask.BlackExhaust);
					break;
				case Gameplay.HitByType.Toxic:
					NetworkLogin.Instance.GetClient().SetCharacterListEvent(Owner.SeatIndex, NetworkClient.EventMask.ToxicExhaust);
					break;
				}
			}
		}
		if (!enable || hitType == Gameplay.HitByType.NormalWeapon)
		{
			if (m_badSmokeEnabled != enable)
			{
				m_badSmokeEnabled = enable;
			}
			if (m_toxicSmokeEnabled)
			{
				m_toxicSmokeEnabled = false;
			}
			UpdateParticles();
		}
		else if (hitType == Gameplay.HitByType.Toxic)
		{
			if (m_toxicSmokeEnabled != enable)
			{
				m_toxicSmokeEnabled = enable;
			}
			if (m_badSmokeEnabled)
			{
				m_badSmokeEnabled = false;
			}
			UpdateParticles();
		}
		if (enable)
		{
			m_exhaustTimeout = GameTime.Instance.CurrentTime() + 4f;
		}
		else
		{
			m_exhaustTimeout = 0f;
		}
	}

	public void EnableIdleExhaust(bool enable)
	{
		if (!m_badSmokeEnabled && !m_toxicSmokeEnabled && m_InIdle != enable)
		{
			m_InIdle = enable;
			UpdateParticles();
		}
	}

	private void Start()
	{
		m_InIdle = true;
		m_badSmokeEnabled = false;
		UpdateParticles();
	}

	private void Update()
	{
		if (m_exhaustTimeout > 0f && GameTime.Instance.CurrentTime() > m_exhaustTimeout)
		{
			EnableBadSmoke(enable: false, Gameplay.HitByType.None);
		}
	}

	private void UpdateParticles()
	{
		if (!NetworkLogin.Instance || !NetworkLogin.Instance.JoinedRoom())
		{
			for (int i = 0; i < BadSmokeExhaustList.Length; i++)
			{
				ParticleSystem.EmissionModule emission = BadSmokeExhaustList[i].emission;
				emission.enabled = m_badSmokeEnabled;
			}
			for (int j = 0; j < Owner.PlayerBadExhaustRoot.Length; j++)
			{
				ParticleSystem.EmissionModule emission2 = Owner.PlayerBadExhaustRoot[j].emission;
				emission2.enabled = m_badSmokeEnabled;
			}
			for (int k = 0; k < ToxicSmokeExhaustList.Length; k++)
			{
				ParticleSystem.EmissionModule emission3 = ToxicSmokeExhaustList[k].emission;
				emission3.enabled = m_toxicSmokeEnabled;
			}
			for (int l = 0; l < Owner.PlayerToxicExhaustRoot.Length; l++)
			{
				ParticleSystem.EmissionModule emission4 = Owner.PlayerToxicExhaustRoot[l].emission;
				emission4.enabled = m_toxicSmokeEnabled;
			}
		}
	}
}
public class KartGeometry : UnityEngine.MonoBehaviour
{
	public GameObject Helmet;

	public SkinnedMeshRenderer RacerRenderer;

	public MeshRenderer RacerRendererAlt;

	public MeshRenderer KartRenderer;

	public MeshRenderer HelmetRenderer;

	public MeshRenderer AIFar_KartRenderer;

	public MeshRenderer AIFar_LOD0Renderer;

	public Animator RacerAnimator;

	public GameObject ParentRenderingObject;

	public GameObject KartShadow;

	public GameObject BubbleShieldObject;

	public GameObject RadiusBombObject;

	public MeshRenderer KartFrame;

	public MeshRenderer KartDashboard;

	public MeshRenderer FrontFariing;

	public Transform Wheel_Front_Left;

	public Transform Wheel_Front_Right;

	public Transform Wheel_Rear;

	public Transform BeeHiveNear;

	public Transform BeeHiveFar;

	public Transform BeeHiveLOD0;

	[HideInInspector]
	public UnityEngine.Color StartRacerRendererColour;

	[HideInInspector]
	public UnityEngine.Color StartRacerRendererAltColour;

	[HideInInspector]
	public UnityEngine.Color StartKartRendererColour;

	[HideInInspector]
	public UnityEngine.Color StartHelmetRendererColour;

	[HideInInspector]
	public UnityEngine.Color WheelColour;

	[HideInInspector]
	public UnityEngine.Color StartKartFrameColour;

	[HideInInspector]
	public UnityEngine.Color StartDashboardColour;

	[HideInInspector]
	public UnityEngine.Color StartKartFairingColour;

	private bool m_coloursStored;

	private Renderer[] m_radiusBombMaterials;

	public void SetupWheelColour()
	{
		TrackList.TrackData loadedTrack = GameSystem.Instance.GetLoadedTrack();
		if ((bool)Wheel_Front_Left)
		{
			MeshRenderer component = Wheel_Front_Left.GetComponent<MeshRenderer>();
			if ((bool)component)
			{
				if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
				{
					component.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
				}
				else
				{
					component.material.SetColor("_Snow", UnityEngine.Color.black);
				}
			}
		}
		if ((bool)Wheel_Front_Right)
		{
			MeshRenderer component2 = Wheel_Front_Right.GetComponent<MeshRenderer>();
			if ((bool)component2)
			{
				if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
				{
					component2.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
				}
				else
				{
					component2.material.SetColor("_Snow", UnityEngine.Color.black);
				}
			}
		}
		if (!Wheel_Rear)
		{
			return;
		}
		MeshRenderer component3 = Wheel_Rear.GetComponent<MeshRenderer>();
		if ((bool)component3)
		{
			if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
			{
				component3.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
			}
			else
			{
				component3.material.SetColor("_Snow", UnityEngine.Color.black);
			}
		}
	}

	public void StoreMaterialColours()
	{
		if (m_coloursStored)
		{
			return;
		}
		if ((bool)RacerRenderer)
		{
			for (int i = 0; i < RacerRenderer.materials.Length; i++)
			{
				if (RacerRenderer.materials[i].HasProperty("_LightColor"))
				{
					StartRacerRendererColour = RacerRenderer.materials[i].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)RacerRendererAlt)
		{
			for (int j = 0; j < RacerRendererAlt.materials.Length; j++)
			{
				if (RacerRendererAlt.materials[j].HasProperty("_LightColor"))
				{
					StartRacerRendererAltColour = RacerRendererAlt.materials[j].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)KartRenderer)
		{
			for (int k = 0; k < KartRenderer.materials.Length; k++)
			{
				if (KartRenderer.materials[k].HasProperty("_LightColor"))
				{
					StartKartRendererColour = KartRenderer.materials[k].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)HelmetRenderer)
		{
			for (int l = 0; l < HelmetRenderer.materials.Length; l++)
			{
				if (HelmetRenderer.materials[l].HasProperty("_LightColor"))
				{
					StartHelmetRendererColour = HelmetRenderer.materials[l].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)HelmetRenderer)
		{
			for (int m = 0; m < HelmetRenderer.materials.Length; m++)
			{
				if (HelmetRenderer.materials[m].HasProperty("_LightColor"))
				{
					StartHelmetRendererColour = HelmetRenderer.materials[m].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)Wheel_Front_Left)
		{
			MeshRenderer component = Wheel_Front_Left.GetComponent<MeshRenderer>();
			for (int n = 0; n < component.materials.Length; n++)
			{
				if (component.materials[n].HasProperty("_LightColor"))
				{
					WheelColour = component.materials[n].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)KartFrame)
		{
			MeshRenderer component2 = KartFrame.GetComponent<MeshRenderer>();
			for (int num = 0; num < component2.materials.Length; num++)
			{
				if (component2.materials[num].HasProperty("_LightColor"))
				{
					StartKartFrameColour = component2.materials[num].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)FrontFariing)
		{
			MeshRenderer component3 = FrontFariing.GetComponent<MeshRenderer>();
			for (int num2 = 0; num2 < component3.materials.Length; num2++)
			{
				if (component3.materials[num2].HasProperty("_LightColor"))
				{
					StartKartFairingColour = component3.materials[num2].GetColor("_LightColor");
					break;
				}
			}
		}
		if ((bool)KartDashboard)
		{
			MeshRenderer component4 = KartDashboard.GetComponent<MeshRenderer>();
			for (int num3 = 0; num3 < component4.materials.Length; num3++)
			{
				if (component4.materials[num3].HasProperty("_Color"))
				{
					StartDashboardColour = component4.materials[num3].GetColor("_Color");
					break;
				}
			}
		}
		m_coloursStored = true;
	}

	public void SetRadiusBombAlpha(float alpha)
	{
		for (int i = 0; i < m_radiusBombMaterials.Length; i++)
		{
			UnityEngine.Color color = m_radiusBombMaterials[i].material.GetColor("_TintColor");
			color.a = alpha;
			m_radiusBombMaterials[i].material.SetColor("_TintColor", color);
		}
	}

	private void Start()
	{
		m_coloursStored = false;
		if ((bool)RadiusBombObject)
		{
			m_radiusBombMaterials = RadiusBombObject.GetComponentsInChildren<Renderer>();
		}
	}
}
public class KartManager : UnityEngine.MonoBehaviour
{
	public enum KartType
	{
		AIKart,
		FEM,
		MainKart,
		Max
	}

	private GameObject[] KartObjects = new GameObject[3];

	public static KartManager Instance;

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		for (int i = 0; i < KartObjects.Length; i++)
		{
			if ((bool)KartObjects[i])
			{
				KartObjects[i].gameObject.SetActive(value: false);
			}
		}
	}

	private string GetKartPrefabName(KartType type)
	{
		string result = string.Empty;
		switch (type)
		{
		default:
			UnityEngine.Debug.LogError("Unsupported kart type");
			break;
		case KartType.AIKart:
			result = "Karts/AIKart_Small";
			break;
		case KartType.FEM:
			result = "Karts/FEMKart";
			break;
		case KartType.MainKart:
			result = "Karts/PlayerKart";
			break;
		}
		return result;
	}

	public void PreCacheKart(KartType type)
	{
		GameObject gameObject = (GameObject)Resources.Load(GetKartPrefabName(type), typeof(GameObject));
		KartObjects[(int)type] = gameObject;
	}

	public Player CreateKart(KartType type, Player.PlayerType playerType, int playerIndex, string onlineID, int seatIndex, int gridPosition, string playerName, Vector3 position, Quaternion rotation)
	{
		GameObject gameObject = null;
		int num = 0;
		if (playerIndex != -1 && (bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			num = NetworkLogin.Instance.GetServer().GetPlayerConnectionByIndex(seatIndex).OnlinePlayer;
		}
		if (type == KartType.MainKart && (bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game && (bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(0);
			gameObject = PhotonNetwork.Instantiate(data: new object[17]
			{
				num,
				playerName,
				playerData.m_colourIndex[0],
				playerData.m_colourIndex[1],
				playerData.m_colourIndex[2],
				playerData.m_colourIndex[3],
				playerData.m_colourIndex[4],
				playerData.m_colourIndex[5],
				playerData.m_colourIndex[6],
				seatIndex,
				playerData.m_customisationData.m_horn,
				playerData.m_customisationData.m_helmetProp,
				playerData.m_customisationData.m_dashProp,
				playerData.m_customisationData.m_dashStyle,
				playerData.m_customisationData.m_visorProp,
				onlineID,
				gridPosition
			}, prefabName: GetKartPrefabName(type), position: position, rotation: rotation, group: 0);
		}
		else
		{
			GameObject gameObject2;
			if (KartObjects[(int)type] != null)
			{
				gameObject2 = KartObjects[(int)type];
			}
			else
			{
				gameObject2 = (GameObject)Resources.Load(GetKartPrefabName(type), typeof(GameObject));
				KartObjects[(int)type] = gameObject2;
			}
			if ((bool)gameObject2)
			{
				gameObject = UnityEngine.Object.Instantiate(gameObject2);
				if ((bool)gameObject)
				{
					if ((bool)gameObject.GetComponent<PhotonTransformView>())
					{
						UnityEngine.Object.Destroy(gameObject.GetComponent<PhotonTransformView>());
					}
					if ((bool)gameObject.GetComponent<PhotonRigidbodyView>())
					{
						UnityEngine.Object.Destroy(gameObject.GetComponent<PhotonRigidbodyView>());
					}
					if ((bool)gameObject.GetComponent<PhotonView>())
					{
						UnityEngine.Object.Destroy(gameObject.GetComponent<PhotonView>());
					}
				}
			}
		}
		gameObject.transform.position = position;
		gameObject.transform.rotation = rotation;
		Player component = gameObject.GetComponent<Player>();
		PhotonView component2 = gameObject.GetComponent<PhotonView>();
		component.SetPlayerType(playerType);
		component.SeatIndex = seatIndex;
		component.NewGridPosition = gridPosition;
		if (playerIndex != -1 && (bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			component2.ownerId = num;
			component.OnlinePlayerIndex = num;
			component.OnlineID = onlineID;
			component.SeatIndex = GameSystem.Instance.GetPositionChooser().FindSeatPosition(component.OnlinePlayerIndex);
		}
		component.SetupKartGeometry();
		if (component.GetPlayerType() == Player.PlayerType.Human)
		{
			component.GetComponent<KartDashboard>().enabled = true;
			if ((bool)component.WeaponControlObject)
			{
				component.WeaponControlObject.enabled = true;
			}
		}
		gameObject.gameObject.SetActive(value: true);
		return component;
	}
}
public class KartNetwork : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private KartWheel[] wheels;

	private Vector3 m_previousDirection;
}
[RequireComponent(typeof(PhotonView))]
public class KartNetworkSerialize : Photon.MonoBehaviour
{
	private Vector3 m_targetPosition;

	private Quaternion m_targetRotation;

	public void Awake()
	{
		if (base.photonView.isMine)
		{
			base.enabled = false;
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.isWriting)
		{
			Vector3 obj = base.transform.localPosition;
			Quaternion obj2 = base.transform.localRotation;
			stream.Serialize(ref obj);
			stream.Serialize(ref obj2);
		}
		else
		{
			Vector3 obj3 = Vector3.zero;
			Quaternion obj4 = Quaternion.identity;
			stream.Serialize(ref obj3);
			stream.Serialize(ref obj4);
			m_targetPosition = obj3;
			m_targetRotation = obj4;
		}
	}

	public void Update()
	{
		base.transform.localPosition = m_targetPosition;
		base.transform.localRotation = m_targetRotation;
	}
}
public class KartSafetyCushion : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Player Owner;

	private const float VelocityKillScale = 0.5f;

	private const float SafetyTimeout = 2f;

	private const float MaxRotationStepSpeed = 15f;

	private const float RotationSpeed = 0.5f;

	private KartController m_controller;

	private bool m_shouldMakePlayerSafe;

	private float m_currentSafetyTimeout;

	public void ResetCushion()
	{
		m_shouldMakePlayerSafe = false;
	}

	private void Start()
	{
		m_controller = Owner.GetComponent<KartController>();
	}

	private void Update()
	{
		UpdatePlayerSafety();
	}

	private void OnTriggerEnter(Collider col)
	{
		CheckCollision(ref col);
	}

	private void SetPlayerSafety()
	{
		if (!m_shouldMakePlayerSafe)
		{
			m_controller.GetComponent<Rigidbody>().velocity *= 0.5f;
			m_shouldMakePlayerSafe = true;
			m_currentSafetyTimeout = GameTime.Instance.CurrentTime() + 2f;
		}
	}

	private void UpdatePlayerSafety()
	{
		if (!m_shouldMakePlayerSafe)
		{
			return;
		}
		if (GameTime.Instance.CurrentTime() > m_currentSafetyTimeout)
		{
			m_currentSafetyTimeout = 0f;
			m_shouldMakePlayerSafe = false;
			return;
		}
		float a = 0.5f * m_controller.CurrentSpeed;
		a = Mathf.Min(a, 15f);
		Vector3 vector = Vector3.RotateTowards(Owner.transform.forward, Owner.ClosestDirOnTrack, a * GameTime.Instance.DeltaTime(), 0f);
		Owner.transform.rotation = Quaternion.Slerp(Owner.transform.rotation, Quaternion.LookRotation(vector), a * GameTime.Instance.DeltaTime());
		if (Vector3.Angle(Owner.transform.forward, vector) < 5f)
		{
			m_shouldMakePlayerSafe = false;
		}
	}

	private void CheckCollision(ref Collider col)
	{
		if (col.gameObject.layer == LayerMask.NameToLayer("RaceScenery") || col.gameObject.layer == LayerMask.NameToLayer("ShowInWingMirrors"))
		{
			SetPlayerSafety();
		}
	}
}
public class KartSelfRighting : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float waitTime = 3f;

	[SerializeField]
	private float velocityThreshold = 1f;

	private float lastOkTime;

	private void Update()
	{
		if (base.transform.up.y > 0f || GetComponent<Rigidbody>().velocity.magnitude > velocityThreshold)
		{
			lastOkTime = Time.time;
		}
		if (Time.time > lastOkTime + waitTime)
		{
			RightCar();
		}
	}

	private void RightCar()
	{
		base.transform.position += Vector3.up;
		base.transform.rotation = Quaternion.LookRotation(base.transform.forward);
	}
}
[RequireComponent(typeof(KartController))]
public class KartUserControl : UnityEngine.MonoBehaviour
{
	[Serializable]
	public class DriftParams
	{
		public float DriftStartSteeringPercentage = 0.9f;

		public float DriftStartSpeed = 45f;

		public float LateralMovementScale = 0.017f;

		public float AngleScale = 0.015f;

		public float LateralMovementLerp = 2f;

		public float AngleLerp = 2f;

		public float LateralMovementRampdownLerp = 4f;

		public float AngleRampdownLerp = 10f;

		public float SteeringLockTimer = 0.5f;

		public bool SpeedBoostRequired = true;

		public bool EnableDebug;

		public bool EnableDrifting = true;
	}

	private enum DriftState
	{
		None,
		InDrift,
		MovingBackFromDrift,
		DriftingPaused
	}

	[SerializeField]
	private float MaxStationaryTime = 0.5f;

	[SerializeField]
	private float StartBoostAmount = 1400f;

	[SerializeField]
	private float StartBoostTimingWindow = 0.2f;

	private const float CollisionImpactTime = 0.5f;

	public float AdditionalBoostSpeed = 15f;

	public float SpeedBoostBonus = 30f;

	public float TopSpeedForBoostBonus = 40f;

	public float SpeedBoostTorqueMultiplier = 5f;

	[SerializeField]
	private DriftParams DriftData;

	[SerializeField]
	public float HumanPlayerNormalSpeed = 55f;

	[SerializeField]
	public float HumanPlayerTurboSpeed = 75f;

	[SerializeField]
	private float RotationCollisionTime = 0.25f;

	private bool m_enableDrift;

	private KartController m_kartController;

	private Rigidbody m_kartRigidBody;

	private VRKartaudio m_kartAudio;

	private float m_steeringAmount;

	private float m_acceleration;

	private Player m_player;

	private bool m_enableStationaryTimer;

	private float m_stationaryTimer;

	private float m_collisionTimer;

	private float m_audioImpactTimer;

	private bool m_startBoostAllowed;

	private bool m_startBoostInitiated;

	private bool m_startBoostEnabled;

	private float m_startBoostTime;

	private const float HornTimerInterval = 1f;

	private float m_onlineHornTimer;

	private float m_rotationCollisionTimer;

	private Quaternion m_prevRotation;

	private float m_yDiffCheck = 0.25f;

	private float m_liftOffGroundTimer;

	private float m_stickToFloorTimer;

	private Vector3 m_sceneryNormal = Vector3.zero;

	private float m_prevYRotation;

	private int m_numTimes;

	private float PushBackAmount = 0.02f;

	private float MinPushBackAmount = 0.5f;

	private float MaxPushBackAmount = 2f;

	private float m_inAirTimer;

	private PhotonTransformView m_photonView;

	private DriftState m_driftState;

	private bool m_driftAllowed;

	private float m_currentLateralMovement;

	private float m_currentDriftAngle;

	private float m_steeringLockTime;

	public void ResetStartBoost()
	{
		m_startBoostAllowed = false;
		m_startBoostInitiated = false;
		m_startBoostEnabled = false;
		m_startBoostTime = 0f;
		KartController component = GetComponent<KartController>();
		if ((bool)component)
		{
			component.EnableSpeedBoost(enable: false);
		}
		VRCarAIControl component2 = GetComponent<VRCarAIControl>();
		if ((bool)component2)
		{
			component2.ResetSpeedBoost();
		}
	}

	public void EnableStartBoost()
	{
		m_startBoostEnabled = true;
	}

	public float GetAcceleration()
	{
		return m_acceleration;
	}

	public float GetSteeringAngle()
	{
		return m_steeringAmount;
	}

	public void SuddenStop()
	{
		m_kartRigidBody.velocity = Vector3.zero;
		m_acceleration = 0f;
		m_steeringAmount = 0f;
	}

	public void EnableDrift(bool enable)
	{
		m_enableDrift = enable;
	}

	private void Awake()
	{
		m_kartController = GetComponent<KartController>();
		m_player = GetComponent<Player>();
		m_kartAudio = GetComponent<VRKartaudio>();
		m_kartRigidBody = GetComponent<Rigidbody>();
		m_photonView = GetComponent<PhotonTransformView>();
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && (bool)GetComponent<PhotonView>() && !GetComponent<PhotonView>().isMine)
		{
			base.enabled = false;
		}
	}

	private void FixedUpdate()
	{
		MovementUpdate();
	}

	private void CheckForRotationCollision()
	{
		if (m_rotationCollisionTimer > 0f)
		{
			m_rotationCollisionTimer -= GameTime.Instance.DeltaTime();
			m_kartRigidBody.angularVelocity = Vector3.zero;
			m_kartRigidBody.MoveRotation(m_prevRotation);
		}
	}

	private void CheckForLiftingOffGround()
	{
		if (m_liftOffGroundTimer > 0f)
		{
			m_liftOffGroundTimer -= GameTime.Instance.DeltaTime();
			m_kartRigidBody.velocity *= 0.95f;
		}
		if (m_stickToFloorTimer > 0f)
		{
			m_kartRigidBody.isKinematic = true;
			m_kartRigidBody.velocity = Vector3.zero;
			m_kartRigidBody.angularVelocity = Vector3.zero;
			m_kartRigidBody.constraints = RigidbodyConstraints.FreezeAll;
			m_stickToFloorTimer -= GameTime.Instance.DeltaTime();
			if (m_stickToFloorTimer <= 0f)
			{
				m_kartRigidBody.isKinematic = false;
				m_kartRigidBody.constraints = RigidbodyConstraints.None;
			}
		}
	}

	private void UpdateStartBoost()
	{
		if (m_startBoostEnabled && Gameplay.Instance.RaceStarted())
		{
			if (m_player.GetPlayerType() == Player.PlayerType.AI && m_kartRigidBody.velocity.magnitude < 1f)
			{
				return;
			}
			m_startBoostEnabled = false;
			m_kartRigidBody.AddForce(base.transform.forward * StartBoostAmount, ForceMode.Impulse);
			if (m_player.GetPlayerType() == Player.PlayerType.Human)
			{
				m_player.PlayOneShotAudio(Player.PlayerSFXType.StartBoost);
			}
			m_kartController.EnableSpeedBoost(enable: true, visualsOnly: true);
			m_startBoostTime = Time.time + 0.5f;
		}
		if (m_startBoostTime > 0f && Time.time > m_startBoostTime)
		{
			m_startBoostTime = 0f;
			m_kartController.EnableSpeedBoost(enable: false);
		}
	}

	private void UpdateSpinOutDetection()
	{
		float f = base.transform.localEulerAngles.y - m_prevYRotation;
		if (Mathf.Abs(f) > 1.5f)
		{
			m_numTimes++;
		}
		else
		{
			m_numTimes = 0;
		}
		if (m_numTimes > 2)
		{
			m_kartRigidBody.velocity = Vector3.Lerp(m_kartRigidBody.velocity, Vector3.zero, 10f * GameTime.Instance.DeltaTime());
			if (m_kartController.IsBoostEnabled())
			{
				m_kartController.EnableSpeedBoost(enable: false);
			}
		}
		m_prevYRotation = base.transform.localEulerAngles.y;
	}

	private void UpdateKartOnline()
	{
		if ((bool)m_photonView)
		{
			m_photonView.SetSynchronizedValues(m_kartRigidBody.velocity, 10f);
		}
	}

	private void UpdateKartMovement()
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice3)
		{
			m_acceleration = 0f;
			m_steeringAmount = 0f;
			m_kartRigidBody.velocity = Vector3.zero;
			return;
		}
		float num = 0f;
		m_acceleration = 0f;
		m_steeringAmount = 0f;
		Vector3 angularVelocity = m_kartRigidBody.angularVelocity;
		angularVelocity = Vector3.Lerp(angularVelocity, Vector3.zero, 4f * GameTime.Instance.DeltaTime());
		if (m_stationaryTimer <= 0f)
		{
			num = InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Acceleration);
			if (!Mathf.Approximately(num, 0f) && num > 0f)
			{
				m_acceleration = num;
			}
			else if (InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.Acceleration))
			{
				m_acceleration = 1f;
			}
			num = InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Brake);
			num = 0f - num;
			if (!Mathf.Approximately(num, 0f) && num < 0f)
			{
				m_acceleration = num;
			}
			else if (InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.Brake))
			{
				m_acceleration = -1f;
			}
		}
		else
		{
			m_kartRigidBody.velocity = Vector3.zero;
		}
		num = InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Steer_Left);
		num = 0f - num;
		if (!Mathf.Approximately(num, 0f) && num < 0f)
		{
			m_steeringAmount = num;
		}
		else if (InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.Steer_Left))
		{
			m_steeringAmount = -1f;
		}
		num = InputRemapper.Instance.GetAxis(InputRemapper.ControllerMapping.Steer_Right);
		if (!Mathf.Approximately(num, 0f) && num > 0f)
		{
			m_steeringAmount = num;
		}
		else if (InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.Steer_Right))
		{
			m_steeringAmount = 1f;
		}
		UpdateStationaryTimer();
	}

	private void UpdateStationaryTimer()
	{
		if (m_stationaryTimer <= 0f)
		{
			if (!m_enableStationaryTimer)
			{
				if (m_kartController.CurrentSpeed > 5f)
				{
					m_enableStationaryTimer = true;
				}
			}
			else if (m_kartController.PreviousSpeed > 0f && m_kartController.CurrentSpeed <= 0f)
			{
				m_stationaryTimer = MaxStationaryTime;
			}
		}
		else
		{
			m_stationaryTimer -= GameTime.Instance.DeltaTime();
			if (m_stationaryTimer <= 0f)
			{
				m_enableStationaryTimer = false;
			}
		}
	}

	private void UpdateHorn()
	{
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend)
		{
			return;
		}
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Horn))
		{
			Gameplay.Instance.Horn(m_player);
			if (NetworkLogin.Instance != null && m_onlineHornTimer <= 0f)
			{
				NetworkLogin.Instance.GetServer().SetGameplayEvent(m_player.SeatIndex, NetworkClient.GameplayEvent.Horn);
				m_onlineHornTimer = 1f;
			}
		}
		if (m_onlineHornTimer > 0f)
		{
			m_onlineHornTimer -= GameTime.Instance.DeltaTime();
		}
	}

	private void UpdateSpeedBoost()
	{
		if ((bool)ResultsManager.Instance && ResultsManager.Instance.ResultsActive())
		{
			if (m_kartController.IsBoostEnabled())
			{
				m_kartController.EnableSpeedBoost(enable: false);
			}
		}
		else if (m_player.GetSpeedPickupAmount() > 0f)
		{
			if (InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.SpeedBoost))
			{
				if (!m_kartController.IsBoostEnabled())
				{
					m_kartController.EnableSpeedBoost(enable: true);
				}
			}
			else if (m_kartController.IsBoostEnabled())
			{
				m_kartController.EnableSpeedBoost(enable: false);
			}
		}
		else if (m_startBoostTime <= 0f && m_kartController.IsBoostEnabled())
		{
			m_startBoostTime = 0f;
			m_kartController.EnableSpeedBoost(enable: false);
		}
	}

	private void MovementUpdate()
	{
		Player.PlayerType playerType = m_player.GetPlayerType();
		UpdateStartBoost();
		if ((playerType != 0 && playerType != Player.PlayerType.Network && playerType != Player.PlayerType.Network_Debug && playerType != Player.PlayerType.FEM) || Gameplay.Instance == null)
		{
			return;
		}
		if (playerType == Player.PlayerType.Human)
		{
			if (GameSystem.Instance.ApplicationPaused)
			{
				return;
			}
			UpdateSpinOutDetection();
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				UpdateKartOnline();
			}
			UpdateKartMovement();
			UpdateHorn();
			UpdateSpeedBoost();
			if (!m_startBoostInitiated)
			{
				CheckForStartBoost();
			}
		}
		CheckForRotationCollision();
		if (DriftData.EnableDrifting)
		{
			UpdateDrifting();
		}
		if (!m_player || ((m_player.GetPlayerType() == Player.PlayerType.Human || m_player.GetPlayerType() == Player.PlayerType.Network || m_player.GetPlayerType() == Player.PlayerType.Network_Debug || m_player.GetPlayerType() == Player.PlayerType.FEM) && !(Gameplay.Instance == null)))
		{
			if (m_player.GetPlayerType() == Player.PlayerType.Human)
			{
				m_kartController.Move(m_steeringAmount, m_acceleration, m_acceleration, 0f);
			}
			CheckForLiftingOffGround();
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!m_player)
		{
			return;
		}
		bool flag = false;
		ContactPoint[] contacts = collision.contacts;
		for (int i = 0; i < contacts.Length; i++)
		{
			ContactPoint contactPoint = contacts[i];
			if (contactPoint.otherCollider.gameObject.tag == "Curb")
			{
				continue;
			}
			int layer = contactPoint.otherCollider.gameObject.layer;
			float num = Vector3.Angle(contactPoint.normal, Vector3.up);
			switch (layer)
			{
			case 8:
			case 11:
			case 16:
			case 17:
			case 31:
			{
				Transform parent = contactPoint.otherCollider.transform;
				while (parent != null && parent.gameObject.GetComponent<Player>() == null)
				{
					parent = parent.parent;
				}
				if (m_player.GetPlayerType() == Player.PlayerType.AI)
				{
					m_kartController.GetComponent<VRCarAIControl>().CollidedWithKart(parent.gameObject.GetComponent<Player>());
				}
				else if (m_player.GetPlayerType() == Player.PlayerType.Human)
				{
					m_rotationCollisionTimer = RotationCollisionTime;
					m_prevRotation = base.transform.rotation;
				}
				if (m_kartRigidBody.velocity.magnitude > 2f)
				{
					m_player.PlayOneShotAudio(Player.PlayerSFXType.KartImpact);
					if (GetComponent<Player>().GetPlayerType() == Player.PlayerType.Human && Time.time > m_collisionTimer && (bool)ForceFeedback.Instance)
					{
						ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.KartCollision);
						m_collisionTimer = Time.time + 0.5f;
					}
					flag = true;
				}
				break;
			}
			case 14:
			case 25:
				if (num > 15f)
				{
					m_sceneryNormal = contactPoint.normal;
					m_liftOffGroundTimer = 0.1f;
					m_rotationCollisionTimer = RotationCollisionTime;
					m_prevRotation = base.transform.rotation;
					if (m_driftState != 0)
					{
						m_stickToFloorTimer = 0.5f;
						flag = true;
					}
					if (m_kartRigidBody.velocity.magnitude > 2f && Time.time > m_audioImpactTimer)
					{
						m_player.PlayOneShotAudio(Player.PlayerSFXType.SceneryImpact);
						m_audioImpactTimer = Time.time + 0.5f;
					}
					if (GetComponent<Player>().GetPlayerType() == Player.PlayerType.Human && Time.time > m_collisionTimer)
					{
						m_collisionTimer = Time.time + 0.5f;
						flag = true;
					}
				}
				break;
			}
		}
		if (flag && m_kartController.IsBoostEnabled())
		{
			m_kartController.EnableSpeedBoost(enable: false);
		}
		Vector3 velocity = m_kartRigidBody.velocity;
		if (velocity.y > 0f)
		{
			velocity.y = 0f;
			m_kartRigidBody.velocity = velocity;
		}
	}

	private void OnCollisionStay(Collision col)
	{
		Vector3 velocity = m_kartRigidBody.velocity;
		if (velocity.y > 0f)
		{
			velocity.y = Mathf.Lerp(velocity.y, 0f, 6f * GameTime.Instance.DeltaTime());
			m_kartRigidBody.velocity = velocity;
		}
	}

	private void OnTriggerEnter(Collider col)
	{
		if (!(col.gameObject.tag == "Curb") || GetComponent<Player>().GetPlayerType() != 0 || !(Time.time > m_collisionTimer))
		{
			return;
		}
		if ((bool)ForceFeedback.Instance)
		{
			ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.Curb);
			if (m_kartRigidBody.velocity.magnitude > 2f)
			{
				m_player.PlayOneShotAudio(Player.PlayerSFXType.CurbImpact);
			}
		}
		m_collisionTimer = Time.time + 0.5f;
	}

	private void UpdateDrifting()
	{
		float num = Mathf.Abs(m_steeringAmount);
		if (m_kartController.CurrentSpeed > DriftData.DriftStartSpeed && num > DriftData.DriftStartSteeringPercentage && (!DriftData.SpeedBoostRequired || m_kartController.IsBoostEnabled()))
		{
			if (m_enableDrift && m_driftState == DriftState.None)
			{
				m_driftState = DriftState.InDrift;
			}
			else if (m_driftState == DriftState.MovingBackFromDrift)
			{
				m_driftState = DriftState.DriftingPaused;
				m_steeringLockTime = Time.time + DriftData.SteeringLockTimer;
			}
		}
		else if (m_driftState == DriftState.InDrift)
		{
			m_driftState = DriftState.MovingBackFromDrift;
		}
		if (m_driftState == DriftState.MovingBackFromDrift || m_driftState == DriftState.DriftingPaused)
		{
			m_currentLateralMovement = Mathf.Lerp(m_currentLateralMovement, 0f, DriftData.LateralMovementRampdownLerp * GameTime.Instance.DeltaTime());
			m_currentDriftAngle = Mathf.Lerp(m_currentDriftAngle, 0f, DriftData.AngleRampdownLerp * GameTime.Instance.DeltaTime());
			if (m_driftState == DriftState.MovingBackFromDrift)
			{
				if (Mathf.Abs(m_currentLateralMovement) <= 0.05f)
				{
					m_driftState = DriftState.None;
				}
			}
			else if (m_driftState == DriftState.DriftingPaused && m_driftAllowed && Time.time > m_steeringLockTime)
			{
				m_driftState = DriftState.None;
			}
		}
		if (m_driftState != 0)
		{
			float num2 = DriftData.AngleScale;
			float num3 = DriftData.LateralMovementScale;
			if (m_kartController.CurrentSteerAngle < 0f)
			{
				num2 = 0f - num2;
			}
			else
			{
				num3 = 0f - num3;
			}
			num2 *= m_kartController.CurrentSpeed;
			num3 *= m_kartController.CurrentSpeed;
			if (m_driftState != DriftState.MovingBackFromDrift)
			{
				m_currentLateralMovement = Mathf.Lerp(m_currentLateralMovement, num3, DriftData.LateralMovementLerp * GameTime.Instance.DeltaTime());
				m_currentDriftAngle = Mathf.Lerp(m_currentDriftAngle, num2, DriftData.AngleLerp * GameTime.Instance.DeltaTime());
			}
			m_kartController.transform.rotation *= Quaternion.AngleAxis(m_currentDriftAngle, Vector3.up);
			m_kartRigidBody.MovePosition(m_kartController.transform.position + m_kartController.transform.right * m_currentLateralMovement);
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				NetworkLogin.Instance.GetClient().SetCharacterListEvent(GetComponent<Player>().SeatIndex, NetworkClient.EventMask.Drifting);
			}
		}
		else if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(GetComponent<Player>().SeatIndex, NetworkClient.EventMask.Drifting);
		}
		m_kartAudio.EnableSkidSound = m_driftState != DriftState.None;
		m_driftAllowed = num < DriftData.DriftStartSteeringPercentage;
	}

	private void CheckForStartBoost()
	{
		float num = 0f;
		num = ((!(Gameplay.Instance.RaceStartTime > 0f)) ? Gameplay.Instance.PreRaceStartTimer() : (GameTime.Instance.CurrentTime() - Gameplay.Instance.RaceStartTime));
		if (num > StartBoostTimingWindow)
		{
			if (Gameplay.Instance.RaceStarted())
			{
				m_startBoostInitiated = true;
			}
			else if (m_acceleration < 0.98f)
			{
				m_startBoostAllowed = true;
			}
			else
			{
				m_startBoostAllowed = false;
			}
		}
		else if (m_startBoostAllowed && m_acceleration > 0.98f)
		{
			m_startBoostInitiated = true;
			EnableStartBoost();
		}
	}
}
[RequireComponent(typeof(WheelCollider))]
public class KartWheel : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private int WheelIndex;

	public Transform wheelModel;

	public float loQualDist = 100f;

	public bool steerable;

	public bool powered;

	[SerializeField]
	private ParticleSystem PortalFireTrail;

	[SerializeField]
	private GameObject GrassParticleRoot;

	[SerializeField]
	private GameObject SandParticleRoot;

	[SerializeField]
	private GameObject MudParticleRoot;

	[SerializeField]
	private GameObject SnowParticleRoot;

	private ParticleSystem[] m_offroadSystemsGrass;

	private ParticleSystem[] m_offroadSystemsSand;

	private ParticleSystem[] m_offroadSystemsMud;

	private ParticleSystem[] m_offroadSystemsSnow;

	private float[] m_originalEmissionRateGrass;

	private float[] m_originalEmissionRateSand;

	private float[] m_originalEmissionRateMud;

	private float[] m_originalEmissionRateSnow;

	private float m_originalEmissionRatePortal;

	private PlayerManager.GroundParticleType m_groundParticleType;

	private PlayerManager.GroundParticleType m_defaultParticleType;

	private float spinAngle;

	private float particleEmit;

	private float sidewaysStiffness;

	private float forwardStiffness;

	private float springCompression;

	private WheelFrictionCurve sidewaysFriction;

	private WheelFrictionCurve forwardFriction;

	private RaycastHit hit;

	private WheelHit wheelHit;

	private float springCompressionGripModifier;

	private float skidFactorTarget;

	private bool ignore;

	private Vector3 m_originalWheelModelPosition;

	private Vector3 m_hitNormal = Vector3.up;

	private Player m_player;

	private VRKartaudio m_playerAudio;

	private Transform m_currentSkidTrail;

	private float m_currentWheelRotation;

	private float m_targetWheelRotation;

	private const float SpinScale = 6f;

	private const float TyreHeightOffset = 0.26f;

	private float m_currentSuspensionPosition;

	private static float MaxSpringHeight = 0.06f;

	private int m_wheelCheckOnFrame;

	private static int WheelCheckFrame = 10;

	public float Rpm { get; private set; }

	public float MaxRpm { get; private set; }

	public float SkidFactor { get; private set; }

	public Transform Hub { get; set; }

	public WheelCollider wheelCollider { get; private set; }

	public KartController car { get; private set; }

	public float suspensionSpringPos { get; private set; }

	public void OverrideGroundParticle(PlayerManager.GroundParticleType type)
	{
		m_groundParticleType = type;
	}

	public void ResetGroundParticleOverride()
	{
		m_groundParticleType = m_defaultParticleType;
	}

	public bool IsInAir()
	{
		if (wheelCollider != null)
		{
			return !wheelCollider.isGrounded;
		}
		return false;
	}

	public void TurnOffWheelEffects()
	{
		if ((bool)PortalFireTrail)
		{
			PortalFireTrail.gameObject.SetActive(value: false);
		}
	}

	public void StopAllParticles(PlayerManager.GroundParticleType particleType)
	{
		switch (particleType)
		{
		case PlayerManager.GroundParticleType.Grass:
		{
			if (m_offroadSystemsGrass.Length <= 0)
			{
				break;
			}
			for (int l = 0; l < m_offroadSystemsGrass.Length; l++)
			{
				if (m_offroadSystemsGrass[l].isPlaying)
				{
					m_offroadSystemsGrass[l].Stop();
				}
			}
			break;
		}
		case PlayerManager.GroundParticleType.Sand:
		{
			if (m_offroadSystemsSand.Length <= 0)
			{
				break;
			}
			for (int k = 0; k < m_offroadSystemsSand.Length; k++)
			{
				if (m_offroadSystemsSand[k].isPlaying)
				{
					m_offroadSystemsSand[k].Stop();
				}
			}
			break;
		}
		case PlayerManager.GroundParticleType.Mud:
		{
			if (m_offroadSystemsMud.Length <= 0)
			{
				break;
			}
			for (int j = 0; j < m_offroadSystemsMud.Length; j++)
			{
				if (m_offroadSystemsMud[j].isPlaying)
				{
					m_offroadSystemsMud[j].Stop();
				}
			}
			break;
		}
		case PlayerManager.GroundParticleType.Snow:
		{
			if (m_offroadSystemsSnow == null || m_offroadSystemsSnow.Length <= 0)
			{
				break;
			}
			for (int i = 0; i < m_offroadSystemsSnow.Length; i++)
			{
				if (m_offroadSystemsSnow[i].isPlaying)
				{
					m_offroadSystemsSnow[i].Stop();
				}
			}
			break;
		}
		}
	}

	private void Start()
	{
		m_wheelCheckOnFrame = WheelCheckFrame++;
		if (GameSystem.Instance.IsOculusGo())
		{
			GrassParticleRoot.SetActive(value: true);
			SandParticleRoot.SetActive(value: true);
			MudParticleRoot.SetActive(value: true);
			if ((bool)SnowParticleRoot)
			{
				SnowParticleRoot.SetActive(value: true);
			}
		}
		if ((bool)PlayerManager.Instance)
		{
			m_groundParticleType = PlayerManager.Instance.OffroadParticleType;
			m_defaultParticleType = PlayerManager.Instance.OffroadParticleType;
		}
		car = base.transform.parent.GetComponent<KartController>();
		if ((bool)car)
		{
			m_player = car.GetComponent<Player>();
			m_playerAudio = car.GetComponent<VRKartaudio>();
		}
		wheelCollider = GetComponent<Collider>() as WheelCollider;
		if (wheelModel != null)
		{
			m_originalWheelModelPosition = wheelModel.localPosition;
		}
		if ((bool)GrassParticleRoot)
		{
			m_offroadSystemsGrass = GrassParticleRoot.GetComponentsInChildren<ParticleSystem>();
			if (m_offroadSystemsGrass.Length > 0)
			{
				m_originalEmissionRateGrass = new float[m_offroadSystemsGrass.Length];
				for (int i = 0; i < m_originalEmissionRateGrass.Length; i++)
				{
					m_originalEmissionRateGrass[i] = m_offroadSystemsGrass[i].emissionRate;
				}
			}
		}
		if ((bool)SandParticleRoot)
		{
			m_offroadSystemsSand = SandParticleRoot.GetComponentsInChildren<ParticleSystem>();
			if (m_offroadSystemsSand.Length > 0)
			{
				m_originalEmissionRateSand = new float[m_offroadSystemsSand.Length];
				for (int j = 0; j < m_originalEmissionRateSand.Length; j++)
				{
					m_originalEmissionRateSand[j] = m_offroadSystemsSand[j].emissionRate;
				}
			}
		}
		if ((bool)MudParticleRoot)
		{
			m_offroadSystemsMud = MudParticleRoot.GetComponentsInChildren<ParticleSystem>();
			if (m_offroadSystemsMud.Length > 0)
			{
				m_originalEmissionRateMud = new float[m_offroadSystemsMud.Length];
				for (int k = 0; k < m_originalEmissionRateMud.Length; k++)
				{
					m_originalEmissionRateMud[k] = m_offroadSystemsMud[k].emissionRate;
				}
			}
		}
		if ((bool)SnowParticleRoot)
		{
			m_offroadSystemsSnow = SnowParticleRoot.GetComponentsInChildren<ParticleSystem>();
			if (m_offroadSystemsSnow != null && m_offroadSystemsSnow.Length > 0)
			{
				m_originalEmissionRateSnow = new float[m_offroadSystemsSnow.Length];
				for (int l = 0; l < m_originalEmissionRateSnow.Length; l++)
				{
					m_originalEmissionRateSnow[l] = m_offroadSystemsSnow[l].emissionRate;
				}
			}
		}
		if ((bool)PortalFireTrail)
		{
			m_originalEmissionRatePortal = PortalFireTrail.main.simulationSpeed;
		}
		sidewaysFriction = wheelCollider.sidewaysFriction;
		forwardFriction = wheelCollider.forwardFriction;
		sidewaysStiffness = wheelCollider.sidewaysFriction.stiffness;
		forwardStiffness = wheelCollider.forwardFriction.stiffness;
		MaxRpm = ((!car) ? 50f : (car.MaxSpeed / ((float)Math.PI * wheelCollider.radius * 2f) * 60f));
	}

	private void FixedUpdate()
	{
		if ((bool)m_player && (m_player.PlayerFinishState == Player.PlayerFinishedState.InResults || ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() != 0) || ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice3)))
		{
			if (wheelModel != null)
			{
				wheelModel.localRotation = Quaternion.identity;
			}
			return;
		}
		springCompressionGripModifier = springCompression + 0.6f;
		springCompressionGripModifier *= springCompressionGripModifier;
		sidewaysFriction.stiffness = sidewaysStiffness * springCompressionGripModifier;
		forwardFriction.stiffness = forwardStiffness * springCompressionGripModifier;
		wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelCollider.forwardFriction = forwardFriction;
		Rpm = wheelCollider.rpm;
		UpdatePortalTrail();
		float num = car.CurrentSpeed * 6f * 6f * GameTime.Instance.DeltaTime();
		if (car.IsReversing())
		{
			num = 0f - num;
		}
		if ((bool)m_player && m_player.GetPlayerType() == Player.PlayerType.Human)
		{
			num = Mathf.Clamp(num, -12f, 12f);
			num += num * UnityEngine.Random.Range(0.01f, 0.2f);
		}
		spinAngle += num;
		spinAngle %= 360f;
		if (wheelModel != null)
		{
			m_currentSuspensionPosition = Mathf.Lerp(m_currentSuspensionPosition, suspensionSpringPos, 4f * GameTime.Instance.DeltaTime());
			wheelModel.localPosition = m_originalWheelModelPosition + m_hitNormal * m_currentSuspensionPosition;
			if ((bool)m_player && m_player.GetPlayerType() == Player.PlayerType.Network)
			{
				float angle = ((!steerable) ? 0f : (m_player.NetworkSteeringAngle * 20f));
				wheelModel.localRotation = Quaternion.AngleAxis(angle, Vector3.up) * Quaternion.Euler(spinAngle, 0f, 0f);
			}
			else
			{
				m_targetWheelRotation = wheelCollider.steerAngle;
				if (m_player.GetPlayerType() == Player.PlayerType.Human && car.ScaledMaxSteeringAngle > 0f && !powered)
				{
					m_targetWheelRotation = wheelCollider.steerAngle / car.ScaledMaxSteeringAngle;
					float num2 = Mathf.Min(car.ScaledMaxSteeringAngle * car.WheelSteeringScaleMultiplier, car.MaxSteerAngle);
					m_targetWheelRotation *= num2;
					if (car.LastSteerInput < 0f && m_targetWheelRotation > 0f - car.MinWheelAngle)
					{
						m_targetWheelRotation = 0f - car.MinWheelAngle;
					}
					else if (car.LastSteerInput > 0f && m_targetWheelRotation < car.MinWheelAngle)
					{
						m_targetWheelRotation = car.MinWheelAngle;
					}
				}
				m_currentWheelRotation = Mathf.Lerp(m_currentWheelRotation, m_targetWheelRotation, 4f * GameTime.Instance.DeltaTime());
				wheelModel.localRotation = Quaternion.AngleAxis(m_currentWheelRotation, Vector3.up) * Quaternion.Euler(spinAngle, 0f, 0f);
			}
		}
		springCompression = 1f;
		if (wheelCollider.GetGroundHit(out wheelHit))
		{
			m_hitNormal = wheelHit.normal;
			if (WheelIndex == 0)
			{
				m_player.GroundPosition = wheelHit.point;
			}
			if (wheelHit.collider.gameObject.tag == "GroundType_Offroad")
			{
				m_player.SetOffroad(offroad: true, WheelIndex);
				if (m_groundParticleType == PlayerManager.GroundParticleType.Grass)
				{
					StopAllParticles(PlayerManager.GroundParticleType.Mud);
					StopAllParticles(PlayerManager.GroundParticleType.Sand);
					StopAllParticles(PlayerManager.GroundParticleType.Snow);
					if (m_offroadSystemsGrass.Length > 0)
					{
						for (int i = 0; i < m_offroadSystemsGrass.Length; i++)
						{
							if (!m_offroadSystemsGrass[i].isPlaying)
							{
								m_offroadSystemsGrass[i].Play();
							}
							m_offroadSystemsGrass[i].emissionRate = m_originalEmissionRateGrass[i] * (car.CurrentSpeed / car.MaxSpeed);
							m_offroadSystemsGrass[i].emissionRate = Mathf.Clamp(m_offroadSystemsGrass[i].emissionRate, 0f, m_originalEmissionRateGrass[i]);
						}
					}
				}
				else if (m_groundParticleType == PlayerManager.GroundParticleType.Sand)
				{
					StopAllParticles(PlayerManager.GroundParticleType.Mud);
					StopAllParticles(PlayerManager.GroundParticleType.Grass);
					StopAllParticles(PlayerManager.GroundParticleType.Snow);
					if (m_offroadSystemsSand.Length > 0)
					{
						for (int j = 0; j < m_offroadSystemsSand.Length; j++)
						{
							if (!m_offroadSystemsSand[j].isPlaying)
							{
								m_offroadSystemsSand[j].Play();
							}
							m_offroadSystemsSand[j].emissionRate = m_originalEmissionRateSand[j] * (car.CurrentSpeed / car.MaxSpeed);
							m_offroadSystemsSand[j].emissionRate = Mathf.Clamp(m_offroadSystemsSand[j].emissionRate, 0f, m_originalEmissionRateSand[j]);
						}
					}
				}
				else if (m_groundParticleType == PlayerManager.GroundParticleType.Mud)
				{
					StopAllParticles(PlayerManager.GroundParticleType.Grass);
					StopAllParticles(PlayerManager.GroundParticleType.Sand);
					StopAllParticles(PlayerManager.GroundParticleType.Snow);
					if (m_offroadSystemsMud.Length > 0)
					{
						for (int k = 0; k < m_offroadSystemsMud.Length; k++)
						{
							if (!m_offroadSystemsMud[k].isPlaying)
							{
								m_offroadSystemsMud[k].Play();
							}
							m_offroadSystemsMud[k].emissionRate = m_originalEmissionRateMud[k] * (car.CurrentSpeed / car.MaxSpeed);
							m_offroadSystemsMud[k].emissionRate = Mathf.Clamp(m_offroadSystemsMud[k].emissionRate, 0f, m_originalEmissionRateMud[k]);
						}
					}
				}
				else if (m_groundParticleType == PlayerManager.GroundParticleType.Snow)
				{
					StopAllParticles(PlayerManager.GroundParticleType.Grass);
					StopAllParticles(PlayerManager.GroundParticleType.Sand);
					StopAllParticles(PlayerManager.GroundParticleType.Mud);
					if (m_offroadSystemsSnow != null && m_offroadSystemsSnow.Length > 0)
					{
						for (int l = 0; l < m_offroadSystemsSnow.Length; l++)
						{
							if (!m_offroadSystemsSnow[l].isPlaying)
							{
								m_offroadSystemsSnow[l].Play();
							}
							m_offroadSystemsSnow[l].emissionRate = m_originalEmissionRateSnow[l] * (car.CurrentSpeed / car.MaxSpeed);
							m_offroadSystemsSnow[l].emissionRate = Mathf.Clamp(m_offroadSystemsSnow[l].emissionRate, 0f, m_originalEmissionRateSnow[l]);
						}
					}
				}
				else
				{
					StopAllParticles(PlayerManager.GroundParticleType.Grass);
					StopAllParticles(PlayerManager.GroundParticleType.Sand);
					StopAllParticles(PlayerManager.GroundParticleType.Mud);
					StopAllParticles(PlayerManager.GroundParticleType.Snow);
				}
			}
			else
			{
				m_player.SetOffroad(offroad: false, WheelIndex);
				StopAllParticles(PlayerManager.GroundParticleType.Grass);
				StopAllParticles(PlayerManager.GroundParticleType.Sand);
				StopAllParticles(PlayerManager.GroundParticleType.Mud);
				StopAllParticles(PlayerManager.GroundParticleType.Snow);
			}
		}
		if ((bool)m_player && (m_player.PlayerFinishState == Player.PlayerFinishedState.InResults || ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() != 0) || ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice3)) && wheelModel != null)
		{
			wheelModel.localRotation = Quaternion.identity;
		}
	}

	private void UpdateSkids()
	{
		if ((bool)m_player && !m_player.IsOffroad())
		{
			skidFactorTarget = m_player.GetComponent<Rigidbody>().velocity.magnitude * 0.05f;
			skidFactorTarget = Mathf.Clamp01(-0.1f + skidFactorTarget * 1.1f);
			SkidFactor = Mathf.MoveTowards(SkidFactor, skidFactorTarget, GameTime.Instance.DeltaTime() * 2f);
		}
		if ((bool)m_player && m_playerAudio.CurrentlySkidding() && SkidFactor > 0.5f && !m_player.IsOffroad())
		{
			if (m_currentSkidTrail == null)
			{
				m_currentSkidTrail = PlayerManager.Instance.FindSpareSkid();
				if (m_currentSkidTrail != null)
				{
					m_currentSkidTrail.parent = base.transform;
					m_currentSkidTrail.localPosition = -Vector3.up * (wheelCollider.radius - 0.1f);
					m_currentSkidTrail.gameObject.SetActive(value: true);
				}
			}
		}
		else if ((bool)m_currentSkidTrail)
		{
			PlayerManager.Instance.DetachSkid(m_currentSkidTrail.gameObject);
			m_currentSkidTrail = null;
		}
	}

	private void UpdatePortalTrail()
	{
		if (steerable)
		{
			return;
		}
		if (m_player.m_portalTrailTimer > 0f)
		{
			if (PortalFireTrail != null)
			{
				if (!PortalFireTrail.gameObject.activeSelf)
				{
					PortalFireTrail.gameObject.SetActive(value: true);
				}
				if (!PortalFireTrail.isPlaying)
				{
					PortalFireTrail.Play();
				}
				ParticleSystem.MainModule main = PortalFireTrail.main;
				if (m_player.m_portalTrailTimer > 1f)
				{
					main.simulationSpeed = 0f;
					return;
				}
				main.simulationSpeed = m_originalEmissionRatePortal * (car.CurrentSpeed / car.MaxSpeed);
				main.simulationSpeed = Mathf.Clamp(main.simulationSpeed, 0f, m_originalEmissionRatePortal);
			}
		}
		else if (PortalFireTrail.gameObject.activeSelf)
		{
			if (PortalFireTrail.isPlaying)
			{
				PortalFireTrail.Stop();
			}
			else if (PortalFireTrail.particleCount == 0)
			{
				PortalFireTrail.gameObject.SetActive(value: false);
			}
		}
	}
}
public class SkidTrail : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float persistTime;

	[SerializeField]
	private float fadeDuration;

	private float startAlpha;

	private void OnEnable()
	{
		StartCoroutine(UpdateSkid());
	}

	private void OnDisable()
	{
		StopCoroutine(UpdateSkid());
	}

	private IEnumerator UpdateSkid()
	{
		while (true)
		{
			yield return new WaitForSeconds(1f);
			UnityEngine.Color startCol = GetComponent<Renderer>().material.color;
			yield return new WaitForSeconds(persistTime);
			float t = Time.time;
			while (Time.time < t + fadeDuration)
			{
				float i = Mathf.InverseLerp(t, t + fadeDuration, Time.time);
				GetComponent<Renderer>().material.color = startCol * new UnityEngine.Color(1f, 1f, 1f, 1f - i);
				yield return null;
			}
			PlayerManager.Instance.FreeSkid(base.gameObject);
		}
	}
}
public class ToolTips : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Text TextMesh;

	[SerializeField]
	private MeshRenderer Arrow;

	private const float FadeSpeed = 2f;

	private float m_currentAlpha = 1f;

	private void Update()
	{
		if (!FTUE.Instance || FTUE.Instance.State == FTUE.FTUEState.None || ((bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend))
		{
			if ((bool)TextMesh && (bool)Arrow)
			{
				UnityEngine.Object.Destroy(TextMesh.gameObject);
				TextMesh = null;
				UnityEngine.Object.Destroy(Arrow.gameObject);
				Arrow = null;
			}
		}
		else if ((bool)Gameplay.Instance && Gameplay.Instance.PreRaceStartTimer() < 1f)
		{
			m_currentAlpha -= 2f * GameTime.Instance.DeltaTime();
			if (m_currentAlpha <= 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			TextMesh.color = new UnityEngine.Color(TextMesh.color.r, TextMesh.color.g, TextMesh.color.b, m_currentAlpha);
			UnityEngine.Color effectColor = TextMesh.GetComponent<Outline>().effectColor;
			effectColor.a = m_currentAlpha * 0.25f;
			TextMesh.GetComponent<Outline>().effectColor = effectColor;
			UnityEngine.Color color = Arrow.material.GetColor("_LightColor");
			Arrow.material.SetColor("_LightColor", new UnityEngine.Color(color.r, color.g, color.b, m_currentAlpha));
		}
	}
}
public class VRKartaudio : UnityEngine.MonoBehaviour
{
	private enum BoostState
	{
		None,
		Up,
		Down
	}

	[SerializeField]
	private AudioSource IdleAudio;

	[SerializeField]
	private AudioSource EngineAudio;

	[SerializeField]
	private AudioSource SkidAudio;

	[SerializeField]
	private AudioSource EngineOffroadAudio;

	[SerializeField]
	private AudioSource BoostAudioSource;

	[SerializeField]
	private AudioClip OffroadDirtClip;

	[SerializeField]
	private AudioClip OffroadMudClip;

	[SerializeField]
	private AudioClip OffroadRainClip;

	[SerializeField]
	private AudioClip OffroadRockClip;

	[SerializeField]
	private AudioClip OffroadSandClip;

	[SerializeField]
	private AudioClip OffroadWoodClip;

	private KartController m_kartController;

	private Player m_player;

	private Player m_mainPlayer;

	private KartUserControl m_kartUserControl;

	private bool m_sourcesPaused;

	private float m_enginePitch;

	private float m_targetEngineVolume;

	private float m_targetIdleVolume;

	[SerializeField]
	private float AudioLerpSpeed = 4f;

	[SerializeField]
	private float TopSpeedForEngine = 40f;

	[SerializeField]
	private float SteeringAngleForSkid = 1f;

	[SerializeField]
	private float SteeringAmountForSkid = 0.8f;

	[SerializeField]
	private float MinSpeedForSkid = 40f;

	private BoostState m_boostState;

	private float m_prevEnginePitch;

	private float m_minEnginePitch = 0.5f;

	private float m_maxEnginePitch = 1f;

	private float m_boostPitch = 1.1f;

	private float m_revTimer;

	private bool m_revvingNow;

	private float m_targetRevPitch = 1f;

	private int m_numRevs;

	public bool EnableSkidSound { get; set; }

	public bool CurrentlySkidding()
	{
		return (bool)SkidAudio && SkidAudio.volume > 0.7f;
	}

	private void OnDestroy()
	{
		if (IdleAudio != null && IdleAudio.isPlaying)
		{
			IdleAudio.Stop();
		}
		if (EngineAudio != null && EngineAudio.isPlaying)
		{
			EngineAudio.Stop();
		}
		if (EngineOffroadAudio != null && EngineOffroadAudio.isPlaying)
		{
			EngineOffroadAudio.Stop();
		}
		if (SkidAudio != null && SkidAudio.isPlaying)
		{
			SkidAudio.Stop();
		}
		if (BoostAudioSource != null && BoostAudioSource.isPlaying)
		{
			BoostAudioSource.Stop();
		}
	}

	private void Start()
	{
		m_minEnginePitch = 0.5f + UnityEngine.Random.Range(-0.05f, 0.05f);
		m_maxEnginePitch = 1f + UnityEngine.Random.Range(-0.05f, 0.05f);
		m_boostPitch = 1.1f + UnityEngine.Random.Range(-0.05f, 0.05f);
		m_kartController = GetComponent<KartController>();
		m_player = GetComponent<Player>();
		if (!FEMManager.Instance)
		{
			IdleAudio.time = UnityEngine.Random.Range(0f, IdleAudio.clip.length);
			IdleAudio.volume = 0f;
			IdleAudio.Play();
			base.enabled = false;
			EngineAudio.time = UnityEngine.Random.Range(0f, EngineAudio.clip.length);
			EngineAudio.volume = 0f;
			EngineAudio.Play();
			SkidAudio.time = UnityEngine.Random.Range(0f, SkidAudio.clip.length);
			SkidAudio.volume = 0f;
			SkidAudio.Play();
			m_enginePitch = 0f;
			EnableSkidSound = false;
		}
	}

	public void StartEngineAudio()
	{
		IdleAudio.volume = 1f;
		base.enabled = true;
	}

	public void EnableOffroadAudio(bool enable)
	{
		if (enable && m_player.PlayerFinishState != 0)
		{
			return;
		}
		PlayerManager.GroundParticleType groundParticleType = m_kartController.GetGroundOverride();
		if (groundParticleType == PlayerManager.GroundParticleType.None)
		{
			groundParticleType = PlayerManager.Instance.OffroadParticleType;
		}
		if (enable)
		{
			switch (groundParticleType)
			{
			case PlayerManager.GroundParticleType.Grass:
			case PlayerManager.GroundParticleType.None:
				EngineOffroadAudio.clip = OffroadDirtClip;
				break;
			case PlayerManager.GroundParticleType.Mud:
				EngineOffroadAudio.clip = OffroadMudClip;
				break;
			case PlayerManager.GroundParticleType.Sand:
				EngineOffroadAudio.clip = OffroadSandClip;
				break;
			case PlayerManager.GroundParticleType.Rain:
				EngineOffroadAudio.clip = OffroadRainClip;
				break;
			case PlayerManager.GroundParticleType.Rock:
				EngineOffroadAudio.clip = OffroadRockClip;
				break;
			case PlayerManager.GroundParticleType.Wood:
				EngineOffroadAudio.clip = OffroadWoodClip;
				break;
			}
			if (!EngineOffroadAudio.isPlaying)
			{
				EngineOffroadAudio.Play();
			}
			EngineOffroadAudio.volume = m_kartController.CurrentSpeed / 5f;
		}
		else
		{
			if (EngineOffroadAudio.isPlaying)
			{
				EngineOffroadAudio.Stop();
			}
			EngineOffroadAudio.clip = null;
		}
	}

	private float Hermite(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value * value * (3f - 2f * value));
	}

	private void UpdateRevs()
	{
		if (m_player.GetPlayerType() == Player.PlayerType.Human)
		{
			if (m_kartUserControl.GetAcceleration() > 0f)
			{
				float b = m_kartUserControl.GetAcceleration() * 0.3f + 1f;
				IdleAudio.pitch = Mathf.Lerp(IdleAudio.pitch, b, 4f * GameTime.Instance.DeltaTime());
			}
			else
			{
				IdleAudio.pitch = Mathf.Lerp(IdleAudio.pitch, 1f, 8f * GameTime.Instance.DeltaTime());
			}
		}
		else if (!m_revvingNow)
		{
			if (m_numRevs <= 0 && GameTime.Instance.CurrentTime() > m_revTimer)
			{
				m_revvingNow = true;
				m_targetRevPitch = UnityEngine.Random.Range(1.05f, 1.3f);
				m_numRevs = UnityEngine.Random.Range(1, 3);
			}
			IdleAudio.pitch = Mathf.Lerp(IdleAudio.pitch, 1f, 8f * GameTime.Instance.DeltaTime());
			if (IdleAudio.pitch < 1.02f && m_numRevs > 0)
			{
				m_revvingNow = true;
				m_targetRevPitch = UnityEngine.Random.Range(1.05f, 1.3f);
			}
		}
		else
		{
			IdleAudio.pitch = Mathf.Lerp(IdleAudio.pitch, m_targetRevPitch, 4f * GameTime.Instance.DeltaTime());
			if (IdleAudio.pitch >= m_targetRevPitch - 0.01f)
			{
				m_numRevs--;
				m_revvingNow = false;
				m_revTimer = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(0.5f, 3f);
			}
		}
	}

	private void Update()
	{
		if (m_mainPlayer == null && (bool)PlayerManager.Instance)
		{
			m_mainPlayer = PlayerManager.Instance.GetPlayerList()[0];
		}
		if (m_kartUserControl == null)
		{
			m_kartUserControl = GetComponent<KartUserControl>();
		}
		if ((bool)Gameplay.Instance && !Gameplay.Instance.RaceStarted())
		{
			UpdateRevs();
		}
		else if (IdleAudio.pitch != 1f)
		{
			IdleAudio.pitch = 1f;
		}
		if (m_player != null && m_mainPlayer != null && m_player != m_mainPlayer)
		{
			float sqrMagnitude = (m_player.transform.position - m_mainPlayer.transform.position).sqrMagnitude;
			if (m_sourcesPaused)
			{
				if (sqrMagnitude < 900f)
				{
					m_sourcesPaused = false;
					IdleAudio.Play();
					EngineAudio.Play();
					SkidAudio.Play();
					EngineOffroadAudio.Play();
					BoostAudioSource.Play();
				}
			}
			else if (sqrMagnitude > 900f)
			{
				m_sourcesPaused = true;
				IdleAudio.Stop();
				EngineAudio.Stop();
				SkidAudio.Stop();
				EngineOffroadAudio.Stop();
				BoostAudioSource.Stop();
			}
		}
		if ((bool)ResultsManager.Instance && ResultsManager.Instance.ResultsActive())
		{
			IdleAudio.volume = 0.4f;
			EngineAudio.volume = 0f;
			SkidAudio.volume = 0f;
			if (BoostAudioSource != null && BoostAudioSource.isPlaying)
			{
				BoostAudioSource.Stop();
			}
			return;
		}
		m_targetIdleVolume = Mathf.InverseLerp(1f, 0f, Mathf.Clamp(Mathf.Abs(m_kartController.CurrentSpeed), 0f, 10f) / 10f);
		m_targetEngineVolume = Mathf.Lerp(0f, 1f, Mathf.Clamp(Mathf.Abs(m_kartController.CurrentSpeed), 0f, 10f) / 10f);
		IdleAudio.volume = Hermite(IdleAudio.volume, m_targetIdleVolume, AudioLerpSpeed * GameTime.Instance.DeltaTime());
		IdleAudio.volume = Mathf.Clamp(IdleAudio.volume, 0f, 1f);
		EngineAudio.volume = Hermite(EngineAudio.volume, m_targetEngineVolume, AudioLerpSpeed * GameTime.Instance.DeltaTime());
		EngineAudio.volume = Mathf.Clamp(EngineAudio.volume, 0f, 1f);
		if (m_kartController.IsBoostEnabled())
		{
			m_boostState = BoostState.Up;
			m_prevEnginePitch = m_enginePitch;
			m_enginePitch = Mathf.Lerp(m_enginePitch, m_boostPitch, 6f * GameTime.Instance.DeltaTime());
			EngineAudio.volume = Mathf.Lerp(EngineAudio.volume, 1f, 2f * GameTime.Instance.DeltaTime());
		}
		else if (m_boostState == BoostState.Up)
		{
			m_boostState = BoostState.Down;
		}
		else if (m_boostState == BoostState.Down)
		{
			m_enginePitch = Mathf.Lerp(m_enginePitch, m_prevEnginePitch, 2f * GameTime.Instance.DeltaTime());
			EngineAudio.volume = Mathf.Lerp(EngineAudio.volume, 0.75f, 2f * GameTime.Instance.DeltaTime());
			if (m_enginePitch <= m_prevEnginePitch + 0.1f)
			{
				m_boostState = BoostState.None;
			}
		}
		else if (m_boostState == BoostState.None)
		{
			m_enginePitch = Mathf.Lerp(m_minEnginePitch, m_maxEnginePitch, Mathf.Clamp(m_kartController.CurrentSpeed - 5f, 0f, TopSpeedForEngine) / TopSpeedForEngine);
		}
		EngineAudio.pitch = m_enginePitch;
		if (EnableSkidSound || (Mathf.Abs(Mathf.Abs(GetComponent<KartController>().CurrentSteerAngle)) > SteeringAngleForSkid && Mathf.Abs(GetComponent<KartController>().LastSteerInput) > SteeringAmountForSkid && Mathf.Abs(GetComponent<KartController>().CurrentSpeed) > MinSpeedForSkid))
		{
			SkidAudio.volume = Mathf.Lerp(SkidAudio.volume, 1f, 2f * GameTime.Instance.DeltaTime());
		}
		else
		{
			SkidAudio.volume = Mathf.Lerp(SkidAudio.volume, 0f, 2f * GameTime.Instance.DeltaTime());
		}
		if (!(BoostAudioSource != null))
		{
			return;
		}
		if (m_kartController.IsBoostEnabled())
		{
			if (!BoostAudioSource.isPlaying)
			{
				BoostAudioSource.Play();
			}
		}
		else if (BoostAudioSource.isPlaying)
		{
			BoostAudioSource.Stop();
		}
	}
}
public class Bob : UnityEngine.MonoBehaviour
{
	public float BobSpeed = 3f;

	public float BobScale = 0.2f;

	public Vector3 axisSpeed;

	private float m_bobAngle;

	private Vector3 m_originalPosition;

	private MeshRenderer m_currentMesh;

	public void OverridePosition(Vector3 pos)
	{
		m_originalPosition = pos;
	}

	private void Start()
	{
		m_currentMesh = GetComponent<MeshRenderer>();
	}

	private void OnEnable()
	{
		m_originalPosition = base.transform.localPosition;
	}

	private void OnDisable()
	{
		base.transform.localPosition = m_originalPosition;
	}

	private void Update()
	{
		if ((bool)m_currentMesh && m_currentMesh.enabled)
		{
			UpdateMovement();
		}
	}

	private void UpdateMovement()
	{
		m_bobAngle += GameTime.Instance.DeltaTime() * BobSpeed;
		if (m_bobAngle > (float)Math.PI * 2f)
		{
			m_bobAngle -= (float)Math.PI * 2f;
		}
		float num = Mathf.Sin(m_bobAngle) * BobScale;
		base.transform.localPosition = new Vector3(m_originalPosition.x, m_originalPosition.y + num, m_originalPosition.z);
		base.transform.Rotate(axisSpeed * Time.deltaTime);
	}
}
public class CutoutWeapon : Pickup
{
	private FTUE.FTUEState m_currentFTUEState;

	public override void Start()
	{
		if (GameSystem.Instance.EnableTimeTrialMode)
		{
			base.gameObject.SetActive(value: false);
		}
		else
		{
			base.Start();
		}
	}

	public override void Update()
	{
		if ((bool)FTUE.Instance && m_currentFTUEState != FTUE.Instance.State)
		{
			if (FTUE.Instance.State == FTUE.FTUEState.Practice1 || FTUE.Instance.State == FTUE.FTUEState.Practice2 || FTUE.Instance.State == FTUE.FTUEState.Practice2a)
			{
				if (NormalWeaponMesh.gameObject.activeSelf)
				{
					NormalWeaponMesh.gameObject.SetActive(value: false);
				}
			}
			else if (!NormalWeaponMesh.gameObject.activeSelf)
			{
				NormalWeaponMesh.gameObject.SetActive(value: true);
			}
			m_currentFTUEState = FTUE.Instance.State;
		}
		base.Update();
	}

	protected override bool CollectPickup(Player player)
	{
		if ((bool)FTUE.Instance && (FTUE.Instance.State == FTUE.FTUEState.Practice1 || FTUE.Instance.State == FTUE.FTUEState.Practice2 || FTUE.Instance.State == FTUE.FTUEState.Practice2a))
		{
			return false;
		}
		player.EnableWeapon(enable: true);
		return true;
	}
}
public abstract class Pickup : UnityEngine.MonoBehaviour
{
	private enum ToxicState
	{
		None,
		RemovePickup,
		AddBarrel,
		WaitForFinish,
		RemoveBarrel,
		AddPickup
	}

	[SerializeField]
	private ParticleSystem EffectPrefab;

	[SerializeField]
	private ParticleSystem ToxicBarrelParticles;

	[SerializeField]
	private Vector3 LocalSpawnPosition = Vector3.zero;

	[SerializeField]
	private ToxicBarrel ToxicBarrelPickup;

	[SerializeField]
	private GameObject PickupGeometryRoot;

	[SerializeField]
	private AudioClip NormalPickupAudio;

	[SerializeField]
	private AudioClip ToxicPickupAudio;

	[SerializeField]
	protected GameObject NormalWeaponMesh;

	private Player m_humanPlayer;

	private const float TransitionSpeed = 15f;

	private Spawn m_spawnObject;

	private ToxicBarrel m_toxicBarrelObject;

	private ToxicState m_toxicState;

	private float m_startYPos;

	private bool InToxicState()
	{
		return m_toxicState == ToxicState.AddBarrel || m_toxicState == ToxicState.WaitForFinish || m_toxicState == ToxicState.RemoveBarrel;
	}

	public virtual void Start()
	{
		m_startYPos = PickupGeometryRoot.transform.position.y;
		for (int i = 0; i < base.transform.childCount; i++)
		{
			if ((bool)base.transform.GetChild(i).GetComponent<Spawn>())
			{
				m_spawnObject = base.transform.GetChild(i).GetComponent<Spawn>();
				break;
			}
		}
		if ((bool)ToxicBarrelPickup)
		{
			m_toxicBarrelObject = ToxicBarrelPickup;
			m_toxicBarrelObject.transform.parent = PickupGeometryRoot.transform.parent;
			m_toxicBarrelObject.transform.localPosition = Vector3.zero;
			m_toxicBarrelObject.gameObject.SetActive(value: false);
		}
	}

	public virtual void Update()
	{
		if (m_humanPlayer == null)
		{
			PlayerManager.Instance.GetHumanPlayer(ref m_humanPlayer);
		}
		UpdateToxicState();
	}

	private void UpdateToxicState()
	{
		switch (m_toxicState)
		{
		case ToxicState.None:
			if (Gameplay.Instance.ToxicRefCount > 0 && (bool)m_humanPlayer && m_humanPlayer.ToxicTimer <= 0f)
			{
				m_toxicState = ToxicState.RemovePickup;
			}
			break;
		case ToxicState.RemovePickup:
			PickupGeometryRoot.transform.position -= new Vector3(0f, 15f * GameTime.Instance.DeltaTime(), 0f);
			if (m_startYPos - PickupGeometryRoot.transform.position.y > 5f)
			{
				PickupGeometryRoot.gameObject.SetActive(value: false);
				m_toxicBarrelObject.transform.position = PickupGeometryRoot.transform.position;
				m_toxicBarrelObject.gameObject.SetActive(value: true);
				m_toxicState = ToxicState.AddBarrel;
			}
			break;
		case ToxicState.AddBarrel:
			m_toxicBarrelObject.transform.position += new Vector3(0f, 15f * GameTime.Instance.DeltaTime(), 0f);
			if (m_toxicBarrelObject.transform.position.y > m_startYPos)
			{
				Vector3 position2 = m_toxicBarrelObject.transform.position;
				position2.y = m_startYPos;
				m_toxicBarrelObject.transform.position = position2;
				m_toxicState = ToxicState.WaitForFinish;
			}
			break;
		case ToxicState.WaitForFinish:
			if (Gameplay.Instance.ToxicRefCount == 0)
			{
				m_toxicState = ToxicState.RemoveBarrel;
			}
			break;
		case ToxicState.RemoveBarrel:
			m_toxicBarrelObject.transform.position -= new Vector3(0f, 15f * GameTime.Instance.DeltaTime(), 0f);
			if (m_startYPos - m_toxicBarrelObject.transform.position.y > 5f)
			{
				m_toxicBarrelObject.gameObject.SetActive(value: false);
				PickupGeometryRoot.transform.position = m_toxicBarrelObject.transform.position;
				PickupGeometryRoot.SetActive(value: true);
				m_toxicState = ToxicState.AddPickup;
			}
			break;
		case ToxicState.AddPickup:
			PickupGeometryRoot.transform.position += new Vector3(0f, 15f * GameTime.Instance.DeltaTime(), 0f);
			if (PickupGeometryRoot.transform.position.y > m_startYPos)
			{
				Vector3 position = PickupGeometryRoot.transform.position;
				position.y = m_startYPos;
				PickupGeometryRoot.transform.position = position;
				m_toxicState = ToxicState.None;
			}
			break;
		}
	}

	protected abstract bool CollectPickup(Player player);

	private void OnTriggerEnter(Collider other)
	{
		if (!m_spawnObject.IsEnabled())
		{
			return;
		}
		bool flag = false;
		Player player = null;
		Transform parent = other.gameObject.transform;
		do
		{
			player = parent.gameObject.GetComponent<Player>();
			if (player != null)
			{
				if (Gameplay.Instance.ToxicRefCount == 0 || player.ToxicTimer > 0f)
				{
					flag = CollectPickup(player);
				}
				else if (player.HitByWeapon(Gameplay.HitByType.Toxic))
				{
					flag = true;
				}
				break;
			}
			parent = parent.parent;
		}
		while (parent != null);
		if (!flag)
		{
			return;
		}
		m_spawnObject.RemoveFromGame();
		if (!(player != null) || !player.GetKartGeometry().ParentRenderingObject.activeSelf)
		{
			return;
		}
		if (Gameplay.Instance.ToxicRefCount == 0 || player.ToxicTimer > 0f)
		{
			if ((bool)EffectPrefab)
			{
				ParticleSystem particleSystem = UnityEngine.Object.Instantiate(EffectPrefab);
				particleSystem.transform.parent = base.transform;
				particleSystem.transform.localPosition = LocalSpawnPosition;
				particleSystem.transform.localRotation = Quaternion.identity;
				particleSystem.Play();
				UnityEngine.Object.DestroyObject(particleSystem, particleSystem.duration + 2f);
			}
			player.PickupAudioSource.clip = NormalPickupAudio;
			player.PickupAudioSource.Play();
			return;
		}
		m_toxicBarrelObject.gameObject.SetActive(value: false);
		if ((bool)ToxicBarrelParticles)
		{
			ParticleSystem particleSystem2 = UnityEngine.Object.Instantiate(ToxicBarrelParticles);
			particleSystem2.transform.parent = base.transform;
			particleSystem2.transform.localPosition = LocalSpawnPosition;
			particleSystem2.transform.localRotation = Quaternion.identity;
			particleSystem2.Play();
			UnityEngine.Object.DestroyObject(particleSystem2, particleSystem2.duration + 2f);
		}
		player.PickupAudioSource.clip = ToxicPickupAudio;
		player.PickupAudioSource.Play();
	}
}
public class PingPong : UnityEngine.MonoBehaviour
{
	public float rotationAmount;

	public float rotationSpeed;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.localEulerAngles = new Vector3(0f, 0f - Mathf.PingPong(Time.time * rotationSpeed, rotationAmount), 0f);
	}
}
public class RotateAndBob : UnityEngine.MonoBehaviour
{
	private const float RotationSpeed = 40f;

	private const float BobSpeed = 3f;

	private const float BobScale = 0.2f;

	private float m_bobAngle;

	private Vector3 m_originalPosition;

	public void OverridePosition(Vector3 pos)
	{
		m_originalPosition = pos;
	}

	private void OnEnable()
	{
		m_originalPosition = base.transform.localPosition;
	}

	private void Update()
	{
		UpdateMovement();
	}

	private void UpdateMovement()
	{
		m_bobAngle += GameTime.Instance.DeltaTime() * 3f;
		if (m_bobAngle > (float)Math.PI * 2f)
		{
			m_bobAngle -= (float)Math.PI * 2f;
		}
		float num = Mathf.Sin(m_bobAngle) * 0.2f;
		base.transform.localPosition = new Vector3(m_originalPosition.x, m_originalPosition.y + num, m_originalPosition.z);
		base.transform.Rotate(new Vector3(0f, 40f, 0f) * GameTime.Instance.DeltaTime());
	}
}
public class ScrollingUVs : UnityEngine.MonoBehaviour
{
	public int materialIndex;

	public Vector2 uvAnimationRate = new Vector2(1f, 0f);

	public string textureName = "_MainTex";

	private Vector2 uvOffset = Vector2.zero;

	private void LateUpdate()
	{
		uvOffset += uvAnimationRate * Time.deltaTime;
		if (GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().materials[materialIndex].SetTextureOffset(textureName, uvOffset);
		}
	}
}
public class SpeedPickup : Pickup
{
	public static float SpeedIncrease = 2f;

	private FTUE.FTUEState m_currentFTUEState;

	public override void Start()
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice1)
		{
			base.gameObject.SetActive(value: false);
		}
		base.Start();
	}

	public override void Update()
	{
		if ((bool)FTUE.Instance && m_currentFTUEState != FTUE.Instance.State)
		{
			if (FTUE.Instance.State == FTUE.FTUEState.Practice1)
			{
				if (NormalWeaponMesh.gameObject.activeSelf)
				{
					NormalWeaponMesh.gameObject.SetActive(value: false);
				}
			}
			else if (!NormalWeaponMesh.gameObject.activeSelf)
			{
				NormalWeaponMesh.gameObject.SetActive(value: true);
			}
			m_currentFTUEState = FTUE.Instance.State;
		}
		base.Update();
	}

	protected override bool CollectPickup(Player player)
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice1)
		{
			return false;
		}
		if (player.AddBoostAmount())
		{
			player.GetComponent<KartController>().IncreaseSpeedPickupAmount(SpeedIncrease);
			return true;
		}
		return false;
	}
}
public class ToxicBarrel : UnityEngine.MonoBehaviour
{
}
public class AILOD : UnityEngine.MonoBehaviour
{
	[Serializable]
	public enum PropHelmetType
	{
		BearHead,
		BoppersSphere,
		Cap,
		PartyHatStars,
		Headphones,
		PartyHatSpots,
		BunnyEars,
		Sunglasses,
		BoppersStar,
		DevilHorns,
		Plain,
		BoppersHeart
	}

	[Serializable]
	public struct PropHelmetData
	{
		public PropHelmetType HelmetType;

		public GameObject HelmetPrefab;
	}

	public enum LODChangeData
	{
		None,
		CloseUp,
		FarAway,
		LOD0
	}

	[SerializeField]
	private Player MainPlayer;

	[SerializeField]
	private GameObject CloseupKartMesh;

	[SerializeField]
	private GameObject FarAwayKartMesh;

	[SerializeField]
	private GameObject MeshLOD0;

	[SerializeField]
	private float SwitchKartDistance1 = 12f;

	[SerializeField]
	private float SwitchKartDistance2 = 14f;

	[SerializeField]
	private PlayerAnimation PlayerAnim;

	[SerializeField]
	private KartGeometry KartGeom;

	[SerializeField]
	private AccessoryLocator CloseUpAccessoryAttachmentRoot;

	[SerializeField]
	private AccessoryLocator FarAwayAccessoryAttachmentRoot;

	[SerializeField]
	private AccessoryLocator LOD0AccessoryAttachmentRoot;

	[SerializeField]
	private GameObject HelmetDataRootCloseUp;

	[SerializeField]
	private GameObject HelmetDataRootFar;

	[SerializeField]
	private GameObject HelmetDataRootLOD0;

	[SerializeField]
	private PropHelmetData[] HelmetDataCloseUp;

	[SerializeField]
	private PropHelmetData[] HelmetDataFar;

	[SerializeField]
	private PropHelmetData[] HelmetDataLOD0;

	private float m_sqrSwitchKartDistance1;

	private float m_sqrSwitchKartDistance2;

	private bool m_init = true;

	private AccessoryLocator m_currentAccessoryRoot;

	private GameObject m_helmetPropCloseUp;

	private GameObject m_helmetPropFar;

	private GameObject m_helmetPropLOD0;

	private float CloseUpAngle = 25f;

	private LODChangeData m_lodChange;

	public LODChangeData GetCurrentLOD()
	{
		return m_lodChange;
	}

	private void Start()
	{
		m_sqrSwitchKartDistance1 = SwitchKartDistance1 * SwitchKartDistance1;
		m_sqrSwitchKartDistance2 = SwitchKartDistance2 * SwitchKartDistance2;
		m_currentAccessoryRoot = CloseUpAccessoryAttachmentRoot;
	}

	public void SetupHelmetProp(PropHelmetType helmetType, int playerIndex)
	{
		for (int i = 0; i < HelmetDataCloseUp.Length; i++)
		{
			if (HelmetDataCloseUp[i].HelmetType == helmetType)
			{
				m_helmetPropCloseUp = UnityEngine.Object.Instantiate(HelmetDataCloseUp[i].HelmetPrefab);
				m_helmetPropCloseUp.name = "HelmetPropCloseUp";
				m_helmetPropCloseUp.transform.parent = HelmetDataRootCloseUp.transform;
				m_helmetPropCloseUp.transform.localPosition = Vector3.zero;
				m_helmetPropCloseUp.transform.localRotation = Quaternion.identity;
				m_helmetPropCloseUp.transform.localScale = Vector3.one;
				m_helmetPropCloseUp.gameObject.SetActive(value: true);
				MeshRenderer mesh = m_helmetPropCloseUp.GetComponent<MeshRenderer>();
				ProfileManager.Instance.SetupHelmetColours(ref mesh, playerIndex);
				break;
			}
		}
		for (int i = 0; i < HelmetDataFar.Length; i++)
		{
			if (HelmetDataFar[i].HelmetType == helmetType)
			{
				m_helmetPropFar = UnityEngine.Object.Instantiate(HelmetDataFar[i].HelmetPrefab);
				m_helmetPropFar.name = "HelmetPropFar";
				m_helmetPropFar.transform.parent = HelmetDataRootFar.transform;
				m_helmetPropFar.transform.localPosition = Vector3.zero;
				m_helmetPropFar.transform.localRotation = Quaternion.identity;
				m_helmetPropFar.transform.localScale = Vector3.one;
				m_helmetPropFar.gameObject.SetActive(value: true);
				MeshRenderer mesh2 = m_helmetPropFar.GetComponent<MeshRenderer>();
				ProfileManager.Instance.SetupHelmetColours(ref mesh2, playerIndex);
				break;
			}
		}
		for (int i = 0; i < HelmetDataLOD0.Length; i++)
		{
			if (HelmetDataLOD0[i].HelmetType == helmetType)
			{
				m_helmetPropLOD0 = UnityEngine.Object.Instantiate(HelmetDataLOD0[i].HelmetPrefab);
				m_helmetPropLOD0.name = "HelmetPropLOD0";
				m_helmetPropLOD0.transform.parent = HelmetDataRootLOD0.transform;
				m_helmetPropLOD0.transform.localPosition = Vector3.zero;
				m_helmetPropLOD0.transform.localRotation = Quaternion.identity;
				m_helmetPropLOD0.transform.localScale = Vector3.one;
				m_helmetPropLOD0.gameObject.SetActive(value: true);
				MeshRenderer mesh3 = m_helmetPropLOD0.GetComponent<MeshRenderer>();
				ProfileManager.Instance.SetupHelmetColours(ref mesh3, playerIndex);
				break;
			}
		}
	}

	private void Update()
	{
		if (!CameraManager.Instance)
		{
			return;
		}
		GameCamera currentCamera = CameraManager.Instance.GetCurrentCamera();
		if (!currentCamera)
		{
			return;
		}
		Vector3 vector = currentCamera.m_cameraArray[0].transform.position - base.transform.position;
		float sqrMagnitude = vector.sqrMagnitude;
		bool flag = false;
		float num = Vector3.Angle(-vector.normalized, currentCamera.m_cameraArray[0].transform.forward);
		if ((bool)Gameplay.Instance && (m_init || m_lodChange != LODChangeData.CloseUp))
		{
			CloseupKartMesh.SetActive(value: true);
			FarAwayKartMesh.SetActive(value: false);
			MeshLOD0.SetActive(value: false);
			m_lodChange = LODChangeData.CloseUp;
			flag = true;
		}
		if (m_init)
		{
			m_init = false;
		}
		if (!flag || ((bool)PlayerAnim && PlayerAnim.PlayingAnyAnimation()))
		{
			return;
		}
		switch (m_lodChange)
		{
		case LODChangeData.CloseUp:
			if ((bool)KartGeom && (bool)CloseUpAccessoryAttachmentRoot)
			{
				m_currentAccessoryRoot.MoveToNewRoot(ref CloseUpAccessoryAttachmentRoot);
				m_currentAccessoryRoot = CloseUpAccessoryAttachmentRoot;
			}
			break;
		case LODChangeData.FarAway:
			if ((bool)KartGeom && (bool)FarAwayAccessoryAttachmentRoot)
			{
				m_currentAccessoryRoot.MoveToNewRoot(ref FarAwayAccessoryAttachmentRoot);
				m_currentAccessoryRoot = FarAwayAccessoryAttachmentRoot;
			}
			break;
		case LODChangeData.LOD0:
			if ((bool)KartGeom && (bool)LOD0AccessoryAttachmentRoot)
			{
				FarAwayAccessoryAttachmentRoot.MoveToNewRoot(ref LOD0AccessoryAttachmentRoot);
				m_currentAccessoryRoot = LOD0AccessoryAttachmentRoot;
			}
			break;
		}
	}
}
public class AIManager : UnityEngine.MonoBehaviour
{
	[Serializable]
	public class AIData
	{
		[HideInInspector]
		public VRWaypointCircuit WayPointCircuit;

		private float[] m_kartSpeedDefault = new float[6] { 0.8f, 1f, 1.4f, 0.9f, 1.3f, 1.2f };

		[HideInInspector]
		public float AIRecoveryTime = 2f;

		[HideInInspector]
		public float NetworkRecoveryTime = 0.4f;

		[SerializeField]
		public float AIGridStartOffset = 0.2f;

		[NonSerialized]
		public float AIRubberbandSpeedIncrease = 18f;

		public float GetKartSpeedMultiplier(int index)
		{
			return m_kartSpeedDefault[index];
		}
	}

	private struct RubberBandingData
	{
		public float m_time;

		public Player m_player;

		public Player m_playerToCatchUp;
	}

	[SerializeField]
	public AIData AI;

	private List<Player> m_playerList = new List<Player>();

	private bool m_usingRubberBanding;

	private float m_bandingTimer;

	private const float BandingTimer = 5f;

	private RubberBandingData[] m_rubberBandingData;

	private float k_rubberBandDistanceBetweenKarts = 0.5f;

	private Vector2 k_rubberBandingChangeTime = new Vector2(1f, 3f);

	private float m_rubberBandingTimer;

	public bool UsingRubberBanding()
	{
		return m_usingRubberBanding;
	}

	private void Start()
	{
		m_playerList = PlayerManager.Instance.GetPLayerListInOrder();
		m_rubberBandingData = new RubberBandingData[PlayerManager.Instance.MaxPlayers];
	}

	public float GetKartSpeed(int playerIndex)
	{
		UpdateSpeedType();
		return AI.GetKartSpeedMultiplier(playerIndex);
	}

	public float GetPlayerStartSpeed(ref Player player)
	{
		UpdateSpeedType();
		if (!GameSystem.Instance.EnableTimeTrialMode && (!NetworkLogin.Instance || !NetworkLogin.Instance.JoinedRoom()) && (FTUE.Instance == null || FTUE.Instance.State == FTUE.FTUEState.None) && ProfileManager.Instance.Speed == ProfileManager.PlayerSpeed.Turbo)
		{
			return player.GetComponent<KartUserControl>().HumanPlayerTurboSpeed;
		}
		return player.GetComponent<KartUserControl>().HumanPlayerNormalSpeed;
	}

	private void UpdateSpeedType()
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
		{
			LapManager.Instance.NumLaps = 4;
		}
		else if (GameSystem.Instance.GetChampionshipMode().ModeInProgress() || ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom()))
		{
			LapManager.Instance.NumLaps = 3;
		}
		else if (GameSystem.Instance.EnableTimeTrialMode)
		{
			LapManager.Instance.NumLaps = 5;
		}
		else
		{
			LapManager.Instance.NumLaps = ProfileManager.Instance.NumLaps;
		}
	}

	private void Update()
	{
		UpdateRubberBanding();
	}

	private void UpdateRubberBanding()
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
		{
			return;
		}
		if (m_rubberBandingTimer <= 0f)
		{
			for (int num = m_playerList.Count - 1; num > 0; num--)
			{
				m_rubberBandingTimer = k_rubberBandingChangeTime[0] + (k_rubberBandingChangeTime[1] - k_rubberBandingChangeTime[0]) * UnityEngine.Random.Range(0f, 1f);
				if (m_playerList[num].GetPlayerType() != 0 && !(m_rubberBandingData[num].m_player != null) && !m_playerList[num].GetComponent<VRCarAIControl>().IsRubberBanding())
				{
					float num2 = m_playerList[num - 1].PointOnTrack() - m_playerList[num].PointOnTrack();
					if (num2 > k_rubberBandDistanceBetweenKarts)
					{
						m_playerList[num].GetComponent<VRCarAIControl>().SetRubberBanding(enable: true);
						for (int i = 0; i < m_rubberBandingData.Length; i++)
						{
							if (m_rubberBandingData[i].m_player == null)
							{
								m_rubberBandingData[num].m_player = m_playerList[num];
								m_rubberBandingData[num].m_playerToCatchUp = m_playerList[num - 1];
								m_rubberBandingData[num].m_time = UnityEngine.Random.Range(k_rubberBandDistanceBetweenKarts * 0.5f, k_rubberBandDistanceBetweenKarts);
								break;
							}
						}
					}
				}
			}
		}
		else
		{
			m_rubberBandingTimer -= GameTime.Instance.DeltaTime();
		}
		for (int j = 0; j < m_rubberBandingData.Length; j++)
		{
			if (m_rubberBandingData[j].m_player != null && m_rubberBandingData[j].m_player.PointOnTrack() >= m_rubberBandingData[j].m_playerToCatchUp.PointOnTrack() + m_rubberBandingData[j].m_time)
			{
				m_rubberBandingData[j].m_player.GetComponent<VRCarAIControl>().SetRubberBanding(enable: false);
				m_rubberBandingData[j].m_time = 0f;
				m_rubberBandingData[j].m_player = null;
			}
		}
	}
}
[RequireComponent(typeof(KartController))]
public class VRCarAIControl : UnityEngine.MonoBehaviour
{
	public enum BrakeCondition
	{
		NeverBrake,
		TargetDirectionDifference,
		TargetDistance
	}

	[SerializeField]
	[Range(0f, 1f)]
	private float cautiousSpeedFactor = 0.05f;

	[SerializeField]
	[Range(0f, 180f)]
	private float cautiousMaxAngle = 50f;

	[SerializeField]
	private float MaxCautiousLookaheadDistance = 20f;

	[SerializeField]
	private float MinCautiousLookaheadDistance = 4f;

	[SerializeField]
	private float MinimumCautiousSpeed = 10f;

	[HideInInspector]
	private float cautiousMaxDistance = 100f;

	[HideInInspector]
	private float cautiousAngularVelocityFactor;

	[SerializeField]
	private float steerSensitivity = 0.05f;

	[SerializeField]
	private float accelSensitivity = 0.04f;

	[SerializeField]
	private float brakeSensitivity = 1f;

	[SerializeField]
	private float AvoidanceDistance = 10f;

	[SerializeField]
	[Range(0f, 1f)]
	public float accelWanderAmount = 0.1f;

	[SerializeField]
	private float accelWanderSpeed = 0.1f;

	[SerializeField]
	private BrakeCondition brakeCondition = BrakeCondition.TargetDistance;

	[SerializeField]
	private bool driving;

	[SerializeField]
	private bool stopWhenTargetReached;

	[SerializeField]
	private float reachTargetThreshold = 2f;

	private Vector2 RandomWeaponDelay = new Vector2(0.5f, 4f);

	private Transform target;

	private Player m_player;

	private List<Player> m_playerList;

	public Vector3 debugTargetPosition = Vector3.zero;

	private Vector3 AITestPosition = Vector3.zero;

	private Vector3 AITestDirection = Vector3.zero;

	private Player m_avoidingKart;

	private float m_AIStopTimer;

	private bool m_recoveryReverse;

	private Vector3 m_recoveryPosition;

	private int m_pathIndex;

	private bool m_usingSpeedBoost;

	private float m_holdingSpeedBoostTimer;

	private Vector3 m_targetAIOffset = Vector3.zero;

	private float m_shieldUseTime;

	private float m_checkForPathTimer;

	private Vector3 m_lookAheadTestPoint = Vector3.zero;

	private float AvoidanceOffsetAmount = 5f;

	private float AvoidanceCautionDistance = 8f;

	private float AvoidanceDistanceSpeedAddition = 2f;

	private float DetectionDistanceSpeedAddition = 6f;

	private float randomPerlin;

	private KartController carController;

	private Vector3 m_avoidanceDirection;

	private float m_weaponTimer = -1f;

	private float m_originalExtraSpeedMultiplier;

	private float m_originalMaxSpeed;

	private bool m_rubberBandingOn;

	public Vector3 BreadCrumbOffset { get; set; }

	public int GetAIPathIndex()
	{
		return m_pathIndex;
	}

	public void SetSpeedMultiplier(float mult)
	{
		TrackList.TrackData trackData = ((!(GameEntry.Instance == null)) ? GameSystem.Instance.GetLoadedTrack() : GameSystem.Instance.GetTrackListing().GetTrackBySceneName(UnityEngine.Application.loadedLevelName));
		float num = ((ProfileManager.Instance.Speed != ProfileManager.PlayerSpeed.Turbo) ? float.Parse(trackData.NormalAIKartSpeed) : float.Parse(trackData.TurboAIKartSpeed));
		carController.SetDefaultSpeed(num);
		carController.MaxSpeed = num * mult;
		carController.SetDefaultSpeed(carController.MaxSpeed);
		m_originalExtraSpeedMultiplier = carController.MaxSpeed;
		if (GameSystem.Instance.GetChampionshipMode().ModeInProgress())
		{
			float num2 = (float)GameSystem.Instance.GetLoadedTrack().AISpeedIncrease * 0.01f;
			carController.MaxSpeed += m_originalExtraSpeedMultiplier * num2;
		}
		m_originalMaxSpeed = carController.MaxSpeed;
		carController.SetDefaultSpeed(carController.MaxSpeed);
	}

	public bool IsRubberBanding()
	{
		return m_rubberBandingOn;
	}

	public void SetRubberBanding(bool enable)
	{
		m_rubberBandingOn = enable;
		if (enable)
		{
			carController.MaxSpeed = 110f;
			carController.SetDefaultSpeed(carController.MaxSpeed);
		}
		else
		{
			carController.MaxSpeed = m_originalMaxSpeed;
			carController.SetDefaultSpeed(carController.MaxSpeed);
		}
	}

	public Vector3 ChooseDestinationPath(ref Vector3 direction)
	{
		float num = 10000f;
		Vector3 result = Vector3.zero;
		for (int i = 0; i < VRWaypointCircuit.PathOffsets.Length; i++)
		{
			Vector3 direction2 = Vector3.zero;
			Vector3 routePositionByIndex = Gameplay.Instance.GetCircuitPath().GetRoutePositionByIndex(0f, i, ref direction2);
			float sqrMagnitude = (base.transform.position - routePositionByIndex).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				m_pathIndex = i;
				num = sqrMagnitude;
				result = routePositionByIndex;
				direction = direction2;
			}
		}
		return result;
	}

	public void CollidedWithKart(Player otherPlayer)
	{
		Vector3 to = otherPlayer.transform.position - base.transform.position;
		to.Normalize();
		float num = Vector3.Angle(base.transform.forward, to);
		if (num < 90f)
		{
			m_avoidingKart = otherPlayer;
		}
	}

	public void ResetReverse()
	{
		m_AIStopTimer = 0f;
		m_recoveryReverse = false;
	}

	public void ResetSpeedBoost()
	{
		m_usingSpeedBoost = false;
	}

	private void Awake()
	{
		carController = GetComponent<KartController>();
		randomPerlin = UnityEngine.Random.value * 100f;
		m_pathIndex = -1;
		m_weaponTimer = UnityEngine.Random.Range(RandomWeaponDelay.x, RandomWeaponDelay.y);
	}

	private void Start()
	{
		m_playerList = PlayerManager.Instance.GetPlayerList();
		m_player = GetComponent<Player>();
		if ((bool)WeaponManager.Instance)
		{
			m_player.WeaponType = WeaponManager.Instance.ChooseRandomWeapon(m_player);
		}
	}

	private void Update()
	{
		if (PlayerManager.Instance == null || Gameplay.Instance == null)
		{
			return;
		}
		if (!Gameplay.Instance.RaceStarted() || !m_player.GridTimerIsGo())
		{
			CheckForBoost();
		}
		else
		{
			if (m_player.PlayerFinishState == Player.PlayerFinishedState.InResults || (!(NetworkLogin.Instance == null) && m_player.GetPlayerType() != Player.PlayerType.AI && !m_player.InGame))
			{
				return;
			}
			if (m_player.TurnOffKartOnTrackFinish)
			{
				GetComponent<Rigidbody>().velocity = Vector3.zero;
				return;
			}
			if (m_player.GetPlayerType() != 0)
			{
				CheckForReverse();
			}
			if (m_player.GetPlayerType() == Player.PlayerType.AI && (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game))
			{
				CheckForWeapons();
				if (m_checkForPathTimer <= 0f)
				{
					CheckForPathItems();
				}
				else
				{
					m_checkForPathTimer -= GameTime.Instance.DeltaTime();
				}
				CheckForBoost();
			}
			bool flag = true;
			if (m_player.GetPlayerType() == Player.PlayerType.Network && m_player.PlayerFinishState != 0)
			{
				flag = true;
			}
			else if (m_player.GetPlayerType() != Player.PlayerType.AI)
			{
				flag = false;
			}
			if (!flag)
			{
				return;
			}
			if (m_pathIndex == -1)
			{
				Vector3 direction = Vector3.zero;
				ChooseDestinationPath(ref direction);
				if (m_pathIndex == -1)
				{
					m_pathIndex = 1;
				}
				return;
			}
			if ((bool)m_avoidingKart)
			{
				if (m_avoidingKart.GetComponent<VRCarAIControl>().GetAIPathIndex() == GetAIPathIndex())
				{
					ChangePaths();
				}
				Vector3 vector = m_avoidingKart.transform.position - base.transform.position;
				if (m_player.PointOnTrack(singleLapOnly: true) < m_avoidingKart.PointOnTrack(singleLapOnly: true))
				{
					if (m_avoidingKart.PointOnTrack(singleLapOnly: true) - m_player.PointOnTrack(singleLapOnly: true) > 0.2f)
					{
						m_avoidingKart = null;
					}
				}
				else
				{
					m_avoidingKart = null;
				}
				return;
			}
			for (int i = 0; i < m_playerList.Count; i++)
			{
				Player player = m_playerList[i];
				if (!(player != null) || !(player != m_player) || UpdateAvoidance(player, (new Vector2(player.transform.position.x, player.transform.position.z) - new Vector2(base.transform.position.x, base.transform.position.z)).sqrMagnitude))
				{
				}
			}
		}
	}

	private void CheckForReverse()
	{
		if (Gameplay.Instance.RaceStarted() && driving && GetComponent<Rigidbody>().velocity.sqrMagnitude < 0.2f)
		{
			if (!m_recoveryReverse)
			{
				float num = ((m_player.GetPlayerType() != Player.PlayerType.AI) ? PlayerManager.Instance.GetAIManager().AI.NetworkRecoveryTime : PlayerManager.Instance.GetAIManager().AI.AIRecoveryTime);
				if (m_AIStopTimer == 0f)
				{
					m_AIStopTimer = Time.time;
				}
				else if (Time.time > m_AIStopTimer + num)
				{
					m_recoveryReverse = true;
					m_recoveryPosition = base.transform.position;
				}
			}
		}
		else if (m_AIStopTimer > 0f)
		{
			m_AIStopTimer = 0f;
		}
		if (m_recoveryReverse)
		{
			float num2 = ((m_player.GetPlayerType() != Player.PlayerType.AI) ? 50f : 38f);
			float sqrMagnitude = (m_recoveryPosition - base.transform.position).sqrMagnitude;
			if (sqrMagnitude < num2)
			{
				carController.Move(0f, -1f, -1f, 0f);
			}
			else
			{
				m_recoveryReverse = false;
			}
		}
	}

	private void CheckForWeapons()
	{
		if (!m_player.WeaponEnabled() || (m_player.WeaponType == WeaponManager.WeaponType.Nitro && (carController.IsReversing() || m_player.IsImmobilized() || carController.ReverseControlsEnabled())))
		{
			return;
		}
		switch (m_player.WeaponType)
		{
		case WeaponManager.WeaponType.Bombhead:
			break;
		case WeaponManager.WeaponType.Missile:
		case WeaponManager.WeaponType.Reverse:
		{
			int[] array = new int[8];
			int num = 0;
			bool flag = false;
			int num2 = 0;
			for (int m = 0; m < m_playerList.Count; m++)
			{
				Player player3 = m_playerList[m];
				if (!(player3 != null) || !(player3 != m_player) || player3.TurnOffKartOnTrackFinish || !(player3.PointOnTrack() > m_player.PointOnTrack()) || !(player3.PointOnTrack() - m_player.PointOnTrack() > 0.08f) || !(player3.PointOnTrack() - m_player.PointOnTrack() < 1f))
				{
					continue;
				}
				m_weaponTimer -= GameTime.Instance.DeltaTime();
				if (!(m_weaponTimer <= 0f))
				{
					continue;
				}
				Vector3 to = player3.transform.position - base.transform.position;
				to.Normalize();
				float num3 = Vector3.Angle(base.transform.forward, to);
				if (num3 < 80f)
				{
					array[num++] = m;
					if (m == 0)
					{
						flag = true;
					}
				}
			}
			if (num > 0)
			{
				float num4 = ((!PlayerManager.Instance.GetAIManager().UsingRubberBanding()) ? 0.85f : 0.95f);
				num2 = ((!flag || !(UnityEngine.Random.Range(0f, 1f) < num4)) ? array[UnityEngine.Random.Range(0, num)] : 0);
				Gameplay.Instance.FireWeapon(m_player, m_playerList[num2], m_player.WeaponType);
				m_weaponTimer = UnityEngine.Random.Range(RandomWeaponDelay.x, RandomWeaponDelay.y);
				m_player.WeaponType = WeaponManager.Instance.ChooseRandomWeapon(m_player);
			}
			break;
		}
		case WeaponManager.WeaponType.Mine:
		case WeaponManager.WeaponType.Stinger:
		case WeaponManager.WeaponType.Toxic:
			m_weaponTimer -= GameTime.Instance.DeltaTime();
			if (m_weaponTimer <= 0f)
			{
				Gameplay.Instance.FireWeapon(m_player, null, m_player.WeaponType);
				m_weaponTimer = UnityEngine.Random.Range(RandomWeaponDelay.x, RandomWeaponDelay.y);
				m_player.WeaponType = WeaponManager.Instance.ChooseRandomWeapon(m_player);
			}
			break;
		case WeaponManager.WeaponType.RadiusBomb:
			m_weaponTimer -= GameTime.Instance.DeltaTime();
			if (m_weaponTimer <= 0f)
			{
				Gameplay.Instance.FireWeapon(m_player, null, m_player.WeaponType);
				m_weaponTimer = UnityEngine.Random.Range(RandomWeaponDelay.x, RandomWeaponDelay.y);
				m_player.WeaponType = WeaponManager.Instance.ChooseRandomWeapon(m_player);
			}
			break;
		case WeaponManager.WeaponType.Shield:
		{
			if (m_shieldUseTime > 0f)
			{
				if (GameTime.Instance.CurrentTime() > m_shieldUseTime)
				{
					WeaponManager.Instance.FireShield(m_player, null);
					m_shieldUseTime = 0f;
				}
				break;
			}
			List<Mine_Proximity> mineList = Gameplay.Instance.MineList;
			for (int j = 0; j < mineList.Count; j++)
			{
				Vector3 vector = mineList[j].transform.position - base.transform.position;
				float sqrMagnitude = vector.sqrMagnitude;
				if (sqrMagnitude < 18f && Vector3.Angle(base.transform.forward, vector.normalized) < 15f)
				{
					if (UnityEngine.Random.Range(0f, 1f) < 0.6f)
					{
						m_shieldUseTime = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(0.2f, 0.8f);
					}
					break;
				}
			}
			List<StingerWeapon> stingerList = Gameplay.Instance.StingerList;
			for (int k = 0; k < stingerList.Count; k++)
			{
				Vector3 vector2 = stingerList[k].transform.position - base.transform.position;
				float sqrMagnitude2 = vector2.sqrMagnitude;
				if (sqrMagnitude2 < 18f && Vector3.Angle(base.transform.forward, vector2.normalized) < 15f)
				{
					if (UnityEngine.Random.Range(0f, 1f) < 0.6f)
					{
						m_shieldUseTime = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(0.2f, 0.8f);
					}
					break;
				}
			}
			if (m_player.IsBeingTargetted() && UnityEngine.Random.Range(0f, 1f) < 0.6f)
			{
				m_shieldUseTime = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(0.2f, 0.8f);
			}
			break;
		}
		case WeaponManager.WeaponType.Nitro:
		{
			if (carController.IsReversing())
			{
				break;
			}
			for (int l = 0; l < m_playerList.Count; l++)
			{
				Player player2 = m_playerList[l];
				if (player2 != null && player2 != m_player && player2.PointOnTrack() > m_player.PointOnTrack() && player2.PointOnTrack() - m_player.PointOnTrack() > 0.08f && player2.PointOnTrack() - m_player.PointOnTrack() < 0.8f)
				{
					WeaponManager.Instance.FireNitro(m_player, null);
					break;
				}
			}
			break;
		}
		case WeaponManager.WeaponType.Portal:
			m_weaponTimer -= GameTime.Instance.DeltaTime();
			if (m_weaponTimer <= 0f)
			{
				WeaponManager.Instance.FirePortal(m_player, null);
			}
			break;
		case WeaponManager.WeaponType.Bees:
		{
			for (int i = 0; i < m_playerList.Count; i++)
			{
				Player player = m_playerList[i];
				if (player != null && player != m_player && !player.TurnOffKartOnTrackFinish && player.PointOnTrack() > m_player.PointOnTrack() && player.PointOnTrack() - m_player.PointOnTrack() > 0.08f && player.PointOnTrack() - m_player.PointOnTrack() < 0.8f)
				{
					WeaponManager.Instance.FireBeehiveWeapon(m_player, player);
				}
			}
			break;
		}
		}
	}

	private void CheckForPathItems()
	{
		List<Mine_Proximity> mineList = Gameplay.Instance.MineList;
		for (int i = 0; i < mineList.Count; i++)
		{
			Vector3 vector = mineList[i].transform.position - base.transform.position;
			float sqrMagnitude = vector.sqrMagnitude;
			if (sqrMagnitude < 240f && Vector3.Angle(base.transform.forward, vector.normalized) < 6f)
			{
				m_checkForPathTimer = 2f;
				ChangePaths();
				return;
			}
		}
		List<StingerWeapon> stingerList = Gameplay.Instance.StingerList;
		for (int j = 0; j < stingerList.Count; j++)
		{
			Vector3 vector2 = stingerList[j].transform.position - base.transform.position;
			float sqrMagnitude2 = vector2.sqrMagnitude;
			if (sqrMagnitude2 < 240f && Vector3.Angle(base.transform.forward, vector2.normalized) < 6f)
			{
				m_checkForPathTimer = 2f;
				ChangePaths();
				break;
			}
		}
	}

	private void CheckForBoost()
	{
		if (!Gameplay.Instance.ProceedWithGridLights() || !Gameplay.Instance.RaceStarted())
		{
			m_usingSpeedBoost = false;
			GetComponent<KartController>().EnableSpeedBoost(enable: false);
		}
		if (!m_usingSpeedBoost)
		{
			if (carController.IsReversing() || m_player.IsImmobilized() || carController.ReverseControlsEnabled() || m_player.GetSpeedPickupAmount() < 0.1f)
			{
				return;
			}
			if (m_holdingSpeedBoostTimer == 0f)
			{
				m_holdingSpeedBoostTimer = Time.time + UnityEngine.Random.Range(8f, 12f);
			}
			else if (Time.time > m_holdingSpeedBoostTimer)
			{
				m_usingSpeedBoost = true;
			}
			for (int i = 0; i < m_playerList.Count; i++)
			{
				Player player = m_playerList[i];
				if (player != null && player != m_player && player.PointOnTrack() > m_player.PointOnTrack() && player.PointOnTrack() - m_player.PointOnTrack() > 0.08f && player.PointOnTrack() - m_player.PointOnTrack() < 0.8f)
				{
					m_usingSpeedBoost = true;
					break;
				}
			}
		}
		else if (m_player.GetSpeedPickupAmount() < 0.1f)
		{
			m_usingSpeedBoost = false;
			GetComponent<KartController>().EnableSpeedBoost(enable: false);
		}
		else
		{
			GetComponent<KartController>().EnableSpeedBoost(enable: true);
		}
	}

	private void FixedUpdate()
	{
		if (((bool)m_player && m_player.GetPlayerType() == Player.PlayerType.Human) || !Gameplay.Instance)
		{
			return;
		}
		if (m_player.PlayerFinishState == Player.PlayerFinishedState.InResults)
		{
			driving = false;
			return;
		}
		if (target == null || !driving)
		{
			if (m_player.GetPlayerType() == Player.PlayerType.Network || m_player.GetPlayerType() == Player.PlayerType.Network_Debug)
			{
				carController.GetComponent<Rigidbody>().velocity = Vector3.zero;
			}
			float num = Mathf.Clamp(0f - carController.CurrentSpeed, -1f, 1f);
			carController.Move(0f, num, num, 0f);
			return;
		}
		float num2 = carController.MaxSpeed;
		float a = MaxCautiousLookaheadDistance * (carController.CurrentSpeed / 100f);
		a = Mathf.Max(a, MinCautiousLookaheadDistance);
		m_lookAheadTestPoint = GetComponent<VRWaypointProgressTracker>().GetCurrentPositionOnSpline(m_player.PointOnTrack(singleLapOnly: true) + a).direction;
		BrakeCondition brakeCondition = this.brakeCondition;
		if ((brakeCondition == BrakeCondition.TargetDistance || brakeCondition != 0) && !PlayerManager.Instance.GetAIManager().UsingRubberBanding())
		{
			Vector3 vector = target.position - base.transform.position;
			float b = Mathf.InverseLerp(cautiousMaxDistance, 0f, vector.magnitude);
			float value = GetComponent<Rigidbody>().angularVelocity.magnitude * cautiousAngularVelocityFactor;
			float t = Mathf.Max(Mathf.InverseLerp(0f, cautiousMaxAngle, value), b);
			num2 = Mathf.Lerp(carController.MaxSpeed, carController.MaxSpeed * cautiousSpeedFactor, t);
		}
		Vector3 position = target.position;
		Vector3 vector2 = Vector3.zero;
		if (m_player.GetPlayerType() == Player.PlayerType.Network || m_player.GetPlayerType() == Player.PlayerType.Network_Debug)
		{
			position = BreadCrumbOffset;
		}
		else
		{
			vector2 = target.right * Gameplay.Instance.GetCircuitPath().GetDistanceFromCentre(m_pathIndex);
			if ((bool)m_avoidingKart)
			{
				float num3 = AvoidanceCautionDistance + AvoidanceDistanceSpeedAddition * (carController.CurrentSpeed / 40f);
				float magnitude = (base.transform.position - m_avoidingKart.transform.position).magnitude;
				float value2 = num3 / magnitude;
				value2 = Mathf.Clamp(value2, 0f, 1f);
				float num4 = AvoidanceOffsetAmount * value2;
				Vector3 normalized = (m_avoidingKart.transform.position - base.transform.position).normalized;
				Vector3 lhs = Vector3.Cross(normalized, Vector3.up);
				if (Vector3.Dot(lhs, base.transform.forward) < 0f)
				{
					vector2 += target.right * num4;
				}
				else
				{
					vector2 -= target.right * num4;
				}
			}
			if (m_targetAIOffset.sqrMagnitude == 0f)
			{
				m_targetAIOffset = vector2;
			}
			else
			{
				m_targetAIOffset = Vector3.Lerp(m_targetAIOffset, vector2, ((!m_avoidingKart && !(m_checkForPathTimer > 0f)) ? 2f : 5f) * GameTime.Instance.DeltaTime());
			}
			position += m_targetAIOffset;
		}
		if (m_player.GetPlayerType() == Player.PlayerType.AI || (m_player.GetPlayerType() == Player.PlayerType.Network && m_player.PlayerFinishState != 0))
		{
			VRWaypointCircuit.RoutePoint currentPositionOnSpline = GetComponent<VRWaypointProgressTracker>().GetCurrentPositionOnSpline();
			AITestPosition = currentPositionOnSpline.position + vector2;
			AITestDirection = currentPositionOnSpline.direction;
		}
		debugTargetPosition = position;
		float num5 = ((!(num2 < carController.CurrentSpeed)) ? accelSensitivity : brakeSensitivity);
		if (!m_recoveryReverse)
		{
			float num6 = Mathf.Clamp((num2 - carController.CurrentSpeed) * num5, -1f, 1f);
			if (m_player.GetPlayerType() == Player.PlayerType.AI)
			{
				num6 *= 1f - accelWanderAmount + Mathf.PerlinNoise(Time.time * accelWanderSpeed, randomPerlin) * accelWanderAmount;
			}
			Vector3 vector3 = base.transform.InverseTransformPoint(position);
			float num7 = Mathf.Atan2(vector3.x, vector3.z) * 57.29578f;
			float steering = Mathf.Clamp(num7 * steerSensitivity, -1f, 1f) * Mathf.Sign(carController.CurrentSpeed);
			carController.Move(steering, num6, num6, 0f);
			if ((m_player.GetPlayerType() == Player.PlayerType.Network || m_player.GetPlayerType() == Player.PlayerType.Network_Debug) && vector3.magnitude < 1f)
			{
				driving = false;
			}
			if (stopWhenTargetReached && vector3.magnitude < reachTargetThreshold)
			{
				driving = false;
			}
		}
	}

	private bool UpdateAvoidance(Player otherAI, float distance)
	{
		if (distance > AvoidanceDistance * AvoidanceDistance)
		{
			return false;
		}
		Vector3 to = otherAI.transform.position - AITestPosition;
		to.Normalize();
		float num = Vector3.Angle(AITestDirection, to);
		Vector3 to2 = otherAI.transform.position - base.transform.position;
		to.Normalize();
		float num2 = Vector3.Angle(base.transform.forward, to2);
		float num3 = ((!(m_avoidingKart != null)) ? 0f : (new Vector2(m_avoidingKart.transform.position.x, m_avoidingKart.transform.position.z) - new Vector2(base.transform.position.x, base.transform.position.z)).sqrMagnitude);
		float num4 = 12f + DetectionDistanceSpeedAddition * (carController.CurrentSpeed / 40f);
		if (otherAI.GetPlayerType() == Player.PlayerType.Human)
		{
			if (!(distance < num4 * num4))
			{
				return false;
			}
			if ((bool)m_avoidingKart && !(distance < num3))
			{
				return false;
			}
			if (Vector3.Angle(base.transform.forward, to2.normalized) < 15f)
			{
				m_avoidingKart = otherAI;
			}
		}
		else
		{
			if (num > 90f)
			{
				return false;
			}
			if (distance < num4 * num4 && (!m_avoidingKart || distance < num3))
			{
				m_avoidingKart = otherAI;
			}
			if (otherAI.GetComponent<VRCarAIControl>().GetAIPathIndex() != m_pathIndex)
			{
				return false;
			}
		}
		ChangePaths();
		return true;
	}

	private void ChangePaths()
	{
		if (m_pathIndex == 0)
		{
			if (IsNewPathClear(1))
			{
				m_pathIndex = 1;
			}
		}
		else if (m_pathIndex == Gameplay.Instance.GetCircuitPath().GetNumAIPaths() - 1)
		{
			if (IsNewPathClear(m_pathIndex - 1))
			{
				m_pathIndex--;
			}
			if (!IsNewPathClear(m_pathIndex))
			{
				m_pathIndex--;
			}
		}
		else if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			if (IsNewPathClear(m_pathIndex + 1))
			{
				m_pathIndex++;
			}
			else if (IsNewPathClear(m_pathIndex - 1))
			{
				m_pathIndex--;
			}
		}
		else if (IsNewPathClear(m_pathIndex - 1))
		{
			m_pathIndex--;
		}
		else if (IsNewPathClear(m_pathIndex + 1))
		{
			m_pathIndex++;
		}
	}

	private bool IsNewPathClear(int pathIndex)
	{
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player player = m_playerList[i];
			if (player != null && player != m_player && player.GetComponent<VRCarAIControl>().GetAIPathIndex() == pathIndex && (new Vector2(player.transform.position.x, player.transform.position.z) - new Vector2(AITestPosition.x, AITestPosition.z)).sqrMagnitude < 9f)
			{
				return false;
			}
		}
		return true;
	}

	public void SetTarget(Transform target)
	{
		this.target = target;
		driving = true;
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.magenta;
		Gizmos.DrawLine(base.transform.position, debugTargetPosition);
		if ((bool)Gameplay.Instance && (bool)m_player)
		{
			Gizmos.color = UnityEngine.Color.green;
			float a = MaxCautiousLookaheadDistance * (carController.CurrentSpeed / 100f);
			a = Mathf.Max(a, MinCautiousLookaheadDistance);
			Vector3 position = GetComponent<VRWaypointProgressTracker>().GetCurrentPositionOnSpline(m_player.PointOnTrack(singleLapOnly: true) + a).position;
			position.y = 0f;
			Gizmos.DrawSphere(position, 1f);
		}
	}
}
public class VRWaypointCircuit : UnityEngine.MonoBehaviour
{
	[Serializable]
	public class WaypointList
	{
		public VRWaypointCircuit circuit;

		public Transform[] items = new Transform[0];
	}

	public struct RoutePoint
	{
		public Vector3 position;

		public Vector3 direction;

		public RoutePoint(Vector3 position, Vector3 direction)
		{
			this.position = position;
			this.direction = direction;
		}
	}

	public SplitLane[] SplitLanes;

	public WaypointList waypointList = new WaypointList();

	public static float[] PathOffsets = new float[3] { -0.35f, 0f, 0.35f };

	private static float PathDivision = 12f;

	[SerializeField]
	private bool smoothRoute = true;

	private int numPoints;

	private Vector3[] points;

	private float[] distances;

	public float editorVisualisationSubsteps = 100f;

	private int p0n;

	private int p1n;

	private int p2n;

	private int p3n;

	private float i;

	private Vector3 P0;

	private Vector3 P1;

	private Vector3 P2;

	private Vector3 P3;

	public float Length { get; private set; }

	public Transform[] Waypoints => waypointList.items;

	private void Awake()
	{
		if (Waypoints.Length > 1)
		{
			CachePositionsAndDistances();
		}
		numPoints = Waypoints.Length;
	}

	public int FindWayPoint(ref GameObject obj)
	{
		for (int i = 0; i < Waypoints.Length; i++)
		{
			if (Waypoints[i].gameObject == obj)
			{
				return i;
			}
		}
		return -1;
	}

	public Vector3 GetPositionFromWayPoints(Vector3 waypoint1, Vector3 wayPoint2, float distance)
	{
		Vector3 vector = wayPoint2 - waypoint1;
		vector *= distance;
		return waypoint1 + vector;
	}

	public float ConvertWaypointDistanceToDistances(float waypointDistance)
	{
		waypointDistance %= (float)Waypoints.Length;
		if (waypointDistance < 0f)
		{
			waypointDistance = (float)(Waypoints.Length - 1) - waypointDistance;
		}
		int num = (int)waypointDistance % distances.Length;
		int num2 = (num + 1) % distances.Length;
		float num3 = waypointDistance - (float)num;
		float num4 = distances[num2] - distances[num];
		return distances[num] + num4 * num3;
	}

	public Vector3 GetClosestPointOnLineSegment(Vector3 A, Vector3 B, Vector3 P, ref float normalisedDistance)
	{
		Vector3 lhs = P - A;
		Vector3 vector = B - A;
		float sqrMagnitude = vector.sqrMagnitude;
		float num = Vector3.Dot(lhs, vector);
		float num2 = num / sqrMagnitude;
		normalisedDistance = Mathf.Clamp(num2, 0f, 1f);
		if (num2 < 0f)
		{
			return A;
		}
		if (num2 > 1f)
		{
			return B;
		}
		return A + vector * num2;
	}

	public float GetClosestPointOnTrack(Vector3 position, ref int wayPoint1, ref int wayPoint2)
	{
		float normalisedDistance = 0f;
		wayPoint1 = -1;
		wayPoint2 = -1;
		float num = float.PositiveInfinity;
		for (int i = 0; i < waypointList.circuit.Waypoints.Length; i++)
		{
			float sqrMagnitude = (waypointList.circuit.Waypoints[i].position - position).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				wayPoint1 = i;
			}
		}
		Vector3 lhs = position - waypointList.circuit.Waypoints[wayPoint1].position;
		lhs.Normalize();
		Vector3 forward = waypointList.circuit.Waypoints[wayPoint1].forward;
		if (Vector3.Dot(lhs, forward) < 0f)
		{
			wayPoint2 = wayPoint1;
			wayPoint1--;
			if (wayPoint1 < 0)
			{
				wayPoint1 = waypointList.circuit.Waypoints.Length - 1;
			}
		}
		else
		{
			wayPoint2 = wayPoint1 + 1;
			wayPoint2 %= waypointList.circuit.Waypoints.Length - 1;
		}
		GetClosestPointOnLineSegment(waypointList.circuit.Waypoints[wayPoint1].position, waypointList.circuit.Waypoints[wayPoint2].position, position, ref normalisedDistance);
		return normalisedDistance + (float)wayPoint1;
	}

	public bool IsWaypointASplitLane(int wayPoint, ref SplitLane lane)
	{
		for (int i = 0; i < SplitLanes.Length; i++)
		{
			if (waypointList.circuit.Waypoints[wayPoint] == SplitLanes[i].Waypoints[0])
			{
				lane = SplitLanes[i];
				return true;
			}
		}
		return false;
	}

	public RoutePoint GetRoutePoint(float dist)
	{
		Vector3 routePosition = GetRoutePosition(dist);
		Vector3 routePosition2 = GetRoutePosition(dist + 0.1f);
		return new RoutePoint(routePosition, (routePosition2 - routePosition).normalized);
	}

	public Vector3 GetRoutePosition(float dist)
	{
		int i = 0;
		if (Length == 0f)
		{
			Length = distances[distances.Length - 1];
		}
		for (dist = Mathf.Repeat(dist, Length); distances[i] < dist; i++)
		{
		}
		p1n = (i - 1 + numPoints) % numPoints;
		p2n = i;
		this.i = Mathf.InverseLerp(distances[p1n], distances[p2n], dist);
		if (smoothRoute)
		{
			p0n = (i - 2 + numPoints) % numPoints;
			p3n = (i + 1) % numPoints;
			p2n %= numPoints;
			P0 = points[p0n];
			P1 = points[p1n];
			P2 = points[p2n];
			P3 = points[p3n];
			return CatmullRom(P0, P1, P2, P3, this.i);
		}
		p1n = (i - 1 + numPoints) % numPoints;
		p2n = i;
		return Vector3.Lerp(points[p1n], points[p2n], this.i);
	}

	public Vector3 GetRoutePositionByIndex(float distance, int pathIndex, ref Vector3 direction)
	{
		Vector3 routePosition = GetRoutePosition(distance);
		Vector3 routePosition2 = GetRoutePosition(distance + 0.2f);
		direction = routePosition - routePosition2;
		direction.Normalize();
		return routePosition + Vector3.Cross(direction, Vector3.up) * (PathOffsets[pathIndex] * PathDivision);
	}

	public float GetDistanceFromCentre(int pathIndex)
	{
		if (pathIndex == -1 || PathOffsets.Length < pathIndex || PathOffsets == null)
		{
			return 0f;
		}
		return PathOffsets[pathIndex] * PathDivision;
	}

	public int GetNumAIPaths()
	{
		return PathOffsets.Length;
	}

	private Vector3 CatmullRom(Vector3 _P0, Vector3 _P1, Vector3 _P2, Vector3 _P3, float _i)
	{
		return 0.5f * (2f * _P1 + (-_P0 + _P2) * _i + (2f * _P0 - 5f * _P1 + 4f * _P2 - _P3) * _i * _i + (-_P0 + 3f * _P1 - 3f * _P2 + _P3) * _i * _i * _i);
	}

	private void CachePositionsAndDistances()
	{
		points = new Vector3[Waypoints.Length + 1];
		distances = new float[Waypoints.Length + 1];
		float num = 0f;
		for (int i = 0; i < points.Length; i++)
		{
			Transform transform = Waypoints[i % Waypoints.Length];
			Transform transform2 = Waypoints[(i + 1) % Waypoints.Length];
			if (transform != null && transform2 != null)
			{
				Vector3 position = transform.position;
				Vector3 position2 = transform2.position;
				ref Vector3 reference = ref points[i];
				reference = Waypoints[i % Waypoints.Length].position;
				distances[i] = num;
				num += (position - position2).magnitude;
			}
		}
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(selected: false);
		Gizmos.color = UnityEngine.Color.blue;
		Transform[] items = waypointList.items;
		foreach (Transform transform in items)
		{
			Gizmos.DrawWireSphere(transform.position, 2f);
			Gizmos.DrawLine(transform.position + transform.up * 2f, transform.position + transform.up * 2f + transform.forward * 10f);
		}
	}

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(selected: true);
	}

	private void DrawGizmos(bool selected)
	{
		waypointList.circuit = this;
		for (int i = 0; i < PathOffsets.Length; i++)
		{
			float num = PathOffsets[i] * PathDivision;
			if (Waypoints.Length <= 1)
			{
				continue;
			}
			numPoints = Waypoints.Length;
			CachePositionsAndDistances();
			Length = distances[distances.Length - 1];
			Gizmos.color = ((num != 0f) ? new UnityEngine.Color(1f / 17f, 1f, 84f / 85f) : UnityEngine.Color.green);
			Vector3 vector = Waypoints[0].position;
			if (smoothRoute)
			{
				for (float num2 = 0f; num2 < Length; num2 += Length / editorVisualisationSubsteps)
				{
					Vector3 routePosition = GetRoutePosition(num2 + 1f);
					Vector3 lhs = routePosition - vector;
					lhs.Normalize();
					Vector3 vector2 = Vector3.Cross(lhs, Vector3.up);
					vector2 *= num;
					Gizmos.DrawLine(vector + vector2, routePosition + vector2);
					vector = routePosition;
				}
				Gizmos.DrawLine(vector, Waypoints[0].position);
			}
			else
			{
				for (int j = 0; j < Waypoints.Length; j++)
				{
					Vector3 position = Waypoints[(j + 1) % Waypoints.Length].position;
					Vector3 lhs2 = position - vector;
					lhs2.Normalize();
					Vector3 vector3 = Vector3.Cross(lhs2, Vector3.up);
					vector3 *= num;
					Gizmos.DrawLine(vector + vector3, position + vector3);
					vector = position;
				}
			}
		}
	}
}
public class VRWaypointProgressTracker : UnityEngine.MonoBehaviour
{
	private VRWaypointCircuit circuit;

	[SerializeField]
	private float lookAheadForTargetOffset = 5f;

	[SerializeField]
	private float lookAheadForSpeedOffset = 10f;

	[SerializeField]
	private float lookAheadForSpeedFactor = 0.2f;

	public Transform target;

	private float progressDistance;

	private Vector3 lastPosition;

	private float speed;

	private float m_previousProgressDistance;

	private int m_splitLaneIndex = -1;

	private int m_ignoreSplitLaneIndex = -1;

	private Player m_player;

	public VRWaypointCircuit.RoutePoint targetPoint { get; private set; }

	public VRWaypointCircuit.RoutePoint speedPoint { get; private set; }

	public VRWaypointCircuit.RoutePoint progressPoint { get; private set; }

	public void SetCircuit(VRWaypointCircuit path)
	{
		circuit = path;
	}

	private void Start()
	{
		m_player = GetComponent<Player>();
		if ((m_player.GetPlayerType() == Player.PlayerType.Network || m_player.GetPlayerType() == Player.PlayerType.Network_Debug) && target == null)
		{
			target = new GameObject(base.name + " Waypoint Target").transform;
			target.transform.parent = base.gameObject.transform;
			GetComponent<VRCarAIControl>().SetTarget(target);
		}
		if (!(PlayerManager.Instance == null) && !(PlayerManager.Instance.GetAIManager().AI.WayPointCircuit == null))
		{
			Reset();
		}
	}

	public void Reset()
	{
		progressDistance = 0f;
		lastPosition = Vector3.zero;
		m_previousProgressDistance = 0f;
		m_previousProgressDistance = 0f;
		m_splitLaneIndex = -1;
		m_ignoreSplitLaneIndex = -1;
	}

	public VRWaypointCircuit.RoutePoint GetCurrentPositionOnSpline(float offset = 0f)
	{
		if (m_splitLaneIndex != -1)
		{
			return circuit.SplitLanes[m_splitLaneIndex].GetRoutePoint(progressDistance + offset);
		}
		return circuit.GetRoutePoint(progressDistance + offset);
	}

	private void Update()
	{
		if (((bool)m_player && m_player.GetPlayerType() == Player.PlayerType.Human) || !Gameplay.Instance || !Gameplay.Instance.RaceStarted() || !m_player.GridTimerIsGo() || m_player.PlayerFinishState == Player.PlayerFinishedState.InResults)
		{
			return;
		}
		if (GameTime.Instance.DeltaTime() > 0f)
		{
			speed = Mathf.Lerp(speed, (lastPosition - base.transform.position).magnitude / GameTime.Instance.DeltaTime(), GameTime.Instance.DeltaTime());
		}
		Vector3 zero = Vector3.zero;
		if (m_player.GetPlayerType() == Player.PlayerType.AI || (m_player.GetPlayerType() == Player.PlayerType.Network && m_player.PlayerFinishState != 0))
		{
			if (m_splitLaneIndex == -1 && circuit.SplitLanes != null && circuit.SplitLanes.Length > 0)
			{
				int wayPoint = 0;
				int wayPoint2 = 0;
				Gameplay.Instance.GetCircuitPath().GetClosestPointOnTrack(circuit.GetRoutePosition(progressDistance + lookAheadForTargetOffset), ref wayPoint, ref wayPoint2);
				Transform transform = circuit.Waypoints[wayPoint];
				for (int i = 0; i < circuit.SplitLanes.Length; i++)
				{
					if (i == m_ignoreSplitLaneIndex || !(transform == circuit.SplitLanes[i].Waypoints[0]))
					{
						continue;
					}
					float num = UnityEngine.Random.Range(0f, 100f);
					int aIPathIndex = GetComponent<VRCarAIControl>().GetAIPathIndex();
					if ((aIPathIndex == 0 && circuit.SplitLanes[i].UseLeftLane > num) || (aIPathIndex == 1 && circuit.SplitLanes[i].UseMiddleLane > num) || (aIPathIndex == 2 && circuit.SplitLanes[i].UseRightLane > num))
					{
						m_splitLaneIndex = i;
						int num2 = 0;
						int num3 = 0;
						for (int j = 0; j < circuit.Waypoints.Length; j++)
						{
							if (circuit.Waypoints[j] == circuit.SplitLanes[i].Waypoints[0])
							{
								num2 = j;
							}
							else if (circuit.Waypoints[j] == circuit.SplitLanes[i].Waypoints[circuit.SplitLanes[i].Waypoints.Count - 1])
							{
								num3 = j;
							}
						}
						m_previousProgressDistance = progressDistance;
						for (int k = num2; k < num3; k++)
						{
							int num4 = (k + 1) % circuit.Waypoints.Length;
							m_previousProgressDistance += (circuit.Waypoints[num4].position - circuit.Waypoints[k].position).magnitude;
						}
						progressDistance = 20f;
					}
					else
					{
						m_ignoreSplitLaneIndex = i;
					}
				}
			}
			if (m_splitLaneIndex != -1 && circuit.SplitLanes[m_splitLaneIndex].HitEndOfSpline(progressDistance + lookAheadForTargetOffset))
			{
				m_splitLaneIndex = -1;
				progressDistance = m_previousProgressDistance;
			}
			zero = ((m_splitLaneIndex == -1) ? circuit.GetRoutePoint(progressDistance + lookAheadForTargetOffset).position : circuit.SplitLanes[m_splitLaneIndex].GetRoutePosition(progressDistance + lookAheadForTargetOffset));
			target.position = zero;
			target.rotation = Quaternion.LookRotation(circuit.GetRoutePoint(progressDistance + lookAheadForSpeedOffset + lookAheadForSpeedFactor * speed).direction);
			if (m_splitLaneIndex == -1)
			{
				progressPoint = circuit.GetRoutePoint(progressDistance);
				Vector3 lhs = progressPoint.position - base.transform.position;
				if (Vector3.Dot(lhs, progressPoint.direction) < 0f)
				{
					progressDistance += lhs.magnitude * 0.5f;
				}
			}
			else
			{
				progressPoint = circuit.SplitLanes[m_splitLaneIndex].GetRoutePoint(progressDistance);
				Vector3 normalized = (progressPoint.position - base.transform.position).normalized;
				if (Vector3.Dot(normalized, progressPoint.direction) < 0f || (base.transform.position - progressPoint.position).magnitude < 0.25f)
				{
					progressDistance += normalized.magnitude * 0.5f;
				}
			}
		}
		else if (m_player.GetPlayerType() == Player.PlayerType.Network || m_player.GetPlayerType() == Player.PlayerType.Network_Debug)
		{
			if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend)
			{
				return;
			}
			zero = circuit.GetRoutePoint(progressDistance + lookAheadForTargetOffset).position;
			target.position = zero;
			target.rotation = Quaternion.LookRotation(circuit.GetRoutePoint(progressDistance + lookAheadForSpeedOffset + lookAheadForSpeedFactor * speed).direction);
			progressPoint = circuit.GetRoutePoint(progressDistance);
			Vector3 lhs2 = progressPoint.position - base.transform.position;
			if (Vector3.Dot(lhs2, progressPoint.direction) < 0f)
			{
				progressDistance += lhs2.magnitude * 0.5f;
			}
		}
		lastPosition = base.transform.position;
	}

	private void OnDrawGizmos()
	{
		if (!(circuit == null) && !(target == null) && UnityEngine.Application.isPlaying)
		{
			Gizmos.color = UnityEngine.Color.green;
			Gizmos.DrawLine(base.transform.position, target.position);
			Gizmos.DrawWireSphere(circuit.GetRoutePosition(progressDistance), 1f);
			Gizmos.color = UnityEngine.Color.yellow;
			if (m_splitLaneIndex >= 0)
			{
				Gizmos.DrawLine(base.transform.position + Vector3.up * 0.5f, base.transform.position + circuit.SplitLanes[m_splitLaneIndex].GetRoutePoint(progressDistance).direction * 2f + Vector3.up * 0.5f);
			}
		}
	}
}
public class AccessoryLocator : UnityEngine.MonoBehaviour
{
	[Serializable]
	public enum LocatorType
	{
		Acc_Back,
		Acc_Front_Bottom,
		Acc_Front_Mid,
		Acc_Front_Top,
		Acc_Left,
		Acc_Right,
		Acc_Top,
		Acc_Visor,
		Acc_Dash001,
		Acc_Dash_Bottom001,
		Acc_DashTop001,
		Acc_EngineHead_Left001,
		Acc_EngineHead_Right001,
		Acc_Fairing_Left001,
		Acc_Fairing_Right001,
		Acc_FrontFairing001,
		Acc_Left_Headlight001,
		Acc_Left_Mirror001,
		Acc_Left_Mirror_Inner001,
		Acc_Left_Pod001,
		Acc_Left_Pod_Rear001,
		Acc_Left_Wheel001,
		Acc_Left_Wheel_Rear001,
		Acc_RegPlate001,
		Acc_Right_Headlight001,
		Acc_Right_Mirror001,
		Acc_Right_Mirror_Inner001,
		Acc_Right_Pod001,
		Acc_Right_Pod_Rear001,
		Acc_Right_Wheel001,
		Acc_Right_Wheel_Rear001
	}

	[Serializable]
	public struct LocatorData
	{
		public Transform Locator;

		public LocatorType Type;
	}

	[SerializeField]
	private LocatorData[] LocatorDataItem;

	private GameObject m_helmetPropObject;

	public Transform GetLocatorByType(LocatorType type)
	{
		for (int i = 0; i < LocatorDataItem.Length; i++)
		{
			if (LocatorDataItem[i].Type == type)
			{
				return LocatorDataItem[i].Locator;
			}
		}
		return null;
	}

	public void EnableObjectByLocatorType(LocatorType type, bool enable)
	{
		if (LocatorDataItem == null || LocatorDataItem.Length == 0)
		{
			return;
		}
		for (int i = 0; i < LocatorDataItem.Length; i++)
		{
			if (LocatorDataItem[i].Type != type)
			{
				continue;
			}
			Transform locator = LocatorDataItem[i].Locator;
			if ((bool)locator)
			{
				for (int j = 0; j < locator.childCount; j++)
				{
					locator.GetChild(j).gameObject.SetActive(enable);
				}
			}
		}
	}

	public void MoveToNewRoot(ref AccessoryLocator newLocator)
	{
		for (int i = 0; i < LocatorDataItem.Length; i++)
		{
			if (LocatorDataItem[i].Locator.childCount > 0)
			{
				for (int j = 0; j < LocatorDataItem[i].Locator.childCount; j++)
				{
					Transform child = LocatorDataItem[i].Locator.GetChild(j);
					child.transform.parent = newLocator.LocatorDataItem[i].Locator;
					child.transform.localPosition = Vector3.zero;
					child.transform.localRotation = Quaternion.identity;
					child.transform.localScale = Vector3.one;
				}
			}
		}
	}
}
public class BombheadBehaviour : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject BombHeadGeometryRoot;

	[SerializeField]
	private GameObject HelmetRoot;

	private const float BombTimer = 10f;

	private const float PassOnTime = 2f;

	private float m_timer;

	private Player m_player;

	public bool AllowedToPassOn()
	{
		return m_timer - Time.time < 8f;
	}

	private void OnEnable()
	{
		if ((bool)HelmetRoot)
		{
			HelmetRoot.GetComponent<Renderer>().enabled = false;
		}
		BombHeadGeometryRoot.gameObject.SetActive(value: true);
		m_timer = Time.time + 10f;
	}

	private void OnDisable()
	{
		if ((bool)HelmetRoot)
		{
			HelmetRoot.GetComponent<Renderer>().enabled = true;
		}
		BombHeadGeometryRoot.gameObject.SetActive(value: false);
		m_timer = 0f;
	}

	private void Start()
	{
		m_player = GetComponent<Player>();
	}

	private void Update()
	{
		if (Time.time > m_timer)
		{
			m_player.HitByWeapon();
			if (m_player.GetPlayerType() == Player.PlayerType.Human && (bool)ForceFeedback.Instance)
			{
				ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.KartCollision);
			}
			Explode();
		}
	}

	private void Explode()
	{
		if (GameSystem.Instance.BombHeadMode)
		{
			BombheadMode.Instance.BombExploded(GetComponent<Player>());
		}
		Gameplay.Instance.GetWeaponManager().CreateImpactEffect(base.gameObject, base.transform.position, WeaponManager.WeaponType.Bombhead);
		AudioSource component = BombHeadGeometryRoot.transform.GetChild(0).GetComponent<AudioSource>();
		if ((bool)component)
		{
			AudioSource audioSource = UnityEngine.Object.Instantiate(component);
			audioSource.name = "BombExplosionAudio";
			audioSource.transform.position = base.transform.position;
			audioSource.GetComponent<AudioSource>().Play();
			UnityEngine.Object.Destroy(audioSource.gameObject, 3f);
		}
		base.enabled = false;
	}
}
public class CollisionLayerManager : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Collider[] m_collidersToSet;

	[SerializeField]
	private Player m_player;

	private bool m_onTrack;

	private void SetOnTrack(bool onTrack)
	{
		m_onTrack = onTrack;
		for (int i = 0; i < m_collidersToSet.Length; i++)
		{
			if (onTrack)
			{
				m_collidersToSet[i].gameObject.layer = LayerMask.NameToLayer("OnTrack");
			}
			else
			{
				m_collidersToSet[i].gameObject.layer = LayerMask.NameToLayer("OffTrack");
			}
		}
	}

	private void Start()
	{
		SetOnTrack(onTrack: true);
	}

	private void Update()
	{
		if ((bool)Gameplay.Instance && Gameplay.Instance.RaceStarted() && m_player.IsOffroad() == m_onTrack)
		{
			SetOnTrack(!m_onTrack);
		}
	}
}
public class CrowdMember : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Animator CurrentAnimator;

	private string[] Anims = new string[6] { "Default", "IsWaving_R", "IsWaving_L", "IsFistPumping_R", "IsFistPumping_L", "IsCelebrating" };

	private float m_animTimer;

	private int m_currentAnimIndex;

	private void Update()
	{
		float num = GameTime.Instance.CurrentTime();
		if (num > m_animTimer)
		{
			int num2 = -1;
			num2 = ((m_currentAnimIndex == 0) ? UnityEngine.Random.Range(0, Anims.Length) : 0);
			if (m_currentAnimIndex != 0)
			{
				CurrentAnimator.SetBool(Anims[m_currentAnimIndex], value: false);
			}
			m_currentAnimIndex = num2;
			if (m_currentAnimIndex != 0)
			{
				CurrentAnimator.SetBool(Anims[m_currentAnimIndex], value: true);
			}
			m_animTimer = num + UnityEngine.Random.Range(2f, 5f);
		}
	}
}
public class DrivingRecorder : UnityEngine.MonoBehaviour
{
}
public class FEMAnimation : UnityEngine.MonoBehaviour
{
	public enum Direction
	{
		Left,
		Right
	}

	[SerializeField]
	private Animator CurrentAnimator;

	private const string DriverLeanLeftAnim = "Driver_Lean_L";

	private const string DriverLeanRightAnim = "Driver_Lean_R";

	private const string DriverIdleAnim = "Driver_FE_Breathe";

	private const float MaxLeanPositionOffset = 0.18f;

	private const float LeanScale = 0.5f;

	private Animator m_animator;

	private float m_currentLeanAmount;

	private float m_leanTarget;

	private void Awake()
	{
		m_animator = CurrentAnimator;
	}

	private void Update()
	{
		if ((bool)m_animator && m_animator.enabled)
		{
			m_animator.Play("Driver_FE_Breathe", 0);
		}
		UpdateLean();
	}

	private void UpdateLean()
	{
		int layerIndex = m_animator.GetLayerIndex("UpperBody");
		float x = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.localPosition.x;
		m_leanTarget = x / 0.18f;
		m_leanTarget = Mathf.Clamp(m_leanTarget, -1f, 1f);
		m_currentLeanAmount = Mathf.Lerp(m_currentLeanAmount, m_leanTarget, 4f * GameTime.Instance.CurrentTime());
		if ((bool)m_animator && m_animator.enabled)
		{
			float num = m_currentLeanAmount * 0.5f;
			if (num > 0f)
			{
				m_animator.Play("Driver_Lean_R", layerIndex, num);
			}
			else if (num < 0f)
			{
				m_animator.Play("Driver_Lean_L", layerIndex, Mathf.Abs(num));
			}
		}
	}
}
public class NameBadge : UnityEngine.MonoBehaviour
{
	public enum NameState
	{
		None,
		Grow,
		Shrink
	}

	[SerializeField]
	private TextMesh NameTag;

	[SerializeField]
	private TextMesh NameTagShadow;

	[SerializeField]
	private TextMesh NumWins;

	[SerializeField]
	private TextMesh OnlinePoints;

	[SerializeField]
	private GameObject ColourTag;

	private const float k_minNameDistance = 5f;

	private const float k_maxNameDistance = 40f;

	private const float k_minNameScale = 1f;

	private const float k_maxNameScale = 2f;

	private const float k_scaleMultiplierSpeed = 5f;

	private float m_targetScale;

	private float m_currentScale;

	private float m_scaleMultiplier;

	private NameState m_nameState;

	public void SetNumWins(int wins)
	{
		if ((bool)NumWins)
		{
			NumWins.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Wins", convertToUpperCase: true) + " " + wins;
		}
	}

	public void SetOnlinePoints(int points)
	{
		if ((bool)OnlinePoints)
		{
			OnlinePoints.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_Points", convertToUpperCase: true) + " " + points;
		}
	}

	private void Update()
	{
		Player refPlayer = null;
		Vector3 worldPosition = Vector3.zero;
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend && FEMManager.Instance.GetFrontendPlayer(0) != null)
		{
			worldPosition = FEMManager.Instance.GetFrontendPlayer(0).transform.position;
		}
		else if (PlayerManager.Instance == null)
		{
			worldPosition = CameraManager.Instance.GetCurrentCamera().transform.position;
		}
		else
		{
			PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
			if (refPlayer != null)
			{
				worldPosition = refPlayer.transform.position;
			}
		}
		if (m_scaleMultiplier > 0f)
		{
			base.transform.LookAt(worldPosition);
			base.transform.Rotate(0f, 180f, 0f);
			float magnitude = (base.transform.position - CameraManager.Instance.GetCurrentCamera().transform.position).magnitude;
			float num = 1f / 35f;
			magnitude -= 5f;
			m_targetScale = Mathf.Clamp(magnitude * num + 1f, 1f, 2f);
		}
		switch (m_nameState)
		{
		case NameState.Grow:
			m_scaleMultiplier += 5f * GameTime.Instance.DeltaTime();
			if (m_scaleMultiplier > 1f)
			{
				m_scaleMultiplier = 1f;
			}
			break;
		case NameState.Shrink:
			m_scaleMultiplier -= 5f * GameTime.Instance.DeltaTime();
			if (m_scaleMultiplier < 0f)
			{
				m_scaleMultiplier = 0f;
			}
			break;
		}
		UpdateScale();
	}

	public void SetState(NameState state)
	{
		if (m_nameState != state)
		{
			m_nameState = state;
		}
	}

	private void UpdateScale()
	{
		m_currentScale = Mathf.Lerp(m_currentScale, m_targetScale, 8f * GameTime.Instance.DeltaTime());
		m_currentScale *= m_scaleMultiplier;
		base.transform.localScale = new Vector3(m_currentScale, m_currentScale, m_currentScale);
		bool flag = base.transform.localScale.y > 0f;
		if (NameTag.gameObject.activeSelf != flag)
		{
			NameTag.gameObject.SetActive(flag);
			if ((bool)NumWins)
			{
				NumWins.gameObject.SetActive(flag);
			}
		}
	}
}
public class Player : UnityEngine.MonoBehaviour
{
	public enum PlayerType
	{
		Human,
		AI,
		Network,
		Network_Debug,
		FEM
	}

	public struct LapData
	{
		public int count;

		public double[] lapTime;

		public double totalTime;

		public double totalAvgTime;
	}

	public enum PlayerSFXType
	{
		ShieldPowerDown,
		StartBoost,
		EngineSplutter,
		SceneryImpact,
		KartImpact,
		CurbImpact
	}

	private enum ShieldState
	{
		None,
		BecomingEnabled,
		Enabled,
		Hit,
		BecomingDisabled
	}

	public enum PlayerFinishedState
	{
		None,
		ReadyForResults,
		InResults
	}

	[SerializeField]
	public Transform CameraLocator;

	[SerializeField]
	public GameObject NameObject;

	[SerializeField]
	private TextMesh NameField;

	[SerializeField]
	private TextMesh NameFieldShadow;

	[SerializeField]
	public MeshRenderer NameColours;

	[SerializeField]
	private AudioSource HornSource;

	[SerializeField]
	private AudioSource EmoteSource;

	[SerializeField]
	private AudioSource LightSwitchSource;

	[SerializeField]
	public Transform ExhaustLocator;

	[SerializeField]
	private Subtitles SubtitleUI;

	[SerializeField]
	private Text TimeTrialText;

	[SerializeField]
	private GameObject HeadlightL;

	[SerializeField]
	private GameObject HeadlightR;

	[SerializeField]
	private Vector3 PlayerHeadAngle = new Vector3(30f, 45f, 30f);

	[SerializeField]
	private TextMesh NamePlate;

	[SerializeField]
	private GameObject ReverseDisruptObject;

	[SerializeField]
	private GameObject WarningLightFeedback;

	[SerializeField]
	public float CutoutTime = 6f;

	[SerializeField]
	private Transform MirrorRoot;

	[SerializeField]
	private KartGeometry DefaultGeometry;

	[SerializeField]
	private KartGeometry NetworkGeometry;

	[SerializeField]
	private KartWheel BackLeft;

	[SerializeField]
	private KartWheel FrontLeft;

	[SerializeField]
	private KartWheel FrontRight;

	[SerializeField]
	public AudioSource PickupAudioSource;

	public WeaponControl WeaponControlObject;

	[SerializeField]
	private int TintColourReduction = 180;

	[SerializeField]
	private float TintColourSpeed = 8f;

	[SerializeField]
	public KartBoostTrail[] BoostTrails;

	[SerializeField]
	private ParticleSystem PortalTeleportStreaks;

	[SerializeField]
	private GameObject OutOfBoundsObj;

	[SerializeField]
	public GameObject WrongWayObj;

	[SerializeField]
	private float SpeedPickupReductionSpeed = 20f;

	[SerializeField]
	private float ReductionSpeedMultiplier = 0.2f;

	[SerializeField]
	private float TopSpeedForSpeedMultiplier = 40f;

	[SerializeField]
	private AudioClip ShieldPowerDownAudio;

	[SerializeField]
	private AudioClip StartBoostSFX;

	[SerializeField]
	private AudioClip CurbImpactSFX;

	[SerializeField]
	private AudioClip[] EngineSplutterSFX;

	[SerializeField]
	private AudioClip[] SceneryImpactSFX;

	[SerializeField]
	private AudioClip[] KartImpactSFX;

	[SerializeField]
	private AudioSource ImpactAudioSource;

	[SerializeField]
	private KartSafetyCushion SafetyCushion;

	[SerializeField]
	private AudioSource RadiusBombAudio;

	public AudioSource MeterFillAudioSource;

	public ParticleSystem[] PlayerBadExhaustRoot;

	public ParticleSystem[] PlayerToxicExhaustRoot;

	private KartGeometry m_currentGeometry;

	private float m_portalStreakTimer;

	public float m_portalTrailTimer;

	public bool TurnOffKartOnTrackFinish;

	private const float k_kartRespawnTrackOffset = 10f;

	private float k_shadowNormalOffset = 0.035f;

	private bool m_gameSeup;

	private bool m_networkSetup;

	private float targetHelmetY;

	private float targetHelmetX;

	private float m_lookaroundTimer;

	private string m_nameString = string.Empty;

	private Player m_overtakenPlayer;

	private float m_offroadFadeDelay;

	private int m_ignoreOffroadRefCount;

	private int m_removeSignRefCount;

	private int m_vibrationOverrideRefCount;

	private int m_stickToGridCounter;

	private const int MaxFramesForStick = 30;

	private float m_targetSteeringAngle;

	private float m_offroadTimer;

	private float m_timeTrialTimer;

	private static int RaceOrderFrameIndex;

	private int m_currentRaceOrderFrameIndex;

	private int m_splitLaneRefCount;

	private SplitLane m_currentSplitLane;

	private List<GameObject> m_customisationProps = new List<GameObject>();

	private List<MeshRenderer> m_propRendereres = new List<MeshRenderer>();

	private List<UnityEngine.Color> m_propStartColour = new List<UnityEngine.Color>();

	private LapData m_lapData;

	private bool m_midLineCrossed;

	private bool m_lapTimesStarted;

	private int m_currentLineIndex;

	private int m_currentWayPointIndex;

	private float m_pointOnTrack;

	private float m_localPointOnTrack;

	private float m_singleLapPointOnTrack;

	private float m_previousPointOnTrack;

	private float m_previousPointOnTrackSingle;

	private float m_originalImmobiliseTime;

	private VRWaypointCircuit m_circuitPath;

	private Vector3 m_closestPositionOnTrack;

	private Vector3 m_closestDirectionOnTrack;

	private int m_finalPosition = -1;

	private PlayerType m_playerType = PlayerType.AI;

	private Vector3 m_prevPosition;

	private GameObject m_targetAIObject;

	private bool m_weaponEnabled;

	private Vector3 m_headlightZonePos;

	private bool m_inHeadlightZone;

	private bool m_enableLights = true;

	private bool m_shouldCheckForHeadlights;

	private float m_currentShadowTintColour;

	private float m_engineSplutterDelay;

	private AudioSource m_playerAudioSource;

	private PlayerAnimation m_playerAnimation;

	private int m_targettedRefCount;

	private const float ShieldFlashSpeed = 0.1f;

	private const float ShieldTransitionTime = 0.5f;

	private const float ShieldColourTime = 10f;

	private ShieldState m_shieldState;

	private UnityEngine.Color m_shieldColour;

	private float m_shieldTimer;

	private float m_targetAlpha = 1f;

	private float m_currentAlpha;

	private float m_choiceTimer;

	private int m_onlinePlayerIndex;

	private bool m_placedOnGrid;

	private float m_gridTimer;

	private float m_ignitionTimer;

	private bool m_engineStarted;

	private bool[] m_offroad;

	private bool m_anyOffroad;

	private float m_slipstreamTime;

	private float m_slipstreamDurationTimer;

	private const float NumSpeedPickups = 10f;

	private float m_speedBoostAmount;

	private bool m_correctOrientationNow;

	private Vector3 m_correctOrientation = Vector3.forward;

	private PlayerFinishedState m_playerFinishState;

	public string OnlineID { get; set; }

	public NameBadge NameBadge { get; private set; }

	public bool EnablePortalTrail { get; set; }

	public bool FinishedWithBees { get; set; }

	public int LocalPlayerIndex { get; set; }

	public bool InGame { get; set; }

	public Vector3 GroundPosition { get; set; }

	public int ResultsCol1 { get; private set; }

	public int ResultsCol2 { get; private set; }

	public LapData LapDataEntry
	{
		get
		{
			return m_lapData;
		}
		set
		{
			m_lapData = value;
		}
	}

	public bool LapTimeStarted => m_lapTimesStarted;

	public float NetworkSteeringAngle { get; set; }

	public float ToxicTimer { get; set; }

	public float ImmobilizeTime { get; set; }

	public Vector3 ClosestDirOnTrack => m_closestDirectionOnTrack;

	public KartExhaust KartExhaust { get; set; }

	public int FinalPosition
	{
		get
		{
			return m_finalPosition;
		}
		set
		{
			m_finalPosition = value;
		}
	}

	public WeaponManager.WeaponType WeaponType { get; set; }

	public WeaponManager.WeaponType WeaponTypeToRender { get; set; }

	public WeaponManager.WeaponType LastWeaponType { get; set; }

	public int PrevRaceOrder { get; set; }

	public int CurrentRaceOrder { get; set; }

	public int CurrentOcclusionZone { get; set; }

	public float WeaponTypeTimer { get; set; }

	public PlayerFinishedState PlayerFinishState
	{
		get
		{
			return m_playerFinishState;
		}
		set
		{
			m_playerFinishState = value;
		}
	}

	public int OnlinePlayerIndex
	{
		get
		{
			return m_onlinePlayerIndex;
		}
		set
		{
			m_onlinePlayerIndex = value;
		}
	}

	public int SeatIndex { get; set; }

	public bool MasterIsHappy { get; set; }

	public int NewGridPosition { get; set; }

	public void SetIgnoreOffroad(bool set, bool removeSign)
	{
		if (set)
		{
			m_ignoreOffroadRefCount++;
		}
		else if (m_ignoreOffroadRefCount > 0)
		{
			m_ignoreOffroadRefCount--;
		}
		if (removeSign)
		{
			if (set)
			{
				m_removeSignRefCount++;
			}
			else if (m_removeSignRefCount > 0)
			{
				m_removeSignRefCount--;
			}
		}
	}

	public bool ShouldIgnoreOffroad()
	{
		return m_ignoreOffroadRefCount > 0;
	}

	public bool ShouldRemoveWrongWay()
	{
		return m_removeSignRefCount > 0;
	}

	public void SetVibrationOverride(bool set)
	{
		if (set)
		{
			m_vibrationOverrideRefCount++;
		}
		else if (m_vibrationOverrideRefCount > 0)
		{
			m_vibrationOverrideRefCount--;
		}
	}

	private bool VibrationOverride()
	{
		return m_vibrationOverrideRefCount > 0;
	}

	public bool IsInAir()
	{
		if (!BackLeft.IsInAir())
		{
			return false;
		}
		if (!FrontLeft.IsInAir())
		{
			return false;
		}
		if (!FrontRight.IsInAir())
		{
			return false;
		}
		return false;
	}

	public void EnablePortalStreaks()
	{
		if (m_portalStreakTimer <= 0f)
		{
			m_portalStreakTimer = 1f;
			if ((bool)PortalTeleportStreaks && !PortalTeleportStreaks.isPlaying)
			{
				PortalTeleportStreaks.Play();
			}
		}
	}

	public void SetInSplitLane(bool set, ref SplitLane lane)
	{
		if (set)
		{
			m_currentSplitLane = lane;
			m_splitLaneRefCount++;
			return;
		}
		m_splitLaneRefCount--;
		if (m_splitLaneRefCount < 0)
		{
			m_splitLaneRefCount = 0;
		}
		if (m_splitLaneRefCount == 0)
		{
			UpdateCurrentWayPoint();
		}
	}

	public bool InSplitLane(ref SplitLane lane)
	{
		if (m_splitLaneRefCount > 0)
		{
			lane = m_currentSplitLane;
			return true;
		}
		return false;
	}

	public KartGeometry GetKartGeometry()
	{
		return m_currentGeometry;
	}

	public void SetBeingTargetted(bool set)
	{
		if (set)
		{
			m_targettedRefCount++;
		}
		else if (m_targettedRefCount > 0)
		{
			m_targettedRefCount--;
		}
	}

	private static void ReferenceCallback()
	{
		RaceOrderFrameIndex = 0;
	}

	public void PlayOneShotAudio(PlayerSFXType type)
	{
		if (PlayerFinishState != 0)
		{
			return;
		}
		AudioSource audioSource = UnityEngine.Object.Instantiate(PickupAudioSource);
		AudioClip audioClip = null;
		audioSource.transform.parent = base.transform;
		audioSource.transform.localPosition = Vector3.zero;
		switch (type)
		{
		case PlayerSFXType.ShieldPowerDown:
			audioClip = ShieldPowerDownAudio;
			break;
		case PlayerSFXType.StartBoost:
			audioClip = StartBoostSFX;
			break;
		case PlayerSFXType.EngineSplutter:
			audioClip = EngineSplutterSFX[UnityEngine.Random.Range(0, EngineSplutterSFX.Length)];
			break;
		case PlayerSFXType.SceneryImpact:
			if (SceneryImpactSFX != null && SceneryImpactSFX.Length > 0)
			{
				ImpactAudioSource.clip = SceneryImpactSFX[UnityEngine.Random.Range(0, SceneryImpactSFX.Length)];
				ImpactAudioSource.Play();
			}
			break;
		case PlayerSFXType.KartImpact:
			ImpactAudioSource.clip = KartImpactSFX[UnityEngine.Random.Range(0, KartImpactSFX.Length)];
			ImpactAudioSource.Play();
			break;
		case PlayerSFXType.CurbImpact:
			audioClip = CurbImpactSFX;
			break;
		}
		if ((bool)audioClip)
		{
			audioSource.PlayOneShot(audioClip);
			UnityEngine.Object.Destroy(audioSource.gameObject, audioClip.length + 0.5f);
		}
	}

	public bool IsPlayingAudio()
	{
		if ((bool)m_playerAudioSource)
		{
			return m_playerAudioSource.isPlaying;
		}
		return false;
	}

	public void PlayAudio(AudioClip audioClip, bool forceNoUI = false)
	{
		if ((bool)m_playerAudioSource)
		{
			m_playerAudioSource.clip = audioClip;
			m_playerAudioSource.Play();
			if ((bool)SubtitleUI && !forceNoUI)
			{
				SubtitleUI.SetText(audioClip, m_playerAudioSource);
			}
		}
	}

	public float GetSteeringAngle()
	{
		return GetComponent<KartUserControl>().GetSteeringAngle();
	}

	public bool IsBeingTargetted()
	{
		return m_targettedRefCount > 0;
	}

	public void ResetIgnition()
	{
		m_engineStarted = false;
		m_ignitionTimer = Time.time + UnityEngine.Random.Range(0.5f, 3f);
	}

	public void ResetWayPoints()
	{
		if (GetPlayerType() != 0)
		{
			m_currentLineIndex = 0;
			m_currentWayPointIndex = 0;
			if ((bool)GetComponent<VRWaypointProgressTracker>())
			{
				GetComponent<VRWaypointProgressTracker>().Reset();
			}
		}
	}

	public void EnableReverseDisrupt(bool enable)
	{
		if (GetPlayerType() == PlayerType.Human)
		{
			if (enable)
			{
				EnableWarningLightFeedback(enable: false);
			}
			if ((bool)ReverseDisruptObject)
			{
				ReverseDisruptObject.SetActive(enable);
			}
		}
	}

	public void EnableWarningLightFeedback(bool enable)
	{
		if (GetPlayerType() == PlayerType.Human && (bool)WarningLightFeedback)
		{
			WarningLightFeedback.SetActive(enable);
		}
	}

	public void SetShieldEnabled(bool enabled)
	{
		if (enabled)
		{
			SetShieldState(ShieldState.Enabled);
			return;
		}
		if (GetPlayerType() == PlayerType.Human)
		{
			PlayOneShotAudio(PlayerSFXType.ShieldPowerDown);
		}
		SetShieldState(ShieldState.BecomingDisabled);
	}

	public void SetRadiusBombEnabled(bool enabled)
	{
		if (enabled)
		{
			RadiusBombAudio.Play();
		}
		GetKartGeometry().RadiusBombObject.SetActive(enabled);
		SetRadiusBombScale(0f);
		GetKartGeometry().SetRadiusBombAlpha(0.75f);
	}

	public void SetRadiusBombScale(float scale)
	{
		GetKartGeometry().RadiusBombObject.transform.localScale = new Vector3(scale, scale, scale);
	}

	public void ForceEffectsOff()
	{
		GetKartGeometry().BubbleShieldObject.SetActive(value: false);
		SetShieldState(ShieldState.None);
		if (RadiusBombAudio != null)
		{
			RadiusBombAudio.Stop();
		}
		if (GetKartGeometry().RadiusBombObject != null)
		{
			GetKartGeometry().RadiusBombObject.SetActive(value: false);
		}
		EnableReverseDisrupt(enable: false);
		EnableWarningLightFeedback(enable: false);
		GetComponent<KartController>().TurnOffWheelEffects();
		if (GetPlayerType() == PlayerType.Human)
		{
			CameraManager.Instance.EnableLowPassFilter(enable: false);
			CameraManager.Instance.EnableReverbFilter(enable: false);
		}
		m_inHeadlightZone = false;
		GetComponent<KartController>().EnableSpeedBoost(enable: false);
	}

	public bool IsShieldEnabled()
	{
		return m_shieldState != ShieldState.None;
	}

	public void DisableNameBadge()
	{
		if ((bool)NameObject)
		{
			NameObject.gameObject.SetActive(value: false);
		}
	}

	public void EnableNameBadge()
	{
		if ((bool)NameObject)
		{
			NameObject.gameObject.SetActive(value: true);
		}
	}

	public int GetCurrentLap()
	{
		return m_lapData.count;
	}

	public bool CalculateAndSendLeaderboardResults(ref int lapIndex)
	{
		double num = double.PositiveInfinity;
		lapIndex = 0;
		for (int i = 0; i < m_lapData.lapTime.Length; i++)
		{
			if (i < LapManager.Instance.GetNumLaps() && m_lapData.lapTime[i] < num)
			{
				num = m_lapData.lapTime[i];
				lapIndex = i;
			}
		}
		if ((bool)NetworkLogin.Instance)
		{
			float timeInSeconds = GameTime.Instance.ConvertToSeconds(num);
			return NetworkLogin.Instance.GetNetworkLeaderboards().AddLeaderboardEntry(NetworkLeaderboards.LeaderboardType.QuickPlay, GameSystem.Instance.GetLoadedTrack().Scene, timeInSeconds);
		}
		return false;
	}

	public float LastPointOnTrack(bool singleLapOnly = false)
	{
		if (singleLapOnly)
		{
			return m_previousPointOnTrackSingle;
		}
		return m_previousPointOnTrack;
	}

	public float PointOnTrack(bool singleLapOnly = false)
	{
		if (singleLapOnly)
		{
			return m_singleLapPointOnTrack;
		}
		return m_pointOnTrack;
	}

	public bool GridTimerIsGo()
	{
		return m_gridTimer <= 0f;
	}

	public void SetGridTime(float gridTime)
	{
		m_gridTimer = gridTime;
	}

	public bool PlacedOnGrid()
	{
		return m_placedOnGrid;
	}

	public PlayerType GetPlayerType()
	{
		return m_playerType;
	}

	public void SetPlayerType(PlayerType type)
	{
		m_playerType = type;
	}

	public Vector3 GetPreviousPosition()
	{
		return m_prevPosition;
	}

	public void SetHornClip(AudioClip clip)
	{
		HornSource.clip = clip;
		HornSource.Play();
	}

	public void SetAITarget(VRWaypointCircuit path)
	{
		GetComponent<VRWaypointProgressTracker>().SetCircuit(path);
		GetComponent<VRWaypointProgressTracker>().target = m_targetAIObject.transform;
		GetComponent<VRCarAIControl>().SetTarget(m_targetAIObject.transform);
	}

	public void EnableWeapon(bool enable)
	{
		m_weaponEnabled = enable;
		if (enable)
		{
			WeaponTypeTimer = 2f;
			m_choiceTimer = 0f;
			WeaponType = WeaponManager.Instance.ChooseRandomWeapon(this);
			WeaponTypeToRender = WeaponType;
		}
	}

	public void GivePlayerWeapon(WeaponManager.WeaponType weapon)
	{
		WeaponTypeTimer = 0.02f;
		WeaponType = weapon;
		WeaponTypeToRender = weapon;
		m_weaponEnabled = true;
	}

	public bool WeaponEnabled()
	{
		return m_weaponEnabled;
	}

	public string GetDisplayName()
	{
		return m_nameString;
	}

	public void SetName(string name)
	{
		if (name == null)
		{
			return;
		}
		m_nameString = name;
		if (m_nameString.Length > ProfileManager.MaxNameLength + 2)
		{
			m_nameString = m_nameString.Substring(0, ProfileManager.MaxNameLength);
			m_nameString += "..";
		}
		if ((bool)NameField)
		{
			NameField.text = m_nameString;
			NameFieldShadow.text = m_nameString;
			if (NamePlate != null)
			{
				NamePlate.text = NameField.text;
			}
		}
	}

	public void SetNumWins(int wins)
	{
		NameBadge.SetNumWins(wins);
	}

	public void SetOnlinePoints(int points)
	{
		NameBadge.SetOnlinePoints(points);
	}

	public void StopExhaust()
	{
		KartExhaust.StopExhaust();
		GetComponent<KartController>().StopAllParticles();
	}

	public bool HitByWeapon(Gameplay.HitByType hitType = Gameplay.HitByType.NormalWeapon)
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice3)
		{
			FTUE.Instance.HitBalloon();
			return true;
		}
		if (IsShieldEnabled())
		{
			SetShieldState(ShieldState.Hit);
			return false;
		}
		GetComponent<KartController>().Immobilize(CutoutTime, hitType);
		UpdateHitByWeaponReaction();
		return true;
	}

	public void SetOffroad(bool offroad, int index)
	{
		m_offroad[index] = offroad;
	}

	public bool IsOffroad()
	{
		return m_anyOffroad;
	}

	public float GetSpeedPickupAmount()
	{
		return m_speedBoostAmount;
	}

	public bool AddBoostAmount()
	{
		if (m_speedBoostAmount < 1f)
		{
			float num = 0.1f;
			if (m_speedBoostAmount < 0.01f)
			{
				num += num * 0.5f;
			}
			m_speedBoostAmount += num;
			if (m_speedBoostAmount > 1f)
			{
				m_speedBoostAmount = 1f;
			}
			return true;
		}
		return false;
	}

	public void ReduceBoostAmount(float normalisedSegmentAmount)
	{
		float num = 0.1f;
		num *= normalisedSegmentAmount;
		m_speedBoostAmount -= num;
		if (m_speedBoostAmount < 0f)
		{
			m_speedBoostAmount = 0f;
		}
	}

	public void AddBoostAmount(float amountToAdd)
	{
		m_speedBoostAmount += amountToAdd;
		if (m_speedBoostAmount > 1f)
		{
			m_speedBoostAmount = 1f;
		}
	}

	public bool ForceEndOfRaceForAI()
	{
		if (PlayerFinishState != 0)
		{
			return false;
		}
		Player refPlayer = null;
		PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		PlayerFinishState = PlayerFinishedState.ReadyForResults;
		m_lapData.totalTime += refPlayer.m_lapData.totalTime;
		m_lapData.totalAvgTime = m_lapData.totalTime / (double)m_lapData.count;
		return true;
	}

	private void UpdatePortalStreaks()
	{
		if (m_portalTrailTimer > 0f)
		{
			m_portalTrailTimer -= GameTime.Instance.DeltaTime();
			if (m_portalTrailTimer <= 0f)
			{
				EnablePortalTrail = false;
			}
		}
		else if (EnablePortalTrail)
		{
			m_portalTrailTimer = 1.1f;
		}
		if (!(m_portalStreakTimer > 0f))
		{
			return;
		}
		KartController component = GetComponent<KartController>();
		if (component.IsBoostEnabled())
		{
			m_portalStreakTimer = 0f;
		}
		m_portalStreakTimer -= GameTime.Instance.DeltaTime();
		if (m_portalStreakTimer <= 0f)
		{
			m_portalStreakTimer = 0f;
			if ((bool)PortalTeleportStreaks && PortalTeleportStreaks.isPlaying)
			{
				PortalTeleportStreaks.Stop();
			}
		}
	}

	private void UpdateSpeedPickups()
	{
		KartController component = GetComponent<KartController>();
		if (component.IsBoostEnabled())
		{
			float num = Mathf.Clamp(component.CurrentSpeed / TopSpeedForSpeedMultiplier, 0f, 1f);
			float num2 = SpeedPickupReductionSpeed * ReductionSpeedMultiplier;
			float num3 = SpeedPickupReductionSpeed - num2;
			float num4 = num2 + num3 * num;
			m_speedBoostAmount -= 1f / num4 * GameTime.Instance.DeltaTime();
			if (m_speedBoostAmount < 0f)
			{
				m_speedBoostAmount = 0f;
			}
		}
	}

	private void UpdateShadowTintColour()
	{
		GetKartGeometry().StoreMaterialColours();
		if (m_inHeadlightZone)
		{
			m_currentShadowTintColour = Mathf.Lerp(m_currentShadowTintColour, TintColourReduction, TintColourSpeed * GameTime.Instance.DeltaTime());
		}
		else
		{
			m_currentShadowTintColour = Mathf.Lerp(m_currentShadowTintColour, 0f, TintColourSpeed * GameTime.Instance.DeltaTime());
		}
		if ((bool)GetKartGeometry().RacerRenderer)
		{
			UnityEngine.Color startRacerRendererColour = GetKartGeometry().StartRacerRendererColour;
			startRacerRendererColour.r -= m_currentShadowTintColour / 255f;
			startRacerRendererColour.g -= m_currentShadowTintColour / 255f;
			startRacerRendererColour.b -= m_currentShadowTintColour / 255f;
			if (startRacerRendererColour.r < 0f)
			{
				startRacerRendererColour.r = 0f;
			}
			if (startRacerRendererColour.g < 0f)
			{
				startRacerRendererColour.g = 0f;
			}
			if (startRacerRendererColour.b < 0f)
			{
				startRacerRendererColour.b = 0f;
			}
			for (int i = 0; i < GetKartGeometry().RacerRenderer.materials.Length; i++)
			{
				if (GetKartGeometry().RacerRenderer.materials[i].HasProperty("_LightColor"))
				{
					GetKartGeometry().RacerRenderer.materials[i].SetColor("_LightColor", startRacerRendererColour);
					break;
				}
			}
		}
		if ((bool)GetKartGeometry().RacerRendererAlt)
		{
			UnityEngine.Color startRacerRendererAltColour = GetKartGeometry().StartRacerRendererAltColour;
			startRacerRendererAltColour.r -= m_currentShadowTintColour / 255f;
			startRacerRendererAltColour.g -= m_currentShadowTintColour / 255f;
			startRacerRendererAltColour.b -= m_currentShadowTintColour / 255f;
			if (startRacerRendererAltColour.r < 0f)
			{
				startRacerRendererAltColour.r = 0f;
			}
			if (startRacerRendererAltColour.g < 0f)
			{
				startRacerRendererAltColour.g = 0f;
			}
			if (startRacerRendererAltColour.b < 0f)
			{
				startRacerRendererAltColour.b = 0f;
			}
			for (int j = 0; j < GetKartGeometry().RacerRendererAlt.materials.Length; j++)
			{
				if (GetKartGeometry().RacerRendererAlt.materials[j].HasProperty("_LightColor"))
				{
					GetKartGeometry().RacerRendererAlt.materials[j].SetColor("_LightColor", startRacerRendererAltColour);
					break;
				}
			}
		}
		if ((bool)GetKartGeometry().KartRenderer)
		{
			UnityEngine.Color startKartRendererColour = GetKartGeometry().StartKartRendererColour;
			startKartRendererColour.r -= m_currentShadowTintColour / 255f;
			startKartRendererColour.g -= m_currentShadowTintColour / 255f;
			startKartRendererColour.b -= m_currentShadowTintColour / 255f;
			if (startKartRendererColour.r < 0f)
			{
				startKartRendererColour.r = 0f;
			}
			if (startKartRendererColour.g < 0f)
			{
				startKartRendererColour.g = 0f;
			}
			if (startKartRendererColour.b < 0f)
			{
				startKartRendererColour.b = 0f;
			}
			for (int k = 0; k < GetKartGeometry().KartRenderer.materials.Length; k++)
			{
				if (GetKartGeometry().KartRenderer.materials[k].HasProperty("_LightColor"))
				{
					GetKartGeometry().KartRenderer.materials[k].SetColor("_LightColor", startKartRendererColour);
					break;
				}
			}
		}
		if ((bool)GetKartGeometry().HelmetRenderer)
		{
			UnityEngine.Color startHelmetRendererColour = GetKartGeometry().StartHelmetRendererColour;
			startHelmetRendererColour.r -= m_currentShadowTintColour / 255f;
			startHelmetRendererColour.g -= m_currentShadowTintColour / 255f;
			startHelmetRendererColour.b -= m_currentShadowTintColour / 255f;
			if (startHelmetRendererColour.r < 0f)
			{
				startHelmetRendererColour.r = 0f;
			}
			if (startHelmetRendererColour.g < 0f)
			{
				startHelmetRendererColour.g = 0f;
			}
			if (startHelmetRendererColour.b < 0f)
			{
				startHelmetRendererColour.b = 0f;
			}
			for (int l = 0; l < GetKartGeometry().HelmetRenderer.materials.Length; l++)
			{
				if (GetKartGeometry().HelmetRenderer.materials[l].HasProperty("_LightColor"))
				{
					GetKartGeometry().HelmetRenderer.materials[l].SetColor("_LightColor", startHelmetRendererColour);
					break;
				}
			}
		}
		if ((bool)GetKartGeometry().Wheel_Front_Left)
		{
			UnityEngine.Color wheelColour = GetKartGeometry().WheelColour;
			wheelColour.r -= m_currentShadowTintColour / 255f;
			wheelColour.g -= m_currentShadowTintColour / 255f;
			wheelColour.b -= m_currentShadowTintColour / 255f;
			if (wheelColour.r < 0f)
			{
				wheelColour.r = 0f;
			}
			if (wheelColour.g < 0f)
			{
				wheelColour.g = 0f;
			}
			if (wheelColour.b < 0f)
			{
				wheelColour.b = 0f;
			}
			MeshRenderer component = GetKartGeometry().Wheel_Front_Left.GetComponent<MeshRenderer>();
			for (int m = 0; m < component.materials.Length; m++)
			{
				if (component.materials[m].HasProperty("_LightColor"))
				{
					component.materials[m].SetColor("_LightColor", wheelColour);
					break;
				}
			}
			component = GetKartGeometry().Wheel_Front_Right.GetComponent<MeshRenderer>();
			for (int n = 0; n < component.materials.Length; n++)
			{
				if (component.materials[n].HasProperty("_LightColor"))
				{
					component.materials[n].SetColor("_LightColor", wheelColour);
					break;
				}
			}
			component = GetKartGeometry().Wheel_Rear.GetComponent<MeshRenderer>();
			for (int num = 0; num < component.materials.Length; num++)
			{
				if (component.materials[num].HasProperty("_LightColor"))
				{
					component.materials[num].SetColor("_LightColor", wheelColour);
					break;
				}
			}
		}
		if ((bool)GetKartGeometry().KartFrame)
		{
			UnityEngine.Color startKartFrameColour = GetKartGeometry().StartKartFrameColour;
			startKartFrameColour.r -= m_currentShadowTintColour / 255f;
			startKartFrameColour.g -= m_currentShadowTintColour / 255f;
			startKartFrameColour.b -= m_currentShadowTintColour / 255f;
			if (startKartFrameColour.r < 0f)
			{
				startKartFrameColour.r = 0f;
			}
			if (startKartFrameColour.g < 0f)
			{
				startKartFrameColour.g = 0f;
			}
			if (startKartFrameColour.b < 0f)
			{
				startKartFrameColour.b = 0f;
			}
			for (int num2 = 0; num2 < GetKartGeometry().KartFrame.materials.Length; num2++)
			{
				if (GetKartGeometry().KartFrame.materials[num2].HasProperty("_LightColor"))
				{
					GetKartGeometry().KartFrame.materials[num2].SetColor("_LightColor", startKartFrameColour);
					break;
				}
			}
		}
		if ((bool)GetKartGeometry().KartDashboard)
		{
			UnityEngine.Color startDashboardColour = GetKartGeometry().StartDashboardColour;
			startDashboardColour.r -= m_currentShadowTintColour / 255f;
			startDashboardColour.g -= m_currentShadowTintColour / 255f;
			startDashboardColour.b -= m_currentShadowTintColour / 255f;
			if (startDashboardColour.r < 0f)
			{
				startDashboardColour.r = 0f;
			}
			if (startDashboardColour.g < 0f)
			{
				startDashboardColour.g = 0f;
			}
			if (startDashboardColour.b < 0f)
			{
				startDashboardColour.b = 0f;
			}
			for (int num3 = 0; num3 < GetKartGeometry().KartDashboard.materials.Length; num3++)
			{
				if (GetKartGeometry().KartDashboard.materials[num3].HasProperty("_Color"))
				{
					GetKartGeometry().KartDashboard.materials[num3].SetColor("_Color", startDashboardColour);
					break;
				}
			}
		}
		if ((bool)GetKartGeometry().FrontFariing)
		{
			UnityEngine.Color startKartFairingColour = GetKartGeometry().StartKartFairingColour;
			startKartFairingColour.r -= m_currentShadowTintColour / 255f;
			startKartFairingColour.g -= m_currentShadowTintColour / 255f;
			startKartFairingColour.b -= m_currentShadowTintColour / 255f;
			if (startKartFairingColour.r < 0f)
			{
				startKartFairingColour.r = 0f;
			}
			if (startKartFairingColour.g < 0f)
			{
				startKartFairingColour.g = 0f;
			}
			if (startKartFairingColour.b < 0f)
			{
				startKartFairingColour.b = 0f;
			}
			for (int num4 = 0; num4 < GetKartGeometry().FrontFariing.materials.Length; num4++)
			{
				if (GetKartGeometry().FrontFariing.materials[num4].HasProperty("_LightColor"))
				{
					GetKartGeometry().FrontFariing.materials[num4].SetColor("_LightColor", startKartFairingColour);
					break;
				}
			}
		}
		for (int num5 = 0; num5 < m_propRendereres.Count; num5++)
		{
			UnityEngine.Color value = m_propStartColour[num5];
			value.r -= m_currentShadowTintColour / 255f;
			value.g -= m_currentShadowTintColour / 255f;
			value.b -= m_currentShadowTintColour / 255f;
			if (value.r < 0f)
			{
				value.r = 0f;
			}
			if (value.g < 0f)
			{
				value.g = 0f;
			}
			if (value.b < 0f)
			{
				value.b = 0f;
			}
			if (m_propRendereres[num5].material.HasProperty("_Color"))
			{
				m_propRendereres[num5].material.SetColor("_Color", value);
			}
		}
	}

	public void EnableRendering(bool enable, bool force = false)
	{
		if (!force)
		{
			if (m_playerFinishState == PlayerFinishedState.InResults)
			{
				enable = true;
			}
			if ((enable && TurnOffKartOnTrackFinish) || ((bool)Gameplay.Instance && !Gameplay.Instance.RaceStarted()))
			{
				return;
			}
		}
		if (GetKartGeometry().ParentRenderingObject.activeSelf != enable)
		{
			GetKartGeometry().ParentRenderingObject.SetActive(enable);
			if ((bool)GetKartGeometry().RacerRenderer)
			{
				GetKartGeometry().RacerRenderer.enabled = enable;
			}
		}
	}

	public bool InHeadlightZone(bool entered, Vector3 zonePos, bool lightHeadlights)
	{
		if (entered)
		{
			m_enableLights = lightHeadlights;
			m_inHeadlightZone = true;
			m_headlightZonePos = zonePos;
		}
		else if (zonePos == m_headlightZonePos)
		{
			m_inHeadlightZone = false;
		}
		return m_inHeadlightZone;
	}

	public void SetupKartGeometry()
	{
		bool flag = true;
		if (GetPlayerType() == PlayerType.Network || GetPlayerType() == PlayerType.FEM || (GetPlayerType() != 0 && (bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && (bool)GetComponent<PhotonView>() && !GetComponent<PhotonView>().isMine))
		{
			if (GetPlayerType() != PlayerType.FEM)
			{
				SetPlayerType(PlayerType.Network);
			}
			m_networkSetup = false;
			if ((bool)NetworkGeometry)
			{
				m_currentGeometry = NetworkGeometry;
				NetworkGeometry.gameObject.SetActive(value: true);
				if ((bool)DefaultGeometry)
				{
					if ((bool)DefaultGeometry.RacerAnimator)
					{
						Animator component = DefaultGeometry.RacerAnimator.GetComponent<Animator>();
						if ((bool)component)
						{
							component.enabled = false;
						}
					}
					DefaultGeometry.gameObject.SetActive(value: false);
				}
				if ((bool)MirrorRoot)
				{
					MirrorRoot.gameObject.SetActive(value: false);
				}
				if ((bool)BackLeft && (bool)FrontLeft && (bool)FrontRight)
				{
					BackLeft.wheelModel = NetworkGeometry.Wheel_Rear;
					FrontLeft.wheelModel = NetworkGeometry.Wheel_Front_Left;
					FrontRight.wheelModel = NetworkGeometry.Wheel_Front_Right;
				}
				flag = false;
				if (GetPlayerType() == PlayerType.Network)
				{
					EnableRendering(enable: false, force: true);
				}
			}
		}
		if (!flag || !DefaultGeometry)
		{
			return;
		}
		m_currentGeometry = DefaultGeometry;
		DefaultGeometry.gameObject.SetActive(value: true);
		if ((bool)NetworkGeometry)
		{
			NetworkGeometry.gameObject.SetActive(value: false);
		}
		if (GetPlayerType() == PlayerType.Human)
		{
			DisableNameBadge();
			if ((bool)MirrorRoot)
			{
				MirrorRoot.gameObject.SetActive(value: true);
			}
		}
		BackLeft.wheelModel = DefaultGeometry.Wheel_Rear;
		FrontLeft.wheelModel = DefaultGeometry.Wheel_Front_Left;
		FrontRight.wheelModel = DefaultGeometry.Wheel_Front_Right;
	}

	public void CorrectOrientation(Vector3 orientation)
	{
		m_correctOrientationNow = true;
		m_correctOrientation = orientation;
	}

	private void Awake()
	{
		m_playerAudioSource = GetComponent<AudioSource>();
		m_playerAnimation = GetComponent<PlayerAnimation>();
		GameSystem.Instance.FrameReferenceManager.RegisterFrameReference(ReferenceCallback);
		NewGridPosition = -1;
		MasterIsHappy = false;
		SetupKartGeometry();
		InGame = true;
		SeatIndex = -1;
		m_offroad = new bool[4];
		m_targetAIObject = new GameObject();
		m_targetAIObject.transform.parent = base.transform;
		if ((bool)GetKartGeometry() && (bool)GetKartGeometry().BubbleShieldObject)
		{
			if (GetKartGeometry().BubbleShieldObject.activeSelf)
			{
				GetKartGeometry().BubbleShieldObject.SetActive(value: false);
			}
			m_shieldColour = GetKartGeometry().BubbleShieldObject.GetComponent<Renderer>().material.GetColor("_TintColor");
		}
		if ((bool)NameObject)
		{
			NameBadge = NameObject.GetComponent<NameBadge>();
		}
		LastWeaponType = WeaponManager.WeaponType.Max;
	}

	public void SetResultsColours(int col1, int col2)
	{
		ResultsCol1 = col1;
		ResultsCol2 = col2;
	}

	private void Start()
	{
		m_shouldCheckForHeadlights = GameSystem.Instance.GetLoadedTrack().EnableHeadlights;
		m_currentRaceOrderFrameIndex = RaceOrderFrameIndex++;
		if (WrongWayObj != null)
		{
			WrongWayObj.SetActive(value: false);
		}
		if (OutOfBoundsObj != null)
		{
			OutOfBoundsObj.SetActive(value: false);
		}
		m_ignitionTimer = 0f;
		m_engineStarted = false;
		m_midLineCrossed = false;
		m_lapTimesStarted = false;
		if ((bool)PlayerManager.Instance)
		{
			m_offroadTimer = PlayerManager.Instance.OffroadTimerFadeOut;
		}
		m_placedOnGrid = false;
		m_targetAIObject.transform.parent = base.transform;
		if ((bool)NameObject && GetPlayerType() == PlayerType.Human)
		{
			NameObject.gameObject.SetActive(value: false);
		}
		if ((bool)HeadlightL && (bool)HeadlightR)
		{
			HeadlightL.SetActive(GameSystem.Instance.GetLoadedTrack().EnableHeadlights);
			HeadlightR.SetActive(GameSystem.Instance.GetLoadedTrack().EnableHeadlights);
		}
		m_weaponEnabled = false;
		m_ignitionTimer = Time.time + UnityEngine.Random.Range(0.5f, 3f);
		m_slipstreamTime = 0f;
		m_slipstreamDurationTimer = 0f;
		if ((bool)Gameplay.Instance)
		{
			m_circuitPath = Gameplay.Instance.GetCircuitPath();
		}
	}

	private void Update()
	{
		if ((bool)FEMManager.Instance && FEMManager.Instance.InHoldingState && GetPlayerType() == PlayerType.Network)
		{
			PhotonView component = GetComponent<PhotonView>();
			object[] instantiationData = component.instantiationData;
			OnlinePlayerIndex = (int)instantiationData[0];
			string text = (string)instantiationData[1];
			SetName(text);
			SeatIndex = (int)instantiationData[9];
			base.gameObject.SetActive(value: false);
			FEMManager.Instance.AddPlayingPlayerInHolding(this);
			return;
		}
		if (!m_gameSeup && (bool)Gameplay.Instance)
		{
			m_gameSeup = true;
			if (LapManager.Instance != null)
			{
				m_lapData = default(LapData);
				m_lapData.lapTime = new double[LapManager.Instance.GetNumLaps()];
				m_lapData.count = 0;
				m_lapData.totalTime = 0.0;
				m_lapData.totalAvgTime = 0.0;
				for (int i = 0; i < LapManager.Instance.GetNumLaps(); i++)
				{
					m_lapData.lapTime[i] = 0.0;
				}
			}
			if (!m_networkSetup && GetPlayerType() == PlayerType.Network)
			{
				if (m_circuitPath == null)
				{
					VRWaypointCircuit vRWaypointCircuit = UnityEngine.Object.FindObjectOfType<VRWaypointCircuit>();
					if ((bool)vRWaypointCircuit)
					{
						SetAITarget(vRWaypointCircuit);
						if ((bool)Gameplay.Instance)
						{
							m_circuitPath = Gameplay.Instance.GetCircuitPath();
						}
					}
				}
				PhotonView component2 = GetComponent<PhotonView>();
				if ((bool)component2)
				{
					object[] instantiationData2 = component2.instantiationData;
					OnlinePlayerIndex = (int)instantiationData2[0];
					string text2 = (string)instantiationData2[1];
					SetName(text2);
					LocalPlayerIndex = PlayerManager.Instance.GetPlayerList().Count;
					PlayerManager.Instance.AddPlayer(this);
					ProfileManager.PlayerData data = ProfileManager.Instance.GetPlayerData(LocalPlayerIndex);
					ProfileManager.Instance.SetPlayerName(LocalPlayerIndex, text2);
					ProfileManager.Instance.SetPlayerData(LocalPlayerIndex, ref data);
					ProfileManager.Instance.UpdateColourIndex(LocalPlayerIndex, 0, (int)instantiationData2[2]);
					ProfileManager.Instance.UpdateColourIndex(LocalPlayerIndex, 1, (int)instantiationData2[3]);
					ProfileManager.Instance.UpdateColourIndex(LocalPlayerIndex, 2, (int)instantiationData2[4]);
					ProfileManager.Instance.UpdateColourIndex(LocalPlayerIndex, 3, (int)instantiationData2[5]);
					ProfileManager.Instance.UpdateColourIndex(LocalPlayerIndex, 4, (int)instantiationData2[6]);
					ProfileManager.Instance.UpdateColourIndex(LocalPlayerIndex, 5, (int)instantiationData2[7]);
					ProfileManager.Instance.UpdateColourIndex(LocalPlayerIndex, 6, (int)instantiationData2[8]);
					SeatIndex = (int)instantiationData2[9];
					NetworkLogin.Instance.GetServer().SetPlayerConnection(OnlinePlayerIndex, SeatIndex);
					data.m_customisationData.m_horn = (string)instantiationData2[10];
					data.m_customisationData.m_helmetProp = (string)instantiationData2[11];
					data.m_customisationData.m_dashProp = (string)instantiationData2[12];
					data.m_customisationData.m_dashStyle = (string)instantiationData2[13];
					data.m_customisationData.m_visorProp = (string)instantiationData2[14];
					OnlineID = (string)instantiationData2[15];
					NewGridPosition = (int)instantiationData2[16];
					Player player = this;
					ProfileManager.Instance.SetColoursOnPlayer(ref player, LocalPlayerIndex);
					ProfileManager.Instance.SetPlayerData(LocalPlayerIndex, ref data);
					player.GetKartGeometry().SetupWheelColour();
					SetResultsColours((int)instantiationData2[2], (int)instantiationData2[3]);
					m_networkSetup = true;
				}
				base.transform.parent = PlayerManager.Instance.gameObject.transform;
			}
			if (PlayerManager.Instance.ExhaustList.Length > 0)
			{
				PlayerManager.Instance.SetExhaust(0, this, LocalPlayerIndex);
			}
			if ((bool)Gameplay.Instance && m_networkSetup)
			{
				SetupCustomisationProps(LocalPlayerIndex);
			}
		}
		UpdateUserHeadRotation();
		UpdateTimeTrialTiming();
		if (!Gameplay.Instance)
		{
			return;
		}
		if (ToxicTimer > 0f)
		{
			ToxicTimer -= GameTime.Instance.DeltaTime();
		}
		UpdateImmobilize();
		CheckForIgnition();
		if (LapManager.Instance != null && Gameplay.Instance.RaceStarted())
		{
			UpdateTiming();
			CheckStartLineCrossing();
			CheckMidLineCrossing();
		}
		UpdateSpeedPickups();
		UpdatePortalStreaks();
		if ((bool)KartExhaust)
		{
			KartExhaust.EnableIdleExhaust(GetComponent<KartController>().CurrentSpeed < 2f);
		}
		if ((bool)Gameplay.Instance)
		{
			if (Gameplay.Instance.RaceStarted() && m_gridTimer > 0f)
			{
				m_gridTimer -= GameTime.Instance.DeltaTime();
			}
			if ((FTUE.Instance == null || FTUE.Instance.State == FTUE.FTUEState.None) && m_placedOnGrid && m_stickToGridCounter < 30 && NewGridPosition >= 0)
			{
				m_stickToGridCounter++;
				base.transform.position = PlayerManager.Instance.GridStartPositions[NewGridPosition].transform.position;
				base.transform.rotation = PlayerManager.Instance.GridStartPositions[NewGridPosition].transform.rotation;
				if (m_stickToGridCounter >= 30 && GetPlayerType() == PlayerType.Network)
				{
					GameSystem.Instance.GetPuffParticles().DoPuff(base.transform.position);
					EnableRendering(enable: true, force: true);
					EnableNameBadge();
				}
			}
		}
		if (!m_placedOnGrid && (GameEntry.Instance == null || (GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game && Gameplay.Instance.GetGameplayState() == Gameplay.GameplayState.None)))
		{
			if (GetPlayerType() == PlayerType.Network && NetworkLogin.Instance.JoinedRoom())
			{
				if (InGame)
				{
					m_placedOnGrid = true;
				}
			}
			else
			{
				m_placedOnGrid = true;
			}
			m_prevPosition = base.transform.position;
			SetDefaultLineIndex();
		}
		if (!m_shouldCheckForHeadlights)
		{
			CheckForHeadlights();
		}
		if (NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom())
		{
			if (GetPlayerType() == PlayerType.Network || GetPlayerType() == PlayerType.FEM)
			{
				NetworkClient.CharacterData data2 = default(NetworkClient.CharacterData);
				NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data2);
				if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(SeatIndex, NetworkClient.EventMask.ReceivedNewData))
				{
					ReceivedNetworkData(ref data2);
					NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(SeatIndex, NetworkClient.EventMask.ReceivedNewData);
				}
				NetworkSteeringAngle = Mathf.Lerp(NetworkSteeringAngle, m_targetSteeringAngle, 6f * GameTime.Instance.DeltaTime());
			}
			else if (GetPlayerType() == PlayerType.Human && CurrentRaceOrder == 0)
			{
				NetworkLogin.Instance.SetCurrentLap(LapManager.Instance.GetNumLaps() - GetCurrentLap());
			}
		}
		if ((bool)OutOfBoundsObj && OutOfBoundsObj.activeSelf != Gameplay.Instance.IsKillEnabled())
		{
			OutOfBoundsObj.SetActive(Gameplay.Instance.IsKillEnabled());
		}
		CheckForGameplayEvents();
		UpdateShieldState();
		if (PlayerFinishState != 0 || Time.frameCount % (RaceOrderFrameIndex + 6) == m_currentRaceOrderFrameIndex)
		{
			UpdateRacePosition();
		}
		if ((GetPlayerType() == PlayerType.Human || GameSystem.Instance.EnableAttractMode) && !GameSystem.Instance.BombHeadMode)
		{
			UpdateWeaponChoice();
		}
	}

	public void SetupCustomisationProps(int profileIndex)
	{
		ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(profileIndex);
		if (playerData.m_customisationData.m_helmetProp != null && playerData.m_customisationData.m_helmetProp.Length > 0)
		{
			CustomisedObject helmetPropByID = CustomisedObjectManager.Instance.GetHelmetPropByID(playerData.m_customisationData.m_helmetProp);
			if ((bool)helmetPropByID)
			{
				Transform locatorByType = GetKartGeometry().GetComponent<AccessoryLocator>().GetLocatorByType(helmetPropByID.CustomiseObject.LocatorID);
				if ((bool)locatorByType && locatorByType.childCount == 0)
				{
					GameObject meshRoot = helmetPropByID.GetMeshRoot();
					GameObject gameObject = UnityEngine.Object.Instantiate(meshRoot);
					if (GetPlayerType() == PlayerType.Human)
					{
						gameObject.layer = 12;
						MeshRenderer[] componentsInChildren = gameObject.GetComponentsInChildren<MeshRenderer>();
						for (int i = 0; i < componentsInChildren.Length; i++)
						{
							componentsInChildren[i].gameObject.layer = 12;
						}
					}
					gameObject.transform.parent = locatorByType;
					gameObject.transform.localPosition = Vector3.zero;
					gameObject.transform.localRotation = Quaternion.identity;
					gameObject.transform.localScale = Vector3.one;
					gameObject.gameObject.SetActive(value: true);
					m_customisationProps.Add(gameObject);
				}
			}
		}
		if (playerData.m_customisationData.m_visorProp != null && playerData.m_customisationData.m_visorProp.Length > 0)
		{
			CustomisedObject visorPropByID = CustomisedObjectManager.Instance.GetVisorPropByID(playerData.m_customisationData.m_visorProp);
			if ((bool)visorPropByID)
			{
				Transform locatorByType2 = GetKartGeometry().GetComponent<AccessoryLocator>().GetLocatorByType(visorPropByID.CustomiseObject.LocatorID);
				if ((bool)locatorByType2 && locatorByType2.childCount == 0)
				{
					GameObject meshRoot2 = visorPropByID.GetMeshRoot();
					GameObject gameObject2 = UnityEngine.Object.Instantiate(meshRoot2);
					if (GetPlayerType() == PlayerType.Human)
					{
						gameObject2.layer = 12;
						MeshRenderer[] componentsInChildren2 = gameObject2.GetComponentsInChildren<MeshRenderer>();
						for (int j = 0; j < componentsInChildren2.Length; j++)
						{
							componentsInChildren2[j].gameObject.layer = 12;
						}
					}
					gameObject2.transform.parent = locatorByType2;
					gameObject2.transform.localPosition = Vector3.zero;
					gameObject2.transform.localRotation = Quaternion.identity;
					gameObject2.transform.localScale = Vector3.one;
					gameObject2.gameObject.SetActive(value: true);
					m_customisationProps.Add(gameObject2);
				}
			}
		}
		if (playerData.m_customisationData.m_dashProp != null && playerData.m_customisationData.m_dashProp.Length > 0)
		{
			CustomisedObject dashboardPropByID = CustomisedObjectManager.Instance.GetDashboardPropByID(playerData.m_customisationData.m_dashProp);
			if ((bool)dashboardPropByID)
			{
				Transform locatorByType3 = GetKartGeometry().GetComponent<AccessoryLocator>().GetLocatorByType(dashboardPropByID.CustomiseObject.LocatorID);
				if ((bool)locatorByType3 && locatorByType3.childCount == 0)
				{
					GameObject meshRoot3 = dashboardPropByID.GetMeshRoot();
					GameObject gameObject3 = UnityEngine.Object.Instantiate(meshRoot3);
					gameObject3.transform.parent = locatorByType3;
					gameObject3.transform.localPosition = Vector3.zero;
					gameObject3.transform.localRotation = Quaternion.identity;
					gameObject3.transform.localScale = Vector3.one;
					gameObject3.gameObject.SetActive(value: true);
					m_customisationProps.Add(gameObject3);
				}
			}
		}
		if (playerData.m_customisationData.m_dashStyle == null || playerData.m_customisationData.m_dashStyle.Length <= 0)
		{
			return;
		}
		CustomisedObject dashboardStyleByID = CustomisedObjectManager.Instance.GetDashboardStyleByID(playerData.m_customisationData.m_dashStyle);
		if ((bool)dashboardStyleByID)
		{
			Transform locatorByType4 = GetKartGeometry().GetComponent<AccessoryLocator>().GetLocatorByType(dashboardStyleByID.CustomiseObject.LocatorID);
			if ((bool)locatorByType4 && locatorByType4.childCount == 0)
			{
				GameObject meshRoot4 = dashboardStyleByID.GetMeshRoot();
				GameObject gameObject4 = UnityEngine.Object.Instantiate(meshRoot4);
				gameObject4.transform.parent = locatorByType4;
				gameObject4.transform.localPosition = Vector3.zero;
				gameObject4.transform.localRotation = Quaternion.identity;
				gameObject4.transform.localScale = Vector3.one;
				gameObject4.gameObject.SetActive(value: true);
				m_customisationProps.Add(gameObject4);
			}
		}
	}

	public void Immobilize(float duration)
	{
		m_originalImmobiliseTime = Time.time;
		ImmobilizeTime = duration;
		EnableWarningLightFeedback(enable: true);
		if (GetPlayerType() == PlayerType.Human)
		{
			ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.Curb);
		}
	}

	public bool IsImmobilized()
	{
		return ImmobilizeTime > 0f;
	}

	private void UpdateImmobilize()
	{
		if (!(ImmobilizeTime > 0f))
		{
			return;
		}
		if (Time.time > m_originalImmobiliseTime + ImmobilizeTime)
		{
			Player player = this;
			ProfileManager.Instance.SetImmobolizeExhaust(ref player, set: false, Gameplay.HitByType.None);
			ImmobilizeTime = 0f;
			EnableWarningLightFeedback(enable: false);
			if ((bool)GetComponent<KartController>())
			{
				GetComponent<KartController>().ResetMaxSpeed();
			}
		}
		else if (m_engineSplutterDelay > 0f)
		{
			m_engineSplutterDelay -= GameTime.Instance.DeltaTime();
		}
		else
		{
			PlayOneShotAudio(PlayerSFXType.EngineSplutter);
			m_engineSplutterDelay = UnityEngine.Random.Range(0.4f, 1.5f);
		}
	}

	private void CheckForHeadlights()
	{
		if ((bool)HeadlightL && HeadlightL.activeSelf != m_inHeadlightZone && (!m_inHeadlightZone || m_enableLights))
		{
			if ((bool)LightSwitchSource && GetPlayerType() == PlayerType.Human)
			{
				LightSwitchSource.Play();
			}
			HeadlightL.SetActive(m_inHeadlightZone);
			HeadlightR.SetActive(m_inHeadlightZone);
		}
	}

	private void UpdateWeaponChoice()
	{
		if (WeaponTypeTimer > 0f)
		{
			WeaponTypeTimer -= 2.5f * GameTime.Instance.DeltaTime();
			if (m_choiceTimer > 0f)
			{
				m_choiceTimer -= GameTime.Instance.DeltaTime();
				return;
			}
			m_choiceTimer += 0.05f;
			int weaponTypeToRender = (int)WeaponTypeToRender;
			weaponTypeToRender = (weaponTypeToRender + 1) % 11;
			WeaponTypeToRender = (WeaponManager.WeaponType)weaponTypeToRender;
		}
		else if (WeaponTypeToRender != WeaponType)
		{
			WeaponTypeToRender = WeaponType;
		}
	}

	private void SetDefaultLineIndex()
	{
		if (!(Gameplay.Instance == null))
		{
			m_currentLineIndex = 0;
		}
	}

	public void UpdateCurrentWayPoint()
	{
		int wayPoint = 0;
		int wayPoint2 = 0;
		Gameplay.Instance.GetCircuitPath().GetClosestPointOnTrack(base.transform.position, ref wayPoint, ref wayPoint2);
		int num;
		if (wayPoint < m_currentLineIndex)
		{
			num = Gameplay.Instance.GetCircuitPath().Waypoints.Length - m_currentLineIndex;
			num += wayPoint;
		}
		else
		{
			num = wayPoint - m_currentLineIndex;
		}
		m_currentLineIndex += num;
		m_currentWayPointIndex += num;
		m_currentLineIndex %= Gameplay.Instance.GetCircuitPath().Waypoints.Length;
	}

	private void CheckForOffroad()
	{
		m_anyOffroad = false;
		for (int i = 0; i < 4; i++)
		{
			if (m_offroad[i])
			{
				m_anyOffroad = true;
				break;
			}
		}
		if (m_anyOffroad)
		{
			if (m_offroadFadeDelay <= 0f)
			{
				m_offroadFadeDelay = PlayerManager.Instance.OffroadFadeDelay;
			}
		}
		else
		{
			m_offroadFadeDelay = 0f;
		}
		if ((!(GameEntry.Instance == null) && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Game) || !Gameplay.Instance.RaceStarted() || Gameplay.Instance.RaceFinished())
		{
			return;
		}
		if (GetPlayerType() == PlayerType.Human && ((!ShouldIgnoreOffroad() && m_anyOffroad) || VibrationOverride()) && (bool)ForceFeedback.Instance)
		{
			if (VibrationOverride())
			{
				ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.DirtTrack);
			}
			else
			{
				ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.Offroad);
			}
		}
		bool flag = m_anyOffroad;
		if (flag && !GetKartGeometry().ParentRenderingObject.activeSelf)
		{
			flag = false;
		}
		flag |= Gameplay.Instance.GoingWrongWay;
		UpdateFadeToReset((!ShouldIgnoreOffroad() && flag) || Gameplay.Instance.IsKillEnabled());
		if ((bool)GetComponent<VRKartaudio>())
		{
			GetComponent<VRKartaudio>().EnableOffroadAudio(m_anyOffroad);
		}
	}

	public void UpdateFadeToReset(bool fadeDown)
	{
		if (GetPlayerType() == PlayerType.AI)
		{
			if (fadeDown)
			{
				if (m_offroadTimer <= 0f)
				{
					m_offroadTimer = PlayerManager.Instance.OffroadTimerFadeOut;
					return;
				}
				m_offroadTimer -= GameTime.Instance.DeltaTime();
				if (m_offroadTimer <= 0f)
				{
					PutKartBackOnTrack();
					GetComponent<KartUserControl>().SuddenStop();
					for (int i = 0; i < 4; i++)
					{
						m_offroad[i] = false;
					}
					m_offroadTimer = PlayerManager.Instance.OffroadTimerFadeOut;
				}
			}
			else if (m_offroadTimer < PlayerManager.Instance.OffroadTimerFadeOut)
			{
				m_offroadTimer = PlayerManager.Instance.OffroadTimerFadeOut;
				for (int j = 0; j < 4; j++)
				{
					m_offroad[j] = false;
				}
			}
			return;
		}
		if (m_offroadFadeDelay > 0f)
		{
			m_offroadFadeDelay -= GameTime.Instance.DeltaTime();
		}
		if (fadeDown)
		{
			if (FadeManager.Instance.GetFadeAlpha() == 1f)
			{
				PutKartBackOnTrack();
				GetComponent<KartUserControl>().SuddenStop();
				for (int k = 0; k < 4; k++)
				{
					m_offroad[k] = false;
				}
				if (NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom())
				{
					NetworkLogin.Instance.GetClient().SetCharacterListEvent(SeatIndex, NetworkClient.EventMask.KartPutOnTrack);
				}
				return;
			}
			float offroadTimerFadeOut = PlayerManager.Instance.OffroadTimerFadeOut;
			if (Gameplay.Instance.RaceFinished())
			{
				offroadTimerFadeOut = PlayerManager.Instance.OffroadTimerRaceFinishFadeOut;
			}
			else if (GetComponent<KartController>().CurrentSpeed < 5f || Gameplay.Instance.GoingWrongWay)
			{
				offroadTimerFadeOut = PlayerManager.Instance.OffroadTimerFadeOutQuick;
			}
			else if (Gameplay.Instance.IsKillEnabled())
			{
				offroadTimerFadeOut = PlayerManager.Instance.OffroadTimerFadeOutOutOfBounds;
			}
			else
			{
				if (m_offroadFadeDelay > 0f)
				{
					return;
				}
				offroadTimerFadeOut = PlayerManager.Instance.OffroadTimerFadeOut;
			}
			FadeManager.Instance.FadeOut(offroadTimerFadeOut);
		}
		else if (FadeManager.Instance.GetFadeAlpha() > 0f)
		{
			FadeManager.Instance.FadeIn(PlayerManager.Instance.OffroadTimerFadeIn);
		}
	}

	public void UpdateShadowPosition(Vector3 collisionPoint, Vector3 normal)
	{
		if ((bool)GetKartGeometry().KartShadow)
		{
			Vector3 position = base.transform.position;
			position += normal * k_shadowNormalOffset;
			GetKartGeometry().KartShadow.transform.position = position;
			GetKartGeometry().KartShadow.transform.rotation = Quaternion.LookRotation(base.transform.forward, normal);
		}
	}

	private void PutKartBackOnTrack()
	{
		float y = 0f;
		Vector3 closestPositionOnTrack = m_closestPositionOnTrack;
		Vector3 direction = m_closestDirectionOnTrack;
		SplitLane lane = null;
		if (InSplitLane(ref lane) && (ShouldIgnoreOffroad() || lane.AlternativeTrackSection))
		{
			closestPositionOnTrack = lane.GetClosestPositionOnTrack(base.transform.position, ref direction);
		}
		Ray ray = new Ray(closestPositionOnTrack + new Vector3(0f, closestPositionOnTrack.y + 6f, 0f), -Vector3.up);
		if (Physics.Raycast(ray, out var hitInfo, 1000f, LayerMask.GetMask("RaceScenery", "ShowInWingMirrors")))
		{
			y = hitInfo.point.y;
		}
		if (GetPlayerType() != 0)
		{
			GameSystem.Instance.GetPuffParticles().DoPuff(base.transform.position);
		}
		base.transform.position = new Vector3(closestPositionOnTrack.x, y, closestPositionOnTrack.z);
		Vector3 vector = closestPositionOnTrack + new Vector3(direction.x, 0f, direction.z);
		base.transform.LookAt(new Vector3(vector.x, 0f, vector.z));
		if (GetPlayerType() != 0)
		{
			GameSystem.Instance.GetPuffParticles().DoPuff(base.transform.position);
			if (GetPlayerType() == PlayerType.AI)
			{
				GetComponent<VRCarAIControl>().ResetReverse();
			}
		}
		Gameplay.Instance.ResetWrongWay();
		Gameplay.Instance.SetKillEnabled(enabled: false);
		InputRemapper.Instance.ResetWaitForAccelerate();
		if ((bool)SafetyCushion)
		{
			SafetyCushion.ResetCushion();
		}
		UpdateCurrentWayPoint();
	}

	private void ReceivedNetworkData(ref NetworkClient.CharacterData data)
	{
		if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(SeatIndex, NetworkClient.EventMask.LeftRoom))
		{
			NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(SeatIndex, NetworkClient.EventMask.LeftRoom);
			GameSystem.Instance.GetPuffParticles().DoPuff(base.transform.position);
		}
		else if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(SeatIndex, NetworkClient.EventMask.KartPutOnTrack))
		{
			NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(SeatIndex, NetworkClient.EventMask.KartPutOnTrack);
			PutKartBackOnTrack();
		}
		else if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(SeatIndex, NetworkClient.EventMask.FinishedWithBees))
		{
			FinishedWithBees = true;
		}
		else if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(SeatIndex, NetworkClient.EventMask.NoExhaust))
		{
			KartExhaust.EnableBadSmoke(enable: false, Gameplay.HitByType.None);
		}
		else if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(SeatIndex, NetworkClient.EventMask.BlackExhaust))
		{
			KartExhaust.EnableBadSmoke(enable: true, Gameplay.HitByType.NormalWeapon);
		}
		else if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(SeatIndex, NetworkClient.EventMask.ToxicExhaust))
		{
			KartExhaust.EnableBadSmoke(enable: true, Gameplay.HitByType.Toxic);
		}
		m_targetSteeringAngle = data.steerAngle;
		LapData lapDataEntry = LapDataEntry;
		lapDataEntry.totalTime = data.finalTime;
		lapDataEntry.totalAvgTime = data.avgTime;
		LapDataEntry = lapDataEntry;
	}

	private void CheckForSlipStream()
	{
		bool flag = false;
		List<Player> playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < playerList.Count; i++)
		{
			Player player = playerList[i];
			if (player == this || player == null || !((player.transform.position - base.transform.position).sqrMagnitude < PlayerManager.Instance.SlipstreamDistance * PlayerManager.Instance.SlipstreamDistance))
			{
				continue;
			}
			Vector3 vector = base.transform.position - player.transform.position;
			vector.Normalize();
			if (Vector3.Dot(base.transform.forward, vector) < 0f)
			{
				float num = Vector3.Angle(base.transform.forward, vector);
				if (num > PlayerManager.Instance.SlipstreamAngleMin && num < PlayerManager.Instance.SlipstreamAngleMax)
				{
					m_slipstreamTime += GameTime.Instance.DeltaTime();
					flag = true;
				}
			}
		}
		if (!flag)
		{
			m_slipstreamTime = 0f;
		}
		else if (m_slipstreamTime > PlayerManager.Instance.SlipstreamTime)
		{
			m_slipstreamDurationTimer = Time.time + PlayerManager.Instance.SlipstreamDuration;
		}
		if (Time.time < m_slipstreamDurationTimer && !flag)
		{
			GetComponent<KartController>().SlipStreamEnable(enable: true);
		}
		else
		{
			GetComponent<KartController>().SlipStreamEnable(enable: false);
		}
	}

	private void CheckForGameplayEvents()
	{
		if ((bool)NetworkLogin.Instance && (bool)Gameplay.Instance && Gameplay.Instance.RaceStarted())
		{
			if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.FireMissile))
			{
				NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
				NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data);
				Gameplay.Instance.FireWeapon(this, PlayerManager.Instance.FindPlayerBySeatIndex(data.targetIndex), WeaponManager.WeaponType.Missile);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.FireMine))
			{
				Gameplay.Instance.FireWeapon(this, null, WeaponManager.WeaponType.Mine);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.FireStinger))
			{
				Gameplay.Instance.FireWeapon(this, null, WeaponManager.WeaponType.Stinger);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.Toxic))
			{
				Gameplay.Instance.FireWeapon(this, null, WeaponManager.WeaponType.Toxic);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.Shield))
			{
				Gameplay.Instance.FireWeapon(this, null, WeaponManager.WeaponType.Shield);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.RadiusBomb))
			{
				Gameplay.Instance.FireWeapon(this, null, WeaponManager.WeaponType.RadiusBomb);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.FireReverse))
			{
				NetworkClient.CharacterData data2 = default(NetworkClient.CharacterData);
				NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data2);
				Gameplay.Instance.FireWeapon(this, PlayerManager.Instance.FindPlayerBySeatIndex(data2.targetIndex), WeaponManager.WeaponType.Reverse);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.Bombhead))
			{
				NetworkClient.CharacterData data3 = default(NetworkClient.CharacterData);
				NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data3);
				Gameplay.Instance.FireWeapon(this, PlayerManager.Instance.FindPlayerBySeatIndex(data3.targetIndex), WeaponManager.WeaponType.Bombhead);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.Portal))
			{
				Gameplay.Instance.FireWeapon(this, null, WeaponManager.WeaponType.Portal);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.Bees))
			{
				NetworkClient.CharacterData data4 = default(NetworkClient.CharacterData);
				NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data4);
				Gameplay.Instance.FireWeapon(this, PlayerManager.Instance.FindPlayerBySeatIndex(data4.targetIndex), WeaponManager.WeaponType.Bees);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.Horn))
			{
				Gameplay.Instance.Horn(this);
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.ResultsShown))
			{
				ResultsManager.Instance.ResultsShown();
			}
			else if (NetworkLogin.Instance.GetClient().IsGameplayEventActive(SeatIndex, NetworkClient.GameplayEvent.ShowingResults) && PlayerFinishState == PlayerFinishedState.None)
			{
				Gameplay.Instance.AssignAICircuit(this);
				PlayerFinishState = PlayerFinishedState.ReadyForResults;
			}
		}
	}

	private void SetShieldState(ShieldState state)
	{
		m_shieldTimer = 0f;
		if (state == ShieldState.Enabled)
		{
			if (m_shieldState == ShieldState.BecomingDisabled)
			{
				m_shieldState = ShieldState.Enabled;
				return;
			}
			if (m_shieldState == ShieldState.None)
			{
				m_shieldState = ShieldState.BecomingEnabled;
				return;
			}
		}
		m_shieldState = state;
		GetKartGeometry().BubbleShieldObject.GetComponent<Renderer>().material.SetColor("_TintColor", m_shieldColour);
	}

	private void UpdateShieldState()
	{
		float num = m_shieldTimer % 0.1f;
		switch (m_shieldState)
		{
		case ShieldState.BecomingEnabled:
		{
			m_shieldTimer += GameTime.Instance.DeltaTime();
			float num3 = m_shieldTimer % 0.1f;
			if (num3 < num)
			{
				m_targetAlpha = ((m_targetAlpha != m_shieldColour.a) ? m_shieldColour.a : 0.2f);
			}
			if (!GetKartGeometry().BubbleShieldObject.activeSelf)
			{
				GetKartGeometry().BubbleShieldObject.SetActive(value: true);
				m_currentAlpha = 0f;
				if (GetPlayerType() == PlayerType.Human)
				{
					CameraManager.Instance.EnableLowPassFilter(enable: true);
				}
			}
			if (m_shieldTimer > 0.5f)
			{
				SetShieldState(ShieldState.Enabled);
			}
			break;
		}
		case ShieldState.Enabled:
			m_targetAlpha = m_shieldColour.a;
			break;
		case ShieldState.Hit:
			GetKartGeometry().BubbleShieldObject.GetComponent<Renderer>().material.SetColor("_TintColor", m_shieldColour * 2f);
			m_shieldTimer += GameTime.Instance.DeltaTime();
			if (m_shieldTimer > 0.15f)
			{
				GetKartGeometry().BubbleShieldObject.GetComponent<Renderer>().material.SetColor("_TintColor", m_shieldColour);
				if (WeaponManager.Instance.ShieldActiveForOneHit)
				{
					SetShieldEnabled(enabled: false);
				}
				else
				{
					SetShieldState(ShieldState.Enabled);
				}
			}
			break;
		case ShieldState.BecomingDisabled:
		{
			m_shieldTimer += GameTime.Instance.DeltaTime();
			float num2 = m_shieldTimer % 0.1f;
			if (num2 < num)
			{
				m_targetAlpha = ((m_targetAlpha != m_shieldColour.a) ? m_shieldColour.a : 0.2f);
			}
			if (m_shieldTimer > 0.5f)
			{
				m_currentAlpha = 0f;
				GetKartGeometry().BubbleShieldObject.SetActive(value: false);
				SetShieldState(ShieldState.None);
				if (GetPlayerType() == PlayerType.Human)
				{
					CameraManager.Instance.EnableLowPassFilter(enable: false);
				}
			}
			break;
		}
		}
		if ((bool)GetKartGeometry().BubbleShieldObject)
		{
			m_currentAlpha = Mathf.Lerp(m_currentAlpha, m_targetAlpha, 10f * GameTime.Instance.DeltaTime());
			UnityEngine.Color color = GetKartGeometry().BubbleShieldObject.GetComponent<Renderer>().material.GetColor("_TintColor");
			color.a = m_currentAlpha;
			GetKartGeometry().BubbleShieldObject.GetComponent<Renderer>().material.SetColor("_TintColor", color);
		}
	}

	private void CheckForIgnition()
	{
		if ((!GameEntry.Instance || GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Frontend) && !m_engineStarted && m_ignitionTimer < Time.time && GetKartGeometry().ParentRenderingObject.activeSelf)
		{
			m_engineStarted = true;
			if ((bool)KartExhaust)
			{
				KartExhaust.StartExhaust();
			}
			if ((bool)GetComponent<VRKartaudio>())
			{
				GetComponent<VRKartaudio>().StartEngineAudio();
			}
		}
	}

	private void LateUpdate()
	{
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0 && NewGridPosition != -1 && (!Gameplay.Instance.ProceedWithGridLights() || FTUE.Instance.State == FTUE.FTUEState.Practice3))
		{
			GetComponent<KartController>().Move(0f, 0f, 0f, 0f);
			GetComponent<Rigidbody>().velocity = Vector3.zero;
			base.transform.rotation = PlayerManager.Instance.GridStartPositions[NewGridPosition].transform.rotation;
		}
		m_prevPosition = base.transform.position;
		CheckForOrientationCorrection();
	}

	private void FixedUpdate()
	{
		if (GetPlayerType() == PlayerType.Network && NetworkLogin.Instance.GetClient().GetCharacterListEvent(GetComponent<Player>().SeatIndex, NetworkClient.EventMask.Drifting))
		{
			NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
			NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data);
			base.transform.position = Vector3.Lerp(base.transform.position, data.currentPosition, 2f * GameTime.Instance.DeltaTime());
		}
	}

	private void CheckForOrientationCorrection()
	{
		if (m_correctOrientationNow)
		{
			base.transform.forward = Vector3.Lerp(base.transform.forward, m_correctOrientation, 12f * GameTime.Instance.DeltaTime());
			if ((base.transform.forward - m_correctOrientation).sqrMagnitude < 0.05f)
			{
				m_correctOrientationNow = false;
			}
		}
	}

	private void UpdateUserHeadRotation()
	{
		if (GetKartGeometry().ParentRenderingObject.activeSelf)
		{
			UpdatePlayerReactions();
		}
		if (GetPlayerType() != PlayerType.AI && GetPlayerType() != PlayerType.Network_Debug)
		{
			if (GetPlayerType() == PlayerType.Network || GetPlayerType() == PlayerType.FEM)
			{
				if ((bool)NetworkLogin.Instance)
				{
					NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
					NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data);
					Vector3 vector = data.rotation * Vector3.forward;
					vector.Normalize();
					float value = Vector3.Dot(base.transform.forward, vector);
					value = Mathf.Clamp(value, -1f, 1f);
					value = Mathf.Acos(value);
					Vector3 rhs = Vector3.Cross(Vector3.up, base.transform.forward);
					float num = Mathf.Sign(Vector3.Dot(vector, rhs));
					value *= num;
					float value2 = Vector3.Dot(base.transform.up, vector);
					value2 = Mathf.Clamp(value2, -1f, 1f);
					value2 = Mathf.Acos(value2);
					SetHeadRotation(value * 57.29578f, value2 * 57.29578f);
				}
				UpdateHeadRotation();
			}
			else if (GetPlayerType() == PlayerType.Human)
			{
				Vector3 localEulerAngles = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.localEulerAngles;
				if (localEulerAngles.y < 180f && localEulerAngles.y > PlayerHeadAngle.y)
				{
					localEulerAngles.y = PlayerHeadAngle.y;
				}
				if (localEulerAngles.y > 180f && localEulerAngles.y < 360f - PlayerHeadAngle.y)
				{
					localEulerAngles.y = 360f - PlayerHeadAngle.y;
				}
				if (localEulerAngles.x < 180f && localEulerAngles.x > PlayerHeadAngle.x)
				{
					localEulerAngles.x = PlayerHeadAngle.x;
				}
				if (localEulerAngles.x > 180f && localEulerAngles.x < 360f - PlayerHeadAngle.x)
				{
					localEulerAngles.x = 360f - PlayerHeadAngle.x;
				}
				if (localEulerAngles.z < 180f && localEulerAngles.z > PlayerHeadAngle.z)
				{
					localEulerAngles.z = PlayerHeadAngle.z;
				}
				if (localEulerAngles.z > 180f && localEulerAngles.z < 360f - PlayerHeadAngle.z)
				{
					localEulerAngles.z = 360f - PlayerHeadAngle.z;
				}
				GetKartGeometry().Helmet.transform.localEulerAngles = localEulerAngles;
			}
		}
		if (GetPlayerType() == PlayerType.Human || GetPlayerType() == PlayerType.AI)
		{
			if ((GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game) && Gameplay.Instance != null && Gameplay.Instance.RaceStarted() && !QuitMenu.Instance.InProgress() && !GameSystem.Instance.BombHeadMode && (bool)FTUE.Instance && (FTUE.Instance.State == FTUE.FTUEState.None || !FTUE.Instance.WaitingToStart()))
			{
				CheckForOffroad();
			}
			if (GameEntry.Instance == null)
			{
				CheckForOffroad();
			}
		}
	}

	private void UpdatePlayerReactions()
	{
		if (!Gameplay.Instance)
		{
			return;
		}
		if (GetPlayerType() == PlayerType.AI && Time.time > m_lookaroundTimer)
		{
			SetHeadRotation(UnityEngine.Random.Range(0f - PlayerManager.MaxHeadAngle, PlayerManager.MaxHeadAngle), 90f);
			m_lookaroundTimer = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(0.5f, 4f);
		}
		if (Gameplay.Instance.RaceFinished())
		{
			UpdateResultsReactions();
		}
		else if (Gameplay.Instance.RaceStarted())
		{
			if (GetPlayerType() == PlayerType.AI)
			{
				UpdateInRaceReactions();
			}
		}
		else if (GetPlayerType() == PlayerType.Human || !FTUE.Instance || FTUE.Instance.State == FTUE.FTUEState.None)
		{
			UpdatePreRaceReactions();
		}
	}

	private PlayerAnimation.Direction GetDirection()
	{
		if (m_overtakenPlayer == null)
		{
			PlayerManager.Instance.GetHumanPlayer(ref m_overtakenPlayer);
		}
		PlayerAnimation.Direction result = PlayerAnimation.Direction.Right;
		Vector3 normalized = (m_overtakenPlayer.transform.position - base.transform.position).normalized;
		Vector3 lhs = Vector3.Cross(normalized, Vector3.up);
		if (Vector3.Dot(lhs, base.transform.forward) < 0f)
		{
			result = PlayerAnimation.Direction.Left;
		}
		return result;
	}

	private PlayerAnimation.Direction GetRandomDirection()
	{
		return (!(UnityEngine.Random.Range(0f, 1f) < 0.5f)) ? PlayerAnimation.Direction.Right : PlayerAnimation.Direction.Left;
	}

	private void UpdateResultsReactions()
	{
		if (!m_playerAnimation.AllowedToPlayAnim())
		{
			return;
		}
		if (GetPlayerType() == PlayerType.Human)
		{
			m_playerAnimation.PlayFingerFlex(GetRandomDirection());
			return;
		}
		float num = UnityEngine.Random.Range(0f, 1f);
		if (CurrentRaceOrder < 2)
		{
			if (num < 0.25f)
			{
				m_playerAnimation.PlayCelebrate();
			}
			else if (num < 0.5f)
			{
				m_playerAnimation.PlayFistPump(GetRandomDirection());
			}
			else if (num < 0.8f)
			{
				m_playerAnimation.PlayWave(GetRandomDirection());
			}
			else
			{
				m_playerAnimation.PlayFingerFlex(GetRandomDirection());
			}
		}
		else if (CurrentRaceOrder < 4)
		{
			if (num < 0.25f)
			{
				m_playerAnimation.PlayFistPump(GetRandomDirection());
			}
			if (num < 0.5f)
			{
				m_playerAnimation.PlayFingerFlex(GetRandomDirection());
			}
			else if (num < 0.75f)
			{
				m_playerAnimation.PlayLookAroundGrid(GetRandomDirection());
			}
			else if (num < 0.85f)
			{
				m_playerAnimation.PlayHeadShake();
			}
			else
			{
				m_playerAnimation.PlayWave(GetRandomDirection());
			}
		}
		else if (CurrentRaceOrder > 4)
		{
			if (num < 0.3f)
			{
				m_playerAnimation.PlayHeadShake();
			}
			else if (num < 0.5f)
			{
				m_playerAnimation.PlayBashWheel(GetRandomDirection());
			}
			else if (num < 0.75f)
			{
				m_playerAnimation.PlayShakeFist(GetRandomDirection());
			}
			else
			{
				m_playerAnimation.PlayDrumFingers();
			}
		}
	}

	private void UpdateInRaceReactions()
	{
		if (CurrentRaceOrder < PrevRaceOrder)
		{
			if (m_playerAnimation.AllowedToPlayAnim())
			{
				m_overtakenPlayer = PlayerManager.Instance.GetPlayerInPosition(PrevRaceOrder);
				float num = UnityEngine.Random.Range(0f, 1f);
				if (num < 0.25f)
				{
					m_playerAnimation.PlayHonkHorn(GetDirection());
				}
				else if (num < 0.5f)
				{
					m_playerAnimation.PlayLookAroundRace(GetDirection());
				}
				else if (num < 0.75f)
				{
					m_playerAnimation.PlayLookAroundGrid(GetDirection());
				}
				else
				{
					m_playerAnimation.PlayTauntWave(GetDirection());
				}
			}
		}
		else if (CurrentRaceOrder > PrevRaceOrder && m_playerAnimation.AllowedToPlayAnim())
		{
			m_overtakenPlayer = PlayerManager.Instance.GetPlayerInPosition(PrevRaceOrder);
			float num2 = UnityEngine.Random.Range(0f, 1f);
			if (num2 < 0.33f)
			{
				m_playerAnimation.PlayShakeFist(GetDirection());
			}
			else if (num2 < 0.66f)
			{
				m_playerAnimation.PlayBashWheel(GetDirection());
			}
			else
			{
				m_playerAnimation.PlayHeadShake();
			}
		}
	}

	private void UpdatePreRaceReactions()
	{
		if (!m_playerAnimation.AllowedToPlayAnim())
		{
			return;
		}
		if (GetPlayerType() == PlayerType.Human)
		{
			m_playerAnimation.PlayFingerFlex(GetRandomDirection());
			return;
		}
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num < 0.15f)
		{
			m_playerAnimation.PlayLookAroundGrid(GetRandomDirection());
		}
		else if (num < 0.3f)
		{
			m_playerAnimation.PlayHonkHorn(GetRandomDirection());
		}
		else if (num < 0.5f)
		{
			m_playerAnimation.PlayFistPump(GetRandomDirection());
		}
		else if (num < 0.75f)
		{
			m_playerAnimation.PlayWave(GetRandomDirection());
		}
		else if (num < 0.9f)
		{
			m_playerAnimation.PlayDrumFingers();
		}
		else
		{
			m_playerAnimation.PlayFingerFlex(GetRandomDirection());
		}
	}

	private void UpdateHitByWeaponReaction()
	{
		if (m_playerAnimation.AllowedToPlayAnim() && GetPlayerType() != 0)
		{
			float num = UnityEngine.Random.Range(0f, 1f);
			if (num < 0.33f)
			{
				m_playerAnimation.PlayShakeFist(GetDirection());
			}
			else if (num < 0.66f)
			{
				m_playerAnimation.PlayBashWheel(GetDirection());
			}
			else
			{
				m_playerAnimation.PlayHeadShake();
			}
		}
	}

	private void UpdateTimeTrialTiming()
	{
		if (!GameSystem.Instance.EnableTimeTrialMode)
		{
			return;
		}
		if (m_timeTrialTimer > 0f && PlayerFinishState == PlayerFinishedState.InResults)
		{
			m_timeTrialTimer = 0f;
		}
		if (!(m_timeTrialTimer >= 0f))
		{
			return;
		}
		m_timeTrialTimer -= GameTime.Instance.DeltaTime();
		if (m_timeTrialTimer < 0f)
		{
			if ((bool)TimeTrialText && TimeTrialText.gameObject.activeSelf)
			{
				TimeTrialText.gameObject.SetActive(value: false);
			}
			return;
		}
		if ((bool)TimeTrialText && !TimeTrialText.gameObject.activeSelf)
		{
			TimeTrialText.gameObject.SetActive(value: true);
		}
		int mins = 0;
		int secs = 0;
		int tenths = 0;
		GameTime.Instance.ConvertTime(m_lapData.lapTime[m_lapData.count - 1], ref mins, ref secs, ref tenths);
		TimeTrialText.text = mins.ToString("00") + ":" + secs.ToString("00") + ":" + tenths.ToString("00");
	}

	private void UpdateHeadRotation()
	{
		if ((bool)GetKartGeometry().Helmet)
		{
			Quaternion quaternion = Quaternion.AngleAxis(targetHelmetY, Vector3.up);
			Quaternion quaternion2 = Quaternion.AngleAxis(targetHelmetX, Vector3.right);
			Quaternion quaternion3 = Quaternion.LookRotation(base.transform.forward);
			quaternion3 = quaternion3 * quaternion * quaternion2;
			GetKartGeometry().Helmet.transform.rotation = Quaternion.Slerp(GetKartGeometry().Helmet.transform.rotation, quaternion3, 4f * GameTime.Instance.DeltaTime());
		}
	}

	public void SetHeadRotation(float angleY, float angleX)
	{
		angleX -= 90f;
		if (angleY < 0f - PlayerManager.MaxHeadAngle)
		{
			angleY = 0f - PlayerManager.MaxHeadAngle;
		}
		else if (angleY > PlayerManager.MaxHeadAngle)
		{
			angleY = PlayerManager.MaxHeadAngle;
		}
		if (angleX < 0f - PlayerManager.MaxHeadAngleX)
		{
			angleX = 0f - PlayerManager.MaxHeadAngleX;
		}
		else if (angleX > PlayerManager.MaxHeadAngleX)
		{
			angleX = PlayerManager.MaxHeadAngleX;
		}
		targetHelmetX = angleX;
		targetHelmetY = angleY;
	}

	private void UpdateRacePosition()
	{
		if (!m_circuitPath)
		{
			return;
		}
		int num = (m_currentLineIndex + 1) % m_circuitPath.Waypoints.Length;
		Vector3 to = base.transform.position - m_circuitPath.Waypoints[num].position;
		if (Vector3.Angle(m_circuitPath.Waypoints[num].forward, to) < 90f)
		{
			m_currentLineIndex = (m_currentLineIndex + 1) % m_circuitPath.Waypoints.Length;
			m_currentWayPointIndex++;
		}
		to = base.transform.position - m_circuitPath.Waypoints[m_currentLineIndex].position;
		if (Vector3.Angle(m_circuitPath.Waypoints[m_currentLineIndex].forward, to) > 90f)
		{
			m_currentLineIndex--;
			if (m_currentLineIndex < 0)
			{
				m_currentLineIndex = m_circuitPath.Waypoints.Length - 1;
			}
			m_currentWayPointIndex--;
		}
		int num2 = (m_currentLineIndex + 1) % m_circuitPath.Waypoints.Length;
		m_closestPositionOnTrack = m_circuitPath.GetClosestPointOnLineSegment(m_circuitPath.Waypoints[m_currentLineIndex].position, m_circuitPath.Waypoints[num2].position, base.transform.position, ref m_localPointOnTrack);
		m_closestDirectionOnTrack = m_circuitPath.Waypoints[num2].position - m_circuitPath.Waypoints[m_currentLineIndex].position;
		m_closestDirectionOnTrack.Normalize();
		m_previousPointOnTrack = m_pointOnTrack;
		m_previousPointOnTrackSingle = m_singleLapPointOnTrack;
		m_singleLapPointOnTrack = m_localPointOnTrack;
		m_singleLapPointOnTrack += m_currentWayPointIndex % m_circuitPath.Waypoints.Length;
		m_localPointOnTrack += m_currentWayPointIndex;
		if (GetPlayerType() != PlayerType.Network)
		{
			m_pointOnTrack = m_localPointOnTrack;
			return;
		}
		NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
		NetworkLogin.Instance.GetClient().GetCharacterListByIndex(SeatIndex, ref data);
		m_pointOnTrack = data.pointOnTrack;
	}

	private void UpdateTiming()
	{
		if (PlayerFinishState == PlayerFinishedState.None && m_lapData.count < LapManager.Instance.GetNumLaps() && GetPlayerType() != PlayerType.Network)
		{
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				m_lapData.totalTime = GameTime.Instance.GetTimeDifferenceInTicks(GameTime.Instance.GetServerTimeInTicks(), Gameplay.Instance.StartTimeOfRace);
			}
			else
			{
				m_lapData.totalTime = GameTime.Instance.GetTimeDifferenceInTicks(GameTime.Instance.GetTimeInTicks(), Gameplay.Instance.StartTimeOfRace);
			}
			m_lapData.totalAvgTime = m_lapData.totalTime / (double)LapManager.Instance.GetNumLaps();
		}
	}

	private void CheckMidLineCrossing()
	{
		MidLine getMidLineObject = LapManager.Instance.GetMidLineObject;
		if (!(getMidLineObject == null) && !m_midLineCrossed && PlayerFinishState == PlayerFinishedState.None)
		{
			float num = LapManager.Instance.MidLinePoint + (float)(m_circuitPath.Waypoints.Length * GetCurrentLap());
			if (PointOnTrack() >= num)
			{
				m_midLineCrossed = true;
			}
		}
	}

	private void CheckStartLineCrossing()
	{
		if ((bool)FEMManager.Instance || !Gameplay.Instance.RaceStarted() || (m_lapTimesStarted && !m_midLineCrossed))
		{
			return;
		}
		int num = (m_lapTimesStarted ? (GetCurrentLap() + 1) : 0);
		float num2 = LapManager.Instance.StartLinePoint + (float)(m_circuitPath.Waypoints.Length * num);
		if (GetPlayerType() != 0 && !TurnOffKartOnTrackFinish && m_lapTimesStarted && m_midLineCrossed && num == LapManager.Instance.GetNumLaps() && (m_localPointOnTrack >= num2 || PlayerFinishState != 0) && GetKartGeometry().ParentRenderingObject.activeSelf)
		{
			EnableRendering(enable: false, force: true);
			GameSystem.Instance.GetPuffParticles().DoPuff(base.transform.position);
			NameBadge.gameObject.SetActive(value: false);
			KartExhaust.StopExhaust();
			GetComponent<KartController>().EnableSpeedBoost(enable: false);
			base.transform.position -= Vector3.up * 1000f;
			TurnOffKartOnTrackFinish = true;
		}
		if (PlayerFinishState != 0 || !(PointOnTrack() >= num2))
		{
			return;
		}
		if (!m_lapTimesStarted)
		{
			m_lapTimesStarted = true;
			m_lapData.count = 0;
		}
		else
		{
			if (ReplaySystem.Instance.enabled)
			{
				return;
			}
			double num3 = 0.0;
			num3 = ((!NetworkLogin.Instance || !NetworkLogin.Instance.JoinedRoom()) ? GameTime.Instance.GetTimeDifferenceInTicks(GameTime.Instance.GetTimeInTicks(), Gameplay.Instance.StartTimeOfRace) : GameTime.Instance.GetTimeDifferenceInTicks(GameTime.Instance.GetServerTimeInTicks(), Gameplay.Instance.StartTimeOfRace));
			for (int i = 0; i < m_lapData.count; i++)
			{
				num3 -= m_lapData.lapTime[i];
			}
			if (m_lapData.lapTime != null && m_lapData.count >= 0 && m_lapData.count < m_lapData.lapTime.Length)
			{
				m_lapData.lapTime[m_lapData.count] = num3;
			}
			m_midLineCrossed = false;
			m_lapData.count++;
			if (GetPlayerType() != 0)
			{
				return;
			}
			if ((bool)FTUE.Instance && FTUE.Instance.State != 0 && FTUE.Instance.State < FTUE.FTUEState.Practice4)
			{
				AudioSource component = LapManager.Instance.GetStartLineObject.GetComponent<AudioSource>();
				if (component != null)
				{
					component.Play();
				}
				FTUE.Instance.ReadyToStart();
			}
			else
			{
				if (m_lapData.count == LapManager.Instance.GetNumLaps() - 1)
				{
					PlayAudio(Gameplay.Instance.FinalLapClip);
				}
				m_timeTrialTimer = 4f;
			}
		}
	}

	private void OnDrawGizmos()
	{
		if (!(Gameplay.Instance == null) && !(Gameplay.Instance.GetCircuitPath() == null))
		{
			Vector3 closestPositionOnTrack = m_closestPositionOnTrack;
			Vector3 direction = Vector3.zero;
			SplitLane lane = null;
			if (InSplitLane(ref lane))
			{
				closestPositionOnTrack = lane.GetClosestPositionOnTrack(base.transform.position, ref direction);
			}
			Gizmos.color = new UnityEngine.Color(1f, 0f, 0f, 0.2f);
			Gizmos.DrawSphere(closestPositionOnTrack, 2f);
		}
	}
}
public class PlayerAnimation : UnityEngine.MonoBehaviour
{
	public enum Direction
	{
		Left,
		Right
	}

	[SerializeField]
	private Player CurrentPlayer;

	private float TimeToDefinitelyPlayAnim = 10f;

	private float MinTimeToPlayAnim = 5f;

	private float RandomChanceToPlay = 0.5f;

	private const string DriverLeftAnim = "Driver_Steer_Left";

	private const string DriverRightAnim = "Driver_Steer_Right";

	private const string DriverLeanLeftAnim = "Driver_Lean_L";

	private const string DriverLeanRightAnim = "Driver_Lean_R";

	private const string DriverIdleAnim = "Driver_Breathe";

	private const string DriverLeftLegLayer = "LeftLegLayer";

	private const string DriverRightLegLayer = "RightLegLayer";

	private const string DriverPedalsDownAnim = "Driver_Pedals_Down";

	private const string ShakeFist_L_Trigger = "ShakeFist_L";

	private const string ShakeFist_R_Trigger = "ShakeFist_R";

	private const string Wave_L_Trigger = "Wave_L";

	private const string Wave_R_Trigger = "Wave_R";

	private const string Fingerflex_L_Trigger = "FingerFlex_L";

	private const string Fingerflex_R_Trigger = "FingerFlex_R";

	private const string BashWheel_L_Trigger = "BashWheel_L";

	private const string BashWheel_R_Trigger = "BashWheel_R";

	private const string HonkHorn_L_Trigger = "HonkHorn_L";

	private const string HonkHorn_R_Trigger = "HonkHorn_R";

	private const string LookAround_Grid_L_Trigger = "LookAround_Grid_L";

	private const string LookAround_Grid_R_Trigger = "LookAround_Grid_R";

	private const string LookAround_Race_L_Trigger = "LookAround_Race_L";

	private const string LookAround_Race_R_Trigger = "LookAround_Race_R";

	private const string FistPump_L_Trigger = "FistPump_L";

	private const string FistPump_R_Trigger = "FistPump_R";

	private const string Wave_Taunt_L_Trigger = "WaveTaunt_L";

	private const string Wave_Taunt_R_Trigger = "WaveTaunt_R";

	private const string HeadShake_Trigger = "HeadShake";

	private const string Celebrate_Trigger = "Celebrate";

	private const string DrumFingers_Trigger = "DrumFingers";

	private const float MaxLeanPositionOffset = 0.18f;

	private const float LeanScale = 0.5f;

	private Animator m_animator;

	private float m_currentSteeringAmount;

	private float m_lastTimeAnimPlayed;

	private float m_currentBrakeAmount;

	private float m_currentAccAmount;

	private float m_currentLeanAmount;

	private float m_leanTarget;

	private int m_refCount;

	public bool PlayingAnyAnimation()
	{
		return m_refCount > 0;
	}

	public void SetPlayingAnim()
	{
		m_refCount++;
	}

	public void SetStoppedAnim()
	{
		if (m_refCount > 0)
		{
			m_refCount--;
		}
	}

	public void SetAnimPlayed()
	{
		m_lastTimeAnimPlayed = GameTime.Instance.CurrentTime();
	}

	public bool AllowedToPlayAnim()
	{
		float num = GameTime.Instance.CurrentTime() - m_lastTimeAnimPlayed;
		if (num > TimeToDefinitelyPlayAnim)
		{
			return true;
		}
		if (num > MinTimeToPlayAnim && UnityEngine.Random.Range(0f, 1f) < RandomChanceToPlay)
		{
			return true;
		}
		return false;
	}

	public void PlayHonkHorn(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("HonkHorn_L");
			}
			else
			{
				m_animator.SetTrigger("HonkHorn_R");
			}
		}
	}

	public void PlayLookAroundGrid(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("LookAround_Grid_L");
			}
			else
			{
				m_animator.SetTrigger("LookAround_Grid_R");
			}
		}
	}

	public void PlayLookAroundRace(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("LookAround_Race_L");
			}
			else
			{
				m_animator.SetTrigger("LookAround_Race_R");
			}
		}
	}

	public void PlayFistPump(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("FistPump_L");
			}
			else
			{
				m_animator.SetTrigger("FistPump_R");
			}
		}
	}

	public void PlayDrumFingers()
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			m_animator.SetTrigger("DrumFingers");
		}
	}

	public void PlayShakeFist(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("ShakeFist_L");
			}
			else
			{
				m_animator.SetTrigger("ShakeFist_R");
			}
		}
	}

	public void PlayWave(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("Wave_L");
			}
			else
			{
				m_animator.SetTrigger("Wave_R");
			}
		}
	}

	public void PlayTauntWave(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("WaveTaunt_L");
			}
			else
			{
				m_animator.SetTrigger("WaveTaunt_R");
			}
		}
	}

	public void PlayFingerFlex(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("FingerFlex_L");
			}
			else
			{
				m_animator.SetTrigger("FingerFlex_R");
			}
		}
	}

	public void PlayBashWheel(Direction dir)
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			if (dir == Direction.Left)
			{
				m_animator.SetTrigger("BashWheel_L");
			}
			else
			{
				m_animator.SetTrigger("BashWheel_R");
			}
		}
	}

	public void PlayHeadShake()
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			m_animator.SetTrigger("HeadShake");
		}
	}

	public void PlayCelebrate()
	{
		if ((bool)m_animator && m_animator.enabled && m_animator.isInitialized)
		{
			SetAnimPlayed();
			m_animator.SetTrigger("Celebrate");
		}
	}

	private void Awake()
	{
		m_animator = ((!CurrentPlayer || !CurrentPlayer.GetKartGeometry()) ? null : CurrentPlayer.GetKartGeometry().RacerAnimator);
		m_lastTimeAnimPlayed = GameTime.Instance.CurrentTime() - UnityEngine.Random.Range(8f, 10f);
	}

	private void Update()
	{
		if ((bool)CurrentPlayer && (CurrentPlayer.PlayerFinishState == Player.PlayerFinishedState.InResults || ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() != 0) || ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice3)))
		{
			if ((bool)m_animator && m_animator.enabled)
			{
				m_animator.Play("Driver_Breathe", 0);
			}
			if (CurrentPlayer.GetPlayerType() == Player.PlayerType.Human)
			{
				UpdateLean();
			}
		}
		else if (CurrentPlayer.GetKartGeometry().ParentRenderingObject.gameObject.activeSelf)
		{
			UpdateSteering();
			if (CurrentPlayer.GetPlayerType() == Player.PlayerType.Human)
			{
				UpdateAcceleration();
				UpdateLean();
			}
		}
	}

	private void UpdateSteering()
	{
		float num = 0f;
		KartController component = GetComponent<KartController>();
		if (component.ScaledMaxSteeringAngle == 0f)
		{
			num = 0f;
		}
		else
		{
			float num2 = component.CurrentSteerAngle;
			if (component.ReverseControlsEnabled())
			{
				num2 = 0f - num2;
			}
			num = num2 / component.ScaledMaxSteeringAngle;
			num = Mathf.Clamp(num * component.SteeringScaleFactor, -1f, 1f);
		}
		m_currentSteeringAmount = Mathf.Lerp(m_currentSteeringAmount, num, 8f * GameTime.Instance.DeltaTime());
		if ((bool)m_animator && m_animator.enabled)
		{
			float num3 = m_currentSteeringAmount * 0.75f;
			if (m_currentSteeringAmount > 0.01f)
			{
				m_animator.Play("Driver_Steer_Right", 0, num3);
			}
			else if (m_currentSteeringAmount < -0.01f)
			{
				m_animator.Play("Driver_Steer_Left", 0, Mathf.Abs(num3));
			}
			else
			{
				m_animator.Play("Driver_Breathe", 0);
			}
		}
	}

	private void UpdateLean()
	{
		int layerIndex = m_animator.GetLayerIndex("UpperBody");
		float x = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.localPosition.x;
		m_leanTarget = x / 0.18f;
		m_leanTarget = Mathf.Clamp(m_leanTarget, -1f, 1f);
		m_currentLeanAmount = Mathf.Lerp(m_currentLeanAmount, m_leanTarget, 4f * GameTime.Instance.CurrentTime());
		if ((bool)m_animator && m_animator.enabled)
		{
			float num = m_currentLeanAmount * 0.5f;
			if (num > 0f)
			{
				m_animator.Play("Driver_Lean_R", layerIndex, num);
			}
			else if (num < 0f)
			{
				m_animator.Play("Driver_Lean_L", layerIndex, Mathf.Abs(num));
			}
		}
	}

	private void UpdateAcceleration()
	{
		int layerIndex = m_animator.GetLayerIndex("LeftLegLayer");
		int layerIndex2 = m_animator.GetLayerIndex("RightLegLayer");
		float acceleration = GetComponent<KartUserControl>().GetAcceleration();
		float b = Mathf.Clamp(acceleration, 0f, 1f);
		float b2 = Mathf.Clamp(acceleration, -1f, 0f);
		m_currentBrakeAmount = Mathf.Lerp(m_currentBrakeAmount, b2, 6f * GameTime.Instance.DeltaTime());
		m_currentAccAmount = Mathf.Lerp(m_currentAccAmount, b, 6f * GameTime.Instance.DeltaTime());
		m_animator.Play("Driver_Pedals_Down", layerIndex2, m_currentAccAmount);
		m_animator.Play("Driver_Pedals_Down", layerIndex, Mathf.Abs(m_currentBrakeAmount));
	}
}
public class PlayerAnimationCallback : UnityEngine.MonoBehaviour
{
	private Player m_player;

	private void Start()
	{
		Transform parent = base.transform;
		while (parent != null && parent.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		m_player = parent.GetComponent<Player>();
	}

	public void HonkHorn()
	{
		if ((bool)m_player)
		{
			Gameplay.Instance.Horn(m_player);
		}
	}
}
public class PlayerManager : UnityEngine.MonoBehaviour
{
	public enum GroundParticleType
	{
		Grass = 0,
		Sand = 1,
		Mud = 2,
		Rain = 3,
		Rock = 4,
		Wood = 5,
		Snow = 6,
		None = 20
	}

	public class PositionData : IComparable
	{
		public float position;

		public int index;

		public int CompareTo(object obj)
		{
			PositionData positionData = obj as PositionData;
			return position.CompareTo(positionData.position);
		}
	}

	[SerializeField]
	public GameObject[] ExhaustList;

	public Locator[] GridStartPositions;

	[SerializeField]
	public float SlipstreamDistance = 20f;

	[SerializeField]
	public float SlipstreamAngleMin = 165f;

	[SerializeField]
	public float SlipstreamAngleMax = 195f;

	[SerializeField]
	public float SlipstreamTime = 1f;

	[SerializeField]
	public float SlipstreamSpeedIncrease = 10f;

	[SerializeField]
	public float SlipstreamDuration = 5f;

	[SerializeField]
	private Transform skidTrailPrefab;

	[SerializeField]
	public GroundParticleType OffroadParticleType;

	[NonSerialized]
	public float OffRoadDragFactor = 0.5f;

	[NonSerialized]
	public float OffRoadMaxSpeed = 20f;

	[NonSerialized]
	public float OffroadTimerRaceFinishFadeOut = 3f;

	[NonSerialized]
	public float OffroadTimerFadeOut = 2f;

	[NonSerialized]
	public float OffroadTimerFadeOutQuick = 0.5f;

	[NonSerialized]
	public float OffroadTimerFadeOutOutOfBounds = 0.3f;

	[NonSerialized]
	public float OffroadFadeDelay = 1f;

	[NonSerialized]
	public float OffroadTimerFadeIn = 1f;

	private int m_hornsChosen;

	public static float BreadCrumbDistance = 10f;

	public static float MaxHeadAngle = 45f;

	public static float MaxHeadAngleX = 20f;

	public static PlayerManager Instance;

	private List<Player> m_playerList = new List<Player>();

	private List<Player> m_playerListInOrder = new List<Player>();

	private AIManager m_AIManager;

	private List<PositionData> m_positionDataList = new List<PositionData>();

	private const int MaxSkidsPerWheel = 32;

	private int m_currentSkid;

	private GameObject m_skidRoot;

	private Transform[] m_skidPool = new Transform[32];

	private float m_nameTagDistanceList;

	private int m_nameTagIndexList;

	public bool ConfettiEnabled { get; set; }

	public int MaxPlayers { get; set; }

	public bool GetHumanPlayer(ref Player refPlayer)
	{
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player player = m_playerList[i];
			if (player != null && player.GetPlayerType() == Player.PlayerType.Human)
			{
				refPlayer = player;
				return true;
			}
		}
		return false;
	}

	public AIManager GetAIManager()
	{
		return m_AIManager;
	}

	public void AddPlayer(Player player)
	{
		m_playerList.Add(player);
	}

	public Player AddReplayKart()
	{
		Player player = null;
		VRWaypointCircuit vRWaypointCircuit = UnityEngine.Object.FindObjectOfType<VRWaypointCircuit>();
		if ((bool)vRWaypointCircuit)
		{
			m_AIManager.AI.WayPointCircuit = vRWaypointCircuit;
		}
		player = KartManager.Instance.CreateKart(KartManager.KartType.AIKart, Player.PlayerType.AI, -1, string.Empty, 0, -1, string.Empty, vRWaypointCircuit.GetRoutePoint(0f).position, Quaternion.LookRotation(vRWaypointCircuit.GetRoutePoint(0f).direction));
		player.name = "ReplayKart";
		player.GetComponent<Player>().SetAITarget(vRWaypointCircuit);
		player.transform.parent = base.gameObject.transform;
		player.GetComponent<VRCarAIControl>().SetSpeedMultiplier(1.4f);
		player.GetComponent<KartController>().IsReplayKart = true;
		return player.GetComponent<Player>();
	}

	public void DestroyNonHumanPlayers()
	{
		for (int i = 1; i < m_playerList.Count; i++)
		{
			if ((bool)m_playerList[i] && m_playerList[i].GetPlayerType() != 0)
			{
				UnityEngine.Object.Destroy(m_playerList[i].gameObject);
				m_playerList[i] = null;
			}
		}
	}

	public void DestroyPlayer(ref Player player)
	{
		for (int i = 1; i < m_playerList.Count; i++)
		{
			if (m_playerList[i] == player)
			{
				UnityEngine.Object.Destroy(m_playerList[i].gameObject);
				m_playerList[i] = null;
			}
		}
	}

	public Player FindPlayerByOnlineIndex(int onlineIndex)
	{
		for (int i = 0; i < m_playerList.Count; i++)
		{
			if ((bool)m_playerList[i] && m_playerList[i].OnlinePlayerIndex == onlineIndex)
			{
				return m_playerList[i];
			}
		}
		return null;
	}

	public Player FindPlayerBySeatIndex(int onlineIndex)
	{
		for (int i = 0; i < m_playerList.Count; i++)
		{
			if ((bool)m_playerList[i] && m_playerList[i].SeatIndex == onlineIndex)
			{
				return m_playerList[i];
			}
		}
		return null;
	}

	public Player GetPlayerInPosition(int position)
	{
		for (int i = 0; i < m_playerList.Count; i++)
		{
			if ((bool)m_playerList[i] && m_playerList[i].CurrentRaceOrder == position)
			{
				return m_playerList[i];
			}
		}
		return null;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		m_AIManager = base.transform.GetChild(0).GetComponent<AIManager>();
		MaxPlayers = 6;
	}

	private void OnDestroy()
	{
		Instance = null;
	}

	private void Start()
	{
		if (GameSystem.Instance.WasInOnlineRoom && (bool)NetworkLogin.Instance && !NetworkLogin.Instance.JoinedRoom())
		{
			QuitMenu.Instance.Kickout();
			return;
		}
		CreateSkids();
		ProfileManager.Instance.ResetColours();
		m_hornsChosen = 0;
		int num = 0;
		Player player = null;
		if (GameSystem.Instance.EnableTimeTrialMode)
		{
			MaxPlayers = 1;
		}
		else if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && NetworkLogin.Instance.GetRoomPlayerCount() > 0)
		{
			MaxPlayers = NetworkLogin.Instance.GetRoomPlayerCount();
		}
		int num2 = -1;
		int num3 = 0;
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			num2 = NetworkLogin.Instance.GetRoomPlayerCount() - 1;
		}
		for (int i = 0; i < MaxPlayers; i++)
		{
			if (num >= GridStartPositions.Length)
			{
				break;
			}
			int pos = 0;
			int num4 = 0;
			bool flag = true;
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
			{
				if (i > 0 && num2 < 0)
				{
					flag = true;
				}
				else if (i == 0)
				{
					int onlinePlayer = NetworkLogin.Instance.GetServer().GetPlayerConnectionByIndex(GameSystem.Instance.HumanSeatIndex).OnlinePlayer;
					pos = GameSystem.Instance.GetPositionChooser().FindSeatPosition(onlinePlayer);
					num4 = GameSystem.Instance.GetPositionChooser().FindGridPosition(onlinePlayer);
					num3 |= 1 << pos;
					flag = false;
				}
			}
			else if (GameSystem.Instance.GetChampionshipMode().ModeInProgress())
			{
				if (GameSystem.Instance.GetChampionshipMode().FindDriverPosition(ProfileManager.Instance.GetPlayerName(i, useSwearFilter: false), ref pos))
				{
					if ((num3 & (1 << pos)) == 0)
					{
						num3 |= 1 << pos;
						num4 = pos;
						flag = false;
					}
				}
				else if (i == 0)
				{
					int num5 = MaxPlayers - 1;
					if ((num3 & (1 << num5)) == 0)
					{
						pos = num5;
						num3 |= 1 << num5;
						num4 = num5;
						flag = false;
					}
				}
			}
			else if (GameSystem.Instance.EnableTimeTrialMode)
			{
				flag = false;
				int num6 = 0;
				if ((num3 & (1 << num6)) == 0)
				{
					pos = num6;
					num3 |= 1 << num6;
					num4 = num6;
				}
			}
			else
			{
				flag = true;
			}
			if (flag)
			{
				int num7 = 0;
				do
				{
					num7 = UnityEngine.Random.Range(0, MaxPlayers);
				}
				while ((num3 & (1 << num7)) != 0);
				pos = num7;
				num4 = pos;
				num3 |= 1 << pos;
			}
			num++;
			Player player2 = null;
			if (i == 0)
			{
				string onlineID = string.Empty;
				if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
				{
					onlineID = NetworkLogin.Instance.GetGoogleDisplayName();
				}
				player2 = KartManager.Instance.CreateKart(KartManager.KartType.MainKart, Player.PlayerType.Human, i, onlineID, pos, num4, ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true), GridStartPositions[num4].transform.position, GridStartPositions[num4].transform.rotation);
				player = player2.GetComponent<Player>();
				float playerStartSpeed = GetAIManager().GetPlayerStartSpeed(ref player);
				player2.GetComponent<KartController>().MaxSpeed = playerStartSpeed;
				player2.GetComponent<KartController>().SetDefaultSpeed(playerStartSpeed);
				player.SetName(ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true));
			}
			else if (num2 <= 0 || i > num2)
			{
				if (num2 >= 0)
				{
					break;
				}
				if (!GameSystem.Instance.GetChampionshipMode().ModeInProgress() || GameSystem.Instance.GetChampionshipMode().CurrentTrackProgress() == 0)
				{
					int num8 = 0;
					do
					{
						num8 = UnityEngine.Random.Range(0, CustomisedObjectManager.Instance.GetTotalHorns() - 1);
					}
					while ((m_hornsChosen & (1 << num8)) != 0);
					m_hornsChosen |= 1 << num8;
					ProfileManager.PlayerData data = ProfileManager.Instance.GetPlayerData(i);
					data.m_customisationData.m_horn = CustomisedObjectManager.Instance.GetHornIdentifierByIndex(num8);
					if (UnityEngine.Random.Range(0f, 1f) < 0.25f)
					{
						data.m_customisationData.m_helmetProp = CustomisedObjectManager.Instance.GetHelmetIdentifierByIndex(UnityEngine.Random.Range(0, CustomisedObjectManager.Instance.GetTotalHelmetProps()));
					}
					if (UnityEngine.Random.Range(0f, 1f) < 0.25f)
					{
						data.m_customisationData.m_visorProp = CustomisedObjectManager.Instance.GetVisorIdentifierByIndex(UnityEngine.Random.Range(0, CustomisedObjectManager.Instance.GetTotalVisorProps()));
					}
					ProfileManager.Instance.SetPlayerData(i, ref data);
				}
				player2 = KartManager.Instance.CreateKart(KartManager.KartType.AIKart, Player.PlayerType.AI, -1, string.Empty, pos, -1, ProfileManager.Instance.GetPlayerName(i, useSwearFilter: true), GridStartPositions[pos].transform.position, GridStartPositions[pos].transform.rotation);
				Player player3 = player2;
				player3.name = player3.name + " " + i;
				player = player2.GetComponent<Player>();
				VRWaypointCircuit vRWaypointCircuit = UnityEngine.Object.FindObjectOfType<VRWaypointCircuit>();
				if ((bool)vRWaypointCircuit)
				{
					m_AIManager.AI.WayPointCircuit = vRWaypointCircuit;
					player.SetAITarget(vRWaypointCircuit);
				}
				player.SetPlayerType(Player.PlayerType.AI);
				player2.GetComponent<VRCarAIControl>().SetSpeedMultiplier(GetAIManager().GetKartSpeed(i));
				player.SetName(ProfileManager.Instance.GetPlayerName(i, useSwearFilter: true));
				if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
				{
					player.GetComponent<KartUserControl>().EnableStartBoost();
				}
			}
			if ((bool)player2)
			{
				player2.transform.parent = base.gameObject.transform;
				if (player.GetPlayerType() == Player.PlayerType.AI)
				{
					player.SetGridTime(m_AIManager.AI.AIGridStartOffset * (float)pos);
				}
				if (!GameSystem.Instance.GetChampionshipMode().ModeInProgress() || GameSystem.Instance.GetChampionshipMode().CurrentTrackProgress() == 0)
				{
					if (player.GetPlayerType() == Player.PlayerType.AI)
					{
						ProfileManager.Instance.SetupDemoProfile(i);
						player.SetName(ProfileManager.Instance.GetPlayerName(i, useSwearFilter: true));
					}
					ProfileManager.Instance.ResetChampionPoints(i);
				}
				if (player.GetPlayerType() == Player.PlayerType.AI)
				{
					player.GetKartGeometry().GetComponent<AILOD>().SetupHelmetProp(ProfileManager.Instance.GetPlayerData(i).m_helmetType, i);
				}
				ProfileManager.Instance.SetColoursOnPlayer(ref player, i);
				player.GetKartGeometry().SetupWheelColour();
				if (player.GetPlayerType() == Player.PlayerType.Human)
				{
					ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(i);
					player.SetResultsColours(playerData.m_colourIndex[0], playerData.m_colourIndex[1]);
				}
				player.LocalPlayerIndex = i;
				if (player.GetPlayerType() == Player.PlayerType.Human)
				{
					player.SetupCustomisationProps(i);
				}
				player.NewGridPosition = num4;
			}
			if ((bool)player2)
			{
				m_playerList.Add(player2.GetComponent<Player>());
			}
		}
	}

	public void SetExhaust(int exhaustIndex, Player kart, int playerIndex)
	{
		if (ExhaustList[exhaustIndex] != null)
		{
			KartExhaust component = ExhaustList[exhaustIndex].GetComponent<KartExhaust>();
			KartExhaust kartExhaust = UnityEngine.Object.Instantiate(component);
			kartExhaust.transform.parent = kart.ExhaustLocator;
			kartExhaust.transform.localPosition = Vector3.zero;
			kartExhaust.transform.localRotation = Quaternion.identity;
			kartExhaust.Owner = kart;
			kart.KartExhaust = kartExhaust;
		}
	}

	private void Update()
	{
		if (ConfettiEnabled || Time.frameCount % 10 == 0)
		{
			UpdateRaceOrder();
			UpdateNameTags();
		}
	}

	private void UpdateNameTags()
	{
		if (Time.frameCount % 6 != 0)
		{
			return;
		}
		m_nameTagDistanceList = float.PositiveInfinity;
		m_nameTagIndexList = -1;
		for (int i = 0; i < m_playerList.Count; i++)
		{
			if (!m_playerList[i])
			{
				continue;
			}
			Vector3 vector = m_playerList[i].transform.position - CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.position;
			Vector3 forward = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward;
			float sqrMagnitude = vector.sqrMagnitude;
			if (sqrMagnitude < 6400f)
			{
				float num = Vector3.Angle(forward, vector.normalized);
				if (num < 40f && sqrMagnitude < m_nameTagDistanceList)
				{
					m_nameTagIndexList = i;
					m_nameTagDistanceList = sqrMagnitude;
				}
			}
		}
		for (int j = 0; j < m_playerList.Count; j++)
		{
			if ((bool)m_playerList[j] && m_playerList[j].GetKartGeometry().ParentRenderingObject.activeSelf)
			{
				if (j == m_nameTagIndexList)
				{
					m_playerList[j].NameObject.GetComponent<NameBadge>().SetState(NameBadge.NameState.Grow);
				}
				else
				{
					m_playerList[j].NameObject.GetComponent<NameBadge>().SetState(NameBadge.NameState.Shrink);
				}
			}
		}
	}

	public List<Player> GetPlayerList()
	{
		return m_playerList;
	}

	public List<Player> GetPLayerListInOrder()
	{
		return m_playerListInOrder;
	}

	public void UpdateRaceOrder()
	{
		m_positionDataList.Clear();
		m_playerListInOrder.Clear();
		for (int i = 0; i < m_playerList.Count; i++)
		{
			if (!(m_playerList[i] == null))
			{
				m_playerList[i].PrevRaceOrder = m_playerList[i].CurrentRaceOrder;
				PositionData positionData = new PositionData();
				positionData.index = i;
				positionData.position = 0f - m_playerList[i].PointOnTrack();
				m_positionDataList.Add(positionData);
			}
		}
		m_positionDataList.Sort();
		if (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			Player refPlayer = null;
			Instance.GetHumanPlayer(ref refPlayer);
			for (int j = 0; j < m_positionDataList.Count; j++)
			{
				m_playerList[m_positionDataList[j].index].CurrentRaceOrder = j;
				m_playerListInOrder.Add(m_playerList[m_positionDataList[j].index]);
			}
		}
	}

	private void CreateSkids()
	{
		if (!(skidTrailPrefab != null))
		{
			return;
		}
		m_skidRoot = new GameObject("SkidPool");
		m_skidRoot.transform.parent = base.gameObject.transform;
		for (int i = 0; i < m_skidPool.Length; i++)
		{
			m_skidPool[i] = UnityEngine.Object.Instantiate(skidTrailPrefab);
			if (m_skidPool[i] != null)
			{
				m_skidPool[i].parent = m_skidRoot.transform;
				m_skidPool[i].gameObject.SetActive(value: false);
			}
		}
	}

	public Transform FindSpareSkid()
	{
		int currentSkid = m_currentSkid;
		m_currentSkid = (m_currentSkid + 1) % m_skidPool.Length;
		return m_skidPool[currentSkid];
	}

	public void FreeSkid(GameObject skidObject)
	{
		skidObject.transform.parent = m_skidRoot.transform;
		skidObject.SetActive(value: false);
	}

	public void DetachSkid(GameObject skidObject)
	{
		skidObject.transform.parent = m_skidRoot.transform;
	}

	public List<PositionData> GetRaceOrder()
	{
		return m_positionDataList;
	}
}
public class PlayerWingMirror : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private int FrameInterval = 2;

	private Camera m_currentCam;

	private int m_index;

	private void Start()
	{
		m_currentCam = GetComponent<Camera>();
	}

	private void FixedUpdate()
	{
		if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Weapon))
		{
			FrameInterval = (FrameInterval + 1) % 6;
			if (FrameInterval == 1)
			{
				FrameInterval = 2;
			}
		}
		m_index++;
		if (FrameInterval > 0 && m_index >= FrameInterval)
		{
			m_index = 0;
			m_currentCam.enabled = true;
		}
		else
		{
			m_currentCam.enabled = false;
		}
	}
}
public class ProfileManager : UnityEngine.MonoBehaviour
{
	public struct PlayerColours
	{
		public UnityEngine.Color HelmetPrimary;

		public UnityEngine.Color HelmetSecondary;

		public UnityEngine.Color RacerPrimary;

		public UnityEngine.Color RacerSecondary;

		public UnityEngine.Color KartPrimary;

		public UnityEngine.Color KartSecondary;

		public UnityEngine.Color BoostTrail;

		public bool Used;

		public PlayerColours(UnityEngine.Color kp, UnityEngine.Color ks, UnityEngine.Color rp, UnityEngine.Color rs, UnityEngine.Color hp, UnityEngine.Color hs, UnityEngine.Color ex, bool used)
		{
			KartPrimary = kp;
			KartSecondary = ks;
			RacerPrimary = rp;
			RacerSecondary = rs;
			HelmetPrimary = hp;
			HelmetSecondary = hs;
			BoostTrail = ex;
			Used = used;
		}
	}

	private enum PlayerColourType
	{
		Tone_1,
		Tone_2,
		Tone_3,
		Tone_4,
		Red_1,
		Red_2,
		Red_3,
		Red_4,
		Orange_1,
		Orange_2,
		Orange_3,
		Orange_4,
		Yellow_1,
		Yellow_2,
		Yellow_3,
		Yellow_4,
		Green_1,
		Green_2,
		Green_3,
		Green_4,
		Light_Blue_1,
		Light_Blue_2,
		Light_Blue_3,
		Light_Blue_4,
		Blue_1,
		Blue_2,
		Blue_3,
		Blue_4,
		Purple_1,
		Purple_2,
		Purple_3,
		Purple_4,
		Pink_1,
		Pink_2,
		Pink_3,
		Pink_4,
		Max
	}

	public enum PlayerSpeed
	{
		Normal,
		Turbo
	}

	public struct DemoConfig
	{
		public UnityEngine.Color Helmet1;

		public UnityEngine.Color Helmet2;

		public UnityEngine.Color Racer1;

		public UnityEngine.Color Racer2;

		public UnityEngine.Color Kart1;

		public UnityEngine.Color Kart2;

		public UnityEngine.Color Boost;

		public string HelmetProp;

		public string VisorProp;

		public string ProfileName;

		public AILOD.PropHelmetType HelmetType;

		public DemoConfig(UnityEngine.Color h1, UnityEngine.Color h2, UnityEngine.Color r1, UnityEngine.Color r2, UnityEngine.Color k1, UnityEngine.Color k2, UnityEngine.Color b, string helmet, string visor, string name, AILOD.PropHelmetType helmetType)
		{
			Helmet1 = h1;
			Helmet2 = h2;
			Racer1 = r1;
			Racer2 = r2;
			Kart1 = k1;
			Kart2 = k2;
			Boost = b;
			HelmetProp = helmet;
			VisorProp = visor;
			ProfileName = name;
			HelmetType = helmetType;
		}
	}

	public struct CustomisationData
	{
		public string m_horn;

		public string m_helmetProp;

		public string m_visorProp;

		public string m_dashProp;

		public string m_dashStyle;
	}

	public struct PlayerData
	{
		public string m_profileName;

		public int m_enteredName;

		public int m_aiColourIndex;

		public PlayerColours m_playerColours;

		public int[] m_colourIndex;

		public AILOD.PropHelmetType m_helmetType;

		public int m_championPoints;

		public CustomisationData m_customisationData;
	}

	public static ProfileManager Instance = null;

	private string playerFile;

	private static readonly int KeyLength = 24;

	private static readonly int IVLength = 8;

	private TripleDES algorithm;

	private TripleDESCryptoServiceProvider serviceProvider;

	public static int MaxNameLength = 12;

	public static string FTUE_VERSION_NO = "1.5";

	public static string SHOP_VERSION_NO = "1.0";

	public static string NETWORK_VERSION_NO = "1.01";

	public static string ONLINE_FILTER_VERSION = "1.1";

	public static string PUBLIC_VERSION_NO = "3.05";

	public static bool LOCKOUT_TIME_TRIAL = false;

	public DemoConfig[] DemoConfigData = new DemoConfig[12]
	{
		new DemoConfig(PlayerColour[26], PlayerColour[14], PlayerColour[14], PlayerColour[26], PlayerColour[14], PlayerColour[26], PlayerColour[26], "Helmet_Boppers_Star", string.Empty, "DISCO SWEDE", AILOD.PropHelmetType.BoppersStar),
		new DemoConfig(PlayerColour[11], PlayerColour[11], PlayerColour[11], PlayerColour[14], PlayerColour[14], PlayerColour[14], PlayerColour[10], "Helmet_BearEars", string.Empty, "HONEY BEAR", AILOD.PropHelmetType.BearHead),
		new DemoConfig(PlayerColour[0], PlayerColour[33], PlayerColour[0], PlayerColour[33], PlayerColour[0], PlayerColour[33], PlayerColour[33], "Helmet_BunnyEars", "Visor_HypnoEyes", "HYPNO BUNNY", AILOD.PropHelmetType.BunnyEars),
		new DemoConfig(PlayerColour[6], PlayerColour[0], PlayerColour[6], PlayerColour[0], PlayerColour[0], PlayerColour[26], PlayerColour[6], "Helmet_Cap", "Visor_Sunglasses", "CAP 'N COOL", AILOD.PropHelmetType.Cap),
		new DemoConfig(PlayerColour[7], PlayerColour[7], PlayerColour[7], PlayerColour[6], PlayerColour[35], PlayerColour[34], PlayerColour[7], "Helmet_Boppers_Heart", string.Empty, "VALENTINO", AILOD.PropHelmetType.BoppersHeart),
		new DemoConfig(PlayerColour[0], PlayerColour[34], PlayerColour[34], PlayerColour[0], PlayerColour[25], PlayerColour[0], PlayerColour[6], "Helmet_PartyHat_Stars", string.Empty, "PARTY BOY", AILOD.PropHelmetType.PartyHatStars),
		new DemoConfig(PlayerColour[3], PlayerColour[2], PlayerColour[3], PlayerColour[2], PlayerColour[3], PlayerColour[18], PlayerColour[18], "Helmet_Boppers_Sphere", "Visor_HypnoEyes", "ANT-ONE", AILOD.PropHelmetType.BoppersSphere),
		new DemoConfig(PlayerColour[14], PlayerColour[30], PlayerColour[30], PlayerColour[14], PlayerColour[30], PlayerColour[14], PlayerColour[30], "Helmet_Headphones", string.Empty, "BEAT FREAK", AILOD.PropHelmetType.Headphones),
		new DemoConfig(PlayerColour[1], PlayerColour[1], PlayerColour[1], PlayerColour[27], PlayerColour[25], PlayerColour[27], PlayerColour[25], "Helmet_PartyHat_Spotty", string.Empty, "BLUE STEAL", AILOD.PropHelmetType.PartyHatSpots),
		new DemoConfig(PlayerColour[6], PlayerColour[6], PlayerColour[6], PlayerColour[2], PlayerColour[6], PlayerColour[2], PlayerColour[2], "Helmet_DevilHorns", string.Empty, "LIL' DEVIL", AILOD.PropHelmetType.DevilHorns),
		new DemoConfig(PlayerColour[3], PlayerColour[34], PlayerColour[3], PlayerColour[2], PlayerColour[34], PlayerColour[3], PlayerColour[33], string.Empty, string.Empty, "META GIRL", AILOD.PropHelmetType.Plain),
		new DemoConfig(PlayerColour[3], PlayerColour[6], PlayerColour[3], PlayerColour[2], PlayerColour[3], PlayerColour[2], PlayerColour[6], string.Empty, string.Empty, "NINJA", AILOD.PropHelmetType.Plain)
	};

	public PlayerColours[] PlayerColourData = new PlayerColours[18]
	{
		new PlayerColours(PlayerColour[2], PlayerColour[10], PlayerColour[2], PlayerColour[10], PlayerColour[2], PlayerColour[2], PlayerColour[10], used: false),
		new PlayerColours(PlayerColour[22], PlayerColour[14], PlayerColour[22], PlayerColour[6], PlayerColour[22], PlayerColour[14], PlayerColour[6], used: false),
		new PlayerColours(PlayerColour[2], PlayerColour[22], PlayerColour[2], PlayerColour[22], PlayerColour[2], PlayerColour[22], PlayerColour[22], used: false),
		new PlayerColours(PlayerColour[2], PlayerColour[6], PlayerColour[2], PlayerColour[6], PlayerColour[2], PlayerColour[6], PlayerColour[2], used: false),
		new PlayerColours(PlayerColour[26], PlayerColour[25], PlayerColour[26], PlayerColour[25], PlayerColour[26], PlayerColour[25], PlayerColour[10], used: false),
		new PlayerColours(PlayerColour[26], PlayerColour[14], PlayerColour[26], PlayerColour[14], PlayerColour[26], PlayerColour[14], PlayerColour[14], used: false),
		new PlayerColours(PlayerColour[25], PlayerColour[0], PlayerColour[10], PlayerColour[0], PlayerColour[10], PlayerColour[0], PlayerColour[10], used: false),
		new PlayerColours(PlayerColour[2], PlayerColour[14], PlayerColour[2], PlayerColour[14], PlayerColour[2], PlayerColour[14], PlayerColour[0], used: false),
		new PlayerColours(PlayerColour[0], PlayerColour[6], PlayerColour[0], PlayerColour[6], PlayerColour[0], PlayerColour[6], PlayerColour[26], used: false),
		new PlayerColours(PlayerColour[30], PlayerColour[0], PlayerColour[4], PlayerColour[0], PlayerColour[4], PlayerColour[0], PlayerColour[4], used: false),
		new PlayerColours(PlayerColour[14], PlayerColour[3], PlayerColour[3], PlayerColour[14], PlayerColour[14], PlayerColour[3], PlayerColour[22], used: false),
		new PlayerColours(PlayerColour[18], PlayerColour[14], PlayerColour[18], PlayerColour[14], PlayerColour[18], PlayerColour[14], PlayerColour[18], used: false),
		new PlayerColours(PlayerColour[26], PlayerColour[0], PlayerColour[0], PlayerColour[26], PlayerColour[0], PlayerColour[26], PlayerColour[0], used: false),
		new PlayerColours(PlayerColour[22], PlayerColour[10], PlayerColour[10], PlayerColour[22], PlayerColour[22], PlayerColour[10], PlayerColour[0], used: false),
		new PlayerColours(PlayerColour[5], PlayerColour[0], PlayerColour[0], PlayerColour[5], PlayerColour[0], PlayerColour[5], PlayerColour[5], used: false),
		new PlayerColours(PlayerColour[0], PlayerColour[6], PlayerColour[0], PlayerColour[22], PlayerColour[0], PlayerColour[22], PlayerColour[6], used: false),
		new PlayerColours(PlayerColour[3], PlayerColour[0], PlayerColour[3], PlayerColour[0], PlayerColour[3], PlayerColour[0], PlayerColour[0], used: false),
		new PlayerColours(PlayerColour[0], PlayerColour[0], PlayerColour[0], PlayerColour[0], PlayerColour[0], PlayerColour[0], PlayerColour[0], used: false)
	};

	private static UnityEngine.Color[] PlayerColour = new UnityEngine.Color[36]
	{
		new UnityEngine.Color(0.96862745f, 0.96862745f, 0.96862745f, 1f),
		new UnityEngine.Color(0.64705884f, 0.654902f, 58f / 85f, 1f),
		new UnityEngine.Color(0.24313726f, 0.24313726f, 13f / 51f, 1f),
		new UnityEngine.Color(6f / 85f, 0.07450981f, 4f / 51f, 1f),
		new UnityEngine.Color(1f, 62f / 85f, 62f / 85f, 1f),
		new UnityEngine.Color(1f, 13f / 51f, 13f / 51f, 1f),
		new UnityEngine.Color(76f / 85f, 0f, 0f, 1f),
		new UnityEngine.Color(0.5294118f, 1f / 51f, 0f, 1f),
		new UnityEngine.Color(1f, 0.8f, 31f / 51f, 1f),
		new UnityEngine.Color(1f, 56f / 85f, 29f / 85f, 1f),
		new UnityEngine.Color(1f, 0.4862745f, 0f, 1f),
		new UnityEngine.Color(0.57254905f, 0.2784314f, 0f, 1f),
		new UnityEngine.Color(0.99607843f, 1f, 37f / 51f, 1f),
		new UnityEngine.Color(0.99607843f, 1f, 0.4117647f, 1f),
		new UnityEngine.Color(1f, 0.7490196f, 14f / 85f, 1f),
		new UnityEngine.Color(0.7058824f, 0.58431375f, 0f, 1f),
		new UnityEngine.Color(38f / 51f, 1f, 0.69803923f, 1f),
		new UnityEngine.Color(0.5372549f, 1f, 23f / 51f, 1f),
		new UnityEngine.Color(13f / 85f, 54f / 85f, 4f / 51f, 1f),
		new UnityEngine.Color(0f, 0.3372549f, 0f, 1f),
		new UnityEngine.Color(0.7372549f, 0.99607843f, 1f, 1f),
		new UnityEngine.Color(47f / 85f, 84f / 85f, 1f, 1f),
		new UnityEngine.Color(0f, 83f / 85f, 1f, 1f),
		new UnityEngine.Color(0.050980393f, 29f / 85f, 37f / 85f, 1f),
		new UnityEngine.Color(31f / 51f, 0.75686276f, 1f, 1f),
		new UnityEngine.Color(29f / 85f, 0.5921569f, 1f, 1f),
		new UnityEngine.Color(0f, 0.34901962f, 0.9098039f, 1f),
		new UnityEngine.Color(2f / 51f, 0.17254902f, 0.40392157f, 1f),
		new UnityEngine.Color(0.78039217f, 35f / 51f, 1f, 1f),
		new UnityEngine.Color(0.6156863f, 23f / 51f, 1f, 1f),
		new UnityEngine.Color(36f / 85f, 0.18431373f, 1f, 1f),
		new UnityEngine.Color(16f / 85f, 0.043137256f, 26f / 51f, 1f),
		new UnityEngine.Color(1f, 0.6901961f, 74f / 85f, 1f),
		new UnityEngine.Color(1f, 23f / 51f, 0.76862746f, 1f),
		new UnityEngine.Color(1f, 0f, 0.58431375f, 1f),
		new UnityEngine.Color(0.4117647f, 1f / 17f, 23f / 85f, 1f)
	};

	public static UnityEngine.Color[] CustomisationColours = new UnityEngine.Color[36]
	{
		PlayerColour[0],
		PlayerColour[1],
		PlayerColour[2],
		PlayerColour[3],
		PlayerColour[4],
		PlayerColour[5],
		PlayerColour[6],
		PlayerColour[7],
		PlayerColour[8],
		PlayerColour[9],
		PlayerColour[10],
		PlayerColour[11],
		PlayerColour[12],
		PlayerColour[13],
		PlayerColour[14],
		PlayerColour[15],
		PlayerColour[16],
		PlayerColour[17],
		PlayerColour[18],
		PlayerColour[19],
		PlayerColour[20],
		PlayerColour[21],
		PlayerColour[22],
		PlayerColour[23],
		PlayerColour[24],
		PlayerColour[25],
		PlayerColour[26],
		PlayerColour[27],
		PlayerColour[28],
		PlayerColour[29],
		PlayerColour[30],
		PlayerColour[31],
		PlayerColour[32],
		PlayerColour[33],
		PlayerColour[34],
		PlayerColour[35]
	};

	private PlayerData[] m_playerData = new PlayerData[8];

	private bool m_checkedForProfileName;

	public bool PlayedProCup;

	private bool[] WonChampModeCup = new bool[4];

	private bool[] WonChampModeCup2 = new bool[4];

	private bool[] WonChampModeCupRandom = new bool[4];

	private PlayerSpeed m_internalSpeed;

	public float MusicVolume { get; set; }

	public float SFXVolume { get; set; }

	public float Version { get; set; }

	public int FTUE { get; set; }

	public bool AlreadyPlayedFTUE { get; set; }

	public int NumLaps { get; set; }

	public bool Loaded { get; set; }

	public int CurrentOnlinePoints { get; set; }

	public ChampionshipMode.TrophyChampionshipType CurrentChampType { get; set; }

	public PlayerSpeed Speed
	{
		get
		{
			if ((bool)GameSystem.Instance && GameSystem.Instance.EnableTimeTrialMode)
			{
				return PlayerSpeed.Normal;
			}
			return m_internalSpeed;
		}
		set
		{
			m_internalSpeed = value;
		}
	}

	public bool WonChampMode(ChampionshipMode.TrophyGroupingType trophyType)
	{
		return CurrentChampType switch
		{
			ChampionshipMode.TrophyChampionshipType.Championship1 => WonChampModeCup[(int)trophyType], 
			ChampionshipMode.TrophyChampionshipType.Championship2 => WonChampModeCup2[(int)trophyType], 
			_ => false, 
		};
	}

	public void SetWonChampModeCup(ChampionshipMode.TrophyGroupingType trophyType)
	{
		switch (CurrentChampType)
		{
		case ChampionshipMode.TrophyChampionshipType.Championship1:
			WonChampModeCup[(int)trophyType] = true;
			break;
		case ChampionshipMode.TrophyChampionshipType.Championship2:
			WonChampModeCup2[(int)trophyType] = true;
			break;
		}
	}

	public void ClearProfileData()
	{
		for (int i = 1; i < m_playerData.Length; i++)
		{
			m_playerData[i].m_profileName = string.Empty;
			m_playerData[i].m_enteredName = 0;
			m_playerData[i].m_aiColourIndex = 0;
			m_playerData[i].m_championPoints = 0;
			m_playerData[i].m_customisationData.m_horn = string.Empty;
			m_playerData[i].m_customisationData.m_helmetProp = string.Empty;
			m_playerData[i].m_customisationData.m_visorProp = string.Empty;
			m_playerData[i].m_customisationData.m_dashProp = string.Empty;
			m_playerData[i].m_customisationData.m_dashStyle = string.Empty;
			if (m_playerData[i].m_colourIndex != null)
			{
				for (int j = 0; j < m_playerData[i].m_colourIndex.Length; j++)
				{
					m_playerData[i].m_colourIndex[j] = 0;
				}
			}
		}
	}

	public PlayerData GetPlayerData(int index)
	{
		return m_playerData[index];
	}

	public void SetPlayerData(int index, ref PlayerData data)
	{
		ref PlayerData reference = ref m_playerData[index];
		reference = data;
	}

	public void SetPlayerName(int index, string name)
	{
		m_playerData[index].m_profileName = name.ToUpper();
	}

	public string GetPlayerName(int index, bool useSwearFilter)
	{
		string profileName = m_playerData[index].m_profileName;
		if (useSwearFilter && profileName != null)
		{
			ApplySwearFilter(ref profileName);
		}
		return profileName;
	}

	public UnityEngine.Color GetPlayerColourByIndex(int colourIndex)
	{
		return PlayerColour[colourIndex];
	}

	public UnityEngine.Color UpdateColourIndex(int playerIndex, int colourIndex, int colourValue)
	{
		switch (colourIndex)
		{
		case 0:
			m_playerData[playerIndex].m_playerColours.HelmetPrimary = CustomisationColours[colourValue];
			return CustomisationColours[colourValue];
		case 1:
			m_playerData[playerIndex].m_playerColours.HelmetSecondary = CustomisationColours[colourValue];
			return CustomisationColours[colourValue];
		case 2:
			m_playerData[playerIndex].m_playerColours.RacerPrimary = CustomisationColours[colourValue];
			return CustomisationColours[colourValue];
		case 3:
			m_playerData[playerIndex].m_playerColours.RacerSecondary = CustomisationColours[colourValue];
			return CustomisationColours[colourValue];
		case 4:
			m_playerData[playerIndex].m_playerColours.KartPrimary = CustomisationColours[colourValue];
			return CustomisationColours[colourValue];
		case 5:
			m_playerData[playerIndex].m_playerColours.KartSecondary = CustomisationColours[colourValue];
			return CustomisationColours[colourValue];
		case 6:
			m_playerData[playerIndex].m_playerColours.BoostTrail = CustomisationColours[colourValue];
			return CustomisationColours[colourValue];
		default:
			return UnityEngine.Color.white;
		}
	}

	public UnityEngine.Color UpdateColours(int playerIndex, int index)
	{
		if (m_playerData[playerIndex].m_colourIndex[index] >= CustomisationColours.Length)
		{
			m_playerData[playerIndex].m_colourIndex[index] = 0;
		}
		else if (m_playerData[playerIndex].m_colourIndex[index] < 0)
		{
			m_playerData[playerIndex].m_colourIndex[index] = CustomisationColours.Length - 1;
		}
		return UpdateColourIndex(playerIndex, index, m_playerData[playerIndex].m_colourIndex[index]);
	}

	public void ResetChampionPoints(int index)
	{
		m_playerData[index].m_championPoints = 0;
	}

	public void SetupDemoProfile(int index)
	{
		int num = 0;
		do
		{
			num = UnityEngine.Random.Range(0, DemoConfigData.Length - 1);
		}
		while (PlayerColourData[num].Used);
		PlayerColourData[num].Used = true;
		m_playerData[index].m_aiColourIndex = num;
		m_playerData[index].m_playerColours.RacerPrimary = DemoConfigData[num].Racer1;
		m_playerData[index].m_playerColours.RacerSecondary = DemoConfigData[num].Racer2;
		m_playerData[index].m_playerColours.HelmetPrimary = DemoConfigData[num].Helmet1;
		m_playerData[index].m_playerColours.HelmetSecondary = DemoConfigData[num].Helmet2;
		m_playerData[index].m_playerColours.KartPrimary = DemoConfigData[num].Kart1;
		m_playerData[index].m_playerColours.KartSecondary = DemoConfigData[num].Kart2;
		m_playerData[index].m_playerColours.BoostTrail = DemoConfigData[num].Boost;
		m_playerData[index].m_customisationData.m_helmetProp = DemoConfigData[num].HelmetProp;
		m_playerData[index].m_customisationData.m_visorProp = DemoConfigData[num].VisorProp;
		m_playerData[index].m_profileName = DemoConfigData[num].ProfileName;
		m_playerData[index].m_helmetType = DemoConfigData[num].HelmetType;
	}

	public void ChooseRandomColours(int index)
	{
		int num = 0;
		do
		{
			num = UnityEngine.Random.Range(0, PlayerColourData.Length - 1);
		}
		while (PlayerColourData[num].Used);
		m_playerData[index].m_aiColourIndex = num;
		m_playerData[index].m_playerColours.RacerPrimary = PlayerColourData[num].RacerPrimary;
		m_playerData[index].m_playerColours.RacerSecondary = PlayerColourData[num].RacerSecondary;
		m_playerData[index].m_playerColours.HelmetPrimary = PlayerColourData[num].HelmetPrimary;
		m_playerData[index].m_playerColours.HelmetSecondary = PlayerColourData[num].HelmetSecondary;
		m_playerData[index].m_playerColours.KartPrimary = PlayerColourData[num].KartPrimary;
		m_playerData[index].m_playerColours.KartSecondary = PlayerColourData[num].KartSecondary;
		m_playerData[index].m_playerColours.BoostTrail = PlayerColourData[num].BoostTrail;
		PlayerColourData[num].Used = true;
	}

	public void SetColoursOnPlayer(ref Player player, int playerColourIndex)
	{
		TrackList.TrackData loadedTrack = GameSystem.Instance.GetLoadedTrack();
		m_playerData[playerColourIndex].m_playerColours.Used = false;
		if (player.GetPlayerType() == Player.PlayerType.Human)
		{
			if ((bool)player.GetKartGeometry().KartRenderer)
			{
				UnityEngine.Color kartPrimary = m_playerData[playerColourIndex].m_playerColours.KartPrimary;
				player.GetKartGeometry().KartRenderer.material.SetColor("_Color1", kartPrimary);
				kartPrimary = m_playerData[playerColourIndex].m_playerColours.KartSecondary;
				player.GetKartGeometry().KartRenderer.material.SetColor("_Color2", kartPrimary);
				if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
				{
					player.GetKartGeometry().KartRenderer.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
				}
				else
				{
					player.GetKartGeometry().KartRenderer.material.SetColor("_Snow", UnityEngine.Color.black);
				}
			}
			if ((bool)player.GetKartGeometry().RacerRenderer)
			{
				UnityEngine.Color racerPrimary = m_playerData[playerColourIndex].m_playerColours.RacerPrimary;
				player.GetKartGeometry().RacerRenderer.material.SetColor("_Color1", racerPrimary);
				racerPrimary = m_playerData[playerColourIndex].m_playerColours.RacerSecondary;
				player.GetKartGeometry().RacerRenderer.material.SetColor("_Color2", racerPrimary);
			}
			if ((bool)player.GetKartGeometry().HelmetRenderer)
			{
				UnityEngine.Color helmetPrimary = m_playerData[playerColourIndex].m_playerColours.HelmetPrimary;
				player.GetKartGeometry().HelmetRenderer.material.SetColor("_Color3", helmetPrimary);
				helmetPrimary = m_playerData[playerColourIndex].m_playerColours.HelmetSecondary;
				player.GetKartGeometry().HelmetRenderer.material.SetColor("_Color4", helmetPrimary);
			}
		}
		else
		{
			if ((bool)player.GetKartGeometry().KartRenderer)
			{
				UnityEngine.Color kartPrimary2 = m_playerData[playerColourIndex].m_playerColours.KartPrimary;
				player.GetKartGeometry().KartRenderer.material.SetColor("_Color5", kartPrimary2);
				kartPrimary2 = m_playerData[playerColourIndex].m_playerColours.KartSecondary;
				player.GetKartGeometry().KartRenderer.material.SetColor("_Color6", kartPrimary2);
				kartPrimary2 = m_playerData[playerColourIndex].m_playerColours.RacerPrimary;
				player.GetKartGeometry().KartRenderer.material.SetColor("_Color1", kartPrimary2);
				kartPrimary2 = m_playerData[playerColourIndex].m_playerColours.RacerSecondary;
				player.GetKartGeometry().KartRenderer.material.SetColor("_Color2", kartPrimary2);
				if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
				{
					player.GetKartGeometry().KartRenderer.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
				}
				else
				{
					player.GetKartGeometry().KartRenderer.material.SetColor("_Snow", UnityEngine.Color.black);
				}
			}
			if ((bool)player.GetKartGeometry().RacerRenderer)
			{
				UnityEngine.Color racerPrimary2 = m_playerData[playerColourIndex].m_playerColours.RacerPrimary;
				player.GetKartGeometry().RacerRenderer.material.SetColor("_Color1", racerPrimary2);
				racerPrimary2 = m_playerData[playerColourIndex].m_playerColours.RacerSecondary;
				player.GetKartGeometry().RacerRenderer.material.SetColor("_Color2", racerPrimary2);
			}
			if ((bool)player.GetKartGeometry().HelmetRenderer)
			{
				UnityEngine.Color helmetPrimary2 = m_playerData[playerColourIndex].m_playerColours.HelmetPrimary;
				player.GetKartGeometry().HelmetRenderer.material.SetColor("_Color3", helmetPrimary2);
				helmetPrimary2 = m_playerData[playerColourIndex].m_playerColours.HelmetSecondary;
				player.GetKartGeometry().HelmetRenderer.material.SetColor("_Color4", helmetPrimary2);
			}
		}
		if ((bool)player.GetKartGeometry().AIFar_KartRenderer)
		{
			UnityEngine.Color kartPrimary3 = m_playerData[playerColourIndex].m_playerColours.KartPrimary;
			player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Color5", kartPrimary3);
			kartPrimary3 = m_playerData[playerColourIndex].m_playerColours.KartSecondary;
			player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Color6", kartPrimary3);
			kartPrimary3 = m_playerData[playerColourIndex].m_playerColours.RacerPrimary;
			player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Color1", kartPrimary3);
			kartPrimary3 = m_playerData[playerColourIndex].m_playerColours.RacerSecondary;
			player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Color2", kartPrimary3);
			kartPrimary3 = m_playerData[playerColourIndex].m_playerColours.HelmetPrimary;
			player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Color3", kartPrimary3);
			kartPrimary3 = m_playerData[playerColourIndex].m_playerColours.HelmetSecondary;
			player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Color4", kartPrimary3);
			if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
			{
				player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
			}
			else
			{
				player.GetKartGeometry().AIFar_KartRenderer.material.SetColor("_Snow", UnityEngine.Color.black);
			}
		}
		if ((bool)player.GetKartGeometry().AIFar_LOD0Renderer)
		{
			UnityEngine.Color kartPrimary4 = m_playerData[playerColourIndex].m_playerColours.KartPrimary;
			player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Color5", kartPrimary4);
			kartPrimary4 = m_playerData[playerColourIndex].m_playerColours.KartSecondary;
			player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Color6", kartPrimary4);
			kartPrimary4 = m_playerData[playerColourIndex].m_playerColours.RacerPrimary;
			player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Color1", kartPrimary4);
			kartPrimary4 = m_playerData[playerColourIndex].m_playerColours.RacerSecondary;
			player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Color2", kartPrimary4);
			kartPrimary4 = m_playerData[playerColourIndex].m_playerColours.HelmetPrimary;
			player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Color3", kartPrimary4);
			kartPrimary4 = m_playerData[playerColourIndex].m_playerColours.HelmetSecondary;
			player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Color4", kartPrimary4);
			if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
			{
				player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
			}
			else
			{
				player.GetKartGeometry().AIFar_LOD0Renderer.material.SetColor("_Snow", UnityEngine.Color.black);
			}
		}
		if ((bool)player.NameColours)
		{
			UnityEngine.Color helmetPrimary3 = m_playerData[playerColourIndex].m_playerColours.HelmetPrimary;
			player.NameColours.material.SetColor("_Color3", helmetPrimary3);
			helmetPrimary3 = m_playerData[playerColourIndex].m_playerColours.HelmetSecondary;
			player.NameColours.material.SetColor("_Color4", helmetPrimary3);
		}
	}

	public void SetupHelmetColours(ref MeshRenderer mesh, int playerColourIndex)
	{
		TrackList.TrackData loadedTrack = GameSystem.Instance.GetLoadedTrack();
		UnityEngine.Color kartPrimary = m_playerData[playerColourIndex].m_playerColours.KartPrimary;
		mesh.material.SetColor("_Color5", kartPrimary);
		kartPrimary = m_playerData[playerColourIndex].m_playerColours.KartSecondary;
		mesh.material.SetColor("_Color6", kartPrimary);
		kartPrimary = m_playerData[playerColourIndex].m_playerColours.RacerPrimary;
		mesh.material.SetColor("_Color1", kartPrimary);
		kartPrimary = m_playerData[playerColourIndex].m_playerColours.RacerSecondary;
		mesh.material.SetColor("_Color2", kartPrimary);
		kartPrimary = m_playerData[playerColourIndex].m_playerColours.HelmetPrimary;
		mesh.material.SetColor("_Color3", kartPrimary);
		kartPrimary = m_playerData[playerColourIndex].m_playerColours.HelmetSecondary;
		mesh.material.SetColor("_Color4", kartPrimary);
		if (mesh.material.HasProperty("_Snow"))
		{
			if (loadedTrack.TrackWeather == TrackList.WeatherType.Blizzard || loadedTrack.TrackWeather == TrackList.WeatherType.Snowy)
			{
				mesh.material.SetColor("_Snow", new UnityEngine.Color(0.4627451f, 0.4627451f, 0.4627451f, 1f));
			}
			else
			{
				mesh.material.SetColor("_Snow", UnityEngine.Color.black);
			}
		}
	}

	public void SetImmobolizeExhaust(ref Player player, bool set, Gameplay.HitByType hitType)
	{
		if ((bool)player && player.GetPlayerType() != Player.PlayerType.Network)
		{
			player.KartExhaust.EnableBadSmoke(set, hitType);
		}
	}

	public void LoadProfileData()
	{
		try
		{
			bool flag = true;
			if (File.Exists(playerFile))
			{
				UnityEngine.Color color = default(UnityEngine.Color);
				using FileStream stream = new FileStream(playerFile, FileMode.Open, FileAccess.Read);
				using CryptoStream stream2 = new CryptoStream(stream, serviceProvider.CreateDecryptor(algorithm.Key, algorithm.IV), CryptoStreamMode.Read);
				using StreamReader streamReader = new StreamReader(stream2);
				string text = streamReader.ReadLine();
				float num = 0f;
				int num2 = 0;
				string empty = string.Empty;
				flag = false;
				num = float.Parse(streamReader.ReadLine());
				MusicVolume = num;
				num = float.Parse(streamReader.ReadLine());
				SFXVolume = num;
				num2 = int.Parse(streamReader.ReadLine());
				Speed = (PlayerSpeed)num2;
				num = float.Parse(streamReader.ReadLine());
				Version = num;
				num2 = int.Parse(streamReader.ReadLine());
				FTUE = num2;
				num2 = int.Parse(streamReader.ReadLine());
				NumLaps = num2;
				empty = streamReader.ReadLine();
				m_playerData[0].m_profileName = empty.ToUpper();
				num2 = int.Parse(streamReader.ReadLine());
				m_playerData[0].m_enteredName = num2;
				empty = streamReader.ReadLine();
				m_playerData[0].m_customisationData.m_horn = empty;
				empty = streamReader.ReadLine();
				m_playerData[0].m_customisationData.m_helmetProp = empty;
				empty = streamReader.ReadLine();
				m_playerData[0].m_customisationData.m_dashProp = empty;
				empty = streamReader.ReadLine();
				m_playerData[0].m_customisationData.m_dashStyle = empty;
				empty = streamReader.ReadLine();
				m_playerData[0].m_customisationData.m_visorProp = empty;
				num = float.Parse(streamReader.ReadLine());
				color.r = num;
				num = float.Parse(streamReader.ReadLine());
				color.g = num;
				num = float.Parse(streamReader.ReadLine());
				color.b = num;
				color.a = 1f;
				SetPlayerColourIndex(color, 0, 0);
				m_playerData[0].m_playerColours.HelmetPrimary = color;
				num = float.Parse(streamReader.ReadLine());
				color.r = num;
				num = float.Parse(streamReader.ReadLine());
				color.g = num;
				num = float.Parse(streamReader.ReadLine());
				color.b = num;
				color.a = 1f;
				SetPlayerColourIndex(color, 0, 1);
				m_playerData[0].m_playerColours.HelmetSecondary = color;
				num = float.Parse(streamReader.ReadLine());
				color.r = num;
				num = float.Parse(streamReader.ReadLine());
				color.g = num;
				num = float.Parse(streamReader.ReadLine());
				color.b = num;
				color.a = 1f;
				SetPlayerColourIndex(color, 0, 2);
				m_playerData[0].m_playerColours.RacerPrimary = color;
				num = float.Parse(streamReader.ReadLine());
				color.r = num;
				num = float.Parse(streamReader.ReadLine());
				color.g = num;
				num = float.Parse(streamReader.ReadLine());
				color.b = num;
				color.a = 1f;
				SetPlayerColourIndex(color, 0, 3);
				m_playerData[0].m_playerColours.RacerSecondary = color;
				num = float.Parse(streamReader.ReadLine());
				color.r = num;
				num = float.Parse(streamReader.ReadLine());
				color.g = num;
				num = float.Parse(streamReader.ReadLine());
				color.b = num;
				color.a = 1f;
				SetPlayerColourIndex(color, 0, 4);
				m_playerData[0].m_playerColours.KartPrimary = color;
				num = float.Parse(streamReader.ReadLine());
				color.r = num;
				num = float.Parse(streamReader.ReadLine());
				color.g = num;
				num = float.Parse(streamReader.ReadLine());
				color.b = num;
				color.a = 1f;
				SetPlayerColourIndex(color, 0, 5);
				m_playerData[0].m_playerColours.KartSecondary = color;
				num = float.Parse(streamReader.ReadLine());
				color.r = num;
				num = float.Parse(streamReader.ReadLine());
				color.g = num;
				num = float.Parse(streamReader.ReadLine());
				color.b = num;
				color.a = 1f;
				SetPlayerColourIndex(color, 0, 6);
				m_playerData[0].m_playerColours.BoostTrail = color;
				PlayedProCup = bool.Parse(streamReader.ReadLine());
				for (int i = 0; i < WonChampModeCup.Length; i++)
				{
					WonChampModeCup[i] = bool.Parse(streamReader.ReadLine());
				}
				int num3 = 0;
				int num4 = 0;
				int num5 = 0;
				for (int j = 0; j < 11; j++)
				{
					num3 = int.Parse(streamReader.ReadLine());
					num4 = int.Parse(streamReader.ReadLine());
					num5 = int.Parse(streamReader.ReadLine());
					InputRemapper.Instance.SetInputConfiguration(j, num3, num4, num5);
				}
				if (Instance.Version != 1.4f)
				{
					for (int k = 0; k < WonChampModeCup2.Length; k++)
					{
						WonChampModeCup2[k] = bool.Parse(streamReader.ReadLine());
					}
					for (int l = 0; l < WonChampModeCupRandom.Length; l++)
					{
						WonChampModeCupRandom[l] = bool.Parse(streamReader.ReadLine());
					}
				}
			}
			if (flag)
			{
				SaveProfileData();
			}
			Loaded = true;
		}
		catch (Exception)
		{
			UnityEngine.Debug.Log("Profiledata load error");
			SaveProfileData();
		}
	}

	public void SaveProfileData()
	{
		if ((bool)QuitMenu.Instance && QuitMenu.Instance.InProgress())
		{
			return;
		}
		if ((bool)FEMManager.Instance)
		{
			FEMManager.Instance.SavingEnabled();
		}
		using FileStream stream = new FileStream(playerFile, FileMode.Create, FileAccess.Write);
		using CryptoStream cryptoStream = new CryptoStream(stream, serviceProvider.CreateEncryptor(algorithm.Key, algorithm.IV), CryptoStreamMode.Write);
		using StreamWriter streamWriter = new StreamWriter(cryptoStream);
		streamWriter.WriteLine("SAVE " + FTUE_VERSION_NO);
		streamWriter.WriteLine(MusicVolume);
		streamWriter.WriteLine(SFXVolume);
		int speed = (int)Speed;
		streamWriter.WriteLine(speed);
		streamWriter.WriteLine(FTUE_VERSION_NO);
		streamWriter.WriteLine(FTUE);
		streamWriter.WriteLine(NumLaps);
		streamWriter.WriteLine(m_playerData[0].m_profileName);
		streamWriter.WriteLine(m_playerData[0].m_enteredName);
		streamWriter.WriteLine(m_playerData[0].m_customisationData.m_horn);
		streamWriter.WriteLine(m_playerData[0].m_customisationData.m_helmetProp);
		streamWriter.WriteLine(m_playerData[0].m_customisationData.m_dashProp);
		streamWriter.WriteLine(m_playerData[0].m_customisationData.m_dashStyle);
		streamWriter.WriteLine(m_playerData[0].m_customisationData.m_visorProp);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.HelmetPrimary.r);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.HelmetPrimary.g);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.HelmetPrimary.b);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.HelmetSecondary.r);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.HelmetSecondary.g);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.HelmetSecondary.b);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.RacerPrimary.r);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.RacerPrimary.g);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.RacerPrimary.b);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.RacerSecondary.r);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.RacerSecondary.g);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.RacerSecondary.b);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.KartPrimary.r);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.KartPrimary.g);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.KartPrimary.b);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.KartSecondary.r);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.KartSecondary.g);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.KartSecondary.b);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.BoostTrail.r);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.BoostTrail.g);
		streamWriter.WriteLine(m_playerData[0].m_playerColours.BoostTrail.b);
		streamWriter.WriteLine(PlayedProCup);
		for (int i = 0; i < WonChampModeCup.Length; i++)
		{
			streamWriter.WriteLine(WonChampModeCup[i]);
		}
		InputRemapper.InputConfig[] inputConfiguration = InputRemapper.Instance.GetInputConfiguration();
		for (int j = 0; j < inputConfiguration.Length; j++)
		{
			streamWriter.WriteLine((int)inputConfiguration[j].mappedInput);
			streamWriter.WriteLine((!inputConfiguration[j].isAxis) ? "0" : "1");
			streamWriter.WriteLine((!inputConfiguration[j].isNegative) ? "0" : "1");
		}
		for (int k = 0; k < WonChampModeCup2.Length; k++)
		{
			streamWriter.WriteLine(WonChampModeCup2[k]);
		}
		for (int l = 0; l < WonChampModeCupRandom.Length; l++)
		{
			streamWriter.WriteLine(WonChampModeCupRandom[l]);
		}
		streamWriter.Flush();
		cryptoStream.FlushFinalBlock();
	}

	public void ResetColours()
	{
		for (int i = 0; i < PlayerColourData.Length; i++)
		{
			PlayerColourData[i].Used = false;
		}
	}

	private void SetPlayerColourIndex(UnityEngine.Color col, int playerIndex, int colourIndex)
	{
		for (int i = 0; i < CustomisationColours.Length; i++)
		{
			if (CustomisationColours[i] == col)
			{
				m_playerData[playerIndex].m_colourIndex[colourIndex] = i;
				break;
			}
		}
	}

	public void ResetProfile()
	{
		Version = 0f;
		NumLaps = 3;
		PlayedProCup = false;
		for (int i = 0; i < WonChampModeCup.Length; i++)
		{
			WonChampModeCup[i] = false;
		}
		for (int j = 0; j < WonChampModeCup2.Length; j++)
		{
			WonChampModeCup2[j] = false;
		}
		for (int k = 0; k < WonChampModeCupRandom.Length; k++)
		{
			WonChampModeCupRandom[k] = false;
		}
		FTUE = 1;
		MusicVolume = 0.8f;
		SFXVolume = 0.5f;
		Speed = PlayerSpeed.Normal;
		m_playerData[0].m_profileName = "PLAYER";
		m_playerData[0].m_enteredName = 0;
		m_playerData[0].m_aiColourIndex = -1;
		for (int l = 0; l < m_playerData.Length; l++)
		{
			m_playerData[l].m_colourIndex = new int[7];
		}
		m_playerData[0].m_customisationData.m_horn = "Internal_PeepPeep";
		m_playerData[0].m_customisationData.m_helmetProp = string.Empty;
		m_playerData[0].m_customisationData.m_dashProp = string.Empty;
		m_playerData[0].m_customisationData.m_dashStyle = string.Empty;
		m_playerData[0].m_customisationData.m_visorProp = string.Empty;
		m_playerData[0].m_playerColours.HelmetPrimary = PlayerColour[26];
		SetPlayerColourIndex(m_playerData[0].m_playerColours.HelmetPrimary, 0, 0);
		m_playerData[0].m_playerColours.HelmetSecondary = PlayerColour[0];
		SetPlayerColourIndex(m_playerData[0].m_playerColours.HelmetSecondary, 0, 1);
		m_playerData[0].m_playerColours.RacerPrimary = PlayerColour[26];
		SetPlayerColourIndex(m_playerData[0].m_playerColours.RacerPrimary, 0, 2);
		m_playerData[0].m_playerColours.RacerSecondary = PlayerColour[0];
		SetPlayerColourIndex(m_playerData[0].m_playerColours.RacerSecondary, 0, 3);
		m_playerData[0].m_playerColours.KartPrimary = PlayerColour[6];
		SetPlayerColourIndex(m_playerData[0].m_playerColours.KartPrimary, 0, 4);
		m_playerData[0].m_playerColours.KartSecondary = PlayerColour[0];
		SetPlayerColourIndex(m_playerData[0].m_playerColours.KartSecondary, 0, 5);
		m_playerData[0].m_playerColours.BoostTrail = PlayerColour[6];
		SetPlayerColourIndex(m_playerData[0].m_playerColours.BoostTrail, 0, 6);
	}

	private void Awake()
	{
		if (!Instance)
		{
			FTUE = 1;
			playerFile = UnityEngine.Application.persistentDataPath + "/SaveData_GearVR.bin";
			string input = "vpg_vk_go" + SystemInfo.deviceUniqueIdentifier;
			algorithm = TripleDES.Create();
			algorithm.Key = MakeKey(input);
			algorithm.IV = MakeIV(input);
			serviceProvider = new TripleDESCryptoServiceProvider();
			Instance = this;
			Loaded = false;
			ResetProfile();
			LoadProfileData();
		}
	}

	private void Update()
	{
	}

	private void ApplySwearFilter(ref string name)
	{
		bool flag = false;
		string testString;
		do
		{
			flag = false;
			testString = name.ToLower();
			flag |= TestAndReplaceString(ref testString, ref name, "anal");
			flag |= TestAndReplaceString(ref testString, ref name, "anus");
			flag |= TestAndReplaceString(ref testString, ref name, "arse");
			flag |= TestAndReplaceString(ref testString, ref name, "ass");
			flag |= TestAndReplaceString(ref testString, ref name, "ballsack");
			flag |= TestAndReplaceString(ref testString, ref name, "balls");
			flag |= TestAndReplaceString(ref testString, ref name, "bastard");
			flag |= TestAndReplaceString(ref testString, ref name, "bitch");
			flag |= TestAndReplaceString(ref testString, ref name, "biatch");
			flag |= TestAndReplaceString(ref testString, ref name, "bloody");
			flag |= TestAndReplaceString(ref testString, ref name, "blowjob");
			flag |= TestAndReplaceString(ref testString, ref name, "blow job");
			flag |= TestAndReplaceString(ref testString, ref name, "bollock");
			flag |= TestAndReplaceString(ref testString, ref name, "bollok");
			flag |= TestAndReplaceString(ref testString, ref name, "boner");
			flag |= TestAndReplaceString(ref testString, ref name, "boob");
			flag |= TestAndReplaceString(ref testString, ref name, "bugger");
			flag |= TestAndReplaceString(ref testString, ref name, "bum");
			flag |= TestAndReplaceString(ref testString, ref name, "butt");
			flag |= TestAndReplaceString(ref testString, ref name, "buttplug");
			flag |= TestAndReplaceString(ref testString, ref name, "clitoris");
			flag |= TestAndReplaceString(ref testString, ref name, "cock");
			flag |= TestAndReplaceString(ref testString, ref name, "coon");
			flag |= TestAndReplaceString(ref testString, ref name, "crap");
			flag |= TestAndReplaceString(ref testString, ref name, "cunt");
			flag |= TestAndReplaceString(ref testString, ref name, "damn");
			flag |= TestAndReplaceString(ref testString, ref name, "dick");
			flag |= TestAndReplaceString(ref testString, ref name, "dildo");
			flag |= TestAndReplaceString(ref testString, ref name, "dyke");
			flag |= TestAndReplaceString(ref testString, ref name, "fag");
			flag |= TestAndReplaceString(ref testString, ref name, "feck");
			flag |= TestAndReplaceString(ref testString, ref name, "fellate");
			flag |= TestAndReplaceString(ref testString, ref name, "fellatio");
			flag |= TestAndReplaceString(ref testString, ref name, "felching");
			flag |= TestAndReplaceString(ref testString, ref name, "fuck");
			flag |= TestAndReplaceString(ref testString, ref name, "f u c k");
			flag |= TestAndReplaceString(ref testString, ref name, "fudgepacker");
			flag |= TestAndReplaceString(ref testString, ref name, "fudge packer");
			flag |= TestAndReplaceString(ref testString, ref name, "flange");
			flag |= TestAndReplaceString(ref testString, ref name, "Goddamn");
			flag |= TestAndReplaceString(ref testString, ref name, "God damn");
			flag |= TestAndReplaceString(ref testString, ref name, "hell");
			flag |= TestAndReplaceString(ref testString, ref name, "homo");
			flag |= TestAndReplaceString(ref testString, ref name, "jerk");
			flag |= TestAndReplaceString(ref testString, ref name, "jizz");
			flag |= TestAndReplaceString(ref testString, ref name, "knobend");
			flag |= TestAndReplaceString(ref testString, ref name, "knob end");
			flag |= TestAndReplaceString(ref testString, ref name, "labia");
			flag |= TestAndReplaceString(ref testString, ref name, "lmao");
			flag |= TestAndReplaceString(ref testString, ref name, "lmfao");
			flag |= TestAndReplaceString(ref testString, ref name, "muff");
			flag |= TestAndReplaceString(ref testString, ref name, "nigger");
			flag |= TestAndReplaceString(ref testString, ref name, "nigga");
			flag |= TestAndReplaceString(ref testString, ref name, "nob");
			flag |= TestAndReplaceString(ref testString, ref name, "omg");
			flag |= TestAndReplaceString(ref testString, ref name, "penis");
			flag |= TestAndReplaceString(ref testString, ref name, "piss");
			flag |= TestAndReplaceString(ref testString, ref name, "poop");
			flag |= TestAndReplaceString(ref testString, ref name, "prick");
			flag |= TestAndReplaceString(ref testString, ref name, "pube");
			flag |= TestAndReplaceString(ref testString, ref name, "pussy");
			flag |= TestAndReplaceString(ref testString, ref name, "queer");
			flag |= TestAndReplaceString(ref testString, ref name, "scrotum");
			flag |= TestAndReplaceString(ref testString, ref name, "sex");
			flag |= TestAndReplaceString(ref testString, ref name, "shit");
			flag |= TestAndReplaceString(ref testString, ref name, "s hit");
			flag |= TestAndReplaceString(ref testString, ref name, "sh1t");
			flag |= TestAndReplaceString(ref testString, ref name, "slut");
			flag |= TestAndReplaceString(ref testString, ref name, "smegma");
			flag |= TestAndReplaceString(ref testString, ref name, "spunk");
			flag |= TestAndReplaceString(ref testString, ref name, "tit");
			flag |= TestAndReplaceString(ref testString, ref name, "tosser");
			flag |= TestAndReplaceString(ref testString, ref name, "turd");
			flag |= TestAndReplaceString(ref testString, ref name, "twat");
			flag |= TestAndReplaceString(ref testString, ref name, "vagina");
			flag |= TestAndReplaceString(ref testString, ref name, "wank");
			flag |= TestAndReplaceString(ref testString, ref name, "whore");
		}
		while (flag | TestAndReplaceString(ref testString, ref name, "wtf"));
	}

	private bool TestAndReplaceString(ref string testString, ref string actualName, string swearWord)
	{
		bool result = false;
		string new_text = new string('#', swearWord.Length);
		if (testString.Contains(swearWord))
		{
			int num = actualName.IndexOf(swearWord);
			if (num >= 0)
			{
				actualName = Overwrite(actualName, num, new_text);
				result = true;
			}
			swearWord = swearWord.ToUpper();
			num = actualName.IndexOf(swearWord);
			if (num >= 0)
			{
				actualName = Overwrite(actualName, num, new_text);
				result = true;
			}
		}
		return result;
	}

	private string Overwrite(string text, int position, string new_text)
	{
		return text.Substring(0, position) + new_text + text.Substring(position + new_text.Length);
	}

	private byte[] MakeKey(string input)
	{
		string s = input.PadRight(KeyLength, '0').Substring(0, KeyLength);
		return Encoding.ASCII.GetBytes(s);
	}

	private byte[] MakeIV(string input)
	{
		string s = input.PadRight(IVLength, '0').Substring(0, IVLength);
		return Encoding.ASCII.GetBytes(s);
	}
}
public class SetCorrectWingMirrorTexture : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private RenderTexture m_gearVRRenderTexture;

	[SerializeField]
	private RenderTexture m_oculusGoRenderTexture;

	private void Start()
	{
		if (GameSystem.Instance.IsOculusGo())
		{
			GetComponent<Camera>().targetTexture = m_oculusGoRenderTexture;
		}
		else
		{
			GetComponent<Camera>().targetTexture = m_gearVRRenderTexture;
		}
	}

	private void Update()
	{
	}
}
public class Bee : UnityEngine.MonoBehaviour
{
	private enum BeeState
	{
		None,
		Buzzing,
		Finish
	}

	[SerializeField]
	private AudioSource BeeAudio;

	private BeeWeapon m_weapon;

	private Player m_player;

	private BeeState m_state;

	private float m_angle;

	private float m_beeMovementTime;

	private Vector3 m_targetPosition;

	private Vector3 m_rotation;

	public void StartBuzzing(ref BeeWeapon weapon, ref Player player, int index)
	{
		m_weapon = weapon;
		m_player = player;
		m_angle = UnityEngine.Random.Range(0f, 360f);
		m_state = BeeState.Buzzing;
		m_beeMovementTime = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(BeeWeapon.BeeTimeRange.x, BeeWeapon.BeeTimeRange.y);
		m_rotation = new Vector3(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), 0f);
		if (index == 0)
		{
			BeeAudio.volume = 0f;
			BeeAudio.Play();
		}
	}

	public void Finish()
	{
		Vector3 position = base.transform.position;
		if (m_weapon != null)
		{
			base.transform.parent = m_weapon.transform;
		}
		base.transform.position = position;
		m_targetPosition = m_player.transform.position;
		m_targetPosition += m_player.transform.forward * 5f;
		m_targetPosition += Vector3.up * 2f;
		Quaternion quaternion = Quaternion.Euler(Vector3.up * UnityEngine.Random.Range(-45f, 45f));
		m_targetPosition = quaternion * m_targetPosition;
		m_state = BeeState.Finish;
	}

	public void TurnOff()
	{
		base.gameObject.SetActive(value: false);
		m_state = BeeState.None;
	}

	private void Awake()
	{
		m_state = BeeState.None;
	}

	private void Update()
	{
		if (BeeAudio.isPlaying)
		{
			BeeAudio.volume = Mathf.Lerp(BeeAudio.volume, 1f, 6f * GameTime.Instance.DeltaTime());
		}
		switch (m_state)
		{
		case BeeState.None:
			break;
		case BeeState.Buzzing:
		{
			Vector3 vector = new Vector3(0f, 0f, m_weapon.PlayerRadius);
			Quaternion quaternion = Quaternion.Euler(m_rotation * m_angle);
			vector = quaternion * vector;
			m_angle += BeeWeapon.BeeMovement * GameTime.Instance.DeltaTime();
			m_targetPosition = vector;
			m_targetPosition += Vector3.forward * m_weapon.PlayerPositionOffset.z;
			m_targetPosition += Vector3.up * m_weapon.PlayerPositionOffset.y;
			m_targetPosition += Vector3.right * m_weapon.PlayerPositionOffset.x;
			base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, m_targetPosition, BeeWeapon.BeeSpeed * GameTime.Instance.DeltaTime());
			base.transform.localRotation = Quaternion.LookRotation((m_targetPosition - base.transform.localPosition).normalized);
			if (GameTime.Instance.CurrentTime() > m_beeMovementTime)
			{
				m_beeMovementTime = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(BeeWeapon.BeeTimeRange.x, BeeWeapon.BeeTimeRange.y);
				m_rotation = new Vector3(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), 0f);
			}
			break;
		}
		case BeeState.Finish:
			TurnOff();
			break;
		}
	}
}
public class BeeWeapon : WeaponBase
{
	private enum HiveState
	{
		None,
		MoveToTarget,
		DropHive,
		ReleaseBees,
		WaitForEnd
	}

	[SerializeField]
	private GameObject BeeHiveObject;

	[SerializeField]
	private GameObject QueenBee;

	[SerializeField]
	private ParticleSystem HiveExplosion;

	[SerializeField]
	private Bee BeePrefab;

	[SerializeField]
	private float ShakeAngle = 20f;

	[SerializeField]
	private int NumShakesBeforeFinish = 6;

	[SerializeField]
	private AudioSource BeeHiveLoop;

	[SerializeField]
	private AudioSource BeeHiveSFXSource;

	[SerializeField]
	private AudioSource BeeHiveExplosionSource;

	[SerializeField]
	private AudioClip HiveFall;

	[SerializeField]
	private AudioClip[] HiveLand;

	[SerializeField]
	private AudioClip[] HiveSmash;

	public float PlayerRadius = 1.2f;

	public static float BeeMovement = 250f;

	public static float BeeSpeed = 20f;

	public static Vector2 BeeTimeRange = new Vector2(3f, 8f);

	private Vector3 BeeHiveDestination = new Vector3(0f, -0.625f, -0.142f);

	[HideInInspector]
	public int PlayAudioOnIndex = 3;

	private const float HiveHeightAbovePlayer = 4f;

	private const float QueenHiveOffset = 1.51f;

	private const float TargetSteeringScale = 0.5f;

	private int NumBees = 4;

	private Bee[] m_beeInstance;

	private Player m_player;

	private Player m_target;

	private Vector3 HumanPlayerOffset = new Vector3(0f, 1f, -0.5f);

	private Vector3 NonHumanOffset = new Vector3(0f, 1f, 0f);

	private int m_shakeIndex;

	private float m_previousShakeAngle;

	private float m_repoolTimer;

	private float m_shakeTimeout;

	private const float MinAITime = 3f;

	private const float MaxAITime = 8f;

	private const float HumanPlayerTimeout = 8f;

	private const float MovementSpeed = 50f;

	private Vector3 m_targetPosition;

	private float m_targetDistance;

	private float m_targetWidth;

	private SplitLane m_currentSplitLane;

	private float m_previousProgress;

	private VRWaypointCircuit.RoutePoint m_point = default(VRWaypointCircuit.RoutePoint);

	private HiveState m_hiveState;

	private bool m_queenBeeFinished;

	private Vector3 m_startLocalPosition;

	private Vector3 CameraPositionOffset = new Vector3(0f, -0.254f, 0f);

	private Vector3 CameraRotationOffset = new Vector3(-90f, 0f, 0f);

	public Vector3 PlayerPositionOffset => (m_target.GetPlayerType() != 0) ? NonHumanOffset : HumanPlayerOffset;

	public void SetPlayer(Player player, Player target)
	{
		m_player = player;
		m_target = target;
		InitWeapon();
		SetupPath();
	}

	private void SetupPath()
	{
		m_currentSplitLane = null;
		if (m_player.InSplitLane(ref m_currentSplitLane))
		{
			int wayPoint = 0;
			int wayPoint2 = 0;
			float closestPointOnTrack = m_currentSplitLane.GetClosestPointOnTrack(m_player.transform.position, ref wayPoint, ref wayPoint2);
			m_targetDistance = m_currentSplitLane.ConvertWaypointDistanceToDistances(closestPointOnTrack);
			closestPointOnTrack = Gameplay.Instance.GetCircuitPath().GetClosestPointOnTrack(m_currentSplitLane.Waypoints[m_currentSplitLane.Waypoints.Count - 1].position, ref wayPoint, ref wayPoint2);
			m_previousProgress = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(closestPointOnTrack);
			m_previousProgress += 10f;
			m_targetWidth = 0f;
		}
		else
		{
			m_targetDistance = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(m_player.PointOnTrack(singleLapOnly: true));
		}
		if (m_currentSplitLane == null)
		{
			VRWaypointCircuit.RoutePoint routePoint = Gameplay.Instance.GetCircuitPath().GetRoutePoint(m_targetDistance);
			Vector3 vector = new Vector3(routePoint.position.x, 0f, routePoint.position.z);
			m_targetWidth = (vector - new Vector3(m_player.transform.position.x, 0f, m_player.transform.position.z)).magnitude;
			Vector3 lhs = Vector3.Cross(routePoint.direction, Vector3.up);
			Vector3 rhs = new Vector3(m_player.transform.position.x, 0f, m_player.transform.position.z) - vector;
			rhs.Normalize();
			if (Vector3.Dot(lhs, rhs) < 0f)
			{
				m_targetWidth = 0f - m_targetWidth;
			}
		}
		m_targetDistance += 10f;
		QueenBee.transform.position = m_player.transform.position + m_target.transform.up * 5.51f;
		BeeHiveObject.transform.localPosition = new Vector3(0f, -1.51f, 0f);
	}

	public bool HasTargetPlayer(Player player)
	{
		return m_target == player;
	}

	public override void ReadyToRepool()
	{
		if ((bool)m_target)
		{
			m_target.GetKartGeometry().HelmetRenderer.enabled = true;
			m_target.GetKartGeometry().GetComponent<AccessoryLocator>().EnableObjectByLocatorType(AccessoryLocator.LocatorType.Acc_Visor, enable: true);
			m_target.GetKartGeometry().GetComponent<AccessoryLocator>().EnableObjectByLocatorType(AccessoryLocator.LocatorType.Acc_Top, enable: true);
		}
		if ((bool)BeeHiveObject && BeeHiveObject.activeSelf)
		{
			BeeHiveObject.transform.parent = base.transform;
			BeeHiveObject.SetActive(value: false);
			BeeHiveLoop.Stop();
		}
	}

	private void Awake()
	{
		BeeHiveObject.SetActive(value: false);
		QueenBee.SetActive(value: false);
		m_beeInstance = new Bee[NumBees];
		for (int i = 0; i < NumBees; i++)
		{
			m_beeInstance[i] = UnityEngine.Object.Instantiate(BeePrefab);
			m_beeInstance[i].transform.parent = base.transform;
			m_beeInstance[i].gameObject.SetActive(value: false);
		}
	}

	private void OnDisable()
	{
		if ((bool)m_target)
		{
			KartDashboard component = m_target.GetComponent<KartDashboard>();
			if ((bool)component)
			{
				component.EnableDashboard();
			}
		}
		m_target = null;
		for (int i = 0; i < NumBees; i++)
		{
			if (m_beeInstance[i].gameObject.activeSelf)
			{
				m_beeInstance[i].TurnOff();
			}
		}
	}

	private void Update()
	{
		if ((bool)m_target && m_target.PlayerFinishState != 0 && m_target.FinishedWithBees)
		{
			FinishedWithBees();
			m_target.FinishedWithBees = false;
			return;
		}
		if (m_target.GetPlayerType() == Player.PlayerType.Network && m_target.FinishedWithBees)
		{
			ExplodeHive();
			FinishedWithBees();
			m_target.FinishedWithBees = false;
		}
		if (m_queenBeeFinished)
		{
			Vector3 normalized = (QueenBee.transform.position - m_startLocalPosition).normalized;
			if (normalized.sqrMagnitude > 0f)
			{
				QueenBee.transform.localRotation = Quaternion.Slerp(QueenBee.transform.localRotation, Quaternion.LookRotation(normalized), 4f * GameTime.Instance.DeltaTime());
			}
			QueenBee.transform.position = Vector3.MoveTowards(QueenBee.transform.position, m_startLocalPosition, 10f * GameTime.Instance.DeltaTime());
			if ((QueenBee.transform.position - m_startLocalPosition).sqrMagnitude < 0.5f)
			{
				QueenBee.SetActive(value: false);
				m_queenBeeFinished = true;
			}
		}
		switch (m_hiveState)
		{
		case HiveState.None:
			break;
		case HiveState.MoveToTarget:
			break;
		case HiveState.DropHive:
		{
			if (m_target.GetPlayerType() != 0)
			{
				CheckForDriverFar();
			}
			Vector3 target = ((m_target.GetPlayerType() != 0) ? Vector3.zero : BeeHiveDestination);
			BeeHiveObject.transform.localPosition = Vector3.MoveTowards(BeeHiveObject.transform.localPosition, target, 8f * GameTime.Instance.DeltaTime());
			if (!(Mathf.Abs(BeeHiveObject.transform.localPosition.y - target.y) < 0.2f))
			{
				break;
			}
			if (BeeHiveSFXSource.enabled)
			{
				BeeHiveSFXSource.clip = HiveLand[UnityEngine.Random.Range(0, HiveLand.Length)];
				BeeHiveSFXSource.Play();
			}
			if (m_target.GetPlayerType() == Player.PlayerType.Human)
			{
				BeeHiveObject.transform.parent = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform;
			}
			else if (m_target.GetPlayerType() == Player.PlayerType.AI)
			{
				KartController component = m_target.GetComponent<KartController>();
				if ((bool)component)
				{
					component.EnableReverseControls(0.1f);
				}
			}
			m_hiveState = HiveState.ReleaseBees;
			KartDashboard component2 = m_target.GetComponent<KartDashboard>();
			if ((bool)component2)
			{
				component2.DisableDashboard();
			}
			if (m_target.GetPlayerType() == Player.PlayerType.AI)
			{
				m_shakeTimeout = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(3f, 8f);
			}
			else
			{
				m_shakeTimeout = GameTime.Instance.CurrentTime() + 8f;
			}
			m_target.GetKartGeometry().HelmetRenderer.enabled = false;
			m_target.GetKartGeometry().GetComponent<AccessoryLocator>().EnableObjectByLocatorType(AccessoryLocator.LocatorType.Acc_Visor, enable: false);
			m_target.GetKartGeometry().GetComponent<AccessoryLocator>().EnableObjectByLocatorType(AccessoryLocator.LocatorType.Acc_Top, enable: false);
			BeeHiveObject.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
			BeeHiveObject.transform.localPosition = Vector3.zero;
			break;
		}
		case HiveState.ReleaseBees:
		{
			CheckForDriverFar();
			if (m_target.GetPlayerType() == Player.PlayerType.Human)
			{
				PlayerRadius = 0.8f;
			}
			else
			{
				PlayerRadius = 1f;
			}
			for (int j = 0; j < m_beeInstance.Length; j++)
			{
				BeeWeapon weapon = this;
				m_beeInstance[j].gameObject.SetActive(value: true);
				m_beeInstance[j].StartBuzzing(ref weapon, ref m_target, j);
				m_beeInstance[j].transform.parent = m_target.GetKartGeometry().transform;
				Vector3 vector = -m_player.transform.forward;
				Quaternion quaternion = Quaternion.Euler(Vector3.up * UnityEngine.Random.Range(-90f, 90f));
				vector = quaternion * vector;
				vector.y += 2f;
				m_beeInstance[j].transform.position = vector + m_player.transform.position;
			}
			m_hiveState = HiveState.WaitForEnd;
			break;
		}
		case HiveState.WaitForEnd:
			CheckForDriverFar();
			if (m_repoolTimer == 0f)
			{
				WaitForPlayerShake();
			}
			else if (GameTime.Instance.CurrentTime() > m_repoolTimer)
			{
				for (int i = 0; i < NumBees; i++)
				{
					m_beeInstance[i].gameObject.SetActive(value: false);
				}
				HiveExplosion.Stop();
				HiveExplosion.gameObject.SetActive(value: false);
				m_target = null;
				m_hiveState = HiveState.None;
				WeaponManager.Instance.RepoolObject(base.gameObject);
			}
			break;
		}
	}

	private void FixedUpdate()
	{
		if (m_hiveState == HiveState.MoveToTarget)
		{
			UpdateMovement();
		}
	}

	private void UpdateMovement()
	{
		int wayPoint = 0;
		int wayPoint2 = 0;
		float num = 0f;
		SplitLane lane = null;
		SplitLane lane2 = null;
		VRWaypointCircuit circuitPath = Gameplay.Instance.GetCircuitPath();
		if (m_currentSplitLane == null)
		{
			num = circuitPath.GetClosestPointOnTrack(QueenBee.transform.position, ref wayPoint, ref wayPoint2);
			if (m_target.InSplitLane(ref lane) && circuitPath.IsWaypointASplitLane(wayPoint, ref lane2) && lane2 == lane)
			{
				m_currentSplitLane = lane;
				m_previousProgress = m_targetDistance;
				for (int i = wayPoint; i < wayPoint2; i++)
				{
					int num2 = (i + 1) % circuitPath.Waypoints.Length;
					m_previousProgress += (circuitPath.Waypoints[num2].position - circuitPath.Waypoints[i].position).magnitude;
				}
				m_targetDistance = 20f;
			}
		}
		m_targetDistance += 50f * GameTime.Instance.SmoothedDeltaTime();
		if (m_currentSplitLane != null)
		{
			if (m_currentSplitLane.HitEndOfSpline(m_targetDistance))
			{
				m_currentSplitLane = null;
				m_targetDistance = m_previousProgress;
			}
			else
			{
				m_point = m_currentSplitLane.GetRoutePoint(m_targetDistance);
			}
		}
		else
		{
			m_point = Gameplay.Instance.GetCircuitPath().GetRoutePoint(m_targetDistance);
		}
		m_targetPosition = new Vector3(m_point.position.x, m_point.position.y, m_point.position.z);
		Vector3 direction = m_point.direction;
		direction = Vector3.Cross(direction, Vector3.up);
		direction *= m_targetWidth;
		m_targetPosition += direction;
		SplitLane lane3 = null;
		if (m_currentSplitLane == null && !m_target.InSplitLane(ref lane3))
		{
			float dist = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(m_target.PointOnTrack(singleLapOnly: true));
			VRWaypointCircuit.RoutePoint routePoint = Gameplay.Instance.GetCircuitPath().GetRoutePoint(dist);
			Vector3 vector = new Vector3(routePoint.position.x, 0f, routePoint.position.z);
			float num3 = (vector - new Vector3(m_target.transform.position.x, 0f, m_target.transform.position.z)).magnitude;
			Vector3 lhs = Vector3.Cross(routePoint.direction, Vector3.up);
			Vector3 rhs = new Vector3(m_target.transform.position.x, 0f, m_target.transform.position.z) - vector;
			rhs.Normalize();
			if (Vector3.Dot(lhs, rhs) < 0f)
			{
				num3 = 0f - num3;
			}
			m_targetWidth = Mathf.Lerp(m_targetWidth, num3, 20f * GameTime.Instance.SmoothedDeltaTime());
		}
		else
		{
			m_targetWidth = Mathf.Lerp(m_targetWidth, 0f, 20f * GameTime.Instance.SmoothedDeltaTime());
		}
		Vector3 position = QueenBee.transform.position;
		m_targetPosition += m_target.transform.up * 5.51f;
		QueenBee.transform.position = Vector3.Lerp(QueenBee.transform.position, m_targetPosition, 8f * GameTime.Instance.SmoothedDeltaTime());
		BeeHiveObject.transform.localPosition = Vector3.Lerp(BeeHiveObject.transform.localPosition, new Vector3(0f, -1.51f, 0f), 2f * GameTime.Instance.DeltaTime());
		QueenBee.transform.rotation = Quaternion.LookRotation((position - QueenBee.transform.position).normalized);
		BeeHiveObject.transform.rotation = QueenBee.transform.rotation * Quaternion.AngleAxis(180f, Vector3.up);
		float num4 = m_target.PointOnTrack(singleLapOnly: true) - num;
		if ((m_currentSplitLane == null && ((num4 > 0f && num4 < 0.025f) || (num4 <= 0f && num4 > -0.025f))) || (new Vector3(QueenBee.transform.position.x, 0f, QueenBee.transform.position.z) - new Vector3(m_target.transform.position.x, 0f, m_target.transform.position.z)).sqrMagnitude < 25f)
		{
			m_hiveState = HiveState.DropHive;
			m_queenBeeFinished = true;
			QueenBee.transform.parent = base.transform;
			BeeHiveSFXSource.clip = HiveFall;
			BeeHiveSFXSource.Play();
			BeeHiveObject.transform.parent = m_target.GetKartGeometry().BeeHiveNear;
			BeeHiveObject.transform.GetChild(0).localRotation = Quaternion.identity;
			BeeHiveObject.transform.GetChild(0).localPosition = Vector3.zero;
			BeeHiveObject.transform.GetChild(0).localScale = new Vector3(1.3f, 1.3f, 1.3f);
			BeeHiveObject.transform.localPosition = Vector3.zero;
			BeeHiveObject.transform.localScale = Vector3.one;
			BeeHiveObject.transform.localRotation = Quaternion.identity;
			m_startLocalPosition += QueenBee.transform.position;
		}
	}

	private void CheckForDriverFar()
	{
		if (m_target == null)
		{
			return;
		}
		if (m_target.GetPlayerType() == Player.PlayerType.Human)
		{
			BeeHiveObject.transform.localPosition = CameraPositionOffset;
			BeeHiveObject.transform.localEulerAngles = CameraRotationOffset;
			return;
		}
		if ((bool)m_target.GetKartGeometry().GetComponent<AILOD>())
		{
			switch (m_target.GetKartGeometry().GetComponent<AILOD>().GetCurrentLOD())
			{
			case AILOD.LODChangeData.FarAway:
				if (BeeHiveObject.transform.parent != m_target.GetKartGeometry().BeeHiveFar)
				{
					BeeHiveObject.transform.parent = m_target.GetKartGeometry().BeeHiveFar;
				}
				BeeHiveObject.transform.GetChild(0).localRotation = Quaternion.identity;
				BeeHiveObject.transform.GetChild(0).localPosition = Vector3.zero;
				BeeHiveObject.transform.GetChild(0).localScale = new Vector3(1.3f, 1.3f, 1.3f);
				BeeHiveObject.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
				BeeHiveObject.transform.localPosition = Vector3.zero;
				BeeHiveObject.transform.localScale = Vector3.one;
				return;
			case AILOD.LODChangeData.LOD0:
				if (BeeHiveObject.transform.parent != m_target.GetKartGeometry().BeeHiveLOD0)
				{
					BeeHiveObject.transform.parent = m_target.GetKartGeometry().BeeHiveLOD0;
				}
				BeeHiveObject.transform.GetChild(0).localRotation = Quaternion.identity;
				BeeHiveObject.transform.GetChild(0).localPosition = Vector3.zero;
				BeeHiveObject.transform.GetChild(0).localScale = new Vector3(1.3f, 1.3f, 1.3f);
				BeeHiveObject.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
				BeeHiveObject.transform.localPosition = Vector3.zero;
				BeeHiveObject.transform.localScale = Vector3.one;
				return;
			}
		}
		if (BeeHiveObject.transform.parent != m_target.GetKartGeometry().BeeHiveNear)
		{
			BeeHiveObject.transform.parent = m_target.GetKartGeometry().BeeHiveNear;
		}
		BeeHiveObject.transform.GetChild(0).localRotation = Quaternion.identity;
		BeeHiveObject.transform.GetChild(0).localPosition = Vector3.zero;
		BeeHiveObject.transform.GetChild(0).localScale = new Vector3(1.3f, 1.3f, 1.3f);
		BeeHiveObject.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
		BeeHiveObject.transform.localPosition = Vector3.zero;
		BeeHiveObject.transform.localScale = Vector3.one;
	}

	private void RemoveBeeHive()
	{
		if (BeeHiveObject.activeSelf)
		{
			BeeHiveObject.transform.parent = base.transform;
			BeeHiveObject.SetActive(value: false);
			BeeHiveLoop.Stop();
		}
		if ((bool)m_target)
		{
			m_target.GetKartGeometry().HelmetRenderer.enabled = true;
			m_target.GetKartGeometry().GetComponent<AccessoryLocator>().EnableObjectByLocatorType(AccessoryLocator.LocatorType.Acc_Visor, enable: true);
			m_target.GetKartGeometry().GetComponent<AccessoryLocator>().EnableObjectByLocatorType(AccessoryLocator.LocatorType.Acc_Top, enable: true);
			KartDashboard component = m_target.GetComponent<KartDashboard>();
			if ((bool)component)
			{
				component.EnableDashboard();
			}
		}
	}

	private void WaitForPlayerShake()
	{
		bool flag = false;
		if (m_target.GetPlayerType() == Player.PlayerType.Human)
		{
			float num = Vector3.Angle(CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward, m_target.transform.forward);
			if (Mathf.Abs(m_previousShakeAngle) < ShakeAngle && Mathf.Abs(num) >= ShakeAngle)
			{
				m_shakeIndex++;
			}
			m_previousShakeAngle = num;
			if (m_shakeIndex > NumShakesBeforeFinish)
			{
				flag = true;
			}
		}
		if (!flag && GameTime.Instance.CurrentTime() > m_shakeTimeout)
		{
			flag = true;
			if (m_target.GetPlayerType() == Player.PlayerType.AI)
			{
				m_target.GetComponent<KartController>().DisableReverseControls();
			}
		}
		if (flag)
		{
			if (m_target.GetPlayerType() == Player.PlayerType.Human && NetworkLogin.Instance != null)
			{
				NetworkLogin.Instance.GetClient().SetCharacterListEvent(m_target.SeatIndex, NetworkClient.EventMask.FinishedWithBees);
			}
			ExplodeHive();
			FinishedWithBees();
		}
	}

	private void ExplodeHive()
	{
		HiveExplosion.transform.position = BeeHiveObject.transform.position;
		HiveExplosion.gameObject.SetActive(value: true);
		HiveExplosion.Play();
		BeeHiveObject.SetActive(value: false);
	}

	private void FinishedWithBees()
	{
		RemoveBeeHive();
		m_repoolTimer = GameTime.Instance.CurrentTime() + 5f;
		for (int i = 0; i < m_beeInstance.Length; i++)
		{
			m_beeInstance[i].Finish();
		}
		m_hiveState = HiveState.WaitForEnd;
	}

	private void InitWeapon()
	{
		m_hiveState = HiveState.MoveToTarget;
		m_queenBeeFinished = false;
		BeeHiveObject.SetActive(value: true);
		QueenBee.SetActive(value: true);
		BeeHiveLoop.Play();
		BeeHiveObject.transform.parent = QueenBee.transform;
		m_startLocalPosition = (m_target.transform.position - m_player.transform.position).normalized;
		m_startLocalPosition *= 30f;
		m_startLocalPosition.y = 20f;
		m_shakeIndex = 0;
		m_repoolTimer = 0f;
	}
}
public class BombheadWeapon : WeaponBase
{
	[SerializeField]
	private AudioSource BombExplosionAudio;

	private const float ProjectileForce = 1800f;

	[SerializeField]
	private float BombTimer = 5f;

	private Player m_player;

	private Player m_targetPlayer;

	private bool m_rest;

	private float m_bombTimer;

	public void SetPlayer(Player player, Player target)
	{
		if (GameSystem.Instance.BombHeadMode)
		{
			target.GetComponent<BombheadBehaviour>().enabled = true;
			Gameplay.Instance.GetWeaponManager().RepoolObject(base.gameObject);
			return;
		}
		m_player = player;
		m_targetPlayer = target;
		Vector3 vector = m_targetPlayer.transform.position - m_player.transform.position;
		vector.Normalize();
		base.transform.GetComponent<Rigidbody>().AddForce(vector * 1800f, ForceMode.Force);
	}

	private void OnEnable()
	{
		InitWeapon();
	}

	private void Start()
	{
		InitWeapon();
	}

	private void InitWeapon()
	{
		m_rest = false;
		m_bombTimer = 0f;
	}

	private void Update()
	{
		if (m_rest)
		{
			GetComponent<Rigidbody>().velocity = Vector3.Lerp(GetComponent<Rigidbody>().velocity, Vector3.zero, 2f * GameTime.Instance.DeltaTime());
			if (Time.time > m_bombTimer)
			{
				Explode();
			}
		}
	}

	private void Explode()
	{
		Gameplay.Instance.GetWeaponManager().CreateImpactEffect(base.gameObject, base.transform.position, WeaponManager.WeaponType.Bombhead);
		AudioSource audioSource = UnityEngine.Object.Instantiate(BombExplosionAudio);
		audioSource.name = "BombExplosionAudio";
		audioSource.transform.position = base.transform.position;
		audioSource.GetComponent<AudioSource>().Play();
		UnityEngine.Object.Destroy(audioSource.gameObject, 3f);
		Gameplay.Instance.GetWeaponManager().RepoolObject(base.gameObject);
	}

	private void OnTriggerEnter(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void OnTriggerStay(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void OnTriggerExit(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void DetectedCollision(GameObject obj)
	{
		if (obj.layer == 17)
		{
			Transform parent = obj.transform;
			Player player = null;
			while ((bool)parent.parent && parent.GetComponent<Player>() == null)
			{
				parent = parent.parent;
			}
			player = parent.GetComponent<Player>();
			if (m_rest)
			{
				Explode();
			}
			else if (player != m_player)
			{
				if (player.IsShieldEnabled())
				{
					Explode();
					return;
				}
				player.GetComponent<BombheadBehaviour>().enabled = true;
				Gameplay.Instance.GetWeaponManager().RepoolObject(base.gameObject);
			}
		}
		else if (obj.layer == 14 && !m_rest)
		{
			m_rest = true;
			m_bombTimer = Time.time + BombTimer;
		}
	}
}
public class Mine_Proximity : WeaponBase
{
	[SerializeField]
	private float ExplosionRadius = 2f;

	[SerializeField]
	private AudioSource MineImpactAudio;

	[SerializeField]
	private AudioClip[] MineImpactSFX;

	private Player m_minePlayer;

	private bool m_okToBeHitBySelf;

	public void SetPlayer(Player player)
	{
		m_minePlayer = player;
		InitWeapon();
	}

	private void InitWeapon()
	{
		m_okToBeHitBySelf = false;
		AudioSource component = GetComponent<AudioSource>();
		component.clip = MineImpactSFX[UnityEngine.Random.Range(0, MineImpactSFX.Length)];
		component.Play();
	}

	private void Update()
	{
		if ((bool)m_minePlayer && !m_okToBeHitBySelf)
		{
			Vector3 position = m_minePlayer.transform.position;
			position.y = 0f;
			Vector3 position2 = base.transform.position;
			position2.y = 0f;
			float sqrMagnitude = (position - position2).sqrMagnitude;
			if (sqrMagnitude > (ExplosionRadius + 2f) * (ExplosionRadius + 2f))
			{
				m_okToBeHitBySelf = true;
			}
		}
		List<Player> playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < playerList.Count; i++)
		{
			if (!playerList[i] || (!(playerList[i] != m_minePlayer) && !m_okToBeHitBySelf))
			{
				continue;
			}
			Vector3 position3 = playerList[i].transform.position;
			position3.y = 0f;
			Vector3 position4 = base.transform.position;
			position4.y = 0f;
			float sqrMagnitude2 = (position3 - position4).sqrMagnitude;
			if (sqrMagnitude2 < ExplosionRadius * ExplosionRadius)
			{
				playerList[i].HitByWeapon();
				if (playerList[i].GetPlayerType() == Player.PlayerType.Human && (bool)ForceFeedback.Instance)
				{
					ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.KartCollision);
				}
				DestroyMine();
			}
		}
	}

	public void DestroyMine()
	{
		WeaponManager.Instance.CreateImpactEffect(null, base.transform.position + base.transform.up * 0.1f, WeaponManager.WeaponType.Mine);
		AudioSource audioSource = UnityEngine.Object.Instantiate(MineImpactAudio);
		audioSource.name = "WeaponAudioImpact";
		audioSource.transform.position = base.transform.position;
		audioSource.Play();
		UnityEngine.Object.Destroy(audioSource.gameObject, 3f);
		Gameplay.Instance.MineList.Remove(this);
		WeaponManager.Instance.RepoolObject(base.gameObject);
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.blue;
		Gizmos.DrawWireSphere(base.transform.position, ExplosionRadius);
	}
}
public class NitroWeapon : WeaponBase
{
	public void SetPlayer(Player player)
	{
		float num = 1f / (float)(PlayerManager.Instance.MaxPlayers - 1) * (float)player.CurrentRaceOrder;
		if (num < 0.2f)
		{
			num = 0.2f;
		}
		player.AddBoostAmount(num);
	}
}
public class PortalCollision : WeaponBase
{
	[SerializeField]
	private PortalWeapon WeaponParent;

	private float m_hitByWeaponTimer;

	private void OnTriggerEnter(Collider col)
	{
		TeleportPlayer(col);
	}

	private void OnTriggerStay(Collider col)
	{
		TeleportPlayer(col);
	}

	private void TeleportPlayer(Collider col)
	{
		Transform parent = col.transform;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if (!parent)
		{
			return;
		}
		Player component = parent.gameObject.GetComponent<Player>();
		if (component == WeaponParent.GetParent())
		{
			if (WeaponParent.TeleportAvailable())
			{
				WeaponParent.TeleportPlayer();
			}
		}
		else if (GameTime.Instance.CurrentTime() > m_hitByWeaponTimer)
		{
			component.HitByWeapon();
			m_hitByWeaponTimer = GameTime.Instance.CurrentTime() + 0.2f;
			WeaponParent.FailedTeleport();
		}
	}
}
public class PortalWeapon : WeaponBase
{
	private enum TeleportState
	{
		None,
		Rise,
		WaitForTeleport,
		Teleported,
		FinishedTeleport,
		Lower
	}

	[SerializeField]
	private GameObject PortalObjectEntrance;

	[SerializeField]
	private GameObject PortalObjectExit;

	[SerializeField]
	private AudioSource EntranceAudioSource;

	[SerializeField]
	private AudioSource ExitAudioSource;

	[SerializeField]
	private AudioClip PortalEnterClip;

	[SerializeField]
	private AudioClip PortalExitClip;

	[SerializeField]
	private AudioClip PortalOpenClip;

	[SerializeField]
	private AudioClip PortalWrongClip;

	[SerializeField]
	private AudioClip PortalHumLoop;

	private const float EntranceSpeed = 4f;

	private const float ExitSpeed = 2f;

	private const float PortalTeleportDistance = 5f;

	private const float PortalOpenDistance = 0.6f;

	private const float PortalEntranceSpeedOffset = 0.8f;

	private Player m_player;

	private VRWaypointCircuit.RoutePoint m_entrancePosition;

	private VRWaypointCircuit.RoutePoint m_exitPosition;

	private float m_exitTimer;

	private float m_scaleOffset;

	private float m_portalSplineOffset;

	private const float ExitTimer = 2f;

	private float m_portalTeleportTimer;

	private TeleportState m_teleportState;

	private float m_portalEntrancePoint;

	public void SetPlayer(Player player)
	{
		m_player = player;
		InitWeapon();
	}

	public Player GetParent()
	{
		return m_player;
	}

	public bool TeleportAvailable()
	{
		return m_teleportState <= TeleportState.WaitForTeleport;
	}

	public void TeleportPlayer()
	{
		EntranceAudioSource.clip = PortalEnterClip;
		EntranceAudioSource.Play();
		ExitAudioSource.clip = PortalExitClip;
		ExitAudioSource.Play();
		m_player.transform.position = m_exitPosition.position;
		m_player.transform.position += -Vector3.up * 0.5f;
		m_player.transform.forward = m_exitPosition.direction;
		m_player.EnablePortalStreaks();
		m_player.EnablePortalTrail = true;
		float magnitude = m_player.transform.GetComponent<Rigidbody>().velocity.magnitude;
		m_player.transform.GetComponent<Rigidbody>().velocity = m_player.transform.forward * (magnitude + 10f);
		m_portalTeleportTimer = 0f;
		m_teleportState = TeleportState.Teleported;
	}

	public void FailedTeleport()
	{
		EntranceAudioSource.clip = PortalWrongClip;
		EntranceAudioSource.Play();
	}

	private void InitWeapon()
	{
		SplitLane lane = null;
		m_exitTimer = 0f;
		m_scaleOffset = 0f;
		float num = 0.6f;
		num += m_player.GetComponent<KartController>().CurrentSpeed / 80f * 0.8f;
		float dist = 0f;
		bool flag = false;
		bool flag2 = false;
		if (m_player.InSplitLane(ref lane))
		{
			int wayPoint = 0;
			int wayPoint2 = 0;
			float closestPointOnTrack = lane.GetClosestPointOnTrack(m_player.transform.position, ref wayPoint, ref wayPoint2);
			m_portalEntrancePoint = closestPointOnTrack + num;
			if (lane.DistanceStillOnSpline(m_portalEntrancePoint))
			{
				flag = true;
				dist = lane.ConvertWaypointDistanceToDistances(m_portalEntrancePoint);
			}
		}
		if (!flag)
		{
			if ((bool)lane)
			{
				num = 0f;
				int wayPoint3 = 0;
				int wayPoint4 = 0;
				m_portalEntrancePoint = Gameplay.Instance.GetCircuitPath().GetClosestPointOnTrack(lane.Waypoints[lane.Waypoints.Count - 1].transform.position, ref wayPoint3, ref wayPoint4);
				flag2 = true;
			}
			else
			{
				lane = null;
				m_portalEntrancePoint = m_player.PointOnTrack() + num;
			}
			dist = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(m_portalEntrancePoint);
		}
		if (lane == null)
		{
			m_entrancePosition = Gameplay.Instance.GetCircuitPath().GetRoutePoint(dist);
			m_entrancePosition.position = new Vector3(m_entrancePosition.position.x, m_entrancePosition.position.y, m_entrancePosition.position.z);
			float dist2 = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(m_player.PointOnTrack());
			VRWaypointCircuit.RoutePoint routePoint = Gameplay.Instance.GetCircuitPath().GetRoutePoint(dist2);
			m_portalSplineOffset = (routePoint.position - m_player.transform.position).magnitude;
			Vector3 vector = Vector3.Cross(routePoint.direction, Vector3.up);
			Vector3 rhs = new Vector3(m_player.transform.position.x, 0f, m_player.transform.position.z) - routePoint.position;
			rhs.Normalize();
			if (Vector3.Dot(vector, rhs) < 0f)
			{
				m_portalSplineOffset = 0f - m_portalSplineOffset;
			}
			m_entrancePosition.position += vector * m_portalSplineOffset;
		}
		else
		{
			m_entrancePosition = lane.GetRoutePoint(dist);
		}
		float num2 = 0f;
		flag = false;
		if (!flag2 && m_player.InSplitLane(ref lane) && lane.DistanceStillOnSpline(m_portalEntrancePoint + 5f))
		{
			flag = true;
			num2 = lane.ConvertWaypointDistanceToDistances(m_portalEntrancePoint + 5f);
			m_exitPosition = lane.GetRoutePoint(num2);
			m_exitPosition.position = new Vector3(m_exitPosition.position.x, m_exitPosition.position.y, m_exitPosition.position.z);
			m_exitPosition.position.y += 0.1f;
		}
		if (!flag)
		{
			if (!flag2 && (bool)lane)
			{
				GameObject obj = lane.GetEndKnot();
				int num3 = Gameplay.Instance.GetCircuitPath().FindWayPoint(ref obj);
				if (num3 == -1)
				{
					m_exitPosition = new VRWaypointCircuit.RoutePoint(lane.Waypoints[lane.Waypoints.Count - 1].transform.position, lane.Waypoints[lane.Waypoints.Count - 1].transform.forward);
				}
				else
				{
					Transform transform = Gameplay.Instance.GetCircuitPath().Waypoints[(num3 + 1) % Gameplay.Instance.GetCircuitPath().Waypoints.Length];
					m_exitPosition = new VRWaypointCircuit.RoutePoint(transform.position, transform.forward);
				}
			}
			else
			{
				num2 = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(m_portalEntrancePoint + 5f);
				m_exitPosition = Gameplay.Instance.GetCircuitPath().GetRoutePoint(num2);
				m_exitPosition.position = new Vector3(m_exitPosition.position.x, m_exitPosition.position.y, m_exitPosition.position.z);
			}
			m_exitPosition.position.y += 0.1f;
			lane = null;
		}
		m_teleportState = TeleportState.Rise;
		EntranceAudioSource.clip = PortalOpenClip;
		EntranceAudioSource.Play();
		ExitAudioSource.clip = PortalOpenClip;
		ExitAudioSource.Play();
	}

	private void Update()
	{
		switch (m_teleportState)
		{
		case TeleportState.Teleported:
			m_portalTeleportTimer += GameTime.Instance.DeltaTime();
			if (m_portalTeleportTimer > 0.25f)
			{
				m_portalTeleportTimer = 0f;
				m_player.UpdateCurrentWayPoint();
				m_teleportState = TeleportState.FinishedTeleport;
			}
			break;
		case TeleportState.Rise:
			if (m_scaleOffset < 1f)
			{
				m_scaleOffset += 4f * GameTime.Instance.DeltaTime();
				if (m_scaleOffset > 1f)
				{
					m_scaleOffset = 1f;
					m_teleportState = TeleportState.WaitForTeleport;
				}
			}
			break;
		case TeleportState.Lower:
			if (m_exitTimer < 2f)
			{
				m_exitTimer += GameTime.Instance.DeltaTime();
			}
			if (m_exitTimer >= 2f)
			{
				m_scaleOffset -= 2f * GameTime.Instance.DeltaTime();
				if (m_scaleOffset <= 0f)
				{
					WeaponManager.Instance.RepoolObject(base.gameObject);
					m_teleportState = TeleportState.None;
				}
			}
			break;
		}
		if (m_teleportState != 0 && m_teleportState != TeleportState.Lower)
		{
			SplitLane lane = null;
			float num = 0f;
			if (m_player.InSplitLane(ref lane))
			{
				int wayPoint = 0;
				int wayPoint2 = 0;
				num = lane.GetClosestPointOnTrack(m_player.transform.position, ref wayPoint, ref wayPoint2);
			}
			else
			{
				num = m_player.PointOnTrack();
			}
			if (num > m_portalEntrancePoint + 0.1f)
			{
				m_teleportState = TeleportState.Lower;
			}
		}
		PortalObjectEntrance.transform.position = new Vector3(m_entrancePosition.position.x, m_entrancePosition.position.y, m_entrancePosition.position.z);
		PortalObjectEntrance.transform.localScale = new Vector3(m_scaleOffset, m_scaleOffset, m_scaleOffset);
		PortalObjectEntrance.transform.forward = m_entrancePosition.direction;
		PortalObjectExit.transform.position = new Vector3(m_exitPosition.position.x, m_exitPosition.position.y, m_exitPosition.position.z);
		PortalObjectExit.transform.localScale = new Vector3(m_scaleOffset, m_scaleOffset, m_scaleOffset);
		PortalObjectExit.transform.forward = m_exitPosition.direction;
	}
}
public class RadiusBomb : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float MaxTime = 1f;

	[SerializeField]
	private float ExtraTimeDuringFade = 0.5f;

	[SerializeField]
	private float MaxSize = 5f;

	[SerializeField]
	private float ExtraSizeDuringFade = 0.5f;

	private Player m_player;

	private float m_timer;

	private const float MaxDetectionSize = 50f;

	public void SetPlayer(Player player)
	{
		m_player = player;
		SetupRadiusBomb();
	}

	private void SetupRadiusBomb()
	{
		m_timer = 0f;
		m_player.SetRadiusBombEnabled(enabled: true);
		m_player.GetKartGeometry().SetRadiusBombAlpha(1f);
		CheckPlayers();
	}

	private void OnDisable()
	{
		if ((bool)m_player)
		{
			m_player.ForceEffectsOff();
		}
	}

	private void CheckPlayers()
	{
		List<Player> playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < playerList.Count; i++)
		{
			if (!(m_player == playerList[i]))
			{
				float sqrMagnitude = (playerList[i].transform.position - m_player.transform.position).sqrMagnitude;
				if (sqrMagnitude < 50f)
				{
					float num = 1f - sqrMagnitude / 50f;
					playerList[i].GetComponent<KartController>().Immobilize(playerList[i].CutoutTime * num, Gameplay.HitByType.NormalWeapon);
					playerList[i].ReduceBoostAmount(num);
				}
			}
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		float timer = m_timer;
		float num = MaxTime + ExtraTimeDuringFade;
		m_timer += GameTime.Instance.DeltaTime();
		if (m_timer < MaxTime)
		{
			float num2 = m_timer / MaxTime;
			m_player.SetRadiusBombScale(num2 * MaxSize);
			return;
		}
		float num3 = (m_timer - MaxTime) / ExtraTimeDuringFade;
		m_player.SetRadiusBombScale(MaxSize + num3 * ExtraSizeDuringFade);
		float num4 = 1f - num3;
		m_player.GetKartGeometry().SetRadiusBombAlpha(num4 * 0.75f);
		if (timer < num && m_timer >= num)
		{
			m_player.SetRadiusBombEnabled(enabled: false);
			m_player = null;
			Gameplay.Instance.GetWeaponManager().RepoolObject(base.gameObject);
		}
	}
}
public class ShieldWeapon : WeaponBase
{
	[SerializeField]
	private float MaxShieldTime = 5f;

	private Player m_player;

	private float m_timer;

	public void SetPlayer(Player player)
	{
		m_player = player;
		SetupShield();
	}

	private void OnDisable()
	{
		if ((bool)m_player)
		{
			m_player.ForceEffectsOff();
		}
	}

	private void SetupShield()
	{
		m_timer = Time.time + MaxShieldTime;
		m_player.SetShieldEnabled(enabled: true);
	}

	private void Update()
	{
		if (Time.time > m_timer || !m_player.IsShieldEnabled())
		{
			m_player.SetShieldEnabled(enabled: false);
			m_player = null;
			Gameplay.Instance.GetWeaponManager().RepoolObject(base.gameObject);
		}
	}
}
public class StingerCollision : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private StingerWeapon ParentWeapon;

	[SerializeField]
	private AudioSource StingerPop;

	[SerializeField]
	private AudioClip[] StingerPopSFX;

	public void Repool()
	{
	}

	private void OnTriggerEnter(Collider collider)
	{
		DetectedCollision(collider.gameObject);
		StingerPop.clip = StingerPopSFX[UnityEngine.Random.Range(0, StingerPopSFX.Length)];
		StingerPop.Play();
	}

	private void OnTriggerStay(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void OnTriggerExit(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void DetectedCollision(GameObject obj)
	{
		if (obj.layer == 11 || obj.layer == 8 || obj.layer == 16 || obj.layer == 17 || obj.layer == 31)
		{
			Transform parent = obj.transform;
			while ((bool)parent.parent && parent.GetComponent<Player>() == null)
			{
				parent = parent.parent;
			}
			ParentWeapon.Hit(parent.GetComponent<Player>());
		}
	}
}
public class StingerWeapon : WeaponBase
{
	[SerializeField]
	private AudioClip ExpandSFX;

	[SerializeField]
	private AudioClip RetractSFX;

	[SerializeField]
	private float MaxWidth = 16f;

	[SerializeField]
	private GameObject StingerRoot;

	[SerializeField]
	private float GrowSpeed = 60f;

	[SerializeField]
	private float RetractSpeed = 30f;

	[SerializeField]
	private float TimeBeforeRetract = 1f;

	[SerializeField]
	private float TimeBeforeRetractNoHit = 10f;

	[SerializeField]
	private float DistanceBeforeActive = 8f;

	[SerializeField]
	private StingerCollision stingerCollision;

	private Player m_player;

	private float m_currentWidth = 1f;

	private float m_hitTimer;

	private float m_idleTimer;

	private bool m_retract;

	private AudioSource m_audioSource;

	public void SetPlayer(Player player)
	{
		m_player = player;
		Vector3 localEulerAngles = m_player.transform.localEulerAngles;
		localEulerAngles.z = 0f;
		base.transform.localEulerAngles = localEulerAngles;
		m_audioSource.clip = ExpandSFX;
		m_audioSource.Play();
	}

	private void OnEnable()
	{
		InitWeapon();
	}

	private void Start()
	{
		InitWeapon();
	}

	private void InitWeapon()
	{
		m_currentWidth = 0f;
		m_hitTimer = 0f;
		m_idleTimer = 0f;
		m_retract = false;
		if (m_audioSource == null)
		{
			m_audioSource = GetComponent<AudioSource>();
		}
	}

	private void UpdateGrowth()
	{
		if (m_currentWidth < MaxWidth)
		{
			m_currentWidth += GrowSpeed * GameTime.Instance.DeltaTime();
			if (m_currentWidth > MaxWidth)
			{
				m_currentWidth = MaxWidth;
				m_idleTimer = TimeBeforeRetractNoHit;
			}
			Vector3 localScale = new Vector3(m_currentWidth, StingerRoot.transform.localScale.y, StingerRoot.transform.localScale.z);
			StingerRoot.transform.localScale = localScale;
		}
	}

	private void UpdateRetract()
	{
		if (m_currentWidth > 0f)
		{
			m_currentWidth -= RetractSpeed * GameTime.Instance.DeltaTime();
			if (m_currentWidth <= 0.1f)
			{
				DestroyStinger();
				return;
			}
			Vector3 localScale = new Vector3(m_currentWidth, StingerRoot.transform.localScale.y, StingerRoot.transform.localScale.z);
			StingerRoot.transform.localScale = localScale;
		}
	}

	private void Update()
	{
		if (m_retract)
		{
			UpdateRetract();
			return;
		}
		if ((bool)m_player)
		{
			float sqrMagnitude = (base.transform.position - m_player.transform.position).sqrMagnitude;
			if (sqrMagnitude > DistanceBeforeActive * DistanceBeforeActive)
			{
				m_player = null;
			}
		}
		UpdateGrowth();
		if (m_hitTimer > 0f)
		{
			m_hitTimer -= GameTime.Instance.DeltaTime();
			if (m_hitTimer <= 0f)
			{
				m_retract = true;
				m_audioSource.clip = RetractSFX;
				m_audioSource.Play();
			}
		}
		if (m_idleTimer > 0f)
		{
			m_idleTimer -= GameTime.Instance.DeltaTime();
			if (m_idleTimer <= 0f)
			{
				m_retract = true;
				m_audioSource.clip = RetractSFX;
				m_audioSource.Play();
			}
		}
	}

	public void Hit(Player player)
	{
		if (m_player != player)
		{
			player.HitByWeapon();
			if (player.GetPlayerType() == Player.PlayerType.Human && (bool)ForceFeedback.Instance)
			{
				ForceFeedback.Instance.SetFeedback(ForceFeedback.FeedbackType.KartCollision);
			}
			if (m_hitTimer == 0f)
			{
				m_hitTimer = TimeBeforeRetract;
			}
		}
	}

	private void DestroyStinger()
	{
		Gameplay.Instance.StingerList.Remove(this);
		WeaponManager.Instance.RepoolObject(base.gameObject);
	}
}
public class ToxicWeapon : WeaponBase
{
	[SerializeField]
	private float MaxToxicTime = 5f;

	private Player m_player;

	private float m_timer;

	public void SetPlayer(Player player)
	{
		m_player = player;
		m_timer = Time.time + MaxToxicTime;
		m_player.ToxicTimer = MaxToxicTime;
		Gameplay.Instance.ToxicRefCount++;
	}

	private void Update()
	{
		if (Time.time > m_timer)
		{
			if (Gameplay.Instance.ToxicRefCount > 0)
			{
				Gameplay.Instance.ToxicRefCount--;
			}
			m_player = null;
			Gameplay.Instance.GetWeaponManager().RepoolObject(base.gameObject);
		}
	}
}
public abstract class WeaponBase : UnityEngine.MonoBehaviour
{
	public virtual void ReadyToRepool()
	{
	}
}
public class WeaponControl : UnityEngine.MonoBehaviour
{
	private enum WeaponState
	{
		None,
		ReadyToFire
	}

	[SerializeField]
	private Player Player;

	[SerializeField]
	private GameObject ReticuleObject;

	[SerializeField]
	private UnityEngine.Color NoTargetColour = UnityEngine.Color.red;

	[SerializeField]
	private UnityEngine.Color TargetColour = UnityEngine.Color.green;

	[SerializeField]
	private float TargetZOffset = 1.6f;

	[SerializeField]
	private float TargetLockExtraSize = 0.2f;

	[SerializeField]
	private float TargetLockSizeSpeed = 6f;

	[SerializeField]
	private float InvalidAngleX = 12f;

	[SerializeField]
	private float InvalidAngleY = 45f;

	[SerializeField]
	private float StickyTimerDuration = 0.4f;

	[SerializeField]
	private float TargetLerpSpeed = 18f;

	private WeaponState m_weaponState;

	private Player m_targetPlayer;

	private Player m_mainPlayer;

	private float m_originalScale;

	private bool m_invalidAngle;

	private float m_targetAlpha = 1f;

	private bool m_firstLook = true;

	private bool m_useStickyPosition;

	private float m_stickyTimer;

	private float m_targetDistance;

	private float Speed = 4f;

	private void Awake()
	{
		ReticuleObject.gameObject.SetActive(value: false);
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom() && Player != null && (bool)Player.GetComponent<PhotonView>() && !Player.GetComponent<PhotonView>().isMine)
		{
			base.enabled = false;
		}
	}

	private void Start()
	{
		m_stickyTimer = 0f;
		m_originalScale = ReticuleObject.transform.localScale.x;
	}

	private void Update()
	{
		Player refPlayer = null;
		if (!PlayerManager.Instance || !PlayerManager.Instance.GetHumanPlayer(ref refPlayer) || !refPlayer.WeaponEnabled())
		{
			return;
		}
		if (!m_mainPlayer)
		{
			m_mainPlayer = refPlayer;
		}
		if (m_mainPlayer.GetComponent<KartDashboard>().ScrollingWeapon())
		{
			return;
		}
		if (m_mainPlayer.WeaponTypeTimer > 0f)
		{
			if (ReticuleObject.activeSelf)
			{
				ReticuleObject.SetActive(value: false);
			}
			return;
		}
		if (ResultsManager.Instance != null && ResultsManager.Instance.ResultsActive())
		{
			ReticuleObject.SetActive(value: false);
			return;
		}
		if (m_mainPlayer.WeaponType != 0 && m_mainPlayer.WeaponType != WeaponManager.WeaponType.Reverse && m_mainPlayer.WeaponType != WeaponManager.WeaponType.Bombhead && m_mainPlayer.WeaponType != WeaponManager.WeaponType.Bees && ReticuleObject.activeSelf)
		{
			ReticuleObject.SetActive(value: false);
		}
		switch (m_weaponState)
		{
		case WeaponState.None:
			UpdateWeaponStart();
			break;
		case WeaponState.ReadyToFire:
			UpdateWeaponPositioning();
			break;
		}
		if (ReticuleObject.activeInHierarchy)
		{
			UpdateReticule();
		}
	}

	private void UpdateReticule()
	{
		Vector3 vector;
		if (!m_useStickyPosition)
		{
			Transform transform = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform;
			vector = transform.position;
			vector += transform.forward * TargetZOffset;
		}
		else
		{
			Vector3 normalized = (m_targetPlayer.transform.position - Player.transform.position).normalized;
			Vector3 position = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.position;
			Vector3 forward = Player.transform.forward;
			float num = Vector3.Angle(forward, normalized);
			vector = position;
			Vector3 lhs = Vector3.Cross(normalized, Vector3.up);
			if (Vector3.Dot(lhs, forward) < 0f)
			{
				num = 0f - num;
			}
			Quaternion quaternion = Quaternion.AngleAxis(num, Vector3.up);
			Vector3 vector2 = quaternion * forward;
			vector += vector2 * TargetZOffset;
		}
		if (m_firstLook)
		{
			m_firstLook = false;
			ReticuleObject.transform.position = vector;
		}
		else
		{
			ReticuleObject.transform.position = Vector3.Lerp(ReticuleObject.transform.position, vector, TargetLerpSpeed * GameTime.Instance.DeltaTime());
		}
		ReticuleObject.transform.rotation = Quaternion.LookRotation(CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward);
	}

	private void UpdateWeaponStart()
	{
		if (!InputRemapper.Instance.GetButton(InputRemapper.ControllerMapping.Weapon))
		{
			return;
		}
		if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Bombhead && GameSystem.Instance.BombHeadMode)
		{
			WeaponManager.Instance.Firebomb(Player, m_targetPlayer);
			return;
		}
		if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Missile || m_mainPlayer.WeaponType == WeaponManager.WeaponType.Reverse || m_mainPlayer.WeaponType == WeaponManager.WeaponType.Bombhead || m_mainPlayer.WeaponType == WeaponManager.WeaponType.Bees)
		{
			ReticuleObject.transform.localScale = new Vector3(m_originalScale, m_originalScale, m_originalScale);
			if (!ReticuleObject.activeSelf)
			{
				m_firstLook = true;
				ReticuleObject.SetActive(value: true);
			}
		}
		m_weaponState = WeaponState.ReadyToFire;
	}

	private void UpdateWeaponPositioning()
	{
		Player targetPlayer = null;
		float rayLength = float.PositiveInfinity;
		FindTarget(ref targetPlayer, rayLength);
		if (targetPlayer != null)
		{
			m_useStickyPosition = true;
			m_stickyTimer = Time.time + StickyTimerDuration;
			m_targetPlayer = targetPlayer;
		}
		else if (Time.time > m_stickyTimer)
		{
			m_useStickyPosition = false;
			m_targetPlayer = null;
		}
		else
		{
			m_useStickyPosition = true;
		}
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
		{
			m_useStickyPosition = false;
		}
		if (InputRemapper.Instance.GetButtonUp(InputRemapper.ControllerMapping.Weapon))
		{
			if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Missile)
			{
				if (!m_invalidAngle && m_targetPlayer != null)
				{
					WeaponManager.Instance.FireMissile(Player, m_targetPlayer);
				}
				ReticuleObject.SetActive(value: false);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Reverse)
			{
				if (!m_invalidAngle && m_targetPlayer != null)
				{
					WeaponManager.Instance.FireReverse(Player, m_targetPlayer);
				}
				ReticuleObject.SetActive(value: false);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Bombhead)
			{
				if (!m_invalidAngle && m_targetPlayer != null)
				{
					WeaponManager.Instance.Firebomb(Player, m_targetPlayer);
				}
				ReticuleObject.SetActive(value: false);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Mine)
			{
				WeaponManager.Instance.FireMine(Player, m_targetPlayer);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Stinger)
			{
				WeaponManager.Instance.FireStinger(Player, m_targetPlayer);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Toxic)
			{
				WeaponManager.Instance.FireToxic(Player, m_targetPlayer);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Shield)
			{
				WeaponManager.Instance.FireShield(Player, m_targetPlayer);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.RadiusBomb)
			{
				WeaponManager.Instance.FireRadiusBomb(Player, m_targetPlayer);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Nitro)
			{
				WeaponManager.Instance.FireNitro(Player, m_targetPlayer);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Portal)
			{
				WeaponManager.Instance.FirePortal(Player, m_targetPlayer);
			}
			else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Bees)
			{
				if (!m_invalidAngle && m_targetPlayer != null)
				{
					WeaponManager.Instance.FireBeehiveWeapon(Player, m_targetPlayer);
				}
				ReticuleObject.SetActive(value: false);
			}
			m_weaponState = WeaponState.None;
		}
		else if (m_mainPlayer.WeaponType == WeaponManager.WeaponType.Missile || m_mainPlayer.WeaponType == WeaponManager.WeaponType.Reverse || m_mainPlayer.WeaponType == WeaponManager.WeaponType.Bombhead || m_mainPlayer.WeaponType == WeaponManager.WeaponType.Bees)
		{
			float b = m_originalScale;
			float num = ReticuleObject.transform.localEulerAngles.x;
			float num2 = ReticuleObject.transform.localEulerAngles.y;
			if (num > 180f)
			{
				num = 360f - num;
			}
			if (num2 > 180f)
			{
				num2 = 360f - num2;
			}
			m_invalidAngle = num > InvalidAngleX || num2 > InvalidAngleY;
			float dist = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(Player.PointOnTrack());
			m_invalidAngle |= Vector3.Angle(Gameplay.Instance.GetCircuitPath().GetRoutePoint(dist).direction, Player.transform.forward) > 25f;
			if (m_invalidAngle)
			{
				m_targetAlpha = Mathf.Lerp(m_targetAlpha, 0f, 6f * GameTime.Instance.DeltaTime());
			}
			else
			{
				m_targetAlpha = Mathf.Lerp(m_targetAlpha, 1f, 6f * GameTime.Instance.DeltaTime());
			}
			if (!m_invalidAngle && m_targetPlayer != null)
			{
				b = m_originalScale + TargetLockExtraSize;
				ReticuleObject.GetComponent<Renderer>().material.color = new UnityEngine.Color(TargetColour.r, TargetColour.g, TargetColour.b, m_targetAlpha);
			}
			else
			{
				ReticuleObject.GetComponent<Renderer>().material.color = new UnityEngine.Color(NoTargetColour.r, NoTargetColour.g, NoTargetColour.b, m_targetAlpha);
			}
			Vector3 localScale = ReticuleObject.transform.localScale;
			localScale.x = Mathf.Lerp(ReticuleObject.transform.localScale.x, b, TargetLockSizeSpeed * GameTime.Instance.DeltaTime());
			localScale.y = Mathf.Lerp(ReticuleObject.transform.localScale.y, b, TargetLockSizeSpeed * GameTime.Instance.DeltaTime());
			localScale.z = Mathf.Lerp(ReticuleObject.transform.localScale.z, b, TargetLockSizeSpeed * GameTime.Instance.DeltaTime());
			ReticuleObject.transform.localScale = localScale;
		}
	}

	private Vector3 FindTarget(ref Player targetPlayer, float rayLength)
	{
		Ray ray = new Ray(CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.position, CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.forward);
		if (Physics.Raycast(ray, out var hitInfo, rayLength, LayerMask.GetMask("TargetCollision", "RaceScenery", "ShowInWingMirrors")))
		{
			Transform parent = hitInfo.collider.gameObject.transform;
			while (parent != null && parent.gameObject.GetComponent<Player>() == null)
			{
				parent = parent.parent;
			}
			if (parent != null)
			{
				targetPlayer = parent.gameObject.GetComponent<Player>();
				if ((Player.WeaponType != WeaponManager.WeaponType.Bees || !WeaponManager.Instance.HasBees(targetPlayer)) && targetPlayer.PlayerFinishState == Player.PlayerFinishedState.None && !targetPlayer.TurnOffKartOnTrackFinish)
				{
					return hitInfo.point;
				}
			}
		}
		targetPlayer = null;
		return Vector3.zero;
	}

	private void OnDrawGizmos()
	{
		if ((bool)Gameplay.Instance)
		{
			VRWaypointCircuit.RoutePoint routePoint = Gameplay.Instance.GetCircuitPath().GetRoutePoint(m_targetDistance);
			Gizmos.color = UnityEngine.Color.green;
			Gizmos.DrawWireSphere(routePoint.position, 1f);
			m_targetDistance += Speed * Time.deltaTime;
		}
	}
}
public class WeaponFiring : WeaponBase
{
	[SerializeField]
	private float MovementSpeed = 3f;

	[SerializeField]
	private float MaxTargetHeight = 10f;

	[SerializeField]
	private AudioSource RocketLaunchAudio;

	[SerializeField]
	private AudioSource RocketFlightAudio;

	[SerializeField]
	private AudioSource RocketImpactAudio;

	[SerializeField]
	private bool IsReverseWeapon;

	private float PlayerDetectionDistance = 120f;

	private Player m_player;

	private Player m_targetPlayer;

	private Vector3 m_targetPosition;

	private float m_targetDistance;

	private float m_targetHeight;

	private float m_targetWidth;

	private float m_rollAngle;

	private bool m_homing;

	private float m_originalHeight;

	private float m_startDistance;

	private bool m_readyForStartDistance;

	private float m_flightAudioTargetDistance;

	private SplitLane m_currentSplitLane;

	private float m_previousProgress;

	private VRWaypointCircuit.RoutePoint m_point = default(VRWaypointCircuit.RoutePoint);

	private float tempDistance;

	private void OnEnable()
	{
		InitWeapon();
	}

	private void Start()
	{
		InitWeapon();
	}

	private void InitWeapon()
	{
		m_homing = false;
		m_originalHeight = base.transform.position.y;
	}

	private void Update()
	{
		m_flightAudioTargetDistance += GameTime.Instance.DeltaTime();
		RocketFlightAudio.volume = Mathf.Lerp(0f, 1f, m_flightAudioTargetDistance);
		if (!IsReverseWeapon)
		{
			CheckForMine();
		}
	}

	private void FixedUpdate()
	{
		if (m_targetPlayer == null)
		{
			return;
		}
		float sqrMagnitude = (new Vector2(m_targetPlayer.transform.position.x, m_targetPlayer.transform.position.z) - new Vector2(base.transform.position.x, base.transform.position.z)).sqrMagnitude;
		if (m_readyForStartDistance)
		{
			m_readyForStartDistance = false;
			m_startDistance = sqrMagnitude;
		}
		if ((!m_homing || m_player.PlayerFinishState != 0) && m_targetPlayer.GetComponent<Player>().enabled)
		{
			int wayPoint = 0;
			int wayPoint2 = 0;
			float num = 0f;
			SplitLane lane = null;
			SplitLane lane2 = null;
			VRWaypointCircuit circuitPath = Gameplay.Instance.GetCircuitPath();
			if (m_currentSplitLane == null)
			{
				num = circuitPath.GetClosestPointOnTrack(base.transform.position, ref wayPoint, ref wayPoint2);
				if (m_targetPlayer.InSplitLane(ref lane) && circuitPath.IsWaypointASplitLane(wayPoint, ref lane2) && lane2 == lane)
				{
					m_currentSplitLane = lane;
					m_previousProgress = m_targetDistance;
					for (int i = wayPoint; i < wayPoint2; i++)
					{
						int num2 = (i + 1) % circuitPath.Waypoints.Length;
						m_previousProgress += (circuitPath.Waypoints[num2].position - circuitPath.Waypoints[i].position).magnitude;
					}
					m_targetDistance = 20f;
				}
			}
			float num3 = m_targetPlayer.PointOnTrack(singleLapOnly: true) - num;
			if ((m_currentSplitLane == null && ((num3 > 0f && num3 < 0.1f) || (num3 <= 0f && num3 > -0.1f))) || (base.transform.position - m_targetPlayer.transform.position).sqrMagnitude < 64f)
			{
				m_homing = true;
			}
			else
			{
				if (m_player.PlayerFinishState == Player.PlayerFinishedState.None)
				{
					float maxTargetHeight = MaxTargetHeight;
					float value = sqrMagnitude / m_startDistance;
					value = Mathf.Clamp(value, 0f, 1f);
					maxTargetHeight *= value;
					if (maxTargetHeight < m_originalHeight)
					{
						maxTargetHeight = m_originalHeight;
					}
					m_targetHeight = Mathf.Lerp(m_targetHeight, maxTargetHeight, 8f * GameTime.Instance.SmoothedDeltaTime());
				}
				m_targetDistance += MovementSpeed * GameTime.Instance.SmoothedDeltaTime();
				if (m_currentSplitLane != null)
				{
					if (m_currentSplitLane.HitEndOfSpline(m_targetDistance))
					{
						m_currentSplitLane = null;
						m_targetDistance = m_previousProgress;
					}
					else
					{
						m_point = m_currentSplitLane.GetRoutePoint(m_targetDistance);
					}
				}
				else
				{
					m_point = Gameplay.Instance.GetCircuitPath().GetRoutePoint(m_targetDistance);
				}
				m_targetPosition = new Vector3(m_point.position.x, m_point.position.y + m_targetHeight, m_point.position.z);
				Vector3 direction = m_point.direction;
				direction = Vector3.Cross(direction, Vector3.up);
				direction *= m_targetWidth;
				m_targetPosition += direction;
				base.transform.position = Vector3.Lerp(base.transform.position, m_targetPosition, 8f * GameTime.Instance.SmoothedDeltaTime());
			}
		}
		else
		{
			m_targetPosition = m_targetPlayer.transform.position + new Vector3(0f, 1f, 0f);
			float num4 = 18f;
			if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.Practice3)
			{
				num4 = 4f;
				m_targetPosition.y += 2f;
			}
			base.gameObject.GetComponent<Rigidbody>().velocity = Vector3.zero;
			base.transform.position = Vector3.Lerp(base.transform.position, m_targetPosition, num4 * GameTime.Instance.SmoothedDeltaTime());
		}
		if (Mathf.Abs((m_targetPosition - base.transform.position).sqrMagnitude) > 0f)
		{
			Vector3 normalized = (m_targetPosition - base.transform.position).normalized;
			base.transform.rotation = Quaternion.LookRotation(normalized);
		}
		m_rollAngle += 30f * GameTime.Instance.DeltaTime();
		m_rollAngle %= 360f;
		Quaternion quaternion = Quaternion.AngleAxis(0f - m_rollAngle, new Vector3(0f, 0f, 1f));
		base.transform.rotation *= quaternion;
		if (m_homing || !(sqrMagnitude > PlayerDetectionDistance))
		{
			return;
		}
		SplitLane lane3 = null;
		if (m_currentSplitLane == null && !m_targetPlayer.InSplitLane(ref lane3))
		{
			float dist = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(m_targetPlayer.PointOnTrack(singleLapOnly: true));
			VRWaypointCircuit.RoutePoint routePoint = Gameplay.Instance.GetCircuitPath().GetRoutePoint(dist);
			Vector3 vector = new Vector3(routePoint.position.x, 0f, routePoint.position.z);
			float num5 = (vector - new Vector3(m_targetPlayer.transform.position.x, 0f, m_targetPlayer.transform.position.z)).magnitude;
			Vector3 lhs = Vector3.Cross(routePoint.direction, Vector3.up);
			Vector3 rhs = new Vector3(m_targetPlayer.transform.position.x, 0f, m_targetPlayer.transform.position.z) - vector;
			rhs.Normalize();
			if (Vector3.Dot(lhs, rhs) < 0f)
			{
				num5 = 0f - num5;
			}
			m_targetWidth = Mathf.Lerp(m_targetWidth, num5, 20f * GameTime.Instance.SmoothedDeltaTime());
		}
		else
		{
			m_targetWidth = Mathf.Lerp(m_targetWidth, 0f, 20f * GameTime.Instance.SmoothedDeltaTime());
		}
	}

	private void OnTriggerEnter(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void OnTriggerStay(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void OnTriggerExit(Collider collider)
	{
		DetectedCollision(collider.gameObject);
	}

	private void DetectedCollision(GameObject obj)
	{
		if (obj.layer != 17)
		{
			return;
		}
		Transform parent = obj.transform;
		Player player = null;
		while ((bool)parent.parent && parent.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		player = parent.GetComponent<Player>();
		if (!(m_targetPlayer == player))
		{
			return;
		}
		if (IsReverseWeapon)
		{
			if (!player.IsShieldEnabled())
			{
				KartController component = parent.GetComponent<KartController>();
				if ((bool)component)
				{
					component.EnableReverseControls();
				}
				player.EnableReverseDisrupt(enable: true);
			}
		}
		else
		{
			player.HitByWeapon();
		}
		DestroyMissile(parent.gameObject, parent.transform.position - parent.transform.forward * 2f + parent.transform.up * 1.25f);
	}

	private void CheckForMine()
	{
		List<Mine_Proximity> mineList = Gameplay.Instance.MineList;
		for (int i = 0; i < mineList.Count; i++)
		{
			Vector3 vector = new Vector3(base.transform.position.x, 0f, base.transform.position.z);
			Vector3 vector2 = new Vector3(mineList[i].transform.position.x, 0f, mineList[i].transform.position.z);
			float sqrMagnitude = (vector - vector2).sqrMagnitude;
			if (sqrMagnitude < 4f)
			{
				DestroyMissile(null, base.transform.position);
				mineList[i].DestroyMine();
				break;
			}
		}
	}

	private void DestroyMissile(GameObject obj, Vector3 position)
	{
		if ((bool)m_targetPlayer)
		{
			m_targetPlayer.SetBeingTargetted(set: false);
		}
		RocketLaunchAudio.Stop();
		RocketFlightAudio.Stop();
		Gameplay.Instance.GetWeaponManager().CreateImpactEffect(obj, position, IsReverseWeapon ? WeaponManager.WeaponType.Reverse : WeaponManager.WeaponType.Missile);
		AudioSource audioSource = UnityEngine.Object.Instantiate(RocketImpactAudio);
		audioSource.name = "WeaponAudioImpact";
		audioSource.transform.position = position;
		audioSource.GetComponent<AudioSource>().Play();
		UnityEngine.Object.Destroy(audioSource.gameObject, 3f);
		WeaponManager.Instance.RepoolObject(base.gameObject);
	}

	public void SetPlayer(Player player, Player target)
	{
		m_player = player;
		m_currentSplitLane = null;
		m_targetPlayer = target;
		m_targetPlayer.SetBeingTargetted(set: true);
		RocketLaunchAudio.Play();
		RocketFlightAudio.volume = 0f;
		RocketFlightAudio.Play();
		m_flightAudioTargetDistance = 0f;
		if (m_player.InSplitLane(ref m_currentSplitLane))
		{
			int wayPoint = 0;
			int wayPoint2 = 0;
			float closestPointOnTrack = m_currentSplitLane.GetClosestPointOnTrack(m_player.transform.position, ref wayPoint, ref wayPoint2);
			m_targetDistance = m_currentSplitLane.ConvertWaypointDistanceToDistances(closestPointOnTrack);
			closestPointOnTrack = Gameplay.Instance.GetCircuitPath().GetClosestPointOnTrack(m_currentSplitLane.Waypoints[m_currentSplitLane.Waypoints.Count - 1].position, ref wayPoint, ref wayPoint2);
			m_previousProgress = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(closestPointOnTrack);
			m_previousProgress += 10f;
			m_targetWidth = 0f;
		}
		else
		{
			m_targetDistance = Gameplay.Instance.GetCircuitPath().ConvertWaypointDistanceToDistances(m_player.PointOnTrack(singleLapOnly: true));
		}
		m_readyForStartDistance = true;
		if (m_currentSplitLane == null)
		{
			VRWaypointCircuit.RoutePoint routePoint = Gameplay.Instance.GetCircuitPath().GetRoutePoint(m_targetDistance);
			Vector3 vector = new Vector3(routePoint.position.x, 0f, routePoint.position.z);
			m_targetWidth = (vector - new Vector3(m_player.transform.position.x, 0f, m_player.transform.position.z)).magnitude;
			Vector3 lhs = Vector3.Cross(routePoint.direction, Vector3.up);
			Vector3 rhs = new Vector3(m_player.transform.position.x, 0f, m_player.transform.position.z) - vector;
			rhs.Normalize();
			if (Vector3.Dot(lhs, rhs) < 0f)
			{
				m_targetWidth = 0f - m_targetWidth;
			}
		}
		m_targetDistance += 10f;
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.green;
		if (m_currentSplitLane != null)
		{
			Gizmos.DrawSphere(m_currentSplitLane.GetRoutePoint(tempDistance).position, 1.5f);
		}
	}
}
public class WeaponManager : UnityEngine.MonoBehaviour
{
	[Serializable]
	public struct ImpactData
	{
		public ParticleSystem ExplosionPrefab;

		public bool AttachToEntity;
	}

	public enum WeaponType
	{
		Missile,
		Mine,
		Stinger,
		Shield,
		Toxic,
		Reverse,
		Nitro,
		Bees,
		Portal,
		Bombhead,
		RadiusBomb,
		Max
	}

	private class WeaponBiasData
	{
		private List<WeaponType> m_biasWeapons = new List<WeaponType>();

		public WeaponBiasData(bool biasMissile, bool biasMine, bool biasStinger, bool biasShield, bool biasToxic, bool biasReverse, bool biasNitro, bool biasBombhead, bool biasPortal, bool biasBees, bool radiusBomb)
		{
			if (biasMissile)
			{
				m_biasWeapons.Add(WeaponType.Missile);
			}
			if (biasMine)
			{
				m_biasWeapons.Add(WeaponType.Mine);
			}
			if (biasStinger)
			{
				m_biasWeapons.Add(WeaponType.Stinger);
			}
			if (biasShield)
			{
				m_biasWeapons.Add(WeaponType.Shield);
			}
			if (biasToxic)
			{
				m_biasWeapons.Add(WeaponType.Toxic);
			}
			if (biasReverse)
			{
				m_biasWeapons.Add(WeaponType.Reverse);
			}
			if (biasNitro)
			{
				m_biasWeapons.Add(WeaponType.Nitro);
			}
			if (biasBombhead)
			{
				m_biasWeapons.Add(WeaponType.Bombhead);
			}
			if (biasPortal)
			{
				m_biasWeapons.Add(WeaponType.Portal);
			}
			if (biasBees)
			{
				m_biasWeapons.Add(WeaponType.Bees);
			}
			if (radiusBomb)
			{
				m_biasWeapons.Add(WeaponType.RadiusBomb);
			}
		}

		public WeaponType GetRandomBiasWeapon()
		{
			return m_biasWeapons[UnityEngine.Random.Range(0, m_biasWeapons.Count)];
		}
	}

	public struct RepoolData
	{
		public GameObject obj;

		public float time;
	}

	[SerializeField]
	private GameObject MinePrefab;

	[SerializeField]
	private GameObject MissilePrefab;

	[SerializeField]
	private GameObject StingerPrefab;

	[SerializeField]
	private GameObject ToxicPrefab;

	[SerializeField]
	private GameObject ShieldPrefab;

	[SerializeField]
	private GameObject ReversePrefab;

	[SerializeField]
	private GameObject BombheadPrefab;

	[SerializeField]
	private GameObject RadiusBombPrefab;

	[SerializeField]
	private GameObject NitroPrefab;

	[SerializeField]
	private GameObject PortalPrefab;

	[SerializeField]
	private GameObject BeehivePrefab;

	[SerializeField]
	public bool ShieldActiveForOneHit = true;

	[SerializeField]
	public float ReverseControlsTime = 8f;

	[SerializeField]
	private AudioSource ToxicFireAudio;

	private const int MaxMissiles = 6;

	private const int MaxMines = 6;

	private const int MaxStingers = 6;

	private const int MaxToxic = 6;

	private const int MaxShield = 6;

	private const int MaxReverse = 6;

	private const int MaxBombheads = 6;

	private const int MaxNitro = 6;

	private const int MaxPortals = 6;

	private const int MaxBeehives = 6;

	private const int MaxImpactEffects = 6;

	private const int MaxRadiusBombs = 6;

	[SerializeField]
	private ImpactData MissileExplosionData;

	[SerializeField]
	private ImpactData MineExplosionData;

	[SerializeField]
	private ImpactData ReverseExplosionData;

	private WeaponBiasData[] m_weaponBiasData = new WeaponBiasData[8]
	{
		new WeaponBiasData(biasMissile: false, biasMine: true, biasStinger: true, biasShield: false, biasToxic: false, biasReverse: false, biasNitro: false, biasBombhead: false, biasPortal: false, biasBees: false, radiusBomb: false),
		new WeaponBiasData(biasMissile: true, biasMine: true, biasStinger: false, biasShield: false, biasToxic: false, biasReverse: true, biasNitro: false, biasBombhead: false, biasPortal: false, biasBees: true, radiusBomb: false),
		new WeaponBiasData(biasMissile: true, biasMine: false, biasStinger: true, biasShield: true, biasToxic: false, biasReverse: true, biasNitro: true, biasBombhead: false, biasPortal: false, biasBees: true, radiusBomb: true),
		new WeaponBiasData(biasMissile: true, biasMine: false, biasStinger: false, biasShield: true, biasToxic: true, biasReverse: true, biasNitro: true, biasBombhead: false, biasPortal: false, biasBees: true, radiusBomb: true),
		new WeaponBiasData(biasMissile: true, biasMine: true, biasStinger: false, biasShield: true, biasToxic: false, biasReverse: true, biasNitro: true, biasBombhead: false, biasPortal: true, biasBees: true, radiusBomb: true),
		new WeaponBiasData(biasMissile: true, biasMine: false, biasStinger: false, biasShield: true, biasToxic: true, biasReverse: true, biasNitro: true, biasBombhead: false, biasPortal: true, biasBees: true, radiusBomb: true),
		new WeaponBiasData(biasMissile: true, biasMine: true, biasStinger: false, biasShield: true, biasToxic: true, biasReverse: false, biasNitro: true, biasBombhead: false, biasPortal: true, biasBees: true, radiusBomb: false),
		new WeaponBiasData(biasMissile: true, biasMine: false, biasStinger: false, biasShield: true, biasToxic: true, biasReverse: true, biasNitro: true, biasBombhead: false, biasPortal: true, biasBees: true, radiusBomb: false)
	};

	private GameObject m_weaponPool;

	private GameObject[] m_missilePool;

	private GameObject[] m_minePool;

	private GameObject[] m_stingerPool;

	private GameObject[] m_toxicPool;

	private GameObject[] m_shieldPool;

	private GameObject[] m_reversePool;

	private GameObject[] m_bombheadPool;

	private GameObject[] m_nitroPool;

	private GameObject[] m_portalPool;

	private GameObject[] m_beesPool;

	private GameObject[] m_radiusBombPool;

	private ImpactData[] m_missileExplosionPool;

	private ImpactData[] m_reverseExplosionPool;

	private ImpactData[] m_mineExplosionPool;

	private int m_missileIndex;

	private int m_mineIndex;

	private int m_stingerIndex;

	private int m_toxicIndex;

	private int m_shieldIndex;

	private int m_reverseIndex;

	private int m_bombheadIndex;

	private int m_nitroIndex;

	private int m_portalindex;

	private int m_beesIndex;

	private int m_radiusBombIndex;

	private int m_mineExplosionIndex;

	private int m_missileExplosionIndex;

	private int m_reverseExplosionIndex;

	public static WeaponManager Instance;

	private List<RepoolData> m_repoolDataList = new List<RepoolData>();

	public void RepoolAllObjects()
	{
		RepoolCollection(m_minePool);
		RepoolCollection(m_stingerPool);
		RepoolCollection(m_toxicPool);
		RepoolCollection(m_shieldPool);
		RepoolCollection(m_reversePool);
		RepoolCollection(m_bombheadPool);
		RepoolCollection(m_nitroPool);
		RepoolCollection(m_portalPool);
		RepoolCollection(m_beesPool);
		RepoolCollection(m_radiusBombPool);
	}

	private void RepoolCollection(GameObject[] collection)
	{
		for (int i = 0; i < collection.Length; i++)
		{
			if ((bool)collection[i])
			{
				RepoolObject(collection[i].gameObject);
			}
		}
	}

	public void FireMissile(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Missile);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.FireMissile);
			GameSystem.Instance.WeaponTargetIndex = targetPlayer.SeatIndex;
		}
	}

	public void FireReverse(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Reverse);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.FireReverse);
			GameSystem.Instance.WeaponTargetIndex = targetPlayer.SeatIndex;
		}
	}

	public void Firebomb(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Bombhead);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.Bombhead);
			GameSystem.Instance.WeaponTargetIndex = targetPlayer.SeatIndex;
		}
	}

	public void FireMine(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Mine);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.FireMine);
		}
	}

	public void FireStinger(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Stinger);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.FireStinger);
		}
	}

	public void FireToxic(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Toxic);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.Toxic);
		}
	}

	public void FireShield(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Shield);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.Shield);
		}
	}

	public void FireRadiusBomb(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.RadiusBomb);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.RadiusBomb);
		}
	}

	public void FireNitro(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Nitro);
	}

	public void FirePortal(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Portal);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.Portal);
		}
	}

	public void FireBeehiveWeapon(Player currentPlayer, Player targetPlayer)
	{
		Gameplay.Instance.FireWeapon(currentPlayer, targetPlayer, WeaponType.Bees);
		if (NetworkLogin.Instance != null)
		{
			NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.Bees);
			GameSystem.Instance.WeaponTargetIndex = targetPlayer.SeatIndex;
		}
	}

	public void PlayToxicFireAudio()
	{
		if (!ToxicFireAudio.isPlaying)
		{
			ToxicFireAudio.Play();
		}
	}

	public bool HasBees(Player player)
	{
		for (int i = 0; i < 6; i++)
		{
			if (m_beesPool[i].GetComponent<BeeWeapon>().HasTargetPlayer(player))
			{
				return true;
			}
		}
		return false;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		CreatePools();
	}

	private void Update()
	{
		if (m_repoolDataList.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < m_repoolDataList.Count; i++)
		{
			if (Time.time > m_repoolDataList[i].time)
			{
				RepoolObject(m_repoolDataList[i].obj);
				m_repoolDataList.Remove(m_repoolDataList[i]);
			}
		}
	}

	private void CreatePools()
	{
		m_weaponPool = new GameObject();
		m_weaponPool.transform.parent = Gameplay.Instance.gameObject.transform;
		m_weaponPool.name = "Weapon Pool";
		m_missilePool = new GameObject[6];
		m_minePool = new GameObject[6];
		m_stingerPool = new GameObject[6];
		m_toxicPool = new GameObject[6];
		m_shieldPool = new GameObject[6];
		m_reversePool = new GameObject[6];
		m_bombheadPool = new GameObject[6];
		m_nitroPool = new GameObject[6];
		m_portalPool = new GameObject[6];
		m_beesPool = new GameObject[6];
		m_radiusBombPool = new GameObject[6];
		m_missileExplosionPool = new ImpactData[6];
		m_reverseExplosionPool = new ImpactData[6];
		m_mineExplosionPool = new ImpactData[6];
		for (int i = 0; i < 6; i++)
		{
			m_missilePool[i] = UnityEngine.Object.Instantiate(MissilePrefab);
			m_missilePool[i].transform.parent = m_weaponPool.transform;
			m_missilePool[i].SetActive(value: false);
		}
		for (int j = 0; j < 6; j++)
		{
			m_minePool[j] = UnityEngine.Object.Instantiate(MinePrefab);
			m_minePool[j].transform.parent = m_weaponPool.transform;
			m_minePool[j].SetActive(value: false);
		}
		for (int k = 0; k < 6; k++)
		{
			m_stingerPool[k] = UnityEngine.Object.Instantiate(StingerPrefab);
			m_stingerPool[k].transform.parent = m_weaponPool.transform;
			m_stingerPool[k].SetActive(value: false);
		}
		for (int l = 0; l < 6; l++)
		{
			m_toxicPool[l] = UnityEngine.Object.Instantiate(ToxicPrefab);
			m_toxicPool[l].transform.parent = m_weaponPool.transform;
			m_toxicPool[l].SetActive(value: false);
		}
		for (int m = 0; m < 6; m++)
		{
			m_shieldPool[m] = UnityEngine.Object.Instantiate(ShieldPrefab);
			m_shieldPool[m].transform.parent = m_weaponPool.transform;
			m_shieldPool[m].SetActive(value: false);
		}
		for (int n = 0; n < 6; n++)
		{
			m_radiusBombPool[n] = UnityEngine.Object.Instantiate(RadiusBombPrefab);
			m_radiusBombPool[n].transform.parent = m_weaponPool.transform;
			m_radiusBombPool[n].SetActive(value: false);
		}
		for (int num = 0; num < 6; num++)
		{
			m_reversePool[num] = UnityEngine.Object.Instantiate(ReversePrefab);
			m_reversePool[num].transform.parent = m_weaponPool.transform;
			m_reversePool[num].SetActive(value: false);
		}
		for (int num2 = 0; num2 < 6; num2++)
		{
			m_nitroPool[num2] = UnityEngine.Object.Instantiate(NitroPrefab);
			m_nitroPool[num2].transform.parent = m_weaponPool.transform;
			m_nitroPool[num2].SetActive(value: false);
		}
		for (int num3 = 0; num3 < 6; num3++)
		{
			m_portalPool[num3] = UnityEngine.Object.Instantiate(PortalPrefab);
			m_portalPool[num3].transform.parent = m_weaponPool.transform;
			m_portalPool[num3].SetActive(value: false);
		}
		for (int num4 = 0; num4 < 6; num4++)
		{
			m_beesPool[num4] = UnityEngine.Object.Instantiate(BeehivePrefab);
			m_beesPool[num4].transform.parent = m_weaponPool.transform;
			m_beesPool[num4].SetActive(value: false);
		}
		for (int num5 = 0; num5 < 6; num5++)
		{
			m_mineExplosionPool[num5].ExplosionPrefab = UnityEngine.Object.Instantiate(MineExplosionData.ExplosionPrefab);
			m_mineExplosionPool[num5].AttachToEntity = MineExplosionData.AttachToEntity;
			m_mineExplosionPool[num5].ExplosionPrefab.gameObject.transform.parent = m_weaponPool.transform;
			m_mineExplosionPool[num5].ExplosionPrefab.gameObject.SetActive(value: false);
		}
		for (int num6 = 0; num6 < 6; num6++)
		{
			m_missileExplosionPool[num6].ExplosionPrefab = UnityEngine.Object.Instantiate(MissileExplosionData.ExplosionPrefab);
			m_missileExplosionPool[num6].AttachToEntity = MissileExplosionData.AttachToEntity;
			m_missileExplosionPool[num6].ExplosionPrefab.gameObject.transform.parent = m_weaponPool.transform;
			m_missileExplosionPool[num6].ExplosionPrefab.gameObject.SetActive(value: false);
		}
		for (int num7 = 0; num7 < 6; num7++)
		{
			m_reverseExplosionPool[num7].ExplosionPrefab = UnityEngine.Object.Instantiate(ReverseExplosionData.ExplosionPrefab);
			m_reverseExplosionPool[num7].AttachToEntity = ReverseExplosionData.AttachToEntity;
			m_reverseExplosionPool[num7].ExplosionPrefab.gameObject.transform.parent = m_weaponPool.transform;
			m_reverseExplosionPool[num7].ExplosionPrefab.gameObject.SetActive(value: false);
		}
	}

	public GameObject GetMissile()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_missilePool[i].activeSelf)
			{
				gameObject = m_missilePool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_missilePool[m_missileIndex];
		}
		gameObject.SetActive(value: true);
		m_missileIndex = (m_missileIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetMine()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_minePool[i].activeSelf)
			{
				gameObject = m_minePool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_minePool[m_mineIndex];
		}
		gameObject.SetActive(value: true);
		m_mineIndex = (m_mineIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetStinger()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_stingerPool[i].activeSelf)
			{
				gameObject = m_stingerPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_stingerPool[m_stingerIndex];
		}
		gameObject.SetActive(value: true);
		m_stingerIndex = (m_stingerIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetToxic()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_toxicPool[i].activeSelf)
			{
				gameObject = m_toxicPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_toxicPool[m_toxicIndex];
		}
		gameObject.SetActive(value: true);
		m_toxicIndex = (m_toxicIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetShield()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_shieldPool[i].activeSelf)
			{
				gameObject = m_shieldPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_shieldPool[m_shieldIndex];
		}
		gameObject.SetActive(value: true);
		m_shieldIndex = (m_shieldIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetRadiusBomb()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_radiusBombPool[i].activeSelf)
			{
				gameObject = m_radiusBombPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_radiusBombPool[m_radiusBombIndex];
		}
		gameObject.SetActive(value: true);
		m_radiusBombIndex = (m_radiusBombIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetReverse()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_reversePool[i].activeSelf)
			{
				gameObject = m_reversePool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_reversePool[m_reverseIndex];
		}
		gameObject.SetActive(value: true);
		m_reverseIndex = (m_reverseIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetBombhead()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_bombheadPool[i].activeSelf)
			{
				gameObject = m_bombheadPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_bombheadPool[m_bombheadIndex];
		}
		gameObject.SetActive(value: true);
		m_bombheadIndex = (m_bombheadIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetNitro()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_nitroPool[i].activeSelf)
			{
				gameObject = m_nitroPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_nitroPool[m_bombheadIndex];
		}
		gameObject.SetActive(value: true);
		m_nitroIndex = (m_nitroIndex + 1) % 6;
		return gameObject;
	}

	public GameObject GetPortal()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_portalPool[i].activeSelf)
			{
				gameObject = m_portalPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_portalPool[m_portalindex];
		}
		gameObject.SetActive(value: true);
		m_portalindex = (m_portalindex + 1) % 6;
		return gameObject;
	}

	public GameObject GetBeehive()
	{
		GameObject gameObject = null;
		for (int i = 0; i < 6; i++)
		{
			if (!m_beesPool[i].activeSelf)
			{
				gameObject = m_beesPool[i];
				break;
			}
		}
		if (!gameObject)
		{
			gameObject = m_beesPool[m_beesIndex];
		}
		gameObject.SetActive(value: true);
		m_beesIndex = (m_beesIndex + 1) % 6;
		return gameObject;
	}

	public void CreateImpactEffect(GameObject obj, Vector3 position, WeaponType type)
	{
		ParticleSystem particleSystem = null;
		bool flag = false;
		for (int i = 0; particleSystem == null || i < 6; i++)
		{
			switch (type)
			{
			case WeaponType.Mine:
			case WeaponType.Bombhead:
				particleSystem = m_mineExplosionPool[i].ExplosionPrefab;
				flag = m_mineExplosionPool[i].AttachToEntity;
				if (!particleSystem)
				{
					particleSystem = m_mineExplosionPool[m_mineExplosionIndex].ExplosionPrefab;
					flag = m_mineExplosionPool[m_mineExplosionIndex].AttachToEntity;
				}
				m_mineExplosionIndex = (m_mineExplosionIndex + 1) % 6;
				break;
			case WeaponType.Missile:
				particleSystem = m_missileExplosionPool[i].ExplosionPrefab;
				flag = m_missileExplosionPool[i].AttachToEntity;
				if (!particleSystem)
				{
					particleSystem = m_missileExplosionPool[m_missileExplosionIndex].ExplosionPrefab;
					flag = m_missileExplosionPool[m_missileExplosionIndex].AttachToEntity;
				}
				m_missileExplosionIndex = (m_missileExplosionIndex + 1) % 6;
				break;
			case WeaponType.Reverse:
				particleSystem = m_reverseExplosionPool[i].ExplosionPrefab;
				flag = m_reverseExplosionPool[i].AttachToEntity;
				if (!particleSystem)
				{
					particleSystem = m_reverseExplosionPool[m_reverseExplosionIndex].ExplosionPrefab;
					flag = m_reverseExplosionPool[m_reverseExplosionIndex].AttachToEntity;
				}
				m_reverseExplosionIndex = (m_reverseExplosionIndex + 1) % 6;
				break;
			default:
				continue;
			}
			break;
		}
		if (flag && obj != null)
		{
			particleSystem.transform.parent = obj.transform;
		}
		particleSystem.gameObject.SetActive(value: true);
		particleSystem.transform.position = position;
		particleSystem.transform.rotation = Quaternion.identity;
		particleSystem.Play();
		RepoolObject(particleSystem.gameObject, Time.time + particleSystem.duration);
	}

	public void RepoolObject(GameObject obj)
	{
		if ((bool)obj)
		{
			obj.transform.parent = m_weaponPool.transform;
			WeaponBase component = obj.GetComponent<WeaponBase>();
			if ((bool)component)
			{
				component.ReadyToRepool();
			}
			obj.SetActive(value: false);
		}
	}

	public void RepoolObject(GameObject obj, float timeToRepool)
	{
		RepoolData item = default(RepoolData);
		item.obj = obj;
		item.time = timeToRepool;
		m_repoolDataList.Add(item);
	}

	public WeaponType ChooseRandomWeapon(Player player)
	{
		WeaponType weaponType = WeaponType.Max;
		bool flag = true;
		SplitLane lane = null;
		if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
		{
			return WeaponType.Missile;
		}
		int num = player.CurrentRaceOrder;
		if (num > 0)
		{
			num = m_weaponBiasData.Length - 1;
			num -= PlayerManager.Instance.MaxPlayers - 1 - player.CurrentRaceOrder;
		}
		num = Mathf.Clamp(num, 0, m_weaponBiasData.Length - 1);
		do
		{
			flag = true;
			weaponType = m_weaponBiasData[num].GetRandomBiasWeapon();
			if (weaponType == player.LastWeaponType)
			{
				flag = false;
			}
			switch (weaponType)
			{
			case WeaponType.Bombhead:
				flag = false;
				break;
			case WeaponType.Portal:
				if (player.InSplitLane(ref lane))
				{
					flag = false;
				}
				break;
			}
		}
		while (!flag);
		player.LastWeaponType = weaponType;
		return weaponType;
	}
}
public class QuitMenu : UnityEngine.MonoBehaviour
{
	private enum QuitState
	{
		None,
		QuitToFEM,
		QuitGame,
		QuittingInProgress,
		InProgress
	}

	[SerializeField]
	private GameObject MenuObject;

	[SerializeField]
	private TextMesh QuitText1;

	[SerializeField]
	private TextMesh QuitText2;

	[SerializeField]
	private TextMesh CentreText;

	[SerializeField]
	private AudioClip OpenDialogClip;

	[SerializeField]
	private AudioClip CloseDialogClip;

	[SerializeField]
	private AudioClip SelectOptionClip;

	[SerializeField]
	private GameObject QuitGlyph;

	public static QuitMenu Instance;

	private const float TotalKickoutDialogTime = 1f;

	private string[] QuitTextEnglish = new string[2] { "STR_QuitGame", "STR_QuitRace" };

	private string KickoutTextEnglish = "STR_ConnectionLost";

	private string OnlineKickoutTextEnglish = "STR_PlayersDroppedOut";

	private string SearchDropoutTextEnglish = "STR_CannotFindPlayers";

	private string OnlineTooSlowKickoutTextEnglish = "STR_RaceOver";

	private float m_kickoutTime;

	private bool m_menuOnscreen;

	private bool m_beingKickedOut;

	private bool m_waitForNoInput;

	private bool m_onlineKickout;

	private FollowPlayerMenu m_followPlayerMenu;

	private QuitState m_quitState;

	private QuitState m_waitState;

	private bool m_pauseButtonPressed;

	private bool m_usingPauseButton;

	private float m_pauseButtonTimer;

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	public void PauseButtonPressed()
	{
		m_usingPauseButton = true;
		m_pauseButtonPressed = true;
	}

	public bool InProgress()
	{
		return m_quitState != 0 || m_menuOnscreen || m_kickoutTime > 0f;
	}

	public bool InProgressNoMenuScreen()
	{
		return m_quitState != 0 || m_kickoutTime > 0f;
	}

	public bool WasKickedOut()
	{
		bool result = m_beingKickedOut && !m_onlineKickout;
		m_beingKickedOut = false;
		return result;
	}

	public void Kickout()
	{
		if (!m_beingKickedOut)
		{
			EnableQuitMenu(string.Empty, KickoutTextEnglish);
			EnableInternalKickout();
		}
	}

	public void OnlineDropOut()
	{
		if (!m_beingKickedOut)
		{
			EnableQuitMenu(string.Empty, OnlineKickoutTextEnglish);
			EnableInternalKickout();
			m_onlineKickout = true;
		}
	}

	public void OnlineTooSlowKickout()
	{
		if (!m_beingKickedOut)
		{
			EnableQuitMenu(string.Empty, OnlineTooSlowKickoutTextEnglish);
			EnableInternalKickout();
			m_onlineKickout = true;
		}
	}

	public void OnlineSearchDropout()
	{
		if (!m_beingKickedOut)
		{
			EnableQuitMenu(string.Empty, SearchDropoutTextEnglish);
			EnableInternalKickout();
			m_onlineKickout = false;
		}
	}

	private void EnableInternalKickout()
	{
		m_kickoutTime = 1f;
		m_beingKickedOut = true;
	}

	public void Reset()
	{
		m_followPlayerMenu = GetComponent<FollowPlayerMenu>();
		m_quitState = QuitState.None;
		m_menuOnscreen = false;
		m_kickoutTime = 0f;
		m_beingKickedOut = false;
		m_onlineKickout = false;
		MenuObject.SetActive(value: false);
		m_followPlayerMenu.SetCallback(EndMenu);
	}

	public void QuitNow()
	{
		GameSystem.Instance.PlayOneShot2DClip(SelectOptionClip);
		if (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game || (NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom()))
		{
			m_waitState = QuitState.QuitToFEM;
			m_quitState = QuitState.QuittingInProgress;
		}
		else
		{
			m_waitState = QuitState.QuitGame;
			m_quitState = QuitState.QuittingInProgress;
		}
		FadeManager.Instance.FadeOut();
	}

	private void Start()
	{
		Reset();
	}

	private void Update()
	{
		if (m_kickoutTime > 0f)
		{
			m_kickoutTime -= GameTime.Instance.DeltaTime();
			if (m_kickoutTime < 0f)
			{
				m_waitState = QuitState.QuitToFEM;
				m_quitState = QuitState.QuittingInProgress;
				FadeManager.Instance.FadeOut();
			}
		}
		if (m_pauseButtonTimer > 0f)
		{
			m_pauseButtonTimer -= GameTime.Instance.DeltaTime();
		}
		if (m_waitForNoInput && !InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Quit_Menu))
		{
			m_waitForNoInput = false;
		}
		if (m_quitState != 0)
		{
			MenuObject.SetActive(value: false);
			if (!FadeManager.Instance.FinishedFading())
			{
				return;
			}
			if (m_quitState == QuitState.QuittingInProgress)
			{
				m_quitState = m_waitState;
				CameraManager.Instance.SetNewTransform(base.transform.root, 200f);
				CameraManager.Instance.GetCurrentCamera().transform.parent = base.transform.root;
				CameraManager.Instance.GetCurrentCamera().transform.localPosition = new Vector3(0f, 200f, 0f);
			}
			else if (m_quitState == QuitState.QuitToFEM)
			{
				if (!GameEntry.Instance.IsLoading() && GameEntry.Instance.FinishedLoading())
				{
					if (!m_onlineKickout && NetworkLogin.Instance != null)
					{
						NetworkLogin.Instance.LeaveRoom();
					}
					if (PlayerManager.Instance != null)
					{
						PlayerManager.Instance.DestroyNonHumanPlayers();
						m_quitState = QuitState.InProgress;
					}
					else
					{
						m_quitState = QuitState.None;
					}
					if ((bool)FEMManager.Instance)
					{
						FEMManager.Instance.ResetStates();
					}
					if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
					{
						FTUE.Instance.State = FTUE.FTUEState.End_Practice;
					}
					CameraManager.Instance.ResetAllGlobalAudioEffects();
					GameSystem.Instance.GetChampionshipMode().EndChampionshipMode();
					GameSystem.Instance.WasInGame = true;
					if ((bool)Gameplay.Instance)
					{
						Gameplay.Instance.RemoveResultsScene();
					}
					GameSystem.Instance.ReducedPowerMode(enable: true);
					GameEntry.Instance.LoadFEM();
				}
			}
			else if (m_quitState == QuitState.QuitGame)
			{
				UnityEngine.Application.Quit();
			}
		}
		else
		{
			if ((GameEntry.Instance != null && (!GameEntry.Instance.FinishedLoading() || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Splash)) || m_kickoutTime > 0f || GameSystem.Instance.ApplicationPaused)
			{
				return;
			}
			if (m_pauseButtonTimer <= 0f && ((!m_usingPauseButton && InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Quit_Menu)) || (m_usingPauseButton && m_pauseButtonPressed)))
			{
				if (!MenuObject.gameObject.activeInHierarchy)
				{
					m_pauseButtonTimer = 0.5f;
				}
				m_waitForNoInput = true;
				if (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
				{
					EnableQuitMenu(QuitTextEnglish[1], string.Empty, useQuitGlyph: true);
				}
				else
				{
					EnableQuitMenu(QuitTextEnglish[0], string.Empty, useQuitGlyph: true);
				}
			}
			else if (MenuObject.gameObject.activeInHierarchy)
			{
				m_usingPauseButton = false;
				if (!m_menuOnscreen)
				{
					if (!m_followPlayerMenu.InTransition())
					{
						MenuObject.SetActive(value: false);
					}
				}
				else if (InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Button_A))
				{
					QuitNow();
				}
			}
			if (m_pauseButtonPressed)
			{
				m_pauseButtonPressed = false;
			}
		}
	}

	private void EnableQuitMenu(string dialog1Text, string centreText, bool useQuitGlyph = false)
	{
		if (!MenuObject.gameObject.activeInHierarchy)
		{
			if ((bool)QuitGlyph)
			{
				QuitGlyph.SetActive(useQuitGlyph);
			}
			GameSystem.Instance.PlayOneShot2DClip(OpenDialogClip);
			m_menuOnscreen = true;
			if (centreText != string.Empty)
			{
				CentreText.gameObject.SetActive(value: true);
				CentreText.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(centreText, convertToUpperCase: true);
				QuitText1.gameObject.SetActive(value: false);
				QuitText2.gameObject.SetActive(value: false);
			}
			else
			{
				QuitText1.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(dialog1Text, convertToUpperCase: true);
				CentreText.gameObject.SetActive(value: false);
				QuitText1.gameObject.SetActive(value: true);
				QuitText2.gameObject.SetActive(value: true);
			}
			MenuObject.SetActive(value: true);
			m_followPlayerMenu.ForceUpdatePosition();
		}
		else
		{
			if ((bool)QuitGlyph)
			{
				QuitGlyph.SetActive(value: false);
			}
			GameSystem.Instance.PlayOneShot2DClip(CloseDialogClip);
			m_followPlayerMenu.ForceNewPosition(Vector3.zero);
			m_menuOnscreen = false;
		}
	}

	public void EndMenu()
	{
		if (m_menuOnscreen && !InProgressNoMenuScreen())
		{
			m_menuOnscreen = false;
			MenuObject.SetActive(value: false);
			GameSystem.Instance.PlayOneShot2DClip(CloseDialogClip);
			m_quitState = QuitState.None;
		}
	}
}
public class FixedFontSize : UnityEngine.MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		GetComponent<Text>().fontSize = 0;
		GetComponent<Text>().fontStyle = UnityEngine.FontStyle.Normal;
	}
}
public class ResultsManager : UnityEngine.MonoBehaviour
{
	private enum ExitResultsState
	{
		None,
		WaitingToFade,
		Fading,
		Wait
	}

	public struct OnlinePointsData
	{
		public string playerID;

		public int points;

		public bool newPointsCalculated;
	}

	public class FinishOrderData : IComparable
	{
		public Player player;

		public double totalTime;

		public int CompareTo(object obj)
		{
			FinishOrderData finishOrderData = obj as FinishOrderData;
			return totalTime.CompareTo(finishOrderData.totalTime);
		}
	}

	[SerializeField]
	private Locator[] GridPositions;

	[SerializeField]
	private float ResultsTime = 6f;

	[SerializeField]
	private ResultsTimer Timer;

	[SerializeField]
	private float TimeOut = 20f;

	[SerializeField]
	private GameObject ResultsScenery;

	[SerializeField]
	private ParticleSystem AppearParticles;

	[SerializeField]
	private GameObject WinnerTrophy;

	[SerializeField]
	private Vector3 WinnerTrophyOffset = Vector3.up;

	[SerializeField]
	private Vector3 HumanPlayerOffset = new Vector3(0f, -2.5f, 8f);

	[SerializeField]
	private GameObject CameraLocator;

	[SerializeField]
	private ResultsBoard[] Boards;

	public static ResultsManager Instance;

	private float m_resultsTimer;

	private float m_loadingTimer;

	private int m_championPointsToAdd = 10;

	private int m_pointsAddedToPlayerMask;

	private float m_resultsDelayTime = 2f;

	private bool m_playedFanFare;

	private bool m_countedPointsUp;

	private AudioSource m_audioSource;

	private ExitResultsState m_exitState;

	private float m_resultsTimeOutTimer;

	private bool m_playerFinished;

	private Player m_humanPlayer;

	private Player m_winningPlayer;

	private int m_totalFinishedPlayers;

	private List<Player> m_playerList;

	private int m_numResultsShown;

	private bool[] m_playerInPosition = new bool[8];

	private double[] m_playerFinishTimes = new double[8];

	private int m_finishTimeValidMask;

	private int m_finishTimeUsedMask;

	private bool m_readyForQuittingFTUE;

	private List<OnlinePointsData> m_onlinePointsData = new List<OnlinePointsData>();

	private float m_endAllPlayersTimer;

	private bool m_updatEndAllPlayers;

	private int m_endAllPlayersIndex;

	private float m_ResultsPauseTimer;

	public GameObject GetResultsScenery => ResultsScenery;

	public bool ChampPointsCountedUp => m_countedPointsUp;

	public void AddOnlinePoints(string ID, int points)
	{
		for (int i = 0; i < m_onlinePointsData.Count; i++)
		{
			if (m_onlinePointsData[i].playerID == ID)
			{
				OnlinePointsData value = m_onlinePointsData[i];
				value.points = points;
				m_onlinePointsData[i] = value;
				return;
			}
		}
		OnlinePointsData item = default(OnlinePointsData);
		item.playerID = ID;
		item.points = points;
		m_onlinePointsData.Add(item);
	}

	public int GetOnlinePoints(string ID)
	{
		for (int i = 0; i < m_onlinePointsData.Count; i++)
		{
			if (m_onlinePointsData[i].playerID == ID)
			{
				return m_onlinePointsData[i].points;
			}
		}
		return 0;
	}

	private bool OnlinePointsCalculated(string ID)
	{
		for (int i = 0; i < m_onlinePointsData.Count; i++)
		{
			if (m_onlinePointsData[i].playerID == ID)
			{
				return m_onlinePointsData[i].newPointsCalculated;
			}
		}
		return false;
	}

	private void SetOnlinePointsCalculated(string ID)
	{
		for (int i = 0; i < m_onlinePointsData.Count; i++)
		{
			if (m_onlinePointsData[i].playerID == ID)
			{
				OnlinePointsData value = m_onlinePointsData[i];
				value.newPointsCalculated = true;
				m_onlinePointsData[i] = value;
			}
		}
	}

	public bool ResultsActive()
	{
		return m_resultsTimer != 0f;
	}

	public void SetWinner(Player winner)
	{
		m_winningPlayer = winner;
		if (!(WinnerTrophy != null))
		{
			return;
		}
		if (!WinnerTrophy.activeSelf)
		{
			WinnerTrophy.SetActive(value: true);
		}
		WinnerTrophy.transform.position = m_winningPlayer.transform.position;
		WinnerTrophy.transform.position += WinnerTrophyOffset;
		if (m_winningPlayer.GetPlayerType() == Player.PlayerType.Human)
		{
			ProfileManager.Instance.SetWonChampModeCup(GameSystem.Instance.GetChampionshipMode().GetTrophyType());
			WinnerTrophy.transform.position += HumanPlayerOffset;
			if (!m_audioSource.isPlaying)
			{
				m_audioSource.clip = GameSystem.Instance.ChampionshipFanfareClip;
				m_audioSource.Play();
			}
		}
		WinnerTrophy.GetComponent<RotateAndBob>().OverridePosition(WinnerTrophy.transform.localPosition);
	}

	public void ResultsShown()
	{
		m_numResultsShown++;
	}

	public bool AnyResultsShown()
	{
		return m_numResultsShown > 0;
	}

	private void UpdateEndAllPlayers()
	{
		if (m_updatEndAllPlayers && GameTime.Instance.CurrentTime() > m_endAllPlayersTimer)
		{
			if (m_playerList[m_endAllPlayersIndex].ForceEndOfRaceForAI())
			{
				m_endAllPlayersTimer = GameTime.Instance.CurrentTime() + 0.3f;
			}
			m_endAllPlayersIndex++;
			if (m_endAllPlayersIndex >= m_playerList.Count)
			{
				m_updatEndAllPlayers = false;
			}
		}
	}

	public void EndAllPlayersRace()
	{
		m_updatEndAllPlayers = true;
	}

	public void InitResults()
	{
		m_audioSource = GetComponent<AudioSource>();
		if ((bool)FTUE.Instance && FTUE.Instance.State == FTUE.FTUEState.None)
		{
			ProfileManager.Instance.PlayedProCup = true;
		}
		if (!(PlayerManager.Instance != null))
		{
			return;
		}
		List<Player> playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < playerList.Count; i++)
		{
			Player player = playerList[i];
			if (!(player == null) && player.GetPlayerType() == Player.PlayerType.Human)
			{
				m_humanPlayer = player;
				break;
			}
		}
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		InitResults();
	}

	private void Update()
	{
		if (m_readyForQuittingFTUE)
		{
			m_readyForQuittingFTUE = false;
			base.gameObject.SetActive(value: false);
			PlayerManager.Instance.DestroyNonHumanPlayers();
			if (!NetworkLogin.Instance || !NetworkLogin.Instance.JoinedRoom())
			{
				Player mainPlayer = PlayerManager.Instance.AddReplayKart();
				Gameplay.Instance.EnableReplay(mainPlayer);
			}
			Gameplay.Instance.CleanUpEndOfRace(quitting: true);
			if (GameSystem.Instance.PlayingGame)
			{
				GameSystem.Instance.GetChampionshipMode().EndChampionshipMode();
				base.gameObject.transform.parent.gameObject.SetActive(value: false);
				GameSystem.Instance.WasInGame = true;
				Gameplay.Instance.RemoveResultsScene();
				GameEntry.Instance.LoadFEM();
			}
			return;
		}
		UpdateEndAllPlayers();
		if (!(Time.time < m_loadingTimer))
		{
			if (NetworkLogin.Instance != null && NetworkLogin.Instance.JoinedRoom())
			{
				CheckForFinishedPlayersOnline();
			}
			else
			{
				CheckForFinishedPlayers();
			}
			UpdateResults();
		}
	}

	private void CheckForFinishedPlayersOnline()
	{
		if (!PlayerManager.Instance)
		{
			return;
		}
		m_playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player currentPlayer = m_playerList[i];
			if (currentPlayer == null)
			{
				continue;
			}
			if (currentPlayer.GetPlayerType() == Player.PlayerType.Human)
			{
				if (currentPlayer.PlayerFinishState == Player.PlayerFinishedState.ReadyForResults && FadeManager.Instance.FinishedFading())
				{
					double totalTime = 0.0;
					double totalAvgTime = 0.0;
					NetworkLogin.Instance.GetServer().GetFinalTimes(ref totalTime, ref totalAvgTime);
					m_playerFinishTimes[currentPlayer.SeatIndex] = totalTime;
					m_finishTimeValidMask |= 1 << currentPlayer.SeatIndex;
					for (int j = 0; j < Boards.Length; j++)
					{
						Boards[j].StoreTimes(currentPlayer.SeatIndex, totalTime, totalAvgTime);
					}
					m_numResultsShown++;
					currentPlayer.PlayerFinishState = Player.PlayerFinishedState.InResults;
					m_ResultsPauseTimer = 1f;
					SetupPlayerForResults(ref currentPlayer);
					NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.ShowingResults);
					CameraLocator.transform.localScale = new Vector3(2f, 2f, 2f);
					CameraManager.Instance.SetNewTransform(CameraLocator.transform);
					Gameplay.Instance.GridLightObjects[0].transform.parent.gameObject.SetActive(value: false);
					GameSystem.Instance.ReducedPowerMode(enable: true);
					FadeManager.Instance.FadeIn();
					m_resultsTimeOutTimer = Time.time;
					m_resultsTimer = ResultsTime;
					m_playerFinished = true;
					if (GameSystem.Instance.GetChampionshipMode().ModeInProgress())
					{
						m_resultsTimer += 2f;
					}
					currentPlayer.GetComponent<KartDashboard>().ResetPickups();
				}
			}
			else
			{
				if (currentPlayer.PlayerFinishState != 0)
				{
					continue;
				}
				NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
				NetworkLogin.Instance.GetClient().GetCharacterListByIndex(currentPlayer.SeatIndex, ref data);
				if (!Mathf.Approximately((float)data.finalTime, 0f))
				{
					m_playerFinishTimes[currentPlayer.SeatIndex] = data.finalTime;
					m_finishTimeValidMask |= 1 << currentPlayer.SeatIndex;
					for (int k = 0; k < Boards.Length; k++)
					{
						Boards[k].StoreTimes(currentPlayer.SeatIndex, data.finalTime, data.avgTime);
					}
					currentPlayer.PlayerFinishState = Player.PlayerFinishedState.InResults;
					SetupPlayerForResults(ref currentPlayer);
					currentPlayer.GetComponent<VRCarAIControl>().enabled = false;
					currentPlayer.GetComponent<VRWaypointProgressTracker>().enabled = false;
				}
			}
		}
		if (m_ResultsPauseTimer > 0f)
		{
			m_ResultsPauseTimer -= GameTime.Instance.DeltaTime();
			if (m_ResultsPauseTimer < 0f)
			{
				FadeManager.Instance.FadeIn();
			}
		}
		UpdateFinishPositions();
	}

	private void SetupPlayerForResults(ref Player currentPlayer)
	{
		currentPlayer.GetComponent<Rigidbody>().isKinematic = false;
		currentPlayer.GetComponent<Rigidbody>().detectCollisions = false;
		currentPlayer.GetComponent<Rigidbody>().velocity = Vector3.zero;
		currentPlayer.GetComponent<Rigidbody>().useGravity = false;
		currentPlayer.StopExhaust();
		currentPlayer.GetComponent<VRKartaudio>().EnableOffroadAudio(enable: false);
		currentPlayer.ForceEffectsOff();
		currentPlayer.DisableNameBadge();
		if (currentPlayer.GetPlayerType() == Player.PlayerType.Human)
		{
			WeaponManager.Instance.RepoolAllObjects();
		}
		Gameplay.Instance.ResetWrongWay();
	}

	private void CheckForFinishedPlayers()
	{
		if (PlayerManager.Instance == null || (Gameplay.Instance != null && !Gameplay.Instance.RaceFinished()) || (m_humanPlayer != null && (m_humanPlayer.PlayerFinishState == Player.PlayerFinishedState.None || (m_humanPlayer.PlayerFinishState == Player.PlayerFinishedState.ReadyForResults && !FadeManager.Instance.FinishedFading()))))
		{
			return;
		}
		m_playerList = PlayerManager.Instance.GetPlayerList();
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player currentPlayer = m_playerList[i];
			if (currentPlayer == null)
			{
				continue;
			}
			if (currentPlayer.PlayerFinishState == Player.PlayerFinishedState.InResults)
			{
				currentPlayer.transform.rotation = GridPositions[currentPlayer.FinalPosition].transform.rotation;
				currentPlayer.GetComponent<Rigidbody>().velocity = Vector3.zero;
			}
			if (currentPlayer.PlayerFinishState != Player.PlayerFinishedState.ReadyForResults)
			{
				continue;
			}
			currentPlayer.FinalPosition = m_totalFinishedPlayers;
			currentPlayer.PlayerFinishState = Player.PlayerFinishedState.InResults;
			SetupPlayerForResults(ref currentPlayer);
			for (int j = 0; j < Boards.Length; j++)
			{
				Boards[j].StoreTimes(currentPlayer.SeatIndex, currentPlayer.LapDataEntry.totalTime, currentPlayer.LapDataEntry.totalAvgTime);
			}
			m_playerFinishTimes[currentPlayer.SeatIndex] = currentPlayer.LapDataEntry.totalTime;
			m_finishTimeValidMask |= 1 << currentPlayer.SeatIndex;
			currentPlayer.ForceEffectsOff();
			m_playerInPosition[m_totalFinishedPlayers] = false;
			currentPlayer.DisableNameBadge();
			m_totalFinishedPlayers++;
			if (currentPlayer.GetPlayerType() == Player.PlayerType.Human)
			{
				if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
				{
					NetworkLogin.Instance.GetServer().SetGameplayEvent(currentPlayer.SeatIndex, NetworkClient.GameplayEvent.ShowingResults);
				}
				CameraLocator.transform.localScale = new Vector3(2f, 2f, 2f);
				CameraManager.Instance.SetNewTransform(CameraLocator.transform);
				GameSystem.Instance.ReducedPowerMode(enable: true);
				m_numResultsShown++;
				Light lenFlareObject = Gameplay.Instance.LenFlareObject;
				if ((bool)lenFlareObject)
				{
					lenFlareObject.enabled = false;
					lenFlareObject.gameObject.SetActive(value: false);
				}
				if ((bool)FTUE.Instance && FTUE.Instance.State != 0)
				{
					m_readyForQuittingFTUE = true;
					continue;
				}
				if ((bool)Gameplay.Instance.SceneryRoot)
				{
					Gameplay.Instance.SceneryRoot.SetActive(value: false);
				}
				Gameplay.Instance.GridLightObjects[0].transform.parent.gameObject.SetActive(value: false);
				FadeManager.Instance.FadeIn();
				m_resultsTimeOutTimer = Time.time;
				m_playerFinished = true;
				currentPlayer.GetComponent<KartDashboard>().ResetPickups();
				m_resultsTimer = ResultsTime;
				if (GameSystem.Instance.GetChampionshipMode().ModeInProgress())
				{
					m_resultsTimer += 2f;
				}
			}
			else
			{
				currentPlayer.GetComponent<VRCarAIControl>().enabled = false;
				currentPlayer.GetComponent<VRWaypointProgressTracker>().enabled = false;
			}
		}
		if (m_resultsDelayTime > 0f && m_humanPlayer.PlayerFinishState == Player.PlayerFinishedState.InResults)
		{
			m_resultsDelayTime -= GameTime.Instance.DeltaTime();
			if (m_resultsDelayTime <= 0f)
			{
				FadeManager.Instance.FadeIn();
			}
		}
		UpdateFinishPositions();
	}

	private void UpdateFinishPositions()
	{
		List<FinishOrderData> list = new List<FinishOrderData>();
		m_finishTimeUsedMask = 0;
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player player = m_playerList[i];
			if ((bool)player && player.PlayerFinishState == Player.PlayerFinishedState.InResults)
			{
				FinishOrderData finishOrderData = new FinishOrderData();
				finishOrderData.player = player;
				finishOrderData.totalTime = m_playerFinishTimes[player.SeatIndex];
				m_finishTimeUsedMask |= 1 << player.SeatIndex;
				list.Add(finishOrderData);
			}
		}
		for (int j = 0; j < 6; j++)
		{
			if ((m_finishTimeValidMask & (1 << j)) != 0 && (m_finishTimeUsedMask & (1 << j)) == 0)
			{
				FinishOrderData finishOrderData2 = new FinishOrderData();
				finishOrderData2.player = null;
				finishOrderData2.totalTime = m_playerFinishTimes[j];
				list.Add(finishOrderData2);
			}
		}
		if (list.Count > 0)
		{
			list.Sort();
		}
		bool flag = false;
		for (int k = 0; k < list.Count; k++)
		{
			if (list[k].player == null)
			{
				continue;
			}
			list[k].player.FinalPosition = k;
			list[k].player.transform.position = GridPositions[list[k].player.FinalPosition].transform.position;
			list[k].player.transform.rotation = GridPositions[list[k].player.FinalPosition].transform.rotation;
			list[k].player.EnableRendering(enable: true, force: true);
			if (list[k].player == m_humanPlayer)
			{
				if (flag)
				{
					continue;
				}
				flag = true;
				if (m_humanPlayer != null)
				{
					CameraLocator.transform.position = m_humanPlayer.CameraLocator.transform.position;
				}
				if (!m_playedFanFare && k == 0)
				{
					if (!GameSystem.Instance.EnableTimeTrialMode || LapManager.Instance.SetNewLapRecord)
					{
						m_audioSource.clip = GameSystem.Instance.RaceFanfareClip;
						m_audioSource.Play();
						GameSystem.Instance.NumWins++;
					}
					m_playedFanFare = true;
				}
			}
			else if (flag && !m_playerInPosition[k])
			{
				m_playerInPosition[k] = true;
				list[k].player.EnableRendering(enable: true);
				if (list[k].player.GetPlayerType() != 0)
				{
					GameSystem.Instance.GetPuffParticles().DoPuff(list[k].player.transform.position);
				}
				list[k].player.transform.localScale = Vector3.zero;
			}
		}
		if (!GameSystem.Instance.GetChampionshipMode().ModeInProgress() || m_countedPointsUp || ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom()) || list.Count != PlayerManager.Instance.MaxPlayers)
		{
			return;
		}
		m_countedPointsUp = true;
		for (int l = 0; l < list.Count; l++)
		{
			if ((m_pointsAddedToPlayerMask & (1 << l)) == 0)
			{
				ProfileManager.PlayerData data = ProfileManager.Instance.GetPlayerData(list[l].player.LocalPlayerIndex);
				data.m_championPoints += m_championPointsToAdd;
				m_championPointsToAdd--;
				ProfileManager.Instance.SetPlayerData(list[l].player.LocalPlayerIndex, ref data);
				m_pointsAddedToPlayerMask |= 1 << l;
			}
		}
	}

	public void UpdateOnlinePoints()
	{
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player player = m_playerList[i];
			if ((bool)player && player.PlayerFinishState == Player.PlayerFinishedState.InResults && !OnlinePointsCalculated(player.OnlineID))
			{
				int num = (PlayerManager.Instance.MaxPlayers - 1 - player.FinalPosition) * 10;
				int num2 = GetOnlinePoints(player.OnlineID) + num;
				AddOnlinePoints(player.OnlineID, num2);
				SetOnlinePointsCalculated(player.OnlineID);
				if (player.GetPlayerType() == Player.PlayerType.Human)
				{
					NetworkLogin.Instance.SetUserData(num2);
					NetworkLogin.Instance.GetNetworkLeaderboards().AddLeaderboardEntry(NetworkLeaderboards.LeaderboardType.OnlinePoints, string.Empty, num2);
				}
			}
		}
	}

	private void UpdateResults()
	{
		if (!m_playerFinished)
		{
			return;
		}
		for (int i = 0; i < m_playerList.Count; i++)
		{
			Player player = m_playerList[i];
			if ((bool)player && (bool)player && player.transform.localScale.x < 1f)
			{
				player.transform.localScale += Vector3.one * (4f * GameTime.Instance.DeltaTime());
			}
		}
		if ((!(NetworkLogin.Instance != null) || !NetworkLogin.Instance.JoinedRoom()) && Time.time < m_resultsTimeOutTimer + TimeOut)
		{
			return;
		}
		m_resultsTimer -= GameTime.Instance.DeltaTime();
		if (m_exitState == ExitResultsState.None)
		{
			if ((bool)GameEntry.Instance && m_resultsTimer <= 0f)
			{
				if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
				{
					NetworkLogin.Instance.GetServer().SetGameplayEvent(m_humanPlayer.SeatIndex, NetworkClient.GameplayEvent.ResultsShown);
					m_exitState = ExitResultsState.WaitingToFade;
				}
				else if (!m_audioSource.isPlaying)
				{
					FadeManager.Instance.FadeOut();
					m_exitState = ExitResultsState.Fading;
				}
			}
		}
		else if (m_exitState == ExitResultsState.WaitingToFade)
		{
			float num = ((!NetworkLogin.Instance || !NetworkLogin.Instance.IsMasterPlayer()) ? (-3f) : 0f);
			if (Gameplay.Instance.InitKillGameTime && Gameplay.Instance.KillGameTime <= num && !m_audioSource.isPlaying)
			{
				FadeManager.Instance.FadeOut();
				m_exitState = ExitResultsState.Fading;
			}
		}
		else
		{
			if (m_exitState != ExitResultsState.Fading || !FadeManager.Instance.FinishedFading())
			{
				return;
			}
			if (!GameSystem.Instance.GetChampionshipMode().ModeInProgress() || !GameSystem.Instance.GetChampionshipMode().ShouldMoveOn())
			{
				m_resultsTimer = 0f;
				PlayerManager.Instance.DestroyNonHumanPlayers();
				GameSystem.Instance.GetChampionshipMode().EndChampionshipMode();
				if (GameSystem.Instance.PlayingGame)
				{
					GameSystem.Instance.WasInGame = true;
					Gameplay.Instance.RemoveResultsScene();
					GameEntry.Instance.LoadFEM();
				}
			}
			else if (m_loadingTimer == 0f)
			{
				CameraManager.Instance.SetNewTransform(CameraManager.Instance.gameObject.transform, 1f);
				m_loadingTimer = Time.time + 1f;
			}
			else
			{
				m_humanPlayer.gameObject.SetActive(value: false);
				base.gameObject.SetActive(value: false);
				m_loadingTimer = 0f;
				PlayerManager.Instance.DestroyNonHumanPlayers();
				Gameplay.Instance.RemoveResultsScene();
				string title = GameSystem.Instance.GetChampionshipMode().MoveOntoNextTrack();
				TrackList.TrackData trackByString = GameSystem.Instance.GetTrackListing().GetTrackByString(title);
				GameSystem.Instance.SetTrackToLoad(trackByString);
				GameEntry.Instance.LoadGame();
			}
		}
	}

	private void OnDisable()
	{
		m_resultsTimer = 0f;
		m_totalFinishedPlayers = 0;
	}
}
public class Balloon : UnityEngine.MonoBehaviour
{
	private static bool RandomisedUVs;

	private void Awake()
	{
		if (!RandomisedUVs)
		{
			GetComponent<MeshRenderer>().sharedMaterial.SetTextureOffset("_MainTex", new Vector2((!(UnityEngine.Random.Range(0f, 1f) < 0.5f)) ? 0.5f : 0f, (!(UnityEngine.Random.Range(0f, 1f) < 0.5f)) ? 0.5f : 0f));
			RandomisedUVs = true;
		}
	}
}
public class FlagWave : UnityEngine.MonoBehaviour
{
	private Material m_newMat;

	private void Start()
	{
		m_newMat = UnityEngine.Object.Instantiate(base.gameObject.GetComponent<Renderer>().material);
		if ((bool)m_newMat)
		{
			base.gameObject.GetComponent<Renderer>().material = m_newMat;
			float @float = base.gameObject.GetComponent<Renderer>().material.GetFloat("_WaveSpeed");
			base.gameObject.GetComponent<Renderer>().material.SetFloat("_WaveSpeed", @float + UnityEngine.Random.Range(-10f, 10f));
		}
	}
}
public class PositionBoard : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private TextMesh PositionText;

	[SerializeField]
	private TextMesh TotalRacersText;

	private static int PositionBoardFrameIndex;

	private int m_boardFrameUpdateIndex;

	private static void ReferenceCallback()
	{
		PositionBoardFrameIndex = 0;
	}

	private void Start()
	{
		GameSystem.Instance.FrameReferenceManager.RegisterFrameReference(ReferenceCallback);
		m_boardFrameUpdateIndex = PositionBoardFrameIndex;
		PositionBoardFrameIndex++;
	}

	private void Update()
	{
		int num = Time.frameCount % PositionBoardFrameIndex;
		if (num == m_boardFrameUpdateIndex && (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game))
		{
			int num2 = 0;
			int num3 = 0;
			PositionText.text = (num2 + 1).ToString();
			TotalRacersText.text = num3.ToString();
		}
	}
}
public class ScrollLight : UnityEngine.MonoBehaviour
{
	private Renderer m_renderer;

	[SerializeField]
	private float m_periodLength = 1f;

	[SerializeField]
	private float m_amount = 0.5f;

	private void Start()
	{
		m_renderer = GetComponent<Renderer>();
	}

	private void Update()
	{
		if (!Mathf.Approximately(m_periodLength, 0f))
		{
			float num = Mathf.Floor(GameTime.Instance.CurrentTime() * (1f / m_periodLength)) * m_amount;
			num %= 1f;
			m_renderer.material.SetTextureOffset("_Illum", new Vector2(num, 0f));
		}
	}
}
public class Swing : UnityEngine.MonoBehaviour
{
	public enum SwingAxis
	{
		X,
		Y,
		Z
	}

	[SerializeField]
	private SwingAxis Axis;

	[SerializeField]
	private float SwingSpeed = 5f;

	[SerializeField]
	private float RestSpeed = 10f;

	[SerializeField]
	private float MaxAngle = 40f;

	[SerializeField]
	private SwingCollision TriggerBox;

	private float m_currentAngle;

	private float m_maxSwingAngle;

	private bool m_enableSwinging;

	public void TriggerBoxEntered(bool swingForwards)
	{
		if (!m_enableSwinging)
		{
			m_enableSwinging = true;
			if (!swingForwards)
			{
				m_currentAngle = (float)Math.PI;
			}
		}
	}

	public bool AllowedToSwing()
	{
		return !m_enableSwinging;
	}

	private void OnEnable()
	{
		m_enableSwinging = TriggerBox == null;
		m_maxSwingAngle = MaxAngle;
	}

	private void Update()
	{
		if (!m_enableSwinging)
		{
			return;
		}
		m_currentAngle += SwingSpeed * GameTime.Instance.DeltaTime();
		m_currentAngle %= (float)Math.PI * 2f;
		float num = ((!(TriggerBox == null)) ? m_maxSwingAngle : MaxAngle);
		float angle = Mathf.Sin(m_currentAngle) * num;
		Quaternion b = Quaternion.identity;
		if (Axis == SwingAxis.X)
		{
			b = Quaternion.AngleAxis(angle, Vector3.right);
		}
		if (Axis == SwingAxis.Y)
		{
			b = Quaternion.AngleAxis(angle, Vector3.up);
		}
		if (Axis == SwingAxis.Z)
		{
			b = Quaternion.AngleAxis(angle, Vector3.forward);
		}
		base.transform.localRotation = Quaternion.Slerp(base.transform.localRotation, b, 10f * GameTime.Instance.DeltaTime());
		if (TriggerBox != null)
		{
			m_maxSwingAngle -= RestSpeed * GameTime.Instance.DeltaTime();
			if (m_maxSwingAngle < 0f)
			{
				m_enableSwinging = false;
				m_maxSwingAngle = MaxAngle;
			}
		}
	}
}
public class SwingCollision : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Swing SwingObject;

	private void OnTriggerEnter(Collider col)
	{
		if (!SwingObject.AllowedToSwing())
		{
			return;
		}
		Transform parent = col.transform;
		Player player = null;
		while (parent != null && parent.gameObject.GetComponent<Player>() == null)
		{
			parent = parent.parent;
		}
		if ((bool)parent)
		{
			player = parent.GetComponent<Player>();
			if (player != null)
			{
				Vector3 to = player.transform.TransformDirection(player.GetComponent<Rigidbody>().velocity.normalized);
				float num = Vector3.Angle(base.transform.forward, to);
				SwingObject.TriggerBoxEntered(num > 90f);
			}
		}
	}
}
public class SkyboxMesh : UnityEngine.MonoBehaviour
{
	public enum Shape
	{
		Sphere,
		Cube
	}

	private static readonly string _shaderText = "Shader \"SkyboxMesh Background\" {Properties {    _Color (\"Main Color\", Color) = (1,1,1,1)    _MainTex (\"Texture\", 2D) = \"white\" {}}Category {   Tags { \"Queue\"=\"Background\" }    ZWrite Off    Lighting Off    Fog {Mode Off}    BindChannels {        Bind \"Color\", color        Bind \"Vertex\", vertex        Bind \"TexCoord\", texcoord    }    SubShader {        Pass {            SetTexture [_MainTex] {                Combine texture            }            SetTexture [_MainTex] {               constantColor [_Color]            combine previous * constant            }        }    }}}";

	public Material material;

	public float radius = 800f;

	public int segments = 32;

	public Shape shape;

	public Material skybox;

	public GameObject follow;

	private void Awake()
	{
		if (material == null)
		{
			material = new Material(_shaderText);
		}
		Mesh mesh = _CreateMesh();
		_CreatePlane(mesh, "_FrontTex", Quaternion.identity);
		_CreatePlane(mesh, "_LeftTex", Quaternion.Euler(0f, 90f, 0f));
		_CreatePlane(mesh, "_BackTex", Quaternion.Euler(0f, 180f, 0f));
		_CreatePlane(mesh, "_RightTex", Quaternion.Euler(0f, 270f, 0f));
		_CreatePlane(mesh, "_UpTex", Quaternion.Euler(-90f, 0f, 0f));
		_CreatePlane(mesh, "_DownTex", Quaternion.Euler(90f, 0f, 0f));
	}

	private void LateUpdate()
	{
		if (follow != null)
		{
			base.transform.position = follow.transform.position;
		}
	}

	private Mesh _CreateMesh()
	{
		Mesh mesh = new Mesh();
		int num = segments + 1;
		int num2 = num / 2;
		int num3 = num * num;
		int num4 = segments * segments * 6;
		Vector3[] array = new Vector3[num3];
		Vector2[] array2 = new Vector2[num3];
		int[] array3 = new int[num4];
		float num5 = 2f / (float)segments;
		float num6 = 1f / (float)segments;
		if (segments <= 1 || shape == Shape.Cube)
		{
			float num7 = 0f;
			float num8 = -1f;
			int num9 = 0;
			int num10 = 0;
			while (num10 < num)
			{
				float num11 = 0f;
				float num12 = -1f;
				int num13 = 0;
				while (num13 < num)
				{
					ref Vector3 reference = ref array[num9];
					reference = new Vector3(num12, num8, 1f);
					ref Vector2 reference2 = ref array2[num9];
					reference2 = new Vector2(num11, num7);
					num13++;
					num9++;
					num11 += num6;
					num12 += num5;
				}
				num10++;
				num7 += num6;
				num8 += num5;
			}
		}
		else
		{
			float num14 = 0f;
			float num15 = -1f;
			int num16 = 0;
			int num17 = 0;
			int num18 = 0;
			while (num18 <= num2)
			{
				float num19 = 0f;
				float num20 = -1f;
				float num21 = num15 * num15;
				int num22 = 0;
				while (num22 <= num2)
				{
					float num23 = Mathf.Sqrt(num20 * num20 + num21 + 1f);
					float f = Mathf.Acos(1f / num23);
					float f2 = Mathf.Atan2(num15, num20);
					float num24 = Mathf.Sin(f);
					ref Vector3 reference3 = ref array[num16];
					reference3 = new Vector3(num24 * Mathf.Cos(f2), num24 * Mathf.Sin(f2), Mathf.Cos(f));
					ref Vector2 reference4 = ref array2[num16];
					reference4 = new Vector2(num19, num14);
					num22++;
					num16++;
					num19 += num6;
					num20 += num5;
				}
				int num25 = num2 - 1;
				while (num22 < num)
				{
					Vector3 vector = array[num17 + num25];
					ref Vector3 reference5 = ref array[num16];
					reference5 = new Vector3(0f - vector.x, vector.y, vector.z);
					ref Vector2 reference6 = ref array2[num16];
					reference6 = new Vector2(num19, num14);
					num22++;
					num16++;
					num25--;
					num19 += num6;
					num20 += num5;
				}
				num18++;
				num17 += num;
				num14 += num6;
				num15 += num5;
			}
			num17 = (num2 - 1) * num;
			int num26 = num2 + 1;
			while (num26 < num)
			{
				float num27 = 0f;
				float num28 = -1f;
				int num29 = 0;
				while (num29 <= num2)
				{
					Vector3 vector2 = array[num17 + num29];
					ref Vector3 reference7 = ref array[num16];
					reference7 = new Vector3(vector2.x, 0f - vector2.y, vector2.z);
					ref Vector2 reference8 = ref array2[num16];
					reference8 = new Vector2(num27, num14);
					num29++;
					num16++;
					num27 += num6;
					num28 += num5;
				}
				int num30 = num2 - 1;
				while (num29 < num)
				{
					Vector3 vector3 = array[num17 + num30];
					ref Vector3 reference9 = ref array[num16];
					reference9 = new Vector3(0f - vector3.x, 0f - vector3.y, vector3.z);
					ref Vector2 reference10 = ref array2[num16];
					reference10 = new Vector2(num27, num14);
					num29++;
					num16++;
					num30--;
					num27 += num6;
					num28 += num5;
				}
				num26++;
				num17 -= num;
				num14 += num6;
				num15 += num5;
			}
		}
		int num31 = 0;
		int num32 = 0;
		int num33 = 0;
		while (num31 < segments)
		{
			int num34 = num33;
			int num35 = num33 + num;
			int num36 = 0;
			while (num36 < segments)
			{
				array3[num32] = num34 + num36;
				array3[num32 + 1] = num35 + num36;
				array3[num32 + 2] = num34 + num36 + 1;
				array3[num32 + 3] = num35 + num36;
				array3[num32 + 4] = num35 + num36 + 1;
				array3[num32 + 5] = num34 + num36 + 1;
				num36++;
				num32 += 6;
			}
			num31++;
			num33 += num;
		}
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.triangles = array3;
		return mesh;
	}

	private void _CreatePlane(Mesh mesh, string textureName, Quaternion rotation)
	{
		GameObject gameObject = new GameObject();
		gameObject.name = textureName;
		gameObject.transform.parent = base.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localScale = new Vector3(radius, radius, radius);
		gameObject.transform.localRotation = rotation;
		Material material = new Material(this.material);
		material.mainTexture = skybox.GetTexture(textureName);
		MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
		meshRenderer.material = material;
		meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		meshRenderer.receiveShadows = false;
		MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
		meshFilter.mesh = mesh;
	}
}
public class InGameCamera : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float m_blendValue = 100f;

	private Player m_mainPlayer;

	private bool m_useCamUpdate;

	private void Start()
	{
		CameraManager.Instance.SetNewTransform(base.transform);
	}

	private void Update()
	{
		UpdateCam();
	}

	private void UpdateCam()
	{
		if (!m_useCamUpdate)
		{
			if (!Gameplay.Instance || Gameplay.Instance.GetGameplayState() != Gameplay.GameplayState.Initialising)
			{
				return;
			}
			if (m_mainPlayer == null)
			{
				m_mainPlayer = PlayerManager.Instance.GetPlayerList()[0];
				if ((bool)m_mainPlayer)
				{
					CameraManager.Instance.SetNewTransform(base.transform);
					m_useCamUpdate = true;
				}
			}
		}
		if (m_mainPlayer == null)
		{
			m_useCamUpdate = false;
			return;
		}
		base.transform.position = m_mainPlayer.CameraLocator.transform.position;
		base.transform.rotation = m_mainPlayer.CameraLocator.transform.rotation;
	}
}
public class LoadingRoom : UnityEngine.MonoBehaviour
{
	private enum LoadingState
	{
		None,
		WaitForPlayingControls,
		PlayingControls,
		WaitToFinish,
		FinishDelay
	}

	[SerializeField]
	private Text ChampModeLevel;

	[SerializeField]
	private Text TrackName;

	[SerializeField]
	private GameObject LogoRoot;

	[SerializeField]
	private GameObject TrophyRoot;

	[SerializeField]
	private Text NewsfeedText;

	[SerializeField]
	private GameObject DemoPad;

	[SerializeField]
	private GameObject Demo_Splash;

	[SerializeField]
	private AudioSource LogoAudio;

	[SerializeField]
	private Canvas TrackRoot;

	[SerializeField]
	private GameObject[] GearVRControllerRoot;

	[SerializeField]
	private GameObject[] GoControllerRoot;

	private bool m_playedAudio;

	private bool m_finished;

	private float m_falseTime;

	private LoadingState m_loadingState;

	public bool IsFinished()
	{
		return m_finished;
	}

	public void InitialiseLoading()
	{
		m_loadingState = LoadingState.None;
		m_finished = false;
		TrackRoot.enabled = true;
		if (!GameSystem.Instance || !GameSystem.Instance.GetChampionshipMode() || !GameSystem.Instance.GetChampionshipMode().ModeInProgress())
		{
			LogoRoot.SetActive(value: true);
			TrophyRoot.SetActive(value: false);
			ChampModeLevel.gameObject.SetActive(value: false);
		}
		else
		{
			LogoRoot.SetActive(value: false);
			TrophyRoot.SetActive(value: true);
			ChampModeLevel.gameObject.SetActive(value: true);
			switch (GameSystem.Instance.GetChampionshipMode().GetTrophyType())
			{
			case ChampionshipMode.TrophyGroupingType.Amateur:
				ChampModeLevel.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_AmateurCup", convertToUpperCase: true);
				break;
			case ChampionshipMode.TrophyGroupingType.Rookie:
				ChampModeLevel.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_RookieCup", convertToUpperCase: true);
				break;
			case ChampionshipMode.TrophyGroupingType.Pro:
				ChampModeLevel.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_ProCup", convertToUpperCase: true);
				break;
			case ChampionshipMode.TrophyGroupingType.MaxUserLevels:
				ChampModeLevel.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier("STR_RandomCup", convertToUpperCase: true);
				break;
			}
		}
		Demo_Splash.SetActive(value: false);
		DemoPad.SetActive(value: false);
		if (GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			TrackName.gameObject.SetActive(value: true);
			TrackName.text = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(GameSystem.Instance.GetLoadedTrack().Name, convertToUpperCase: true);
		}
		else
		{
			TrackName.gameObject.SetActive(value: false);
		}
		bool flag = true;
		if ((bool)NewsfeedText)
		{
			string title = string.Empty;
			string body = string.Empty;
			if (NetworkNews.Instance.GetLatestNewsItem(ref title, ref body))
			{
				NewsfeedText.gameObject.SetActive(value: true);
				NewsfeedText.text = body;
				flag = false;
			}
		}
		if (flag)
		{
			NewsfeedText.gameObject.SetActive(value: false);
		}
		FadeManager.Instance.FadeIn();
	}

	private void Update()
	{
		if (m_finished)
		{
			return;
		}
		switch (m_loadingState)
		{
		case LoadingState.None:
			if (FadeManager.Instance.FinishedFading())
			{
				if (!m_playedAudio)
				{
					m_playedAudio = true;
					LogoAudio.Play();
				}
				if (GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game && InputRemapper.Instance.GetControlSystem() == InputRemapper.ControlSystem.GearVRController)
				{
					m_falseTime = GameTime.Instance.CurrentTime() + GameEntry.Instance.FalseWaitTime;
					m_loadingState = LoadingState.WaitForPlayingControls;
				}
				else
				{
					m_finished = true;
				}
			}
			break;
		case LoadingState.WaitForPlayingControls:
			if (GameTime.Instance.CurrentTime() > m_falseTime)
			{
				FadeManager.Instance.FadeOut();
				m_loadingState = LoadingState.PlayingControls;
			}
			break;
		case LoadingState.PlayingControls:
			if (!FadeManager.Instance.FinishedFading())
			{
				break;
			}
			TrackRoot.enabled = false;
			Demo_Splash.SetActive(value: false);
			LogoRoot.SetActive(value: false);
			TrophyRoot.SetActive(value: false);
			ChampModeLevel.gameObject.SetActive(value: false);
			DemoPad.SetActive(value: true);
			if (GameSystem.Instance.IsOculusGo())
			{
				for (int i = 0; i < GearVRControllerRoot.Length; i++)
				{
					GearVRControllerRoot[i].SetActive(value: false);
				}
				for (int j = 0; j < GoControllerRoot.Length; j++)
				{
					GoControllerRoot[j].SetActive(value: true);
				}
			}
			else
			{
				for (int k = 0; k < GearVRControllerRoot.Length; k++)
				{
					GearVRControllerRoot[k].SetActive(value: true);
				}
				for (int l = 0; l < GoControllerRoot.Length; l++)
				{
					GoControllerRoot[l].SetActive(value: false);
				}
			}
			FadeManager.Instance.FadeIn();
			m_loadingState = LoadingState.WaitToFinish;
			break;
		case LoadingState.WaitToFinish:
			if (FadeManager.Instance.FinishedFading())
			{
				m_falseTime = GameTime.Instance.CurrentTime() + GameEntry.Instance.FalseWaitTime;
				m_loadingState = LoadingState.FinishDelay;
			}
			break;
		case LoadingState.FinishDelay:
			if (GameTime.Instance.CurrentTime() > m_falseTime)
			{
				m_finished = true;
				m_loadingState = LoadingState.None;
			}
			break;
		}
	}
}
public class OVRGameInput : UnityEngine.MonoBehaviour
{
	private OVRTracker tracker;

	private void Start()
	{
		tracker = new OVRTracker();
		tracker.isEnabled = false;
	}

	private void Update()
	{
		OVRInput.Update();
	}

	private void FixedUpdate()
	{
		OVRInput.FixedUpdate();
	}
}
public class Splash : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float ShowTime = 5f;

	private float m_timer;

	private bool m_finish;

	private Vector3 m_currentPos;

	private bool m_waitForLoadFinish = true;

	private void Start()
	{
		m_waitForLoadFinish = true;
	}

	private void Update()
	{
		if (m_waitForLoadFinish)
		{
			if (!(GameEntry.Instance == null) && !GameEntry.Instance.FinishedLoading())
			{
				return;
			}
			m_timer = Time.time + ShowTime;
			m_waitForLoadFinish = false;
			CameraManager.Instance.SetNewTransform(base.transform);
			FadeManager.Instance.FadeIn();
		}
		if (GameEntry.Instance != null && !m_finish && m_timer < Time.time)
		{
			m_finish = true;
			GameEntry.Instance.LoadFEM();
		}
	}
}
public class MeshBakerArtZone : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private MB3_MeshBaker m_meshBakerRoot;

	private List<GameObject> objList;

	public void AssignObjects()
	{
		objList = m_meshBakerRoot.GetObjectsToCombine();
		objList.Clear();
		AssignObjectsFromChildren(base.transform);
	}

	private void AssignObjectsFromChildren(Transform trans)
	{
		for (int i = 0; i < trans.childCount; i++)
		{
			Transform transform = trans.GetChild(i).transform;
			if (transform.childCount > 0)
			{
				AssignObjectsFromChildren(transform);
			}
			if (transform.gameObject.isStatic && (bool)transform.GetComponent<MeshRenderer>() && transform.gameObject.activeSelf)
			{
				objList.Add(transform.gameObject);
			}
		}
	}
}
public class MeshBakerArtZoneAll : UnityEngine.MonoBehaviour
{
	public void AssignAllObjects()
	{
		MeshBakerArtZone[] componentsInChildren = base.transform.GetComponentsInChildren<MeshBakerArtZone>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].AssignObjects();
		}
	}
}
public class RandomAudioPlaySingleSample : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float MinRandomTime = 0.2f;

	[SerializeField]
	private float MaxRandomTime = 0.6f;

	[SerializeField]
	private float MinRandomPitch = 1f;

	[SerializeField]
	private float MaxRandomPitch = 1f;

	private AudioSource m_audioSource;

	private float m_targetPlayTime;

	private void Start()
	{
		m_audioSource = GetComponent<AudioSource>();
		SetupTargetPlayTime();
	}

	private void Update()
	{
		if ((bool)m_audioSource && !m_audioSource.isPlaying && GameTime.Instance.CurrentTime() > m_targetPlayTime)
		{
			SetupTargetPlayTime();
			m_audioSource.pitch = MinRandomPitch + UnityEngine.Random.Range(0f, MaxRandomPitch - MinRandomPitch);
			m_audioSource.Play();
		}
	}

	private void SetupTargetPlayTime()
	{
		m_targetPlayTime = GameTime.Instance.CurrentTime() + UnityEngine.Random.Range(MinRandomTime, MaxRandomTime);
	}
}
public class BuildSettings : UnityEngine.MonoBehaviour
{
	public enum BuildType
	{
		Demo_Build,
		Full_Build
	}

	[SerializeField]
	private BuildType m_type;

	private static BuildSettings s_instance;

	public BuildType Type => m_type;

	public static BuildSettings Instance
	{
		get
		{
			if (s_instance == null)
			{
				GameObject gameObject = Resources.Load("BuildSettings") as GameObject;
				if (gameObject != null)
				{
					s_instance = gameObject.GetComponent<BuildSettings>();
				}
			}
			return s_instance;
		}
	}
}
public class CameraLayerDistances : UnityEngine.MonoBehaviour
{
	[Serializable]
	private struct LayerDataStruct
	{
		public int layerIndex;

		public float CameraDistance;
	}

	[SerializeField]
	private LayerDataStruct[] LayerData;

	public int CurrentOffsetValue;

	private int m_sceneLayerOffset;

	private void Awake()
	{
		UnityEngine.Object.Destroy(this);
	}

	private void SetupLayers()
	{
		Camera component = GetComponent<Camera>();
		Camera[] componentsInChildren = component.GetComponentsInChildren<Camera>();
		float[] array = new float[32];
		for (int i = 0; i < LayerData.Length; i++)
		{
			array[LayerData[i].layerIndex] = LayerData[i].CameraDistance;
			if (LayerData[i].layerIndex == LayerMask.NameToLayer("ShowInWingMirrors"))
			{
				array[LayerData[i].layerIndex] += m_sceneLayerOffset;
			}
		}
		component.layerCullDistances = array;
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			componentsInChildren[j].layerCullDistances = array;
		}
	}

	public void AddSceneLayerOffset(int offset)
	{
		m_sceneLayerOffset = offset;
		CurrentOffsetValue = offset;
		SetupLayers();
	}
}
public class CameraManager : UnityEngine.MonoBehaviour
{
	public enum CameraType
	{
		Google = 0,
		FP = 1,
		SwitchAbleCameras = 2,
		Replay = 2,
		Credits = 3,
		DebugFlyCam = 4,
		TabletCamera = 5
	}

	public enum VisorType
	{
		Offroad,
		Motion
	}

	[SerializeField]
	private GameCamera[] CameraList;

	[SerializeField]
	private VisorOverlay[] OffroadOverlay;

	[SerializeField]
	private VisorOverlay[] MotionOverlay;

	private int m_currentCameraIndex;

	private Transform m_cameraParentTransform;

	private Vector3 m_cachedLocalPosition = Vector3.zero;

	private bool m_newParentAttached;

	private AudioLowPassFilter m_lowPassFilter;

	private AudioReverbFilter m_reverbFilter;

	public static CameraManager Instance;

	private const float LowPassEnableValue = 1600f;

	private const float LowPassDisableValue = 22000f;

	private float m_currentLowPassValue = 22000f;

	private float m_targetLowPassValue = 22000f;

	private const float ReverbEnableValue = 395f;

	private const float ReverbDisableValue = -10000f;

	private float m_currentReverbValue = -10000f;

	private float m_targetReverbValue = -10000f;

	private int m_lowpassRefCount;

	private int m_reverbRefCount;

	private float OculusCameraScale = 1f;

	private float m_camYHeight;

	private Vector3 m_previousHeadsetAngle = Vector3.zero;

	private float MaxHeadsetAngleDiffX = 0.4f;

	private float MaxHeadsetAngleDiffY = 0.8f;

	private float MaxOverlayTransitionSpeedX = 0.2f;

	private float MaxOverlayTransitionSpeedY = 0.4f;

	public void SetCamYHeight(float yHeight)
	{
		m_camYHeight = yHeight;
	}

	public GameCamera GetCurrentCamera()
	{
		return CameraList[m_currentCameraIndex].GetComponent<GameCamera>();
	}

	public void UpdateFollow(GameObject objectToFollow)
	{
		FPCamera component = GetCameraByType(CameraType.FP).GetComponent<FPCamera>();
		if ((bool)component)
		{
			component.followOrientation = objectToFollow.transform;
		}
	}

	public void ResetFollow()
	{
		FPCamera component = CameraList[m_currentCameraIndex].gameObject.GetComponent<FPCamera>();
		if ((bool)component)
		{
			component.followOrientation = null;
		}
	}

	public void SetMovement(bool enable)
	{
	}

	public void ResetAllGlobalAudioEffects()
	{
		m_reverbRefCount = 0;
		m_lowpassRefCount = 0;
		EnableReverbFilter(enable: false);
		EnableLowPassFilter(enable: false);
		m_lowpassRefCount = 0;
		m_reverbRefCount = 0;
	}

	public void EnableLowPassFilter(bool enable)
	{
		if (!enable || !QuitMenu.Instance.InProgress())
		{
			if (enable)
			{
				m_lowpassRefCount++;
			}
			else if (m_lowpassRefCount > 0)
			{
				m_lowpassRefCount--;
			}
			m_targetLowPassValue = ((m_lowpassRefCount <= 0) ? 22000f : 1600f);
		}
	}

	public void EnableReverbFilter(bool enable)
	{
		if (!enable || !QuitMenu.Instance.InProgress())
		{
			if (enable)
			{
				m_reverbRefCount++;
			}
			else if (m_reverbRefCount > 0)
			{
				m_reverbRefCount--;
			}
			m_targetReverbValue = ((m_reverbRefCount <= 0) ? (-10000f) : 395f);
		}
	}

	public float GetOverlayTransitionAmount(VisorType visorType, VisorOverlay.OverlayType type)
	{
		switch (visorType)
		{
		case VisorType.Offroad:
			if (type == VisorOverlay.OverlayType.All)
			{
				return OffroadOverlay[0].GetOverlayTransitionAmount(VisorOverlay.OverlayType.Left);
			}
			return OffroadOverlay[0].GetOverlayTransitionAmount(type);
		case VisorType.Motion:
			if (type == VisorOverlay.OverlayType.All)
			{
				return MotionOverlay[0].GetOverlayTransitionAmount(VisorOverlay.OverlayType.Left);
			}
			return MotionOverlay[0].GetOverlayTransitionAmount(type);
		default:
			return 0f;
		}
	}

	public void SetOverlayTransition(VisorType visorType, VisorOverlay.OverlayType type, float normalisedTarget, float speed)
	{
		if (visorType == VisorType.Offroad)
		{
			for (int i = 0; i < OffroadOverlay.Length; i++)
			{
				if (type == VisorOverlay.OverlayType.All)
				{
					OffroadOverlay[i].SetOverlayTransition(VisorOverlay.OverlayType.Left, normalisedTarget, speed);
					OffroadOverlay[i].SetOverlayTransition(VisorOverlay.OverlayType.Right, normalisedTarget, speed);
					OffroadOverlay[i].SetOverlayTransition(VisorOverlay.OverlayType.Up, normalisedTarget, speed);
					OffroadOverlay[i].SetOverlayTransition(VisorOverlay.OverlayType.Down, normalisedTarget, speed);
				}
				else
				{
					OffroadOverlay[i].SetOverlayTransition(type, normalisedTarget, speed);
				}
			}
		}
		else
		{
			if (MotionOverlay.Length <= 0 || visorType != VisorType.Motion)
			{
				return;
			}
			for (int j = 0; j < MotionOverlay.Length; j++)
			{
				if (type == VisorOverlay.OverlayType.All)
				{
					MotionOverlay[j].SetOverlayTransition(VisorOverlay.OverlayType.Left, normalisedTarget, speed);
					MotionOverlay[j].SetOverlayTransition(VisorOverlay.OverlayType.Right, normalisedTarget, speed);
					MotionOverlay[j].SetOverlayTransition(VisorOverlay.OverlayType.Up, normalisedTarget, speed);
					MotionOverlay[j].SetOverlayTransition(VisorOverlay.OverlayType.Down, normalisedTarget, speed);
				}
				else
				{
					MotionOverlay[j].SetOverlayTransition(type, normalisedTarget, speed);
				}
			}
		}
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		for (int i = 0; i < CameraList.Length; i++)
		{
			if ((bool)CameraList[i] && (bool)CameraList[i].GetComponent<AudioListener>())
			{
				CameraList[i].GetComponent<AudioListener>().enabled = false;
			}
			m_currentCameraIndex = i;
			EnableCamera(enable: false);
		}
	}

	private void Start()
	{
		m_currentLowPassValue = 22000f;
		SetupDefaultCamera();
	}

	private void SetupDefaultCamera()
	{
		int num = 0;
		num = 0;
		UpdateCameraSelection((CameraType)num);
		m_currentCameraIndex = num;
		EnableCamera(enable: true);
	}

	private void Update()
	{
		UpdateLowPass();
		UpdateReverb();
		UpdateMotionVisor();
	}

	private void UpdateMotionVisor()
	{
		if (GameEntry.Instance == null || (GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game && (bool)Gameplay.Instance && Gameplay.Instance.GetGameplayState() != Gameplay.GameplayState.Initialising && (bool)ResultsManager.Instance && !ResultsManager.Instance.ResultsActive()))
		{
			Vector3 localEulerAngles = Instance.GetCurrentCamera().m_cameraArray[0].transform.localEulerAngles;
			Vector3 vector = localEulerAngles - m_previousHeadsetAngle;
			vector.x = Mathf.Clamp(vector.x, 0f - MaxHeadsetAngleDiffY, MaxHeadsetAngleDiffY);
			vector.y = Mathf.Clamp(vector.y, 0f - MaxHeadsetAngleDiffX, MaxHeadsetAngleDiffX);
			vector.z = Mathf.Clamp(vector.z, 0f - MaxHeadsetAngleDiffX, MaxHeadsetAngleDiffX);
			Instance.SetOverlayTransition(VisorType.Motion, VisorOverlay.OverlayType.Left, (!(vector.y < 0f)) ? 0f : (vector.y / (0f - MaxHeadsetAngleDiffX)), MaxOverlayTransitionSpeedX);
			Instance.SetOverlayTransition(VisorType.Motion, VisorOverlay.OverlayType.Right, (!(vector.y > 0f)) ? 0f : (vector.y / MaxHeadsetAngleDiffX), MaxOverlayTransitionSpeedX);
			Instance.SetOverlayTransition(VisorType.Motion, VisorOverlay.OverlayType.Up, (!(vector.x < 0f)) ? 0f : (vector.x / (0f - MaxHeadsetAngleDiffY)), MaxOverlayTransitionSpeedY);
			Instance.SetOverlayTransition(VisorType.Motion, VisorOverlay.OverlayType.Down, (!(vector.x > 0f)) ? 0f : (vector.x / MaxHeadsetAngleDiffY), MaxOverlayTransitionSpeedY);
			m_previousHeadsetAngle = localEulerAngles;
		}
		else
		{
			Instance.SetOverlayTransition(VisorType.Motion, VisorOverlay.OverlayType.All, 0f, MaxOverlayTransitionSpeedX);
			Instance.SetOverlayTransition(VisorType.Offroad, VisorOverlay.OverlayType.All, 0f, MaxOverlayTransitionSpeedX);
		}
	}

	private void UpdateLowPass()
	{
		m_currentLowPassValue = Mathf.Lerp(m_currentLowPassValue, m_targetLowPassValue, 8f * GameTime.Instance.DeltaTime());
		if ((bool)m_lowPassFilter)
		{
			m_lowPassFilter.enabled = 22000f - m_currentLowPassValue > 4f;
			m_lowPassFilter.cutoffFrequency = m_currentLowPassValue;
		}
	}

	private void UpdateReverb()
	{
		m_currentReverbValue = Mathf.Lerp(m_currentReverbValue, m_targetReverbValue, 8f * GameTime.Instance.DeltaTime());
		if ((bool)m_reverbFilter)
		{
			m_reverbFilter.enabled = m_currentReverbValue > -9500f;
			m_reverbFilter.reverbLevel = m_currentReverbValue;
		}
	}

	private void LateUpdate()
	{
		if (m_newParentAttached || (m_cameraParentTransform != null && GetCurrentCamera().transform.parent != m_cameraParentTransform))
		{
			if (GetCurrentType() != CameraType.SwitchAbleCameras)
			{
				GetCurrentCamera().transform.parent = m_cameraParentTransform;
				GetCurrentCamera().transform.localPosition = m_cachedLocalPosition;
				GetCurrentCamera().transform.localRotation = Quaternion.identity;
				m_newParentAttached = false;
			}
			if (GetCurrentType() != CameraType.FP)
			{
			}
		}
		if (GetCurrentType() != CameraType.DebugFlyCam && !QuitMenu.Instance.InProgress() && !Mathf.Approximately(GetCurrentCamera().transform.localPosition.y, m_camYHeight))
		{
			Vector3 localPosition = GetCurrentCamera().transform.localPosition;
			localPosition.y = m_camYHeight;
			GetCurrentCamera().transform.localPosition = localPosition;
		}
	}

	private void EnableCamera(bool enable)
	{
		GameCamera component = CameraList[m_currentCameraIndex].GetComponent<GameCamera>();
		AudioListener[] componentsInChildren = component.GetComponentsInChildren<AudioListener>();
		AudioListener[] array = componentsInChildren;
		foreach (AudioListener audioListener in array)
		{
			audioListener.enabled = enable;
			if (enable && (bool)audioListener.GetComponent<AudioLowPassFilter>())
			{
				m_lowPassFilter = audioListener.GetComponent<AudioLowPassFilter>();
			}
			if (enable && (bool)audioListener.GetComponent<AudioReverbFilter>())
			{
				m_reverbFilter = audioListener.GetComponent<AudioReverbFilter>();
			}
		}
		AudioListener component2 = component.GetComponent<AudioListener>();
		if ((bool)component2)
		{
			component2.enabled = enable;
			if (enable && (bool)component2.GetComponent<AudioLowPassFilter>())
			{
				m_lowPassFilter = component2.GetComponent<AudioLowPassFilter>();
			}
			if (enable && (bool)component2.GetComponent<AudioReverbFilter>())
			{
				m_reverbFilter = component2.GetComponent<AudioReverbFilter>();
			}
		}
		if (!enable)
		{
			component.transform.parent = base.transform;
			component.transform.localPosition = Vector3.zero;
		}
		if ((bool)component.GetComponent<Camera>())
		{
			component.GetComponent<Camera>().enabled = enable;
		}
		component.gameObject.SetActive(enable);
		if (!enable)
		{
		}
	}

	public void UpdateCameraSelection(CameraType newIndex)
	{
		EnableCamera(enable: false);
		m_currentCameraIndex = (int)newIndex;
		EnableCamera(enable: true);
	}

	public void EnableRenderTargetCamera(CameraType index, bool enableCam, bool enableListener)
	{
		CameraList[(int)index].gameObject.SetActive(enableCam);
		Camera[] cameraArray = CameraList[(int)index].m_cameraArray;
		foreach (Camera camera in cameraArray)
		{
			camera.enabled = enableCam;
			if ((bool)camera.GetComponent<AudioListener>())
			{
				camera.GetComponent<AudioListener>().enabled = enableListener;
			}
		}
	}

	public bool IsCameraEnabled(CameraType index)
	{
		if (CameraList[(int)index].m_cameraArray.Length > 0)
		{
			return CameraList[(int)index].m_cameraArray[0].enabled;
		}
		return false;
	}

	public CameraType GetCurrentType()
	{
		return (CameraType)m_currentCameraIndex;
	}

	public GameCamera GetCameraByType(CameraType type)
	{
		return CameraList[(int)type];
	}

	public bool SetNewTransform(Transform transform, float yHeight = 0f)
	{
		bool result = m_cameraParentTransform == transform;
		m_cameraParentTransform = transform;
		m_cachedLocalPosition = new Vector3(0f, yHeight, 0f);
		m_newParentAttached = true;
		return result;
	}

	public void SetNewTransformImmediate(Transform transform)
	{
		GetCurrentCamera().transform.parent = transform;
		GetCurrentCamera().transform.localPosition = Vector3.zero;
		m_cameraParentTransform = transform;
		m_newParentAttached = false;
	}

	public void ResetAllCameras()
	{
		m_cameraParentTransform = base.transform;
		GameCamera[] cameraList = CameraList;
		foreach (GameCamera gameCamera in cameraList)
		{
			gameCamera.transform.parent = base.transform;
			gameCamera.transform.localPosition = Vector3.zero;
		}
	}
}
[AddComponentMenu("Camera-Control/FirstPerson")]
public class FPCamera : UnityEngine.MonoBehaviour
{
	private float xSpeed = 180f;

	private float ySpeed = 80f;

	private float x;

	private float y;

	private float xAcc = 2f;

	private float yAcc = 2f;

	private float xInertia = 12f;

	private float yInertia = 12f;

	private float xMaxAcc = 0.05f;

	private float yMaxAcc = 0.05f;

	public bool allowMovement = true;

	public Transform followOrientation;

	private float fVelX;

	private float fVelY;

	private bool m_usingMouse = true;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
	}

	private void Update()
	{
		if (CameraManager.Instance.GetCurrentType() != CameraManager.CameraType.FP && CameraManager.Instance.GetCurrentType() != CameraManager.CameraType.DebugFlyCam)
		{
			return;
		}
		x += Input.GetAxis("Mouse X") * xSpeed * 0.01f;
		y -= Input.GetAxis("Mouse Y") * ySpeed * 0.01f;
		x += Input.GetAxis("Horizontal R") * xSpeed * 0.004f;
		y += Input.GetAxis("Vertical R") * ySpeed * 0.008f;
		float num = ((!followOrientation) ? 0f : followOrientation.transform.eulerAngles.y);
		Quaternion rotation = Quaternion.Euler(y, x + num, 0f);
		base.transform.rotation = rotation;
		if (Mathf.Abs(Input.GetAxis("Mouse X")) > 0.02f || Mathf.Abs(Input.GetAxis("Mouse Y")) > 0.02f)
		{
			m_usingMouse = true;
		}
		else if (Mathf.Abs(Input.GetAxis("Horizontal R")) > 0.02f || Mathf.Abs(Input.GetAxis("Vertical R")) > 0.02f)
		{
			m_usingMouse = false;
		}
		if (!m_usingMouse)
		{
			x = Mathf.Lerp(x, 0f, 2f * GameTime.Instance.DeltaTime());
			y = Mathf.Lerp(y, 0f, 2f * GameTime.Instance.DeltaTime());
		}
		if (allowMovement)
		{
			if (Input.GetKey(KeyCode.W))
			{
				fVelX += xAcc;
			}
			else if (Input.GetKey(KeyCode.S))
			{
				fVelX -= xAcc;
			}
			if (Input.GetKey(KeyCode.A))
			{
				fVelY -= yAcc;
			}
			else if (Input.GetKey(KeyCode.D))
			{
				fVelY += yAcc;
			}
		}
		fVelX = Mathf.Clamp(fVelX, 0f - xMaxAcc, xMaxAcc);
		fVelY = Mathf.Clamp(fVelY, 0f - yMaxAcc, yMaxAcc);
		Vector3 forward = base.transform.forward;
		Vector3 right = base.transform.right;
		Vector3 vector = forward * fVelX;
		Vector3 vector2 = right * fVelY;
		base.transform.position += vector;
		base.transform.position += vector2;
		fVelX = Mathf.Lerp(fVelX, 0f, xInertia * (1f / 60f));
		fVelY = Mathf.Lerp(fVelY, 0f, yInertia * (1f / 60f));
	}

	private float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class GameCamera : UnityEngine.MonoBehaviour
{
	public Camera[] m_cameraArray;
}
public class OculusCameraFade : UnityEngine.MonoBehaviour
{
	private void OnPostRender()
	{
		if (FadeManager.Instance.GetFadeAlpha() > 0f)
		{
			Material fadeMaterial = FadeManager.Instance.GetFadeMaterial();
			fadeMaterial.SetPass(0);
			GL.PushMatrix();
			GL.LoadOrtho();
			GL.Color(fadeMaterial.color);
			GL.Begin(7);
			GL.Vertex3(0f, 0f, -12f);
			GL.Vertex3(0f, 1f, -12f);
			GL.Vertex3(1f, 1f, -12f);
			GL.Vertex3(1f, 0f, -12f);
			GL.End();
			GL.PopMatrix();
		}
	}
}
public class ReplayCamera : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Vector2 RotationRange;

	[SerializeField]
	private float FollowSpeed = 1f;

	[SerializeField]
	public float DetectionRange = 100f;

	[SerializeField]
	private Vector3 DetectionOffset;

	public static bool ShowAllCameras;

	private Vector3 m_followAngles;

	protected Vector3 m_followVelocity;

	private Quaternion m_originalRotation;

	private Vector3 m_cachedDetectionPositon;

	private Camera m_replayCamera;

	private GameObject m_target;

	private bool m_snapCamera;

	private Vector2 m_currentAngles = Vector2.zero;

	public void SetReplayCamera(Camera cam, GameObject target)
	{
		if (!base.enabled)
		{
			m_snapCamera = true;
			m_replayCamera = cam;
			m_target = target;
			base.enabled = true;
			m_originalRotation = base.transform.localRotation;
			Update();
		}
	}

	public void CacheDetectionPosition()
	{
		Vector3 vector = base.transform.rotation * DetectionOffset;
		m_cachedDetectionPositon = vector + base.transform.position;
	}

	public Vector2 GetCurrentAngles()
	{
		return m_currentAngles;
	}

	private void Start()
	{
		m_originalRotation = base.transform.localRotation;
	}

	private void Update()
	{
		if (!(m_target == null))
		{
			base.transform.localRotation = m_originalRotation;
			Vector3 vector = base.transform.InverseTransformPoint(m_target.transform.position);
			float value = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
			value = Mathf.Clamp(value, (0f - RotationRange.y) * 0.5f, RotationRange.y * 0.5f);
			base.transform.localRotation = m_originalRotation * Quaternion.Euler(0f, value, 0f);
			vector = base.transform.InverseTransformPoint(m_target.transform.position);
			float value2 = Mathf.Atan2(vector.y, vector.z) * 57.29578f;
			value2 = Mathf.Clamp(value2, (0f - RotationRange.x) * 0.5f, RotationRange.x * 0.5f);
			Vector3 vector2 = new Vector3(m_followAngles.x + Mathf.DeltaAngle(m_followAngles.x, value2), m_followAngles.y + Mathf.DeltaAngle(m_followAngles.y, value));
			m_currentAngles.x = value2;
			m_currentAngles.y = value;
			if (m_snapCamera)
			{
				m_followAngles = vector2;
				m_snapCamera = false;
			}
			else
			{
				m_followAngles = Vector3.SmoothDamp(m_followAngles, vector2, ref m_followVelocity, FollowSpeed * GameTime.Instance.DeltaTime());
			}
			base.transform.localRotation = m_originalRotation * Quaternion.Euler(0f - m_followAngles.x, m_followAngles.y, 0f);
			m_replayCamera.transform.position = base.transform.position;
			m_replayCamera.transform.rotation = base.transform.rotation;
		}
	}

	public Vector3 GetDetectionPosition()
	{
		if (Gameplay.Instance != null && Gameplay.Instance.RaceStarted())
		{
			return m_cachedDetectionPositon;
		}
		Vector3 vector = base.transform.rotation * DetectionOffset;
		return vector + base.transform.position;
	}

	private void OnDrawGizmos()
	{
		if (ShowAllCameras)
		{
			DrawReplaySphere();
		}
	}

	private void OnDrawGizmosSelected()
	{
		DrawReplaySphere();
	}

	private void DrawReplaySphere()
	{
		Gizmos.color = UnityEngine.Color.cyan;
		Gizmos.DrawWireSphere(GetDetectionPosition(), DetectionRange);
		DrawLine(base.transform.position + new Vector3(0f, 0f, 0f), base.transform.position + new Vector3(0f, 0f, 5f));
		DrawLine(base.transform.position + new Vector3(0f, 0f, 5f), base.transform.position + new Vector3(1f, 0f, 4f));
		DrawLine(base.transform.position + new Vector3(0f, 0f, 5f), base.transform.position + new Vector3(-1f, 0f, 4f));
	}

	private void DrawLine(Vector3 vec1, Vector3 vec2)
	{
		vec1 -= base.transform.position;
		vec1 = base.transform.rotation * vec1;
		vec1 += base.transform.position;
		vec2 -= base.transform.position;
		vec2 = base.transform.rotation * vec2;
		vec2 += base.transform.position;
		Gizmos.DrawLine(vec1, vec2);
	}
}
public class CameraFade : UnityEngine.MonoBehaviour
{
	public UnityEngine.Color fadeColor = new UnityEngine.Color(0.01f, 0.01f, 0.01f, 1f);

	public Shader fadeShader;

	private Material fadeMaterial;

	private float m_currentFadeAmount;

	private float FadeZVal = -5f;

	private void Awake()
	{
		fadeMaterial = ((!(fadeShader != null)) ? new Material(Shader.Find("Transparent/Diffuse")) : new Material(fadeShader));
	}

	private void Update()
	{
	}

	public void UpdateFade()
	{
		UnityEngine.Color color = fadeColor;
		m_currentFadeAmount = FadeManager.Instance.GetFadeAlpha();
		color.a = m_currentFadeAmount;
		fadeMaterial.color = color;
	}

	private void OnPostRender()
	{
		if (m_currentFadeAmount > 0f)
		{
			fadeMaterial.SetPass(0);
			GL.PushMatrix();
			GL.LoadOrtho();
			GL.Color(fadeMaterial.color);
			GL.Begin(7);
			GL.Vertex3(0f, 0f, FadeZVal);
			GL.Vertex3(0f, 1f, FadeZVal);
			GL.Vertex3(1f, 1f, FadeZVal);
			GL.Vertex3(1f, 0f, FadeZVal);
			GL.End();
			GL.PopMatrix();
		}
	}
}
[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class CameraFog : UnityEngine.MonoBehaviour
{
	public bool Enabled;

	public float StartDistance;

	public float EndDistance;

	public FogMode Mode;

	public float Density;

	public UnityEngine.Color Color;

	private float _startDistance;

	private float _endDistance;

	private FogMode _mode;

	private float _density;

	private UnityEngine.Color _color;

	private bool _enabled;

	private void OnPreRender()
	{
		_startDistance = RenderSettings.fogStartDistance;
		_endDistance = RenderSettings.fogEndDistance;
		_mode = RenderSettings.fogMode;
		_density = RenderSettings.fogDensity;
		_color = RenderSettings.fogColor;
		_enabled = RenderSettings.fog;
		RenderSettings.fog = Enabled;
		RenderSettings.fogStartDistance = StartDistance;
		RenderSettings.fogEndDistance = EndDistance;
		RenderSettings.fogMode = Mode;
		RenderSettings.fogDensity = Density;
		RenderSettings.fogColor = Color;
	}

	private void OnPostRender()
	{
		RenderSettings.fog = _enabled;
		RenderSettings.fogStartDistance = _startDistance;
		RenderSettings.fogEndDistance = _endDistance;
		RenderSettings.fogMode = _mode;
		RenderSettings.fogDensity = _density;
		RenderSettings.fogColor = _color;
	}
}
public class ComponentDistanceCheck : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private Behaviour[] m_components;

	[SerializeField]
	private Renderer[] m_renderingComponents;

	[SerializeField]
	private GameObject[] m_objectComponents;

	[SerializeField]
	private float MinEnableDistance = 10f;

	[SerializeField]
	private Vector3 m_positionOffset = Vector3.zero;

	private float m_sqrDistance;

	private bool m_enabled = true;

	private static int s_frameUpdate = 1;

	private static int s_objectsPerFrame = 5;

	private static int s_currentObjectPerFrame;

	private int m_currentFrameForUpdate;

	private static void ReferenceCallback()
	{
		s_frameUpdate = 1;
		s_objectsPerFrame = 5;
		s_currentObjectPerFrame = 0;
	}

	private void Start()
	{
		GameSystem.Instance.FrameReferenceManager.RegisterFrameReference(ReferenceCallback);
		s_currentObjectPerFrame++;
		if (s_currentObjectPerFrame > s_objectsPerFrame)
		{
			s_frameUpdate++;
			s_currentObjectPerFrame = 0;
		}
		m_currentFrameForUpdate = s_frameUpdate;
		m_sqrDistance = MinEnableDistance * MinEnableDistance;
	}

	private void Update()
	{
		if (s_frameUpdate <= m_currentFrameForUpdate)
		{
			s_frameUpdate++;
		}
		if (Time.frameCount % s_frameUpdate != m_currentFrameForUpdate)
		{
			return;
		}
		int num = 0;
		float sqrMagnitude = (CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.position - (base.transform.position + m_positionOffset)).sqrMagnitude;
		if (sqrMagnitude < m_sqrDistance && !m_enabled)
		{
			m_enabled = true;
			for (num = 0; num < m_components.Length; num++)
			{
				m_components[num].enabled = true;
			}
			for (num = 0; num < m_renderingComponents.Length; num++)
			{
				m_renderingComponents[num].enabled = true;
			}
			for (num = 0; num < m_objectComponents.Length; num++)
			{
				m_objectComponents[num].SetActive(value: true);
			}
		}
		else if (sqrMagnitude >= m_sqrDistance && m_enabled)
		{
			m_enabled = false;
			for (num = 0; num < m_components.Length; num++)
			{
				m_components[num].enabled = false;
			}
			for (num = 0; num < m_renderingComponents.Length; num++)
			{
				m_renderingComponents[num].enabled = false;
			}
			for (num = 0; num < m_objectComponents.Length; num++)
			{
				m_objectComponents[num].SetActive(value: false);
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = new UnityEngine.Color(0f, 0f, 1f, 0.35f);
		Gizmos.DrawSphere(base.transform.position + m_positionOffset, MinEnableDistance);
	}
}
public class FadeManager : UnityEngine.MonoBehaviour
{
	public enum FadeState
	{
		None,
		FadeIn,
		FadeOut
	}

	public static FadeManager Instance;

	[SerializeField]
	private float m_fadeSpeed;

	[SerializeField]
	private MeshRenderer quad;

	private List<CameraFade> m_fadeList = new List<CameraFade>();

	private float m_alpha = 1f;

	private FadeState m_state;

	private float m_fadeSpeedOverride;

	private float m_fadeTargetOverride;

	private int m_waitFrameUpdate;

	private Material m_fadeMaterial;

	public Material GetFadeMaterial()
	{
		return m_fadeMaterial;
	}

	public void AttachFadeToCamera()
	{
		m_fadeList.Clear();
		for (int i = 0; i < CameraManager.Instance.GetCurrentCamera().m_cameraArray.Length; i++)
		{
			m_fadeList.Add(CameraManager.Instance.GetCurrentCamera().m_cameraArray[i].GetComponent<CameraFade>());
		}
	}

	public float GetFadeAlpha()
	{
		return m_alpha;
	}

	public FadeState GetFadeState()
	{
		return m_state;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
			m_fadeMaterial = new Material(Shader.Find("Oculus/Unlit Transparent Color"));
			m_fadeMaterial.color = UnityEngine.Color.black;
			m_fadeMaterial.renderQueue = 5000;
		}
	}

	private void Start()
	{
		m_alpha = ((!(GameEntry.Instance != null)) ? 1f : 0.8f);
	}

	private void OnDestroy()
	{
		if (m_fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(m_fadeMaterial);
		}
	}

	private void Update()
	{
	}

	public void FadeIn()
	{
		m_waitFrameUpdate = 4;
		m_state = FadeState.FadeIn;
		m_fadeSpeedOverride = 0f;
		m_fadeTargetOverride = 0f;
		StartCoroutine(FadeUpdate());
	}

	public void FadeIn(float fadeSpeed)
	{
		if (GetFadeState() != FadeState.FadeIn)
		{
			FadeIn();
		}
		m_fadeSpeedOverride = fadeSpeed;
		m_fadeTargetOverride = 0f;
	}

	public void FadeInToTargetAlpha(float targetAlpha)
	{
		m_fadeTargetOverride = targetAlpha;
	}

	public void FadeOut()
	{
		m_waitFrameUpdate = 4;
		m_state = FadeState.FadeOut;
		m_fadeSpeedOverride = 0f;
		StartCoroutine(FadeUpdate());
	}

	public void FadeOut(float fadeSpeed)
	{
		if (GetFadeState() != FadeState.FadeOut)
		{
			FadeOut();
		}
		m_fadeSpeedOverride = fadeSpeed;
		m_fadeTargetOverride = 0f;
	}

	public void FadeOutFromStartAlpha(float alpha)
	{
		FadeOut();
		m_alpha = alpha;
	}

	public void FadeOutToTargetAlpha(float targetAlpha)
	{
		FadeOut();
		m_fadeTargetOverride = targetAlpha;
	}

	public bool FinishedFading()
	{
		return m_state == FadeState.None;
	}

	private IEnumerator FadeUpdate()
	{
		while (m_state != 0)
		{
			yield return new WaitForEndOfFrame();
			switch (m_state)
			{
			case FadeState.FadeIn:
			{
				float num2 = ((!(m_fadeSpeedOverride > 0f)) ? m_fadeSpeed : m_fadeSpeedOverride);
				m_alpha -= GameTime.Instance.DeltaTime() / num2;
				if (m_alpha <= ((!(m_fadeTargetOverride > 0f)) ? 0f : m_fadeTargetOverride))
				{
					m_alpha = ((!(m_fadeTargetOverride > 0f)) ? 0f : m_fadeTargetOverride);
					m_waitFrameUpdate--;
				}
				if (m_waitFrameUpdate <= 0)
				{
					m_state = FadeState.None;
				}
				break;
			}
			case FadeState.FadeOut:
			{
				float num = ((!(m_fadeSpeedOverride > 0f)) ? m_fadeSpeed : m_fadeSpeedOverride);
				m_alpha += GameTime.Instance.DeltaTime() / num;
				if (m_alpha >= ((!(m_fadeTargetOverride > 0f)) ? 1f : m_fadeTargetOverride))
				{
					m_alpha = ((!(m_fadeTargetOverride > 0f)) ? 1f : m_fadeTargetOverride);
					m_waitFrameUpdate--;
				}
				if (m_waitFrameUpdate <= 0)
				{
					m_state = FadeState.None;
				}
				break;
			}
			}
			m_fadeMaterial.color = new UnityEngine.Color(0f, 0f, 0f, Instance.GetFadeAlpha());
			quad.material.color = new UnityEngine.Color(0f, 0f, 0f, m_alpha);
			if (m_alpha > 0f && !quad.gameObject.activeSelf)
			{
				quad.gameObject.SetActive(value: true);
			}
			else if (m_alpha == 0f && quad.gameObject.activeSelf)
			{
				quad.gameObject.SetActive(value: false);
			}
		}
	}
}
public class ForceFeedback : UnityEngine.MonoBehaviour
{
	public enum FeedbackType
	{
		None = -1,
		KartCollision,
		Offroad,
		Curb,
		DirtTrack,
		Test,
		Max
	}

	public enum ControllerType
	{
		Generic_Pad,
		SteeringWheel,
		XBoxOne_Pad
	}

	[Serializable]
	public struct FeedbackData
	{
		public float leftMotor;

		public float rightMotor;

		public float offTime;

		public float time;

		public float maxSpeed;

		public FeedbackData(float left, float right, float totalOffTime, float totalTime, float max)
		{
			leftMotor = left;
			rightMotor = right;
			offTime = totalOffTime;
			time = totalTime;
			maxSpeed = max;
		}
	}

	[Serializable]
	public struct FeedbackControllerData
	{
		public FeedbackData KartCollisionFeedback;

		public FeedbackData OffroadFeedback;

		public FeedbackData CurbFeedback;

		public FeedbackData DirtTrack;
	}

	public static ForceFeedback Instance;

	[SerializeField]
	private float TestLeftMotor = 0.6f;

	[SerializeField]
	private float TestRightMotor = 0.6f;

	[SerializeField]
	private float TestOffTime = 0.6f;

	[SerializeField]
	private float TestTime = 0.6f;

	[SerializeField]
	private float TestMaxSpeed = -1f;

	[SerializeField]
	private bool TestLoop;

	[SerializeField]
	private bool TestNow;

	[SerializeField]
	private FeedbackControllerData PadFeedback;

	[SerializeField]
	private FeedbackControllerData WheelFeedback;

	private ControllerType m_controllerType;

	private const int UpdateFrame = 10;

	private const int MaxNumControllers = 4;

	private uint[] m_previousControllerValue = new uint[4];

	private float[] m_currentMotors = new float[2];

	private FeedbackType m_currentType = FeedbackType.None;

	private float m_feedbackOffTime;

	private float m_feedbackEndTime;

	private bool m_testingNow;

	private int m_currentControlIndex;

	private static bool m_enableFeedback = true;

	public ControllerType GetControllerType => m_controllerType;

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	public void SetFeedback(FeedbackType type)
	{
		if (m_currentType != type)
		{
			FeedbackControllerData controllerData = GetControllerData();
			m_currentType = type;
			switch (type)
			{
			case FeedbackType.KartCollision:
				m_feedbackEndTime = Time.time + controllerData.KartCollisionFeedback.time;
				m_feedbackOffTime = Time.time + controllerData.KartCollisionFeedback.offTime;
				break;
			case FeedbackType.Offroad:
				m_feedbackEndTime = Time.time + controllerData.OffroadFeedback.time;
				m_feedbackOffTime = Time.time + controllerData.OffroadFeedback.offTime;
				break;
			case FeedbackType.Curb:
				m_feedbackEndTime = Time.time + controllerData.CurbFeedback.time;
				m_feedbackOffTime = Time.time + controllerData.CurbFeedback.offTime;
				break;
			case FeedbackType.DirtTrack:
				m_feedbackEndTime = Time.time + controllerData.DirtTrack.time;
				m_feedbackOffTime = Time.time + controllerData.DirtTrack.offTime;
				break;
			case FeedbackType.Test:
				m_feedbackEndTime = Time.time + TestTime;
				m_feedbackOffTime = Time.time + TestOffTime;
				break;
			}
		}
	}

	public FeedbackType GetFeedbackType()
	{
		return m_currentType;
	}

	public void ResetFeedback()
	{
		SetVibration(0f, 0f, -1f);
	}

	private void OnDestroy()
	{
		ResetFeedback();
	}

	private void Start()
	{
		for (int i = 0; i < 4; i++)
		{
			m_previousControllerValue[i] = 0u;
		}
		ResetFeedback();
	}

	private void Update()
	{
		UpdateControlIndex();
		if (m_currentType != FeedbackType.None)
		{
			if (Time.time < m_feedbackEndTime)
			{
				FeedbackControllerData controllerData = GetControllerData();
				if (Time.time > m_feedbackOffTime)
				{
					SetVibration(0f, 0f, -1f);
				}
				else
				{
					switch (m_currentType)
					{
					case FeedbackType.KartCollision:
						SetVibration(controllerData.KartCollisionFeedback.leftMotor, controllerData.KartCollisionFeedback.rightMotor, controllerData.KartCollisionFeedback.maxSpeed);
						break;
					case FeedbackType.Offroad:
						SetVibration(controllerData.OffroadFeedback.leftMotor, controllerData.OffroadFeedback.rightMotor, controllerData.OffroadFeedback.maxSpeed);
						break;
					case FeedbackType.Curb:
						SetVibration(controllerData.CurbFeedback.leftMotor, controllerData.CurbFeedback.rightMotor, controllerData.CurbFeedback.maxSpeed);
						break;
					case FeedbackType.DirtTrack:
						SetVibration(controllerData.DirtTrack.leftMotor, controllerData.DirtTrack.rightMotor, controllerData.DirtTrack.maxSpeed);
						break;
					case FeedbackType.Test:
						SetVibration(TestLeftMotor, TestRightMotor, TestMaxSpeed);
						break;
					}
				}
			}
			else if (m_currentType == FeedbackType.Test && TestLoop)
			{
				m_currentType = FeedbackType.None;
				SetFeedback(FeedbackType.Test);
			}
			else
			{
				SetVibration(0f, 0f, -1f);
				m_currentType = FeedbackType.None;
			}
		}
		if (m_testingNow != TestNow && m_currentType == FeedbackType.None)
		{
			SetFeedback(FeedbackType.Test);
			m_testingNow = TestNow;
		}
	}

	private FeedbackControllerData GetControllerData()
	{
		switch (m_controllerType)
		{
		case ControllerType.Generic_Pad:
		case ControllerType.XBoxOne_Pad:
			return PadFeedback;
		case ControllerType.SteeringWheel:
			return WheelFeedback;
		default:
			return PadFeedback;
		}
	}

	private void SetVibration(float leftMotor, float rightMotor, float maxSpeed)
	{
		if (!m_enableFeedback)
		{
			return;
		}
		if (QuitMenu.Instance.InProgress())
		{
			leftMotor = 0f;
			rightMotor = 0f;
		}
		if (Mathf.Approximately(leftMotor, m_currentMotors[0]) && Mathf.Approximately(rightMotor, m_currentMotors[1]))
		{
			return;
		}
		m_currentMotors[0] = leftMotor;
		m_currentMotors[1] = rightMotor;
		try
		{
			leftMotor = GetScaledMotor(leftMotor, maxSpeed);
			rightMotor = GetScaledMotor(rightMotor, maxSpeed);
		}
		catch (Exception)
		{
			m_enableFeedback = false;
		}
	}

	private float GetScaledMotor(float motorValue, float maxSpeed)
	{
		if (maxSpeed > -1f && PlayerManager.Instance != null)
		{
			Player refPlayer = null;
			PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
			float currentSpeed = refPlayer.GetComponent<KartController>().CurrentSpeed;
			float num = Mathf.Clamp(currentSpeed / maxSpeed, 0f, 1f);
			motorValue *= num;
		}
		return motorValue;
	}

	private void UpdateControlIndex()
	{
	}
}
public class FrameReference : UnityEngine.MonoBehaviour
{
	public delegate void FrameReferenceCallback();

	private List<FrameReferenceCallback> m_referenceList = new List<FrameReferenceCallback>();

	public void RegisterFrameReference(FrameReferenceCallback callback)
	{
		for (int i = 0; i < m_referenceList.Count; i++)
		{
			if (m_referenceList[i] == callback)
			{
				return;
			}
		}
		m_referenceList.Add(callback);
	}

	public void ResetFrameReferences()
	{
		for (int i = 0; i < m_referenceList.Count; i++)
		{
			m_referenceList[i]();
		}
		m_referenceList.Clear();
	}
}
public class Billboard : UnityEngine.MonoBehaviour
{
	private MeshRenderer m_currentMesh;

	private void Start()
	{
		m_currentMesh = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		if ((bool)m_currentMesh && m_currentMesh.enabled)
		{
			Transform transform = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform;
			Vector3 vector = transform.position - base.transform.position;
			vector.x = (vector.z = 0f);
			base.transform.LookAt(transform.position - vector);
			base.transform.Rotate(Vector3.up, 180f);
		}
	}
}
public class CustomisedObject : UnityEngine.MonoBehaviour
{
	[Serializable]
	public struct CustomisedObjectData
	{
		public string DisplayName;

		public string Identifier;

		public MenuCustomisation.CurrentCustomisation CustomiseType;

		public bool AvailableToPlayer;

		public AccessoryLocator.LocatorType LocatorID;
	}

	public CustomisedObjectData CustomiseObject;

	[Header("Customisable Objects")]
	[SerializeField]
	private AudioClip HornClip;

	[SerializeField]
	private GameObject MeshPrefab;

	[SerializeField]
	private Sprite DisplayImage;

	public AudioClip GetAudioClip()
	{
		return HornClip;
	}

	public GameObject GetMeshRoot()
	{
		return MeshPrefab;
	}

	public Sprite GetDisplayImage()
	{
		return DisplayImage;
	}
}
public class CustomisedObjectManager : UnityEngine.MonoBehaviour
{
	public static CustomisedObjectManager Instance;

	private List<CustomisedObject> m_hornObjects = new List<CustomisedObject>();

	private List<CustomisedObject> m_helmetProps = new List<CustomisedObject>();

	private List<CustomisedObject> m_visorProps = new List<CustomisedObject>();

	private List<CustomisedObject> m_dashboardProps = new List<CustomisedObject>();

	private List<CustomisedObject> m_dashboardStyles = new List<CustomisedObject>();

	private int m_totalHornsAvailableToPlayer;

	public void PlayHornByIndex(int hornIndex, ref AudioSource audioSource)
	{
		audioSource.clip = m_hornObjects[hornIndex].GetAudioClip();
		audioSource.Play();
	}

	public void PlayHornByID(string ID, ref AudioSource audioSource)
	{
		for (int i = 0; i < m_hornObjects.Count; i++)
		{
			if (m_hornObjects[i].CustomiseObject.Identifier == ID)
			{
				PlayHornByIndex(i, ref audioSource);
				break;
			}
		}
	}

	public string GetHornDisplayNameByIndex(int index)
	{
		return m_hornObjects[index].CustomiseObject.DisplayName;
	}

	public string GetHornDisplayNameByID(string ID)
	{
		return m_hornObjects[GetHornIndexByID(ID)].CustomiseObject.DisplayName;
	}

	public bool IsHornAvailableToPlayer(int index)
	{
		return m_hornObjects[index].CustomiseObject.AvailableToPlayer;
	}

	public string GetHornIdentifierByIndex(int index)
	{
		return m_hornObjects[index].CustomiseObject.Identifier;
	}

	public AudioClip GetHornClip(string ID)
	{
		return m_hornObjects[GetHornIndexByID(ID)].GetAudioClip();
	}

	public int GetHornIndexByID(string ID)
	{
		for (int i = 0; i < m_hornObjects.Count; i++)
		{
			if (m_hornObjects[i].CustomiseObject.Identifier == ID)
			{
				return i;
			}
		}
		return 0;
	}

	public int GetTotalHorns()
	{
		return m_hornObjects.Count;
	}

	public int GetTotalHornsAvailableToPlayer()
	{
		return m_totalHornsAvailableToPlayer;
	}

	public int GetTotalHelmetProps()
	{
		return m_helmetProps.Count;
	}

	public string GetHelmetIdentifierByIndex(int index)
	{
		return m_helmetProps[index].CustomiseObject.Identifier;
	}

	public CustomisedObject GetHelmetPropByID(string ID)
	{
		for (int i = 0; i < m_helmetProps.Count; i++)
		{
			if (m_helmetProps[i].CustomiseObject.Identifier == ID)
			{
				return m_helmetProps[i];
			}
		}
		return null;
	}

	public int GetTotalVisorProps()
	{
		return m_visorProps.Count;
	}

	public string GetVisorIdentifierByIndex(int index)
	{
		return m_visorProps[index].CustomiseObject.Identifier;
	}

	public CustomisedObject GetHornPropByID(string ID)
	{
		bool flag = false;
		if (ID.Contains("Internal_"))
		{
			ID = ID.Replace("Internal_", string.Empty);
			flag = true;
		}
		for (int i = 0; i < m_hornObjects.Count; i++)
		{
			if ((!flag && m_hornObjects[i].CustomiseObject.Identifier == ID) || (flag && m_hornObjects[i].CustomiseObject.DisplayName == ID))
			{
				return m_hornObjects[i];
			}
		}
		return null;
	}

	public CustomisedObject GetVisorPropByID(string ID)
	{
		for (int i = 0; i < m_visorProps.Count; i++)
		{
			if (m_visorProps[i].CustomiseObject.Identifier == ID)
			{
				return m_visorProps[i];
			}
		}
		return null;
	}

	public CustomisedObject GetDashboardPropByID(string ID)
	{
		for (int i = 0; i < m_dashboardProps.Count; i++)
		{
			if (m_dashboardProps[i].CustomiseObject.Identifier == ID)
			{
				return m_dashboardProps[i];
			}
		}
		return null;
	}

	public CustomisedObject GetDashboardStyleByID(string ID)
	{
		for (int i = 0; i < m_dashboardStyles.Count; i++)
		{
			if (m_dashboardStyles[i].CustomiseObject.Identifier == ID)
			{
				return m_dashboardStyles[i];
			}
		}
		return null;
	}

	public CustomisedObject GetObjectByID(string ID)
	{
		CustomisedObject customisedObject = null;
		customisedObject = GetHornPropByID(ID);
		if ((bool)customisedObject)
		{
			return customisedObject;
		}
		customisedObject = GetHelmetPropByID(ID);
		if ((bool)customisedObject)
		{
			return customisedObject;
		}
		customisedObject = GetVisorPropByID(ID);
		if ((bool)customisedObject)
		{
			return customisedObject;
		}
		customisedObject = GetDashboardPropByID(ID);
		if ((bool)customisedObject)
		{
			return customisedObject;
		}
		customisedObject = GetDashboardStyleByID(ID);
		if ((bool)customisedObject)
		{
			return customisedObject;
		}
		return null;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		SetupData();
	}

	private void SetupData()
	{
		CustomisedObject[] componentsInChildren = GetComponentsInChildren<CustomisedObject>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			switch (componentsInChildren[i].CustomiseObject.CustomiseType)
			{
			default:
				UnityEngine.Debug.LogError("Unsupported customised type");
				break;
			case MenuCustomisation.CurrentCustomisation.Horn:
				m_hornObjects.Add(componentsInChildren[i]);
				if (componentsInChildren[i].CustomiseObject.AvailableToPlayer)
				{
					m_totalHornsAvailableToPlayer++;
				}
				break;
			case MenuCustomisation.CurrentCustomisation.HelmetProp:
				m_helmetProps.Add(componentsInChildren[i]);
				break;
			case MenuCustomisation.CurrentCustomisation.VisorProp:
				m_visorProps.Add(componentsInChildren[i]);
				break;
			case MenuCustomisation.CurrentCustomisation.DashboardProp:
				m_dashboardProps.Add(componentsInChildren[i]);
				break;
			case MenuCustomisation.CurrentCustomisation.DashboardStyle:
				m_dashboardStyles.Add(componentsInChildren[i]);
				break;
			}
		}
	}
}
public class PositionChooser : UnityEngine.MonoBehaviour
{
	private int[] m_onlineSeatOrder = new int[8];

	private int[] m_gridOrder = new int[8];

	private int[] m_onlinePoints = new int[8];

	private void Start()
	{
		for (int i = 0; i < m_onlineSeatOrder.Length; i++)
		{
			m_onlineSeatOrder[i] = -1;
			m_gridOrder[i] = -1;
			m_onlinePoints[i] = 0;
		}
	}

	public void ClearAllSeats()
	{
		for (int i = 0; i < m_onlineSeatOrder.Length; i++)
		{
			m_onlineSeatOrder[i] = -1;
			m_gridOrder[i] = -1;
			m_onlinePoints[i] = 0;
		}
	}

	public int AllocateSeat(int photonPlayerID)
	{
		int num = FindSeatPosition(photonPlayerID);
		if (num == -1)
		{
			return SetSeatPosition(photonPlayerID);
		}
		return num;
	}

	public void SetSeatPosition(int photonPlayerID, int position)
	{
		m_onlineSeatOrder[position] = photonPlayerID;
	}

	public int SetSeatPosition(int ID)
	{
		for (int i = 0; i < m_onlineSeatOrder.Length; i++)
		{
			if (m_onlineSeatOrder[i] == -1)
			{
				m_onlineSeatOrder[i] = ID;
				return i;
			}
		}
		return -1;
	}

	public void FreeUpSeat(int photonPlayerID)
	{
		for (int i = 0; i < m_onlineSeatOrder.Length; i++)
		{
			if (m_onlineSeatOrder[i] == photonPlayerID)
			{
				m_onlineSeatOrder[i] = -1;
				break;
			}
		}
	}

	public int FindSeatPosition(int ID)
	{
		for (int i = 0; i < m_onlineSeatOrder.Length; i++)
		{
			if (m_onlineSeatOrder[i] == ID)
			{
				return i;
			}
		}
		return -1;
	}

	public void SetGridPosition(int ID, int position)
	{
		if (position >= 0)
		{
			m_gridOrder[position] = ID;
		}
	}

	public int FindGridPosition(int ID)
	{
		for (int i = 0; i < m_gridOrder.Length; i++)
		{
			if (m_gridOrder[i] == ID)
			{
				return i;
			}
		}
		return -1;
	}

	public void SetStoredOnlinePoints(int seatIndex, int points)
	{
		m_onlinePoints[seatIndex] = points;
	}

	public int GetStoredOnlinePoints(int seatIndex)
	{
		return m_onlinePoints[seatIndex];
	}
}
public class PuffParticles : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private ParticleSystem AppearParticles;

	public void DoPuff(Vector3 position)
	{
		Player refPlayer = null;
		if ((bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend)
		{
			refPlayer = FEMManager.Instance.GetFrontendPlayer(0);
		}
		else if ((bool)PlayerManager.Instance)
		{
			PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		}
		if ((bool)refPlayer)
		{
			Transform transform = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform;
			GameObject gameObject = UnityEngine.Object.Instantiate(AppearParticles.gameObject);
			gameObject.transform.parent = base.transform;
			gameObject.transform.position = position + Vector3.up * 1f;
			Vector3 normalized = (refPlayer.transform.position - position).normalized;
			normalized.y = 0f;
			gameObject.transform.position += normalized * 5f;
			gameObject.transform.LookAt(transform.position);
			UnityEngine.Object.Destroy(gameObject.gameObject, 1f);
		}
	}
}
public class GameDebug : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject m_debugPlane;

	[SerializeField]
	private TextMesh m_fpsText;

	[SerializeField]
	private TextMesh m_statsText;

	[SerializeField]
	private TextMesh[] DebugText;

	[SerializeField]
	private GameObject DetailedDebugText;

	[SerializeField]
	public int CameraOverrideIndex;

	[SerializeField]
	private GameObject FrameDot;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFPS = "FPS: 0";

	private bool m_debugActive = true;

	private CameraManager.CameraType m_prevCamType;

	private float m_debugTextTimer;

	public static GameDebug Instance;

	private int m_fpsFrameCount;

	private float m_fpsTotal;

	public bool IsDebugActive()
	{
		return m_debugActive;
	}

	public void SetDebugText(int index, string text)
	{
		DebugText[index].text = text;
	}

	public void SetDetailedText(int index, string text)
	{
		DetailedDebugText.transform.GetChild(index).GetComponent<TextMesh>().text = text;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		m_debugPlane.gameObject.SetActive(value: false);
	}

	private void Update()
	{
	}

	public void ResetAvgFPS()
	{
		m_fpsFrameCount = 0;
		m_fpsTotal = 0f;
	}

	private void UpdateFPS()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			m_fpsFrameCount++;
			m_fpsTotal += num;
			float num2 = m_fpsTotal / (float)m_fpsFrameCount;
			strFPS = $"FPS: {num:F2}";
			strFPS = strFPS + " " + $"AVG: {num2:F2}";
			GameSystem.Instance.SetFPS(num);
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
			FrameDot.SetActive(value: false);
		}
		m_fpsText.text = strFPS;
	}
}
public class GameRenderSettings : UnityEngine.MonoBehaviour
{
	[Serializable]
	private class BloomSettingsData
	{
		[SerializeField]
		public bool Enabled;

		[SerializeField]
		[Range(0f, 1.5f)]
		public float Threshold;

		[SerializeField]
		[Range(0f, 2.5f)]
		public float Intensity;

		[SerializeField]
		[Range(0.25f, 5.5f)]
		public float BlurSize;

		public BloomSettingsData(float ThresholdDefault, float IntensityDefault, float BlurSizeDefault)
		{
			Threshold = ThresholdDefault;
			Intensity = IntensityDefault;
			BlurSize = BlurSizeDefault;
			Enabled = true;
		}
	}

	[SerializeField]
	private bool Fog;

	[SerializeField]
	private UnityEngine.Color FogColour = new UnityEngine.Color(0.5f, 0.5f, 0.5f, 1f);

	[SerializeField]
	private FogMode FogModeType = FogMode.ExponentialSquared;

	[SerializeField]
	private float FogDensity = 0.01f;

	[SerializeField]
	private float LinearFogStart;

	[SerializeField]
	private float LinearFogEnd = 300f;

	[SerializeField]
	private UnityEngine.Color AmbientLight = new UnityEngine.Color(0.2f, 0.2f, 0.2f, 1f);

	[SerializeField]
	private UnityEngine.Color BackgroundColour = new UnityEngine.Color(0.29803923f, 0.73777777f, 0.8980392f, 1f);

	[SerializeField]
	private Material SkyboxMaterial;

	[SerializeField]
	private float HaloStrength = 0.5f;

	[SerializeField]
	private float FlareStrength = 1f;

	[SerializeField]
	private float FlareFadeSpeed = 3f;

	[SerializeField]
	private LightProbes PerSceneLightProbes;

	[SerializeField]
	private BloomSettingsData BloomSettings = new BloomSettingsData(0.2f, 0.3f, 1f);

	[SerializeField]
	private float NearClipPlane = 0.1f;

	private bool m_readyToSetCamProperties;

	private bool m_readyToSetPlayerProperties;

	private void OnEnable()
	{
		RenderSettings.fog = Fog;
		RenderSettings.fogColor = FogColour;
		RenderSettings.fogMode = FogModeType;
		RenderSettings.fogDensity = FogDensity;
		RenderSettings.fogStartDistance = LinearFogStart;
		RenderSettings.fogEndDistance = LinearFogEnd;
		RenderSettings.ambientLight = AmbientLight;
		RenderSettings.skybox = SkyboxMaterial;
		RenderSettings.haloStrength = HaloStrength;
		RenderSettings.flareStrength = FlareStrength;
		RenderSettings.flareFadeSpeed = FlareFadeSpeed;
		if (PerSceneLightProbes != null)
		{
			LightmapSettings.lightProbes = PerSceneLightProbes;
		}
		m_readyToSetCamProperties = true;
		m_readyToSetPlayerProperties = true;
	}

	private void Update()
	{
		if (m_readyToSetCamProperties)
		{
			m_readyToSetCamProperties = false;
			GameCamera cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.Google);
			if ((bool)cameraByType)
			{
				for (int i = 0; i < cameraByType.m_cameraArray.Length; i++)
				{
					cameraByType.m_cameraArray[i].nearClipPlane = NearClipPlane;
				}
				FastBloom component = cameraByType.m_cameraArray[0].GetComponent<FastBloom>();
				if ((bool)component)
				{
					if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
					{
						component.enabled = false;
					}
					else
					{
						component.enabled = BloomSettings.Enabled;
					}
					component.threshhold = BloomSettings.Threshold;
					component.intensity = BloomSettings.Intensity;
					component.blurSize = BloomSettings.BlurSize;
				}
				CameraFog component2 = cameraByType.m_cameraArray[0].GetComponent<CameraFog>();
				if ((bool)component2)
				{
					component2.StartDistance = LinearFogStart;
					component2.EndDistance = LinearFogEnd;
					component2.Color = FogColour;
					component2.Mode = FogMode.Linear;
					if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
					{
						component2.Enabled = false;
					}
					else
					{
						component2.Enabled = Fog;
					}
				}
			}
			cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.FP);
			if ((bool)cameraByType)
			{
				for (int j = 0; j < cameraByType.m_cameraArray.Length; j++)
				{
					cameraByType.m_cameraArray[j].nearClipPlane = NearClipPlane;
				}
				FastBloom component = cameraByType.m_cameraArray[0].GetComponent<FastBloom>();
				if ((bool)component)
				{
					component.enabled = BloomSettings.Enabled;
					component.threshhold = BloomSettings.Threshold;
					component.intensity = BloomSettings.Intensity;
					component.blurSize = BloomSettings.BlurSize;
				}
				CameraFog component2 = cameraByType.m_cameraArray[0].GetComponent<CameraFog>();
				if ((bool)component2)
				{
					component2.StartDistance = LinearFogStart;
					component2.EndDistance = LinearFogEnd;
					component2.Color = FogColour;
					component2.Mode = FogMode.Linear;
					component2.Enabled = Fog;
				}
			}
		}
		if (!m_readyToSetPlayerProperties)
		{
			return;
		}
		Player refPlayer = null;
		if ((bool)PlayerManager.Instance && PlayerManager.Instance.GetHumanPlayer(ref refPlayer))
		{
			Camera[] array = UnityEngine.Object.FindObjectsOfType<Camera>();
			Camera[] array2 = array;
			foreach (Camera camera in array2)
			{
				camera.backgroundColor = BackgroundColour;
			}
			m_readyToSetPlayerProperties = false;
		}
	}
}
public class GameSystem : UnityEngine.MonoBehaviour
{
	public enum GearVRType
	{
		UNKNOWN,
		GalaxyNote4,
		GalaxyS6,
		GalaxyS7,
		GalaxyS8
	}

	public static GameSystem Instance;

	public static bool WaitForWelcome = true;

	[HideInInspector]
	public int LastSelectedOnlineTrack1 = -1;

	[HideInInspector]
	public int LastSelectedOnlineTrack2 = -1;

	[HideInInspector]
	public bool WaitingForOnlineTrackSelection = true;

	[SerializeField]
	public FTUE FTUERoot;

	[SerializeField]
	private ChampionshipMode ChampionshipObj;

	[SerializeField]
	private TrackList TrackListingObj;

	[SerializeField]
	private PuffParticles PuffParticleSystem;

	[SerializeField]
	private PositionChooser PosChooser;

	[SerializeField]
	private TrackThumbnails ThumbnailManager;

	[SerializeField]
	public AudioSource LevelIntro;

	[SerializeField]
	private AudioClip[] LevelMusic;

	[SerializeField]
	public AudioClip RaceFanfareClip;

	[SerializeField]
	public AudioClip ChampionshipFanfareClip;

	[SerializeField]
	public AudioClip RaceFinishedClip;

	[SerializeField]
	private StringTable StringTableObject;

	[SerializeField]
	private MarketCatalogue Market;

	[SerializeField]
	private AudioSource MonoAudioSource;

	[SerializeField]
	private int TargetFrameRate = 60;

	[SerializeField]
	public FrameReference FrameReferenceManager;

	public OutOfBounds OutOfBoundsSystem;

	[NonSerialized]
	public bool ApplicationPaused;

	[SerializeField]
	private bool EnableMirroring;

	private GearVRType m_currentGearType = GearVRType.GalaxyS6;

	private int m_levelMusicIndex;

	private bool m_firstTimeLevelMusic = true;

	private int m_prevAASettings;

	private Vector3 m_fogZonePos = Vector3.zero;

	private TrackList.TrackData m_trackToLoad;

	private float m_disconnectionTimer;

	private bool m_inReducedPowerMode;

	[HideInInspector]
	public bool BombHeadMode { get; set; }

	[HideInInspector]
	public int NumWins { get; set; }

	[HideInInspector]
	public bool EnableTimeTrialMode { get; set; }

	[HideInInspector]
	public bool EnableAttractMode { get; set; }

	[HideInInspector]
	public bool PlayingGame { get; set; }

	[HideInInspector]
	public bool WasInGame { get; set; }

	[HideInInspector]
	public bool WasInOnlineRoom { get; set; }

	public int HumanSeatIndex { get; set; }

	public bool InReducedPowerMode
	{
		get
		{
			return m_inReducedPowerMode;
		}
		private set
		{
			m_inReducedPowerMode = value;
		}
	}

	public int WeaponTargetIndex { get; set; }

	public static GearVRType Type => GetType(SystemInfo.deviceModel);

	public void SetTrackToLoad(TrackList.TrackData trackData)
	{
		m_trackToLoad = trackData;
	}

	public TrackList.TrackData GetLoadedTrack()
	{
		if (GameEntry.Instance == null)
		{
			return GetTrackListing().GetTrackBySceneName(UnityEngine.Application.loadedLevelName);
		}
		return m_trackToLoad;
	}

	public bool IsOculusGo()
	{
		return SystemInfo.deviceModel.Contains("Oculus Pacific") || SystemInfo.deviceModel.Contains("Oculus Go");
	}

	public bool GamepadConnected()
	{
		bool result = false;
		string[] joystickNames = Input.GetJoystickNames();
		if (joystickNames.Length != 0)
		{
			for (int i = 0; i < joystickNames.Length; i++)
			{
				if (joystickNames[i].Length > 0 && joystickNames[i] != "Oculus Remote")
				{
					result = true;
					break;
				}
			}
		}
		return result;
	}

	public void ReducedPowerMode(bool enable)
	{
		if (m_inReducedPowerMode == enable)
		{
			return;
		}
		m_inReducedPowerMode = enable;
		if (enable)
		{
			if (IsOculusGo())
			{
				OVRManager.display.displayFrequency = 60f;
				Time.fixedDeltaTime = 1f / 60f;
				Time.maximumDeltaTime = 1f / 60f;
				VRSettings.renderScale = 1.5f;
				OVRManager.cpuLevel = 0;
				OVRManager.gpuLevel = 0;
			}
			else
			{
				OVRManager.cpuLevel = 1;
				OVRManager.gpuLevel = 1;
			}
		}
		else if (IsOculusGo())
		{
			if (NetworkLogin.Instance == null || !NetworkLogin.Instance.JoinedRoom())
			{
				OVRManager.display.displayFrequency = 72f;
				Time.fixedDeltaTime = 1f / 72f;
			}
			VRSettings.renderScale = 1.25f;
			OVRManager.cpuLevel = 2;
			OVRManager.gpuLevel = 2;
		}
		else
		{
			OVRManager.cpuLevel = 2;
			OVRManager.gpuLevel = 2;
		}
	}

	public TrackList GetTrackListing()
	{
		return TrackListingObj;
	}

	public ChampionshipMode GetChampionshipMode()
	{
		return ChampionshipObj;
	}

	public PuffParticles GetPuffParticles()
	{
		return PuffParticleSystem;
	}

	public PositionChooser GetPositionChooser()
	{
		return PosChooser;
	}

	public TrackThumbnails GetThumbnailManager()
	{
		return ThumbnailManager;
	}

	public void ResetLevelMusic()
	{
		m_firstTimeLevelMusic = true;
	}

	public MarketCatalogue GetMarket()
	{
		return Market;
	}

	public void PlayOneShot2DClip(AudioClip clip)
	{
		MonoAudioSource.clip = clip;
		MonoAudioSource.Play();
	}

	public void SetupLevelMusic(AudioSource audioSourceObj)
	{
		if (m_firstTimeLevelMusic)
		{
			m_levelMusicIndex = UnityEngine.Random.Range(0, LevelMusic.Length);
		}
		audioSourceObj.clip = LevelMusic[m_levelMusicIndex];
		m_levelMusicIndex = (m_levelMusicIndex + 1) % LevelMusic.Length;
		if (m_firstTimeLevelMusic)
		{
			m_firstTimeLevelMusic = false;
		}
	}

	public bool HMDConnected()
	{
		return true;
	}

	public StringTable GetStringTable()
	{
		return StringTableObject;
	}

	public void InFogZone(bool entered, Vector3 zonePos, int layerOffset)
	{
		if (entered)
		{
			CameraManager.Instance.GetCurrentCamera().GetComponent<CameraLayerDistances>().AddSceneLayerOffset(layerOffset);
			m_fogZonePos = zonePos;
		}
		else if (zonePos == m_fogZonePos)
		{
			CameraManager.Instance.GetCurrentCamera().GetComponent<CameraLayerDistances>().AddSceneLayerOffset(0);
		}
	}

	public void RecentreHeadsetPosition(bool ignoreOneTime = false)
	{
	}

	public void RecentreHeadset()
	{
		InputTracking.Recenter();
		CameraManager.Instance.SetCamYHeight(0f);
	}

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		UnityEngine.Random.InitState((int)DateTime.Now.Ticks);
	}

	private void Start()
	{
		GetTrackListing().ParseTracksIntoTracklist();
		ReducedPowerMode(enable: true);
		m_currentGearType = Type;
		if (IsOculusGo())
		{
			VRSettings.renderViewportScale = 1f;
			VRSettings.renderScale = 1.25f;
			OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSHigh;
		}
		else
		{
			VRSettings.renderScale = 1f;
			VRSettings.renderViewportScale = 1f;
		}
	}

	public void SetFPS(float fps)
	{
	}

	private void Update()
	{
		if (m_disconnectionTimer > 0f && (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend || ((bool)Gameplay.Instance && Gameplay.Instance.RaceStarted())))
		{
			m_disconnectionTimer -= GameTime.Instance.DeltaTime();
		}
		CheckForRecentreInput();
		UpdateVolumes();
	}

	private void CheckForRecentreInput()
	{
		if ((!(FEMManager.Instance != null) || (!FEMManager.Instance.ConfigureOptionEnabled() && FEMManager.Instance.CurrentOption != FEMManager.FEMOption.Settings)) && (Input.GetKeyDown(KeyCode.R) || InputRemapper.Instance.GetButtonDown(InputRemapper.ControllerMapping.Recentre_View)))
		{
			RecentreHeadset();
		}
	}

	private void UpdateVolumes()
	{
		if (FadeManager.Instance == null || FadeManager.Instance.FinishedFading())
		{
			if ((FadeManager.Instance == null || FadeManager.Instance.GetFadeAlpha() == 0f) && AudioListener.volume != ProfileManager.Instance.SFXVolume)
			{
				AudioListener.volume = ProfileManager.Instance.SFXVolume;
			}
		}
		else
		{
			AudioListener.volume = ProfileManager.Instance.SFXVolume * (1f - FadeManager.Instance.GetFadeAlpha());
		}
	}

	private static GearVRType GetType(string deviceName)
	{
		Match match = Regex.Match(deviceName.ToUpper(), "SM-(\\w)9(\\d)\\d*\\w*");
		GearVRType result = GearVRType.UNKNOWN;
		if (match.Groups.Count == 3)
		{
			if (match.Groups[1].ToString() == "N")
			{
				result = GearVRType.GalaxyNote4;
			}
			else
			{
				int result2 = -1;
				if (int.TryParse(match.Groups[2].ToString(), out result2))
				{
					switch (result2)
					{
					case 2:
						result = GearVRType.GalaxyS6;
						break;
					case 3:
						result = GearVRType.GalaxyS7;
						break;
					case 5:
						result = GearVRType.GalaxyS8;
						break;
					}
				}
			}
		}
		else if (deviceName.ToUpper().Contains("SCL24") || deviceName.ToUpper().Contains("SC-01G"))
		{
			result = GearVRType.GalaxyNote4;
		}
		return result;
	}
}
public class GameSystemShell : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameSystem SystemPrefab;

	private GameSystem m_systemObj;

	private void Awake()
	{
		m_systemObj = UnityEngine.Object.FindObjectOfType<GameSystem>();
		if (m_systemObj == null)
		{
			m_systemObj = UnityEngine.Object.Instantiate(SystemPrefab);
			if ((bool)m_systemObj)
			{
				m_systemObj.transform.parent = base.transform;
			}
		}
	}
}
public class GameTime : UnityEngine.MonoBehaviour
{
	public static GameTime Instance;

	private bool m_paused;

	private float m_currentTime;

	private float m_prevTime;

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Start()
	{
		m_paused = false;
	}

	private void Update()
	{
		m_prevTime = m_currentTime;
		m_currentTime = Time.time;
	}

	public float DeltaTime()
	{
		if (m_paused)
		{
			return 0f;
		}
		return Time.deltaTime;
	}

	public float SmoothedDeltaTime()
	{
		if (m_paused)
		{
			return 0f;
		}
		return Time.smoothDeltaTime;
	}

	public float CurrentTime()
	{
		return m_currentTime;
	}

	public float PrevTime()
	{
		return m_prevTime;
	}

	public double GetTimeInTicks()
	{
		uint tickCount = (uint)Environment.TickCount;
		return tickCount;
	}

	public double GetServerTimeInTicks()
	{
		uint serverTimeInMilliSeconds = (uint)PhotonNetwork.networkingPeer.ServerTimeInMilliSeconds;
		return serverTimeInMilliSeconds;
	}

	public double GetTimeDifferenceInTicks(double end, double start)
	{
		if (end > start)
		{
			return end - start;
		}
		double num = 2147483647.0 - start;
		double num2 = end - -2147483648.0;
		return num + num2;
	}

	public float ConvertToSeconds(double timeInTicks)
	{
		return (float)timeInTicks / 1000f;
	}

	public void ConvertTime(double ticks, ref int mins, ref int secs, ref int tenths)
	{
		float num = Instance.ConvertToSeconds(ticks);
		mins = (int)(num / 60f);
		secs = (int)num - mins * 60;
		tenths = (int)((num - (float)mins * 60f - (float)secs) * 100f);
	}

	public void ConvertTimeFromSeconds(float timeInSecs, ref int mins, ref int secs, ref int tenths)
	{
		mins = (int)(timeInSecs / 60f);
		secs = (int)timeInSecs - mins * 60;
		tenths = (int)((timeInSecs - (float)mins * 60f - (float)secs) * 100f);
	}

	public void Pause(bool pause)
	{
		m_paused = pause;
		Time.timeScale = ((!pause) ? 1f : 0f);
	}

	public bool IsPaused()
	{
		return m_paused;
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Bloom and Glow/Bloom (Optimized)")]
public class FastBloom : PostEffectsBase
{
	public enum Resolution
	{
		Low,
		High
	}

	public enum BlurType
	{
		Standard,
		Sgx
	}

	[Range(0f, 1.5f)]
	public float threshhold = 0.25f;

	[Range(0f, 2.5f)]
	public float intensity = 0.75f;

	[Range(0.25f, 5.5f)]
	public float blurSize = 1f;

	public Resolution resolution;

	[Range(1f, 4f)]
	public int blurIterations = 1;

	public BlurType blurType;

	public Shader fastBloomShader;

	private Material fastBloomMaterial;

	protected override bool CheckResources()
	{
		CheckSupport(needDepth: false);
		fastBloomMaterial = CheckShaderAndCreateMaterial(fastBloomShader, fastBloomMaterial);
		if (!isSupported)
		{
			ReportAutoDisable();
		}
		return isSupported;
	}

	private void OnDisable()
	{
		if ((bool)fastBloomMaterial)
		{
			UnityEngine.Object.DestroyImmediate(fastBloomMaterial);
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!CheckResources())
		{
			UnityEngine.Graphics.Blit(source, destination);
			return;
		}
		int num = ((resolution != 0) ? 2 : 4);
		float num2 = ((resolution != 0) ? 1f : 0.5f);
		fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2, 0f, threshhold, intensity));
		source.filterMode = FilterMode.Bilinear;
		int width = source.width / num;
		int height = source.height / num;
		RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
		renderTexture.filterMode = FilterMode.Bilinear;
		UnityEngine.Graphics.Blit(source, renderTexture, fastBloomMaterial, 1);
		int num3 = ((blurType != 0) ? 2 : 0);
		for (int i = 0; i < blurIterations; i++)
		{
			fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2 + (float)i * 1f, 0f, threshhold, intensity));
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
			temporary.filterMode = FilterMode.Bilinear;
			UnityEngine.Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 2 + num3);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
			temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
			temporary.filterMode = FilterMode.Bilinear;
			UnityEngine.Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 3 + num3);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		fastBloomMaterial.SetTexture("_Bloom", renderTexture);
		UnityEngine.Graphics.Blit(source, destination, fastBloomMaterial, 0);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class PostEffectsBase : UnityEngine.MonoBehaviour
{
	protected bool supportHDRTextures = true;

	protected bool supportDX11;

	protected bool isSupported = true;

	public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
	{
		if (!s)
		{
			UnityEngine.Debug.Log("Missing shader in " + ToString());
			base.enabled = false;
			return null;
		}
		if (s.isSupported && (bool)m2Create && m2Create.shader == s)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			NotSupported();
			UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
			return null;
		}
		m2Create = new Material(s);
		m2Create.hideFlags = HideFlags.DontSave;
		if ((bool)m2Create)
		{
			return m2Create;
		}
		return null;
	}

	private Material CreateMaterial(Shader s, Material m2Create)
	{
		if (!s)
		{
			UnityEngine.Debug.Log("Missing shader in " + ToString());
			return null;
		}
		if ((bool)m2Create && m2Create.shader == s && s.isSupported)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			return null;
		}
		m2Create = new Material(s);
		m2Create.hideFlags = HideFlags.DontSave;
		if ((bool)m2Create)
		{
			return m2Create;
		}
		return null;
	}

	private void OnEnable()
	{
		isSupported = true;
	}

	public bool CheckSupport()
	{
		return CheckSupport(needDepth: false);
	}

	protected virtual bool CheckResources()
	{
		UnityEngine.Debug.LogWarning("CheckResources () for " + ToString() + " should be overwritten.");
		return isSupported;
	}

	private void Start()
	{
		CheckResources();
	}

	public bool CheckSupport(bool needDepth)
	{
		isSupported = true;
		supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
		supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
		if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
		{
			NotSupported();
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			NotSupported();
			return false;
		}
		if (needDepth)
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
		}
		return true;
	}

	public bool CheckSupport(bool needDepth, bool needHdr)
	{
		if (!CheckSupport(needDepth))
		{
			return false;
		}
		if (needHdr && !supportHDRTextures)
		{
			NotSupported();
			return false;
		}
		return true;
	}

	private bool Dx11Support()
	{
		return supportDX11;
	}

	public void ReportAutoDisable()
	{
		UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
	}

	private bool CheckShader(Shader s)
	{
		UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package.");
		if (!s.isSupported)
		{
			NotSupported();
			return false;
		}
		return false;
	}

	private void NotSupported()
	{
		base.enabled = false;
		isSupported = false;
	}

	private void DrawBorder(RenderTexture dest, Material material)
	{
		RenderTexture.active = dest;
		bool flag = true;
		GL.PushMatrix();
		GL.LoadOrtho();
		for (int i = 0; i < material.passCount; i++)
		{
			material.SetPass(i);
			float y;
			float y2;
			if (flag)
			{
				y = 1f;
				y2 = 0f;
			}
			else
			{
				y = 0f;
				y2 = 1f;
			}
			float x = 0f;
			float x2 = 1f / ((float)dest.width * 1f);
			float y3 = 0f;
			float y4 = 1f;
			GL.Begin(7);
			GL.TexCoord2(0f, y);
			GL.Vertex3(x, y3, 0.1f);
			GL.TexCoord2(1f, y);
			GL.Vertex3(x2, y3, 0.1f);
			GL.TexCoord2(1f, y2);
			GL.Vertex3(x2, y4, 0.1f);
			GL.TexCoord2(0f, y2);
			GL.Vertex3(x, y4, 0.1f);
			x = 1f - 1f / ((float)dest.width * 1f);
			x2 = 1f;
			y3 = 0f;
			y4 = 1f;
			GL.TexCoord2(0f, y);
			GL.Vertex3(x, y3, 0.1f);
			GL.TexCoord2(1f, y);
			GL.Vertex3(x2, y3, 0.1f);
			GL.TexCoord2(1f, y2);
			GL.Vertex3(x2, y4, 0.1f);
			GL.TexCoord2(0f, y2);
			GL.Vertex3(x, y4, 0.1f);
			x = 0f;
			x2 = 1f;
			y3 = 0f;
			y4 = 1f / ((float)dest.height * 1f);
			GL.TexCoord2(0f, y);
			GL.Vertex3(x, y3, 0.1f);
			GL.TexCoord2(1f, y);
			GL.Vertex3(x2, y3, 0.1f);
			GL.TexCoord2(1f, y2);
			GL.Vertex3(x2, y4, 0.1f);
			GL.TexCoord2(0f, y2);
			GL.Vertex3(x, y4, 0.1f);
			x = 0f;
			x2 = 1f;
			y3 = 1f - 1f / ((float)dest.height * 1f);
			y4 = 1f;
			GL.TexCoord2(0f, y);
			GL.Vertex3(x, y3, 0.1f);
			GL.TexCoord2(1f, y);
			GL.Vertex3(x2, y3, 0.1f);
			GL.TexCoord2(1f, y2);
			GL.Vertex3(x2, y4, 0.1f);
			GL.TexCoord2(0f, y2);
			GL.Vertex3(x, y4, 0.1f);
			GL.End();
		}
		GL.PopMatrix();
	}
}
public class VPGPlatformMenu : UnityEngine.MonoBehaviour
{
	public enum eHandler
	{
		ShowConfirmQuit,
		RetreatOneLevel,
		PauseMenu
	}

	private enum eBackButtonAction
	{
		NONE,
		DOUBLE_TAP,
		SHORT_PRESS
	}

	public KeyCode keyCode = KeyCode.Escape;

	public eHandler shortPressHandler;

	public Func<bool> OnShortPress;

	private static Stack<string> sceneStack = new Stack<string>();

	private float doubleTapDelay = 0.25f;

	private float shortPressDelay = 0.25f;

	private float longPressDelay = 0.75f;

	private int downCount;

	private int upCount;

	private float initialDownTime = -1f;

	private bool m_longPressMade;

	private eBackButtonAction ResetAndSendAction(eBackButtonAction action)
	{
		UnityEngine.MonoBehaviour.print(string.Concat("ResetAndSendAction( ", action, " );"));
		downCount = 0;
		upCount = 0;
		initialDownTime = -1f;
		return action;
	}

	private eBackButtonAction HandleBackButtonState()
	{
		if (Input.GetKeyDown(keyCode))
		{
			downCount++;
			if (downCount == 1)
			{
				initialDownTime = Time.realtimeSinceStartup;
			}
		}
		else if (downCount > 0)
		{
			if (Input.GetKey(keyCode))
			{
				if (downCount <= upCount)
				{
					downCount++;
				}
				float num = Time.realtimeSinceStartup - initialDownTime;
				if (num > longPressDelay)
				{
					m_longPressMade = true;
					return ResetAndSendAction(eBackButtonAction.NONE);
				}
			}
			else if (initialDownTime >= 0f)
			{
				if (upCount < downCount)
				{
					upCount++;
				}
				float num2 = Time.realtimeSinceStartup - initialDownTime;
				if (num2 < doubleTapDelay)
				{
					if (downCount == 2 && upCount == 2)
					{
						return ResetAndSendAction(eBackButtonAction.DOUBLE_TAP);
					}
				}
				else if (num2 > shortPressDelay && num2 < longPressDelay)
				{
					if (downCount == 1 && upCount == 1)
					{
						return ResetAndSendAction(eBackButtonAction.SHORT_PRESS);
					}
				}
				else if (num2 > longPressDelay)
				{
					m_longPressMade = true;
					return ResetAndSendAction(eBackButtonAction.NONE);
				}
			}
		}
		return eBackButtonAction.NONE;
	}

	private void Awake()
	{
		if (shortPressHandler == eHandler.RetreatOneLevel && OnShortPress == null)
		{
			OnShortPress = RetreatOneLevel;
		}
		else if (shortPressHandler == eHandler.PauseMenu && OnShortPress == null)
		{
			OnShortPress = PauseMenuHandler;
		}
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
		else
		{
			sceneStack.Push(SceneManager.GetActiveScene().name);
		}
	}

	private void OnApplicationFocus(bool focusState)
	{
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			Input.ResetInputAxes();
		}
	}

	private void ShowConfirmQuitMenu()
	{
		UnityEngine.Debug.Log("[PlatformUI-ConfirmQuit] Showing @ " + Time.time);
		OVRManager.PlatformUIConfirmQuit();
	}

	private static bool RetreatOneLevel()
	{
		if (sceneStack.Count > 1)
		{
			string sceneName = sceneStack.Pop();
			SceneManager.LoadSceneAsync(sceneName);
			return false;
		}
		return true;
	}

	private static bool PauseMenuHandler()
	{
		if (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			QuitMenu.Instance.PauseButtonPressed();
			return false;
		}
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.JoinedRoom())
		{
			QuitMenu.Instance.PauseButtonPressed();
			return false;
		}
		if ((bool)FEMManager.Instance && FEMManager.Instance.EnteredFrontendMenus())
		{
			InputRemapper.Instance.SetBackButtonPressed();
			return false;
		}
		QuitMenu.Instance.PauseButtonPressed();
		return false;
	}

	private void Update()
	{
		eBackButtonAction eBackButtonAction = HandleBackButtonState();
		if (eBackButtonAction == eBackButtonAction.SHORT_PRESS && (OnShortPress == null || OnShortPress()))
		{
			ShowConfirmQuitMenu();
		}
		if (m_longPressMade)
		{
			m_longPressMade = false;
			ShowConfirmQuitMenu();
		}
	}
}
public class InputRemapper : UnityEngine.MonoBehaviour
{
	public enum JoypadInput
	{
		None = -1,
		joystick_button_0,
		joystick_button_1,
		joystick_button_2,
		joystick_button_3,
		joystick_button_4,
		joystick_button_5,
		joystick_button_6,
		joystick_button_7,
		joystick_button_8,
		joystick_button_9,
		joystick_button_10,
		joystick_button_11,
		joystick_button_12,
		joystick_button_13,
		joystick_button_14,
		joystick_button_15,
		joystick_button_16,
		joystick_button_17,
		joystick_button_18,
		joystick_button_19,
		joystick_button_20,
		X_Axis,
		Y_Axis,
		Third_Axis,
		Fourth_Axis,
		Fifth_Axis,
		Sixth_Axis,
		Seventh_Axis,
		Eighth_Axis,
		Ninth_Axis,
		Tenth_Axis,
		Eleventh_Axis,
		Twelfth_Axis,
		Thirteenth_Axis,
		Fourteenth_Axis,
		Fifteenth_Axis,
		Sixteenth_Axis,
		Seventeenth_Axis,
		Eighteenth_Axis,
		Ninteenth_Axis,
		Twentieth_Axis
	}

	public enum ControllerMapping
	{
		Horn,
		Weapon,
		SpeedBoost,
		Acceleration,
		Brake,
		Steer_Left,
		Steer_Right,
		Quit_Menu,
		Recentre_View,
		Button_A,
		Button_B,
		Button_X,
		Button_Y,
		DPad_Up,
		DPad_Down,
		DPad_Left,
		DPad_Right,
		Shop_Left,
		Shop_Right
	}

	public enum Mapping_2D
	{
		None,
		Up,
		Down,
		Left,
		Right
	}

	public enum ControlSystem
	{
		PadControl,
		GearVRController
	}

	public enum InputConfigType
	{
		Horn = 0,
		Weapon = 1,
		Boost = 2,
		Accelerate = 3,
		Brake = 4,
		SteerLeft = 5,
		SteerRight = 6,
		Quit = 7,
		Recentre = 8,
		MenuLeft = 9,
		MenuRight = 10,
		Max = 10
	}

	public class InputConfig
	{
		public JoypadInput mappedInput;

		public bool isAxis;

		public bool isNegative;

		public float prevValue;

		public float currentValue;

		public InputConfig(JoypadInput mappedInputToSet, bool isAxisToSet, bool isNegativeToSet, float prevValueToSet, float currentValueToSet)
		{
			mappedInput = mappedInputToSet;
			isAxis = isAxisToSet;
			isNegative = isNegativeToSet;
			prevValue = 0f;
			currentValue = 0f;
		}
	}

	private string[] JoypadInputName = new string[41]
	{
		"joystick button 0", "joystick button 1", "joystick button 2", "joystick button 3", "joystick button 4", "joystick button 5", "joystick button 6", "joystick button 7", "joystick button 8", "joystick button 9",
		"joystick button 10", "joystick button 11", "joystick button 12", "joystick button 13", "joystick button 14", "joystick button 15", "joystick button 16", "joystick button 17", "joystick button 18", "joystick button 19",
		"joystick button 20", "X Axis", "Y Axis", "3rd Axis", "4th Axis", "5th Axis", "6th Axis", "7th Axis", "8th Axis", "9th Axis",
		"10th Axis", "11th Axis", "12th Axis", "13th Axis", "14th Axis", "15th Axis", "16th Axis", "17th Axis", "18th Axis", "19th Axis",
		"20th Axis"
	};

	private const float CentrePoint = 0.5f;

	private const float DeadZone = 0.1f;

	public static float ScrollDetectionAmount = 0.4f;

	private bool ENABLE_INPUT_TEST;

	private bool m_controllerReset = true;

	private const float k_axisCentreDeadzone = 10f;

	private const float k_axisValidInput = 20f;

	public static InputRemapper Instance;

	private ControlSystem m_currentControlSystem;

	private float m_prevHorAxis;

	private float m_prevVertAxis;

	private bool m_waitForAccelerate = true;

	private Vector2 m_originalTouchPos = Vector2.zero;

	private Vector2 m_currentTouchPos = Vector2.zero;

	private List<JoypadInput> m_controlBlackList = new List<JoypadInput>();

	private string[] m_configureControllerText = new string[11]
	{
		"STR_HornConfig", "STR_WeaponConfig", "STR_BoostConfig", "STR_AccelerateConfig", "STR_BrakeConfig", "STR_SteerLeftConfig", "STR_SteerRightConfig", "STR_QuitConfig", "STR_RecentreConfig", "STR_MenuLeft",
		"STR_MenuRight"
	};

	private InputConfig[] m_inputConfig = new InputConfig[11];

	private InputConfig[] m_inputConfigToSet = new InputConfig[11];

	private InputConfig[] m_defaultInputConfig = new InputConfig[11]
	{
		new InputConfig(JoypadInput.joystick_button_2, isAxisToSet: false, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.joystick_button_0, isAxisToSet: false, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.joystick_button_1, isAxisToSet: false, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.Twelfth_Axis, isAxisToSet: true, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.Thirteenth_Axis, isAxisToSet: true, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.X_Axis, isAxisToSet: true, isNegativeToSet: true, 0f, 0f),
		new InputConfig(JoypadInput.X_Axis, isAxisToSet: true, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.joystick_button_10, isAxisToSet: false, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.Fourteenth_Axis, isAxisToSet: true, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.joystick_button_4, isAxisToSet: false, isNegativeToSet: false, 0f, 0f),
		new InputConfig(JoypadInput.joystick_button_5, isAxisToSet: false, isNegativeToSet: false, 0f, 0f)
	};

	private bool m_backButtonPressed;

	public bool RemoteConnected { get; private set; }

	public void SetBackButtonPressed()
	{
		m_backButtonPressed = true;
	}

	public string GetInputText(InputConfigType configType)
	{
		return m_configureControllerText[(int)configType];
	}

	public void ResetAllInputs()
	{
		for (int i = 0; i < m_inputConfig.Length; i++)
		{
			m_inputConfig[i] = new InputConfig(m_defaultInputConfig[i].mappedInput, m_defaultInputConfig[i].isAxis, m_defaultInputConfig[i].isNegative, 0f, 0f);
			m_inputConfigToSet[i] = new InputConfig(m_defaultInputConfig[i].mappedInput, m_defaultInputConfig[i].isAxis, m_defaultInputConfig[i].isNegative, 0f, 0f);
		}
	}

	public InputConfig[] GetInputConfiguration()
	{
		return m_inputConfig;
	}

	public void SetInputConfiguration(int index, int mapping, int isAxis, int isNegative)
	{
		m_inputConfig[index].mappedInput = (JoypadInput)mapping;
		m_inputConfig[index].isAxis = isAxis == 1;
		m_inputConfig[index].isNegative = isNegative == 1;
		m_inputConfig[index].prevValue = 0f;
		m_inputConfig[index].currentValue = 0f;
	}

	public bool GetAnyInput()
	{
		for (int i = 0; i < JoypadInputName.Length; i++)
		{
			if (CheckForBlacklistedInput((JoypadInput)i))
			{
				continue;
			}
			if (JoypadInputName[i].Contains("Axis"))
			{
				if (CrossPlatformInputManager.GetAxis(JoypadInputName[i]) > 0.8f)
				{
					UpdateBlacklist((JoypadInput)i);
					return true;
				}
				if (CrossPlatformInputManager.GetAxis(JoypadInputName[i]) < -0.8f)
				{
					UpdateBlacklist((JoypadInput)i);
					return true;
				}
			}
			else if (CrossPlatformInputManager.GetButtonDown(JoypadInputName[i]))
			{
				UpdateBlacklist((JoypadInput)i);
				return true;
			}
		}
		return false;
	}

	private bool CheckForBlacklistedInput(JoypadInput input)
	{
		for (int i = 0; i < m_controlBlackList.Count; i++)
		{
			if (m_controlBlackList[i] == input)
			{
				return true;
			}
		}
		return false;
	}

	public void UpdateBlacklist(JoypadInput existingInput)
	{
		m_controlBlackList.Clear();
		for (int i = 0; i < JoypadInputName.Length; i++)
		{
			JoypadInput joypadInput = (JoypadInput)i;
			if (joypadInput == existingInput)
			{
				continue;
			}
			if (JoypadInputName[i].Contains("Axis"))
			{
				if (CrossPlatformInputManager.GetAxis(JoypadInputName[i]) > 0.8f)
				{
					m_controlBlackList.Add((JoypadInput)i);
				}
				else if (CrossPlatformInputManager.GetAxis(JoypadInputName[i]) < -0.8f)
				{
					m_controlBlackList.Add((JoypadInput)i);
				}
			}
			else if (CrossPlatformInputManager.GetButton(JoypadInputName[i]))
			{
				m_controlBlackList.Add((JoypadInput)i);
			}
		}
	}

	public bool WaitForInput(InputConfigType controllerMapping)
	{
		bool result = false;
		for (int i = 0; i < JoypadInputName.Length; i++)
		{
			if (CheckForBlacklistedInput((JoypadInput)i))
			{
				continue;
			}
			if (JoypadInputName[i].Contains("Axis"))
			{
				if (CrossPlatformInputManager.GetAxis(JoypadInputName[i]) > 0.8f)
				{
					UpdateBlacklist((JoypadInput)i);
					m_inputConfigToSet[(int)controllerMapping].mappedInput = (JoypadInput)i;
					m_inputConfigToSet[(int)controllerMapping].isAxis = true;
					m_inputConfigToSet[(int)controllerMapping].isNegative = false;
					m_inputConfigToSet[(int)controllerMapping].currentValue = 0f;
					m_inputConfigToSet[(int)controllerMapping].prevValue = 0f;
					result = true;
					break;
				}
				if (CrossPlatformInputManager.GetAxis(JoypadInputName[i]) < -0.8f)
				{
					UpdateBlacklist((JoypadInput)i);
					m_inputConfigToSet[(int)controllerMapping].mappedInput = (JoypadInput)i;
					m_inputConfigToSet[(int)controllerMapping].isAxis = true;
					m_inputConfigToSet[(int)controllerMapping].isNegative = true;
					m_inputConfigToSet[(int)controllerMapping].currentValue = 0f;
					m_inputConfigToSet[(int)controllerMapping].prevValue = 0f;
					result = true;
					break;
				}
			}
			else if (CrossPlatformInputManager.GetButtonDown(JoypadInputName[i]))
			{
				UpdateBlacklist((JoypadInput)i);
				m_inputConfigToSet[(int)controllerMapping].mappedInput = (JoypadInput)i;
				m_inputConfigToSet[(int)controllerMapping].isAxis = false;
				m_inputConfigToSet[(int)controllerMapping].isNegative = false;
				m_inputConfigToSet[(int)controllerMapping].currentValue = 0f;
				m_inputConfigToSet[(int)controllerMapping].prevValue = 0f;
				result = true;
				break;
			}
		}
		return result;
	}

	public void StoreNewInputs()
	{
		m_inputConfig = m_inputConfigToSet;
	}

	private float GetRemappedInputValue(InputConfigType inputType)
	{
		InputConfig inputConfig = m_inputConfig[(int)inputType];
		return inputConfig.currentValue;
	}

	private bool GetRemappedButtonDown(InputConfigType inputType)
	{
		InputConfig inputConfig = m_inputConfig[(int)inputType];
		if (inputConfig.currentValue > 0.8f && inputConfig.prevValue < 0.8f)
		{
			return true;
		}
		return false;
	}

	private bool GetRemappedButtonUp(InputConfigType inputType)
	{
		InputConfig inputConfig = m_inputConfig[(int)inputType];
		if (inputConfig.currentValue < 0.8f && inputConfig.prevValue > 0.8f)
		{
			return true;
		}
		return false;
	}

	private bool GetRemappedButton(InputConfigType inputType)
	{
		InputConfig inputConfig = m_inputConfig[(int)inputType];
		if (inputConfig.currentValue > 0.8f)
		{
			return true;
		}
		return false;
	}

	public void ResetWaitForAccelerate()
	{
		m_waitForAccelerate = true;
	}

	public Quaternion GetControllerOrientation()
	{
		if (m_currentControlSystem == ControlSystem.PadControl)
		{
			return CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.localRotation;
		}
		return OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController());
	}

	public void SetControlSystem(ControlSystem controlSystem)
	{
		m_currentControlSystem = controlSystem;
	}

	public ControlSystem GetControlSystem()
	{
		return m_currentControlSystem;
	}

	public bool StartedScrolling()
	{
		return OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad) || OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger);
	}

	public bool IsScrolling()
	{
		return OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) || OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger);
	}

	public bool FinishedScrolling()
	{
		return OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad) || OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger);
	}

	public Vector2 ScrollDifference()
	{
		return m_currentTouchPos - m_originalTouchPos;
	}

	private void UpdateScrolling()
	{
		if (StartedScrolling())
		{
			m_originalTouchPos = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
			m_currentTouchPos = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
		}
		else if (IsScrolling())
		{
			m_currentTouchPos = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
		}
	}

	private void UpdateRegisteredInputs()
	{
		for (int i = 0; i < m_inputConfig.Length; i++)
		{
			m_inputConfig[i].prevValue = m_inputConfig[i].currentValue;
			if (m_inputConfig[i].isAxis)
			{
				float axis = CrossPlatformInputManager.GetAxis(JoypadInputName[(int)m_inputConfig[i].mappedInput]);
				if (m_inputConfig[i].isNegative)
				{
					if (axis < 0f)
					{
						m_inputConfig[i].currentValue = 0f - axis;
					}
					else
					{
						m_inputConfig[i].currentValue = 0f;
					}
				}
				else if (axis > 0f)
				{
					m_inputConfig[i].currentValue = axis;
				}
				else
				{
					m_inputConfig[i].currentValue = 0f;
				}
			}
			else if (CrossPlatformInputManager.GetButton(JoypadInputName[(int)m_inputConfig[i].mappedInput]))
			{
				m_inputConfig[i].currentValue = 1f;
			}
			else
			{
				m_inputConfig[i].currentValue = 0f;
			}
		}
	}

	public float GetAxis(ControllerMapping controllerMapping)
	{
		if (m_currentControlSystem == ControlSystem.PadControl)
		{
			switch (controllerMapping)
			{
			case ControllerMapping.Acceleration:
			{
				float remappedInputValue4 = GetRemappedInputValue(InputConfigType.Accelerate);
				if (remappedInputValue4 > 0f)
				{
					return remappedInputValue4;
				}
				break;
			}
			case ControllerMapping.Brake:
			{
				float remappedInputValue2 = GetRemappedInputValue(InputConfigType.Brake);
				if (remappedInputValue2 > 0f)
				{
					return remappedInputValue2;
				}
				break;
			}
			case ControllerMapping.Steer_Left:
			{
				float remappedInputValue3 = GetRemappedInputValue(InputConfigType.SteerLeft);
				if (remappedInputValue3 > 0f)
				{
					return Mathf.Abs(remappedInputValue3);
				}
				break;
			}
			case ControllerMapping.Steer_Right:
			{
				float remappedInputValue = GetRemappedInputValue(InputConfigType.SteerRight);
				if (remappedInputValue > 0f)
				{
					return remappedInputValue;
				}
				break;
			}
			}
		}
		else if (m_currentControlSystem == ControlSystem.GearVRController)
		{
			switch (controllerMapping)
			{
			case ControllerMapping.Steer_Left:
			{
				float z2 = OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController()).eulerAngles.z;
				if (z2 < 60f)
				{
					return z2 / 60f;
				}
				if (z2 < 180f)
				{
					return 1f;
				}
				break;
			}
			case ControllerMapping.Steer_Right:
			{
				float z = OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController()).eulerAngles.z;
				if (z > 300f)
				{
					return (360f - z) / 60f;
				}
				if (z > 180f)
				{
					return 1f;
				}
				break;
			}
			}
		}
		return 0f;
	}

	public bool GetButtonDown(ControllerMapping controllerMapping)
	{
		if (m_currentControlSystem == ControlSystem.GearVRController)
		{
			switch (controllerMapping)
			{
			case ControllerMapping.Button_A:
				if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad) || OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_B:
				return m_backButtonPressed;
			case ControllerMapping.SpeedBoost:
			{
				Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.GetActiveController());
				if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad) && vector.x < 0f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.Weapon:
			{
				Vector2 vector2 = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.GetActiveController());
				if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad) && vector2.x > 0f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.Quit_Menu:
				if (m_currentControlSystem != ControlSystem.GearVRController && OVRInput.GetDown(OVRInput.Button.Back))
				{
					return true;
				}
				break;
			case ControllerMapping.Shop_Left:
			{
				float x2 = OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController()).eulerAngles.x;
				if (m_controllerReset && x2 < 180f && x2 > 20f)
				{
					m_controllerReset = false;
					return true;
				}
				break;
			}
			case ControllerMapping.Shop_Right:
			{
				float x = OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController()).eulerAngles.x;
				if (m_controllerReset && x > 180f && x < 340f)
				{
					m_controllerReset = false;
					return true;
				}
				break;
			}
			}
		}
		else if (m_currentControlSystem == ControlSystem.PadControl)
		{
			switch (controllerMapping)
			{
			case ControllerMapping.DPad_Up:
			{
				float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
				if (m_prevVertAxis > -0.75f && axis2 < -0.75f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.DPad_Down:
			{
				float axis = CrossPlatformInputManager.GetAxis("Vertical");
				if (m_prevVertAxis < 0.75f && axis > 0.75f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.DPad_Left:
			{
				float axis3 = CrossPlatformInputManager.GetAxis("Horizontal");
				if (m_prevHorAxis > -0.75f && axis3 < -0.75f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.DPad_Right:
			{
				float axis4 = CrossPlatformInputManager.GetAxis("Horizontal");
				if (m_prevHorAxis < 0.75f && axis4 > 0.75f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.Button_A:
				if (CrossPlatformInputManager.GetButtonDown("joystick button 0"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_B:
				if (CrossPlatformInputManager.GetButtonDown("joystick button 1"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_X:
				if (CrossPlatformInputManager.GetButtonDown("joystick button 2"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_Y:
				if (CrossPlatformInputManager.GetButtonDown("joystick button 3"))
				{
					return true;
				}
				break;
			case ControllerMapping.SpeedBoost:
				if (GetRemappedButtonDown(InputConfigType.Boost))
				{
					return true;
				}
				break;
			case ControllerMapping.Weapon:
				if (GetRemappedButtonDown(InputConfigType.Weapon))
				{
					return true;
				}
				break;
			case ControllerMapping.Shop_Left:
				if (CrossPlatformInputManager.GetButtonDown("joystick button 4"))
				{
					return true;
				}
				break;
			case ControllerMapping.Shop_Right:
				if (CrossPlatformInputManager.GetButtonDown("joystick button 5"))
				{
					return true;
				}
				break;
			case ControllerMapping.Quit_Menu:
				if (GetRemappedButtonDown(InputConfigType.Quit))
				{
					return true;
				}
				break;
			case ControllerMapping.Recentre_View:
				if (GetRemappedButtonDown(InputConfigType.Recentre))
				{
					return true;
				}
				break;
			default:
				switch (controllerMapping)
				{
				case ControllerMapping.Shop_Left:
					if (GetRemappedButtonDown(InputConfigType.MenuLeft))
					{
						return true;
					}
					break;
				case ControllerMapping.Shop_Right:
					if (GetRemappedButtonDown(InputConfigType.MenuRight))
					{
						return true;
					}
					break;
				case ControllerMapping.Horn:
					if (GetRemappedButtonDown(InputConfigType.Horn))
					{
						return true;
					}
					break;
				}
				break;
			}
		}
		return false;
	}

	private float PadTouchAngle()
	{
		Vector2 to = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
		to.x -= 0.5f;
		to.y -= 0.5f;
		to *= 2f;
		float num = Vector2.Angle(Vector2.up, to);
		Vector3 vector = new Vector3(to.x, to.y, 0f);
		Vector3 vector2 = Vector3.Cross(vector, Vector3.right);
		if (Vector3.Dot(Vector3.right, vector) < 0f)
		{
			num = 180f + (180f - num);
		}
		return num;
	}

	public bool GetButtonUp(ControllerMapping controllerMapping)
	{
		if (m_currentControlSystem == ControlSystem.GearVRController)
		{
			switch (controllerMapping)
			{
			case ControllerMapping.Button_A:
				if (OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad) || OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger))
				{
					return true;
				}
				break;
			case ControllerMapping.SpeedBoost:
				if (OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad))
				{
					return true;
				}
				break;
			case ControllerMapping.Weapon:
				if (OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad))
				{
					return true;
				}
				break;
			case ControllerMapping.Quit_Menu:
				if (m_currentControlSystem != ControlSystem.GearVRController && OVRInput.GetUp(OVRInput.Button.Back))
				{
					return true;
				}
				break;
			}
		}
		else if (m_currentControlSystem == ControlSystem.PadControl)
		{
			switch (controllerMapping)
			{
			case ControllerMapping.Button_A:
				if (CrossPlatformInputManager.GetButtonUp("joystick button 0"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_B:
				if (CrossPlatformInputManager.GetButtonUp("joystick button 1"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_X:
				if (CrossPlatformInputManager.GetButtonUp("joystick button 2"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_Y:
				if (CrossPlatformInputManager.GetButtonUp("joystick button 3"))
				{
					return true;
				}
				break;
			case ControllerMapping.SpeedBoost:
				if (GetRemappedButtonUp(InputConfigType.Boost))
				{
					return true;
				}
				break;
			case ControllerMapping.Weapon:
				if (GetRemappedButtonUp(InputConfigType.Weapon))
				{
					return true;
				}
				break;
			case ControllerMapping.Shop_Left:
				if (CrossPlatformInputManager.GetButtonUp("joystick button 4"))
				{
					return true;
				}
				break;
			case ControllerMapping.Shop_Right:
				if (CrossPlatformInputManager.GetButtonUp("joystick button 5"))
				{
					return true;
				}
				break;
			default:
				if (controllerMapping == ControllerMapping.Shop_Right && CrossPlatformInputManager.GetButtonUp("joystick button 7"))
				{
					return true;
				}
				break;
			}
		}
		return false;
	}

	public bool GetButton(ControllerMapping controllerMapping)
	{
		if (m_currentControlSystem == ControlSystem.GearVRController)
		{
			if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger))
			{
				if (controllerMapping == ControllerMapping.Acceleration)
				{
					m_waitForAccelerate = false;
					return true;
				}
			}
			else if (controllerMapping == ControllerMapping.Brake && !m_waitForAccelerate)
			{
				return true;
			}
			switch (controllerMapping)
			{
			case ControllerMapping.Button_A:
				if (OVRInput.Get(OVRInput.Button.PrimaryTouchpad) || OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_B:
				return m_backButtonPressed;
			case ControllerMapping.SpeedBoost:
			{
				Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.GetActiveController());
				if (OVRInput.Get(OVRInput.Button.PrimaryTouchpad) && vector.x < 0f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.Weapon:
			{
				Vector2 vector2 = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.GetActiveController());
				if (OVRInput.Get(OVRInput.Button.PrimaryTouchpad) && vector2.x > 0f)
				{
					return true;
				}
				break;
			}
			case ControllerMapping.Quit_Menu:
				if (m_currentControlSystem != ControlSystem.GearVRController && OVRInput.Get(OVRInput.Button.Back))
				{
					return true;
				}
				break;
			}
		}
		else if (m_currentControlSystem == ControlSystem.PadControl)
		{
			switch (controllerMapping)
			{
			case ControllerMapping.Button_A:
				if (CrossPlatformInputManager.GetButton("joystick button 0"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_B:
				if (CrossPlatformInputManager.GetButton("joystick button 1"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_X:
				if (CrossPlatformInputManager.GetButton("joystick button 2"))
				{
					return true;
				}
				break;
			case ControllerMapping.Button_Y:
				if (CrossPlatformInputManager.GetButton("joystick button 3"))
				{
					return true;
				}
				break;
			case ControllerMapping.SpeedBoost:
				if (GetRemappedButton(InputConfigType.Boost))
				{
					return true;
				}
				break;
			case ControllerMapping.Weapon:
				if (GetRemappedButton(InputConfigType.Weapon))
				{
					return true;
				}
				break;
			case ControllerMapping.Shop_Left:
				if (CrossPlatformInputManager.GetButton("joystick button 4"))
				{
					return true;
				}
				break;
			case ControllerMapping.Shop_Right:
				if (CrossPlatformInputManager.GetButton("joystick button 5"))
				{
					return true;
				}
				break;
			default:
				if (controllerMapping == ControllerMapping.Shop_Right && CrossPlatformInputManager.GetButton("joystick button 7"))
				{
					return true;
				}
				break;
			}
		}
		return false;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
		ResetAllInputs();
	}

	private void UpdateFakeControllerRotation()
	{
	}

	private void CheckControllerType()
	{
		if ((bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Frontend)
		{
			return;
		}
		RemoteConnected = OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote) || OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote);
		if (GameSystem.Instance.GamepadConnected())
		{
			if (m_currentControlSystem != 0)
			{
				m_currentControlSystem = ControlSystem.PadControl;
			}
		}
		else if (RemoteConnected)
		{
			if (m_currentControlSystem != ControlSystem.GearVRController)
			{
				m_currentControlSystem = ControlSystem.GearVRController;
			}
		}
		else if (m_currentControlSystem != 0)
		{
			m_currentControlSystem = ControlSystem.PadControl;
		}
	}

	private void Update()
	{
		CheckControllerType();
		UpdateScrolling();
		UpdateRegisteredInputs();
		if (ENABLE_INPUT_TEST)
		{
			int index = 2;
			GameDebug.Instance.SetDebugText(index, "No Button");
			if (OVRInput.Get(OVRInput.Button.Back))
			{
				GameDebug.Instance.SetDebugText(index++, "BACK BUTTON");
			}
			else if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger))
			{
				GameDebug.Instance.SetDebugText(index++, "Primary Index");
			}
			else if (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad))
			{
				Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, OVRInput.GetActiveController());
				GameDebug.Instance.SetDebugText(index++, "Primary Touch " + vector.ToString());
			}
		}
	}

	private void LateUpdate()
	{
		m_prevHorAxis = CrossPlatformInputManager.GetAxis("Horizontal");
		m_prevVertAxis = CrossPlatformInputManager.GetAxis("Vertical");
		float x = OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController()).eulerAngles.x;
		if (x < 10f || x > 350f)
		{
			m_controllerReset = true;
		}
		if (m_backButtonPressed)
		{
			m_backButtonPressed = false;
		}
	}
}
public class Locator : UnityEngine.MonoBehaviour
{
	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.white;
		Gizmos.DrawWireSphere(base.transform.position, 0.25f);
		Gizmos.DrawWireSphere(base.transform.position, 0.5f);
		DrawLine(base.transform.position + new Vector3(0f, 0.5f, 0f), base.transform.position + new Vector3(0f, 0.5f, 1.25f));
		DrawLine(base.transform.position + new Vector3(0f, 0.5f, 1.25f), base.transform.position + new Vector3(0.5f, 0.5f, 1f));
		DrawLine(base.transform.position + new Vector3(0f, 0.5f, 1.25f), base.transform.position + new Vector3(-0.5f, 0.5f, 1f));
	}

	private void DrawLine(Vector3 vec1, Vector3 vec2)
	{
		vec1 -= base.transform.position;
		vec1 = base.transform.rotation * vec1;
		vec1 += base.transform.position;
		vec2 -= base.transform.position;
		vec2 = base.transform.rotation * vec2;
		vec2 += base.transform.position;
		Gizmos.DrawLine(vec1, vec2);
	}
}
public class MarketCatalogue : UnityEngine.MonoBehaviour
{
	public enum ItemType
	{
		Unknown = -1,
		HelmetProp,
		DashboardProp,
		DashboardStyle,
		HornSFX,
		VisorProp
	}

	public struct CatalogueData
	{
		public ItemType type;

		public string itemID;

		public string displayName;

		public float cost;

		public string filename;

		public bool available;
	}

	public struct ItemData
	{
		public string itemID;
	}

	public struct ItemTypeLookup
	{
		public string stringID;

		public ItemType itemType;

		public ItemTypeLookup(string id, ItemType item)
		{
			stringID = id;
			itemType = item;
		}
	}

	public delegate void SuccessCallback();

	public delegate void FailCallback();

	private enum CatalogueState
	{
		None,
		LoadCatalog,
		WaitForCatalogLoad,
		LoadUserInventory,
		WaitForUserInventory,
		CullUnusedItems,
		Finish
	}

	private SuccessCallback m_successFunc;

	private FailCallback m_failFunc;

	private ItemTypeLookup[] s_itemTypeLookupData = new ItemTypeLookup[5]
	{
		new ItemTypeLookup("HelmetProp", ItemType.HelmetProp),
		new ItemTypeLookup("DashboardProp", ItemType.DashboardProp),
		new ItemTypeLookup("DashboardStyle", ItemType.DashboardStyle),
		new ItemTypeLookup("HornSFX", ItemType.HornSFX),
		new ItemTypeLookup("VisorProp", ItemType.VisorProp)
	};

	private CatalogueState m_catalogueState;

	private List<CatalogueData> m_catalogueData = new List<CatalogueData>();

	private List<ItemData> m_userInventory = new List<ItemData>();

	private float m_currency;

	private string m_lastErrorCode = string.Empty;

	private bool m_waitForInventoryUpdate;

	private ShoppingList m_shoppingListObject;

	private const string CatalogVersion = "Release_V1";

	private const bool USE_FAKE_CATALOGUE = true;

	private bool m_usedFakeCatalogue;

	public string GetLastErrorCode()
	{
		return m_lastErrorCode;
	}

	public bool HasValidCatalogue()
	{
		return m_catalogueData.Count > 0;
	}

	public List<CatalogueData> GetAllCatalogueData()
	{
		return m_catalogueData;
	}

	public void GetAllItemData(ref List<ItemData> itemList, ref float currency)
	{
		itemList = m_userInventory;
		currency = m_currency;
	}

	public void SetAllCatalogueData(List<CatalogueData> catalogueList)
	{
		m_catalogueData = catalogueList;
	}

	public void SetAllItemData(List<ItemData> itemList, float currency)
	{
		m_userInventory = itemList;
		m_currency = currency;
	}

	public List<ItemData> GetPersonalInventory()
	{
		return m_userInventory;
	}

	public float GetCurrency()
	{
		return m_currency;
	}

	private void AddFakeItem(ref GetCatalogItemsResult result, string itemID, string DisplayName, string Tag, string customData)
	{
		CatalogItem catalogItem = new CatalogItem();
		catalogItem.ItemId = itemID;
		catalogItem.DisplayName = DisplayName;
		catalogItem.Consumable = new CatalogItemConsumableInfo();
		catalogItem.Consumable.UsageCount = 1u;
		catalogItem.Tags = new List<string> { Tag };
		catalogItem.CustomData = "\"Filename\",\"";
		catalogItem.CustomData += customData;
		catalogItem.CustomData += "\",\"Available\",\"Yes\"";
		catalogItem.VirtualCurrencyPrices = new Dictionary<string, uint> { { "VK", 0u } };
		result.Catalog.Add(catalogItem);
		ItemData item = default(ItemData);
		item.itemID = catalogItem.ItemId;
		m_userInventory.Add(item);
	}

	private void Update()
	{
		switch (m_catalogueState)
		{
		case CatalogueState.None:
			m_catalogueData.Clear();
			if (!m_usedFakeCatalogue)
			{
				m_usedFakeCatalogue = true;
				GetCatalogItemsResult result = new GetCatalogItemsResult();
				result.Catalog = new List<CatalogItem>();
				AddFakeItem(ref result, "Helmet_DevilHorns", "Devil Horns", "HelmetProp", "Helmet_DevilHorns");
				AddFakeItem(ref result, "Helmet_BearEars", "Bear Ears", "HelmetProp", "Helmet_BearEars");
				AddFakeItem(ref result, "Helmet_Cap", "Cap", "HelmetProp", "Helmet_Cap");
				AddFakeItem(ref result, "Helmet_Headphones", "Headphones", "HelmetProp", "Helmet_Headphones");
				AddFakeItem(ref result, "Helmet_Boppers_Heart", "Heart Boppers", "HelmetProp", "Helmet_Boppers_Heart");
				AddFakeItem(ref result, "Helmet_Boppers_Sphere", "Green Boppers", "HelmetProp", "Helmet_Boppers_Sphere");
				AddFakeItem(ref result, "Helmet_Boppers_Star", "Star Boppers", "HelmetProp", "Helmet_Boppers_Star");
				AddFakeItem(ref result, "Helmet_BunnyEars", "Bunny Ears", "HelmetProp", "Helmet_BunnyEars");
				AddFakeItem(ref result, "Helmet_PartyHat_Spotty", "Party Hat: Spotty", "HelmetProp", "Helmet_PartyHat_Spotty");
				AddFakeItem(ref result, "Helmet_PartyHat_Stars", "Party Hat: Stars", "HelmetProp", "Helmet_PartyHat_Stars");
				AddFakeItem(ref result, "Visor_Sunglasses", "Sunglasses", "VisorProp", "Visor_Sunglasses");
				AddFakeItem(ref result, "Visor_HypnoEyes", "Hypnotic Eyes", "VisorProp", "Visor_HypnoEyes");
				ConstructCatalog(result);
			}
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
			{
				m_catalogueState = CatalogueState.LoadCatalog;
			}
			break;
		case CatalogueState.LoadCatalog:
		{
			m_catalogueState = CatalogueState.WaitForCatalogLoad;
			GetCatalogItemsRequest getCatalogItemsRequest = new GetCatalogItemsRequest();
			getCatalogItemsRequest.CatalogVersion = "Release_V1";
			PlayFabClientAPI.GetCatalogItems(getCatalogItemsRequest, ConstructCatalog, OnPlayFabError);
			break;
		}
		case CatalogueState.LoadUserInventory:
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
			{
				m_catalogueState = CatalogueState.WaitForUserInventory;
				PlayFabClientAPI.GetUserInventory(new GetUserInventoryRequest(), OnGetUserInventory, OnPlayFabError);
			}
			break;
		case CatalogueState.CullUnusedItems:
		{
			bool flag = true;
			do
			{
				flag = true;
				for (int i = 0; i < m_catalogueData.Count; i++)
				{
					if (!m_catalogueData[i].available && !IsItemOwnedByUser(m_catalogueData[i].itemID))
					{
						m_catalogueData.RemoveAt(i);
						flag = false;
						break;
					}
				}
			}
			while (!flag);
			m_catalogueState = CatalogueState.Finish;
			break;
		}
		}
		if (m_catalogueState == CatalogueState.Finish && m_waitForInventoryUpdate)
		{
			m_waitForInventoryUpdate = false;
			if (m_successFunc != null)
			{
				m_successFunc();
			}
		}
	}

	private bool ItemFoundInCatalogue(string itemID)
	{
		for (int i = 0; i < m_catalogueData.Count; i++)
		{
			if (m_catalogueData[i].itemID == itemID)
			{
				return true;
			}
		}
		return false;
	}

	private ItemType FindItemTypeByID(string ID)
	{
		for (int i = 0; i < s_itemTypeLookupData.Length; i++)
		{
			if (s_itemTypeLookupData[i].stringID == ID)
			{
				return s_itemTypeLookupData[i].itemType;
			}
		}
		return ItemType.Unknown;
	}

	private void ConstructCatalog(GetCatalogItemsResult result)
	{
		List<CatalogItem> catalog = result.Catalog;
		for (int i = 0; i < catalog.Count; i++)
		{
			CatalogueData item = default(CatalogueData);
			if (catalog[i].CustomData != "null" && catalog[i].CustomData.Length > 0)
			{
				string[] array = catalog[i].CustomData.Split("\""[0]);
				for (int j = 0; j < array.Length; j++)
				{
					if (array[j] == "Filename")
					{
						j += 2;
						item.filename = array[j];
					}
					else if (array[j] == "Available")
					{
						j += 2;
						item.available = ((array[j] == "True" || array[j] == "Yes") ? true : false);
					}
				}
			}
			else
			{
				item.filename = string.Empty;
				item.available = false;
			}
			item.type = FindItemTypeByID(catalog[i].Tags[0]);
			item.displayName = catalog[i].DisplayName;
			item.itemID = catalog[i].ItemId;
			item.cost = catalog[i].VirtualCurrencyPrices["VK"];
			m_catalogueData.Add(item);
		}
		m_catalogueState = CatalogueState.LoadUserInventory;
	}

	private void OnGetUserInventory(GetUserInventoryResult result)
	{
		List<ItemInstance> inventory = result.Inventory;
		if (inventory.Count > 0)
		{
			m_userInventory.Clear();
		}
		for (int i = 0; i < inventory.Count; i++)
		{
			if (inventory[i].RemainingUses.HasValue && ItemFoundInCatalogue(inventory[i].ItemId))
			{
				ItemData item = default(ItemData);
				item.itemID = inventory[i].ItemId;
				m_userInventory.Add(item);
				if ((bool)m_shoppingListObject)
				{
					m_shoppingListObject.RemoveShoppingItem(item.itemID);
				}
			}
		}
		if (result.VirtualCurrency.ContainsKey("VK"))
		{
			m_currency = result.VirtualCurrency["VK"];
		}
		m_catalogueState = CatalogueState.CullUnusedItems;
	}

	public List<CatalogueData> GetCatalogueDataByType(ItemType type)
	{
		List<CatalogueData> list = new List<CatalogueData>();
		for (int i = 0; i < m_catalogueData.Count; i++)
		{
			if (m_catalogueData[i].type == type)
			{
				list.Add(m_catalogueData[i]);
			}
		}
		return list;
	}

	public bool GetCatalogueDataItemByID(string ID, ref CatalogueData data)
	{
		for (int i = 0; i < m_catalogueData.Count; i++)
		{
			if (m_catalogueData[i].itemID == ID)
			{
				data = m_catalogueData[i];
				return true;
			}
		}
		return false;
	}

	public bool IsItemOwnedByUser(string ID)
	{
		if (ID.Contains("Internal_"))
		{
			return true;
		}
		for (int i = 0; i < m_userInventory.Count; i++)
		{
			if (ID == m_userInventory[i].itemID)
			{
				return true;
			}
		}
		return false;
	}

	public List<ItemData> GetUserInventory()
	{
		return m_userInventory;
	}

	public void PurchaseItem(string ID, ShoppingList shoppingListObject, SuccessCallback successFunc, FailCallback failFunc)
	{
		CatalogueData data = default(CatalogueData);
		if (GetCatalogueDataItemByID(ID, ref data))
		{
			m_shoppingListObject = shoppingListObject;
			m_successFunc = successFunc;
			m_failFunc = failFunc;
			if (IsItemOwnedByUser(ID))
			{
				m_lastErrorCode = "Already owned";
				failFunc();
				return;
			}
			PurchaseItemRequest purchaseItemRequest = new PurchaseItemRequest();
			purchaseItemRequest.CatalogVersion = "Release_V1";
			purchaseItemRequest.VirtualCurrency = "VK";
			purchaseItemRequest.Price = (int)data.cost;
			purchaseItemRequest.ItemId = ID;
			PlayFabClientAPI.PurchaseItem(purchaseItemRequest, OnPurchase, PurchaseFail);
		}
	}

	public void OnPurchase(PurchaseItemResult result)
	{
		m_waitForInventoryUpdate = true;
		m_catalogueState = CatalogueState.WaitForCatalogLoad;
		GameSystem.Instance.GetMarket().UpdateInventory();
	}

	private void onConsumeCompleted(ConsumeItemResult result)
	{
		UnityEngine.Debug.Log("Consumed");
	}

	public void UpdateInventory()
	{
		if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
		{
			PlayFabClientAPI.GetUserInventory(new GetUserInventoryRequest(), OnGetUserInventory, OnPlayFabError);
		}
	}

	private void OnPlayFabError(PlayFabError error)
	{
		UnityEngine.Debug.Log("Got an error: " + error.ErrorMessage);
		m_catalogueState = CatalogueState.Finish;
		if (m_waitForInventoryUpdate)
		{
			m_waitForInventoryUpdate = false;
			PurchaseFail(error);
		}
	}

	private void PurchaseFail(PlayFabError error)
	{
		m_lastErrorCode = error.ErrorMessage;
		UnityEngine.Debug.Log("Got an error: " + error.ErrorMessage);
		if (m_failFunc != null)
		{
			m_failFunc();
		}
	}
}
public class NetworkChat : UnityEngine.MonoBehaviour
{
	public class StringData : IComparable
	{
		public float TimeStamp;

		public string Text;

		public int CompareTo(object obj)
		{
			StringData stringData = obj as StringData;
			return TimeStamp.CompareTo(stringData.TimeStamp);
		}
	}

	[SerializeField]
	private float UpdatePeriod = 0.5f;

	private List<StringData> m_stringBuffer = new List<StringData>();

	private List<StringData> m_stringReceiveBuffer = new List<StringData>();

	private List<string> m_stringOutputBuffer = new List<string>();

	private float m_currentUpdateTime;

	public void SendString(string text)
	{
		string empty = string.Empty;
		string playerName = ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true);
		if (playerName.Length < ProfileManager.MaxNameLength)
		{
			empty = playerName;
		}
		else
		{
			empty = playerName.Substring(0, ProfileManager.MaxNameLength);
			empty += "..";
		}
		StringData stringData = new StringData();
		stringData.TimeStamp = PhotonNetwork.networkingPeer.ServerTimeInMilliSeconds;
		stringData.Text = empty;
		m_stringBuffer.Add(stringData);
		NetworkLogin.Instance.GetServer().SendChatString(stringData.TimeStamp, empty, text);
		ReceiveString(stringData.TimeStamp, empty, text);
	}

	public void ReceiveString(float time, string profileName, string text)
	{
		string translationByIdentifier = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(text);
		StringData stringData = new StringData();
		stringData.TimeStamp = time;
		stringData.Text = profileName + ": " + translationByIdentifier;
		m_stringReceiveBuffer.Add(stringData);
		UpdateStringBuffer();
	}

	public string[] GetChatOutput()
	{
		string[] result = m_stringOutputBuffer.ToArray();
		m_stringOutputBuffer.Clear();
		return result;
	}

	private void Update()
	{
	}

	private void UpdateStringBuffer()
	{
		for (int i = 0; i < m_stringReceiveBuffer.Count; i++)
		{
			m_stringOutputBuffer.Add(m_stringReceiveBuffer[i].Text);
		}
		m_stringReceiveBuffer.Clear();
	}
}
public class NetworkClient : UnityEngine.MonoBehaviour
{
	public enum EventMask
	{
		Used,
		ReceivedNewData,
		LeftRoom,
		KartPutOnTrack,
		Boost,
		FinishedWithBees,
		NoExhaust,
		BlackExhaust,
		ToxicExhaust,
		Drifting
	}

	public enum GameplayEvent
	{
		InGame,
		FireMissile,
		FireMine,
		FireStinger,
		Toxic,
		Shield,
		FireReverse,
		Bombhead,
		Portal,
		Bees,
		Horn,
		ResultsShown,
		ShowingResults,
		RadiusBomb,
		Max
	}

	public struct CharacterData
	{
		public int playerIndex;

		public int targetIndex;

		public Quaternion rotation;

		public float steerAngle;

		public int eventMask;

		public float pointOnTrack;

		public double finalTime;

		public double avgTime;

		public Vector3 currentPosition;
	}

	[HideInInspector]
	public int[] m_gameplayEvents;

	[HideInInspector]
	public float m_startTime;

	private CharacterData[] m_characterList;

	public CharacterData[] GetCharacterList()
	{
		return m_characterList;
	}

	public bool GetCharacterListForSerializeByIndex(int index, ref CharacterData data)
	{
		if (m_characterList != null && m_characterList.Length > index)
		{
			data = m_characterList[index];
			return true;
		}
		return false;
	}

	public void GetCharacterListByIndex(int index, ref CharacterData data)
	{
		for (int i = 0; i < m_characterList.Length; i++)
		{
			if (m_characterList[i].playerIndex == index)
			{
				data = m_characterList[i];
				break;
			}
		}
	}

	public void ResetGameplayEvents()
	{
		for (int i = 0; i < m_gameplayEvents.Length; i++)
		{
			m_gameplayEvents[i] = 0;
		}
	}

	public bool IsGameplayEventActive(int index, GameplayEvent ev)
	{
		return (m_gameplayEvents[(int)ev] & (1 << index)) != 0;
	}

	public bool GetCharacterListEvent(int index, EventMask ev)
	{
		int num = FindCharacterListIndex(index);
		if (m_characterList != null && num >= 0 && num < m_characterList.Length)
		{
			return (m_characterList[num].eventMask & (1 << (int)ev)) != 0;
		}
		return false;
	}

	public void SetCharacterListEvent(int index, EventMask ev)
	{
		int num = FindCharacterListIndex(index);
		m_characterList[num].eventMask |= 1 << (int)ev;
	}

	public void UnSetCharacterListEvent(int index, EventMask ev)
	{
		int num = FindCharacterListIndex(index);
		m_characterList[num].eventMask &= ~(1 << (int)ev);
	}

	public void ResetCharacterList(int index)
	{
		int num = FindCharacterListIndex(index);
		m_characterList[num].playerIndex = -1;
	}

	public void ResetAllCharacterLists()
	{
		for (int i = 0; i < m_characterList.Length; i++)
		{
			m_characterList[i].playerIndex = -1;
		}
	}

	public int FindCharacterListIndex(int onlineIndex)
	{
		int num = 0;
		for (num = 0; num < m_characterList.Length && m_characterList[num].playerIndex != onlineIndex; num++)
		{
		}
		if (num == m_characterList.Length)
		{
			for (num = 0; num < m_characterList.Length; num++)
			{
				if (m_characterList[num].playerIndex == -1)
				{
					m_characterList[num].playerIndex = onlineIndex;
					m_characterList[num].eventMask = 0;
					break;
				}
			}
		}
		return num;
	}

	public void SetCharacterListByIndex(int index, ref CharacterData data)
	{
		ref CharacterData reference = ref m_characterList[index];
		reference = data;
	}

	private void Start()
	{
		m_characterList = new CharacterData[NetworkLogin.Instance.MaxPlayersInRoom];
		m_gameplayEvents = new int[14];
		for (int i = 0; i < m_characterList.Length; i++)
		{
			m_characterList[i].playerIndex = -1;
		}
	}

	private void PopulateCharacterData(int playerIndex, int targetIndex, int eventMask, double finalTime, double avgTime)
	{
		int num = FindCharacterListIndex(playerIndex);
		m_characterList[num].playerIndex = playerIndex;
		m_characterList[num].targetIndex = targetIndex;
		m_characterList[num].eventMask = eventMask;
		m_characterList[num].finalTime = finalTime;
		m_characterList[num].avgTime = avgTime;
		SetCharacterListEvent(playerIndex, EventMask.Used);
		SetCharacterListEvent(playerIndex, EventMask.ReceivedNewData);
	}

	[PunRPC]
	public void CharacterUpdate(int playerNum, int targetIndex, int eventMask, double finalTime, double avgTime)
	{
		PopulateCharacterData(playerNum, targetIndex, eventMask, finalTime, avgTime);
	}

	private void PopulatePlayerHeader(int playerIndex, int[] cols, string helmetProp, string visorProp, string dashProp, string dashStyle, string playerName, bool inOnlineRoom, int numWins, int onlinePoints)
	{
		int num = 0;
		for (num = 0; num < NetworkLogin.Instance.MaxPlayersInRoom && (!(FEMManager.Instance.GetFrontendPlayer(num) != null) || FEMManager.Instance.GetFrontendPlayer(num).OnlinePlayerIndex != playerIndex); num++)
		{
		}
		if (num == NetworkLogin.Instance.MaxPlayersInRoom)
		{
			if (FEMManager.Instance.InHoldingState)
			{
				FEMManager.Instance.AddHoldingPlayer(playerName, playerIndex);
			}
			return;
		}
		ProfileManager.PlayerData data = ProfileManager.Instance.GetPlayerData(num);
		ProfileManager.Instance.SetPlayerName(num, playerName);
		data.m_colourIndex = cols;
		ProfileManager.Instance.SetPlayerData(num, ref data);
		Player player = FEMManager.Instance.GetFrontendPlayer(num);
		if (!(player != null))
		{
			return;
		}
		for (int i = 0; i < data.m_colourIndex.Length; i++)
		{
			ProfileManager.Instance.UpdateColours(num, i);
		}
		ProfileManager.Instance.SetColoursOnPlayer(ref player, num);
		data = ProfileManager.Instance.GetPlayerData(num);
		data.m_customisationData.m_helmetProp = helmetProp;
		data.m_customisationData.m_visorProp = visorProp;
		data.m_customisationData.m_dashProp = dashProp;
		data.m_customisationData.m_dashStyle = dashStyle;
		ProfileManager.Instance.SetPlayerData(num, ref data);
		if (inOnlineRoom && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend && FEMManager.Instance.GetOnlineState() == FEMManager.FEMOnlineState.InRoom)
		{
			player.SetName(playerName);
			player.SetNumWins(numWins);
			player.SetOnlinePoints(onlinePoints);
			int num2 = GameSystem.Instance.GetPositionChooser().FindSeatPosition(player.OnlinePlayerIndex);
			if (num2 != -1)
			{
				GameSystem.Instance.GetPositionChooser().SetStoredOnlinePoints(num2, onlinePoints);
			}
		}
		player.SetupCustomisationProps(num);
	}

	[PunRPC]
	public void PlayerHeader(int playerIndex, int colour0, int colour1, int colour2, int colour3, int colour4, int colour5, int colour6, string helmetProp, string visorProp, string dashProp, string dashStyle, string playerName, bool inOnlineRoom, int numWins, int onlinePoints)
	{
		PopulatePlayerHeader(playerIndex, new int[7] { colour0, colour1, colour2, colour3, colour4, colour5, colour6 }, helmetProp, visorProp, dashProp, dashStyle, playerName, inOnlineRoom, numWins, onlinePoints);
	}

	[PunRPC]
	public void OnlineEntry(int trackIndex, int[] onlineIndices, int[] seatIndices, float holdingTime, int votingTrack1, int votingTrack2)
	{
		FEMManager.Instance.SetOnlineTrack(trackIndex);
		Player[] frontendPlayerList = FEMManager.Instance.GetFrontendPlayerList();
		if (frontendPlayerList != null)
		{
			for (int i = 0; i < onlineIndices.Length; i++)
			{
				if (onlineIndices[i] != -1)
				{
					NetworkLogin.Instance.GetServer().SetPlayerConnection(onlineIndices[i], seatIndices[i]);
				}
				for (int j = 0; j < frontendPlayerList.Length; j++)
				{
					if (frontendPlayerList[j] != null && frontendPlayerList[j].OnlinePlayerIndex == onlineIndices[i])
					{
						Player player = frontendPlayerList[j];
						player.SeatIndex = seatIndices[i];
						player.MasterIsHappy = true;
						GameSystem.Instance.GetPositionChooser().SetSeatPosition(player.OnlinePlayerIndex, player.SeatIndex);
					}
				}
			}
		}
		if (holdingTime != -1f)
		{
			FEMManager.Instance.SetCurrentHoldingTimer(holdingTime - (float)PhotonNetwork.GetPing() * 0.001f);
			GameSystem.Instance.LastSelectedOnlineTrack1 = votingTrack1;
			GameSystem.Instance.LastSelectedOnlineTrack2 = votingTrack2;
			GameSystem.Instance.WaitingForOnlineTrackSelection = false;
		}
	}

	[PunRPC]
	public void GameplayEvents(int[] gameplayEvents)
	{
		if (!GameEntry.Instance || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			m_gameplayEvents = gameplayEvents;
		}
	}

	[PunRPC]
	public void GameSetupData(int[] seatIndices, int[] onlineIndices)
	{
		Player[] frontendPlayerList = FEMManager.Instance.GetFrontendPlayerList();
		for (int i = 0; i < seatIndices.Length; i++)
		{
			if (onlineIndices[i] == -1)
			{
				continue;
			}
			for (int j = 0; j < frontendPlayerList.Length; j++)
			{
				if ((bool)frontendPlayerList[j] && frontendPlayerList[j].OnlinePlayerIndex == onlineIndices[i])
				{
					frontendPlayerList[j].NewGridPosition = seatIndices[i];
					break;
				}
			}
		}
	}

	[PunRPC]
	public void ExtraGameplayData(int onlineIndex, Vector3 orientation)
	{
		if ((!GameEntry.Instance || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game) && !(PlayerManager.Instance == null))
		{
			Player player = PlayerManager.Instance.FindPlayerByOnlineIndex(onlineIndex);
			if ((bool)player)
			{
				player.CorrectOrientation(orientation);
			}
		}
	}

	[PunRPC]
	public void ChatOutput(float time, string profileName, string text)
	{
		NetworkLogin.Instance.GetChat().ReceiveString(time, profileName, text);
	}

	[PunRPC]
	public void ExtraFrontendData(int seatIndex, int voteCount, Quaternion headRotation)
	{
		if ((bool)FEMManager.Instance && seatIndex >= 0)
		{
			FEMManager.Instance.PlayerVotes[seatIndex] = (FEMManager.PlayerVote)voteCount;
			m_characterList[seatIndex].rotation = headRotation;
		}
	}
}
public class NetworkIAP : UnityEngine.MonoBehaviour
{
}
public class NetworkKart : Photon.MonoBehaviour, IPunObservable
{
	private Player m_player;

	private const float k_ForceMovementAmount = 2f;

	private float m_forceMovementTime;

	private bool m_keepAwakeFlipFlop;

	private void Awake()
	{
		m_player = GetComponent<Player>();
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (!base.photonView)
		{
			base.enabled = false;
		}
		else if (GameTime.Instance.CurrentTime() > m_forceMovementTime)
		{
			m_forceMovementTime = GameTime.Instance.CurrentTime() + 2f;
			m_keepAwakeFlipFlop = !m_keepAwakeFlipFlop;
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.isWriting)
		{
			Quaternion obj = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.rotation;
			stream.Serialize(ref obj);
			float obj2 = m_player.GetSteeringAngle();
			stream.Serialize(ref obj2);
			float obj3 = m_player.PointOnTrack();
			stream.Serialize(ref obj3);
			Vector3 obj4 = m_player.transform.position;
			stream.Serialize(ref obj4);
			float obj5 = ((!NetworkLogin.Instance.IsMasterPlayer()) ? 0f : NetworkLogin.Instance.GetServer().GetStartTime());
			stream.Serialize(ref obj5);
			float obj6 = ((!NetworkLogin.Instance.IsMasterPlayer()) ? 20f : NetworkLogin.Instance.GetServer().GetKillGameTime());
			stream.Serialize(ref obj6);
			stream.Serialize(ref m_keepAwakeFlipFlop);
			return;
		}
		Quaternion obj7 = Quaternion.identity;
		stream.Serialize(ref obj7);
		float obj8 = 0f;
		stream.Serialize(ref obj8);
		float obj9 = 0f;
		stream.Serialize(ref obj9);
		Vector3 obj10 = Vector3.zero;
		stream.Serialize(ref obj10);
		float obj11 = 0f;
		stream.Serialize(ref obj11);
		float obj12 = 0f;
		stream.Serialize(ref obj12);
		bool myBool = false;
		stream.Serialize(ref myBool);
		int num = 0;
		if (m_player.SeatIndex == -1)
		{
			return;
		}
		num = NetworkLogin.Instance.GetClient().FindCharacterListIndex(m_player.SeatIndex);
		NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
		if (!NetworkLogin.Instance.GetClient().GetCharacterListForSerializeByIndex(num, ref data))
		{
			return;
		}
		data.rotation = obj7;
		data.steerAngle = obj8;
		data.pointOnTrack = obj9;
		data.currentPosition = obj10;
		NetworkLogin.Instance.GetClient().SetCharacterListByIndex(num, ref data);
		if (obj11 > 0f)
		{
			obj11 -= (float)PhotonNetwork.GetPing() * 0.001f;
			if ((bool)Gameplay.Instance)
			{
				Gameplay.Instance.SetStartTime(obj11);
			}
			obj11 = 0f;
		}
		if ((bool)Gameplay.Instance && !NetworkLogin.Instance.IsMasterPlayer() && obj12 < 20f && Gameplay.Instance.InitKillGameTime)
		{
			Gameplay.Instance.KillGameTime = obj12;
		}
	}
}
public class NetworkLeaderboards : UnityEngine.MonoBehaviour
{
	public enum LeaderboardType
	{
		QuickPlay,
		OnlinePoints,
		Max
	}

	public class LeaderboardSortData : IComparable
	{
		public string displayName;

		public float time;

		public int position;

		public int CompareTo(object obj)
		{
			LeaderboardSortData leaderboardSortData = obj as LeaderboardSortData;
			return time.CompareTo(leaderboardSortData.time);
		}
	}

	public struct LeaderboardEntry
	{
		public int position;

		public string displayName;

		public string time;
	}

	public class Leaderboard
	{
		public string trackName;

		public float updateTime;

		public LeaderboardEntry[] entry;

		public LeaderboardType type;

		public Leaderboard()
		{
			entry = new LeaderboardEntry[10];
		}
	}

	[HideInInspector]
	public delegate void LeaderboardCallback(Leaderboard newLeaderboard);

	private const int MAX_LEADERBOARD_ENTRIES = 10;

	public static bool USE_LEADERBOARDS = true;

	private string[] StatName = new string[2] { "QP", "OP" };

	private List<Leaderboard> m_leaderboardList = new List<Leaderboard>();

	private int m_totalTracks;

	private Leaderboard m_currentLeaderboard;

	private Leaderboard m_currentOnlinePointsLeaderboard;

	private LeaderboardCallback m_callback;

	private Dictionary<string, int> m_currentUserStats;

	private List<int> m_leaderboardQueue = new List<int>();

	private List<string> m_leaderboardIDList = new List<string>();

	public Leaderboard GetCurrentLeaderboard()
	{
		return m_currentLeaderboard;
	}

	public Leaderboard GetOnlinePointsLeaderboard()
	{
		return m_currentOnlinePointsLeaderboard;
	}

	public void RefreshLeaderboards()
	{
		if (USE_LEADERBOARDS)
		{
			m_leaderboardQueue.Clear();
			m_totalTracks = GameSystem.Instance.GetTrackListing().GetTotalTracks();
			if (m_totalTracks > 0)
			{
				m_leaderboardList.Clear();
			}
			m_currentLeaderboard = null;
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
			{
				PlayFabClientAPI.GetUserStatistics(new GetUserStatisticsRequest(), OnUserStatsRetrieval, OnPlayFabError);
			}
		}
	}

	public Leaderboard GetLeaderboardByTrackName(string trackName)
	{
		for (int i = 0; i < m_leaderboardList.Count; i++)
		{
			if (m_leaderboardList[i].trackName == trackName)
			{
				return m_leaderboardList[i];
			}
		}
		return null;
	}

	public bool AddLeaderboardEntry(LeaderboardType type, string trackName, float timeInSeconds)
	{
		bool result = false;
		if (USE_LEADERBOARDS && (bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
		{
			string key = string.Empty;
			int num = 0;
			switch (type)
			{
			case LeaderboardType.QuickPlay:
				key = StatName[(int)type] + "_" + trackName;
				num = (int)(timeInSeconds * 1000f);
				num = -num;
				break;
			case LeaderboardType.OnlinePoints:
				key = "OnlinePoints";
				num = (int)timeInSeconds;
				break;
			}
			if (m_currentUserStats.ContainsKey(key))
			{
				if (type == LeaderboardType.QuickPlay && num < m_currentUserStats[key])
				{
					m_currentUserStats[key] = num;
					result = true;
				}
				else if (type == LeaderboardType.OnlinePoints)
				{
					m_currentUserStats[key] = num;
					result = true;
				}
			}
			else
			{
				m_currentUserStats.Add(key, num);
				result = true;
			}
			UpdateUserStatisticsRequest updateUserStatisticsRequest = new UpdateUserStatisticsRequest();
			updateUserStatisticsRequest.UserStatistics = m_currentUserStats;
			PlayFabClientAPI.UpdateUserStatistics(updateUserStatisticsRequest, OnUserStatsUpdate, OnPlayFabError);
		}
		return result;
	}

	public void GetLeaderboard(string trackName, LeaderboardCallback callback, bool showLeaderboardAroundUser, bool showLeaderboardAroundFriends)
	{
		if (GameSystem.Instance == null || m_leaderboardQueue == null || !USE_LEADERBOARDS)
		{
			return;
		}
		int trackIndexBySceneName = GameSystem.Instance.GetTrackListing().GetTrackIndexBySceneName(trackName);
		for (int i = 0; i < m_leaderboardQueue.Count; i++)
		{
			if (m_leaderboardQueue[i] == trackIndexBySceneName)
			{
				return;
			}
		}
		m_leaderboardQueue.Add(trackIndexBySceneName);
		m_callback = callback;
		if (showLeaderboardAroundUser)
		{
			GetLeaderboardAroundCurrentUserRequest getLeaderboardAroundCurrentUserRequest = new GetLeaderboardAroundCurrentUserRequest();
			getLeaderboardAroundCurrentUserRequest.MaxResultsCount = 10;
			getLeaderboardAroundCurrentUserRequest.StatisticName = StatName[0] + "_" + trackName;
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
			{
				PlayFabClientAPI.GetLeaderboardAroundCurrentUser(getLeaderboardAroundCurrentUserRequest, ConstructLeaderboardAroundUser, OnPlayFabError);
			}
		}
		else
		{
			GetLeaderboardRequest getLeaderboardRequest = new GetLeaderboardRequest();
			getLeaderboardRequest.MaxResultsCount = 10;
			getLeaderboardRequest.StatisticName = StatName[0] + "_" + trackName;
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
			{
				PlayFabClientAPI.GetLeaderboard(getLeaderboardRequest, ConstructLeaderboard, OnPlayFabError);
			}
		}
	}

	public void GetOnlinePointsLeaderboard(LeaderboardCallback callback, bool showLeaderboardAroundUser, bool showLeaderboardAroundFriends)
	{
		if (GameSystem.Instance == null || !USE_LEADERBOARDS)
		{
			return;
		}
		m_callback = callback;
		if (m_currentOnlinePointsLeaderboard == null)
		{
			m_currentOnlinePointsLeaderboard = new Leaderboard();
			m_currentOnlinePointsLeaderboard.type = LeaderboardType.OnlinePoints;
		}
		if (showLeaderboardAroundUser)
		{
			GetLeaderboardAroundCurrentUserRequest getLeaderboardAroundCurrentUserRequest = new GetLeaderboardAroundCurrentUserRequest();
			getLeaderboardAroundCurrentUserRequest.MaxResultsCount = 10;
			getLeaderboardAroundCurrentUserRequest.StatisticName = "OnlinePoints";
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
			{
				PlayFabClientAPI.GetLeaderboardAroundCurrentUser(getLeaderboardAroundCurrentUserRequest, ConstructLeaderboardAroundUserOnlinePoints, OnPlayFabError);
			}
		}
		else
		{
			GetLeaderboardRequest getLeaderboardRequest = new GetLeaderboardRequest();
			getLeaderboardRequest.MaxResultsCount = 10;
			getLeaderboardRequest.StatisticName = "OnlinePoints";
			if ((bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
			{
				PlayFabClientAPI.GetLeaderboard(getLeaderboardRequest, ConstructLeaderboardOnlinePoints, OnPlayFabError);
			}
		}
	}

	private void Start()
	{
		m_leaderboardIDList.Clear();
	}

	private void Update()
	{
	}

	private void ConstructLeaderboard(GetLeaderboardResult result)
	{
		ConstructLeaderboardFromData(result.Leaderboard);
	}

	private void ConstructLeaderboardAroundUser(GetLeaderboardAroundCurrentUserResult result)
	{
		ConstructLeaderboardFromData(result.Leaderboard);
	}

	private void ConstructLeaderboardFromData(List<PlayerLeaderboardEntry> leaderboardData)
	{
		m_currentLeaderboard = null;
		int index = 0;
		if (m_leaderboardQueue.Count > 0)
		{
			index = m_leaderboardQueue[0];
			m_leaderboardQueue.RemoveAt(0);
		}
		if (leaderboardData.Count > 0)
		{
			string scene = GameSystem.Instance.GetTrackListing().GetTrackByIndex(index).Scene;
			for (int i = 0; i < m_leaderboardList.Count; i++)
			{
				if (m_leaderboardList[i].trackName == scene)
				{
					m_currentLeaderboard = m_leaderboardList[i];
					break;
				}
			}
			if (m_currentLeaderboard == null)
			{
				m_currentLeaderboard = new Leaderboard();
				m_currentLeaderboard.trackName = scene;
				m_leaderboardList.Add(m_currentLeaderboard);
			}
			m_currentLeaderboard.updateTime = GameTime.Instance.CurrentTime();
		}
		int num = 0;
		int num2 = 0;
		for (int j = 0; j < leaderboardData.Count; j++)
		{
			PlayerLeaderboardEntry playerLeaderboardEntry = leaderboardData[j];
			if (playerLeaderboardEntry.DisplayName != null)
			{
				m_currentLeaderboard.entry[num2].displayName = ((playerLeaderboardEntry.DisplayName.Length <= 0) ? playerLeaderboardEntry.PlayFabId : playerLeaderboardEntry.DisplayName);
				m_currentLeaderboard.entry[num2].position = playerLeaderboardEntry.Position;
				num = playerLeaderboardEntry.Position;
				float num3 = (float)playerLeaderboardEntry.StatValue / 1000f;
				num3 = 0f - num3;
				int mins = 0;
				int secs = 0;
				int tenths = 0;
				GameTime.Instance.ConvertTimeFromSeconds(num3, ref mins, ref secs, ref tenths);
				m_currentLeaderboard.entry[num2].time = mins.ToString("00") + ":" + secs.ToString("00") + ":" + tenths.ToString("00");
				num2++;
			}
		}
		if (num2 > 0)
		{
			for (int k = num2; k < m_currentLeaderboard.entry.Length; k++)
			{
				m_currentLeaderboard.entry[k].displayName = string.Empty;
				m_currentLeaderboard.entry[k].time = string.Empty;
				m_currentLeaderboard.entry[k].position = num + 1;
				num++;
			}
		}
		if (m_callback != null)
		{
			m_callback(m_currentLeaderboard);
		}
	}

	private void ConstructLeaderboardAroundUserOnlinePoints(GetLeaderboardAroundCurrentUserResult result)
	{
		ConstructLeaderboardFromDataOnlinePoints(result.Leaderboard);
	}

	private void ConstructLeaderboardOnlinePoints(GetLeaderboardResult result)
	{
		ConstructLeaderboardFromDataOnlinePoints(result.Leaderboard);
	}

	private void ConstructLeaderboardFromDataOnlinePoints(List<PlayerLeaderboardEntry> leaderboardData)
	{
		if (m_currentOnlinePointsLeaderboard != null && m_currentOnlinePointsLeaderboard.type == LeaderboardType.OnlinePoints)
		{
			int num = 0;
			for (int i = 0; i < leaderboardData.Count; i++)
			{
				PlayerLeaderboardEntry playerLeaderboardEntry = leaderboardData[i];
				m_currentOnlinePointsLeaderboard.entry[i].displayName = ((playerLeaderboardEntry.DisplayName == null || playerLeaderboardEntry.DisplayName.Length <= 0) ? playerLeaderboardEntry.PlayFabId : playerLeaderboardEntry.DisplayName);
				m_currentOnlinePointsLeaderboard.entry[i].position = playerLeaderboardEntry.Position;
				m_currentOnlinePointsLeaderboard.entry[i].time = playerLeaderboardEntry.StatValue.ToString();
				num = playerLeaderboardEntry.Position;
			}
			for (int j = leaderboardData.Count; j < m_currentOnlinePointsLeaderboard.entry.Length; j++)
			{
				m_currentOnlinePointsLeaderboard.entry[j].displayName = string.Empty;
				m_currentOnlinePointsLeaderboard.entry[j].time = string.Empty;
				m_currentOnlinePointsLeaderboard.entry[j].position = num + 1;
				num++;
			}
		}
		if (m_callback != null)
		{
			m_callback(m_currentOnlinePointsLeaderboard);
		}
	}

	private void OnUserStatsUpdate(UpdateUserStatisticsResult result)
	{
	}

	private void OnUserStatsRetrieval(GetUserStatisticsResult result)
	{
		m_currentUserStats = result.UserStatistics;
	}

	private void OnPlayFabError(PlayFabError error)
	{
		UnityEngine.Debug.Log("Got an error: " + error.ErrorMessage);
	}
}
[RequireComponent(typeof(PhotonView))]
public class NetworkLogin : UnityEngine.MonoBehaviour
{
	private enum NameRegisterState
	{
		None,
		RetrieveName,
		NameAttempt2
	}

	private class PingData : IComparable
	{
		public CloudRegionCode code;

		public int ping;

		public PingData(CloudRegionCode codeVal)
		{
			code = codeVal;
		}

		public int CompareTo(object obj)
		{
			PingData pingData = obj as PingData;
			return ping.CompareTo(pingData.ping);
		}
	}

	private class LanguageData
	{
		public CloudRegionCode code;

		public string language;

		public LanguageData(string languageStr, CloudRegionCode codeVal)
		{
			code = codeVal;
			language = languageStr;
		}
	}

	public enum ServerConnectionState
	{
		NotConnected,
		Connecting,
		FinishedConnecting,
		Finished
	}

	private static string PhotonID_Google = "57d10993-9dd7-4597-910e-a945ebf38126";

	private int MaxPlayers = 8;

	private bool m_connectedToServer;

	private bool m_joinedRoom;

	private int m_playerNumInRoom;

	private PhotonView m_photonView;

	private string m_currentPlayerID = string.Empty;

	private string m_googlePlayerID = string.Empty;

	private string m_googleDisplayName = string.Empty;

	private bool m_allowedToCloudSave;

	private bool m_isSignedIntoGPGS;

	private NameRegisterState m_nameRegisterState;

	private bool m_readyToAuthenticate;

	private bool m_okToAuthenticate = true;

	private string m_authTicket = "None";

	private bool m_waitForInitialConnection = true;

	public static NetworkLogin Instance;

	private static string s_networkDebug = string.Empty;

	private List<int> m_playingPlayers = new List<int>();

	private List<PingData> m_pingDataList = new List<PingData>
	{
		new PingData(CloudRegionCode.asia),
		new PingData(CloudRegionCode.us),
		new PingData(CloudRegionCode.eu)
	};

	private List<LanguageData> m_languageData = new List<LanguageData>
	{
		new LanguageData("be", CloudRegionCode.eu),
		new LanguageData("be-BY", CloudRegionCode.eu),
		new LanguageData("bg", CloudRegionCode.eu),
		new LanguageData("bg-BG", CloudRegionCode.eu),
		new LanguageData("ca", CloudRegionCode.eu),
		new LanguageData("ca-ES", CloudRegionCode.eu),
		new LanguageData("cs", CloudRegionCode.eu),
		new LanguageData("cs-CZ", CloudRegionCode.eu),
		new LanguageData("da", CloudRegionCode.eu),
		new LanguageData("da-DK", CloudRegionCode.eu),
		new LanguageData("de", CloudRegionCode.eu),
		new LanguageData("de-AT", CloudRegionCode.eu),
		new LanguageData("de-CH", CloudRegionCode.eu),
		new LanguageData("de-DE", CloudRegionCode.eu),
		new LanguageData("de-LU", CloudRegionCode.eu),
		new LanguageData("el", CloudRegionCode.eu),
		new LanguageData("el-GR", CloudRegionCode.eu),
		new LanguageData("en-GB", CloudRegionCode.eu),
		new LanguageData("en-IE", CloudRegionCode.eu),
		new LanguageData("es", CloudRegionCode.eu),
		new LanguageData("es-AR", CloudRegionCode.eu),
		new LanguageData("es-DO", CloudRegionCode.eu),
		new LanguageData("es-ES", CloudRegionCode.eu),
		new LanguageData("et", CloudRegionCode.eu),
		new LanguageData("et-EE", CloudRegionCode.eu),
		new LanguageData("eu-ES", CloudRegionCode.eu),
		new LanguageData("fi", CloudRegionCode.eu),
		new LanguageData("fi-FI", CloudRegionCode.eu),
		new LanguageData("fo-FO", CloudRegionCode.eu),
		new LanguageData("fr", CloudRegionCode.eu),
		new LanguageData("fr-BE", CloudRegionCode.eu),
		new LanguageData("fr-CH", CloudRegionCode.eu),
		new LanguageData("fr-LU", CloudRegionCode.eu),
		new LanguageData("fr-FR", CloudRegionCode.eu),
		new LanguageData("gl-ES", CloudRegionCode.eu),
		new LanguageData("hr", CloudRegionCode.eu),
		new LanguageData("hr-HR", CloudRegionCode.eu),
		new LanguageData("hu", CloudRegionCode.eu),
		new LanguageData("hu-HU", CloudRegionCode.eu),
		new LanguageData("id-ID", CloudRegionCode.eu),
		new LanguageData("it-CH", CloudRegionCode.eu),
		new LanguageData("is", CloudRegionCode.eu),
		new LanguageData("is-IS", CloudRegionCode.eu),
		new LanguageData("it", CloudRegionCode.eu),
		new LanguageData("it-IT", CloudRegionCode.eu),
		new LanguageData("lt", CloudRegionCode.eu),
		new LanguageData("lt-LT", CloudRegionCode.eu),
		new LanguageData("lv", CloudRegionCode.eu),
		new LanguageData("lv-LV", CloudRegionCode.eu),
		new LanguageData("nb-NO", CloudRegionCode.eu),
		new LanguageData("nl", CloudRegionCode.eu),
		new LanguageData("nl-BE", CloudRegionCode.eu),
		new LanguageData("nl-NL", CloudRegionCode.eu),
		new LanguageData("nn-NO", CloudRegionCode.eu),
		new LanguageData("pl", CloudRegionCode.eu),
		new LanguageData("pl-PL", CloudRegionCode.eu),
		new LanguageData("pt", CloudRegionCode.eu),
		new LanguageData("pt-PT", CloudRegionCode.eu),
		new LanguageData("ro", CloudRegionCode.eu),
		new LanguageData("ro-RO", CloudRegionCode.eu),
		new LanguageData("ru", CloudRegionCode.eu),
		new LanguageData("ru-RU", CloudRegionCode.eu),
		new LanguageData("sq-AL", CloudRegionCode.eu),
		new LanguageData("sk", CloudRegionCode.eu),
		new LanguageData("sk-SK", CloudRegionCode.eu),
		new LanguageData("sl", CloudRegionCode.eu),
		new LanguageData("sl-SI", CloudRegionCode.eu),
		new LanguageData("sq", CloudRegionCode.eu),
		new LanguageData("sv", CloudRegionCode.eu),
		new LanguageData("sv-SE", CloudRegionCode.eu),
		new LanguageData("sv-FI", CloudRegionCode.eu),
		new LanguageData("tr", CloudRegionCode.eu),
		new LanguageData("tr-TR", CloudRegionCode.eu),
		new LanguageData("uk", CloudRegionCode.eu),
		new LanguageData("uk-UA", CloudRegionCode.eu),
		new LanguageData("en-US", CloudRegionCode.us),
		new LanguageData("en-AU", CloudRegionCode.us),
		new LanguageData("en-NZ", CloudRegionCode.us),
		new LanguageData("ja", CloudRegionCode.asia),
		new LanguageData("ko", CloudRegionCode.asia),
		new LanguageData("th", CloudRegionCode.asia),
		new LanguageData("vi", CloudRegionCode.asia),
		new LanguageData("hi", CloudRegionCode.asia),
		new LanguageData("kok", CloudRegionCode.asia),
		new LanguageData("zh-CHS", CloudRegionCode.asia),
		new LanguageData("zh-CHT", CloudRegionCode.asia),
		new LanguageData("zh-TW", CloudRegionCode.asia),
		new LanguageData("ja-JP", CloudRegionCode.asia),
		new LanguageData("ko-KR", CloudRegionCode.asia),
		new LanguageData("th-TH", CloudRegionCode.asia),
		new LanguageData("sw-KE", CloudRegionCode.asia),
		new LanguageData("gu-IN", CloudRegionCode.asia),
		new LanguageData("ta-IN", CloudRegionCode.asia),
		new LanguageData("te-IN", CloudRegionCode.asia),
		new LanguageData("kn-IN", CloudRegionCode.asia),
		new LanguageData("mr-IN", CloudRegionCode.asia),
		new LanguageData("kok-IN", CloudRegionCode.asia),
		new LanguageData("zh-HK", CloudRegionCode.asia),
		new LanguageData("zh-MO", CloudRegionCode.asia)
	};

	private int m_pingIndex;

	private ServerConnectionState m_serverConnection;

	private CloudRegionCode m_lastRegion = CloudRegionCode.none;

	private float m_disconnectionTimeout;

	private bool USEREGIONAL;

	public bool AuthenticatedAndReady { get; private set; }

	public int MaxPlayersInRoom => MaxPlayers;

	public string PlayFabPlayerID => m_currentPlayerID;

	private void OnEnable()
	{
		AuthenticatedAndReady = false;
	}

	public ServerConnectionState GetConnectionStatus()
	{
		return m_serverConnection;
	}

	public CloudRegionCode FindRegionFromLanguage(string lang)
	{
		for (int i = 0; i < m_languageData.Count; i++)
		{
			if (m_languageData[i].language == lang)
			{
				return m_languageData[i].code;
			}
		}
		return CloudRegionCode.us;
	}

	public void ConnectToServer()
	{
		if (m_googlePlayerID.Length != 0)
		{
			if (m_waitForInitialConnection)
			{
				m_waitForInitialConnection = false;
				AuthenticatedAndReady = false;
			}
			if (PhotonNetwork.connectedAndReady)
			{
				PhotonNetwork.Disconnect();
			}
			PhotonHandler.BestRegionCodeInPreferences = CloudRegionCode.none;
			PhotonNetwork.autoJoinLobby = true;
			if (!USEREGIONAL)
			{
				PhotonNetwork.OverrideBestCloudServer(CloudRegionCode.us);
				PhotonNetwork.ConnectToBestCloudServer("1.0");
				m_pingIndex = m_pingDataList.Count;
			}
			m_serverConnection = ServerConnectionState.Connecting;
		}
	}

	public bool ConnectedToMaster()
	{
		return m_connectedToServer && PhotonNetwork.connectionState == ConnectionState.Connected;
	}

	public bool JoinedRoom()
	{
		return m_joinedRoom;
	}

	public void LeaveRoom()
	{
		GameSystem.Instance.GetPositionChooser().ClearAllSeats();
		if (JoinedRoom())
		{
			PhotonNetwork.LeaveRoom();
		}
		m_joinedRoom = false;
		if ((bool)FEMManager.Instance)
		{
			FEMManager.Instance.RemoveFEMPlayers();
		}
	}

	public int GetPlayerNumber()
	{
		return m_playerNumInRoom;
	}

	public int GetServerPlayerCount()
	{
		return PhotonNetwork.countOfPlayersInRooms;
	}

	public bool IsMasterPlayer()
	{
		return PhotonNetwork.isMasterClient;
	}

	public int GetRoomPlayerCount()
	{
		int num = 0;
		for (int i = 0; i < PhotonNetwork.playerList.Length; i++)
		{
			for (int j = 0; j < m_playingPlayers.Count; j++)
			{
				if (m_playingPlayers[j] == PhotonNetwork.playerList[i].ID)
				{
					num++;
				}
			}
		}
		return num;
	}

	public int GetActualRoomPlayerCount()
	{
		if (PhotonNetwork.room != null)
		{
			return PhotonNetwork.room.playerCount;
		}
		return 0;
	}

	public void ClearAllOnlinePlayers()
	{
		m_playingPlayers.Clear();
	}

	public void IncludeOnlinePlayer(int playerID)
	{
		for (int i = 0; i < m_playingPlayers.Count; i++)
		{
			if (m_playingPlayers[i] == playerID)
			{
				return;
			}
		}
		m_playingPlayers.Add(playerID);
	}

	public void RemoveOnlinePlayer(int playerID)
	{
		for (int i = 0; i < m_playingPlayers.Count; i++)
		{
			if (m_playingPlayers[i] == playerID)
			{
				m_playingPlayers.RemoveAt(i);
				break;
			}
		}
	}

	public int GetNumberOfPlayersLookingForRooms()
	{
		return PhotonNetwork.countOfPlayersOnMaster;
	}

	public int GetNumberOfPlayersInTotal()
	{
		return PhotonNetwork.countOfPlayers;
	}

	public void SetCurrentLap(int lapNum)
	{
		if (PhotonNetwork.room != null && (PhotonNetwork.room.customProperties["lapNum"] == null || (int)PhotonNetwork.room.customProperties["lapNum"] != lapNum))
		{
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Add("lapNum", lapNum);
			ExitGames.Client.Photon.Hashtable propertiesToSet = hashtable;
			PhotonNetwork.room.SetCustomProperties(propertiesToSet);
		}
	}

	public int GetCurrentLap()
	{
		if (PhotonNetwork.room != null && PhotonNetwork.room.customProperties["lapNum"] != null)
		{
			return (int)PhotonNetwork.room.customProperties["lapNum"];
		}
		return -1;
	}

	public NetworkClient GetClient()
	{
		return GetComponent<NetworkClient>();
	}

	public NetworkServer GetServer()
	{
		return GetComponent<NetworkServer>();
	}

	public NetworkLeaderboards GetNetworkLeaderboards()
	{
		return GetComponent<NetworkLeaderboards>();
	}

	public NetworkChat GetChat()
	{
		return GetComponent<NetworkChat>();
	}

	public PhotonView GetPhotonView()
	{
		return m_photonView;
	}

	public NetworkIAP GetNetworkIAP()
	{
		return GetComponent<NetworkIAP>();
	}

	public string GetGoogleDisplayName()
	{
		return m_googleDisplayName;
	}

	public void SetReadyToAuthenticate()
	{
		m_readyToAuthenticate = true;
	}

	private void Awake()
	{
		Instance = this;
		GetComponent<PhotonView>().viewID = 100;
		PlayFabSettings.TitleId = "FA89";
		Core.Initialize();
		CheckEntitlement();
	}

	private void Start()
	{
		m_photonView = GetComponent<PhotonView>();
		PhotonNetwork.networkingPeer.DisconnectTimeout = 20000;
		PhotonNetwork.sendRate = 30;
		PhotonNetwork.sendRateOnSerialize = 10;
		PhotonNetwork.UseRpcMonoBehaviourCache = true;
	}

	private void CheckEntitlement()
	{
		Entitlements.IsUserEntitledToApplication().OnComplete(EntitlementCallback);
	}

	private void EntitlementCallback(Message msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Application.Quit();
		}
	}

	private void GetLoggedInUser()
	{
		Users.GetLoggedInUser().OnComplete(GetUserCallback);
	}

	private void GetUserCallback(Message<User> msg)
	{
		if (!msg.IsError)
		{
			User data = msg.Data;
			UnityEngine.Debug.Log("User: " + data.ID + " " + data.OculusID + " " + data.Presence + " " + data.InviteToken);
			m_googlePlayerID = data.ID.ToString();
			m_googleDisplayName = data.OculusID;
		}
	}

	private void LoginAndAuthenticate()
	{
		LoginWithCustomIDRequest loginWithCustomIDRequest = new LoginWithCustomIDRequest();
		loginWithCustomIDRequest.TitleId = PlayFabSettings.TitleId;
		loginWithCustomIDRequest.CustomId = m_googlePlayerID;
		loginWithCustomIDRequest.CreateAccount = true;
		PlayFabClientAPI.LoginWithCustomID(loginWithCustomIDRequest, OnLoginResult, OnPlayFabError);
	}

	public void OnRegister(RegisterPlayFabUserResult result)
	{
		UnityEngine.Debug.Log("registered");
	}

	public void OnPhotonAuthenticationSuccess(GetPhotonAuthenticationTokenResult result)
	{
		UnityEngine.Debug.Log("photon authenticated");
		s_networkDebug = "Adding auth params " + m_currentPlayerID;
		PhotonNetwork.AuthValues = new AuthenticationValues();
		PhotonNetwork.AuthValues.AuthType = CustomAuthenticationType.Custom;
		PhotonNetwork.AuthValues.AddAuthParameter("username", m_currentPlayerID);
		PhotonNetwork.AuthValues.AddAuthParameter("token", result.PhotonCustomAuthenticationToken);
		AuthenticatedAndReady = true;
		m_nameRegisterState = NameRegisterState.RetrieveName;
		Instance.GetUserData(Instance.PlayFabPlayerID);
	}

	public void OnLoginResult(LoginResult result)
	{
		m_currentPlayerID = result.PlayFabId;
		GetPhotonAuthenticationTokenRequest getPhotonAuthenticationTokenRequest = new GetPhotonAuthenticationTokenRequest();
		s_networkDebug = "Authenitcating with Photon";
		getPhotonAuthenticationTokenRequest.PhotonApplicationId = PhotonID_Google;
		PlayFabClientAPI.GetPhotonAuthenticationToken(getPhotonAuthenticationTokenRequest, OnPhotonAuthenticationSuccess, OnPlayFabError);
	}

	private void OnCustomAuthenticationFailed(string debugMessage)
	{
		UnityEngine.Debug.Log("Photon error: " + debugMessage);
		s_networkDebug = "Network Error " + m_currentPlayerID;
	}

	private void OnDisplayNameChange(UpdateUserTitleDisplayNameResult result)
	{
		m_nameRegisterState = NameRegisterState.None;
	}

	private void OnPlayFabErrorName(PlayFabError error)
	{
		UnityEngine.Debug.Log("Playfab error: " + error.Error);
		s_networkDebug = "Playfab Error " + error.Error;
		if (m_nameRegisterState == NameRegisterState.RetrieveName)
		{
			UpdateUserTitleDisplayNameRequest updateUserTitleDisplayNameRequest = new UpdateUserTitleDisplayNameRequest();
			updateUserTitleDisplayNameRequest.DisplayName = m_googleDisplayName + " ";
			PlayFabClientAPI.UpdateUserTitleDisplayName(updateUserTitleDisplayNameRequest, OnDisplayNameChange, OnPlayFabErrorName);
			m_nameRegisterState = NameRegisterState.NameAttempt2;
		}
		else
		{
			m_nameRegisterState = NameRegisterState.None;
		}
	}

	private void OnPlayFabError(PlayFabError error)
	{
		UnityEngine.Debug.Log("Playfab error: " + error.Error);
		s_networkDebug = "Playfab Error " + error.Error;
	}

	private void OnPlayFabErrorUserData(PlayFabError error)
	{
		UnityEngine.Debug.Log("Playfab error: " + error.Error);
		s_networkDebug = "Playfab Error " + error.Error;
	}

	private void Update()
	{
		switch (m_nameRegisterState)
		{
		}
		Request.RunCallbacks();
		if (m_readyToAuthenticate)
		{
			s_networkDebug = "Authenticating connection";
			m_readyToAuthenticate = false;
			GetLoggedInUser();
		}
		if (m_okToAuthenticate && m_googlePlayerID != string.Empty)
		{
			s_networkDebug = "Authenticated connection - ready to login";
			LoginAndAuthenticate();
			m_okToAuthenticate = false;
		}
		if (GameEntry.Instance == null || GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Frontend || m_waitForInitialConnection)
		{
			return;
		}
		if (m_serverConnection == ServerConnectionState.Connecting)
		{
			if (PhotonNetwork.connectedAndReady)
			{
				if (m_pingIndex == m_pingDataList.Count)
				{
					m_serverConnection = ServerConnectionState.FinishedConnecting;
				}
				else
				{
					ConnectToNextServer();
				}
			}
		}
		else if (m_serverConnection == ServerConnectionState.NotConnected)
		{
			m_disconnectionTimeout += Time.deltaTime;
			if (m_disconnectionTimeout > 5f)
			{
				m_serverConnection = ServerConnectionState.Connecting;
				ConnectToNextServer();
			}
		}
	}

	public void ConnectOnline()
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable.Add("deviceType", "GearVR");
		hashtable.Add("version", ProfileManager.ONLINE_FILTER_VERSION);
		ExitGames.Client.Photon.Hashtable expectedCustomRoomProperties = hashtable;
		PhotonNetwork.JoinRandomRoom(expectedCustomRoomProperties, (byte)MaxPlayersInRoom);
	}

	public void SetRoomInRace(bool openRoom)
	{
		if (PhotonNetwork.room != null && IsMasterPlayer() && (PhotonNetwork.room.customProperties["inRace"] == null || (bool)PhotonNetwork.room.customProperties["inRace"] != openRoom))
		{
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Add("inRace", openRoom);
			ExitGames.Client.Photon.Hashtable propertiesToSet = hashtable;
			PhotonNetwork.room.SetCustomProperties(propertiesToSet);
		}
	}

	public bool IsRoomInRace()
	{
		if (PhotonNetwork.room != null && PhotonNetwork.room.customProperties["inRace"] != null)
		{
			return (bool)PhotonNetwork.room.customProperties["inRace"];
		}
		return false;
	}

	private void CreateNewRoom()
	{
		string[] customRoomPropertiesForLobby = new string[2] { "deviceType", "version" };
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable.Add("deviceType", "GearVR");
		hashtable.Add("version", ProfileManager.ONLINE_FILTER_VERSION);
		ExitGames.Client.Photon.Hashtable customRoomProperties = hashtable;
		RoomOptions roomOptions = new RoomOptions();
		roomOptions.isVisible = true;
		roomOptions.isOpen = true;
		roomOptions.maxPlayers = (byte)MaxPlayersInRoom;
		roomOptions.customRoomProperties = customRoomProperties;
		roomOptions.customRoomPropertiesForLobby = customRoomPropertiesForLobby;
		PhotonNetwork.CreateRoom(string.Empty, roomOptions, null);
		m_playerNumInRoom = 0;
	}

	public bool IsPlayerLocal(int ID)
	{
		return PhotonNetwork.player.ID == ID;
	}

	private void OnConnectedToPhoton()
	{
		UnityEngine.Debug.Log("Connected to network");
		AuthenticatedAndReady = true;
	}

	private void ConnectToNextServer()
	{
		if (m_serverConnection != ServerConnectionState.Connecting)
		{
			return;
		}
		PingData pingData = m_pingDataList[m_pingIndex];
		pingData.ping = PhotonNetwork.GetPing();
		m_pingDataList[m_pingIndex] = pingData;
		if (!USEREGIONAL)
		{
			UnityEngine.Debug.Log("Connected to " + m_pingDataList[m_pingIndex].code.ToString() + "  Ping = " + m_pingDataList[m_pingIndex].ping);
		}
		m_pingIndex++;
		if (m_pingIndex < m_pingDataList.Count)
		{
			ConnectToServer();
			return;
		}
		m_serverConnection = ServerConnectionState.FinishedConnecting;
		m_pingDataList.Sort();
		if (m_lastRegion != m_pingDataList[0].code)
		{
			UnityEngine.Debug.Log("Best server = " + m_pingDataList[0].code.ToString() + "  connecting back to that one..");
			PhotonNetwork.Disconnect();
			PhotonNetwork.OverrideBestCloudServer(m_pingDataList[0].code);
			PhotonNetwork.ConnectToBestCloudServer("1.0");
		}
		else
		{
			UnityEngine.Debug.Log("Best server = " + m_pingDataList[0].code.ToString() + " - already connected");
		}
	}

	private void OnDisconnectedFromPhoton()
	{
		if ((m_connectedToServer && JoinedRoom() && (bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game) || ((bool)FEMManager.Instance && FEMManager.Instance.GetOnlineState() != 0))
		{
			CameraManager.Instance.SetNewTransformImmediate(null);
			QuitMenu.Instance.Kickout();
		}
		if (m_serverConnection == ServerConnectionState.Finished)
		{
			ResetConnection();
		}
	}

	private void ResetConnection()
	{
		if (m_connectedToServer && JoinedRoom() && (bool)GameEntry.Instance && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game && (bool)QuitMenu.Instance && !QuitMenu.Instance.InProgress())
		{
			QuitMenu.Instance.Kickout();
		}
		m_connectedToServer = false;
		m_pingIndex = 0;
		m_serverConnection = ServerConnectionState.NotConnected;
		m_lastRegion = CloudRegionCode.none;
		m_joinedRoom = false;
		m_playerNumInRoom = 0;
		m_disconnectionTimeout = 0f;
	}

	public void OnConnectedToMaster()
	{
		if (m_serverConnection == ServerConnectionState.FinishedConnecting)
		{
			m_serverConnection = ServerConnectionState.Finished;
			m_connectedToServer = true;
		}
	}

	public void OnPhotonRandomJoinFailed()
	{
		CreateNewRoom();
	}

	private void OnFailedToConnectToPhoton()
	{
		ResetConnection();
	}

	private void OnConnectionFail(DisconnectCause cause)
	{
	}

	private void OnCreatedRoom()
	{
	}

	private void OnLeftRoom()
	{
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend)
		{
			FEMManager.Instance.HumanPlayerLeft();
		}
		else if (Gameplay.Instance != null)
		{
			Gameplay.Instance.HumanPlayerLeft();
		}
	}

	public void OnJoinedRoom()
	{
		m_joinedRoom = true;
		m_playerNumInRoom = ((PhotonNetwork.room != null) ? (PhotonNetwork.room.playerCount - 1) : 0);
	}

	public int[] GetPlayerIDList()
	{
		int[] array = new int[PhotonNetwork.playerList.Length];
		int num = 1;
		array[0] = PhotonNetwork.player.ID;
		for (int i = 0; i < PhotonNetwork.playerList.Length; i++)
		{
			if (PhotonNetwork.playerList[i].ID != PhotonNetwork.player.ID)
			{
				array[num++] = PhotonNetwork.playerList[i].ID;
			}
		}
		return array;
	}

	public bool AllowedToSaveToCloud()
	{
		return !ConnectedToMaster() || m_allowedToCloudSave;
	}

	public void GetUserData(string playerPlayfabID)
	{
		if ((bool)Instance && Instance.AuthenticatedAndReady)
		{
			GetUserDataRequest getUserDataRequest = new GetUserDataRequest();
			getUserDataRequest.PlayFabId = playerPlayfabID;
			getUserDataRequest.Keys = new List<string>();
			getUserDataRequest.Keys.Add("OnlinePoints");
			getUserDataRequest.Keys.Add("UserName");
			getUserDataRequest.Keys.Add("VersionNo");
			PlayFabClientAPI.GetUserData(getUserDataRequest, OnUserDataUpdate, OnPlayFabErrorUserData);
		}
	}

	private void OnUserDataUpdate(GetUserDataResult result)
	{
		int num = 0;
		string text = string.Empty;
		string empty = string.Empty;
		if (!m_allowedToCloudSave)
		{
			m_allowedToCloudSave = true;
		}
		UserDataRecord value = null;
		result.Data.TryGetValue("OnlinePoints", out value);
		UserDataRecord value2 = null;
		result.Data.TryGetValue("UserName", out value2);
		UserDataRecord value3 = null;
		result.Data.TryGetValue("VersionNo", out value3);
		if (value != null)
		{
			num = int.Parse(value.Value);
		}
		if (value2 != null)
		{
			text = value2.Value;
		}
		if (value3 != null)
		{
			empty = value3.Value;
			if (ProfileManager.NETWORK_VERSION_NO != empty)
			{
				num = 0;
			}
		}
		if (value != null && value2 != null)
		{
			if (ResultsManager.Instance != null)
			{
				ResultsManager.Instance.AddOnlinePoints(text, num);
			}
			if (text == Instance.GetGoogleDisplayName())
			{
				ProfileManager.Instance.CurrentOnlinePoints = num;
			}
		}
		if (m_nameRegisterState == NameRegisterState.RetrieveName)
		{
			if (text != string.Empty)
			{
				m_googleDisplayName = text;
			}
			else
			{
				SetUserData(num);
			}
			UpdateUserTitleDisplayNameRequest updateUserTitleDisplayNameRequest = new UpdateUserTitleDisplayNameRequest();
			updateUserTitleDisplayNameRequest.DisplayName = m_googleDisplayName;
			PlayFabClientAPI.UpdateUserTitleDisplayName(updateUserTitleDisplayNameRequest, OnDisplayNameChange, OnPlayFabErrorName);
		}
	}

	public void SetUserData(int onlinePoints)
	{
		if ((bool)Instance && Instance.AuthenticatedAndReady)
		{
			UpdateUserDataRequest updateUserDataRequest = new UpdateUserDataRequest();
			updateUserDataRequest.Data = new Dictionary<string, string>
			{
				{
					"OnlinePoints",
					onlinePoints.ToString()
				},
				{
					"UserName",
					Instance.GetGoogleDisplayName()
				},
				{
					"VersionNo",
					ProfileManager.NETWORK_VERSION_NO
				}
			};
			UpdateUserDataRequest updateUserDataRequest2 = updateUserDataRequest;
			updateUserDataRequest2.Permission = UserDataPermission.Public;
			PlayFabClientAPI.UpdateUserData(updateUserDataRequest2, UserDataUpdated, OnPlayFabError);
		}
	}

	private void UserDataUpdated(UpdateUserDataResult result)
	{
	}

	private void OnReceivedRoomListUpdate()
	{
	}

	private void OnPhotonCreateRoomFailed()
	{
		UnityEngine.Debug.Log("A CreateRoom call failed, most likely the room name is already in use.");
		FEMManager.Instance.ResetStates();
	}

	private void OnPhotonJoinRoomFailed()
	{
		UnityEngine.Debug.Log("A JoinRoom call failed, most likely the room name does not exist or is full.");
		FEMManager.Instance.ResetStates();
	}

	private void OnReceivedRoomList()
	{
	}

	private void OnJoinedLobby()
	{
		if (m_serverConnection == ServerConnectionState.FinishedConnecting)
		{
			m_serverConnection = ServerConnectionState.Finished;
			m_connectedToServer = true;
		}
	}

	private void OnLeftLobby()
	{
	}

	private void OnPhotonPlayerConnected(PhotonPlayer player)
	{
	}

	private void OnPhotonPlayerDisconnected(PhotonPlayer player)
	{
		if (FEMManager.Instance.InHoldingState)
		{
			FEMManager.Instance.RemovePlayingPlayerInHolding(player.ID);
		}
		if ((bool)Gameplay.Instance)
		{
			Gameplay.Instance.RemoveNetworkPlayer(player.ID);
		}
	}

	private void OnMasterClientSwitched(PhotonPlayer newMaster)
	{
	}
}
public class NetworkNews : UnityEngine.MonoBehaviour
{
	private const int m_newsToLoad = 100;

	private List<TitleNewsItem> m_news;

	private bool m_loadedNews;

	private int m_currentNewsItem;

	private int m_maxNewsItems = 24;

	public static NetworkNews Instance;

	public bool GetLatestNewsItem(ref string title, ref string body)
	{
		if (m_news != null)
		{
			if (m_maxNewsItems > 0)
			{
				if (title != null)
				{
					title = m_news[m_currentNewsItem].Title;
				}
				if (body != null)
				{
					body = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(m_news[m_currentNewsItem].Body);
				}
				m_currentNewsItem = (m_currentNewsItem + 1) % m_maxNewsItems;
				return true;
			}
		}
		else if (m_maxNewsItems > 0)
		{
			if (m_currentNewsItem + 1 == 9)
			{
				m_currentNewsItem++;
			}
			string identifer = "STR_Tip" + (m_currentNewsItem + 1);
			body = GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(identifer);
			m_currentNewsItem = (m_currentNewsItem + 1) % m_maxNewsItems;
			return true;
		}
		return false;
	}

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	private void Update()
	{
		if (!m_loadedNews && (bool)NetworkLogin.Instance && NetworkLogin.Instance.AuthenticatedAndReady)
		{
			m_loadedNews = true;
			LoadNews();
		}
	}

	private void LoadNews()
	{
		m_currentNewsItem = UnityEngine.Random.Range(0, m_maxNewsItems - 1);
	}

	private void OnNewsResult(GetTitleNewsResult result)
	{
		m_news = result.News;
		m_maxNewsItems = m_news.Count;
		m_currentNewsItem = UnityEngine.Random.Range(0, m_maxNewsItems - 1);
	}

	private void OnPlayFabError(PlayFabError error)
	{
		UnityEngine.Debug.Log("Got an error: " + error.ErrorMessage);
	}
}
public class NetworkServer : UnityEngine.MonoBehaviour
{
	public class PlayerConnectionData
	{
		public int OnlinePlayer;
	}

	private enum FEMDetailsStatus
	{
		None,
		Sending,
		Sent
	}

	private enum ServerSendType
	{
		PlayerHeader,
		UpdateGameSetupData,
		OnlineEntry,
		ExtraFrontendData,
		CharacterController,
		Max
	}

	private float PacketLimitTimer = 0.1f;

	private float m_lastSentPacket;

	private float ExtraGameplayTimer = 1.5f;

	private float m_lastGameplayPacketSent;

	private double m_totalHumanRaceTime;

	private double m_totalAvgHumanRaceTime;

	private NetworkLogin m_networkLogin;

	private FEMDetailsStatus m_sendDetailsNow;

	[HideInInspector]
	public int[] m_serverGameplayEvents;

	private float m_startTime;

	private float m_killGameTime = 20f;

	private bool m_serverEventsPresent;

	private PlayerConnectionData[] m_playerConnection = new PlayerConnectionData[8];

	private bool[] m_serverSendData = new bool[5];

	public void ResetPlayerConnections()
	{
		m_sendDetailsNow = FEMDetailsStatus.None;
		m_totalHumanRaceTime = 0.0;
		m_totalAvgHumanRaceTime = 0.0;
		m_killGameTime = 20f;
		for (int i = 0; i < m_playerConnection.Length; i++)
		{
			m_playerConnection[i].OnlinePlayer = -1;
		}
	}

	public PlayerConnectionData GetPlayerConnectionByIndex(int index)
	{
		return m_playerConnection[index];
	}

	public void SetPlayerConnection(int onlinePlayer, int seatIndex)
	{
		m_playerConnection[seatIndex].OnlinePlayer = onlinePlayer;
	}

	public void RemovePlayerConnection(int onlinePlayer, int seatIndex)
	{
		m_playerConnection[seatIndex].OnlinePlayer = -1;
	}

	public void ForceNetworkUpdate()
	{
		m_lastSentPacket = 0f;
	}

	public void ResetFrontendDetails()
	{
		m_sendDetailsNow = FEMDetailsStatus.Sending;
	}

	public void SendFrontendDetails(bool send)
	{
		if (send)
		{
			m_sendDetailsNow = FEMDetailsStatus.Sending;
		}
		else
		{
			m_sendDetailsNow = FEMDetailsStatus.Sent;
		}
	}

	public void SetGameplayEvent(int playerToSet, NetworkClient.GameplayEvent ev)
	{
		m_serverGameplayEvents[(int)ev] |= 1 << playerToSet;
		m_serverEventsPresent = true;
	}

	public void SetStartTime(float startTime)
	{
		m_startTime = startTime;
		m_serverEventsPresent = true;
	}

	public float GetStartTime()
	{
		return m_startTime;
	}

	public void SetKillGameTime(float endTime)
	{
		m_killGameTime = endTime;
		m_serverEventsPresent = true;
	}

	public float GetKillGameTime()
	{
		return m_killGameTime;
	}

	public void StoreFinalTimes(double totalTime, double totalAvgTime)
	{
		if (Mathf.Approximately((float)m_totalHumanRaceTime, 0f))
		{
			m_totalHumanRaceTime = totalTime;
			m_totalAvgHumanRaceTime = totalAvgTime;
		}
	}

	public void GetFinalTimes(ref double totalTime, ref double totalAvgTime)
	{
		totalTime = m_totalHumanRaceTime;
		totalAvgTime = m_totalAvgHumanRaceTime;
	}

	public void SendChatString(float time, string profileName, string text)
	{
		m_networkLogin.GetPhotonView().RPC("ChatOutput", PhotonTargets.Others, time, profileName, text);
	}

	private void SetServerToSendOfType(ServerSendType type)
	{
		m_serverSendData[(int)type] = true;
	}

	private void UpdateServerSenders()
	{
		for (int i = 0; i < 5; i++)
		{
			if (m_serverSendData[i])
			{
				m_serverSendData[i] = false;
				switch ((ServerSendType)i)
				{
				case ServerSendType.PlayerHeader:
					UpdatePlayerHeader();
					break;
				case ServerSendType.UpdateGameSetupData:
					UpdateGameSetupData();
					break;
				case ServerSendType.OnlineEntry:
					UpdateOnlineEntry();
					break;
				case ServerSendType.ExtraFrontendData:
					UpdateExtraFrontendData();
					break;
				case ServerSendType.CharacterController:
					UpdateCharacterController();
					break;
				}
				break;
			}
		}
	}

	private void Awake()
	{
		m_networkLogin = GetComponent<NetworkLogin>();
		m_serverGameplayEvents = new int[14];
	}

	private void Start()
	{
		for (int i = 0; i < m_playerConnection.Length; i++)
		{
			m_playerConnection[i] = new PlayerConnectionData();
			m_playerConnection[i].OnlinePlayer = -1;
		}
	}

	private void Update()
	{
		if (!m_networkLogin.JoinedRoom())
		{
			return;
		}
		UpdateServerSenders();
		if (!(Time.time > m_lastSentPacket))
		{
			return;
		}
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend)
		{
			if (!FEMManager.Instance.InHoldingState)
			{
				if (m_sendDetailsNow == FEMDetailsStatus.Sending)
				{
					SetServerToSendOfType(ServerSendType.PlayerHeader);
				}
				else if (m_sendDetailsNow == FEMDetailsStatus.Sent && NetworkLogin.Instance.IsRoomInRace())
				{
					SetServerToSendOfType(ServerSendType.UpdateGameSetupData);
				}
				SetServerToSendOfType(ServerSendType.OnlineEntry);
				SetServerToSendOfType(ServerSendType.ExtraFrontendData);
			}
		}
		else if (m_sendDetailsNow != 0)
		{
			m_sendDetailsNow = FEMDetailsStatus.None;
		}
		if (!FEMManager.Instance.InHoldingState)
		{
			SetServerToSendOfType(ServerSendType.CharacterController);
		}
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			UpdateServerEvents();
		}
		m_lastSentPacket = Time.time + PacketLimitTimer;
	}

	private void UpdatePlayerHeader()
	{
		if ((bool)FEMManager.Instance)
		{
			Player frontendPlayer = FEMManager.Instance.GetFrontendPlayer(0);
			if ((bool)frontendPlayer)
			{
				NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
				ProfileManager.PlayerData playerData = ProfileManager.Instance.GetPlayerData(0);
				m_networkLogin.GetClient().GetCharacterListByIndex(frontendPlayer.SeatIndex, ref data);
				m_networkLogin.GetPhotonView().RPC("PlayerHeader", PhotonTargets.Others, frontendPlayer.OnlinePlayerIndex, playerData.m_colourIndex[0], playerData.m_colourIndex[1], playerData.m_colourIndex[2], playerData.m_colourIndex[3], playerData.m_colourIndex[4], playerData.m_colourIndex[5], playerData.m_colourIndex[6], playerData.m_customisationData.m_helmetProp, playerData.m_customisationData.m_visorProp, playerData.m_customisationData.m_dashProp, playerData.m_customisationData.m_dashStyle, ProfileManager.Instance.GetPlayerName(0, useSwearFilter: true), FEMManager.Instance.GetOnlineState() == FEMManager.FEMOnlineState.InRoom, GameSystem.Instance.NumWins, ProfileManager.Instance.CurrentOnlinePoints);
			}
		}
	}

	private void UpdateOnlineEntry()
	{
		if (!NetworkLogin.Instance.IsMasterPlayer() || !FEMManager.Instance)
		{
			return;
		}
		int[] array = null;
		Player[] frontendPlayerList = FEMManager.Instance.GetFrontendPlayerList();
		if (frontendPlayerList != null)
		{
			array = new int[frontendPlayerList.Length];
		}
		Player frontendPlayer = FEMManager.Instance.GetFrontendPlayer(0);
		if (!frontendPlayer)
		{
			return;
		}
		int[] array2 = new int[m_playerConnection.Length];
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i] = m_playerConnection[i].OnlinePlayer;
			if (frontendPlayerList == null)
			{
				continue;
			}
			for (int j = 0; j < frontendPlayerList.Length; j++)
			{
				if (frontendPlayerList[j] != null && frontendPlayerList[j].OnlinePlayerIndex == array2[i])
				{
					array[i] = frontendPlayerList[j].SeatIndex;
					break;
				}
			}
		}
		float currentHoldingTimer = FEMManager.Instance.GetCurrentHoldingTimer();
		m_networkLogin.GetPhotonView().RPC("OnlineEntry", PhotonTargets.Others, FEMManager.Instance.GetOnlineTrackIndex(), array2, array, currentHoldingTimer, GameSystem.Instance.LastSelectedOnlineTrack1, GameSystem.Instance.LastSelectedOnlineTrack2);
	}

	private void UpdateGameSetupData()
	{
		if (!NetworkLogin.Instance.IsMasterPlayer())
		{
			return;
		}
		Player[] frontendPlayerList = FEMManager.Instance.GetFrontendPlayerList();
		int[] array = new int[frontendPlayerList.Length];
		int[] array2 = new int[frontendPlayerList.Length];
		for (int i = 0; i < frontendPlayerList.Length; i++)
		{
			if ((bool)frontendPlayerList[i])
			{
				array[i] = frontendPlayerList[i].NewGridPosition;
				array2[i] = frontendPlayerList[i].OnlinePlayerIndex;
			}
			else
			{
				array[i] = -1;
				array2[i] = -1;
			}
		}
		m_networkLogin.GetPhotonView().RPC("GameSetupData", PhotonTargets.Others, array, array2);
	}

	private void UpdateCharacterController()
	{
		Player refPlayer = null;
		if (m_networkLogin == null || m_networkLogin.GetClient() == null)
		{
			return;
		}
		if (FEMManager.Instance != null && GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend)
		{
			refPlayer = FEMManager.Instance.GetFrontendPlayer(0);
		}
		else if ((bool)PlayerManager.Instance)
		{
			PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		}
		if (!FEMManager.Instance.InHoldingState && (bool)refPlayer)
		{
			NetworkClient.CharacterData data = default(NetworkClient.CharacterData);
			m_networkLogin.GetClient().GetCharacterListByIndex(refPlayer.SeatIndex, ref data);
			m_networkLogin.GetPhotonView().RPC("CharacterUpdate", PhotonTargets.Others, refPlayer.SeatIndex, GameSystem.Instance.WeaponTargetIndex, data.eventMask, m_totalHumanRaceTime, m_totalAvgHumanRaceTime);
			if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.KartPutOnTrack))
			{
				NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.KartPutOnTrack);
			}
			if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.FinishedWithBees))
			{
				NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.FinishedWithBees);
			}
			if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.NoExhaust))
			{
				NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.NoExhaust);
			}
			if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.BlackExhaust))
			{
				NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.BlackExhaust);
			}
			if (NetworkLogin.Instance.GetClient().GetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.ToxicExhaust))
			{
				NetworkLogin.Instance.GetClient().UnSetCharacterListEvent(refPlayer.SeatIndex, NetworkClient.EventMask.ToxicExhaust);
			}
		}
	}

	private void UpdateServerEvents()
	{
		Player refPlayer = null;
		if (m_networkLogin == null || m_networkLogin.GetClient() == null)
		{
			return;
		}
		if (FEMManager.Instance != null && GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Frontend)
		{
			refPlayer = FEMManager.Instance.GetFrontendPlayer(0);
		}
		else if ((bool)PlayerManager.Instance)
		{
			PlayerManager.Instance.GetHumanPlayer(ref refPlayer);
		}
		if (!FEMManager.Instance.InHoldingState && (bool)refPlayer && m_serverEventsPresent)
		{
			m_networkLogin.GetPhotonView().RPC("GameplayEvents", PhotonTargets.Others, m_serverGameplayEvents);
			for (int i = 0; i < 14; i++)
			{
				m_serverGameplayEvents[i] = 0;
			}
			m_startTime = 0f;
			m_serverEventsPresent = false;
		}
	}

	private void UpdateExtraFrontendData()
	{
		Player frontendPlayer = FEMManager.Instance.GetFrontendPlayer(0);
		if ((bool)frontendPlayer && frontendPlayer.SeatIndex >= 0)
		{
			m_networkLogin.GetPhotonView().RPC("ExtraFrontendData", PhotonTargets.Others, frontendPlayer.SeatIndex, (int)((!(FEMManager.Instance == null)) ? FEMManager.Instance.PlayerVotes[frontendPlayer.SeatIndex] : ((FEMManager.PlayerVote)(-1))), CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.rotation);
		}
	}
}
public class PlayServices : UnityEngine.MonoBehaviour
{
	private class AuthCallback : AndroidJavaProxy
	{
		internal AuthCallback()
			: base("com.google.vr.sdk.samples.avrpgs.PlayGamesFragment$AuthenticateCallback")
		{
		}

		private void onResult(AndroidJavaObject integerResult)
		{
			UnityEngine.Debug.Log("PlayGames:AuthCallback() calling integerResult.getStatusCode()");
			authStatusCode = integerResult.Call<int>("getStatusCode", new object[0]);
			UnityEngine.Debug.Log("PlayGames:AuthCallback() status code:" + authStatusCode);
			if (authStatusCode >= 0)
			{
				connected = true;
			}
		}
	}

	public AndroidJavaObject playGamesFragment;

	public static bool connected;

	private static int authStatusCode = -1;

	private AuthCallback myCallback;

	public static AndroidJavaObject GetActivity()
	{
		UnityEngine.Debug.Log("PlayGames:GetActivity()");
		using AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
		return androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("PlayGames:Awake()");
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.google.vr.sdk.samples.avrpgs.PlayGamesFragment");
		UnityEngine.Debug.Log("PlayGames:Awake() get PlayGamesFragment " + androidJavaClass);
		playGamesFragment = androidJavaClass.CallStatic<AndroidJavaObject>("getInstance", new object[1] { GetActivity() });
		UnityEngine.Debug.Log("PlayGames:Awake() getInstance " + playGamesFragment);
	}

	private void Start()
	{
		myCallback = new AuthCallback();
		UnityEngine.Debug.Log("PlayGames:Start() calling authenticate");
		AndroidJavaObject androidJavaObject = playGamesFragment.Call<AndroidJavaObject>("authenticate", new object[1] { myCallback });
	}
}
public class TestNetwork : UnityEngine.MonoBehaviour
{
	private enum LoginState
	{
		None,
		AuthenticateSteam,
		ConnectToPlayfab,
		ConnectedToPlayfab,
		ConnectToPhoton,
		JoinRoom,
		Finish
	}

	[SerializeField]
	private string PlayFabID;

	private string m_authTicket = string.Empty;

	private string m_currentPlayerID = string.Empty;

	private LoginState m_loginState;

	private void Start()
	{
	}

	private void Update()
	{
		switch (m_loginState)
		{
		case LoginState.None:
			m_loginState = LoginState.AuthenticateSteam;
			break;
		case LoginState.AuthenticateSteam:
			if (m_authTicket != string.Empty)
			{
				UnityEngine.Debug.Log("Logging in to Playfab");
				LoginWithSteamRequest loginWithSteamRequest = new LoginWithSteamRequest();
				loginWithSteamRequest.TitleId = PlayFabID;
				loginWithSteamRequest.SteamTicket = m_authTicket;
				loginWithSteamRequest.CreateAccount = true;
				PlayFabClientAPI.LoginWithSteam(loginWithSteamRequest, OnLoginResult, OnPlayFabError);
				m_loginState = LoginState.ConnectToPlayfab;
			}
			break;
		case LoginState.ConnectToPlayfab:
			break;
		case LoginState.ConnectedToPlayfab:
			UnityEngine.Debug.Log("Connected to playfab - ready for connection to Photon");
			PhotonNetwork.networkingPeer.DebugOut = DebugLevel.ALL;
			PhotonNetwork.logLevel = PhotonLogLevel.Full;
			PhotonHandler.BestRegionCodeInPreferences = CloudRegionCode.none;
			PhotonNetwork.autoJoinLobby = true;
			PhotonNetwork.OverrideBestCloudServer(CloudRegionCode.us);
			PhotonNetwork.ConnectToBestCloudServer("1.0");
			m_loginState = LoginState.ConnectToPhoton;
			break;
		case LoginState.ConnectToPhoton:
			break;
		case LoginState.JoinRoom:
		{
			UnityEngine.Debug.Log("Creating photon room");
			RoomOptions roomOptions = new RoomOptions();
			roomOptions.isVisible = true;
			roomOptions.isOpen = true;
			roomOptions.maxPlayers = 8;
			PhotonNetwork.CreateRoom(string.Empty, roomOptions, null);
			m_loginState = LoginState.Finish;
			break;
		}
		case LoginState.Finish:
			break;
		}
	}

	private void OnJoinedLobby()
	{
		UnityEngine.Debug.Log("Joined Photon Lobby");
		m_loginState = LoginState.JoinRoom;
	}

	public void OnJoinedRoom()
	{
		UnityEngine.Debug.Log("Joined Photon Room");
		UnityEngine.Debug.Log("Joined room");
	}

	private void OnPhotonCreateRoomFailed()
	{
		UnityEngine.Debug.Log("CreateRoom failed");
	}

	private void OnPhotonJoinRoomFailed()
	{
		UnityEngine.Debug.Log("OnPhotonJoinRoom Failed");
	}

	public void OnPhotonAuthenticationSuccess(GetPhotonAuthenticationTokenResult result)
	{
		UnityEngine.Debug.Log("photon authenticated");
		PhotonNetwork.AuthValues = new AuthenticationValues();
		PhotonNetwork.AuthValues.AuthType = CustomAuthenticationType.Custom;
		PhotonNetwork.AuthValues.AddAuthParameter("username", m_currentPlayerID);
		PhotonNetwork.AuthValues.AddAuthParameter("token", result.PhotonCustomAuthenticationToken);
		m_loginState = LoginState.ConnectedToPlayfab;
	}

	public void OnLoginResult(LoginResult result)
	{
		UnityEngine.Debug.Log("Playfab login successful - ready for photon");
		m_currentPlayerID = result.PlayFabId;
		GetPhotonAuthenticationTokenRequest getPhotonAuthenticationTokenRequest = new GetPhotonAuthenticationTokenRequest();
		getPhotonAuthenticationTokenRequest.PhotonApplicationId = PhotonNetwork.PhotonServerSettings.AppID;
		PlayFabClientAPI.GetPhotonAuthenticationToken(getPhotonAuthenticationTokenRequest, OnPhotonAuthenticationSuccess, OnPlayFabError);
	}

	private void OnCustomAuthenticationFailed(string debugMessage)
	{
		UnityEngine.Debug.Log("Photon error: " + debugMessage);
	}

	private void OnPlayFabError(PlayFabError error)
	{
		UnityEngine.Debug.Log("Playfab error: " + error.Error);
	}
}
public class NineSliceQuad : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject[] NineSlices = new GameObject[9];

	[SerializeField]
	private UnityEngine.Color BackgroundColour = UnityEngine.Color.white;

	private void Start()
	{
		UpdateColour();
	}

	private void UpdateColour()
	{
		for (int i = 0; i < NineSlices.Length; i++)
		{
			if (NineSlices[i] != null)
			{
				NineSlices[i].GetComponent<Renderer>().material.color = BackgroundColour;
			}
		}
	}
}
public class OcclusionZone : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private OcclusionZone[] VisibleZones;

	[SerializeField]
	public GameObject[] RootObjects;

	private List<MeshRenderer> m_objectList = new List<MeshRenderer>();

	private List<ParticleSystem> m_particleList = new List<ParticleSystem>();

	private List<CrowdMember> m_crowdList = new List<CrowdMember>();

	private List<GameObject> m_gameObjList = new List<GameObject>();

	private UnityEngine.Color m_boxCol = UnityEngine.Color.black;

	private OcclusionZone m_currentZone;

	private bool m_objectToRender = true;

	private int m_currentMeshIndex;

	private int m_currentParticleIndex;

	private int m_currentCrowdIndex;

	private int m_gameObjIndex;

	private const int NumMeshesToUpdatePerFrame = 15;

	private const int NumParticlesToUpdatePerFrame = 2;

	private const int NumCrowdToUpdatePerFrame = 4;

	private static bool m_overrideToGrey;

	public UnityEngine.Color BoxColour
	{
		get
		{
			return m_boxCol;
		}
		set
		{
			m_boxCol = value;
		}
	}

	public int CurrentZoneIndex { get; set; }

	public OcclusionZone[] GetVisibleZones()
	{
		return VisibleZones;
	}

	public bool ObjectsShouldRender()
	{
		return m_objectToRender;
	}

	public void SetObjectsToRender(bool toRender)
	{
		if (m_objectToRender != toRender)
		{
			m_currentMeshIndex = 0;
			m_currentParticleIndex = 0;
			m_currentCrowdIndex = 0;
			m_gameObjIndex = 0;
		}
		m_objectToRender = toRender;
	}

	private void Awake()
	{
		m_currentZone = GetComponent<OcclusionZone>();
	}

	private void Start()
	{
		for (int i = 0; i < RootObjects.Length; i++)
		{
			MeshRenderer[] componentsInChildren = RootObjects[i].GetComponentsInChildren<MeshRenderer>();
			MeshRenderer[] array = componentsInChildren;
			foreach (MeshRenderer item in array)
			{
				m_objectList.Add(item);
			}
			ParticleSystem[] componentsInChildren2 = RootObjects[i].GetComponentsInChildren<ParticleSystem>();
			ParticleSystem[] array2 = componentsInChildren2;
			foreach (ParticleSystem item2 in array2)
			{
				m_particleList.Add(item2);
			}
		}
	}

	private void Update()
	{
		UpdateHideShowObjects();
	}

	private void UpdateHideShowObjects()
	{
		if (m_currentMeshIndex < m_objectList.Count)
		{
			int currentMeshIndex = m_currentMeshIndex;
			int num = Mathf.Min(m_currentMeshIndex + 15, m_objectList.Count);
			for (int i = currentMeshIndex; i < num; i++)
			{
				m_objectList[i].enabled = m_objectToRender;
			}
			m_currentMeshIndex += 15;
		}
		if (m_currentParticleIndex < m_particleList.Count)
		{
			int currentParticleIndex = m_currentParticleIndex;
			int num2 = Mathf.Min(m_currentParticleIndex + 2, m_particleList.Count);
			for (int j = currentParticleIndex; j < num2; j++)
			{
				if (m_objectToRender)
				{
					m_particleList[j].Play();
				}
				else
				{
					m_particleList[j].Stop();
				}
			}
			m_currentParticleIndex += 2;
		}
		if (m_currentCrowdIndex < m_crowdList.Count)
		{
			int currentCrowdIndex = m_currentCrowdIndex;
			int num3 = Mathf.Min(m_currentCrowdIndex + 4, m_crowdList.Count);
			for (int k = currentCrowdIndex; k < num3; k++)
			{
				m_crowdList[k].gameObject.SetActive(m_objectToRender);
			}
			m_currentCrowdIndex += 4;
		}
		if (m_gameObjIndex < m_gameObjList.Count)
		{
			for (int l = m_gameObjIndex; l < m_gameObjList.Count; l++)
			{
				m_gameObjList[l].gameObject.SetActive(m_objectToRender);
			}
			m_gameObjIndex += m_gameObjList.Count;
		}
	}

	public void AddObjectToZone(GameObject obj)
	{
		m_gameObjList.Add(obj);
	}

	public void AddObjectToZone(string objName, string parentName, float x, float y, float z)
	{
		if (RootObjects.Length > 0)
		{
			return;
		}
		object[] array = UnityEngine.Object.FindObjectsOfType(typeof(MeshRenderer));
		for (int i = 0; i < array.Length; i++)
		{
			MeshRenderer meshRenderer = array[i] as MeshRenderer;
			if (meshRenderer.name == objName && (meshRenderer.transform.parent == null || meshRenderer.transform.parent.name == parentName) && OcclusionZoneManager.WithinTolerance(meshRenderer.transform.position.x, x) && OcclusionZoneManager.WithinTolerance(meshRenderer.transform.position.y, y) && OcclusionZoneManager.WithinTolerance(meshRenderer.transform.position.z, z))
			{
				m_objectList.Add(meshRenderer);
				return;
			}
		}
		array = UnityEngine.Object.FindObjectsOfType(typeof(ParticleSystem));
		for (int j = 0; j < array.Length; j++)
		{
			ParticleSystem particleSystem = array[j] as ParticleSystem;
			if (particleSystem.name == objName && (particleSystem.transform.parent == null || particleSystem.transform.parent.name == parentName) && OcclusionZoneManager.WithinTolerance(particleSystem.transform.position.x, x) && OcclusionZoneManager.WithinTolerance(particleSystem.transform.position.y, y) && OcclusionZoneManager.WithinTolerance(particleSystem.transform.position.z, z))
			{
				particleSystem.playOnAwake = false;
				m_particleList.Add(particleSystem);
				return;
			}
		}
		array = UnityEngine.Object.FindObjectsOfType(typeof(CrowdMember));
		for (int k = 0; k < array.Length; k++)
		{
			CrowdMember crowdMember = array[k] as CrowdMember;
			if (crowdMember.name == objName && (crowdMember.transform.parent == null || crowdMember.transform.parent.name == parentName) && OcclusionZoneManager.WithinTolerance(crowdMember.transform.position.x, x) && OcclusionZoneManager.WithinTolerance(crowdMember.transform.position.y, y) && OcclusionZoneManager.WithinTolerance(crowdMember.transform.position.z, z))
			{
				m_crowdList.Add(crowdMember);
				break;
			}
		}
	}

	private void DrawBoxes()
	{
		OcclusionZone occlusionZone = base.gameObject.GetComponent<OcclusionZone>();
		OcclusionZone occlusionZone2 = null;
		if (!OcclusionZoneManager.ShowAllZones)
		{
			do
			{
				occlusionZone2 = null;
				if (occlusionZone.transform.parent != null)
				{
					occlusionZone2 = occlusionZone.transform.parent.GetComponent<OcclusionZone>();
				}
				if (occlusionZone2 != null)
				{
					occlusionZone = occlusionZone2;
				}
			}
			while (occlusionZone2 != null);
			OcclusionZone[] componentsInChildren = occlusionZone.GetComponentsInChildren<OcclusionZone>();
			foreach (OcclusionZone occlusionZone3 in componentsInChildren)
			{
				occlusionZone3.DrawBox(occlusionZone);
			}
		}
		else
		{
			occlusionZone.DrawBox(occlusionZone);
		}
	}

	private void DrawBox(OcclusionZone parentZone)
	{
		if (parentZone.BoxColour == UnityEngine.Color.black)
		{
			parentZone.BoxColour = new UnityEngine.Color(UnityEngine.Random.Range(10f, 255f) / 255f, UnityEngine.Random.Range(10f, 255f) / 255f, UnityEngine.Random.Range(10f, 255f) / 255f, 0.47058824f);
		}
		Gizmos.color = ((!m_overrideToGrey) ? parentZone.BoxColour : new UnityEngine.Color(0.6f, 0.6f, 0.6f, 0.4f));
		Gizmos.DrawCube(base.transform.position, base.transform.localScale);
	}

	private void OnDrawGizmos()
	{
		if (OcclusionZoneManager.ShowAllZones)
		{
			DrawBoxes();
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!OcclusionZoneManager.ShowAllZones)
		{
			DrawBoxes();
		}
		m_overrideToGrey = true;
		OcclusionZone[] visibleZones = VisibleZones;
		foreach (OcclusionZone occlusionZone in visibleZones)
		{
			if ((bool)occlusionZone)
			{
				occlusionZone.DrawBoxes();
			}
		}
		m_overrideToGrey = false;
	}
}
public class OcclusionZoneManager : UnityEngine.MonoBehaviour
{
	public class ZoneData : IComparable
	{
		public string zoneName;

		public int totalTris;

		public int totalVerts;

		public int CompareTo(object obj)
		{
			ZoneData zoneData = obj as ZoneData;
			return totalTris.CompareTo(zoneData.totalTris);
		}
	}

	[HideInInspector]
	public static bool ShowAllZones;

	[HideInInspector]
	public int FirstTimeThrough;

	private OcclusionZone[] m_zones;

	private Camera m_cullCam;

	private Bounds m_bounds = default(Bounds);

	private List<Player> m_playerList;

	[SerializeField]
	private GameObject ZoneRoot;

	public static bool WithinTolerance(float x, float y)
	{
		return Mathf.Abs(x - y) < 0.001f;
	}

	private void OnDestroy()
	{
		StopCoroutine(UpdateZones());
	}

	private void Start()
	{
		if (!ZoneRoot)
		{
			UnityEngine.Debug.LogError("NO ZONE ROOT FOUND - ADD IT TO THE ZONE MANAGER IN GAMEPLAY");
		}
		else
		{
			m_zones = new OcclusionZone[ZoneRoot.transform.childCount];
			for (int i = 0; i < ZoneRoot.transform.childCount; i++)
			{
				m_zones[i] = ZoneRoot.transform.GetChild(i).GetComponent<OcclusionZone>();
				m_zones[i].CurrentZoneIndex = i;
			}
		}
		m_playerList = PlayerManager.Instance.GetPlayerList();
		m_cullCam = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0];
	}

	private void Update()
	{
		if ((bool)ReplaySystem.Instance && ReplaySystem.Instance.GetTarget() != null)
		{
			m_cullCam = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.SwitchAbleCameras).m_cameraArray[0];
		}
		else
		{
			m_cullCam = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0];
		}
	}

	private IEnumerator UpdateZones()
	{
		while (true)
		{
			int[] visibleZoneMask = new int[2];
			int zonesToCheck = 0;
			if (m_zones == null || m_zones.Length == 0)
			{
				yield return null;
			}
			while (zonesToCheck < m_zones.Length)
			{
				OcclusionZone currentZone = m_zones[zonesToCheck];
				if (currentZone.GetVisibleZones().Length == 0)
				{
					zonesToCheck++;
					continue;
				}
				m_bounds.center = currentZone.transform.position;
				m_bounds.size = currentZone.transform.localScale;
				if (m_bounds.Contains(m_cullCam.transform.position))
				{
					int num = (int)((float)zonesToCheck / 32f);
					visibleZoneMask[num] |= 1 << zonesToCheck;
					OcclusionZone[] visibleZones = m_zones[zonesToCheck].GetVisibleZones();
					for (int i = 0; i < visibleZones.Length; i++)
					{
						if ((bool)visibleZones[i])
						{
							num = (int)((float)visibleZones[i].CurrentZoneIndex / 32f);
							visibleZoneMask[num] |= 1 << visibleZones[i].CurrentZoneIndex;
						}
					}
				}
				for (int j = 1; j < m_playerList.Count; j++)
				{
					if ((bool)m_playerList[j] && m_playerList[j].CurrentOcclusionZone != zonesToCheck && m_bounds.Contains(m_playerList[j].transform.position))
					{
						m_playerList[j].CurrentOcclusionZone = zonesToCheck;
					}
				}
				zonesToCheck++;
				if (zonesToCheck % 4 == 0)
				{
					yield return null;
				}
			}
			for (int k = 0; k < m_zones.Length; k++)
			{
				int num2 = (int)((float)k / 32f);
				if ((visibleZoneMask[num2] & (1 << k)) != 0)
				{
					if (!m_zones[k].ObjectsShouldRender())
					{
						m_zones[k].SetObjectsToRender(toRender: true);
					}
					if (!Gameplay.Instance || !Gameplay.Instance.RaceStarted())
					{
						continue;
					}
					for (int l = 1; l < m_playerList.Count; l++)
					{
						if ((bool)m_playerList[l] && m_playerList[l].CurrentOcclusionZone == k)
						{
							bool enable = !m_playerList[l].TurnOffKartOnTrackFinish;
							m_playerList[l].EnableRendering(enable);
						}
					}
					continue;
				}
				if (m_zones[k].ObjectsShouldRender())
				{
					m_zones[k].SetObjectsToRender(toRender: false);
				}
				if (!Gameplay.Instance || !Gameplay.Instance.RaceStarted())
				{
					continue;
				}
				for (int m = 1; m < m_playerList.Count; m++)
				{
					if ((bool)m_playerList[m] && m_playerList[m].CurrentOcclusionZone == k)
					{
						m_playerList[m].EnableRendering(enable: false);
					}
				}
			}
			if (FirstTimeThrough < 2)
			{
				FirstTimeThrough++;
			}
			yield return null;
		}
	}

	public static void ExportZones(string trackName, ref List<ZoneData> zoneData)
	{
		Directory.CreateDirectory("Assets\\Game\\Resources\\Occlusion");
		string path = "Assets\\Game\\Resources\\Occlusion\\OcclusionZone_" + trackName + ".xml";
		FileStream fileStream = new FileStream(path, FileMode.Create);
		XmlTextWriter xmlTextWriter = new XmlTextWriter(fileStream, Encoding.UTF8);
		xmlTextWriter.Formatting = System.Xml.Formatting.Indented;
		xmlTextWriter.Indentation = 4;
		xmlTextWriter.WriteStartDocument();
		xmlTextWriter.WriteStartElement("ZoneList");
		object[] array = UnityEngine.Object.FindObjectsOfType(typeof(OcclusionZone));
		object[] array2 = array;
		foreach (object obj in array2)
		{
			OcclusionZone occlusionZone = (OcclusionZone)obj;
			xmlTextWriter.WriteStartElement("Zone");
			xmlTextWriter.WriteAttributeString("Name", occlusionZone.name);
			xmlTextWriter.WriteAttributeString("PosX", occlusionZone.transform.position.x.ToString());
			xmlTextWriter.WriteAttributeString("PosY", occlusionZone.transform.position.y.ToString());
			xmlTextWriter.WriteAttributeString("PosZ", occlusionZone.transform.position.z.ToString());
			Bounds bounds = default(Bounds);
			bounds.center = occlusionZone.transform.position;
			bounds.size = occlusionZone.transform.localScale;
			ZoneData zoneData2 = new ZoneData();
			zoneData2.zoneName = occlusionZone.name;
			zoneData2.totalTris = 0;
			zoneData2.totalVerts = 0;
			GameObject[] array3 = UnityEngine.Object.FindObjectsOfType<GameObject>();
			GameObject[] array4 = array3;
			foreach (GameObject gameObject in array4)
			{
				if ((!(gameObject.GetComponent<MeshRenderer>() == null) || !(gameObject.GetComponent<ParticleSystem>() == null) || !(gameObject.GetComponent<CrowdMember>() == null)) && (gameObject.gameObject.layer == 14 || gameObject.gameObject.layer == 25 || gameObject.gameObject.layer == 10 || gameObject.gameObject.layer == 23) && bounds.Contains(gameObject.transform.position))
				{
					xmlTextWriter.WriteStartElement("Object");
					xmlTextWriter.WriteAttributeString("Name", gameObject.name);
					xmlTextWriter.WriteAttributeString("Parent", (!gameObject.transform.parent) ? string.Empty : gameObject.transform.parent.name);
					xmlTextWriter.WriteAttributeString("PosX", gameObject.transform.position.x.ToString());
					xmlTextWriter.WriteAttributeString("PosY", gameObject.transform.position.y.ToString());
					xmlTextWriter.WriteAttributeString("PosZ", gameObject.transform.position.z.ToString());
					xmlTextWriter.WriteEndElement();
					MeshFilter component = gameObject.GetComponent<MeshFilter>();
					if ((bool)component && (bool)component.sharedMesh)
					{
						zoneData2.totalTris += component.sharedMesh.triangles.Length;
						zoneData2.totalVerts += component.sharedMesh.vertexCount;
					}
				}
			}
			zoneData.Add(zoneData2);
			xmlTextWriter.WriteEndElement();
		}
		zoneData.Sort();
		xmlTextWriter.WriteEndElement();
		xmlTextWriter.Flush();
		fileStream.Close();
	}

	public void LoadOcclusionZones(string sceneName)
	{
		StartCoroutine(UpdateZones());
	}
}
public class OutOfBounds : UnityEngine.MonoBehaviour
{
	private bool m_outOfBounds = true;

	private bool m_delayShowingScreen = true;

	private const float outOfBoundsPos = 0.6f;

	private const float outOfBoundsPosTolerance = 0.4f;

	public bool IsOutOfBounds()
	{
		return m_outOfBounds;
	}

	private void Start()
	{
		m_delayShowingScreen = true;
	}

	private void CheckForOutOfBounds()
	{
		if (!m_outOfBounds)
		{
			float magnitude = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.transform.localPosition.magnitude;
			if (magnitude > 0.6f)
			{
				GameSystem.Instance.RecentreHeadset();
				m_outOfBounds = true;
			}
		}
		else
		{
			float magnitude2 = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].transform.transform.localPosition.magnitude;
			if (magnitude2 < 0.20000002f)
			{
				m_outOfBounds = false;
			}
		}
	}

	private void Update()
	{
		if (m_delayShowingScreen)
		{
			if (((bool)GameEntry.Instance && !Gameplay.Instance && !FEMManager.Instance) || !FadeManager.Instance.FinishedFading())
			{
				return;
			}
			m_delayShowingScreen = false;
		}
		CheckForOutOfBounds();
	}
}
public class LogThread
{
	public class Frame
	{
	}

	private Queue<Frame> m_frames = new Queue<Frame>();

	private Thread m_thread;

	private string m_rootDir;

	private int m_msSleepTime;

	private string m_tag;

	private string m_type;

	public Exception Exception { get; private set; }

	public LogThread(string tag, int msSleep)
	{
		m_tag = tag;
		m_msSleepTime = msSleep;
		m_type = "VRKarts";
		m_rootDir = UnityEngine.Application.persistentDataPath;
		m_thread = new Thread(ThreadFunc);
		m_thread.Start();
	}

	public void Shutdown()
	{
		if (m_thread != null)
		{
			m_thread.Abort();
			m_thread.Join();
		}
	}

	public void CommitFrame(Frame frame)
	{
		lock (m_frames)
		{
			m_frames.Enqueue(frame);
		}
	}

	private void ThreadFunc()
	{
		try
		{
			DateTime now = DateTime.Now;
			string path = string.Format("{0}/{2}-{3}-{1}.csv", m_rootDir, now.ToString("yyyMMddHHmmss"), m_tag, m_type);
			while (true)
			{
				FileStream fileStream = new FileStream(path, FileMode.Append, FileAccess.Write, FileShare.Write);
				while (m_frames.Count > 0)
				{
					Frame frame;
					lock (m_frames)
					{
						frame = m_frames.Dequeue();
					}
					string s = frame.ToString();
					fileStream.Write(Encoding.ASCII.GetBytes(s), 0, Encoding.ASCII.GetByteCount(s));
				}
				fileStream.Close();
				Thread.Sleep(m_msSleepTime);
			}
		}
		catch (Exception exception)
		{
			Exception = exception;
		}
	}
}
public class PerformanceLog : UnityEngine.MonoBehaviour
{
	public class Frame : LogThread.Frame
	{
		private enum FieldLabels
		{
			Time,
			DeltaTime,
			PositionX,
			PositionY,
			PositionZ,
			ForwardsX,
			ForwardsY,
			ForwardsZ,
			FarClip,
			FOV,
			MAX
		}

		public float Time;

		public float DeltaTime;

		public Vector3 Position = default(Vector3);

		public Vector3 Forwards = default(Vector3);

		public float FarClip;

		public float FOV;

		public static Frame Parse(string csv)
		{
			string[] array = csv.Split(',');
			if (array.Length < 10)
			{
				return null;
			}
			Frame frame = new Frame();
			if (!string.IsNullOrEmpty(array[0]))
			{
				frame.Time = float.Parse(array[0]);
			}
			if (!string.IsNullOrEmpty(array[1]))
			{
				frame.DeltaTime = float.Parse(array[1]);
			}
			if (!string.IsNullOrEmpty(array[2]))
			{
				frame.Position.x = float.Parse(array[2]);
			}
			if (!string.IsNullOrEmpty(array[3]))
			{
				frame.Position.y = float.Parse(array[3]);
			}
			if (!string.IsNullOrEmpty(array[4]))
			{
				frame.Position.z = float.Parse(array[4]);
			}
			if (!string.IsNullOrEmpty(array[5]))
			{
				frame.Forwards.x = float.Parse(array[5]);
			}
			if (!string.IsNullOrEmpty(array[6]))
			{
				frame.Forwards.y = float.Parse(array[6]);
			}
			if (!string.IsNullOrEmpty(array[7]))
			{
				frame.Forwards.z = float.Parse(array[7]);
			}
			if (!string.IsNullOrEmpty(array[8]))
			{
				frame.FarClip = float.Parse(array[8]);
			}
			if (!string.IsNullOrEmpty(array[9]))
			{
				frame.FOV = float.Parse(array[9]);
			}
			return frame;
		}

		public override string ToString()
		{
			string empty = string.Empty;
			empty += $"{Time},";
			empty += $"{DeltaTime},";
			empty += $"{Position.x},{Position.y},{Position.z},";
			empty += $"{Forwards.x},{Forwards.y},{Forwards.z},";
			empty += $"{FarClip},";
			return empty + $"{FOV}\n";
		}
	}

	[Tooltip("Amount of ms to sleep after processing a batch of frames")]
	[SerializeField]
	private int m_msSleepTime = 500;

	private LogThread m_thread;

	private float m_t;

	private void Start()
	{
		m_thread = new LogThread("perf", m_msSleepTime);
	}

	private void OnDestroy()
	{
		if (m_thread != null)
		{
			m_thread.Shutdown();
		}
	}

	private void Awake()
	{
		m_t = Time.realtimeSinceStartup;
	}

	private void Update()
	{
		if (m_thread.Exception != null)
		{
			throw m_thread.Exception;
		}
		Camera main = Camera.main;
		if ((bool)main)
		{
			Frame frame = new Frame();
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float deltaTime = realtimeSinceStartup - m_t;
			m_t = realtimeSinceStartup;
			frame.Time = Time.realtimeSinceStartup;
			frame.DeltaTime = deltaTime;
			frame.Position = main.transform.position;
			frame.Forwards = main.transform.forward;
			frame.FarClip = main.farClipPlane;
			frame.FOV = main.fieldOfView;
			m_thread.CommitFrame(frame);
		}
	}
}
public class PlayerEntitlement : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject MenuObject;

	private bool m_userEntitled = true;

	private bool m_delayShowingScreen = true;

	private FollowPlayerMenu m_followPlayerMenu;

	public bool UserEntitled()
	{
		return m_userEntitled;
	}

	private void Start()
	{
		m_followPlayerMenu = GetComponent<FollowPlayerMenu>();
		m_delayShowingScreen = true;
		MenuObject.SetActive(value: false);
	}

	private void Update()
	{
		if (GameEntry.Instance == null && MenuObject.gameObject.activeInHierarchy)
		{
			MenuObject.SetActive(value: false);
		}
		if (m_delayShowingScreen)
		{
			if (((bool)GameEntry.Instance && !Gameplay.Instance && !FEMManager.Instance) || !FadeManager.Instance.FinishedFading())
			{
				return;
			}
			m_delayShowingScreen = false;
		}
		m_userEntitled = false;
		if (m_userEntitled)
		{
			if (MenuObject.gameObject.activeInHierarchy)
			{
				MenuObject.SetActive(value: false);
			}
		}
		else if (!MenuObject.gameObject.activeInHierarchy)
		{
			m_followPlayerMenu.ForceUpdatePosition();
			MenuObject.SetActive(value: true);
			MenuObject.transform.localPosition = new Vector3(0f, 0f, 0.8f);
			MenuObject.transform.localRotation = Quaternion.identity;
		}
	}
}
public class RandomAudioPlayer : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float MinRandomTime;

	[SerializeField]
	private float MaxRandomTime;

	[SerializeField]
	private float MinRandomPitch;

	[SerializeField]
	private float MaxRandomPitch;

	private float m_timeToPlay;

	private void Start()
	{
		GetComponent<AudioSource>().Play();
	}

	private void SetTimeToPlay()
	{
		m_timeToPlay = Time.time + UnityEngine.Random.Range(MinRandomTime, MaxRandomTime);
	}

	private void Update()
	{
		if (GameEntry.Instance != null && GameEntry.Instance.GetCurrentState() != GameEntry.GameState.Game)
		{
			GetComponent<AudioSource>().volume = 0f;
			return;
		}
		if (m_timeToPlay == 0f && !GetComponent<AudioSource>().isPlaying)
		{
			SetTimeToPlay();
		}
		if (m_timeToPlay > 0f && Time.time > m_timeToPlay)
		{
			m_timeToPlay = 0f;
			GetComponent<AudioSource>().pitch = MinRandomPitch + UnityEngine.Random.Range(0f, MaxRandomPitch - MinRandomPitch);
			GetComponent<AudioSource>().Play();
		}
	}
}
public class ReplaySystem : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private ReplayCamera[] CameraPoints;

	[SerializeField]
	public float PlayerCarSpeedForReplay = 200f;

	public static ReplaySystem Instance;

	private GameObject Target;

	private void Awake()
	{
		if (!Instance)
		{
			Instance = this;
		}
	}

	public GameObject GetTarget()
	{
		return Target;
	}

	public void SetTarget(GameObject targetObj)
	{
		Target = targetObj;
	}

	public void DebugEnableReplaySystem()
	{
		GameCamera cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.SwitchAbleCameras);
		cameraByType.GetComponent<Camera>().targetTexture = null;
		CameraManager.Instance.UpdateCameraSelection(CameraManager.CameraType.SwitchAbleCameras);
	}

	private void Start()
	{
		for (int i = 0; i < CameraPoints.Length; i++)
		{
			CameraPoints[i].enabled = false;
			CameraPoints[i].CacheDetectionPosition();
		}
		base.enabled = false;
	}

	private void Update()
	{
		GameCamera cameraByType = CameraManager.Instance.GetCameraByType(CameraManager.CameraType.SwitchAbleCameras);
		if (!(cameraByType != null))
		{
			return;
		}
		for (int i = 0; i < CameraPoints.Length; i++)
		{
			if ((Target.transform.position - CameraPoints[i].GetDetectionPosition()).sqrMagnitude < CameraPoints[i].DetectionRange * CameraPoints[i].DetectionRange)
			{
				CameraPoints[i].SetReplayCamera(cameraByType.GetComponent<Camera>(), Target);
			}
			else
			{
				CameraPoints[i].enabled = false;
			}
		}
	}
}
public class Rotator : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float RotateSpeed = 10f;

	[SerializeField]
	private Vector3 Axis = new Vector3(0f, 1f, 0f);

	private float m_angle;

	private void Update()
	{
		m_angle += RotateSpeed * GameTime.Instance.DeltaTime();
		m_angle %= 360f;
		Quaternion b = Quaternion.AngleAxis(m_angle, Axis);
		base.transform.localRotation = Quaternion.Slerp(base.transform.localRotation, b, 1f * GameTime.Instance.DeltaTime());
	}
}
public class Spawn : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private float RespawnTime = 2f;

	private float m_timeRemoved;

	private Renderer[] m_rendererArray;

	private void Start()
	{
		m_rendererArray = base.gameObject.GetComponentsInChildren<Renderer>();
	}

	private void Update()
	{
		if (m_timeRemoved > 0f && Time.time > m_timeRemoved + RespawnTime)
		{
			m_timeRemoved = 0f;
			EnableObject(enable: true);
		}
	}

	public void RemoveFromGame()
	{
		EnableObject(enable: false);
		m_timeRemoved = Time.time;
	}

	public bool IsEnabled()
	{
		return m_timeRemoved == 0f;
	}

	private void EnableObject(bool enable)
	{
		for (int i = 0; i < m_rendererArray.Length; i++)
		{
			m_rendererArray[i].gameObject.SetActive(enable);
		}
	}
}
public class SplitLane : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private GameObject StartKnot;

	[SerializeField]
	private GameObject EndKnot;

	[SerializeField]
	private GameObject SplitBoxRoot;

	[SerializeField]
	public bool AlternativeTrackSection;

	[Range(0f, 100f)]
	public float UseLeftLane;

	[Range(0f, 100f)]
	public float UseMiddleLane;

	[Range(0f, 100f)]
	public float UseRightLane;

	[HideInInspector]
	public List<Transform> Waypoints = new List<Transform>();

	private int numPoints;

	private Vector3[] points;

	private float[] distances;

	private int p0n;

	private int p1n;

	private int p2n;

	private int p3n;

	private float i;

	private Vector3 P0;

	private Vector3 P1;

	private Vector3 P2;

	private Vector3 P3;

	private Vector3 targetPosition;

	private float progressDistance;

	private Vector3 lastPosition;

	private float speed;

	public float Length { get; private set; }

	private void Start()
	{
		Locator[] componentsInChildren = GetComponentsInChildren<Locator>();
		if ((bool)SplitBoxRoot)
		{
			SplitLaneZone[] componentsInChildren2 = SplitBoxRoot.GetComponentsInChildren<SplitLaneZone>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				SplitLane lane = this;
				componentsInChildren2[i].SetSplitLane(ref lane);
			}
		}
		Waypoints.Clear();
		if ((bool)StartKnot)
		{
			Waypoints.Add(StartKnot.transform);
		}
		else
		{
			Waypoints.Add(componentsInChildren[0].transform);
		}
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			Waypoints.Add(componentsInChildren[j].transform);
		}
		if ((bool)EndKnot)
		{
			Waypoints.Add(EndKnot.transform);
		}
		else
		{
			Waypoints.Add(componentsInChildren[componentsInChildren.Length - 1].transform);
		}
		numPoints = Waypoints.Count;
		CachePositionsAndDistances();
		Length = distances[distances.Length - 1];
	}

	private void OnDrawGizmos()
	{
		DrawGizmos();
	}

	private void CachePositionsAndDistances()
	{
		points = new Vector3[Waypoints.Count];
		distances = new float[Waypoints.Count];
		float num = 0f;
		for (int i = 0; i < points.Length; i++)
		{
			int value = i;
			int value2 = i + 1;
			value = Mathf.Clamp(value, 0, Waypoints.Count - 1);
			value2 = Mathf.Clamp(value2, 0, Waypoints.Count - 1);
			Vector3 position = Waypoints[value].transform.position;
			Vector3 position2 = Waypoints[value2].transform.position;
			Vector3 vector = position;
			Vector3 vector2 = position2;
			ref Vector3 reference = ref points[i];
			reference = Waypoints[value].transform.position;
			distances[i] = num;
			num += (vector - vector2).magnitude;
		}
	}

	public GameObject GetEndKnot()
	{
		return EndKnot;
	}

	public bool HitEndOfSpline(float dist)
	{
		return dist >= Length;
	}

	public VRWaypointCircuit.RoutePoint GetRoutePoint(float dist)
	{
		Vector3 routePosition = GetRoutePosition(dist);
		Vector3 routePosition2 = GetRoutePosition(dist + 0.1f);
		return new VRWaypointCircuit.RoutePoint(routePosition, (routePosition2 - routePosition).normalized);
	}

	public Vector3 GetRoutePosition(float dist)
	{
		int num = 0;
		if (distances == null || numPoints == 0)
		{
			return base.transform.position;
		}
		if (Length == 0f)
		{
			Length = distances[distances.Length - 1];
		}
		while (distances[num] < dist)
		{
			num++;
			if (num > distances.Length - 1)
			{
				num = distances.Length - 1;
				break;
			}
		}
		p1n = (num - 1 + numPoints) % numPoints;
		p2n = num;
		i = Mathf.InverseLerp(distances[p1n], distances[p2n], dist);
		p0n = (num - 2 + numPoints) % numPoints;
		p3n = (num + 1) % numPoints;
		p2n %= numPoints;
		P0 = points[p0n];
		P1 = points[p1n];
		P2 = points[p2n];
		P3 = points[p3n];
		return CatmullRom(P0, P1, P2, P3, i);
	}

	private Vector3 CatmullRom(Vector3 _P0, Vector3 _P1, Vector3 _P2, Vector3 _P3, float _i)
	{
		return 0.5f * (2f * _P1 + (-_P0 + _P2) * _i + (2f * _P0 - 5f * _P1 + 4f * _P2 - _P3) * _i * _i + (-_P0 + 3f * _P1 - 3f * _P2 + _P3) * _i * _i * _i);
	}

	public Vector3 GetClosestPositionOnTrack(Vector3 position, ref Vector3 direction)
	{
		float normalisedDistance = 0f;
		int num = -1;
		int num2 = -1;
		float num3 = float.PositiveInfinity;
		for (int i = 0; i < Waypoints.Count; i++)
		{
			float sqrMagnitude = (Waypoints[i].position - position).sqrMagnitude;
			if (sqrMagnitude < num3)
			{
				num3 = sqrMagnitude;
				num = i;
			}
		}
		Vector3 lhs = position - Waypoints[num].position;
		lhs.Normalize();
		Vector3 forward = Waypoints[num].forward;
		if (Vector3.Dot(lhs, forward) < 0f)
		{
			num2 = num;
			num--;
			if (num < 0)
			{
				num = Waypoints.Count - 1;
			}
		}
		else
		{
			num2 = num + 1;
			num2 %= Waypoints.Count - 1;
		}
		direction = (Waypoints[num2].position - Waypoints[num].position).normalized;
		return GetClosestPointOnLineSegment(Waypoints[num].position, Waypoints[num2].position, position, ref normalisedDistance);
	}

	public float GetClosestPointOnTrack(Vector3 position, ref int wayPoint1, ref int wayPoint2)
	{
		float normalisedDistance = 0f;
		wayPoint1 = -1;
		wayPoint2 = -1;
		float num = float.PositiveInfinity;
		for (int i = 0; i < Waypoints.Count; i++)
		{
			float sqrMagnitude = (Waypoints[i].position - position).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				wayPoint1 = i;
			}
		}
		Vector3 lhs = position - Waypoints[wayPoint1].position;
		lhs.Normalize();
		Vector3 forward = Waypoints[wayPoint1].forward;
		if (Vector3.Dot(lhs, forward) < 0f)
		{
			wayPoint2 = wayPoint1;
			wayPoint1--;
			if (wayPoint1 < 0)
			{
				wayPoint1 = Waypoints.Count - 1;
			}
		}
		else
		{
			wayPoint2 = wayPoint1 + 1;
			wayPoint2 %= Waypoints.Count - 1;
		}
		GetClosestPointOnLineSegment(Waypoints[wayPoint1].position, Waypoints[wayPoint2].position, position, ref normalisedDistance);
		return normalisedDistance + (float)wayPoint1;
	}

	public Vector3 GetClosestPointOnLineSegment(Vector3 A, Vector3 B, Vector3 P, ref float normalisedDistance)
	{
		Vector3 lhs = P - A;
		Vector3 vector = B - A;
		float sqrMagnitude = vector.sqrMagnitude;
		float num = Vector3.Dot(lhs, vector);
		float num2 = num / sqrMagnitude;
		normalisedDistance = Mathf.Clamp(num2, 0f, 1f);
		if (num2 < 0f)
		{
			return A;
		}
		if (num2 > 1f)
		{
			return B;
		}
		return A + vector * num2;
	}

	public bool DistanceStillOnSpline(float dist)
	{
		return (int)dist < Waypoints.Count - 1;
	}

	public float ConvertWaypointDistanceToDistances(float waypointDistance)
	{
		waypointDistance %= (float)Waypoints.Count;
		if (waypointDistance < 0f)
		{
			waypointDistance = (float)(Waypoints.Count - 1) - waypointDistance;
		}
		int num = (int)waypointDistance % distances.Length;
		int num2 = (num + 1) % distances.Length;
		float num3 = waypointDistance - (float)num;
		float num4 = distances[num2] - distances[num];
		return distances[num] + num4 * num3;
	}

	private void DrawGizmos()
	{
		Locator[] componentsInChildren = GetComponentsInChildren<Locator>();
		Waypoints.Clear();
		if ((bool)StartKnot)
		{
			Waypoints.Add(StartKnot.transform);
		}
		else
		{
			Waypoints.Add(componentsInChildren[0].transform);
		}
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Waypoints.Add(componentsInChildren[i].transform);
		}
		if ((bool)EndKnot)
		{
			Waypoints.Add(EndKnot.transform);
		}
		else
		{
			Waypoints.Add(componentsInChildren[componentsInChildren.Length - 1].transform);
		}
		numPoints = Waypoints.Count;
		CachePositionsAndDistances();
		Length = distances[distances.Length - 1];
		if (Waypoints.Count > 1)
		{
			Gizmos.color = UnityEngine.Color.magenta;
			Vector3 from = Waypoints[0].transform.position;
			for (float num = 0f; num < Length; num += Length / 100f)
			{
				Vector3 routePosition = GetRoutePosition(num + 1f);
				Gizmos.DrawLine(from, routePosition);
				from = routePosition;
			}
		}
	}
}
public class GameStateAnimation : StateMachineBehaviour
{
	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		Transform transform = animator.transform;
		while (transform != null && transform.gameObject.GetComponent<PlayerAnimation>() == null)
		{
			transform = transform.parent;
		}
		PlayerAnimation component = transform.GetComponent<PlayerAnimation>();
		if ((bool)component)
		{
			component.SetPlayingAnim();
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		Transform transform = animator.transform;
		while (transform != null && transform.gameObject.GetComponent<PlayerAnimation>() == null)
		{
			transform = transform.parent;
		}
		PlayerAnimation component = transform.GetComponent<PlayerAnimation>();
		if ((bool)component)
		{
			component.SetStoppedAnim();
		}
	}
}
public class FollowPlayerMenu : UnityEngine.MonoBehaviour
{
	private enum TransitionState
	{
		None,
		Shrink,
		NewPos,
		Grow
	}

	public delegate void EndMenuCallback();

	[SerializeField]
	private float MenuZOffset;

	[SerializeField]
	private float TransitionSpeed = 12f;

	[SerializeField]
	private bool PersistentPopup = true;

	private TransitionState m_state;

	private Vector3 m_forcedPosition;

	private bool m_forced;

	private Vector3 m_positionOffset = Vector3.zero;

	private Vector3 m_camPosition = Vector3.zero;

	private EndMenuCallback m_endMenuCallback;

	public void SetCallback(EndMenuCallback endCallback)
	{
		m_endMenuCallback = endCallback;
	}

	public bool InTransition()
	{
		return m_state != TransitionState.None;
	}

	public void ForceUpdatePosition()
	{
		m_forced = false;
		m_state = TransitionState.NewPos;
		base.transform.localScale = Vector3.zero;
	}

	public void ForceNewPosition(Vector3 position)
	{
		m_forcedPosition = position;
		m_forced = true;
		m_state = TransitionState.Shrink;
	}

	private void Update()
	{
		GameObject gameObject = CameraManager.Instance.GetCurrentCamera().m_cameraArray[0].gameObject;
		if (!base.gameObject.activeSelf)
		{
			return;
		}
		if (!GameEntry.Instance || GameEntry.Instance.GetCurrentState() == GameEntry.GameState.Game)
		{
			base.transform.position = gameObject.transform.position + m_positionOffset;
		}
		else
		{
			base.transform.position = m_camPosition + m_positionOffset;
		}
		switch (m_state)
		{
		case TransitionState.None:
		{
			float num = Vector3.Angle(gameObject.transform.forward, base.transform.forward);
			if (base.transform.localScale.x > 0.1f && num > 15f)
			{
				m_state = TransitionState.Shrink;
			}
			break;
		}
		case TransitionState.Shrink:
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, Vector3.zero, TransitionSpeed * Time.deltaTime);
			if (!(base.transform.localScale.x <= 0.02f))
			{
				break;
			}
			if (PersistentPopup)
			{
				m_state = TransitionState.NewPos;
				break;
			}
			m_state = TransitionState.None;
			if (m_endMenuCallback != null)
			{
				m_endMenuCallback();
			}
			break;
		case TransitionState.NewPos:
		{
			Vector3 vector = gameObject.transform.position;
			if (m_forced)
			{
				vector = m_forcedPosition;
				m_forced = false;
			}
			m_camPosition = vector;
			base.transform.position = vector;
			base.transform.position += gameObject.transform.forward * MenuZOffset;
			m_positionOffset = base.transform.position - gameObject.transform.position;
			Vector3 eulerAngles = gameObject.transform.rotation.eulerAngles;
			eulerAngles.z = 0f;
			base.transform.eulerAngles = eulerAngles;
			base.transform.localScale = new Vector3(0f, 0f, 0f);
			m_state = TransitionState.Grow;
			break;
		}
		case TransitionState.Grow:
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, Vector3.one, TransitionSpeed * Time.deltaTime);
			if (base.transform.localScale.x >= 0.99f)
			{
				base.transform.localScale = new Vector3(1f, 1f, 1f);
				m_state = TransitionState.None;
			}
			break;
		}
	}
}
public class PRBox : UnityEngine.MonoBehaviour
{
	private enum PRState
	{
		None,
		FadeDown,
		FadeUp
	}

	[SerializeField]
	private GameObject CamLocator;

	[SerializeField]
	private Camera CurrentCam;

	private PRState m_currentState;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.F))
		{
			m_currentState = PRState.FadeDown;
			FadeManager.Instance.FadeOut();
			PlayerManager.Instance.GetPlayerList()[0].GetComponent<Player>().enabled = false;
		}
		switch (m_currentState)
		{
		case PRState.FadeDown:
			if (FadeManager.Instance.FinishedFading())
			{
				CameraManager.Instance.SetNewTransform(CamLocator.transform);
				FadeManager.Instance.FadeIn();
				m_currentState = PRState.FadeUp;
			}
			break;
		case PRState.FadeUp:
			if (FadeManager.Instance.FinishedFading())
			{
				CurrentCam.transform.parent = CamLocator.transform;
				CurrentCam.transform.localPosition = Vector3.zero;
				CurrentCam.transform.localRotation = Quaternion.identity;
				m_currentState = PRState.None;
			}
			break;
		}
	}
}
public class StringTable : UnityEngine.MonoBehaviour
{
	public enum Language
	{
		UK,
		US,
		French,
		Italian,
		German,
		Spanish,
		CanadianFrench,
		LATAMSpanish,
		Japanese,
		Korean,
		Russian,
		Hindi,
		Chinese,
		Max
	}

	private struct StringTableEntry
	{
		public string identifier;

		public string usage;

		public string direction;

		public string[] translation;
	}

	private List<StringTableEntry> m_stringTableData = new List<StringTableEntry>();

	private Language m_currentLanguage;

	private int m_localIndex;

	private string[] m_stringArray;

	public void LoadStringTable(string filename)
	{
		TextAsset textAsset = (TextAsset)Resources.Load(filename);
		if (textAsset == null)
		{
			return;
		}
		m_localIndex = 0;
		string text = textAsset.text.Replace("\r", "\t");
		text = textAsset.text.Replace("\"", string.Empty);
		text = text.Replace("\n", "\n\t");
		m_stringArray = text.Split("\t"[0]);
		do
		{
			StringTableEntry item = default(StringTableEntry);
			item.translation = new string[13];
			string nextString = GetNextString();
			if (nextString == string.Empty)
			{
				MoveToNextLine();
				continue;
			}
			item.identifier = nextString;
			item.usage = GetNextString();
			item.direction = GetNextString();
			item.translation[0] = GetNextLanguageString();
			item.translation[1] = GetNextLanguageString();
			item.translation[2] = GetNextLanguageString();
			item.translation[3] = GetNextLanguageString();
			item.translation[4] = GetNextLanguageString();
			item.translation[5] = GetNextLanguageString();
			item.translation[6] = GetNextLanguageString();
			item.translation[7] = GetNextLanguageString();
			item.translation[8] = GetNextLanguageString();
			item.translation[9] = GetNextLanguageString();
			item.translation[10] = GetNextLanguageString();
			item.translation[11] = GetNextLanguageString();
			item.translation[12] = GetNextLanguageString();
			MoveToNextLine();
			m_stringTableData.Add(item);
		}
		while (m_localIndex < m_stringArray.Length);
	}

	private string GetNextString()
	{
		return m_stringArray[m_localIndex++];
	}

	private string GetNextLanguageString()
	{
		string text = m_stringArray[m_localIndex++].ToUpper();
		return text.Replace("\\N", Environment.NewLine);
	}

	private void MoveToNextLine()
	{
		while (m_localIndex < m_stringArray.Length)
		{
			if (m_stringArray[m_localIndex].Contains("\n"))
			{
				m_localIndex++;
				break;
			}
			m_localIndex++;
			if (m_localIndex >= m_stringArray.Length)
			{
				break;
			}
		}
	}

	public void SetCurrentLanguage(Language languageToSet)
	{
		m_currentLanguage = languageToSet;
	}

	public Language GetCurrentLanguage()
	{
		return m_currentLanguage;
	}

	public string GetTranslationByIdentifier(string identifer, bool convertToUpperCase = false)
	{
		identifer = identifer.Replace(" ", string.Empty);
		StringTableEntry entryToReturn = default(StringTableEntry);
		if (FindEntryByIdentifer(identifer, ref entryToReturn))
		{
			return entryToReturn.translation[(int)m_currentLanguage];
		}
		return "STR_UNKNOWN";
	}

	private bool FindEntryByIdentifer(string identifier, ref StringTableEntry entryToReturn)
	{
		for (int i = 0; i < m_stringTableData.Count; i++)
		{
			if (m_stringTableData[i].identifier == identifier)
			{
				entryToReturn = m_stringTableData[i];
				return true;
			}
		}
		return false;
	}

	private void Start()
	{
		LoadStringTable("VR_Karts_Stringtable");
		SetupLanguage();
	}

	private void SetupLanguage()
	{
		string language = PreciseLocale.GetLanguage();
		string region = PreciseLocale.GetRegion();
		switch (language)
		{
		default:
			m_currentLanguage = Language.US;
			break;
		case "en":
			switch (region)
			{
			case "GB":
			case "IE":
			case "IM":
			case "GG":
			case "JE":
				m_currentLanguage = Language.UK;
				break;
			default:
				m_currentLanguage = Language.US;
				break;
			}
			break;
		case "fr":
			m_currentLanguage = Language.French;
			break;
		case "it":
			m_currentLanguage = Language.Italian;
			break;
		case "de":
			m_currentLanguage = Language.German;
			break;
		case "es":
			if (region == "419")
			{
				m_currentLanguage = Language.LATAMSpanish;
			}
			else
			{
				m_currentLanguage = Language.Spanish;
			}
			break;
		}
	}

	private void Update()
	{
	}
}
public class StringTranslation : UnityEngine.MonoBehaviour
{
	private class GlyphPlacement
	{
		public string id;

		public Vector2[] localPos;

		public GlyphPlacement(string newID, Vector2 xUS, Vector2 xUK, Vector2 xFrench, Vector2 xItalian, Vector2 xGerman, Vector2 xSpanish, Vector2 xCanFrench, Vector2 xLATAMSpan, Vector2 xJapanese, Vector2 xKorean, Vector2 xRussian, Vector2 xHindi, Vector2 xChinese)
		{
			localPos = new Vector2[13];
			id = newID;
			localPos[1] = xUS;
			localPos[0] = xUK;
			localPos[2] = xFrench;
			localPos[3] = xItalian;
			localPos[4] = xGerman;
			localPos[5] = xSpanish;
			localPos[6] = xCanFrench;
			localPos[7] = xLATAMSpan;
			localPos[8] = xJapanese;
			localPos[9] = xKorean;
			localPos[10] = xRussian;
			localPos[11] = xHindi;
			localPos[12] = xChinese;
		}
	}

	[SerializeField]
	private string Identifier;

	[SerializeField]
	private bool UpperCase = true;

	[SerializeField]
	private string PreString = string.Empty;

	[SerializeField]
	private string PostString = string.Empty;

	[SerializeField]
	private GameObject Glyph;

	private StringTable m_stringTable;

	private StringTable.Language m_currentLanguage = StringTable.Language.Max;

	private float textSize = 0.024f;

	private GlyphPlacement[] GlyphPlacementData = new GlyphPlacement[6]
	{
		new GlyphPlacement("STR_EnterCustomisation", new Vector2(6.5f, 0.87f), new Vector2(6.5f, 0.87f), new Vector2(11.7f, 4.9f), new Vector2(13.9f, 0.4f), new Vector2(7.5f, 4.2f), new Vector2(1.3f, 0.9f), new Vector2(11.8f, 4.4f), new Vector2(1.5f, 1.4f), new Vector2(-23f, 4.1f), new Vector2(-31.3f, 4.1f), new Vector2(-13.4f, 4.1f), new Vector2(-10.4f, -3.7f), new Vector2(-0.2f, 4.1f)),
		new GlyphPlacement("STR_PressToJoin", new Vector2(-3.5f, -4.4f), new Vector2(-3.5f, -4.4f), new Vector2(17.5f, -0.3f), new Vector2(4.2f, -0.6f), new Vector2(6f, -0.3f), new Vector2(1.1f, -0.3f), new Vector2(17.5f, -0.3f), new Vector2(1.1f, -0.3f), new Vector2(-19.8f, -4.4f), new Vector2(-31.7f, -4.4f), new Vector2(2.9f, 0.3f), new Vector2(15.9f, -4.4f), new Vector2(-5.9f, -4.4f)),
		new GlyphPlacement("STR_PressToRace", new Vector2(-4.5f, -3.7f), new Vector2(-4.5f, -3.7f), new Vector2(11.81f, 0.48f), new Vector2(2.8f, 0.7f), new Vector2(8.29f, 0.32f), new Vector2(6.4f, 0.4f), new Vector2(12.06f, 0.91f), new Vector2(6.4f, 0.91f), new Vector2(-21.9f, 0f), new Vector2(-30.1f, 0f), new Vector2(0.9f, 4.1f), new Vector2(12.8f, 0f), new Vector2(-12.3f, 0f)),
		new GlyphPlacement("STR_PressToChat", new Vector2(-8.4f, 0f), new Vector2(-8.4f, 0f), new Vector2(-10.4f, 0f), new Vector2(-14.5f, 0f), new Vector2(-20.5f, 0f), new Vector2(-17.5f, 0f), new Vector2(-10.4f, 0f), new Vector2(-17.5f, 0f), new Vector2(-17.5f, 4.1f), new Vector2(-17.5f, 4.1f), new Vector2(-17.5f, 4.1f), new Vector2(-17.5f, 4.1f), new Vector2(-17.5f, 4.1f)),
		new GlyphPlacement("STR_PressToConfirm", new Vector2(-12.4f, -3.7f), new Vector2(-12.4f, -3.7f), new Vector2(-12f, -3.4f), new Vector2(-21.9f, -3.5f), new Vector2(-21.9f, -3.6f), new Vector2(-22.9f, -3.4f), new Vector2(23f, 0.2f), new Vector2(14.6f, 0.4f), new Vector2(-19.5f, 0f), new Vector2(-29.8f, 0f), new Vector2(3f, 4.1f), new Vector2(15f, 0f), new Vector2(-12.4f, 0f)),
		new GlyphPlacement("STR_PressToConfirmQuit", new Vector2(-12.31f, -3.8f), new Vector2(-12.31f, -3.8f), new Vector2(23.37f, 0.59f), new Vector2(12.65f, 0.32f), new Vector2(6.92f, 0.45f), new Vector2(13.6f, 0.24f), new Vector2(22.26f, 0.38f), new Vector2(13.6f, 0.37f), new Vector2(-13.4f, 4.1f), new Vector2(-13.4f, 4.1f), new Vector2(-13.4f, 4.1f), new Vector2(-13.4f, 4.1f), new Vector2(-13.4f, 4.1f))
	};

	private void Start()
	{
		m_stringTable = GameSystem.Instance.GetStringTable();
	}

	private void OnEnable()
	{
		SetTranslationText();
	}

	private Vector2 FindGlyphPlacement(string id)
	{
		for (int i = 0; i < GlyphPlacementData.Length; i++)
		{
			if (GlyphPlacementData[i].id == id)
			{
				return GlyphPlacementData[i].localPos[(int)GameSystem.Instance.GetStringTable().GetCurrentLanguage()];
			}
		}
		return Vector2.zero;
	}

	private void SetTranslationText()
	{
		if (!GameSystem.Instance)
		{
			return;
		}
		string text = PreString + GameSystem.Instance.GetStringTable().GetTranslationByIdentifier(Identifier, UpperCase) + PostString;
		if (Glyph != null)
		{
			int num = text.IndexOf("(A)");
			if (num != -1)
			{
				text = text.Replace("(A)", "    ");
				Vector2 vector = FindGlyphPlacement(Identifier);
				Glyph.transform.localPosition = new Vector3(vector.x, vector.y, 0f);
			}
		}
		if ((bool)GetComponent<TextMesh>())
		{
			GetComponent<TextMesh>().text = text;
		}
		else if ((bool)GetComponent<Text>())
		{
			GetComponent<Text>().text = text;
		}
	}

	private void Update()
	{
		if (m_currentLanguage != m_stringTable.GetCurrentLanguage())
		{
			m_currentLanguage = m_stringTable.GetCurrentLanguage();
			SetTranslationText();
		}
	}
}
public class TextureFrame : UnityEngine.MonoBehaviour
{
	public int Columns = 2;

	public int Rows = 2;

	public Vector2 Scale = new Vector3(1f, 1f);

	public Vector2 Offset = Vector2.zero;

	public Vector2 Buffer = Vector2.zero;

	private int m_index;

	private Vector2 m_textureSize = Vector2.zero;

	public void SetIndex(int index)
	{
		m_index = index + Rows;
		ApplyOffset();
	}

	private void Start()
	{
		CalcTextureSize();
	}

	private void CalcTextureSize()
	{
		m_textureSize = new Vector2(1f / (float)Columns, 1f / (float)Rows);
		m_textureSize.x /= Scale.x;
		m_textureSize.y /= Scale.y;
		m_textureSize -= Buffer;
	}

	private void ApplyOffset()
	{
		Vector2 value = new Vector2((float)m_index / (float)Columns - (float)(m_index / Columns), 1f - (float)(m_index / Columns) / (float)Rows);
		if (value.y == 1f)
		{
			value.y = 0f;
		}
		value.x += (1f / (float)Columns - m_textureSize.x) / 2f;
		value.y += (1f / (float)Rows - m_textureSize.y) / 2f;
		value.x += Offset.x;
		value.y += Offset.y;
		if ((bool)GetComponent<Renderer>() && (bool)GetComponent<Renderer>().sharedMaterial)
		{
			GetComponent<Renderer>().sharedMaterial.SetTextureOffset("_MainTex", value);
		}
	}
}
public class VisorOverlay : UnityEngine.MonoBehaviour
{
	public enum OverlayType
	{
		Left,
		Right,
		Up,
		Down,
		All
	}

	protected struct TransitionData
	{
		public float currentTransition;

		public float normalisedTarget;

		public float speed;
	}

	[SerializeField]
	private MeshRenderer LeftOverlay;

	[SerializeField]
	private MeshRenderer RightOverlay;

	[SerializeField]
	private MeshRenderer UpOverlay;

	[SerializeField]
	private MeshRenderer DownOverlay;

	[SerializeField]
	private bool ContinuousReduction;

	private TransitionData[] m_transitionData = new TransitionData[4];

	private float[] OverlayExtents = new float[4] { 0.85f, 0.85f, -0.38f, 0.38f };

	public void SetOverlayTransition(OverlayType type, float normalisedTarget, float speed)
	{
		m_transitionData[(int)type].normalisedTarget = normalisedTarget;
		m_transitionData[(int)type].speed = speed;
	}

	public float GetOverlayTransitionAmount(OverlayType type)
	{
		return m_transitionData[(int)type].currentTransition;
	}

	private void Start()
	{
		for (int i = 0; i < m_transitionData.Length; i++)
		{
			m_transitionData[i] = default(TransitionData);
		}
	}

	private void Update()
	{
		for (int i = 0; i < m_transitionData.Length; i++)
		{
			if (!Mathf.Approximately(m_transitionData[i].currentTransition, m_transitionData[i].normalisedTarget))
			{
				m_transitionData[i].currentTransition = Mathf.Lerp(m_transitionData[i].currentTransition, m_transitionData[i].normalisedTarget, GameTime.Instance.DeltaTime() / m_transitionData[i].speed);
			}
			if (ContinuousReduction)
			{
				m_transitionData[i].currentTransition = Mathf.Lerp(m_transitionData[i].currentTransition, 0f, 2f * GameTime.Instance.DeltaTime());
			}
		}
		UpdateOverlay();
	}

	private void UpdateOverlay()
	{
		LeftOverlay.transform.localPosition = new Vector3(m_transitionData[0].currentTransition * OverlayExtents[0], LeftOverlay.transform.localPosition.y, LeftOverlay.transform.localPosition.z);
		RightOverlay.transform.localPosition = new Vector3(m_transitionData[1].currentTransition * OverlayExtents[1], RightOverlay.transform.localPosition.y, RightOverlay.transform.localPosition.z);
		UpOverlay.transform.localPosition = new Vector3(UpOverlay.transform.localPosition.x, m_transitionData[2].currentTransition * OverlayExtents[2], UpOverlay.transform.localPosition.z);
		DownOverlay.transform.localPosition = new Vector3(DownOverlay.transform.localPosition.x, m_transitionData[3].currentTransition * OverlayExtents[3], DownOverlay.transform.localPosition.z);
	}
}
public class UnityAnalyticsIntegration : UnityEngine.MonoBehaviour
{
}
public class UtilLineDraw
{
	private List<Vector3> splineVerts = new List<Vector3>();

	private LineRenderer lineRenderer;

	private GameObject m_gameObject = new GameObject();

	private static Material lineMaterial;

	public void ResetVerts()
	{
		splineVerts.Clear();
	}

	public void AddVert(Vector3 vert)
	{
		splineVerts.Add(vert);
		lineRenderer.SetVertexCount(splineVerts.Count);
		for (int i = 0; i < splineVerts.Count; i++)
		{
			lineRenderer.SetPosition(i, splineVerts[i]);
		}
	}

	public void Init()
	{
		CreateLineMaterial();
		lineRenderer = m_gameObject.AddComponent<LineRenderer>();
		lineRenderer.useWorldSpace = true;
		lineRenderer.material = lineMaterial;
		lineRenderer.SetColors(UnityEngine.Color.red, UnityEngine.Color.red);
		lineRenderer.SetWidth(2f, 2f);
		lineRenderer.SetVertexCount(360);
	}

	private static void CreateLineMaterial()
	{
		if (!lineMaterial)
		{
			lineMaterial = new Material("Shader \"Lines/Colored Blended\" {SubShader { Pass {     Blend SrcAlpha OneMinusSrcAlpha     ZWrite Off Cull Off Fog { Mode Off }     BindChannels {      Bind \"vertex\", vertex Bind \"color\", color }} } }");
			lineMaterial.hideFlags = HideFlags.HideAndDontSave;
			lineMaterial.shader.hideFlags = HideFlags.HideAndDontSave;
		}
	}
}
namespace HeurekaGames
{
	public static class Extensions
	{
		public static Vector2 YZ(this Vector3 v)
		{
			return new Vector2(v.x, v.z);
		}

		public static Vector2[] YZ(this Vector3[] v)
		{
			Vector2[] array = new Vector2[v.Length];
			for (int i = 0; i < v.Length; i++)
			{
				ref Vector2 reference = ref array[i];
				reference = new Vector2(v[i].x, v[i].z);
			}
			return array;
		}

		public static float Remap(this float value, float from1, float to1, float from2, float to2)
		{
			return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static string ToCamelCase(this string camelCaseString)
		{
			return Regex.Replace(camelCaseString, "([a-z](?=[A-Z])|[A-Z](?=[A-Z][a-z]))", "$1 ").Trim();
		}

		public static bool Contains(this string source, string toCheck, StringComparison comp)
		{
			return source != null && toCheck != null && source.IndexOf(toCheck, comp) >= 0;
		}

		public static void SetComponentRecursively<T>(this GameObject gameObject, bool tf) where T : UnityEngine.Component
		{
			T[] componentsInChildren = gameObject.GetComponentsInChildren<T>();
			T[] array = componentsInChildren;
			foreach (T obj in array)
			{
				try
				{
					PropertyInfo property = typeof(T).GetProperty("enabled");
					if (property != null && property.CanWrite)
					{
						property.SetValue(obj, tf, null);
						continue;
					}
					Console.WriteLine("BLABLA");
					UnityEngine.Debug.Log("Property does not exist, or cannot write");
				}
				catch (NullReferenceException ex)
				{
					UnityEngine.Debug.Log("The property does not exist in MyClass." + ex.Message);
				}
			}
		}

		public static void CastList<T>(this List<T> targetList)
		{
			targetList = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Cast<T>(targetList));
		}

		public static bool Has<T>(this Enum type, T value)
		{
			try
			{
				return ((int)(object)type & (int)(object)value) == (int)(object)value;
			}
			catch
			{
				return false;
			}
		}

		public static bool Is<T>(this Enum type, T value)
		{
			try
			{
				return (int)(object)type == (int)(object)value;
			}
			catch
			{
				return false;
			}
		}

		public static T Add<T>(this Enum type, T value)
		{
			try
			{
				return (T)(object)((int)(object)type | (int)(object)value);
			}
			catch (Exception innerException)
			{
				throw new ArgumentException($"Could not append value from enumerated type '{typeof(T).Name}'.", innerException);
			}
		}

		public static T Remove<T>(this Enum type, T value)
		{
			try
			{
				return (T)(object)((int)(object)type & ~(int)(object)value);
			}
			catch (Exception innerException)
			{
				throw new ArgumentException($"Could not remove value from enumerated type '{typeof(T).Name}'.", innerException);
			}
		}

		public static UnityEngine.Color ModifiedAlpha(this UnityEngine.Color color, float alpha)
		{
			UnityEngine.Color result = color;
			result.a = alpha;
			return result;
		}
	}
	public class Singleton<T> : UnityEngine.MonoBehaviour where T : UnityEngine.MonoBehaviour
	{
		private static T _instance;

		private static object _lock = new object();

		private static bool applicationIsQuitting = false;

		public static T Instance
		{
			get
			{
				if (applicationIsQuitting)
				{
					UnityEngine.Debug.LogWarning(string.Concat("[Singleton] Instance '", typeof(T), "' already destroyed on application quit. Won't create again - returning null."));
					return (T)null;
				}
				lock (_lock)
				{
					if (_instance == null)
					{
						_instance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
						if (UnityEngine.Object.FindObjectsOfType(typeof(T)).Length > 1)
						{
							UnityEngine.Debug.LogError("[Singleton] Something went really wrong  - there should never be more than 1 singleton! Reopenning the scene might fix it.");
							return _instance;
						}
						if (_instance == null)
						{
							GameObject gameObject = new GameObject();
							_instance = gameObject.AddComponent<T>();
							gameObject.name = "(singleton) " + typeof(T).ToString();
							UnityEngine.Debug.Log(string.Concat("[Singleton] An instance of ", typeof(T), " was created."));
						}
						else
						{
							UnityEngine.Debug.Log("[Singleton] Using instance already created: " + _instance.gameObject.name);
						}
					}
					return _instance;
				}
			}
		}

		public void OnDestroy()
		{
			applicationIsQuitting = true;
		}
	}
}
public class MB_SwapShirts : UnityEngine.MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public Renderer[] clothingAndBodyPartsBareTorso;

	public Renderer[] clothingAndBodyPartsBareTorsoDamagedArm;

	public Renderer[] clothingAndBodyPartsHoodie;

	private void Start()
	{
		GameObject[] array = new GameObject[clothingAndBodyPartsBareTorso.Length];
		for (int i = 0; i < clothingAndBodyPartsBareTorso.Length; i++)
		{
			array[i] = clothingAndBodyPartsBareTorso[i].gameObject;
		}
		meshBaker.ClearMesh();
		meshBaker.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		meshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Wear Hoodie"))
		{
			ChangeOutfit(clothingAndBodyPartsHoodie);
		}
		if (GUILayout.Button("Bare Torso"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorso);
		}
		if (GUILayout.Button("Damaged Arm"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorsoDamagedArm);
		}
	}

	private void ChangeOutfit(Renderer[] outfit)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (GameObject item in meshBaker.meshCombiner.GetObjectsInCombined())
		{
			Renderer component = item.GetComponent<Renderer>();
			bool flag = false;
			for (int i = 0; i < outfit.Length; i++)
			{
				if (component == outfit[i])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(component.gameObject);
				UnityEngine.Debug.Log("Removing " + component.gameObject);
			}
		}
		List<GameObject> list2 = new List<GameObject>();
		for (int j = 0; j < outfit.Length; j++)
		{
			if (!meshBaker.meshCombiner.GetObjectsInCombined().Contains(outfit[j].gameObject))
			{
				list2.Add(outfit[j].gameObject);
				UnityEngine.Debug.Log("Adding " + outfit[j].gameObject);
			}
		}
		meshBaker.AddDeleteGameObjects(list2.ToArray(), list.ToArray(), disableRendererInSource: true);
		meshBaker.Apply();
	}
}
namespace DigitalOpus.MB.Core
{
	public interface TextureBlender
	{
		bool DoesShaderNameMatch(string shaderName);

		void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName);

		UnityEngine.Color OnBlendTexturePixel(string shaderPropertyName, UnityEngine.Color pixelColor);

		bool NonTexturePropertiesAreEqual(Material a, Material b);

		void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial);

		UnityEngine.Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName);
	}
	public class TextureBlenderFallback : TextureBlender
	{
		private bool m_doTintColor;

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_defaultColor = UnityEngine.Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return true;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				m_doTintColor = true;
				m_tintColor = UnityEngine.Color.white;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else if (sourceMat.HasProperty("_TintColor"))
				{
					m_tintColor = sourceMat.GetColor("_TintColor");
				}
			}
			else
			{
				m_doTintColor = false;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string shaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (m_doTintColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (a.HasProperty("_Color"))
			{
				if (_compareColor(a, b, m_defaultColor, "_Color"))
				{
					return true;
				}
			}
			else if (a.HasProperty("_TintColor") && _compareColor(a, b, m_defaultColor, "_TintColor"))
			{
				return true;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.HasProperty("_Color"))
			{
				resultMaterial.SetColor("_Color", m_defaultColor);
			}
			else if (resultMaterial.HasProperty("_TintColor"))
			{
				resultMaterial.SetColor("_TintColor", m_defaultColor);
			}
		}

		public UnityEngine.Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texProperty)
		{
			if (texProperty.isNormalMap)
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texProperty.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
				else if (mat != null && mat.HasProperty("_TintColor"))
				{
					try
					{
						return mat.GetColor("_TintColor");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_SpecGlossMap"))
			{
				if (mat != null && mat.HasProperty("_SpecColor"))
				{
					try
					{
						UnityEngine.Color color = mat.GetColor("_SpecColor");
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								color.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						UnityEngine.Debug.LogWarning(color);
						return color;
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_MetallicGlossMap"))
			{
				if (mat != null && mat.HasProperty("_Metallic"))
				{
					try
					{
						float @float = mat.GetFloat("_Metallic");
						UnityEngine.Color result = new UnityEngine.Color(@float, @float, @float);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								result.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						return result;
					}
					catch (Exception)
					{
					}
				}
			}
			else
			{
				if (texProperty.name.Equals("_ParallaxMap"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
				if (texProperty.name.Equals("_OcclusionMap"))
				{
					return new UnityEngine.Color(1f, 1f, 1f, 1f);
				}
				if (texProperty.name.Equals("_EmissionMap"))
				{
					if (mat != null && mat.HasProperty("_EmissionScaleUI"))
					{
						if (mat.HasProperty("_EmissionColor") && mat.HasProperty("_EmissionColorUI"))
						{
							try
							{
								UnityEngine.Color color2 = mat.GetColor("_EmissionColor");
								UnityEngine.Color color3 = mat.GetColor("_EmissionColorUI");
								float float2 = mat.GetFloat("_EmissionScaleUI");
								if (color2 == new UnityEngine.Color(0f, 0f, 0f, 0f) && color3 == new UnityEngine.Color(1f, 1f, 1f, 1f))
								{
									return new UnityEngine.Color(float2, float2, float2, float2);
								}
								return color3;
							}
							catch (Exception)
							{
							}
						}
						else
						{
							try
							{
								float float3 = mat.GetFloat("_EmissionScaleUI");
								return new UnityEngine.Color(float3, float3, float3, float3);
							}
							catch (Exception)
							{
							}
						}
					}
				}
				else if (texProperty.name.Equals("_DetailMask"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}

		public static bool _compareColor(Material a, Material b, UnityEngine.Color defaultVal, string propertyName)
		{
			UnityEngine.Color color = defaultVal;
			UnityEngine.Color color2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				color = a.GetColor(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				color2 = b.GetColor(propertyName);
			}
			if (color != color2)
			{
				return false;
			}
			return true;
		}

		public static bool _compareFloat(Material a, Material b, float defaultVal, string propertyName)
		{
			float num = defaultVal;
			float num2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				num = a.GetFloat(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				num2 = b.GetFloat(propertyName);
			}
			if (num != num2)
			{
				return false;
			}
			return true;
		}
	}
	public class TextureBlenderLegacyBumpDiffuse : TextureBlender
	{
		private bool doColor;

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_defaultTintColor = UnityEngine.Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Bumped Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Bumped Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", UnityEngine.Color.white);
		}

		public UnityEngine.Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderLegacyDiffuse : TextureBlender
	{
		private bool doColor;

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_defaultTintColor = UnityEngine.Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", UnityEngine.Color.white);
		}

		public UnityEngine.Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardMetallic : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doEmission,
			doNone
		}

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_emission;

		private Prop propertyToDo = Prop.doNone;

		private UnityEngine.Color m_defaultColor = UnityEngine.Color.white;

		private float m_defaultMetallic;

		private float m_defaultGlossiness = 0.5f;

		private UnityEngine.Color m_defaultEmission = UnityEngine.Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_defaultColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_emission = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emission = m_defaultEmission;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				return pixelColor;
			}
			if (propertyToDo == Prop.doEmission)
			{
				return new UnityEngine.Color(pixelColor.r * m_emission.r, pixelColor.g * m_emission.g, pixelColor.b * m_emission.b, pixelColor.a * m_emission.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_defaultMetallic, "_Metallic"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_defaultGlossiness, "_Glossiness"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultEmission, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", m_defaultColor);
			resultMaterial.SetFloat("_Metallic", m_defaultMetallic);
			resultMaterial.SetFloat("_Glossiness", m_defaultGlossiness);
			if (resultMaterial.GetTexture("_EmissionMap") == null)
			{
				resultMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			}
			else
			{
				resultMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
			}
		}

		public UnityEngine.Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texPropertyName.name.Equals("_MetallicGlossMap"))
			{
				if (!(mat != null) || !mat.HasProperty("_Metallic"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0.5f);
				}
				try
				{
					float @float = mat.GetFloat("_Metallic");
					UnityEngine.Color result = new UnityEngine.Color(@float, @float, @float);
					if (mat.HasProperty("_Glossiness"))
					{
						try
						{
							result.a = mat.GetFloat("_Glossiness");
						}
						catch (Exception)
						{
						}
					}
					return result;
				}
				catch (Exception)
				{
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new UnityEngine.Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.HasProperty("_EmissionColor"))
						{
							return UnityEngine.Color.black;
						}
						try
						{
							return mat.GetColor("_EmissionColor");
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardSpecular : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doSpecular,
			doEmission,
			doNone
		}

		private UnityEngine.Color m_tintColor;

		private UnityEngine.Color m_emission;

		private Prop propertyToDo = Prop.doNone;

		private UnityEngine.Color m_defaultColor = UnityEngine.Color.white;

		private UnityEngine.Color m_defaultSpecular = UnityEngine.Color.black;

		private float m_defaultGlossiness = 0.5f;

		private UnityEngine.Color m_defaultEmission = UnityEngine.Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Specular setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_defaultColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doSpecular;
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					m_emission = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emission = m_defaultEmission;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public UnityEngine.Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, UnityEngine.Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new UnityEngine.Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doSpecular)
			{
				return pixelColor;
			}
			if (propertyToDo == Prop.doEmission)
			{
				return new UnityEngine.Color(pixelColor.r * m_emission.r, pixelColor.g * m_emission.g, pixelColor.b * m_emission.b, pixelColor.a * m_emission.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultSpecular, "_SpecColor"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_defaultGlossiness, "_Glossiness"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_defaultEmission, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", m_defaultColor);
			resultMaterial.SetColor("_SpecColor", m_defaultSpecular);
			resultMaterial.SetFloat("_Glossiness", m_defaultGlossiness);
			if (resultMaterial.GetTexture("_EmissionMap") == null)
			{
				resultMaterial.SetColor("_EmissionColor", UnityEngine.Color.black);
			}
			else
			{
				resultMaterial.SetColor("_EmissionColor", UnityEngine.Color.white);
			}
		}

		public UnityEngine.Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texPropertyName.name.Equals("_SpecGlossMap"))
			{
				bool flag = false;
				if (mat != null && mat.HasProperty("_SpecColor"))
				{
					try
					{
						UnityEngine.Color color = mat.GetColor("_SpecColor");
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								flag = true;
								color.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						UnityEngine.Debug.LogWarning(color);
						return color;
					}
					catch (Exception)
					{
					}
				}
				if (!flag)
				{
					return m_defaultSpecular;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new UnityEngine.Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.HasProperty("_EmissionColor"))
						{
							return UnityEngine.Color.black;
						}
						try
						{
							return mat.GetColor("_EmissionColor");
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}
	}
}
public class MB3_TestTexturePacker : UnityEngine.MonoBehaviour
{
	private MB2_TexturePacker texturePacker;

	public int numTex = 32;

	public int min = 126;

	public int max = 2046;

	public float xMult = 1f;

	public float yMult = 1f;

	public bool imgsMustBePowerOfTwo;

	public List<Vector2> imgsToAdd = new List<Vector2>();

	public int padding = 1;

	public int maxDim = 4096;

	public bool doPowerOfTwoTextures = true;

	public bool doMultiAtlas;

	public MB2_LogLevel logLevel;

	public string res;

	public AtlasPackingResult[] rs;

	[ContextMenu("Generate List Of Images To Add")]
	public void GenerateListOfImagesToAdd()
	{
		imgsToAdd = new List<Vector2>();
		for (int i = 0; i < numTex; i++)
		{
			Vector2 item = new Vector2(Mathf.RoundToInt((float)UnityEngine.Random.Range(min, max) * xMult), Mathf.RoundToInt((float)UnityEngine.Random.Range(min, max) * yMult));
			if (imgsMustBePowerOfTwo)
			{
				item.x = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo((int)item.x);
				item.y = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo((int)item.y);
			}
			imgsToAdd.Add(item);
		}
	}

	[ContextMenu("Run")]
	public void RunTestHarness()
	{
		texturePacker = new MB2_TexturePacker();
		texturePacker.doPowerOfTwoTextures = doPowerOfTwoTextures;
		texturePacker.LOG_LEVEL = logLevel;
		rs = texturePacker.GetRects(imgsToAdd, maxDim, padding, doMultiAtlas);
		if (rs != null)
		{
			UnityEngine.Debug.Log("NumAtlas= " + rs.Length);
			for (int i = 0; i < rs.Length; i++)
			{
				for (int j = 0; j < rs[i].rects.Length; j++)
				{
					Rect rect = rs[i].rects[j];
					rect.x *= rs[i].atlasX;
					rect.y *= rs[i].atlasY;
					rect.width *= rs[i].atlasX;
					rect.height *= rs[i].atlasY;
					UnityEngine.Debug.Log(rect.ToString("f5"));
				}
				UnityEngine.Debug.Log("===============");
			}
			res = "mxX= " + rs[0].atlasX + " mxY= " + rs[0].atlasY;
		}
		else
		{
			res = "ERROR: PACKING FAILED";
		}
	}

	private void OnDrawGizmos()
	{
		if (rs == null)
		{
			return;
		}
		for (int i = 0; i < rs.Length; i++)
		{
			Vector2 vector = new Vector2((float)i * 1.5f * (float)maxDim, 0f);
			AtlasPackingResult atlasPackingResult = rs[i];
			Vector2 vector2 = new Vector2(vector.x + (float)(atlasPackingResult.atlasX / 2), vector.y + (float)(atlasPackingResult.atlasY / 2));
			Gizmos.DrawWireCube(size: new Vector2(atlasPackingResult.atlasX, atlasPackingResult.atlasY), center: vector2);
			for (int j = 0; j < rs[i].rects.Length; j++)
			{
				Rect rect = rs[i].rects[j];
				Gizmos.color = new UnityEngine.Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
				vector2 = new Vector2(vector.x + (rect.x + rect.width / 2f) * (float)rs[i].atlasX, vector.y + (rect.y + rect.height / 2f) * (float)rs[i].atlasY);
				Gizmos.DrawCube(size: new Vector2(rect.width * (float)rs[i].atlasX, rect.height * (float)rs[i].atlasY), center: vector2);
			}
		}
	}

	[ContextMenu("Test1")]
	private void Test1()
	{
		texturePacker = new MB2_TexturePacker();
		texturePacker.doPowerOfTwoTextures = true;
		List<Vector2> list = new List<Vector2>();
		list.Add(new Vector2(450f, 200f));
		list.Add(new Vector2(450f, 200f));
		list.Add(new Vector2(450f, 80f));
		texturePacker.LOG_LEVEL = logLevel;
		rs = texturePacker.GetRects(list, 512, 8, doMultiAtlas: true);
		UnityEngine.Debug.Log("Success! ");
	}

	[ContextMenu("Test2")]
	private void Test2()
	{
		texturePacker = new MB2_TexturePacker();
		texturePacker.doPowerOfTwoTextures = true;
		List<Vector2> list = new List<Vector2>();
		list.Add(new Vector2(200f, 450f));
		list.Add(new Vector2(200f, 450f));
		list.Add(new Vector2(80f, 450f));
		texturePacker.LOG_LEVEL = logLevel;
		rs = texturePacker.GetRects(list, 512, 8, doMultiAtlas: true);
		UnityEngine.Debug.Log("Success! ");
	}

	[ContextMenu("Test3")]
	private void Test3()
	{
		texturePacker = new MB2_TexturePacker();
		texturePacker.doPowerOfTwoTextures = false;
		List<Vector2> list = new List<Vector2>();
		list.Add(new Vector2(450f, 200f));
		list.Add(new Vector2(450f, 200f));
		list.Add(new Vector2(450f, 80f));
		texturePacker.LOG_LEVEL = logLevel;
		rs = texturePacker.GetRects(list, 512, 8, doMultiAtlas: true);
		UnityEngine.Debug.Log("Success! ");
	}

	[ContextMenu("Test4")]
	private void Test4()
	{
		texturePacker = new MB2_TexturePacker();
		texturePacker.doPowerOfTwoTextures = false;
		List<Vector2> list = new List<Vector2>();
		list.Add(new Vector2(200f, 450f));
		list.Add(new Vector2(200f, 450f));
		list.Add(new Vector2(80f, 450f));
		texturePacker.LOG_LEVEL = logLevel;
		rs = texturePacker.GetRects(list, 512, 8, doMultiAtlas: true);
		UnityEngine.Debug.Log("Success! ");
	}
}
namespace DigitalOpus.MB.Core
{
	[Serializable]
	public class MB3_AgglomerativeClustering
	{
		[Serializable]
		public class ClusterNode
		{
			public item_s leaf;

			public ClusterNode cha;

			public ClusterNode chb;

			public int height;

			public float distToMergedCentroid;

			public Vector3 centroid;

			public int[] leafs;

			public int idx;

			public bool isUnclustered = true;

			public ClusterNode(item_s ii, int index)
			{
				leaf = ii;
				idx = index;
				leafs = new int[1];
				leafs[0] = index;
				centroid = ii.coord;
				height = 0;
			}

			public ClusterNode(ClusterNode a, ClusterNode b, int index, int h, float dist, ClusterNode[] clusters)
			{
				cha = a;
				chb = b;
				idx = index;
				leafs = new int[a.leafs.Length + b.leafs.Length];
				Array.Copy(a.leafs, leafs, a.leafs.Length);
				Array.Copy(b.leafs, 0, leafs, a.leafs.Length, b.leafs.Length);
				Vector3 zero = Vector3.zero;
				for (int i = 0; i < leafs.Length; i++)
				{
					zero += clusters[leafs[i]].centroid;
				}
				centroid = zero / leafs.Length;
				height = h;
				distToMergedCentroid = dist;
			}
		}

		[Serializable]
		public class item_s
		{
			public GameObject go;

			public Vector3 coord;
		}

		public class ClusterDistance
		{
			public ClusterNode a;

			public ClusterNode b;

			public ClusterDistance(ClusterNode aa, ClusterNode bb)
			{
				a = aa;
				b = bb;
			}
		}

		public List<item_s> items = new List<item_s>();

		public ClusterNode[] clusters;

		public bool wasCanceled;

		private const int MAX_PRIORITY_Q_SIZE = 2048;

		private float euclidean_distance(Vector3 a, Vector3 b)
		{
			return Vector3.Distance(a, b);
		}

		public bool agglomerate(ProgressUpdateCancelableDelegate progFunc)
		{
			wasCanceled = true;
			if (progFunc != null)
			{
				wasCanceled = progFunc("Filling Priority Queue:", 0f);
			}
			if (items.Count <= 1)
			{
				clusters = new ClusterNode[0];
				return false;
			}
			clusters = new ClusterNode[items.Count * 2 - 1];
			for (int i = 0; i < items.Count; i++)
			{
				clusters[i] = new ClusterNode(items[i], i);
			}
			int num = items.Count;
			List<ClusterNode> list = new List<ClusterNode>();
			for (int j = 0; j < num; j++)
			{
				clusters[j].isUnclustered = true;
				list.Add(clusters[j]);
			}
			int num2 = 0;
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			float num3 = 0f;
			long num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
			PriorityQueue<float, ClusterDistance> priorityQueue = new PriorityQueue<float, ClusterDistance>();
			int num5 = 0;
			while (list.Count > 1)
			{
				int num6 = 0;
				num2++;
				if (priorityQueue.Count == 0)
				{
					num5++;
					num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
					if (progFunc != null)
					{
						wasCanceled = progFunc("Refilling Q:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
					}
					num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
					if (priorityQueue.Count == 0)
					{
						break;
					}
				}
				KeyValuePair<float, ClusterDistance> keyValuePair = priorityQueue.Dequeue();
				while (!keyValuePair.Value.a.isUnclustered || !keyValuePair.Value.b.isUnclustered)
				{
					if (priorityQueue.Count == 0)
					{
						num5++;
						num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
						if (progFunc != null)
						{
							wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
						}
						num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
						if (priorityQueue.Count == 0)
						{
							break;
						}
					}
					keyValuePair = priorityQueue.Dequeue();
					num6++;
				}
				num++;
				ClusterNode clusterNode = new ClusterNode(keyValuePair.Value.a, keyValuePair.Value.b, num - 1, num2, keyValuePair.Key, clusters);
				list.Remove(keyValuePair.Value.a);
				list.Remove(keyValuePair.Value.b);
				keyValuePair.Value.a.isUnclustered = false;
				keyValuePair.Value.b.isUnclustered = false;
				int num7 = num - 1;
				if (num7 == clusters.Length)
				{
					UnityEngine.Debug.LogError("how did this happen");
				}
				clusters[num7] = clusterNode;
				list.Add(clusterNode);
				clusterNode.isUnclustered = true;
				for (int k = 0; k < list.Count - 1; k++)
				{
					float num8 = euclidean_distance(clusterNode.centroid, list[k].centroid);
					if (num8 < num3)
					{
						priorityQueue.Add(new KeyValuePair<float, ClusterDistance>(num8, new ClusterDistance(clusterNode, list[k])));
					}
				}
				if (wasCanceled)
				{
					break;
				}
				num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
				if (progFunc != null)
				{
					wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
				}
			}
			if (progFunc != null)
			{
				wasCanceled = progFunc("Finished clustering:", 100f);
			}
			if (wasCanceled)
			{
				return false;
			}
			return true;
		}

		private float _RefillPriorityQWithSome(PriorityQueue<float, ClusterDistance> pq, List<ClusterNode> unclustered, ClusterNode[] clusters, ProgressUpdateCancelableDelegate progFunc)
		{
			List<float> list = new List<float>(2048);
			for (int i = 0; i < unclustered.Count; i++)
			{
				for (int j = i + 1; j < unclustered.Count; j++)
				{
					list.Add(euclidean_distance(unclustered[i].centroid, unclustered[j].centroid));
				}
				wasCanceled = progFunc("Refilling Queue Part A:", (float)i / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			if (list.Count == 0)
			{
				return 1E+11f;
			}
			float num = NthSmallestElement(list, 2048);
			for (int k = 0; k < unclustered.Count; k++)
			{
				for (int l = k + 1; l < unclustered.Count; l++)
				{
					int idx = unclustered[k].idx;
					int idx2 = unclustered[l].idx;
					float num2 = euclidean_distance(unclustered[k].centroid, unclustered[l].centroid);
					if (num2 <= num)
					{
						pq.Add(new KeyValuePair<float, ClusterDistance>(num2, new ClusterDistance(clusters[idx], clusters[idx2])));
					}
				}
				wasCanceled = progFunc("Refilling Queue Part B:", (float)(unclustered.Count + k) / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			return num;
		}

		public int TestRun(List<GameObject> gos)
		{
			List<item_s> list = new List<item_s>();
			for (int i = 0; i < gos.Count; i++)
			{
				item_s item_s = new item_s();
				item_s.go = gos[i];
				item_s.coord = gos[i].transform.position;
				list.Add(item_s);
			}
			items = list;
			if (items.Count > 0)
			{
				agglomerate(null);
			}
			return 0;
		}

		public static void Main()
		{
			List<float> list = new List<float>();
			list.AddRange(new float[10] { 19f, 18f, 17f, 16f, 15f, 10f, 11f, 12f, 13f, 14f });
			UnityEngine.Debug.Log("Loop quick select 10 times.");
			UnityEngine.Debug.Log(NthSmallestElement(list, 0));
		}

		public static T NthSmallestElement<T>(List<T> array, int n) where T : IComparable<T>
		{
			if (n < 0)
			{
				n = 0;
			}
			if (n > array.Count - 1)
			{
				n = array.Count - 1;
			}
			if (array.Count == 0)
			{
				throw new ArgumentException("Array is empty.", "array");
			}
			if (array.Count == 1)
			{
				return array[0];
			}
			return QuickSelectSmallest(array, n)[n];
		}

		private static List<T> QuickSelectSmallest<T>(List<T> input, int n) where T : IComparable<T>
		{
			int num = 0;
			int num2 = input.Count - 1;
			int pivotIndex = n;
			System.Random random = new System.Random();
			while (num2 > num)
			{
				pivotIndex = QuickSelectPartition(input, num, num2, pivotIndex);
				if (pivotIndex == n)
				{
					break;
				}
				if (pivotIndex > n)
				{
					num2 = pivotIndex - 1;
				}
				else
				{
					num = pivotIndex + 1;
				}
				pivotIndex = random.Next(num, num2);
			}
			return input;
		}

		private static int QuickSelectPartition<T>(List<T> array, int startIndex, int endIndex, int pivotIndex) where T : IComparable<T>
		{
			T other = array[pivotIndex];
			Swap(array, pivotIndex, endIndex);
			for (int i = startIndex; i < endIndex; i++)
			{
				if (array[i].CompareTo(other) <= 0)
				{
					Swap(array, i, startIndex);
					startIndex++;
				}
			}
			Swap(array, endIndex, startIndex);
			return startIndex;
		}

		private static void Swap<T>(List<T> array, int index1, int index2)
		{
			if (index1 != index2)
			{
				T value = array[index1];
				array[index1] = array[index2];
				array[index2] = value;
			}
		}
	}
}
public class MB3_KMeansClustering
{
	private class DataPoint
	{
		public Vector3 center;

		public GameObject gameObject;

		public int Cluster;

		public DataPoint(GameObject go)
		{
			gameObject = go;
			center = go.transform.position;
			if (go.GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("Object does not have a renderer " + go);
			}
		}
	}

	private List<DataPoint> _normalizedDataToCluster = new List<DataPoint>();

	private Vector3[] _clusters = new Vector3[0];

	private int _numberOfClusters;

	public MB3_KMeansClustering(List<GameObject> gos, int numClusters)
	{
		for (int i = 0; i < gos.Count; i++)
		{
			if (gos[i] != null)
			{
				DataPoint item = new DataPoint(gos[i]);
				_normalizedDataToCluster.Add(item);
			}
			else
			{
				UnityEngine.Debug.LogWarning($"Object {i} in list of objects to cluster was null.");
			}
		}
		if (numClusters <= 0)
		{
			UnityEngine.Debug.LogError("Number of clusters must be posititve.");
			numClusters = 1;
		}
		if (_normalizedDataToCluster.Count <= numClusters)
		{
			UnityEngine.Debug.LogError("There must be fewer clusters than objects to cluster");
			numClusters = _normalizedDataToCluster.Count - 1;
		}
		_numberOfClusters = numClusters;
		if (_numberOfClusters <= 0)
		{
			_numberOfClusters = 1;
		}
		_clusters = new Vector3[_numberOfClusters];
	}

	private void InitializeCentroids()
	{
		for (int i = 0; i < _numberOfClusters; i++)
		{
			_normalizedDataToCluster[i].Cluster = i;
		}
		for (int j = _numberOfClusters; j < _normalizedDataToCluster.Count; j++)
		{
			_normalizedDataToCluster[j].Cluster = UnityEngine.Random.Range(0, _numberOfClusters);
		}
	}

	private bool UpdateDataPointMeans(bool force)
	{
		if (AnyAreEmpty(_normalizedDataToCluster) && !force)
		{
			return false;
		}
		Vector3[] array = new Vector3[_numberOfClusters];
		int[] array2 = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			int cluster = _normalizedDataToCluster[i].Cluster;
			array[cluster] += _normalizedDataToCluster[i].center;
			array2[cluster]++;
		}
		for (int j = 0; j < _numberOfClusters; j++)
		{
			ref Vector3 reference = ref _clusters[j];
			reference = array[j] / array2[j];
		}
		return true;
	}

	private bool AnyAreEmpty(List<DataPoint> data)
	{
		int[] array = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			array[_normalizedDataToCluster[i].Cluster]++;
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] == 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool UpdateClusterMembership()
	{
		bool flag = false;
		float[] array = new float[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			for (int j = 0; j < _numberOfClusters; j++)
			{
				array[j] = ElucidanDistance(_normalizedDataToCluster[i], _clusters[j]);
			}
			int num = MinIndex(array);
			if (num != _normalizedDataToCluster[i].Cluster)
			{
				flag = true;
				_normalizedDataToCluster[i].Cluster = num;
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private float ElucidanDistance(DataPoint dataPoint, Vector3 mean)
	{
		return Vector3.Distance(dataPoint.center, mean);
	}

	private int MinIndex(float[] distances)
	{
		int result = 0;
		double num = distances[0];
		for (int i = 0; i < distances.Length; i++)
		{
			if ((double)distances[i] < num)
			{
				num = distances[i];
				result = i;
			}
		}
		return result;
	}

	public List<Renderer> GetCluster(int idx, out Vector3 mean, out float size)
	{
		if (idx < 0 || idx >= _numberOfClusters)
		{
			UnityEngine.Debug.LogError("idx is out of bounds");
			mean = Vector3.zero;
			size = 1f;
			return new List<Renderer>();
		}
		UpdateDataPointMeans(force: true);
		List<Renderer> list = new List<Renderer>();
		mean = _clusters[idx];
		float num = 0f;
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			if (_normalizedDataToCluster[i].Cluster == idx)
			{
				float num2 = Vector3.Distance(mean, _normalizedDataToCluster[i].center);
				if (num2 > num)
				{
					num = num2;
				}
				list.Add(_normalizedDataToCluster[i].gameObject.GetComponent<Renderer>());
			}
		}
		mean = _clusters[idx];
		size = num;
		return list;
	}

	public void Cluster()
	{
		bool flag = true;
		bool flag2 = true;
		InitializeCentroids();
		int num = _normalizedDataToCluster.Count * 1000;
		int num2 = 0;
		while (flag2 && flag && num2 < num)
		{
			num2++;
			flag2 = UpdateDataPointMeans(force: false);
			flag = UpdateClusterMembership();
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public class PriorityQueue<TPriority, TValue> : ICollection<KeyValuePair<TPriority, TValue>>, IEnumerable, IEnumerable<KeyValuePair<TPriority, TValue>>
	{
		public List<KeyValuePair<TPriority, TValue>> _baseHeap;

		private IComparer<TPriority> _comparer;

		public bool IsEmpty => _baseHeap.Count == 0;

		public int Count => _baseHeap.Count;

		public bool IsReadOnly => false;

		public PriorityQueue()
			: this((IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity)
			: this(capacity, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity, IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(capacity);
			_comparer = comparer;
		}

		public PriorityQueue(IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>();
			_comparer = comparer;
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data)
			: this(data, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data, IComparer<TPriority> comparer)
		{
			if (data == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			_comparer = comparer;
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(data);
			for (int num = _baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				HeapifyFromBeginningToEnd(num);
			}
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2)
		{
			if (pq1 == null || pq2 == null)
			{
				throw new ArgumentNullException();
			}
			if (pq1._comparer != pq2._comparer)
			{
				throw new InvalidOperationException("Priority queues to be merged must have equal comparers");
			}
			return MergeQueues(pq1, pq2, pq1._comparer);
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2, IComparer<TPriority> comparer)
		{
			if (pq1 == null || pq2 == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			PriorityQueue<TPriority, TValue> priorityQueue = new PriorityQueue<TPriority, TValue>(pq1.Count + pq2.Count, pq1._comparer);
			priorityQueue._baseHeap.AddRange(pq1._baseHeap);
			priorityQueue._baseHeap.AddRange(pq2._baseHeap);
			for (int num = priorityQueue._baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				priorityQueue.HeapifyFromBeginningToEnd(num);
			}
			return priorityQueue;
		}

		public void Enqueue(TPriority priority, TValue value)
		{
			Insert(priority, value);
		}

		public KeyValuePair<TPriority, TValue> Dequeue()
		{
			if (!IsEmpty)
			{
				KeyValuePair<TPriority, TValue> result = _baseHeap[0];
				DeleteRoot();
				return result;
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue DequeueValue()
		{
			return Dequeue().Value;
		}

		public KeyValuePair<TPriority, TValue> Peek()
		{
			if (!IsEmpty)
			{
				return _baseHeap[0];
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue PeekValue()
		{
			return Peek().Value;
		}

		private void ExchangeElements(int pos1, int pos2)
		{
			KeyValuePair<TPriority, TValue> value = _baseHeap[pos1];
			_baseHeap[pos1] = _baseHeap[pos2];
			_baseHeap[pos2] = value;
		}

		private void Insert(TPriority priority, TValue value)
		{
			KeyValuePair<TPriority, TValue> item = new KeyValuePair<TPriority, TValue>(priority, value);
			_baseHeap.Add(item);
			HeapifyFromEndToBeginning(_baseHeap.Count - 1);
		}

		private int HeapifyFromEndToBeginning(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return -1;
			}
			while (pos > 0)
			{
				int num = (pos - 1) / 2;
				if (_comparer.Compare(_baseHeap[num].Key, _baseHeap[pos].Key) > 0)
				{
					ExchangeElements(num, pos);
					pos = num;
					continue;
				}
				break;
			}
			return pos;
		}

		private void DeleteRoot()
		{
			if (_baseHeap.Count <= 1)
			{
				_baseHeap.Clear();
				return;
			}
			_baseHeap[0] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			HeapifyFromBeginningToEnd(0);
		}

		private void HeapifyFromBeginningToEnd(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return;
			}
			while (true)
			{
				int num = pos;
				int num2 = 2 * pos + 1;
				int num3 = 2 * pos + 2;
				if (num2 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num2].Key) > 0)
				{
					num = num2;
				}
				if (num3 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num3].Key) > 0)
				{
					num = num3;
				}
				if (num != pos)
				{
					ExchangeElements(num, pos);
					pos = num;
					continue;
				}
				break;
			}
		}

		public void Add(KeyValuePair<TPriority, TValue> item)
		{
			Enqueue(item.Key, item.Value);
		}

		public void Clear()
		{
			_baseHeap.Clear();
		}

		public bool Contains(KeyValuePair<TPriority, TValue> item)
		{
			return _baseHeap.Contains(item);
		}

		public bool TryFindValue(TPriority item, out TValue foundVersion)
		{
			for (int i = 0; i < _baseHeap.Count; i++)
			{
				if (_comparer.Compare(item, _baseHeap[i].Key) == 0)
				{
					foundVersion = _baseHeap[i].Value;
					return true;
				}
			}
			foundVersion = default(TValue);
			return false;
		}

		public void CopyTo(KeyValuePair<TPriority, TValue>[] array, int arrayIndex)
		{
			_baseHeap.CopyTo(array, arrayIndex);
		}

		public bool Remove(KeyValuePair<TPriority, TValue> item)
		{
			int num = _baseHeap.IndexOf(item);
			if (num < 0)
			{
				return false;
			}
			_baseHeap[num] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			int num2 = HeapifyFromEndToBeginning(num);
			if (num2 == num)
			{
				HeapifyFromBeginningToEnd(num);
			}
			return true;
		}

		public IEnumerator<KeyValuePair<TPriority, TValue>> GetEnumerator()
		{
			return _baseHeap.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public struct DRect
	{
		public double x;

		public double y;

		public double width;

		public double height;

		public Vector2 min => new Vector2((float)x, (float)y);

		public Vector2 max => new Vector2((float)(x + width), (float)(y + width));

		public Vector2 size => new Vector2((float)width, (float)width);

		public DRect(Rect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(Vector2 o, Vector2 s)
		{
			x = o.x;
			y = o.y;
			width = s.x;
			height = s.y;
		}

		public DRect(float xx, float yy, float w, float h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public DRect(double xx, double yy, double w, double h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public Rect GetRect()
		{
			return new Rect((float)x, (float)y, (float)width, (float)height);
		}

		public override bool Equals(object obj)
		{
			DRect dRect = (DRect)obj;
			if (dRect.x == x && dRect.y == y && dRect.width == width && dRect.height == height)
			{
				return true;
			}
			return false;
		}

		public static bool operator ==(DRect a, DRect b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(DRect a, DRect b)
		{
			return !a.Equals(b);
		}

		public override string ToString()
		{
			return string.Format("(x={0},y={1},w={2},h={3})", x.ToString("F5"), y.ToString("F5"), width.ToString("F5"), height.ToString("F5"));
		}

		public bool Encloses(DRect smallToTestIfFits)
		{
			double num = smallToTestIfFits.x;
			double num2 = smallToTestIfFits.y;
			double num3 = smallToTestIfFits.x + smallToTestIfFits.width;
			double num4 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num5 = x;
			double num6 = y;
			double num7 = x + width;
			double num8 = y + height;
			return num5 <= num && num <= num7 && num5 <= num3 && num3 <= num7 && num6 <= num2 && num2 <= num8 && num6 <= num4 && num4 <= num8;
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode() ^ width.GetHashCode() ^ height.GetHashCode();
		}
	}
	public class MB3_UVTransformUtility
	{
		public static void Test()
		{
			DRect t = new DRect(0.5, 0.5, 2.0, 2.0);
			DRect t2 = new DRect(0.25, 0.25, 3.0, 3.0);
			DRect r = InverseTransform(ref t);
			DRect r2 = InverseTransform(ref t2);
			DRect r3 = CombineTransforms(ref t, ref r2);
			UnityEngine.Debug.Log(r);
			UnityEngine.Debug.Log(r3);
			UnityEngine.Debug.Log("one mat trans " + TransformPoint(ref t, new Vector2(1f, 1f)));
			UnityEngine.Debug.Log("one inv mat trans " + TransformPoint(ref r, new Vector2(1f, 1f)).ToString("f4"));
			UnityEngine.Debug.Log("zero " + TransformPoint(ref r3, new Vector2(0f, 0f)).ToString("f4"));
			UnityEngine.Debug.Log("one " + TransformPoint(ref r3, new Vector2(1f, 1f)).ToString("f4"));
		}

		public static float TransformX(DRect r, double x)
		{
			return (float)(r.width * x + r.x);
		}

		public static DRect CombineTransforms(ref DRect r1, ref DRect r2)
		{
			return new DRect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static Rect CombineTransforms(ref Rect r1, ref Rect r2)
		{
			return new Rect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static void Canonicalize(ref DRect r, double minX, double minY)
		{
			r.x -= Mathf.FloorToInt((float)r.x);
			if (r.x < minX)
			{
				r.x += Mathf.CeilToInt((float)minX);
			}
			r.y -= Mathf.FloorToInt((float)r.y);
			if (r.y < minY)
			{
				r.y += Mathf.CeilToInt((float)minY);
			}
		}

		public static void Canonicalize(ref Rect r, float minX, float minY)
		{
			r.x -= Mathf.FloorToInt(r.x);
			if (r.x < minX)
			{
				r.x += Mathf.CeilToInt(minX);
			}
			r.y -= Mathf.FloorToInt(r.y);
			if (r.y < minY)
			{
				r.y += Mathf.CeilToInt(minY);
			}
		}

		public static DRect InverseTransform(ref DRect t)
		{
			DRect result = default(DRect);
			result.x = (0.0 - t.x) / t.width;
			result.y = (0.0 - t.y) / t.height;
			result.width = 1.0 / t.width;
			result.height = 1.0 / t.height;
			return result;
		}

		public static DRect GetEncapsulatingRect(ref DRect uvRect1, ref DRect uvRect2)
		{
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num = uvRect1.x + uvRect1.width;
			double num2 = uvRect1.y + uvRect1.height;
			double x2 = uvRect2.x;
			double y2 = uvRect2.y;
			double num3 = uvRect2.x + uvRect2.width;
			double num4 = uvRect2.y + uvRect2.height;
			double num5;
			double num6 = (num5 = x);
			double num7;
			double num8 = (num7 = y);
			if (x2 < num6)
			{
				num6 = x2;
			}
			if (x < num6)
			{
				num6 = x;
			}
			if (y2 < num8)
			{
				num8 = y2;
			}
			if (y < num8)
			{
				num8 = y;
			}
			if (num3 > num5)
			{
				num5 = num3;
			}
			if (num > num5)
			{
				num5 = num;
			}
			if (num4 > num7)
			{
				num7 = num4;
			}
			if (num2 > num7)
			{
				num7 = num2;
			}
			return new DRect(num6, num8, num5 - num6, num7 - num8);
		}

		public static bool RectContains(ref DRect bigRect, ref DRect smallToTestIfFits)
		{
			double x = smallToTestIfFits.x;
			double y = smallToTestIfFits.y;
			double num = smallToTestIfFits.x + smallToTestIfFits.width;
			double num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num3 = bigRect.x - 0.009999999776482582;
			double num4 = bigRect.y - 0.009999999776482582;
			double num5 = bigRect.x + bigRect.width + 0.019999999552965164;
			double num6 = bigRect.y + bigRect.height + 0.019999999552965164;
			return num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2 && num2 <= num6;
		}

		public static bool RectContains(ref Rect bigRect, ref Rect smallToTestIfFits)
		{
			float x = smallToTestIfFits.x;
			float y = smallToTestIfFits.y;
			float num = smallToTestIfFits.x + smallToTestIfFits.width;
			float num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			float num3 = bigRect.x - 0.01f;
			float num4 = bigRect.y - 0.01f;
			float num5 = bigRect.x + bigRect.width + 0.02f;
			float num6 = bigRect.y + bigRect.height + 0.02f;
			return num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2 && num2 <= num6;
		}

		internal static Vector2 TransformPoint(ref DRect r, Vector2 p)
		{
			return new Vector2((float)(r.width * (double)p.x + r.x), (float)(r.height * (double)p.y + r.y));
		}
	}
	public static class MB_TGAWriter
	{
		public static void Write(UnityEngine.Color[] pixels, int width, int height, string path)
		{
			if (File.Exists(path))
			{
				File.Delete(path);
			}
			FileStream output = File.Create(path);
			Write(pixels, width, height, output);
		}

		public static void Write(UnityEngine.Color[] pixels, int width, int height, Stream output)
		{
			byte[] array = new byte[pixels.Length * 4];
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < height; i++)
			{
				for (int j = 0; j < width; j++)
				{
					UnityEngine.Color color = pixels[num];
					array[num2] = (byte)(color.b * 255f);
					array[num2 + 1] = (byte)(color.g * 255f);
					array[num2 + 2] = (byte)(color.r * 255f);
					array[num2 + 3] = (byte)(color.a * 255f);
					num++;
					num2 += 4;
				}
			}
			byte[] buffer = new byte[18]
			{
				0,
				0,
				2,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				(byte)((uint)width & 0xFFu),
				(byte)((width & 0xFF00) >> 8),
				(byte)((uint)height & 0xFFu),
				(byte)((height & 0xFF00) >> 8),
				32,
				0
			};
			using BinaryWriter binaryWriter = new BinaryWriter(output);
			binaryWriter.Write(buffer);
			binaryWriter.Write(array);
		}
	}
}
public class OVRBoundary
{
	public enum Node
	{
		HandLeft = 3,
		HandRight = 4,
		Head = 9
	}

	public enum BoundaryType
	{
		OuterBoundary = 1,
		PlayArea = 0x100
	}

	public struct BoundaryTestResult
	{
		public bool IsTriggering;

		public float ClosestDistance;

		public Vector3 ClosestPoint;

		public Vector3 ClosestPointNormal;
	}

	public struct BoundaryLookAndFeel
	{
		public UnityEngine.Color Color;
	}

	private static int cachedVector3fSize = Marshal.SizeOf(typeof(OVRPlugin.Vector3f));

	private static OVRNativeBuffer cachedGeometryNativeBuffer = new OVRNativeBuffer(0);

	private static float[] cachedGeometryManagedBuffer = new float[0];

	public bool GetConfigured()
	{
		return OVRPlugin.GetBoundaryConfigured();
	}

	public BoundaryTestResult TestNode(Node node, BoundaryType boundaryType)
	{
		OVRPlugin.BoundaryTestResult boundaryTestResult = OVRPlugin.TestBoundaryNode((OVRPlugin.Node)node, (OVRPlugin.BoundaryType)boundaryType);
		BoundaryTestResult result = default(BoundaryTestResult);
		result.IsTriggering = boundaryTestResult.IsTriggering == OVRPlugin.Bool.True;
		result.ClosestDistance = boundaryTestResult.ClosestDistance;
		result.ClosestPoint = boundaryTestResult.ClosestPoint.FromFlippedZVector3f();
		result.ClosestPointNormal = boundaryTestResult.ClosestPointNormal.FromFlippedZVector3f();
		return result;
	}

	public BoundaryTestResult TestPoint(Vector3 point, BoundaryType boundaryType)
	{
		OVRPlugin.BoundaryTestResult boundaryTestResult = OVRPlugin.TestBoundaryPoint(point.ToFlippedZVector3f(), (OVRPlugin.BoundaryType)boundaryType);
		BoundaryTestResult result = default(BoundaryTestResult);
		result.IsTriggering = boundaryTestResult.IsTriggering == OVRPlugin.Bool.True;
		result.ClosestDistance = boundaryTestResult.ClosestDistance;
		result.ClosestPoint = boundaryTestResult.ClosestPoint.FromFlippedZVector3f();
		result.ClosestPointNormal = boundaryTestResult.ClosestPointNormal.FromFlippedZVector3f();
		return result;
	}

	public void SetLookAndFeel(BoundaryLookAndFeel lookAndFeel)
	{
		OVRPlugin.BoundaryLookAndFeel boundaryLookAndFeel = default(OVRPlugin.BoundaryLookAndFeel);
		boundaryLookAndFeel.Color = lookAndFeel.Color.ToColorf();
		OVRPlugin.BoundaryLookAndFeel boundaryLookAndFeel2 = boundaryLookAndFeel;
		OVRPlugin.SetBoundaryLookAndFeel(boundaryLookAndFeel2);
	}

	public void ResetLookAndFeel()
	{
		OVRPlugin.ResetBoundaryLookAndFeel();
	}

	public Vector3[] GetGeometry(BoundaryType boundaryType)
	{
		int pointsCount = 0;
		if (OVRPlugin.GetBoundaryGeometry2((OVRPlugin.BoundaryType)boundaryType, IntPtr.Zero, ref pointsCount) && pointsCount > 0)
		{
			int num = pointsCount * cachedVector3fSize;
			if (cachedGeometryNativeBuffer.GetCapacity() < num)
			{
				cachedGeometryNativeBuffer.Reset(num);
			}
			int num2 = pointsCount * 3;
			if (cachedGeometryManagedBuffer.Length < num2)
			{
				cachedGeometryManagedBuffer = new float[num2];
			}
			if (OVRPlugin.GetBoundaryGeometry2((OVRPlugin.BoundaryType)boundaryType, cachedGeometryNativeBuffer.GetPointer(), ref pointsCount))
			{
				Marshal.Copy(cachedGeometryNativeBuffer.GetPointer(), cachedGeometryManagedBuffer, 0, num2);
				Vector3[] array = new Vector3[pointsCount];
				for (int i = 0; i < pointsCount; i++)
				{
					ref Vector3 reference = ref array[i];
					reference = new OVRPlugin.Vector3f
					{
						x = cachedGeometryManagedBuffer[3 * i],
						y = cachedGeometryManagedBuffer[3 * i + 1],
						z = cachedGeometryManagedBuffer[3 * i + 2]
					}.FromFlippedZVector3f();
				}
				return array;
			}
		}
		return new Vector3[0];
	}

	public Vector3 GetDimensions(BoundaryType boundaryType)
	{
		return OVRPlugin.GetBoundaryDimensions((OVRPlugin.BoundaryType)boundaryType).FromVector3f();
	}

	public bool GetVisible()
	{
		return OVRPlugin.GetBoundaryVisible();
	}

	public void SetVisible(bool value)
	{
		OVRPlugin.SetBoundaryVisible(value);
	}
}
[ExecuteInEditMode]
public class OVRCameraRig : UnityEngine.MonoBehaviour
{
	public bool usePerEyeCameras;

	public bool useFixedUpdateForTracking;

	protected bool _skipUpdate;

	protected readonly string trackingSpaceName = "TrackingSpace";

	protected readonly string trackerAnchorName = "TrackerAnchor";

	protected readonly string leftEyeAnchorName = "LeftEyeAnchor";

	protected readonly string centerEyeAnchorName = "CenterEyeAnchor";

	protected readonly string rightEyeAnchorName = "RightEyeAnchor";

	protected readonly string leftHandAnchorName = "LeftHandAnchor";

	protected readonly string rightHandAnchorName = "RightHandAnchor";

	protected Camera _centerEyeCamera;

	protected Camera _leftEyeCamera;

	protected Camera _rightEyeCamera;

	public Camera leftEyeCamera => (!usePerEyeCameras) ? _centerEyeCamera : _leftEyeCamera;

	public Camera rightEyeCamera => (!usePerEyeCameras) ? _centerEyeCamera : _rightEyeCamera;

	public Transform trackingSpace { get; private set; }

	public Transform leftEyeAnchor { get; private set; }

	public Transform centerEyeAnchor { get; private set; }

	public Transform rightEyeAnchor { get; private set; }

	public Transform leftHandAnchor { get; private set; }

	public Transform rightHandAnchor { get; private set; }

	public Transform trackerAnchor { get; private set; }

	public event Action<OVRCameraRig> UpdatedAnchors;

	protected virtual void Awake()
	{
		_skipUpdate = true;
		EnsureGameObjectIntegrity();
	}

	protected virtual void Start()
	{
		UpdateAnchors();
	}

	protected virtual void FixedUpdate()
	{
		if (useFixedUpdateForTracking)
		{
			UpdateAnchors();
		}
	}

	protected virtual void Update()
	{
		_skipUpdate = false;
		if (!useFixedUpdateForTracking)
		{
			UpdateAnchors();
		}
	}

	protected virtual void UpdateAnchors()
	{
		EnsureGameObjectIntegrity();
		if (UnityEngine.Application.isPlaying)
		{
			if (_skipUpdate)
			{
				centerEyeAnchor.FromOVRPose(OVRPose.identity, isLocal: true);
				leftEyeAnchor.FromOVRPose(OVRPose.identity, isLocal: true);
				rightEyeAnchor.FromOVRPose(OVRPose.identity, isLocal: true);
				return;
			}
			bool monoscopic = OVRManager.instance.monoscopic;
			OVRPose pose = OVRManager.tracker.GetPose();
			trackerAnchor.localRotation = pose.orientation;
			centerEyeAnchor.localRotation = InputTracking.GetLocalRotation(VRNode.CenterEye);
			leftEyeAnchor.localRotation = ((!monoscopic) ? InputTracking.GetLocalRotation(VRNode.LeftEye) : centerEyeAnchor.localRotation);
			rightEyeAnchor.localRotation = ((!monoscopic) ? InputTracking.GetLocalRotation(VRNode.RightEye) : centerEyeAnchor.localRotation);
			leftHandAnchor.localRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch);
			rightHandAnchor.localRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch);
			trackerAnchor.localPosition = pose.position;
			centerEyeAnchor.localPosition = InputTracking.GetLocalPosition(VRNode.CenterEye);
			leftEyeAnchor.localPosition = ((!monoscopic) ? InputTracking.GetLocalPosition(VRNode.LeftEye) : centerEyeAnchor.localPosition);
			rightEyeAnchor.localPosition = ((!monoscopic) ? InputTracking.GetLocalPosition(VRNode.RightEye) : centerEyeAnchor.localPosition);
			leftHandAnchor.localPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch);
			rightHandAnchor.localPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch);
			RaiseUpdatedAnchorsEvent();
		}
	}

	protected virtual void RaiseUpdatedAnchorsEvent()
	{
		if (this.UpdatedAnchors != null)
		{
			this.UpdatedAnchors(this);
		}
	}

	public virtual void EnsureGameObjectIntegrity()
	{
		if (trackingSpace == null)
		{
			trackingSpace = ConfigureAnchor(null, trackingSpaceName);
		}
		if (leftEyeAnchor == null)
		{
			leftEyeAnchor = ConfigureAnchor(trackingSpace, leftEyeAnchorName);
		}
		if (centerEyeAnchor == null)
		{
			centerEyeAnchor = ConfigureAnchor(trackingSpace, centerEyeAnchorName);
		}
		if (rightEyeAnchor == null)
		{
			rightEyeAnchor = ConfigureAnchor(trackingSpace, rightEyeAnchorName);
		}
		if (leftHandAnchor == null)
		{
			leftHandAnchor = ConfigureAnchor(trackingSpace, leftHandAnchorName);
		}
		if (rightHandAnchor == null)
		{
			rightHandAnchor = ConfigureAnchor(trackingSpace, rightHandAnchorName);
		}
		if (trackerAnchor == null)
		{
			trackerAnchor = ConfigureAnchor(trackingSpace, trackerAnchorName);
		}
		if (_centerEyeCamera == null || _leftEyeCamera == null || _rightEyeCamera == null)
		{
			_centerEyeCamera = centerEyeAnchor.GetComponent<Camera>();
			_leftEyeCamera = leftEyeAnchor.GetComponent<Camera>();
			_rightEyeCamera = rightEyeAnchor.GetComponent<Camera>();
			if (_centerEyeCamera == null)
			{
				_centerEyeCamera = centerEyeAnchor.gameObject.AddComponent<Camera>();
				_centerEyeCamera.tag = "MainCamera";
			}
			if (_leftEyeCamera == null)
			{
				_leftEyeCamera = leftEyeAnchor.gameObject.AddComponent<Camera>();
				_leftEyeCamera.tag = "MainCamera";
			}
			if (_rightEyeCamera == null)
			{
				_rightEyeCamera = rightEyeAnchor.gameObject.AddComponent<Camera>();
				_rightEyeCamera.tag = "MainCamera";
			}
			_centerEyeCamera.stereoTargetEye = StereoTargetEyeMask.Both;
			_leftEyeCamera.stereoTargetEye = StereoTargetEyeMask.Left;
			_rightEyeCamera.stereoTargetEye = StereoTargetEyeMask.Right;
		}
		if (_centerEyeCamera.enabled == usePerEyeCameras || _leftEyeCamera.enabled == !usePerEyeCameras || _rightEyeCamera.enabled == !usePerEyeCameras)
		{
			_skipUpdate = true;
		}
		_centerEyeCamera.enabled = !usePerEyeCameras;
		_leftEyeCamera.enabled = usePerEyeCameras;
		_rightEyeCamera.enabled = usePerEyeCameras;
	}

	protected virtual Transform ConfigureAnchor(Transform root, string name)
	{
		Transform transform = ((!(root != null)) ? null : base.transform.Find(root.name + "/" + name));
		if (transform == null)
		{
			transform = base.transform.Find(name);
		}
		if (transform == null)
		{
			transform = new GameObject(name).transform;
		}
		transform.name = name;
		transform.parent = ((!(root != null)) ? base.transform : root);
		transform.localScale = Vector3.one;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		return transform;
	}

	public virtual Matrix4x4 ComputeTrackReferenceMatrix()
	{
		if (centerEyeAnchor == null)
		{
			UnityEngine.Debug.LogError("centerEyeAnchor is required");
			return Matrix4x4.identity;
		}
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(VRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(VRNode.Head);
		OVRPose oVRPose2 = oVRPose.Inverse();
		Matrix4x4 matrix4x = Matrix4x4.TRS(oVRPose2.position, oVRPose2.orientation, Vector3.one);
		return centerEyeAnchor.localToWorldMatrix * matrix4x;
	}
}
public static class OVRExtensions
{
	public static OVRPose ToTrackingSpacePose(this Transform transform, Camera camera)
	{
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(VRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(VRNode.Head);
		return oVRPose * transform.ToHeadSpacePose(camera);
	}

	public static OVRPose ToWorldSpacePose(OVRPose trackingSpacePose)
	{
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(VRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(VRNode.Head);
		OVRPose oVRPose2 = oVRPose.Inverse() * trackingSpacePose;
		return Camera.main.transform.ToOVRPose() * oVRPose2;
	}

	public static OVRPose ToHeadSpacePose(this Transform transform, Camera camera)
	{
		return camera.transform.ToOVRPose().Inverse() * transform.ToOVRPose();
	}

	internal static OVRPose ToOVRPose(this Transform t, bool isLocal = false)
	{
		OVRPose result = default(OVRPose);
		result.orientation = ((!isLocal) ? t.rotation : t.localRotation);
		result.position = ((!isLocal) ? t.position : t.localPosition);
		return result;
	}

	internal static void FromOVRPose(this Transform t, OVRPose pose, bool isLocal = false)
	{
		if (isLocal)
		{
			t.localRotation = pose.orientation;
			t.localPosition = pose.position;
		}
		else
		{
			t.rotation = pose.orientation;
			t.position = pose.position;
		}
	}

	internal static OVRPose ToOVRPose(this OVRPlugin.Posef p)
	{
		OVRPose result = default(OVRPose);
		result.position = new Vector3(p.Position.x, p.Position.y, 0f - p.Position.z);
		result.orientation = new Quaternion(0f - p.Orientation.x, 0f - p.Orientation.y, p.Orientation.z, p.Orientation.w);
		return result;
	}

	internal static OVRTracker.Frustum ToFrustum(this OVRPlugin.Frustumf f)
	{
		OVRTracker.Frustum result = default(OVRTracker.Frustum);
		result.nearZ = f.zNear;
		result.farZ = f.zFar;
		result.fov = new Vector2
		{
			x = 57.29578f * f.fovX,
			y = 57.29578f * f.fovY
		};
		return result;
	}

	internal static UnityEngine.Color FromColorf(this OVRPlugin.Colorf c)
	{
		UnityEngine.Color result = default(UnityEngine.Color);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static OVRPlugin.Colorf ToColorf(this UnityEngine.Color c)
	{
		OVRPlugin.Colorf result = default(OVRPlugin.Colorf);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static Vector3 FromVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static Vector3 FromFlippedZVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToFlippedZVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static Quaternion FromQuatf(this OVRPlugin.Quatf q)
	{
		Quaternion result = default(Quaternion);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static Quaternion FromFlippedZQuatf(this OVRPlugin.Quatf q)
	{
		Quaternion result = default(Quaternion);
		result.x = 0f - q.x;
		result.y = 0f - q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static OVRPlugin.Quatf ToQuatf(this Quaternion q)
	{
		OVRPlugin.Quatf result = default(OVRPlugin.Quatf);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static OVRPlugin.Quatf ToFlippedZQuatf(this Quaternion q)
	{
		OVRPlugin.Quatf result = default(OVRPlugin.Quatf);
		result.x = 0f - q.x;
		result.y = 0f - q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}
}
[Serializable]
public struct OVRPose
{
	public Vector3 position;

	public Quaternion orientation;

	public static OVRPose identity
	{
		get
		{
			OVRPose result = default(OVRPose);
			result.position = Vector3.zero;
			result.orientation = Quaternion.identity;
			return result;
		}
	}

	public override bool Equals(object obj)
	{
		return obj is OVRPose && this == (OVRPose)obj;
	}

	public override int GetHashCode()
	{
		return position.GetHashCode() ^ orientation.GetHashCode();
	}

	public static bool operator ==(OVRPose x, OVRPose y)
	{
		return x.position == y.position && x.orientation == y.orientation;
	}

	public static bool operator !=(OVRPose x, OVRPose y)
	{
		return !(x == y);
	}

	public static OVRPose operator *(OVRPose lhs, OVRPose rhs)
	{
		OVRPose result = default(OVRPose);
		result.position = lhs.position + lhs.orientation * rhs.position;
		result.orientation = lhs.orientation * rhs.orientation;
		return result;
	}

	public OVRPose Inverse()
	{
		OVRPose result = default(OVRPose);
		result.orientation = Quaternion.Inverse(orientation);
		result.position = result.orientation * -position;
		return result;
	}

	internal OVRPose flipZ()
	{
		OVRPose result = this;
		result.position.z = 0f - result.position.z;
		result.orientation.z = 0f - result.orientation.z;
		result.orientation.w = 0f - result.orientation.w;
		return result;
	}

	internal OVRPlugin.Posef ToPosef()
	{
		OVRPlugin.Posef result = default(OVRPlugin.Posef);
		result.Position = position.ToVector3f();
		result.Orientation = orientation.ToQuatf();
		return result;
	}
}
public class OVRNativeBuffer : IDisposable
{
	private bool disposed;

	private int m_numBytes;

	private IntPtr m_ptr = IntPtr.Zero;

	public OVRNativeBuffer(int numBytes)
	{
		Reallocate(numBytes);
	}

	~OVRNativeBuffer()
	{
		Dispose(disposing: false);
	}

	public void Reset(int numBytes)
	{
		Reallocate(numBytes);
	}

	public int GetCapacity()
	{
		return m_numBytes;
	}

	public IntPtr GetPointer(int byteOffset = 0)
	{
		if (byteOffset < 0 || byteOffset >= m_numBytes)
		{
			return IntPtr.Zero;
		}
		return (byteOffset != 0) ? new IntPtr(m_ptr.ToInt64() + byteOffset) : m_ptr;
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	private void Dispose(bool disposing)
	{
		if (!disposed)
		{
			if (disposing)
			{
			}
			Release();
			disposed = true;
		}
	}

	private void Reallocate(int numBytes)
	{
		Release();
		if (numBytes > 0)
		{
			m_ptr = Marshal.AllocHGlobal(numBytes);
			m_numBytes = numBytes;
		}
		else
		{
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}

	private void Release()
	{
		if (m_ptr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(m_ptr);
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}
}
public class OVRDebugHeadController : UnityEngine.MonoBehaviour
{
	[SerializeField]
	public bool AllowPitchLook;

	[SerializeField]
	public bool AllowYawLook = true;

	[SerializeField]
	public bool InvertPitch;

	[SerializeField]
	public float GamePad_PitchDegreesPerSec = 90f;

	[SerializeField]
	public float GamePad_YawDegreesPerSec = 90f;

	[SerializeField]
	public bool AllowMovement;

	[SerializeField]
	public float ForwardSpeed = 2f;

	[SerializeField]
	public float StrafeSpeed = 2f;

	protected OVRCameraRig CameraRig;

	private void Awake()
	{
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRCamParent: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRCamParent: More then 1 OVRCameraRig attached.");
		}
		else
		{
			CameraRig = componentsInChildren[0];
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (AllowMovement)
		{
			float y = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick).y;
			float x = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick).x;
			Vector3 vector = CameraRig.centerEyeAnchor.rotation * Vector3.forward * y * Time.deltaTime * ForwardSpeed;
			Vector3 vector2 = CameraRig.centerEyeAnchor.rotation * Vector3.right * x * Time.deltaTime * StrafeSpeed;
			base.transform.position += vector + vector2;
		}
		if (VRDevice.isPresent || (!AllowYawLook && !AllowPitchLook))
		{
			return;
		}
		Quaternion quaternion = base.transform.rotation;
		if (AllowYawLook)
		{
			float x2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick).x;
			float angle = x2 * Time.deltaTime * GamePad_YawDegreesPerSec;
			Quaternion quaternion2 = Quaternion.AngleAxis(angle, Vector3.up);
			quaternion = quaternion2 * quaternion;
		}
		if (AllowPitchLook)
		{
			float num = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick).y;
			if (Mathf.Abs(num) > 0.0001f)
			{
				if (InvertPitch)
				{
					num *= -1f;
				}
				float angle2 = num * Time.deltaTime * GamePad_PitchDegreesPerSec;
				Quaternion quaternion3 = Quaternion.AngleAxis(angle2, Vector3.left);
				quaternion *= quaternion3;
			}
		}
		base.transform.rotation = quaternion;
	}
}
public class OVRDisplay
{
	public struct EyeRenderDesc
	{
		public Vector2 resolution;

		public Vector2 fov;
	}

	public struct LatencyData
	{
		public float render;

		public float timeWarp;

		public float postPresent;

		public float renderError;

		public float timeWarpError;
	}

	private bool needsConfigureTexture;

	private EyeRenderDesc[] eyeDescs = new EyeRenderDesc[2];

	private bool recenterRequested;

	private int recenterRequestedFrameCount = int.MaxValue;

	public Vector3 acceleration
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.None, OVRPlugin.Step.Render).FromFlippedZVector3f();
		}
	}

	public Vector3 angularAcceleration
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeAngularAcceleration(OVRPlugin.Node.None, OVRPlugin.Step.Render).FromFlippedZVector3f() * 57.29578f;
		}
	}

	public Vector3 velocity
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.None, OVRPlugin.Step.Render).FromFlippedZVector3f();
		}
	}

	public Vector3 angularVelocity
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeAngularVelocity(OVRPlugin.Node.None, OVRPlugin.Step.Render).FromFlippedZVector3f() * 57.29578f;
		}
	}

	public LatencyData latency
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return default(LatencyData);
			}
			string input = OVRPlugin.latency;
			Regex regex = new Regex("Render: ([0-9]+[.][0-9]+)ms, TimeWarp: ([0-9]+[.][0-9]+)ms, PostPresent: ([0-9]+[.][0-9]+)ms", RegexOptions.None);
			LatencyData result = default(LatencyData);
			Match match = regex.Match(input);
			if (match.Success)
			{
				result.render = float.Parse(match.Groups[1].Value);
				result.timeWarp = float.Parse(match.Groups[2].Value);
				result.postPresent = float.Parse(match.Groups[3].Value);
			}
			return result;
		}
	}

	public float appFramerate
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.GetAppFramerate();
		}
	}

	public int recommendedMSAALevel
	{
		get
		{
			int num = OVRPlugin.recommendedMSAALevel;
			if (num == 1)
			{
				num = 0;
			}
			return num;
		}
	}

	public float[] displayFrequenciesAvailable => OVRPlugin.systemDisplayFrequenciesAvailable;

	public float displayFrequency
	{
		get
		{
			return OVRPlugin.systemDisplayFrequency;
		}
		set
		{
			OVRPlugin.systemDisplayFrequency = value;
		}
	}

	public event Action RecenteredPose;

	public OVRDisplay()
	{
		UpdateTextures();
	}

	public void Update()
	{
		UpdateTextures();
		if (recenterRequested && Time.frameCount > recenterRequestedFrameCount)
		{
			if (this.RecenteredPose != null)
			{
				this.RecenteredPose();
			}
			recenterRequested = false;
			recenterRequestedFrameCount = int.MaxValue;
		}
	}

	public void RecenterPose()
	{
		InputTracking.Recenter();
		recenterRequested = true;
		recenterRequestedFrameCount = Time.frameCount;
	}

	public EyeRenderDesc GetEyeRenderDesc(VRNode eye)
	{
		return eyeDescs[(int)eye];
	}

	private void UpdateTextures()
	{
		ConfigureEyeDesc(VRNode.LeftEye);
		ConfigureEyeDesc(VRNode.RightEye);
	}

	private void ConfigureEyeDesc(VRNode eye)
	{
		if (OVRManager.isHmdPresent)
		{
			OVRPlugin.Sizei eyeTextureSize = OVRPlugin.GetEyeTextureSize((OVRPlugin.Eye)eye);
			OVRPlugin.Frustumf eyeFrustum = OVRPlugin.GetEyeFrustum((OVRPlugin.Eye)eye);
			ref EyeRenderDesc reference = ref eyeDescs[(int)eye];
			reference = new EyeRenderDesc
			{
				resolution = new Vector2(eyeTextureSize.w, eyeTextureSize.h),
				fov = 57.29578f * new Vector2(eyeFrustum.fovX, eyeFrustum.fovY)
			};
		}
	}
}
public static class OVRHaptics
{
	public static class Config
	{
		public static int SampleRateHz { get; private set; }

		public static int SampleSizeInBytes { get; private set; }

		public static int MinimumSafeSamplesQueued { get; private set; }

		public static int MinimumBufferSamplesCount { get; private set; }

		public static int OptimalBufferSamplesCount { get; private set; }

		public static int MaximumBufferSamplesCount { get; private set; }

		static Config()
		{
			Load();
		}

		public static void Load()
		{
			OVRPlugin.HapticsDesc controllerHapticsDesc = OVRPlugin.GetControllerHapticsDesc(2u);
			SampleRateHz = controllerHapticsDesc.SampleRateHz;
			SampleSizeInBytes = controllerHapticsDesc.SampleSizeInBytes;
			MinimumSafeSamplesQueued = controllerHapticsDesc.MinimumSafeSamplesQueued;
			MinimumBufferSamplesCount = controllerHapticsDesc.MinimumBufferSamplesCount;
			OptimalBufferSamplesCount = controllerHapticsDesc.OptimalBufferSamplesCount;
			MaximumBufferSamplesCount = controllerHapticsDesc.MaximumBufferSamplesCount;
		}
	}

	public class OVRHapticsChannel
	{
		private OVRHapticsOutput m_output;

		public OVRHapticsChannel(uint outputIndex)
		{
			m_output = m_outputs[outputIndex];
		}

		public void Preempt(OVRHapticsClip clip)
		{
			m_output.Preempt(clip);
		}

		public void Queue(OVRHapticsClip clip)
		{
			m_output.Queue(clip);
		}

		public void Mix(OVRHapticsClip clip)
		{
			m_output.Mix(clip);
		}

		public void Clear()
		{
			m_output.Clear();
		}
	}

	private class OVRHapticsOutput
	{
		private class ClipPlaybackTracker
		{
			public int ReadCount { get; set; }

			public OVRHapticsClip Clip { get; set; }

			public ClipPlaybackTracker(OVRHapticsClip clip)
			{
				Clip = clip;
			}
		}

		private bool m_lowLatencyMode = true;

		private int m_prevSamplesQueued;

		private float m_prevSamplesQueuedTime;

		private int m_numPredictionHits;

		private int m_numPredictionMisses;

		private int m_numUnderruns;

		private List<ClipPlaybackTracker> m_pendingClips = new List<ClipPlaybackTracker>();

		private uint m_controller;

		private OVRNativeBuffer m_nativeBuffer = new OVRNativeBuffer(Config.MaximumBufferSamplesCount * Config.SampleSizeInBytes);

		private OVRHapticsClip m_paddingClip = new OVRHapticsClip();

		public OVRHapticsOutput(uint controller)
		{
			m_controller = controller;
		}

		public void Process()
		{
			OVRPlugin.HapticsState controllerHapticsState = OVRPlugin.GetControllerHapticsState(m_controller);
			float num = Time.realtimeSinceStartup - m_prevSamplesQueuedTime;
			if (m_prevSamplesQueued > 0)
			{
				int num2 = m_prevSamplesQueued - (int)(num * (float)Config.SampleRateHz + 0.5f);
				if (num2 < 0)
				{
					num2 = 0;
				}
				if (controllerHapticsState.SamplesQueued - num2 == 0)
				{
					m_numPredictionHits++;
				}
				else
				{
					m_numPredictionMisses++;
				}
				if (num2 > 0 && controllerHapticsState.SamplesQueued == 0)
				{
					m_numUnderruns++;
				}
				m_prevSamplesQueued = controllerHapticsState.SamplesQueued;
				m_prevSamplesQueuedTime = Time.realtimeSinceStartup;
			}
			int num3 = Config.OptimalBufferSamplesCount;
			if (m_lowLatencyMode)
			{
				float num4 = 1000f / (float)Config.SampleRateHz;
				float num5 = num * 1000f;
				int num6 = (int)Mathf.Ceil(num5 / num4);
				int num7 = Config.MinimumSafeSamplesQueued + num6;
				if (num7 < num3)
				{
					num3 = num7;
				}
			}
			if (controllerHapticsState.SamplesQueued > num3)
			{
				return;
			}
			if (num3 > Config.MaximumBufferSamplesCount)
			{
				num3 = Config.MaximumBufferSamplesCount;
			}
			if (num3 > controllerHapticsState.SamplesAvailable)
			{
				num3 = controllerHapticsState.SamplesAvailable;
			}
			int num8 = 0;
			int num9 = 0;
			while (num8 < num3 && num9 < m_pendingClips.Count)
			{
				int num10 = num3 - num8;
				int num11 = m_pendingClips[num9].Clip.Count - m_pendingClips[num9].ReadCount;
				if (num10 > num11)
				{
					num10 = num11;
				}
				if (num10 > 0)
				{
					int length = num10 * Config.SampleSizeInBytes;
					int byteOffset = num8 * Config.SampleSizeInBytes;
					int startIndex = m_pendingClips[num9].ReadCount * Config.SampleSizeInBytes;
					Marshal.Copy(m_pendingClips[num9].Clip.Samples, startIndex, m_nativeBuffer.GetPointer(byteOffset), length);
					m_pendingClips[num9].ReadCount += num10;
					num8 += num10;
				}
				num9++;
			}
			int num12 = m_pendingClips.Count - 1;
			while (num12 >= 0 && m_pendingClips.Count > 0)
			{
				if (m_pendingClips[num12].ReadCount >= m_pendingClips[num12].Clip.Count)
				{
					m_pendingClips.RemoveAt(num12);
				}
				num12--;
			}
			int num13 = num3 - (controllerHapticsState.SamplesQueued + num8);
			if (num13 < Config.MinimumBufferSamplesCount - num8)
			{
				num13 = Config.MinimumBufferSamplesCount - num8;
			}
			if (num13 > controllerHapticsState.SamplesAvailable)
			{
				num13 = controllerHapticsState.SamplesAvailable;
			}
			if (num13 > 0)
			{
				int length2 = num13 * Config.SampleSizeInBytes;
				int byteOffset2 = num8 * Config.SampleSizeInBytes;
				int startIndex2 = 0;
				Marshal.Copy(m_paddingClip.Samples, startIndex2, m_nativeBuffer.GetPointer(byteOffset2), length2);
				num8 += num13;
			}
			if (num8 > 0)
			{
				OVRPlugin.HapticsBuffer hapticsBuffer = default(OVRPlugin.HapticsBuffer);
				hapticsBuffer.Samples = m_nativeBuffer.GetPointer();
				hapticsBuffer.SamplesCount = num8;
				OVRPlugin.SetControllerHaptics(m_controller, hapticsBuffer);
				m_prevSamplesQueued = OVRPlugin.GetControllerHapticsState(m_controller).SamplesQueued;
				m_prevSamplesQueuedTime = Time.realtimeSinceStartup;
			}
		}

		public void Preempt(OVRHapticsClip clip)
		{
			m_pendingClips.Clear();
			m_pendingClips.Add(new ClipPlaybackTracker(clip));
		}

		public void Queue(OVRHapticsClip clip)
		{
			m_pendingClips.Add(new ClipPlaybackTracker(clip));
		}

		public void Mix(OVRHapticsClip clip)
		{
			int num = 0;
			int num2 = 0;
			int num3 = clip.Count;
			while (num3 > 0 && num < m_pendingClips.Count)
			{
				int num4 = m_pendingClips[num].Clip.Count - m_pendingClips[num].ReadCount;
				num3 -= num4;
				num2 += num4;
				num++;
			}
			if (num3 > 0)
			{
				num2 += num3;
				num3 = 0;
			}
			if (num > 0)
			{
				OVRHapticsClip oVRHapticsClip = new OVRHapticsClip(num2);
				int i = 0;
				for (int j = 0; j < num; j++)
				{
					OVRHapticsClip clip2 = m_pendingClips[j].Clip;
					for (int k = m_pendingClips[j].ReadCount; k < clip2.Count; k++)
					{
						if (Config.SampleSizeInBytes == 1)
						{
							byte sample = 0;
							if (i < clip.Count && k < clip2.Count)
							{
								sample = (byte)Mathf.Clamp(clip.Samples[i] + clip2.Samples[k], 0, 255);
								i++;
							}
							else if (k < clip2.Count)
							{
								sample = clip2.Samples[k];
							}
							oVRHapticsClip.WriteSample(sample);
						}
					}
				}
				for (; i < clip.Count; i++)
				{
					if (Config.SampleSizeInBytes == 1)
					{
						oVRHapticsClip.WriteSample(clip.Samples[i]);
					}
				}
				m_pendingClips[0] = new ClipPlaybackTracker(oVRHapticsClip);
				for (int l = 1; l < num; l++)
				{
					m_pendingClips.RemoveAt(1);
				}
			}
			else
			{
				m_pendingClips.Add(new ClipPlaybackTracker(clip));
			}
		}

		public void Clear()
		{
			m_pendingClips.Clear();
		}
	}

	public static readonly OVRHapticsChannel[] Channels;

	public static readonly OVRHapticsChannel LeftChannel;

	public static readonly OVRHapticsChannel RightChannel;

	private static readonly OVRHapticsOutput[] m_outputs;

	static OVRHaptics()
	{
		Config.Load();
		m_outputs = new OVRHapticsOutput[2]
		{
			new OVRHapticsOutput(1u),
			new OVRHapticsOutput(2u)
		};
		Channels = new OVRHapticsChannel[2]
		{
			LeftChannel = new OVRHapticsChannel(0u),
			RightChannel = new OVRHapticsChannel(1u)
		};
	}

	public static void Process()
	{
		Config.Load();
		for (int i = 0; i < m_outputs.Length; i++)
		{
			m_outputs[i].Process();
		}
	}
}
public class OVRHapticsClip
{
	public int Count { get; private set; }

	public int Capacity { get; private set; }

	public byte[] Samples { get; private set; }

	public OVRHapticsClip()
	{
		Capacity = OVRHaptics.Config.MaximumBufferSamplesCount;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
	}

	public OVRHapticsClip(int capacity)
	{
		Capacity = ((capacity >= 0) ? capacity : 0);
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
	}

	public OVRHapticsClip(byte[] samples, int samplesCount)
	{
		Samples = samples;
		Capacity = Samples.Length / OVRHaptics.Config.SampleSizeInBytes;
		Count = ((samplesCount >= 0) ? samplesCount : 0);
	}

	public OVRHapticsClip(OVRHapticsClip a, OVRHapticsClip b)
	{
		int count = a.Count;
		if (b.Count > count)
		{
			count = b.Count;
		}
		Capacity = count;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
		for (int i = 0; i < a.Count || i < b.Count; i++)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				byte sample = 0;
				if (i < a.Count && i < b.Count)
				{
					sample = (byte)Mathf.Clamp(a.Samples[i] + b.Samples[i], 0, 255);
				}
				else if (i < a.Count)
				{
					sample = a.Samples[i];
				}
				else if (i < b.Count)
				{
					sample = b.Samples[i];
				}
				WriteSample(sample);
			}
		}
	}

	public OVRHapticsClip(AudioClip audioClip, int channel = 0)
	{
		float[] array = new float[audioClip.samples * audioClip.channels];
		audioClip.GetData(array, 0);
		InitializeFromAudioFloatTrack(array, audioClip.frequency, audioClip.channels, channel);
	}

	public void WriteSample(byte sample)
	{
		if (Count < Capacity)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				Samples[Count * OVRHaptics.Config.SampleSizeInBytes] = sample;
			}
			Count++;
		}
	}

	public void Reset()
	{
		Count = 0;
	}

	private void InitializeFromAudioFloatTrack(float[] sourceData, double sourceFrequency, int sourceChannelCount, int sourceChannel)
	{
		double num = (sourceFrequency + 1E-06) / (double)OVRHaptics.Config.SampleRateHz;
		if (num < 1.0)
		{
			return;
		}
		int num2 = (int)num;
		double num3 = num - (double)num2;
		double num4 = 0.0;
		int num5 = sourceData.Length;
		Count = 0;
		Capacity = num5 / sourceChannelCount / num2 + 1;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
		int num6 = sourceChannel % sourceChannelCount;
		while (num6 < num5)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				WriteSample((byte)(Mathf.Clamp01(Mathf.Abs(sourceData[num6])) * 255f));
			}
			num6 += num2 * sourceChannelCount;
			num4 += num3;
			if ((int)num4 > 0)
			{
				num6 += (int)num4 * sourceChannelCount;
				num4 -= (double)(int)num4;
			}
		}
	}
}
public static class OVRInput
{
	[Flags]
	public enum Button
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		Start = 0x100,
		Back = 0x200,
		PrimaryShoulder = 0x1000,
		PrimaryIndexTrigger = 0x2000,
		PrimaryHandTrigger = 0x4000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbstickUp = 0x10000,
		PrimaryThumbstickDown = 0x20000,
		PrimaryThumbstickLeft = 0x40000,
		PrimaryThumbstickRight = 0x80000,
		PrimaryTouchpad = 0x400,
		SecondaryShoulder = 0x100000,
		SecondaryIndexTrigger = 0x200000,
		SecondaryHandTrigger = 0x400000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbstickUp = 0x1000000,
		SecondaryThumbstickDown = 0x2000000,
		SecondaryThumbstickLeft = 0x4000000,
		SecondaryThumbstickRight = 0x8000000,
		SecondaryTouchpad = 0x800,
		DpadUp = 0x10,
		DpadDown = 0x20,
		DpadLeft = 0x40,
		DpadRight = 0x80,
		Up = 0x10000000,
		Down = 0x20000000,
		Left = 0x40000000,
		Right = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum RawButton
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		Start = 0x100000,
		Back = 0x200000,
		LShoulder = 0x800,
		LIndexTrigger = 0x10000000,
		LHandTrigger = 0x20000000,
		LThumbstick = 0x400,
		LThumbstickUp = 0x10,
		LThumbstickDown = 0x20,
		LThumbstickLeft = 0x40,
		LThumbstickRight = 0x80,
		LTouchpad = 0x40000000,
		RShoulder = 8,
		RIndexTrigger = 0x4000000,
		RHandTrigger = 0x8000000,
		RThumbstick = 4,
		RThumbstickUp = 0x1000,
		RThumbstickDown = 0x2000,
		RThumbstickLeft = 0x4000,
		RThumbstickRight = 0x8000,
		RTouchpad = int.MinValue,
		DpadUp = 0x10000,
		DpadDown = 0x20000,
		DpadLeft = 0x40000,
		DpadRight = 0x80000,
		Any = -1
	}

	[Flags]
	public enum Touch
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		PrimaryIndexTrigger = 0x2000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbRest = 0x1000,
		PrimaryTouchpad = 0x400,
		SecondaryIndexTrigger = 0x200000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbRest = 0x100000,
		SecondaryTouchpad = 0x800,
		Any = -1
	}

	[Flags]
	public enum RawTouch
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		LIndexTrigger = 0x1000,
		LThumbstick = 0x400,
		LThumbRest = 0x800,
		LTouchpad = 0x40000000,
		RIndexTrigger = 0x10,
		RThumbstick = 4,
		RThumbRest = 8,
		RTouchpad = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum NearTouch
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryThumbButtons = 2,
		SecondaryIndexTrigger = 4,
		SecondaryThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum RawNearTouch
	{
		None = 0,
		LIndexTrigger = 1,
		LThumbButtons = 2,
		RIndexTrigger = 4,
		RThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum Axis1D
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryHandTrigger = 4,
		SecondaryIndexTrigger = 2,
		SecondaryHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis1D
	{
		None = 0,
		LIndexTrigger = 1,
		LHandTrigger = 4,
		RIndexTrigger = 2,
		RHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum Axis2D
	{
		None = 0,
		PrimaryThumbstick = 1,
		PrimaryTouchpad = 4,
		SecondaryThumbstick = 2,
		SecondaryTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis2D
	{
		None = 0,
		LThumbstick = 1,
		LTouchpad = 4,
		RThumbstick = 2,
		RTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 0x10,
		Touchpad = 0x8000000,
		LTrackedRemote = 0x1000000,
		RTrackedRemote = 0x2000000,
		Active = int.MinValue,
		All = -1
	}

	private abstract class OVRControllerBase
	{
		public class VirtualButtonMap
		{
			public RawButton None;

			public RawButton One;

			public RawButton Two;

			public RawButton Three;

			public RawButton Four;

			public RawButton Start;

			public RawButton Back;

			public RawButton PrimaryShoulder;

			public RawButton PrimaryIndexTrigger;

			public RawButton PrimaryHandTrigger;

			public RawButton PrimaryThumbstick;

			public RawButton PrimaryThumbstickUp;

			public RawButton PrimaryThumbstickDown;

			public RawButton PrimaryThumbstickLeft;

			public RawButton PrimaryThumbstickRight;

			public RawButton PrimaryTouchpad;

			public RawButton SecondaryShoulder;

			public RawButton SecondaryIndexTrigger;

			public RawButton SecondaryHandTrigger;

			public RawButton SecondaryThumbstick;

			public RawButton SecondaryThumbstickUp;

			public RawButton SecondaryThumbstickDown;

			public RawButton SecondaryThumbstickLeft;

			public RawButton SecondaryThumbstickRight;

			public RawButton SecondaryTouchpad;

			public RawButton DpadUp;

			public RawButton DpadDown;

			public RawButton DpadLeft;

			public RawButton DpadRight;

			public RawButton Up;

			public RawButton Down;

			public RawButton Left;

			public RawButton Right;

			public RawButton ToRawMask(Button virtualMask)
			{
				RawButton rawButton = RawButton.None;
				if (virtualMask == Button.None)
				{
					return RawButton.None;
				}
				if ((virtualMask & Button.One) != 0)
				{
					rawButton |= One;
				}
				if ((virtualMask & Button.Two) != 0)
				{
					rawButton |= Two;
				}
				if ((virtualMask & Button.Three) != 0)
				{
					rawButton |= Three;
				}
				if ((virtualMask & Button.Four) != 0)
				{
					rawButton |= Four;
				}
				if ((virtualMask & Button.Start) != 0)
				{
					rawButton |= Start;
				}
				if ((virtualMask & Button.Back) != 0)
				{
					rawButton |= Back;
				}
				if ((virtualMask & Button.PrimaryShoulder) != 0)
				{
					rawButton |= PrimaryShoulder;
				}
				if ((virtualMask & Button.PrimaryIndexTrigger) != 0)
				{
					rawButton |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Button.PrimaryHandTrigger) != 0)
				{
					rawButton |= PrimaryHandTrigger;
				}
				if ((virtualMask & Button.PrimaryThumbstick) != 0)
				{
					rawButton |= PrimaryThumbstick;
				}
				if ((virtualMask & Button.PrimaryThumbstickUp) != 0)
				{
					rawButton |= PrimaryThumbstickUp;
				}
				if ((virtualMask & Button.PrimaryThumbstickDown) != 0)
				{
					rawButton |= PrimaryThumbstickDown;
				}
				if ((virtualMask & Button.PrimaryThumbstickLeft) != 0)
				{
					rawButton |= PrimaryThumbstickLeft;
				}
				if ((virtualMask & Button.PrimaryThumbstickRight) != 0)
				{
					rawButton |= PrimaryThumbstickRight;
				}
				if ((virtualMask & Button.PrimaryTouchpad) != 0)
				{
					rawButton |= PrimaryTouchpad;
				}
				if ((virtualMask & Button.SecondaryShoulder) != 0)
				{
					rawButton |= SecondaryShoulder;
				}
				if ((virtualMask & Button.SecondaryIndexTrigger) != 0)
				{
					rawButton |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Button.SecondaryHandTrigger) != 0)
				{
					rawButton |= SecondaryHandTrigger;
				}
				if ((virtualMask & Button.SecondaryThumbstick) != 0)
				{
					rawButton |= SecondaryThumbstick;
				}
				if ((virtualMask & Button.SecondaryThumbstickUp) != 0)
				{
					rawButton |= SecondaryThumbstickUp;
				}
				if ((virtualMask & Button.SecondaryThumbstickDown) != 0)
				{
					rawButton |= SecondaryThumbstickDown;
				}
				if ((virtualMask & Button.SecondaryThumbstickLeft) != 0)
				{
					rawButton |= SecondaryThumbstickLeft;
				}
				if ((virtualMask & Button.SecondaryThumbstickRight) != 0)
				{
					rawButton |= SecondaryThumbstickRight;
				}
				if ((virtualMask & Button.SecondaryTouchpad) != 0)
				{
					rawButton |= SecondaryTouchpad;
				}
				if ((virtualMask & Button.DpadUp) != 0)
				{
					rawButton |= DpadUp;
				}
				if ((virtualMask & Button.DpadDown) != 0)
				{
					rawButton |= DpadDown;
				}
				if ((virtualMask & Button.DpadLeft) != 0)
				{
					rawButton |= DpadLeft;
				}
				if ((virtualMask & Button.DpadRight) != 0)
				{
					rawButton |= DpadRight;
				}
				if ((virtualMask & Button.Up) != 0)
				{
					rawButton |= Up;
				}
				if ((virtualMask & Button.Down) != 0)
				{
					rawButton |= Down;
				}
				if ((virtualMask & Button.Left) != 0)
				{
					rawButton |= Left;
				}
				if (((uint)virtualMask & 0x80000000u) != 0)
				{
					rawButton |= Right;
				}
				return rawButton;
			}
		}

		public class VirtualTouchMap
		{
			public RawTouch None;

			public RawTouch One;

			public RawTouch Two;

			public RawTouch Three;

			public RawTouch Four;

			public RawTouch PrimaryIndexTrigger;

			public RawTouch PrimaryThumbstick;

			public RawTouch PrimaryThumbRest;

			public RawTouch PrimaryTouchpad;

			public RawTouch SecondaryIndexTrigger;

			public RawTouch SecondaryThumbstick;

			public RawTouch SecondaryThumbRest;

			public RawTouch SecondaryTouchpad;

			public RawTouch ToRawMask(Touch virtualMask)
			{
				RawTouch rawTouch = RawTouch.None;
				if (virtualMask == Touch.None)
				{
					return RawTouch.None;
				}
				if ((virtualMask & Touch.One) != 0)
				{
					rawTouch |= One;
				}
				if ((virtualMask & Touch.Two) != 0)
				{
					rawTouch |= Two;
				}
				if ((virtualMask & Touch.Three) != 0)
				{
					rawTouch |= Three;
				}
				if ((virtualMask & Touch.Four) != 0)
				{
					rawTouch |= Four;
				}
				if ((virtualMask & Touch.PrimaryIndexTrigger) != 0)
				{
					rawTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Touch.PrimaryThumbstick) != 0)
				{
					rawTouch |= PrimaryThumbstick;
				}
				if ((virtualMask & Touch.PrimaryThumbRest) != 0)
				{
					rawTouch |= PrimaryThumbRest;
				}
				if ((virtualMask & Touch.PrimaryTouchpad) != 0)
				{
					rawTouch |= PrimaryTouchpad;
				}
				if ((virtualMask & Touch.SecondaryIndexTrigger) != 0)
				{
					rawTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Touch.SecondaryThumbstick) != 0)
				{
					rawTouch |= SecondaryThumbstick;
				}
				if ((virtualMask & Touch.SecondaryThumbRest) != 0)
				{
					rawTouch |= SecondaryThumbRest;
				}
				if ((virtualMask & Touch.SecondaryTouchpad) != 0)
				{
					rawTouch |= SecondaryTouchpad;
				}
				return rawTouch;
			}
		}

		public class VirtualNearTouchMap
		{
			public RawNearTouch None;

			public RawNearTouch PrimaryIndexTrigger;

			public RawNearTouch PrimaryThumbButtons;

			public RawNearTouch SecondaryIndexTrigger;

			public RawNearTouch SecondaryThumbButtons;

			public RawNearTouch ToRawMask(NearTouch virtualMask)
			{
				RawNearTouch rawNearTouch = RawNearTouch.None;
				if (virtualMask == NearTouch.None)
				{
					return RawNearTouch.None;
				}
				if ((virtualMask & NearTouch.PrimaryIndexTrigger) != 0)
				{
					rawNearTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.PrimaryThumbButtons) != 0)
				{
					rawNearTouch |= PrimaryThumbButtons;
				}
				if ((virtualMask & NearTouch.SecondaryIndexTrigger) != 0)
				{
					rawNearTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.SecondaryThumbButtons) != 0)
				{
					rawNearTouch |= SecondaryThumbButtons;
				}
				return rawNearTouch;
			}
		}

		public class VirtualAxis1DMap
		{
			public RawAxis1D None;

			public RawAxis1D PrimaryIndexTrigger;

			public RawAxis1D PrimaryHandTrigger;

			public RawAxis1D SecondaryIndexTrigger;

			public RawAxis1D SecondaryHandTrigger;

			public RawAxis1D ToRawMask(Axis1D virtualMask)
			{
				RawAxis1D rawAxis1D = RawAxis1D.None;
				if (virtualMask == Axis1D.None)
				{
					return RawAxis1D.None;
				}
				if ((virtualMask & Axis1D.PrimaryIndexTrigger) != 0)
				{
					rawAxis1D |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.PrimaryHandTrigger) != 0)
				{
					rawAxis1D |= PrimaryHandTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryIndexTrigger) != 0)
				{
					rawAxis1D |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryHandTrigger) != 0)
				{
					rawAxis1D |= SecondaryHandTrigger;
				}
				return rawAxis1D;
			}
		}

		public class VirtualAxis2DMap
		{
			public RawAxis2D None;

			public RawAxis2D PrimaryThumbstick;

			public RawAxis2D PrimaryTouchpad;

			public RawAxis2D SecondaryThumbstick;

			public RawAxis2D SecondaryTouchpad;

			public RawAxis2D ToRawMask(Axis2D virtualMask)
			{
				RawAxis2D rawAxis2D = RawAxis2D.None;
				if (virtualMask == Axis2D.None)
				{
					return RawAxis2D.None;
				}
				if ((virtualMask & Axis2D.PrimaryThumbstick) != 0)
				{
					rawAxis2D |= PrimaryThumbstick;
				}
				if ((virtualMask & Axis2D.PrimaryTouchpad) != 0)
				{
					rawAxis2D |= PrimaryTouchpad;
				}
				if ((virtualMask & Axis2D.SecondaryThumbstick) != 0)
				{
					rawAxis2D |= SecondaryThumbstick;
				}
				if ((virtualMask & Axis2D.SecondaryTouchpad) != 0)
				{
					rawAxis2D |= SecondaryTouchpad;
				}
				return rawAxis2D;
			}
		}

		public Controller controllerType;

		public VirtualButtonMap buttonMap = new VirtualButtonMap();

		public VirtualTouchMap touchMap = new VirtualTouchMap();

		public VirtualNearTouchMap nearTouchMap = new VirtualNearTouchMap();

		public VirtualAxis1DMap axis1DMap = new VirtualAxis1DMap();

		public VirtualAxis2DMap axis2DMap = new VirtualAxis2DMap();

		public OVRPlugin.ControllerState4 previousState = default(OVRPlugin.ControllerState4);

		public OVRPlugin.ControllerState4 currentState = default(OVRPlugin.ControllerState4);

		public bool shouldApplyDeadzone = true;

		public OVRControllerBase()
		{
			ConfigureButtonMap();
			ConfigureTouchMap();
			ConfigureNearTouchMap();
			ConfigureAxis1DMap();
			ConfigureAxis2DMap();
		}

		public virtual Controller Update()
		{
			OVRPlugin.ControllerState4 controllerState = OVRPlugin.GetControllerState4((uint)controllerType);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public virtual void SetControllerVibration(float frequency, float amplitude)
		{
			OVRPlugin.SetControllerVibration((uint)controllerType, frequency, amplitude);
		}

		public virtual void RecenterController()
		{
			OVRPlugin.RecenterTrackingOrigin(OVRPlugin.RecenterFlags.Controllers);
		}

		public virtual bool WasRecentered()
		{
			return false;
		}

		public virtual byte GetRecenterCount()
		{
			return 0;
		}

		public virtual byte GetBatteryPercentRemaining()
		{
			return 0;
		}

		public abstract void ConfigureButtonMap();

		public abstract void ConfigureTouchMap();

		public abstract void ConfigureNearTouchMap();

		public abstract void ConfigureAxis1DMap();

		public abstract void ConfigureAxis2DMap();

		public RawButton ResolveToRawMask(Button virtualMask)
		{
			return buttonMap.ToRawMask(virtualMask);
		}

		public RawTouch ResolveToRawMask(Touch virtualMask)
		{
			return touchMap.ToRawMask(virtualMask);
		}

		public RawNearTouch ResolveToRawMask(NearTouch virtualMask)
		{
			return nearTouchMap.ToRawMask(virtualMask);
		}

		public RawAxis1D ResolveToRawMask(Axis1D virtualMask)
		{
			return axis1DMap.ToRawMask(virtualMask);
		}

		public RawAxis2D ResolveToRawMask(Axis2D virtualMask)
		{
			return axis2DMap.ToRawMask(virtualMask);
		}
	}

	private class OVRControllerTouch : OVRControllerBase
	{
		public OVRControllerTouch()
		{
			controllerType = Controller.Touch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.X;
			touchMap.Four = RawTouch.Y;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.SecondaryThumbstick = RawTouch.RThumbstick;
			touchMap.SecondaryThumbRest = RawTouch.RThumbRest;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.RThumbButtons;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.RHandTrigger;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerLTouch : OVRControllerBase
	{
		public OVRControllerLTouch()
		{
			controllerType = Controller.LTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.X;
			buttonMap.Two = RawButton.Y;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.X;
			touchMap.Two = RawTouch.Y;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerRTouch : OVRControllerBase
	{
		public OVRControllerRTouch()
		{
			controllerType = Controller.RTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.None;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.RThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.RThumbstickUp;
			buttonMap.Down = RawButton.RThumbstickDown;
			buttonMap.Left = RawButton.RThumbstickLeft;
			buttonMap.Right = RawButton.RThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.RThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.RThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.RThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.RHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerRemote : OVRControllerBase
	{
		public OVRControllerRemote()
		{
			controllerType = Controller.Remote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.Start;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadPC : OVRControllerBase
	{
		public OVRControllerGamepadPC()
		{
			controllerType = Controller.Gamepad;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadMac : OVRControllerBase
	{
		private enum AxisGPC
		{
			None = -1,
			LeftXAxis,
			LeftYAxis,
			RightXAxis,
			RightYAxis,
			LeftTrigger,
			RightTrigger,
			DPad_X_Axis,
			DPad_Y_Axis,
			Max
		}

		public enum ButtonGPC
		{
			None = -1,
			A,
			B,
			X,
			Y,
			Up,
			Down,
			Left,
			Right,
			Start,
			Back,
			LStick,
			RStick,
			LeftShoulder,
			RightShoulder,
			Max
		}

		private bool initialized;

		private const string DllName = "OVRGamepad";

		public OVRControllerGamepadMac()
		{
			controllerType = Controller.Gamepad;
			initialized = OVR_GamepadController_Initialize();
		}

		~OVRControllerGamepadMac()
		{
			if (initialized)
			{
				OVR_GamepadController_Destroy();
			}
		}

		public override Controller Update()
		{
			if (!initialized)
			{
				return Controller.None;
			}
			OVRPlugin.ControllerState4 controllerState = default(OVRPlugin.ControllerState4);
			if (OVR_GamepadController_Update())
			{
				controllerState.ConnectedControllers = 16u;
			}
			if (OVR_GamepadController_GetButton(0))
			{
				controllerState.Buttons |= 1u;
			}
			if (OVR_GamepadController_GetButton(1))
			{
				controllerState.Buttons |= 2u;
			}
			if (OVR_GamepadController_GetButton(2))
			{
				controllerState.Buttons |= 256u;
			}
			if (OVR_GamepadController_GetButton(3))
			{
				controllerState.Buttons |= 512u;
			}
			if (OVR_GamepadController_GetButton(4))
			{
				controllerState.Buttons |= 65536u;
			}
			if (OVR_GamepadController_GetButton(5))
			{
				controllerState.Buttons |= 131072u;
			}
			if (OVR_GamepadController_GetButton(6))
			{
				controllerState.Buttons |= 262144u;
			}
			if (OVR_GamepadController_GetButton(7))
			{
				controllerState.Buttons |= 524288u;
			}
			if (OVR_GamepadController_GetButton(8))
			{
				controllerState.Buttons |= 1048576u;
			}
			if (OVR_GamepadController_GetButton(9))
			{
				controllerState.Buttons |= 2097152u;
			}
			if (OVR_GamepadController_GetButton(10))
			{
				controllerState.Buttons |= 1024u;
			}
			if (OVR_GamepadController_GetButton(11))
			{
				controllerState.Buttons |= 4u;
			}
			if (OVR_GamepadController_GetButton(12))
			{
				controllerState.Buttons |= 2048u;
			}
			if (OVR_GamepadController_GetButton(13))
			{
				controllerState.Buttons |= 8u;
			}
			controllerState.LThumbstick.x = OVR_GamepadController_GetAxis(0);
			controllerState.LThumbstick.y = OVR_GamepadController_GetAxis(1);
			controllerState.RThumbstick.x = OVR_GamepadController_GetAxis(2);
			controllerState.RThumbstick.y = OVR_GamepadController_GetAxis(3);
			controllerState.LIndexTrigger = OVR_GamepadController_GetAxis(4);
			controllerState.RIndexTrigger = OVR_GamepadController_GetAxis(5);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override void SetControllerVibration(float frequency, float amplitude)
		{
			int node = 0;
			float frequency2 = frequency * 200f;
			OVR_GamepadController_SetVibration(node, amplitude, frequency2);
		}

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Initialize();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Destroy();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Update();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern float OVR_GamepadController_GetAxis(int axis);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_GetButton(int button);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_SetVibration(int node, float strength, float frequency);
	}

	private class OVRControllerGamepadAndroid : OVRControllerBase
	{
		public OVRControllerGamepadAndroid()
		{
			controllerType = Controller.Gamepad;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerTouchpad : OVRControllerBase
	{
		private OVRPlugin.Vector2f moveAmount;

		private float maxTapMagnitude = 0.1f;

		private float minMoveMagnitude = 0.15f;

		public OVRControllerTouchpad()
		{
			controllerType = Controller.Touchpad;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount = currentState.LTouchpad;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				float magnitude = vector.magnitude;
				if (magnitude < maxTapMagnitude)
				{
					currentState.Buttons |= 1048576u;
					currentState.Buttons |= 1073741824u;
				}
				else if (magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.LTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.LTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.LTouchpad;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerLTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerLTrackedRemote()
		{
			controllerType = Controller.LTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.LTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.LTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.LTouchpad;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.LTouchpad;
			}
			if (GetDown(RawButton.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.LTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}

		public override bool WasRecentered()
		{
			return currentState.LRecenterCount != previousState.LRecenterCount;
		}

		public override byte GetRecenterCount()
		{
			return currentState.LRecenterCount;
		}

		public override byte GetBatteryPercentRemaining()
		{
			return currentState.LBatteryPercentRemaining;
		}
	}

	private class OVRControllerRTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerRTrackedRemote()
		{
			controllerType = Controller.RTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.RTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.RTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.RTouchpad;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.RTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.RHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.RTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.RTouchpad;
			}
			if (GetDown(RawButton.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.RTouchpad, Controller.RTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.RTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.RTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}

		public override bool WasRecentered()
		{
			return currentState.RRecenterCount != previousState.RRecenterCount;
		}

		public override byte GetRecenterCount()
		{
			return currentState.RRecenterCount;
		}

		public override byte GetBatteryPercentRemaining()
		{
			return currentState.RBatteryPercentRemaining;
		}
	}

	private static readonly float AXIS_AS_BUTTON_THRESHOLD;

	private static readonly float AXIS_DEADZONE_THRESHOLD;

	private static List<OVRControllerBase> controllers;

	private static Controller activeControllerType;

	private static Controller connectedControllerTypes;

	private static OVRPlugin.Step stepType;

	private static int fixedUpdateCount;

	private static bool _pluginSupportsActiveController;

	private static bool _pluginSupportsActiveControllerCached;

	private static Version _pluginSupportsActiveControllerMinVersion;

	private static bool pluginSupportsActiveController
	{
		get
		{
			if (!_pluginSupportsActiveControllerCached)
			{
				bool flag = true;
				_pluginSupportsActiveController = false && OVRPlugin.version >= _pluginSupportsActiveControllerMinVersion;
				_pluginSupportsActiveControllerCached = true;
			}
			return _pluginSupportsActiveController;
		}
	}

	static OVRInput()
	{
		AXIS_AS_BUTTON_THRESHOLD = 0.5f;
		AXIS_DEADZONE_THRESHOLD = 0.2f;
		activeControllerType = Controller.None;
		connectedControllerTypes = Controller.None;
		stepType = OVRPlugin.Step.Render;
		fixedUpdateCount = 0;
		_pluginSupportsActiveController = false;
		_pluginSupportsActiveControllerCached = false;
		_pluginSupportsActiveControllerMinVersion = new Version(1, 9, 0);
		controllers = new List<OVRControllerBase>
		{
			new OVRControllerGamepadAndroid(),
			new OVRControllerTouchpad(),
			new OVRControllerLTrackedRemote(),
			new OVRControllerRTrackedRemote()
		};
	}

	public static void Update()
	{
		connectedControllerTypes = Controller.None;
		stepType = OVRPlugin.Step.Render;
		fixedUpdateCount = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			connectedControllerTypes |= oVRControllerBase.Update();
			if ((connectedControllerTypes & oVRControllerBase.controllerType) != 0)
			{
				RawButton rawMask = RawButton.Any;
				RawTouch rawMask2 = RawTouch.Any;
				if (Get(rawMask, oVRControllerBase.controllerType) || Get(rawMask2, oVRControllerBase.controllerType))
				{
					activeControllerType = oVRControllerBase.controllerType;
				}
			}
		}
		if (activeControllerType == Controller.LTouch || activeControllerType == Controller.RTouch)
		{
			activeControllerType = Controller.Touch;
		}
		if ((connectedControllerTypes & activeControllerType) == 0)
		{
			activeControllerType = Controller.None;
		}
		if (activeControllerType == Controller.None)
		{
			if ((connectedControllerTypes & Controller.RTrackedRemote) != 0)
			{
				activeControllerType = Controller.RTrackedRemote;
			}
			else if ((connectedControllerTypes & Controller.LTrackedRemote) != 0)
			{
				activeControllerType = Controller.LTrackedRemote;
			}
		}
		if (pluginSupportsActiveController)
		{
			connectedControllerTypes = (Controller)OVRPlugin.GetConnectedControllers();
			activeControllerType = (Controller)OVRPlugin.GetActiveController();
		}
	}

	public static void FixedUpdate()
	{
		stepType = OVRPlugin.Step.Physics;
		double predictionSeconds = (double)fixedUpdateCount * (double)Time.fixedDeltaTime / (double)Mathf.Max(Time.timeScale, 1E-06f);
		fixedUpdateCount++;
		OVRPlugin.UpdateNodePhysicsPoses(0, predictionSeconds);
	}

	public static bool GetControllerOrientationTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static bool GetControllerPositionTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static Vector3 GetLocalControllerPosition(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, stepType).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, stepType).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerVelocity(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerAcceleration(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static Quaternion GetLocalControllerRotation(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, stepType).ToOVRPose().orientation;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, stepType).ToOVRPose().orientation;
		default:
			return Quaternion.identity;
		}
	}

	public static Vector3 GetLocalControllerAngularVelocity(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAngularVelocity(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAngularVelocity(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerAngularAcceleration(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAngularAcceleration(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAngularAcceleration(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static bool Get(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(virtualMask, RawButton.None, controllerMask);
	}

	public static bool Get(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButton(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetDown(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonDown(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetUp(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonUp(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) == 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool Get(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouch(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetDown(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchDown(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetUp(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchUp(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) == 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool Get(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouch(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetDown(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchDown(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetUp(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchUp(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) == 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static float Get(Axis1D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(virtualMask, RawAxis1D.None, controllerMask);
	}

	public static float Get(RawAxis1D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(Axis1D.None, rawMask, controllerMask);
	}

	private static float GetResolvedAxis1D(Axis1D virtualMask, RawAxis1D rawMask, Controller controllerMask)
	{
		float num = 0f;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis1D rawAxis1D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis1D.LIndexTrigger & rawAxis1D) != 0)
			{
				float num2 = oVRControllerBase.currentState.LIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num2 = CalculateDeadzone(num2, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num2);
			}
			if ((RawAxis1D.RIndexTrigger & rawAxis1D) != 0)
			{
				float num3 = oVRControllerBase.currentState.RIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num3 = CalculateDeadzone(num3, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num3);
			}
			if ((RawAxis1D.LHandTrigger & rawAxis1D) != 0)
			{
				float num4 = oVRControllerBase.currentState.LHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num4 = CalculateDeadzone(num4, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num4);
			}
			if ((RawAxis1D.RHandTrigger & rawAxis1D) != 0)
			{
				float num5 = oVRControllerBase.currentState.RHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num5 = CalculateDeadzone(num5, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num5);
			}
		}
		return num;
	}

	public static Vector2 Get(Axis2D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(virtualMask, RawAxis2D.None, controllerMask);
	}

	public static Vector2 Get(RawAxis2D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(Axis2D.None, rawMask, controllerMask);
	}

	private static Vector2 GetResolvedAxis2D(Axis2D virtualMask, RawAxis2D rawMask, Controller controllerMask)
	{
		Vector2 vector = Vector2.zero;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis2D rawAxis2D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis2D.LThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector2 = new Vector2(oVRControllerBase.currentState.LThumbstick.x, oVRControllerBase.currentState.LThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector2 = CalculateDeadzone(vector2, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector2);
			}
			if ((RawAxis2D.LTouchpad & rawAxis2D) != 0)
			{
				Vector2 b = new Vector2(oVRControllerBase.currentState.LTouchpad.x, oVRControllerBase.currentState.LTouchpad.y);
				vector = CalculateAbsMax(vector, b);
			}
			if ((RawAxis2D.RThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector3 = new Vector2(oVRControllerBase.currentState.RThumbstick.x, oVRControllerBase.currentState.RThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector3 = CalculateDeadzone(vector3, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector3);
			}
			if ((RawAxis2D.RTouchpad & rawAxis2D) != 0)
			{
				Vector2 b2 = new Vector2(oVRControllerBase.currentState.RTouchpad.x, oVRControllerBase.currentState.RTouchpad.y);
				vector = CalculateAbsMax(vector, b2);
			}
		}
		return vector;
	}

	public static Controller GetConnectedControllers()
	{
		return connectedControllerTypes;
	}

	public static bool IsControllerConnected(Controller controller)
	{
		return (connectedControllerTypes & controller) == controller;
	}

	public static Controller GetActiveController()
	{
		return activeControllerType;
	}

	public static void SetControllerVibration(float frequency, float amplitude, Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				oVRControllerBase.SetControllerVibration(frequency, amplitude);
			}
		}
	}

	public static void RecenterController(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				oVRControllerBase.RecenterController();
			}
		}
	}

	public static bool GetControllerWasRecentered(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		bool flag = false;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				flag |= oVRControllerBase.WasRecentered();
			}
		}
		return flag;
	}

	public static byte GetControllerRecenterCount(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		byte result = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				result = oVRControllerBase.GetRecenterCount();
				break;
			}
		}
		return result;
	}

	public static byte GetControllerBatteryPercentRemaining(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		byte result = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				result = oVRControllerBase.GetBatteryPercentRemaining();
				break;
			}
		}
		return result;
	}

	private static Vector2 CalculateAbsMax(Vector2 a, Vector2 b)
	{
		float sqrMagnitude = a.sqrMagnitude;
		float sqrMagnitude2 = b.sqrMagnitude;
		if (sqrMagnitude >= sqrMagnitude2)
		{
			return a;
		}
		return b;
	}

	private static float CalculateAbsMax(float a, float b)
	{
		float num = ((!(a >= 0f)) ? (0f - a) : a);
		float num2 = ((!(b >= 0f)) ? (0f - b) : b);
		if (num >= num2)
		{
			return a;
		}
		return b;
	}

	private static Vector2 CalculateDeadzone(Vector2 a, float deadzone)
	{
		if (a.sqrMagnitude <= deadzone * deadzone)
		{
			return Vector2.zero;
		}
		a *= (a.magnitude - deadzone) / (1f - deadzone);
		if (a.sqrMagnitude > 1f)
		{
			return a.normalized;
		}
		return a;
	}

	private static float CalculateDeadzone(float a, float deadzone)
	{
		float num = ((!(a >= 0f)) ? (0f - a) : a);
		if (num <= deadzone)
		{
			return 0f;
		}
		a *= (num - deadzone) / (1f - deadzone);
		if (a * a > 1f)
		{
			return (!(a >= 0f)) ? (-1f) : 1f;
		}
		return a;
	}

	private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)
	{
		bool result = false;
		if ((controllerType & controllerMask) == controllerType)
		{
			result = true;
		}
		if ((controllerMask & Controller.Touch) == Controller.Touch && (controllerType & Controller.Touch) != 0 && (controllerType & Controller.Touch) != Controller.Touch)
		{
			result = false;
		}
		return result;
	}
}
public class OVRLayerAttribute : PropertyAttribute
{
}
public class OVRManager : UnityEngine.MonoBehaviour
{
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel
	}

	public enum EyeTextureFormat
	{
		Default = 0,
		R16G16B16A16_FP = 2,
		R11G11B10_FP = 3
	}

	public enum TiledMultiResLevel
	{
		Off,
		LMSLow,
		LMSMedium,
		LMSHigh
	}

	private static OVRProfile _profile;

	private IEnumerable<Camera> disabledCameras;

	private float prevTimeScale;

	private static bool _isHmdPresentCached = false;

	private static bool _isHmdPresent = false;

	private static bool _wasHmdPresent = false;

	private static bool _hasVrFocusCached = false;

	private static bool _hasVrFocus = false;

	private static bool _hadVrFocus = false;

	private static bool _hadInputFocus = true;

	[Header("Performance/Quality")]
	[Tooltip("If true, distortion rendering work is submitted a quarter-frame early to avoid pipeline stalls and increase CPU-GPU parallelism.")]
	public bool queueAhead = true;

	[Tooltip("If true, Unity will use the optimal antialiasing level for quality/performance on the current hardware.")]
	public bool useRecommendedMSAALevel;

	[Tooltip("If true, dynamic resolution will be enabled On PC")]
	public bool enableAdaptiveResolution;

	[Range(0.5f, 2f)]
	[Tooltip("Min RenderScale the app can reach under adaptive resolution mode")]
	public float minRenderScale = 0.7f;

	[Range(0.5f, 2f)]
	[Tooltip("Max RenderScale the app can reach under adaptive resolution mode")]
	public float maxRenderScale = 1f;

	[Header("Tracking")]
	[SerializeField]
	[Tooltip("Defines the current tracking origin type.")]
	private TrackingOrigin _trackingOriginType;

	[Tooltip("If true, head tracking will affect the position of each OVRCameraRig's cameras.")]
	public bool usePositionTracking = true;

	[HideInInspector]
	public bool useRotationTracking = true;

	[Tooltip("If true, the distance between the user's eyes will affect the position of each OVRCameraRig's cameras.")]
	public bool useIPDInPositionTracking = true;

	[Tooltip("If true, each scene load will cause the head pose to reset.")]
	public bool resetTrackerOnLoad;

	[Tooltip("If true, the Reset View in the universal menu will cause the pose to be reset. This should generally be enabled for applications with a stationary position in the virtual world and will allow the View Reset command to place the person back to a predefined location (such as a cockpit seat). Set this to false if you have a locomotion system because resetting the view would effectively teleport the player to potentially invalid locations.")]
	public bool AllowRecenter = true;

	private static bool _isUserPresentCached = false;

	private static bool _isUserPresent = false;

	private static bool _wasUserPresent = false;

	private static bool prevAudioOutIdIsCached = false;

	private static bool prevAudioInIdIsCached = false;

	private static string prevAudioOutId = string.Empty;

	private static string prevAudioInId = string.Empty;

	private static bool wasPositionTracked = false;

	private bool multipleMainCameraWarningPresented;

	public static OVRManager instance { get; private set; }

	public static OVRDisplay display { get; private set; }

	public static OVRTracker tracker { get; private set; }

	public static OVRBoundary boundary { get; private set; }

	public static OVRProfile profile
	{
		get
		{
			if (_profile == null)
			{
				_profile = new OVRProfile();
			}
			return _profile;
		}
	}

	public static bool isHmdPresent
	{
		get
		{
			if (!_isHmdPresentCached)
			{
				_isHmdPresentCached = true;
				_isHmdPresent = OVRPlugin.hmdPresent;
			}
			return _isHmdPresent;
		}
		private set
		{
			_isHmdPresentCached = true;
			_isHmdPresent = value;
		}
	}

	public static string audioOutId => OVRPlugin.audioOutId;

	public static string audioInId => OVRPlugin.audioInId;

	public static bool hasVrFocus
	{
		get
		{
			if (!_hasVrFocusCached)
			{
				_hasVrFocusCached = true;
				_hasVrFocus = OVRPlugin.hasVrFocus;
			}
			return _hasVrFocus;
		}
		private set
		{
			_hasVrFocusCached = true;
			_hasVrFocus = value;
		}
	}

	public static bool hasInputFocus => OVRPlugin.hasInputFocus;

	public bool chromatic
	{
		get
		{
			if (!isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.chromatic;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.chromatic = value;
			}
		}
	}

	public bool monoscopic
	{
		get
		{
			if (!isHmdPresent)
			{
				return true;
			}
			return OVRPlugin.monoscopic;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.monoscopic = value;
			}
		}
	}

	public int vsyncCount
	{
		get
		{
			if (!isHmdPresent)
			{
				return 1;
			}
			return OVRPlugin.vsyncCount;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.vsyncCount = value;
			}
		}
	}

	public static float batteryLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 1f;
			}
			return OVRPlugin.batteryLevel;
		}
	}

	public static float batteryTemperature
	{
		get
		{
			if (!isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.batteryTemperature;
		}
	}

	public static int batteryStatus
	{
		get
		{
			if (!isHmdPresent)
			{
				return -1;
			}
			return (int)OVRPlugin.batteryStatus;
		}
	}

	public static float volumeLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.systemVolume;
		}
	}

	public static int cpuLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 2;
			}
			return OVRPlugin.cpuLevel;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.cpuLevel = value;
			}
		}
	}

	public static int gpuLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 2;
			}
			return OVRPlugin.gpuLevel;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.gpuLevel = value;
			}
		}
	}

	public static bool isPowerSavingActive
	{
		get
		{
			if (!isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.powerSaving;
		}
	}

	public static EyeTextureFormat eyeTextureFormat
	{
		get
		{
			return (EyeTextureFormat)OVRPlugin.GetDesiredEyeTextureFormat();
		}
		set
		{
			OVRPlugin.SetDesiredEyeTextureFormat((OVRPlugin.EyeTextureFormat)value);
		}
	}

	public static bool tiledMultiResSupported => OVRPlugin.tiledMultiResSupported;

	public static TiledMultiResLevel tiledMultiResLevel
	{
		get
		{
			if (!OVRPlugin.tiledMultiResSupported)
			{
				UnityEngine.Debug.LogWarning("Tiled-based Multi-resolution feature is not supported");
			}
			return (TiledMultiResLevel)OVRPlugin.tiledMultiResLevel;
		}
		set
		{
			if (!OVRPlugin.tiledMultiResSupported)
			{
				UnityEngine.Debug.LogWarning("Tiled-based Multi-resolution feature is not supported");
			}
			OVRPlugin.tiledMultiResLevel = (OVRPlugin.TiledMultiResLevel)value;
		}
	}

	public static bool gpuUtilSupported => OVRPlugin.gpuUtilSupported;

	public static float gpuUtilLevel
	{
		get
		{
			if (!OVRPlugin.gpuUtilSupported)
			{
				UnityEngine.Debug.LogWarning("GPU Util is not supported");
			}
			return OVRPlugin.gpuUtilLevel;
		}
	}

	public TrackingOrigin trackingOriginType
	{
		get
		{
			if (!isHmdPresent)
			{
				return _trackingOriginType;
			}
			return (TrackingOrigin)OVRPlugin.GetTrackingOriginType();
		}
		set
		{
			if (isHmdPresent && OVRPlugin.SetTrackingOriginType((OVRPlugin.TrackingOrigin)value))
			{
				_trackingOriginType = value;
			}
		}
	}

	public bool isSupportedPlatform { get; private set; }

	public bool isUserPresent
	{
		get
		{
			if (!_isUserPresentCached)
			{
				_isUserPresentCached = true;
				_isUserPresent = OVRPlugin.userPresent;
			}
			return _isUserPresent;
		}
		private set
		{
			_isUserPresentCached = true;
			_isUserPresent = value;
		}
	}

	public static Version utilitiesVersion => OVRPlugin.wrapperVersion;

	public static Version pluginVersion => OVRPlugin.version;

	public static Version sdkVersion => OVRPlugin.nativeSDKVersion;

	public static event Action HMDAcquired;

	public static event Action HMDLost;

	public static event Action HMDMounted;

	public static event Action HMDUnmounted;

	public static event Action VrFocusAcquired;

	public static event Action VrFocusLost;

	public static event Action InputFocusAcquired;

	public static event Action InputFocusLost;

	public static event Action AudioOutChanged;

	public static event Action AudioInChanged;

	public static event Action TrackingAcquired;

	public static event Action TrackingLost;

	[Obsolete]
	public static event Action HSWDismissed;

	public static bool IsAdaptiveResSupportedByEngine()
	{
		return false;
	}

	private void Awake()
	{
		if (instance != null)
		{
			base.enabled = false;
			UnityEngine.Object.DestroyImmediate(this);
			return;
		}
		instance = this;
		UnityEngine.Debug.Log(string.Concat("Unity v", UnityEngine.Application.unityVersion, ", Oculus Utilities v", OVRPlugin.wrapperVersion, ", OVRPlugin v", OVRPlugin.version, ", SDK v", OVRPlugin.nativeSDKVersion, "."));
		RuntimePlatform platform = UnityEngine.Application.platform;
		isSupportedPlatform |= platform == RuntimePlatform.Android;
		isSupportedPlatform |= platform == RuntimePlatform.OSXEditor;
		isSupportedPlatform |= platform == RuntimePlatform.OSXPlayer;
		isSupportedPlatform |= platform == RuntimePlatform.WindowsEditor;
		isSupportedPlatform |= platform == RuntimePlatform.WindowsPlayer;
		if (!isSupportedPlatform)
		{
			UnityEngine.Debug.LogWarning("This platform is unsupported");
			return;
		}
		chromatic = false;
		Initialize();
		if (resetTrackerOnLoad)
		{
			display.RecenterPose();
		}
	}

	private void Initialize()
	{
		if (display == null)
		{
			display = new OVRDisplay();
		}
		if (tracker == null)
		{
			tracker = new OVRTracker();
		}
		if (boundary == null)
		{
			boundary = new OVRBoundary();
		}
	}

	private void Update()
	{
		if (OVRPlugin.shouldQuit)
		{
			UnityEngine.Application.Quit();
		}
		if (AllowRecenter && OVRPlugin.shouldRecenter)
		{
			display.RecenterPose();
		}
		if (trackingOriginType != _trackingOriginType)
		{
			trackingOriginType = _trackingOriginType;
		}
		tracker.isEnabled = usePositionTracking;
		OVRPlugin.rotation = useRotationTracking;
		OVRPlugin.useIPDInPositionTracking = useIPDInPositionTracking;
		isHmdPresent = OVRPlugin.hmdPresent;
		if (useRecommendedMSAALevel && QualitySettings.antiAliasing != display.recommendedMSAALevel)
		{
			UnityEngine.Debug.Log("The current MSAA level is " + QualitySettings.antiAliasing + ", but the recommended MSAA level is " + display.recommendedMSAALevel + ". Switching to the recommended level.");
			QualitySettings.antiAliasing = display.recommendedMSAALevel;
		}
		if (_wasHmdPresent && !isHmdPresent)
		{
			try
			{
				if (OVRManager.HMDLost != null)
				{
					OVRManager.HMDLost();
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex);
			}
		}
		if (!_wasHmdPresent && isHmdPresent)
		{
			try
			{
				if (OVRManager.HMDAcquired != null)
				{
					OVRManager.HMDAcquired();
				}
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex2);
			}
		}
		_wasHmdPresent = isHmdPresent;
		isUserPresent = OVRPlugin.userPresent;
		if (_wasUserPresent && !isUserPresent)
		{
			try
			{
				if (OVRManager.HMDUnmounted != null)
				{
					OVRManager.HMDUnmounted();
				}
			}
			catch (Exception ex3)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex3);
			}
		}
		if (!_wasUserPresent && isUserPresent)
		{
			try
			{
				if (OVRManager.HMDMounted != null)
				{
					OVRManager.HMDMounted();
				}
			}
			catch (Exception ex4)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex4);
			}
		}
		_wasUserPresent = isUserPresent;
		hasVrFocus = OVRPlugin.hasVrFocus;
		if (_hadVrFocus && !hasVrFocus)
		{
			try
			{
				if (OVRManager.VrFocusLost != null)
				{
					OVRManager.VrFocusLost();
				}
			}
			catch (Exception ex5)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex5);
			}
		}
		if (!_hadVrFocus && hasVrFocus)
		{
			try
			{
				if (OVRManager.VrFocusAcquired != null)
				{
					OVRManager.VrFocusAcquired();
				}
			}
			catch (Exception ex6)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex6);
			}
		}
		_hadVrFocus = hasVrFocus;
		bool flag = OVRPlugin.hasInputFocus;
		if (_hadInputFocus && !flag)
		{
			try
			{
				if (OVRManager.InputFocusLost != null)
				{
					OVRManager.InputFocusLost();
				}
			}
			catch (Exception ex7)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex7);
			}
		}
		if (!_hadInputFocus && flag)
		{
			try
			{
				if (OVRManager.InputFocusAcquired != null)
				{
					OVRManager.InputFocusAcquired();
				}
			}
			catch (Exception ex8)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex8);
			}
		}
		_hadInputFocus = flag;
		string text = OVRPlugin.audioOutId;
		if (!prevAudioOutIdIsCached)
		{
			prevAudioOutId = text;
			prevAudioOutIdIsCached = true;
		}
		else if (text != prevAudioOutId)
		{
			try
			{
				if (OVRManager.AudioOutChanged != null)
				{
					OVRManager.AudioOutChanged();
				}
			}
			catch (Exception ex9)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex9);
			}
			prevAudioOutId = text;
		}
		string text2 = OVRPlugin.audioInId;
		if (!prevAudioInIdIsCached)
		{
			prevAudioInId = text2;
			prevAudioInIdIsCached = true;
		}
		else if (text2 != prevAudioInId)
		{
			try
			{
				if (OVRManager.AudioInChanged != null)
				{
					OVRManager.AudioInChanged();
				}
			}
			catch (Exception ex10)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex10);
			}
			prevAudioInId = text2;
		}
		if (wasPositionTracked && !tracker.isPositionTracked)
		{
			try
			{
				if (OVRManager.TrackingLost != null)
				{
					OVRManager.TrackingLost();
				}
			}
			catch (Exception ex11)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex11);
			}
		}
		if (!wasPositionTracked && tracker.isPositionTracked)
		{
			try
			{
				if (OVRManager.TrackingAcquired != null)
				{
					OVRManager.TrackingAcquired();
				}
			}
			catch (Exception ex12)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex12);
			}
		}
		wasPositionTracked = tracker.isPositionTracked;
		display.Update();
		OVRInput.Update();
	}

	private Camera FindMainCamera()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("MainCamera");
		List<Camera> list = new List<Camera>(4);
		GameObject[] array2 = array;
		foreach (GameObject gameObject in array2)
		{
			Camera component = gameObject.GetComponent<Camera>();
			if (component != null && component.enabled)
			{
				OVRCameraRig componentInParent = component.GetComponentInParent<OVRCameraRig>();
				if (componentInParent != null && componentInParent.trackingSpace != null)
				{
					list.Add(component);
				}
			}
		}
		if (list.Count == 0)
		{
			return Camera.main;
		}
		if (list.Count == 1)
		{
			return list[0];
		}
		if (!multipleMainCameraWarningPresented)
		{
			UnityEngine.Debug.LogWarning("Multiple MainCamera found. Assume the real MainCamera is the camera with the least depth");
			multipleMainCameraWarningPresented = true;
		}
		list.Sort((Camera c0, Camera c1) => (c0.depth < c1.depth) ? (-1) : ((c0.depth > c1.depth) ? 1 : 0));
		return list[0];
	}

	private void OnDisable()
	{
	}

	private void LateUpdate()
	{
		OVRHaptics.Process();
	}

	private void FixedUpdate()
	{
		OVRInput.FixedUpdate();
	}

	public void ReturnToLauncher()
	{
		PlatformUIConfirmQuit();
	}

	public static void PlatformUIConfirmQuit()
	{
		if (isHmdPresent)
		{
			OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		}
	}
}
public abstract class OVROnCompleteListener : AndroidJavaProxy
{
	public OVROnCompleteListener()
		: base("com.oculus.svclib.OnCompleteListener")
	{
	}

	public abstract void onSuccess();

	public abstract void onFailure();
}
public class OVROverlay : UnityEngine.MonoBehaviour
{
	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4,
		Equirect = 5
	}

	public enum OverlayType
	{
		None,
		Underlay,
		Overlay
	}

	private struct LayerTexture
	{
		public Texture appTexture;

		public IntPtr appTexturePtr;

		public Texture[] swapChain;

		public IntPtr[] swapChainPtr;
	}

	public OverlayType currentOverlayType = OverlayType.Overlay;

	public bool isDynamic;

	public bool isProtectedContent;

	public OverlayShape currentOverlayShape;

	private OverlayShape prevOverlayShape;

	public Texture[] textures = new Texture[2];

	protected IntPtr[] texturePtrs = new IntPtr[2]
	{
		IntPtr.Zero,
		IntPtr.Zero
	};

	protected bool isOverridePending;

	internal const int maxInstances = 3;

	internal static OVROverlay[] instances = new OVROverlay[3];

	private static Material tex2DMaterial;

	private static Material cubeMaterial;

	private OVRPlugin.LayerLayout layout = OVRPlugin.LayerLayout.Mono;

	private LayerTexture[] layerTextures;

	private OVRPlugin.LayerDesc layerDesc;

	private int stageCount = -1;

	private int layerIndex = -1;

	private int layerId;

	private GCHandle layerIdHandle;

	private IntPtr layerIdPtr = IntPtr.Zero;

	private int frameIndex;

	private int prevFrameIndex = -1;

	private Renderer rend;

	private int texturesPerStage => (layout != 0) ? 1 : 2;

	public void OverrideOverlayTextureInfo(Texture srcTexture, IntPtr nativePtr, VRNode node)
	{
		int num = ((node == VRNode.RightEye) ? 1 : 0);
		if (textures.Length > num)
		{
			textures[num] = srcTexture;
			texturePtrs[num] = nativePtr;
			isOverridePending = true;
		}
	}

	private bool CreateLayer(int mipLevels, int sampleCount, OVRPlugin.EyeTextureFormat etFormat, int flags, OVRPlugin.Sizei size, OVRPlugin.OverlayShape shape)
	{
		if (!layerIdHandle.IsAllocated || layerIdPtr == IntPtr.Zero)
		{
			layerIdHandle = GCHandle.Alloc(layerId, GCHandleType.Pinned);
			layerIdPtr = layerIdHandle.AddrOfPinnedObject();
		}
		if (layerIndex == -1)
		{
			for (int i = 0; i < 3; i++)
			{
				if (instances[i] == null || instances[i] == this)
				{
					layerIndex = i;
					instances[i] = this;
					break;
				}
			}
		}
		if (!isOverridePending && layerDesc.MipLevels == mipLevels && layerDesc.SampleCount == sampleCount && layerDesc.Format == etFormat && layerDesc.LayerFlags == flags && layerDesc.TextureSize.Equals(size) && layerDesc.Shape == shape)
		{
			return false;
		}
		OVRPlugin.LayerDesc desc = OVRPlugin.CalculateLayerDesc(shape, layout, size, mipLevels, sampleCount, etFormat, flags);
		OVRPlugin.EnqueueSetupLayer(desc, layerIdPtr);
		layerId = (int)layerIdHandle.Target;
		if (layerId > 0)
		{
			layerDesc = desc;
			stageCount = OVRPlugin.GetLayerTextureStageCount(layerId);
		}
		isOverridePending = false;
		return true;
	}

	private bool CreateLayerTextures(bool useMipmaps, OVRPlugin.Sizei size, bool isHdr)
	{
		bool result = false;
		if (stageCount <= 0)
		{
			return false;
		}
		if (layerTextures == null)
		{
			frameIndex = 0;
			layerTextures = new LayerTexture[texturesPerStage];
		}
		for (int i = 0; i < texturesPerStage; i++)
		{
			if (layerTextures[i].swapChain == null)
			{
				layerTextures[i].swapChain = new Texture[stageCount];
			}
			if (layerTextures[i].swapChainPtr == null)
			{
				layerTextures[i].swapChainPtr = new IntPtr[stageCount];
			}
			for (int j = 0; j < stageCount; j++)
			{
				Texture texture = layerTextures[i].swapChain[j];
				IntPtr intPtr = layerTextures[i].swapChainPtr[j];
				if (texture != null && intPtr != IntPtr.Zero)
				{
					continue;
				}
				if (intPtr == IntPtr.Zero)
				{
					intPtr = OVRPlugin.GetLayerTexture(layerId, j, (OVRPlugin.Eye)i);
				}
				if (!(intPtr == IntPtr.Zero))
				{
					TextureFormat format = ((!isHdr) ? TextureFormat.RGBA32 : TextureFormat.RGBAHalf);
					if (currentOverlayShape != OverlayShape.Cubemap && currentOverlayShape != OverlayShape.OffcenterCubemap)
					{
						texture = Texture2D.CreateExternalTexture(size.w, size.h, format, useMipmaps, linear: true, intPtr);
					}
					layerTextures[i].swapChain[j] = texture;
					layerTextures[i].swapChainPtr[j] = intPtr;
					result = true;
				}
			}
		}
		return result;
	}

	private void DestroyLayerTextures()
	{
		int num = 0;
		while (layerTextures != null && num < texturesPerStage)
		{
			if (layerTextures[num].swapChain != null)
			{
				for (int i = 0; i < stageCount; i++)
				{
					UnityEngine.Object.DestroyImmediate(layerTextures[num].swapChain[i]);
				}
			}
			num++;
		}
		layerTextures = null;
	}

	private void DestroyLayer()
	{
		if (layerIndex != -1)
		{
			OVRPlugin.EnqueueSubmitLayer(onTop: true, headLocked: false, IntPtr.Zero, IntPtr.Zero, -1, 0, OVRPose.identity.ToPosef(), Vector3.one.ToVector3f(), layerIndex, (OVRPlugin.OverlayShape)prevOverlayShape);
			instances[layerIndex] = null;
			layerIndex = -1;
		}
		if (layerIdPtr != IntPtr.Zero)
		{
			OVRPlugin.EnqueueDestroyLayer(layerIdPtr);
			layerIdPtr = IntPtr.Zero;
			layerIdHandle.Free();
			layerId = 0;
		}
		layerDesc = default(OVRPlugin.LayerDesc);
	}

	private bool LatchLayerTextures()
	{
		for (int i = 0; i < texturesPerStage; i++)
		{
			if ((textures[i] != layerTextures[i].appTexture || layerTextures[i].appTexturePtr == IntPtr.Zero) && textures[i] != null)
			{
				RenderTexture renderTexture = textures[i] as RenderTexture;
				if ((bool)renderTexture && !renderTexture.IsCreated())
				{
					renderTexture.Create();
				}
				layerTextures[i].appTexturePtr = ((!(texturePtrs[i] != IntPtr.Zero)) ? textures[i].GetNativeTexturePtr() : texturePtrs[i]);
				if (layerTextures[i].appTexturePtr != IntPtr.Zero)
				{
					layerTextures[i].appTexture = textures[i];
				}
			}
			if (currentOverlayShape == OverlayShape.Cubemap && textures[i] as Cubemap == null)
			{
				UnityEngine.Debug.LogError("Need Cubemap texture for cube map overlay");
				return false;
			}
		}
		if (layerTextures[0].appTexture == null || layerTextures[0].appTexturePtr == IntPtr.Zero)
		{
			return false;
		}
		return true;
	}

	private OVRPlugin.LayerDesc GetCurrentLayerDesc()
	{
		OVRPlugin.LayerDesc layerDesc = default(OVRPlugin.LayerDesc);
		layerDesc.Format = OVRPlugin.EyeTextureFormat.Default;
		layerDesc.LayerFlags = 8;
		layerDesc.Layout = layout;
		layerDesc.MipLevels = 1;
		layerDesc.SampleCount = 1;
		layerDesc.Shape = (OVRPlugin.OverlayShape)currentOverlayShape;
		layerDesc.TextureSize = new OVRPlugin.Sizei
		{
			w = textures[0].width,
			h = textures[0].height
		};
		OVRPlugin.LayerDesc result = layerDesc;
		Texture2D texture2D = textures[0] as Texture2D;
		if (texture2D != null)
		{
			if (texture2D.format == TextureFormat.RGBAHalf || texture2D.format == TextureFormat.RGBAFloat)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
			result.MipLevels = texture2D.mipmapCount;
		}
		Cubemap cubemap = textures[0] as Cubemap;
		if (cubemap != null)
		{
			if (cubemap.format == TextureFormat.RGBAHalf || cubemap.format == TextureFormat.RGBAFloat)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
			result.MipLevels = cubemap.mipmapCount;
		}
		RenderTexture renderTexture = textures[0] as RenderTexture;
		if (renderTexture != null)
		{
			result.SampleCount = renderTexture.antiAliasing;
			if (renderTexture.format == RenderTextureFormat.ARGBHalf || renderTexture.format == RenderTextureFormat.ARGBFloat || renderTexture.format == RenderTextureFormat.RGB111110Float)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
		}
		if (isProtectedContent)
		{
			result.LayerFlags |= 64;
		}
		return result;
	}

	private bool PopulateLayer(int mipLevels, bool isHdr, OVRPlugin.Sizei size, int sampleCount)
	{
		bool result = false;
		RenderTextureFormat format = (isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
		for (int i = 0; i < texturesPerStage; i++)
		{
			int dstElement = ((layout == OVRPlugin.LayerLayout.Array) ? i : 0);
			int num = frameIndex % stageCount;
			Texture texture = layerTextures[i].swapChain[num];
			if (texture == null)
			{
				continue;
			}
			for (int j = 0; j < mipLevels; j++)
			{
				int num2 = size.w >> j;
				if (num2 < 1)
				{
					num2 = 1;
				}
				int num3 = size.h >> j;
				if (num3 < 1)
				{
					num3 = 1;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(num2, num3, 0, format, RenderTextureReadWrite.Linear, sampleCount);
				if (!temporary.IsCreated())
				{
					temporary.Create();
				}
				temporary.DiscardContents();
				RenderTexture renderTexture = textures[i] as RenderTexture;
				bool flag = isHdr || QualitySettings.activeColorSpace == ColorSpace.Linear;
				flag |= renderTexture != null && renderTexture.sRGB;
				flag = true;
				if (currentOverlayShape != OverlayShape.Cubemap && currentOverlayShape != OverlayShape.OffcenterCubemap)
				{
					tex2DMaterial.SetInt("_linearToSrgb", (!isHdr && flag) ? 1 : 0);
					UnityEngine.Graphics.Blit(textures[i], temporary, tex2DMaterial);
					UnityEngine.Graphics.CopyTexture(temporary, 0, 0, texture, dstElement, j);
				}
				RenderTexture.ReleaseTemporary(temporary);
				result = true;
			}
		}
		return result;
	}

	private bool SubmitLayer(bool overlay, bool headLocked, OVRPose pose, Vector3 scale)
	{
		int num = ((texturesPerStage >= 2) ? 1 : 0);
		bool result = OVRPlugin.EnqueueSubmitLayer(overlay, headLocked, layerTextures[0].appTexturePtr, layerTextures[num].appTexturePtr, layerId, frameIndex, pose.flipZ().ToPosef(), scale.ToVector3f(), layerIndex, (OVRPlugin.OverlayShape)currentOverlayShape);
		if (isDynamic)
		{
			frameIndex++;
		}
		prevOverlayShape = currentOverlayShape;
		return result;
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("Overlay Awake");
		if (tex2DMaterial == null)
		{
			tex2DMaterial = new Material(Shader.Find("Oculus/Texture2D Blit"));
		}
		if (cubeMaterial == null)
		{
			cubeMaterial = new Material(Shader.Find("Oculus/Cubemap Blit"));
		}
		rend = GetComponent<Renderer>();
		if (textures.Length == 0)
		{
			textures = new Texture[1];
		}
		if (rend != null && textures[0] == null)
		{
			textures[0] = rend.material.mainTexture;
		}
		if (textures.Length == 2 && textures[1] != null)
		{
			layout = OVRPlugin.LayerLayout.Stereo;
		}
	}

	private void OnEnable()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
	}

	private void OnDisable()
	{
		DestroyLayerTextures();
		DestroyLayer();
	}

	private void OnDestroy()
	{
		DestroyLayerTextures();
		DestroyLayer();
	}

	private bool ComputeSubmit(ref OVRPose pose, ref Vector3 scale, ref bool overlay, ref bool headLocked)
	{
		Camera main = Camera.main;
		overlay = currentOverlayType == OverlayType.Overlay;
		headLocked = false;
		Transform parent = base.transform;
		while (parent != null && !headLocked)
		{
			headLocked |= parent == main.transform;
			parent = parent.parent;
		}
		pose = ((!headLocked) ? base.transform.ToTrackingSpacePose(main) : base.transform.ToHeadSpacePose(main));
		scale = base.transform.lossyScale;
		for (int i = 0; i < 3; i++)
		{
			scale[i] /= main.transform.lossyScale[i];
		}
		if (currentOverlayShape == OverlayShape.Cubemap)
		{
			pose.position = main.transform.position;
		}
		if (currentOverlayShape == OverlayShape.OffcenterCubemap)
		{
			pose.position = base.transform.position;
			if (pose.position.magnitude > 1f)
			{
				UnityEngine.Debug.LogWarning("Your cube map center offset's magnitude is greater than 1, which will cause some cube map pixel always invisible .");
				return false;
			}
		}
		if (currentOverlayShape == OverlayShape.Cylinder)
		{
			float num = scale.x / scale.z / (float)Math.PI * 180f;
			if (num > 180f)
			{
				UnityEngine.Debug.LogWarning("Cylinder overlay's arc angle has to be below 180 degree, current arc angle is " + num + " degree.");
				return false;
			}
		}
		return true;
	}

	private void LateUpdate()
	{
		if (currentOverlayType == OverlayType.None || textures.Length < texturesPerStage || textures[0] == null || Time.frameCount <= prevFrameIndex)
		{
			return;
		}
		prevFrameIndex = Time.frameCount;
		OVRPose pose = OVRPose.identity;
		Vector3 scale = Vector3.one;
		bool overlay = false;
		bool headLocked = false;
		if (!ComputeSubmit(ref pose, ref scale, ref overlay, ref headLocked))
		{
			return;
		}
		OVRPlugin.LayerDesc currentLayerDesc = GetCurrentLayerDesc();
		bool isHdr = currentLayerDesc.Format == OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
		bool flag = CreateLayer(currentLayerDesc.MipLevels, currentLayerDesc.SampleCount, currentLayerDesc.Format, currentLayerDesc.LayerFlags, currentLayerDesc.TextureSize, currentLayerDesc.Shape);
		if (layerIndex == -1 || layerId <= 0)
		{
			return;
		}
		bool useMipmaps = currentLayerDesc.MipLevels > 1;
		flag |= CreateLayerTextures(useMipmaps, currentLayerDesc.TextureSize, isHdr);
		if (layerTextures[0].appTexture as RenderTexture != null)
		{
			isDynamic = true;
		}
		if (LatchLayerTextures() && PopulateLayer(currentLayerDesc.MipLevels, isHdr, currentLayerDesc.TextureSize, currentLayerDesc.SampleCount))
		{
			bool flag2 = SubmitLayer(overlay, headLocked, pose, scale);
			if ((bool)rend)
			{
				rend.enabled = !flag2;
			}
		}
	}
}
public class OVRPlatformMenu : UnityEngine.MonoBehaviour
{
	public enum eHandler
	{
		ShowConfirmQuit,
		RetreatOneLevel
	}

	private enum eBackButtonAction
	{
		NONE,
		SHORT_PRESS
	}

	private OVRInput.RawButton inputCode = OVRInput.RawButton.Back;

	public eHandler shortPressHandler;

	public Func<bool> OnShortPress;

	private static Stack<string> sceneStack = new Stack<string>();

	private eBackButtonAction HandleBackButtonState()
	{
		eBackButtonAction result = eBackButtonAction.NONE;
		if (OVRInput.GetDown(inputCode))
		{
			result = eBackButtonAction.SHORT_PRESS;
		}
		return result;
	}

	private void Awake()
	{
		if (shortPressHandler == eHandler.RetreatOneLevel && OnShortPress == null)
		{
			OnShortPress = RetreatOneLevel;
		}
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
		else
		{
			sceneStack.Push(SceneManager.GetActiveScene().name);
		}
	}

	private void ShowConfirmQuitMenu()
	{
		UnityEngine.Debug.Log("[PlatformUI-ConfirmQuit] Showing @ " + Time.time);
		OVRManager.PlatformUIConfirmQuit();
	}

	private static bool RetreatOneLevel()
	{
		if (sceneStack.Count > 1)
		{
			string sceneName = sceneStack.Pop();
			SceneManager.LoadSceneAsync(sceneName);
			return false;
		}
		return true;
	}

	private void Update()
	{
		eBackButtonAction eBackButtonAction = HandleBackButtonState();
		if (eBackButtonAction == eBackButtonAction.SHORT_PRESS && (OnShortPress == null || OnShortPress()))
		{
			ShowConfirmQuitMenu();
		}
	}
}
internal static class OVRPlugin
{
	[StructLayout(LayoutKind.Sequential)]
	private class GUID
	{
		public int a;

		public short b;

		public short c;

		public byte d0;

		public byte d1;

		public byte d2;

		public byte d3;

		public byte d4;

		public byte d5;

		public byte d6;

		public byte d7;
	}

	public enum Bool
	{
		False,
		True
	}

	public enum Result
	{
		Success = 0,
		Failure = -1000,
		Failure_InvalidParameter = -1001,
		Failure_NotInitialized = -1002,
		Failure_InvalidOperation = -1003,
		Failure_Unsupported = -1004,
		Failure_NotYetImplemented = -1005,
		Failure_OperationFailed = -1006,
		Failure_InsufficientSize = -1007
	}

	public enum CameraStatus
	{
		CameraStatus_None = 0,
		CameraStatus_Connected = 1,
		CameraStatus_Calibrating = 2,
		CameraStatus_CalibrationFailed = 3,
		CameraStatus_Calibrated = 4,
		CameraStatus_EnumSize = int.MaxValue
	}

	public enum Eye
	{
		None = -1,
		Left,
		Right,
		Count
	}

	public enum Tracker
	{
		None = -1,
		Zero,
		One,
		Two,
		Three,
		Count
	}

	public enum Node
	{
		None = -1,
		EyeLeft,
		EyeRight,
		EyeCenter,
		HandLeft,
		HandRight,
		TrackerZero,
		TrackerOne,
		TrackerTwo,
		TrackerThree,
		Head,
		DeviceObjectZero,
		Count
	}

	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 16,
		Touchpad = 134217728,
		LTrackedRemote = 16777216,
		RTrackedRemote = 33554432,
		Active = int.MinValue,
		All = -1
	}

	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		Count
	}

	public enum RecenterFlags
	{
		Default = 0,
		Controllers = 1073741824,
		IgnoreAll = int.MinValue,
		Count = -2147483647
	}

	public enum BatteryStatus
	{
		Charging,
		Discharging,
		Full,
		NotCharging,
		Unknown
	}

	public enum EyeTextureFormat
	{
		Default = 0,
		R8G8B8A8_sRGB = 0,
		R8G8B8A8 = 1,
		R16G16B16A16_FP = 2,
		R11G11B10_FP = 3,
		B8G8R8A8_sRGB = 4,
		B8G8R8A8 = 5,
		R5G6B5 = 11,
		EnumSize = int.MaxValue
	}

	public enum PlatformUI
	{
		None = -1,
		ConfirmQuit = 1,
		GlobalMenuTutorial = 2
	}

	public enum SystemRegion
	{
		Unspecified,
		Japan,
		China
	}

	public enum SystemHeadset
	{
		None = 0,
		GearVR_R320 = 1,
		GearVR_R321 = 2,
		GearVR_R322 = 3,
		GearVR_R323 = 4,
		GearVR_R324 = 5,
		GearVR_R325 = 6,
		Oculus_Go = 7,
		Rift_DK1 = 4096,
		Rift_DK2 = 4097,
		Rift_CV1 = 4098
	}

	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4,
		Equirect = 5
	}

	public enum Step
	{
		Render = -1,
		Physics
	}

	public enum CameraDevice
	{
		None = 0,
		WebCamera0 = 100,
		WebCamera1 = 101,
		ZEDCamera = 300
	}

	public enum CameraDeviceDepthSensingMode
	{
		Standard,
		Fill
	}

	public enum CameraDeviceDepthQuality
	{
		Low,
		Medium,
		High
	}

	public enum TiledMultiResLevel
	{
		Off = 0,
		LMSLow = 1,
		LMSMedium = 2,
		LMSHigh = 3,
		EnumSize = int.MaxValue
	}

	public struct CameraDeviceIntrinsicsParameters
	{
		private float fx;

		private float fy;

		private float cx;

		private float cy;

		private double disto0;

		private double disto1;

		private double disto2;

		private double disto3;

		private double disto4;

		private float v_fov;

		private float h_fov;

		private float d_fov;

		private int w;

		private int h;
	}

	private enum OverlayFlag
	{
		None = 0,
		OnTop = 1,
		HeadLocked = 2,
		ShapeFlag_Quad = 0,
		ShapeFlag_Cylinder = 16,
		ShapeFlag_Cubemap = 32,
		ShapeFlag_OffcenterCubemap = 64,
		ShapeFlagRangeMask = 240
	}

	public struct Vector2f
	{
		public float x;

		public float y;
	}

	public struct Vector3f
	{
		public float x;

		public float y;

		public float z;

		public override string ToString()
		{
			return $"{x}, {y}, {z}";
		}
	}

	public struct Quatf
	{
		public float x;

		public float y;

		public float z;

		public float w;

		public override string ToString()
		{
			return $"{x}, {y}, {z}, {w}";
		}
	}

	public struct Posef
	{
		public Quatf Orientation;

		public Vector3f Position;

		public override string ToString()
		{
			return $"Position ({Position}), Orientation({Orientation})";
		}
	}

	public struct PoseStatef
	{
		public Posef Pose;

		public Vector3f Velocity;

		public Vector3f Acceleration;

		public Vector3f AngularVelocity;

		public Vector3f AngularAcceleration;

		private double Time;
	}

	public struct ControllerState4
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;

		public Vector2f LTouchpad;

		public Vector2f RTouchpad;

		public byte LBatteryPercentRemaining;

		public byte RBatteryPercentRemaining;

		public byte LRecenterCount;

		public byte RRecenterCount;

		public byte Reserved_27;

		public byte Reserved_26;

		public byte Reserved_25;

		public byte Reserved_24;

		public byte Reserved_23;

		public byte Reserved_22;

		public byte Reserved_21;

		public byte Reserved_20;

		public byte Reserved_19;

		public byte Reserved_18;

		public byte Reserved_17;

		public byte Reserved_16;

		public byte Reserved_15;

		public byte Reserved_14;

		public byte Reserved_13;

		public byte Reserved_12;

		public byte Reserved_11;

		public byte Reserved_10;

		public byte Reserved_09;

		public byte Reserved_08;

		public byte Reserved_07;

		public byte Reserved_06;

		public byte Reserved_05;

		public byte Reserved_04;

		public byte Reserved_03;

		public byte Reserved_02;

		public byte Reserved_01;

		public byte Reserved_00;

		public ControllerState4(ControllerState2 cs)
		{
			ConnectedControllers = cs.ConnectedControllers;
			Buttons = cs.Buttons;
			Touches = cs.Touches;
			NearTouches = cs.NearTouches;
			LIndexTrigger = cs.LIndexTrigger;
			RIndexTrigger = cs.RIndexTrigger;
			LHandTrigger = cs.LHandTrigger;
			RHandTrigger = cs.RHandTrigger;
			LThumbstick = cs.LThumbstick;
			RThumbstick = cs.RThumbstick;
			LTouchpad = cs.LTouchpad;
			RTouchpad = cs.RTouchpad;
			LBatteryPercentRemaining = 0;
			RBatteryPercentRemaining = 0;
			LRecenterCount = 0;
			RRecenterCount = 0;
			Reserved_27 = 0;
			Reserved_26 = 0;
			Reserved_25 = 0;
			Reserved_24 = 0;
			Reserved_23 = 0;
			Reserved_22 = 0;
			Reserved_21 = 0;
			Reserved_20 = 0;
			Reserved_19 = 0;
			Reserved_18 = 0;
			Reserved_17 = 0;
			Reserved_16 = 0;
			Reserved_15 = 0;
			Reserved_14 = 0;
			Reserved_13 = 0;
			Reserved_12 = 0;
			Reserved_11 = 0;
			Reserved_10 = 0;
			Reserved_09 = 0;
			Reserved_08 = 0;
			Reserved_07 = 0;
			Reserved_06 = 0;
			Reserved_05 = 0;
			Reserved_04 = 0;
			Reserved_03 = 0;
			Reserved_02 = 0;
			Reserved_01 = 0;
			Reserved_00 = 0;
		}
	}

	public struct ControllerState2
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;

		public Vector2f LTouchpad;

		public Vector2f RTouchpad;

		public ControllerState2(ControllerState cs)
		{
			ConnectedControllers = cs.ConnectedControllers;
			Buttons = cs.Buttons;
			Touches = cs.Touches;
			NearTouches = cs.NearTouches;
			LIndexTrigger = cs.LIndexTrigger;
			RIndexTrigger = cs.RIndexTrigger;
			LHandTrigger = cs.LHandTrigger;
			RHandTrigger = cs.RHandTrigger;
			LThumbstick = cs.LThumbstick;
			RThumbstick = cs.RThumbstick;
			LTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
			RTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
		}
	}

	public struct ControllerState
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;
	}

	public struct HapticsBuffer
	{
		public IntPtr Samples;

		public int SamplesCount;
	}

	public struct HapticsState
	{
		public int SamplesAvailable;

		public int SamplesQueued;
	}

	public struct HapticsDesc
	{
		public int SampleRateHz;

		public int SampleSizeInBytes;

		public int MinimumSafeSamplesQueued;

		public int MinimumBufferSamplesCount;

		public int OptimalBufferSamplesCount;

		public int MaximumBufferSamplesCount;
	}

	public struct AppPerfFrameStats
	{
		public int HmdVsyncIndex;

		public int AppFrameIndex;

		public int AppDroppedFrameCount;

		public float AppMotionToPhotonLatency;

		public float AppQueueAheadTime;

		public float AppCpuElapsedTime;

		public float AppGpuElapsedTime;

		public int CompositorFrameIndex;

		public int CompositorDroppedFrameCount;

		public float CompositorLatency;

		public float CompositorCpuElapsedTime;

		public float CompositorGpuElapsedTime;

		public float CompositorCpuStartToGpuEndElapsedTime;

		public float CompositorGpuEndToVsyncElapsedTime;
	}

	public struct AppPerfStats
	{
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
		public AppPerfFrameStats[] FrameStats;

		public int FrameStatsCount;

		public Bool AnyFrameStatsDropped;

		public float AdaptiveGpuPerformanceScale;
	}

	public struct Sizei
	{
		public int w;

		public int h;
	}

	public struct Sizef
	{
		public float w;

		public float h;
	}

	public struct Vector2i
	{
		public int x;

		public int y;
	}

	public struct Recti
	{
		private Vector2i Pos;

		private Sizei Size;
	}

	public struct Rectf
	{
		private Vector2f Pos;

		private Sizef Size;
	}

	public struct Frustumf
	{
		public float zNear;

		public float zFar;

		public float fovX;

		public float fovY;
	}

	public enum BoundaryType
	{
		OuterBoundary = 1,
		PlayArea = 0x100
	}

	public struct BoundaryTestResult
	{
		public Bool IsTriggering;

		public float ClosestDistance;

		public Vector3f ClosestPoint;

		public Vector3f ClosestPointNormal;
	}

	public struct BoundaryLookAndFeel
	{
		public Colorf Color;
	}

	public struct BoundaryGeometry
	{
		public BoundaryType BoundaryType;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		public Vector3f[] Points;

		public int PointsCount;
	}

	public struct Colorf
	{
		public float r;

		public float g;

		public float b;

		public float a;
	}

	public struct Fovf
	{
		public float UpTan;

		public float DownTan;

		public float LeftTan;

		public float RightTan;
	}

	public struct CameraIntrinsics
	{
		public bool IsValid;

		public double LastChangedTimeSeconds;

		public Fovf FOVPort;

		public float VirtualNearPlaneDistanceMeters;

		public float VirtualFarPlaneDistanceMeters;

		public Sizei ImageSensorPixelResolution;
	}

	public struct CameraExtrinsics
	{
		public bool IsValid;

		public double LastChangedTimeSeconds;

		public CameraStatus CameraStatusData;

		public Node AttachedToNode;

		public Posef RelativePose;
	}

	public enum LayerLayout
	{
		Stereo = 0,
		Mono = 1,
		DoubleWide = 2,
		Array = 3,
		EnumSize = 15
	}

	public enum LayerFlags
	{
		Static = 1,
		LoadingScreen = 2,
		SymmetricFov = 4,
		TextureOriginAtBottomLeft = 8,
		ChromaticAberrationCorrection = 0x10,
		NoAllocation = 0x20,
		ProtectedContent = 0x40
	}

	public struct LayerDesc
	{
		public OverlayShape Shape;

		public LayerLayout Layout;

		public Sizei TextureSize;

		public int MipLevels;

		public int SampleCount;

		public EyeTextureFormat Format;

		public int LayerFlags;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public Fovf[] Fov;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public Rectf[] VisibleRect;

		public Sizei MaxViewportSize;

		private EyeTextureFormat DepthFormat;

		public override string ToString()
		{
			string text = ", ";
			return Shape.ToString() + text + Layout.ToString() + text + TextureSize.w + "x" + TextureSize.h + text + MipLevels + text + SampleCount + text + Format.ToString() + text + LayerFlags;
		}
	}

	public struct LayerSubmit
	{
		private int LayerId;

		private int TextureStage;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		private Recti[] ViewportRect;

		private Posef Pose;

		private int LayerSubmitFlags;
	}

	private static class OVRP_0_1_0
	{
		public static readonly Version version = new Version(0, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Sizei ovrp_GetEyeTextureSize(Eye eyeId);
	}

	private static class OVRP_0_1_1
	{
		public static readonly Version version = new Version(0, 1, 1);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad2(Bool onTop, Bool headLocked, IntPtr texture, IntPtr device, Posef pose, Vector3f scale);
	}

	private static class OVRP_0_1_2
	{
		public static readonly Version version = new Version(0, 1, 2);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerVibration(uint controllerMask, float frequency, float amplitude);
	}

	private static class OVRP_0_1_3
	{
		public static readonly Version version = new Version(0, 1, 3);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration(Node nodeId);
	}

	private static class OVRP_0_5_0
	{
		public static readonly Version version = new Version(0, 5, 0);
	}

	private static class OVRP_1_0_0
	{
		public static readonly Version version = new Version(1, 0, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern TrackingOrigin ovrp_GetTrackingOriginType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOriginType(TrackingOrigin originType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetTrackingCalibratedOrigin();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_RecenterTrackingOrigin(uint flags);
	}

	private static class OVRP_1_1_0
	{
		public static readonly Version version = new Version(1, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetInitialized();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetNativeSDKVersion")]
		private static extern IntPtr _ovrp_GetNativeSDKVersion();

		public static string ovrp_GetNativeSDKVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetNativeSDKVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioOutId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioInId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeTextureScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeTextureScale(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOrientationEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingPositionEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePresent(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodeOrientationTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePositionTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Frustumf ovrp_GetNodeFrustum(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState ovrp_GetControllerState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemCpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemCpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemGpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemGpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemPowerSavingMode();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemDisplayFrequency();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemVSyncCount();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemVolume();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BatteryStatus ovrp_GetSystemBatteryStatus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryTemperature();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetSystemProductName")]
		private static extern IntPtr _ovrp_GetSystemProductName();

		public static string ovrp_GetSystemProductName()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetSystemProductName());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ShowSystemUI(PlatformUI ui);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppMonoscopic();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppMonoscopic(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppHasVrFocus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldQuit();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldRecenter();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetAppLatencyTimings")]
		private static extern IntPtr _ovrp_GetAppLatencyTimings();

		public static string ovrp_GetAppLatencyTimings()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetAppLatencyTimings());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetUserPresent();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserIPD();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserIPD(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeDepth();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeDepth(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeHeight();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeHeight(float value);
	}

	private static class OVRP_1_2_0
	{
		public static readonly Version version = new Version(1, 2, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemVSyncCount(int vsyncCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrpi_SetTrackingCalibratedOrigin();
	}

	private static class OVRP_1_3_0
	{
		public static readonly Version version = new Version(1, 3, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetEyeOcclusionMeshEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeOcclusionMeshEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemHeadphonesPresent();
	}

	private static class OVRP_1_5_0
	{
		public static readonly Version version = new Version(1, 5, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemRegion ovrp_GetSystemRegion();
	}

	private static class OVRP_1_6_0
	{
		public static readonly Version version = new Version(1, 6, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingIPDEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingIPDEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsDesc ovrp_GetControllerHapticsDesc(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsState ovrp_GetControllerHapticsState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad3(uint flags, IntPtr textureLeft, IntPtr textureRight, IntPtr device, Posef pose, Vector3f scale, int layerIndex);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeRecommendedResolutionScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetAppCpuStartToGpuEndTime();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemRecommendedMSAALevel();
	}

	private static class OVRP_1_7_0
	{
		public static readonly Version version = new Version(1, 7, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppChromaticCorrection();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppChromaticCorrection(Bool value);
	}

	private static class OVRP_1_8_0
	{
		public static readonly Version version = new Version(1, 8, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryConfigured();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryNode(Node nodeId, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryPoint(Vector3f point, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetBoundaryLookAndFeel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryGeometry ovrp_GetBoundaryGeometry(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Vector3f ovrp_GetBoundaryDimensions(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryVisible();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryVisible(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_Update2(int stateId, int frameIndex, double predictionSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration2(int stateId, Node nodeId);
	}

	private static class OVRP_1_9_0
	{
		public static readonly Version version = new Version(1, 9, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemHeadset ovrp_GetSystemHeadsetType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetActiveController();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetConnectedControllers();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern AppPerfStats ovrp_GetAppPerfStats();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetAppPerfStats();
	}

	private static class OVRP_1_10_0
	{
		public static readonly Version version = new Version(1, 10, 0);
	}

	private static class OVRP_1_11_0
	{
		public static readonly Version version = new Version(1, 11, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetDesiredEyeTextureFormat(EyeTextureFormat value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern EyeTextureFormat ovrp_GetDesiredEyeTextureFormat();
	}

	private static class OVRP_1_12_0
	{
		public static readonly Version version = new Version(1, 12, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetAppFramerate();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern PoseStatef ovrp_GetNodePoseState(Step stepId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState2 ovrp_GetControllerState2(uint controllerMask);
	}

	private static class OVRP_1_15_0
	{
		public const int OVRP_EXTERNAL_CAMERA_NAME_SIZE = 32;

		public static readonly Version version = new Version(1, 15, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_InitializeMixedReality();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_ShutdownMixedReality();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetMixedRealityInitialized();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_UpdateExternalCamera();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraCount(out int cameraCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraName(int cameraId, [MarshalAs(UnmanagedType.LPArray, SizeConst = 32)] char[] cameraName);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraIntrinsics(int cameraId, out CameraIntrinsics cameraIntrinsics);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraExtrinsics(int cameraId, out CameraExtrinsics cameraExtrinsics);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_CalculateLayerDesc(OverlayShape shape, LayerLayout layout, ref Sizei textureSize, int mipLevels, int sampleCount, EyeTextureFormat format, int layerFlags, ref LayerDesc layerDesc);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_EnqueueSetupLayer(ref LayerDesc desc, IntPtr layerId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_EnqueueDestroyLayer(IntPtr layerId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetLayerTextureStageCount(int layerId, ref int layerTextureStageCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetLayerTexturePtr(int layerId, int stage, Eye eyeId, ref IntPtr textureHandle);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_EnqueueSubmitLayer(uint flags, IntPtr textureLeft, IntPtr textureRight, int layerId, int frameIndex, ref Posef pose, ref Vector3f scale, int layerIndex);
	}

	private static class OVRP_1_16_0
	{
		public static readonly Version version = new Version(1, 16, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetControllerState4(uint controllerMask, ref ControllerState4 controllerState);
	}

	private static class OVRP_1_17_0
	{
		public static readonly Version version = new Version(1, 17, 0);
	}

	private static class OVRP_1_18_0
	{
		public static readonly Version version = new Version(1, 18, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SetHandNodePoseStateLatency(double latencyInSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetHandNodePoseStateLatency(out double latencyInSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetAppHasInputFocus(out Bool appHasInputFocus);
	}

	private static class OVRP_1_19_0
	{
		public static readonly Version version = new Version(1, 19, 0);
	}

	private static class OVRP_1_21_0
	{
		public static readonly Version version = new Version(1, 21, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetTiledMultiResSupported(out Bool foveationSupported);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetTiledMultiResLevel(out TiledMultiResLevel level);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SetTiledMultiResLevel(TiledMultiResLevel level);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetGPUUtilSupported(out Bool gpuUtilSupported);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetGPUUtilLevel(out float gpuUtil);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetSystemDisplayFrequency2(out float systemDisplayFrequency);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetSystemDisplayAvailableFrequencies(IntPtr systemDisplayAvailableFrequencies, out int numFrequencies);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SetSystemDisplayFrequency(float requestedFrequency);
	}

	private static class OVRP_1_24_2
	{
		public static readonly Version version = new Version(1, 24, 2);
	}

	public static readonly Version wrapperVersion = OVRP_1_24_2.version;

	private static Version _version;

	private static Version _nativeSDKVersion;

	private const int OverlayShapeFlagShift = 4;

	public const int AppPerfFrameStatsMaxCount = 5;

	private static GUID _nativeAudioOutGuid = new GUID();

	private static Guid _cachedAudioOutGuid;

	private static string _cachedAudioOutString;

	private static GUID _nativeAudioInGuid = new GUID();

	private static Guid _cachedAudioInGuid;

	private static string _cachedAudioInString;

	private static OVRNativeBuffer _nativeSystemDisplayFrequenciesAvailable = null;

	private static float[] _cachedSystemDisplayFrequenciesAvailable = null;

	private const string pluginName = "OVRPlugin";

	private static Version _versionZero = new Version(0, 0, 0);

	public static Version version
	{
		get
		{
			if (_version == null)
			{
				try
				{
					string text = OVRP_1_1_0.ovrp_GetVersion();
					if (text != null)
					{
						text = text.Split('-')[0];
						_version = new Version(text);
					}
					else
					{
						_version = _versionZero;
					}
				}
				catch
				{
					_version = _versionZero;
				}
				if (_version == OVRP_0_5_0.version)
				{
					_version = OVRP_0_1_0.version;
				}
				if (_version > _versionZero && _version < OVRP_1_3_0.version)
				{
					throw new PlatformNotSupportedException(string.Concat("Oculus Utilities version ", wrapperVersion, " is too new for OVRPlugin version ", _version.ToString(), ". Update to the latest version of Unity."));
				}
			}
			return _version;
		}
	}

	public static Version nativeSDKVersion
	{
		get
		{
			if (_nativeSDKVersion == null)
			{
				try
				{
					string empty = string.Empty;
					empty = ((!(version >= OVRP_1_1_0.version)) ? _versionZero.ToString() : OVRP_1_1_0.ovrp_GetNativeSDKVersion());
					if (empty != null)
					{
						empty = empty.Split('-')[0];
						_nativeSDKVersion = new Version(empty);
					}
					else
					{
						_nativeSDKVersion = _versionZero;
					}
				}
				catch
				{
					_nativeSDKVersion = _versionZero;
				}
			}
			return _nativeSDKVersion;
		}
	}

	public static bool initialized => OVRP_1_1_0.ovrp_GetInitialized() == Bool.True;

	public static bool chromatic
	{
		get
		{
			if (version >= OVRP_1_7_0.version)
			{
				return OVRP_1_7_0.ovrp_GetAppChromaticCorrection() == Bool.True;
			}
			return false;
		}
		set
		{
			if (version >= OVRP_1_7_0.version)
			{
				OVRP_1_7_0.ovrp_SetAppChromaticCorrection(ToBool(value));
			}
		}
	}

	public static bool monoscopic
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetAppMonoscopic() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetAppMonoscopic(ToBool(value));
		}
	}

	public static bool rotation
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetTrackingOrientationEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetTrackingOrientationEnabled(ToBool(value));
		}
	}

	public static bool position
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetTrackingPositionEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetTrackingPositionEnabled(ToBool(value));
		}
	}

	public static bool useIPDInPositionTracking
	{
		get
		{
			if (version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetTrackingIPDEnabled() == Bool.True;
			}
			return true;
		}
		set
		{
			if (version >= OVRP_1_6_0.version)
			{
				OVRP_1_6_0.ovrp_SetTrackingIPDEnabled(ToBool(value));
			}
		}
	}

	public static bool positionSupported => OVRP_1_1_0.ovrp_GetTrackingPositionSupported() == Bool.True;

	public static bool positionTracked => OVRP_1_1_0.ovrp_GetNodePositionTracked(Node.EyeCenter) == Bool.True;

	public static bool powerSaving => OVRP_1_1_0.ovrp_GetSystemPowerSavingMode() == Bool.True;

	public static bool hmdPresent => OVRP_1_1_0.ovrp_GetNodePresent(Node.EyeCenter) == Bool.True;

	public static bool userPresent => OVRP_1_1_0.ovrp_GetUserPresent() == Bool.True;

	public static bool headphonesPresent => OVRP_1_3_0.ovrp_GetSystemHeadphonesPresent() == Bool.True;

	public static int recommendedMSAALevel
	{
		get
		{
			if (version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetSystemRecommendedMSAALevel();
			}
			return 2;
		}
	}

	public static SystemRegion systemRegion
	{
		get
		{
			if (version >= OVRP_1_5_0.version)
			{
				return OVRP_1_5_0.ovrp_GetSystemRegion();
			}
			return SystemRegion.Unspecified;
		}
	}

	public static string audioOutId
	{
		get
		{
			try
			{
				if (_nativeAudioOutGuid == null)
				{
					_nativeAudioOutGuid = new GUID();
				}
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioOutId();
				if (intPtr != IntPtr.Zero)
				{
					Marshal.PtrToStructure(intPtr, _nativeAudioOutGuid);
					Guid guid = new Guid(_nativeAudioOutGuid.a, _nativeAudioOutGuid.b, _nativeAudioOutGuid.c, _nativeAudioOutGuid.d0, _nativeAudioOutGuid.d1, _nativeAudioOutGuid.d2, _nativeAudioOutGuid.d3, _nativeAudioOutGuid.d4, _nativeAudioOutGuid.d5, _nativeAudioOutGuid.d6, _nativeAudioOutGuid.d7);
					if (guid != _cachedAudioOutGuid)
					{
						_cachedAudioOutGuid = guid;
						_cachedAudioOutString = _cachedAudioOutGuid.ToString();
					}
					return _cachedAudioOutString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static string audioInId
	{
		get
		{
			try
			{
				if (_nativeAudioInGuid == null)
				{
					_nativeAudioInGuid = new GUID();
				}
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioInId();
				if (intPtr != IntPtr.Zero)
				{
					Marshal.PtrToStructure(intPtr, _nativeAudioInGuid);
					Guid guid = new Guid(_nativeAudioInGuid.a, _nativeAudioInGuid.b, _nativeAudioInGuid.c, _nativeAudioInGuid.d0, _nativeAudioInGuid.d1, _nativeAudioInGuid.d2, _nativeAudioInGuid.d3, _nativeAudioInGuid.d4, _nativeAudioInGuid.d5, _nativeAudioInGuid.d6, _nativeAudioInGuid.d7);
					if (guid != _cachedAudioInGuid)
					{
						_cachedAudioInGuid = guid;
						_cachedAudioInString = _cachedAudioInGuid.ToString();
					}
					return _cachedAudioInString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static bool hasVrFocus => OVRP_1_1_0.ovrp_GetAppHasVrFocus() == Bool.True;

	public static bool hasInputFocus
	{
		get
		{
			if (version >= OVRP_1_18_0.version)
			{
				Bool appHasInputFocus = Bool.False;
				if (OVRP_1_18_0.ovrp_GetAppHasInputFocus(out appHasInputFocus) == Result.Success)
				{
					return appHasInputFocus == Bool.True;
				}
				return false;
			}
			return true;
		}
	}

	public static bool shouldQuit => OVRP_1_1_0.ovrp_GetAppShouldQuit() == Bool.True;

	public static bool shouldRecenter => OVRP_1_1_0.ovrp_GetAppShouldRecenter() == Bool.True;

	public static string productName => OVRP_1_1_0.ovrp_GetSystemProductName();

	public static string latency => OVRP_1_1_0.ovrp_GetAppLatencyTimings();

	public static float eyeDepth
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeDepth();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeDepth(value);
		}
	}

	public static float eyeHeight
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeHeight();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeHeight(value);
		}
	}

	public static float batteryLevel => OVRP_1_1_0.ovrp_GetSystemBatteryLevel();

	public static float batteryTemperature => OVRP_1_1_0.ovrp_GetSystemBatteryTemperature();

	public static int cpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemCpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemCpuLevel(value);
		}
	}

	public static int gpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemGpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemGpuLevel(value);
		}
	}

	public static int vsyncCount
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemVSyncCount();
		}
		set
		{
			OVRP_1_2_0.ovrp_SetSystemVSyncCount(value);
		}
	}

	public static float systemVolume => OVRP_1_1_0.ovrp_GetSystemVolume();

	public static float ipd
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserIPD();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserIPD(value);
		}
	}

	public static bool occlusionMesh
	{
		get
		{
			return OVRP_1_3_0.ovrp_GetEyeOcclusionMeshEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_3_0.ovrp_SetEyeOcclusionMeshEnabled(ToBool(value));
		}
	}

	public static BatteryStatus batteryStatus => OVRP_1_1_0.ovrp_GetSystemBatteryStatus();

	public static bool tiledMultiResSupported
	{
		get
		{
			if (version >= OVRP_1_21_0.version)
			{
				if (OVRP_1_21_0.ovrp_GetTiledMultiResSupported(out var foveationSupported) == Result.Success)
				{
					return foveationSupported == Bool.True;
				}
				return false;
			}
			return false;
		}
	}

	public static TiledMultiResLevel tiledMultiResLevel
	{
		get
		{
			if (version >= OVRP_1_21_0.version && tiledMultiResSupported)
			{
				if (OVRP_1_21_0.ovrp_GetTiledMultiResLevel(out var level) != 0)
				{
				}
				return level;
			}
			return TiledMultiResLevel.Off;
		}
		set
		{
			if (version >= OVRP_1_21_0.version && tiledMultiResSupported && OVRP_1_21_0.ovrp_SetTiledMultiResLevel(value) == Result.Success)
			{
			}
		}
	}

	public static bool gpuUtilSupported
	{
		get
		{
			if (version >= OVRP_1_21_0.version)
			{
				if (OVRP_1_21_0.ovrp_GetGPUUtilSupported(out var @bool) == Result.Success)
				{
					return @bool == Bool.True;
				}
				return false;
			}
			return false;
		}
	}

	public static float gpuUtilLevel
	{
		get
		{
			if (version >= OVRP_1_21_0.version && gpuUtilSupported)
			{
				if (OVRP_1_21_0.ovrp_GetGPUUtilLevel(out var gpuUtil) == Result.Success)
				{
					return gpuUtil;
				}
				return 0f;
			}
			return 0f;
		}
	}

	public static float[] systemDisplayFrequenciesAvailable
	{
		get
		{
			if (_cachedSystemDisplayFrequenciesAvailable == null)
			{
				_cachedSystemDisplayFrequenciesAvailable = new float[0];
				if (version >= OVRP_1_21_0.version)
				{
					int numFrequencies = 0;
					if (OVRP_1_21_0.ovrp_GetSystemDisplayAvailableFrequencies(IntPtr.Zero, out numFrequencies) == Result.Success && numFrequencies > 0)
					{
						int num = numFrequencies;
						_nativeSystemDisplayFrequenciesAvailable = new OVRNativeBuffer(4 * num);
						if (OVRP_1_21_0.ovrp_GetSystemDisplayAvailableFrequencies(_nativeSystemDisplayFrequenciesAvailable.GetPointer(), out numFrequencies) == Result.Success)
						{
							int num2 = ((numFrequencies > num) ? num : numFrequencies);
							if (num2 > 0)
							{
								_cachedSystemDisplayFrequenciesAvailable = new float[num2];
								Marshal.Copy(_nativeSystemDisplayFrequenciesAvailable.GetPointer(), _cachedSystemDisplayFrequenciesAvailable, 0, num2);
							}
						}
					}
				}
			}
			return _cachedSystemDisplayFrequenciesAvailable;
		}
	}

	public static float systemDisplayFrequency
	{
		get
		{
			if (version >= OVRP_1_21_0.version)
			{
				if (OVRP_1_21_0.ovrp_GetSystemDisplayFrequency2(out var result) == Result.Success)
				{
					return result;
				}
				return 0f;
			}
			if (version >= OVRP_1_1_0.version)
			{
				return OVRP_1_1_0.ovrp_GetSystemDisplayFrequency();
			}
			return 0f;
		}
		set
		{
			if (version >= OVRP_1_21_0.version)
			{
				OVRP_1_21_0.ovrp_SetSystemDisplayFrequency(value);
			}
		}
	}

	public static Frustumf GetEyeFrustum(Eye eyeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)eyeId);
	}

	public static Sizei GetEyeTextureSize(Eye eyeId)
	{
		return OVRP_0_1_0.ovrp_GetEyeTextureSize(eyeId);
	}

	public static Posef GetTrackerPose(Tracker trackerId)
	{
		return GetNodePose((Node)(trackerId + 5), Step.Render);
	}

	public static Frustumf GetTrackerFrustum(Tracker trackerId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)(trackerId + 5));
	}

	public static bool ShowUI(PlatformUI ui)
	{
		return OVRP_1_1_0.ovrp_ShowSystemUI(ui) == Bool.True;
	}

	public static bool EnqueueSubmitLayer(bool onTop, bool headLocked, IntPtr leftTexture, IntPtr rightTexture, int layerId, int frameIndex, Posef pose, Vector3f scale, int layerIndex = 0, OverlayShape shape = OverlayShape.Quad)
	{
		if (version >= OVRP_1_6_0.version)
		{
			uint num = 0u;
			if (onTop)
			{
				num |= 1u;
			}
			if (headLocked)
			{
				num |= 2u;
			}
			if (shape == OverlayShape.Cylinder || shape == OverlayShape.Cubemap)
			{
				if (!(version >= OVRP_1_7_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (shape == OverlayShape.OffcenterCubemap)
			{
				if (!(version >= OVRP_1_11_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (shape == OverlayShape.Equirect)
			{
				if (!(version >= OVRP_1_21_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (version >= OVRP_1_15_0.version && layerId != -1)
			{
				return OVRP_1_15_0.ovrp_EnqueueSubmitLayer(num, leftTexture, rightTexture, layerId, frameIndex, ref pose, ref scale, layerIndex) == Result.Success;
			}
			return OVRP_1_6_0.ovrp_SetOverlayQuad3(num, leftTexture, rightTexture, IntPtr.Zero, pose, scale, layerIndex) == Bool.True;
		}
		if (layerIndex != 0)
		{
			return false;
		}
		return OVRP_0_1_1.ovrp_SetOverlayQuad2(ToBool(onTop), ToBool(headLocked), leftTexture, IntPtr.Zero, pose, scale) == Bool.True;
	}

	public static LayerDesc CalculateLayerDesc(OverlayShape shape, LayerLayout layout, Sizei textureSize, int mipLevels, int sampleCount, EyeTextureFormat format, int layerFlags)
	{
		LayerDesc layerDesc = default(LayerDesc);
		if (version >= OVRP_1_15_0.version)
		{
			OVRP_1_15_0.ovrp_CalculateLayerDesc(shape, layout, ref textureSize, mipLevels, sampleCount, format, layerFlags, ref layerDesc);
		}
		return layerDesc;
	}

	public static bool EnqueueSetupLayer(LayerDesc desc, IntPtr layerID)
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_EnqueueSetupLayer(ref desc, layerID) == Result.Success;
		}
		return false;
	}

	public static bool EnqueueDestroyLayer(IntPtr layerID)
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_EnqueueDestroyLayer(layerID) == Result.Success;
		}
		return false;
	}

	public static IntPtr GetLayerTexture(int layerId, int stage, Eye eyeId)
	{
		IntPtr textureHandle = IntPtr.Zero;
		if (version >= OVRP_1_15_0.version)
		{
			OVRP_1_15_0.ovrp_GetLayerTexturePtr(layerId, stage, eyeId, ref textureHandle);
		}
		return textureHandle;
	}

	public static int GetLayerTextureStageCount(int layerId)
	{
		int layerTextureStageCount = 1;
		if (version >= OVRP_1_15_0.version)
		{
			OVRP_1_15_0.ovrp_GetLayerTextureStageCount(layerId, ref layerTextureStageCount);
		}
		return layerTextureStageCount;
	}

	public static bool UpdateNodePhysicsPoses(int frameIndex, double predictionSeconds)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_Update2(0, frameIndex, predictionSeconds) == Bool.True;
		}
		return false;
	}

	public static Posef GetNodePose(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).Pose;
		}
		if (version >= OVRP_1_8_0.version && stepId == Step.Physics)
		{
			return OVRP_1_8_0.ovrp_GetNodePose2(0, nodeId);
		}
		return OVRP_0_1_2.ovrp_GetNodePose(nodeId);
	}

	public static Vector3f GetNodeVelocity(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).Velocity;
		}
		if (version >= OVRP_1_8_0.version && stepId == Step.Physics)
		{
			return OVRP_1_8_0.ovrp_GetNodeVelocity2(0, nodeId).Position;
		}
		return OVRP_0_1_3.ovrp_GetNodeVelocity(nodeId).Position;
	}

	public static Vector3f GetNodeAngularVelocity(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).AngularVelocity;
		}
		return default(Vector3f);
	}

	public static Vector3f GetNodeAcceleration(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).Acceleration;
		}
		if (version >= OVRP_1_8_0.version && stepId == Step.Physics)
		{
			return OVRP_1_8_0.ovrp_GetNodeAcceleration2(0, nodeId).Position;
		}
		return OVRP_0_1_3.ovrp_GetNodeAcceleration(nodeId).Position;
	}

	public static Vector3f GetNodeAngularAcceleration(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).AngularAcceleration;
		}
		return default(Vector3f);
	}

	public static bool GetNodePresent(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePresent(nodeId) == Bool.True;
	}

	public static bool GetNodeOrientationTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeOrientationTracked(nodeId) == Bool.True;
	}

	public static bool GetNodePositionTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePositionTracked(nodeId) == Bool.True;
	}

	public static ControllerState GetControllerState(uint controllerMask)
	{
		return OVRP_1_1_0.ovrp_GetControllerState(controllerMask);
	}

	public static ControllerState2 GetControllerState2(uint controllerMask)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetControllerState2(controllerMask);
		}
		return new ControllerState2(OVRP_1_1_0.ovrp_GetControllerState(controllerMask));
	}

	public static ControllerState4 GetControllerState4(uint controllerMask)
	{
		if (version >= OVRP_1_16_0.version)
		{
			ControllerState4 controllerState = default(ControllerState4);
			OVRP_1_16_0.ovrp_GetControllerState4(controllerMask, ref controllerState);
			return controllerState;
		}
		return new ControllerState4(GetControllerState2(controllerMask));
	}

	public static bool SetControllerVibration(uint controllerMask, float frequency, float amplitude)
	{
		return OVRP_0_1_2.ovrp_SetControllerVibration(controllerMask, frequency, amplitude) == Bool.True;
	}

	public static HapticsDesc GetControllerHapticsDesc(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsDesc(controllerMask);
		}
		return default(HapticsDesc);
	}

	public static HapticsState GetControllerHapticsState(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsState(controllerMask);
		}
		return default(HapticsState);
	}

	public static bool SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_SetControllerHaptics(controllerMask, hapticsBuffer) == Bool.True;
		}
		return false;
	}

	public static float GetEyeRecommendedResolutionScale()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetEyeRecommendedResolutionScale();
		}
		return 1f;
	}

	public static float GetAppCpuStartToGpuEndTime()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetAppCpuStartToGpuEndTime();
		}
		return 0f;
	}

	public static bool GetBoundaryConfigured()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryConfigured() == Bool.True;
		}
		return false;
	}

	public static BoundaryTestResult TestBoundaryNode(Node nodeId, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryNode(nodeId, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static BoundaryTestResult TestBoundaryPoint(Vector3f point, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryPoint(point, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static bool SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryLookAndFeel(lookAndFeel) == Bool.True;
		}
		return false;
	}

	public static bool ResetBoundaryLookAndFeel()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_ResetBoundaryLookAndFeel() == Bool.True;
		}
		return false;
	}

	public static BoundaryGeometry GetBoundaryGeometry(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryGeometry(boundaryType);
		}
		return default(BoundaryGeometry);
	}

	public static bool GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount)
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetBoundaryGeometry2(boundaryType, points, ref pointsCount) == Bool.True;
		}
		pointsCount = 0;
		return false;
	}

	public static AppPerfStats GetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetAppPerfStats();
		}
		return default(AppPerfStats);
	}

	public static bool ResetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_ResetAppPerfStats() == Bool.True;
		}
		return false;
	}

	public static float GetAppFramerate()
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetAppFramerate();
		}
		return 0f;
	}

	public static bool SetHandNodePoseStateLatency(double latencyInSeconds)
	{
		if (version >= OVRP_1_18_0.version)
		{
			if (OVRP_1_18_0.ovrp_SetHandNodePoseStateLatency(latencyInSeconds) == Result.Success)
			{
				return true;
			}
			return false;
		}
		return false;
	}

	public static double GetHandNodePoseStateLatency()
	{
		if (version >= OVRP_1_18_0.version)
		{
			double latencyInSeconds = 0.0;
			if (OVRP_1_18_0.ovrp_GetHandNodePoseStateLatency(out latencyInSeconds) == Result.Success)
			{
				return latencyInSeconds;
			}
			return 0.0;
		}
		return 0.0;
	}

	public static EyeTextureFormat GetDesiredEyeTextureFormat()
	{
		if (version >= OVRP_1_11_0.version)
		{
			uint num = (uint)OVRP_1_11_0.ovrp_GetDesiredEyeTextureFormat();
			if (num == 1)
			{
				num = 0u;
			}
			return (EyeTextureFormat)num;
		}
		return EyeTextureFormat.Default;
	}

	public static bool SetDesiredEyeTextureFormat(EyeTextureFormat value)
	{
		if (version >= OVRP_1_11_0.version)
		{
			return OVRP_1_11_0.ovrp_SetDesiredEyeTextureFormat(value) == Bool.True;
		}
		return false;
	}

	public static bool InitializeMixedReality()
	{
		if (version >= OVRP_1_15_0.version)
		{
			Result result = OVRP_1_15_0.ovrp_InitializeMixedReality();
			if (result != 0)
			{
			}
			return result == Result.Success;
		}
		return false;
	}

	public static bool ShutdownMixedReality()
	{
		if (version >= OVRP_1_15_0.version)
		{
			Result result = OVRP_1_15_0.ovrp_ShutdownMixedReality();
			if (result != 0)
			{
			}
			return result == Result.Success;
		}
		return false;
	}

	public static bool IsMixedRealityInitialized()
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_GetMixedRealityInitialized() == Bool.True;
		}
		return false;
	}

	public static int GetExternalCameraCount()
	{
		if (version >= OVRP_1_15_0.version)
		{
			int cameraCount = 0;
			if (OVRP_1_15_0.ovrp_GetExternalCameraCount(out cameraCount) != 0)
			{
				return 0;
			}
			return cameraCount;
		}
		return 0;
	}

	public static bool UpdateExternalCamera()
	{
		if (version >= OVRP_1_15_0.version)
		{
			Result result = OVRP_1_15_0.ovrp_UpdateExternalCamera();
			if (result != 0)
			{
			}
			return result == Result.Success;
		}
		return false;
	}

	public static bool GetMixedRealityCameraInfo(int cameraId, out CameraExtrinsics cameraExtrinsics, out CameraIntrinsics cameraIntrinsics)
	{
		cameraExtrinsics = default(CameraExtrinsics);
		cameraIntrinsics = default(CameraIntrinsics);
		if (version >= OVRP_1_15_0.version)
		{
			bool result = true;
			if (OVRP_1_15_0.ovrp_GetExternalCameraExtrinsics(cameraId, out cameraExtrinsics) != 0)
			{
				result = false;
			}
			if (OVRP_1_15_0.ovrp_GetExternalCameraIntrinsics(cameraId, out cameraIntrinsics) != 0)
			{
				result = false;
			}
			return result;
		}
		return false;
	}

	public static Vector3f GetBoundaryDimensions(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryDimensions(boundaryType);
		}
		return default(Vector3f);
	}

	public static bool GetBoundaryVisible()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryVisible() == Bool.True;
		}
		return false;
	}

	public static bool SetBoundaryVisible(bool value)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryVisible(ToBool(value)) == Bool.True;
		}
		return false;
	}

	public static SystemHeadset GetSystemHeadsetType()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetSystemHeadsetType();
		}
		return SystemHeadset.None;
	}

	public static Controller GetActiveController()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetActiveController();
		}
		return Controller.None;
	}

	public static Controller GetConnectedControllers()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetConnectedControllers();
		}
		return Controller.None;
	}

	private static Bool ToBool(bool b)
	{
		return b ? Bool.True : Bool.False;
	}

	public static TrackingOrigin GetTrackingOriginType()
	{
		return OVRP_1_0_0.ovrp_GetTrackingOriginType();
	}

	public static bool SetTrackingOriginType(TrackingOrigin originType)
	{
		return OVRP_1_0_0.ovrp_SetTrackingOriginType(originType) == Bool.True;
	}

	public static Posef GetTrackingCalibratedOrigin()
	{
		return OVRP_1_0_0.ovrp_GetTrackingCalibratedOrigin();
	}

	public static bool SetTrackingCalibratedOrigin()
	{
		return OVRP_1_2_0.ovrpi_SetTrackingCalibratedOrigin() == Bool.True;
	}

	public static bool RecenterTrackingOrigin(RecenterFlags flags)
	{
		return OVRP_1_0_0.ovrp_RecenterTrackingOrigin((uint)flags) == Bool.True;
	}
}
public class OVRProfile : UnityEngine.Object
{
	[Obsolete]
	public enum State
	{
		NOT_TRIGGERED,
		LOADING,
		READY,
		ERROR
	}

	[Obsolete]
	public string id => "000abc123def";

	[Obsolete]
	public string userName => "Oculus User";

	[Obsolete]
	public string locale => "en_US";

	public float ipd => Vector3.Distance(OVRPlugin.GetNodePose(OVRPlugin.Node.EyeLeft, OVRPlugin.Step.Render).ToOVRPose().position, OVRPlugin.GetNodePose(OVRPlugin.Node.EyeRight, OVRPlugin.Step.Render).ToOVRPose().position);

	public float eyeHeight => OVRPlugin.eyeHeight;

	public float eyeDepth => OVRPlugin.eyeDepth;

	public float neckHeight => eyeHeight - 0.075f;

	[Obsolete]
	public State state => State.READY;
}
public static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		Left,
		Right,
		Up,
		Down
	}

	public class TouchArgs : EventArgs
	{
		public TouchEvent TouchType;
	}

	private enum TouchState
	{
		Init,
		Down,
		Stationary,
		Move,
		Up
	}

	private static TouchState touchState = TouchState.Init;

	private static float minMovMagnitude = 100f;

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static event EventHandler TouchHandler;

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
			touchState = TouchState.Down;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
			touchState = TouchState.Init;
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInput(TouchState state, ref Vector2 move)
	{
		if (move.magnitude < minMovMagnitude || touchState == TouchState.Stationary || touchState != TouchState.Move)
		{
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (!(move.x > 0f))
			{
			}
		}
		else if (!(move.y > 0f))
		{
		}
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if (move.magnitude < minMovMagnitudeMouse)
		{
			if (OVRTouchpad.TouchHandler != null)
			{
				OVRTouchpad.TouchHandler(null, new TouchArgs
				{
					TouchType = TouchEvent.SingleTap
				});
			}
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				if (OVRTouchpad.TouchHandler != null)
				{
					OVRTouchpad.TouchHandler(null, new TouchArgs
					{
						TouchType = TouchEvent.Left
					});
				}
			}
			else if (OVRTouchpad.TouchHandler != null)
			{
				OVRTouchpad.TouchHandler(null, new TouchArgs
				{
					TouchType = TouchEvent.Right
				});
			}
		}
		else if (move.y > 0f)
		{
			if (OVRTouchpad.TouchHandler != null)
			{
				OVRTouchpad.TouchHandler(null, new TouchArgs
				{
					TouchType = TouchEvent.Down
				});
			}
		}
		else if (OVRTouchpad.TouchHandler != null)
		{
			OVRTouchpad.TouchHandler(null, new TouchArgs
			{
				TouchType = TouchEvent.Up
			});
		}
	}
}
public sealed class OVRTouchpadHelper : UnityEngine.MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRTouchpad.TouchHandler += LocalTouchEventCallback;
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(object sender, EventArgs args)
	{
		OVRTouchpad.TouchArgs touchArgs = (OVRTouchpad.TouchArgs)args;
		switch (touchArgs.TouchType)
		{
		case OVRTouchpad.TouchEvent.SingleTap:
			break;
		case OVRTouchpad.TouchEvent.Left:
			break;
		case OVRTouchpad.TouchEvent.Right:
			break;
		case OVRTouchpad.TouchEvent.Up:
			break;
		case OVRTouchpad.TouchEvent.Down:
			break;
		}
	}
}
public class OVRTracker
{
	public struct Frustum
	{
		public float nearZ;

		public float farZ;

		public Vector2 fov;
	}

	public bool isPresent
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.positionSupported;
		}
	}

	public bool isPositionTracked => OVRPlugin.positionTracked;

	public bool isEnabled
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.position;
		}
		set
		{
			if (OVRManager.isHmdPresent)
			{
				OVRPlugin.position = value;
			}
		}
	}

	public int count
	{
		get
		{
			int num = 0;
			for (int i = 0; i < 4; i++)
			{
				if (GetPresent(i))
				{
					num++;
				}
			}
			return num;
		}
	}

	public Frustum GetFrustum(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return default(Frustum);
		}
		return OVRPlugin.GetTrackerFrustum((OVRPlugin.Tracker)tracker).ToFrustum();
	}

	public OVRPose GetPose(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return OVRPose.identity;
		}
		OVRPose oVRPose;
		switch (tracker)
		{
		case 0:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerZero, OVRPlugin.Step.Render).ToOVRPose();
			break;
		case 1:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerOne, OVRPlugin.Step.Render).ToOVRPose();
			break;
		case 2:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerTwo, OVRPlugin.Step.Render).ToOVRPose();
			break;
		case 3:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerThree, OVRPlugin.Step.Render).ToOVRPose();
			break;
		default:
			return OVRPose.identity;
		}
		OVRPose result = default(OVRPose);
		result.position = oVRPose.position;
		result.orientation = oVRPose.orientation * Quaternion.Euler(0f, 180f, 0f);
		return result;
	}

	public bool GetPoseValid(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}

	public bool GetPresent(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}
}
public class OVRChromaticAberration : UnityEngine.MonoBehaviour
{
	public OVRInput.RawButton toggleButton = OVRInput.RawButton.X;

	private bool chromatic;

	private void Start()
	{
		OVRManager.instance.chromatic = chromatic;
	}

	private void Update()
	{
		if (OVRInput.GetDown(toggleButton))
		{
			chromatic = !chromatic;
			OVRManager.instance.chromatic = chromatic;
		}
	}
}
public class OVRCubemapCapture : UnityEngine.MonoBehaviour
{
	public bool autoTriggerAfterLaunch = true;

	public float autoTriggerDelay = 1f;

	private float autoTriggerElapse;

	public KeyCode triggeredByKey = KeyCode.F8;

	public string pathName;

	public int cubemapSize = 2048;

	private void Update()
	{
		if (autoTriggerAfterLaunch)
		{
			autoTriggerElapse += Time.deltaTime;
			if (autoTriggerElapse >= autoTriggerDelay)
			{
				autoTriggerAfterLaunch = false;
				TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
			}
		}
		if (Input.GetKeyDown(triggeredByKey))
		{
			TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
		}
	}

	public static void TriggerCubemapCapture(Vector3 capturePos, int cubemapSize = 2048, string pathName = null)
	{
		GameObject gameObject = new GameObject("CubemapCamera", typeof(Camera));
		gameObject.hideFlags = HideFlags.HideAndDontSave;
		gameObject.transform.position = capturePos;
		gameObject.transform.rotation = Quaternion.identity;
		Camera component = gameObject.GetComponent<Camera>();
		component.farClipPlane = 10000f;
		component.enabled = false;
		Cubemap cubemap = new Cubemap(cubemapSize, TextureFormat.RGB24, mipmap: false);
		RenderIntoCubemap(component, cubemap);
		SaveCubemapCapture(cubemap, pathName);
		UnityEngine.Object.DestroyImmediate(cubemap);
		UnityEngine.Object.DestroyImmediate(gameObject);
	}

	public static void RenderIntoCubemap(Camera ownerCamera, Cubemap outCubemap)
	{
		int width = outCubemap.width;
		int height = outCubemap.height;
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		Vector3[] array2 = new Vector3[6]
		{
			new Vector3(0f, 90f, 0f),
			new Vector3(0f, -90f, 0f),
			new Vector3(-90f, 0f, 0f),
			new Vector3(90f, 0f, 0f),
			new Vector3(0f, 0f, 0f),
			new Vector3(0f, 180f, 0f)
		};
		RenderTexture active = RenderTexture.active;
		float fieldOfView = ownerCamera.fieldOfView;
		float aspect = ownerCamera.aspect;
		Quaternion rotation = ownerCamera.transform.rotation;
		RenderTexture renderTexture = new RenderTexture(width, height, 24);
		renderTexture.antiAliasing = 8;
		renderTexture.dimension = TextureDimension.Tex2D;
		renderTexture.hideFlags = HideFlags.HideAndDontSave;
		Texture2D texture2D = new Texture2D(width, height, TextureFormat.RGB24, mipmap: false);
		texture2D.hideFlags = HideFlags.HideAndDontSave;
		ownerCamera.targetTexture = renderTexture;
		ownerCamera.fieldOfView = 90f;
		ownerCamera.aspect = 1f;
		UnityEngine.Color[] array3 = new UnityEngine.Color[texture2D.height * texture2D.width];
		for (int i = 0; i < array.Length; i++)
		{
			ownerCamera.transform.eulerAngles = array2[i];
			ownerCamera.Render();
			RenderTexture.active = renderTexture;
			texture2D.ReadPixels(new Rect(0f, 0f, width, height), 0, 0);
			UnityEngine.Color[] pixels = texture2D.GetPixels();
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					ref UnityEngine.Color reference = ref array3[j * width + k];
					reference = pixels[(height - 1 - j) * width + k];
				}
			}
			outCubemap.SetPixels(array3, array[i]);
		}
		outCubemap.SmoothEdges();
		RenderTexture.active = active;
		ownerCamera.fieldOfView = fieldOfView;
		ownerCamera.aspect = aspect;
		ownerCamera.transform.rotation = rotation;
		ownerCamera.targetTexture = active;
		UnityEngine.Object.DestroyImmediate(texture2D);
		UnityEngine.Object.DestroyImmediate(renderTexture);
	}

	public static bool SaveCubemapCapture(Cubemap cubemap, string pathName = null)
	{
		int width = cubemap.width;
		int height = cubemap.height;
		int num = 0;
		int y = 0;
		bool flag = true;
		string text;
		string text2;
		if (string.IsNullOrEmpty(pathName))
		{
			text = UnityEngine.Application.persistentDataPath + "/OVR_ScreenShot360/";
			text2 = null;
		}
		else
		{
			text = Path.GetDirectoryName(pathName);
			text2 = Path.GetFileName(pathName);
			if (text[text.Length - 1] != '/' || text[text.Length - 1] != '\\')
			{
				text += "/";
			}
		}
		if (string.IsNullOrEmpty(text2))
		{
			text2 = "OVR_" + DateTime.Now.ToString("hh_mm_ss") + ".png";
		}
		string extension = Path.GetExtension(text2);
		if (extension == ".png")
		{
			flag = true;
		}
		else
		{
			if (!(extension == ".jpg"))
			{
				UnityEngine.Debug.LogError("Unsupported file format" + extension);
				return false;
			}
			flag = false;
		}
		try
		{
			Directory.CreateDirectory(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Failed to create path " + text + " since " + ex.ToString());
			return false;
		}
		Texture2D texture2D = new Texture2D(width * 6, height, TextureFormat.RGB24, mipmap: false);
		if (texture2D == null)
		{
			UnityEngine.Debug.LogError("[OVRScreenshotWizard] Failed creating the texture!");
			return false;
		}
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		for (int i = 0; i < array.Length; i++)
		{
			UnityEngine.Color[] array2 = null;
			UnityEngine.Color[] pixels = cubemap.GetPixels(array[i]);
			array2 = new UnityEngine.Color[pixels.Length];
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					ref UnityEngine.Color reference = ref array2[j * width + k];
					reference = pixels[(height - 1 - j) * width + k];
				}
			}
			texture2D.SetPixels(num, y, width, height, array2);
			num += width;
		}
		try
		{
			byte[] bytes = ((!flag) ? texture2D.EncodeToJPG() : texture2D.EncodeToPNG());
			File.WriteAllBytes(text + text2, bytes);
			UnityEngine.Debug.Log("Cubemap file created " + text + text2);
		}
		catch (Exception ex2)
		{
			UnityEngine.Debug.LogError("Failed to save cubemap file since " + ex2.ToString());
			return false;
		}
		UnityEngine.Object.DestroyImmediate(texture2D);
		return true;
	}
}
public class OVRDebugInfo : UnityEngine.MonoBehaviour
{
	private GameObject debugUIManager;

	private GameObject debugUIObject;

	private GameObject riftPresent;

	private GameObject fps;

	private GameObject ipd;

	private GameObject fov;

	private GameObject height;

	private GameObject depth;

	private GameObject resolutionEyeTexture;

	private GameObject latencies;

	private GameObject texts;

	private string strRiftPresent;

	private string strFPS;

	private string strIPD;

	private string strFOV;

	private string strHeight;

	private string strDepth;

	private string strResolutionEyeTexture;

	private string strLatencies;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private bool initUIComponent;

	private bool isInited;

	private float offsetY = 55f;

	private float riftPresentTimeout;

	private bool showVRVars;

	private void Awake()
	{
		debugUIManager = new GameObject();
		debugUIManager.name = "DebugUIManager";
		debugUIManager.transform.parent = GameObject.Find("LeftEyeAnchor").transform;
		RectTransform rectTransform = debugUIManager.AddComponent<RectTransform>();
		rectTransform.sizeDelta = new Vector2(100f, 100f);
		rectTransform.localScale = new Vector3(0.001f, 0.001f, 0.001f);
		rectTransform.localPosition = new Vector3(0.01f, 0.17f, 0.53f);
		rectTransform.localEulerAngles = Vector3.zero;
		Canvas canvas = debugUIManager.AddComponent<Canvas>();
		canvas.renderMode = RenderMode.WorldSpace;
		canvas.pixelPerfect = false;
	}

	private void Update()
	{
		if (initUIComponent && !isInited)
		{
			InitUIComponents();
		}
		if (Input.GetKeyDown(KeyCode.Space) && riftPresentTimeout < 0f)
		{
			initUIComponent = true;
			showVRVars ^= true;
		}
		UpdateDeviceDetection();
		if (showVRVars)
		{
			debugUIManager.SetActive(value: true);
			UpdateVariable();
			UpdateStrings();
		}
		else
		{
			debugUIManager.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		isInited = false;
	}

	private void InitUIComponents()
	{
		float num = 0f;
		int fontSize = 20;
		debugUIObject = new GameObject();
		debugUIObject.name = "DebugInfo";
		debugUIObject.transform.parent = GameObject.Find("DebugUIManager").transform;
		debugUIObject.transform.localPosition = new Vector3(0f, 100f, 0f);
		debugUIObject.transform.localEulerAngles = Vector3.zero;
		debugUIObject.transform.localScale = new Vector3(1f, 1f, 1f);
		if (!string.IsNullOrEmpty(strFPS))
		{
			fps = VariableObjectManager(fps, "FPS", num -= offsetY, strFPS, fontSize);
		}
		if (!string.IsNullOrEmpty(strIPD))
		{
			ipd = VariableObjectManager(ipd, "IPD", num -= offsetY, strIPD, fontSize);
		}
		if (!string.IsNullOrEmpty(strFOV))
		{
			fov = VariableObjectManager(fov, "FOV", num -= offsetY, strFOV, fontSize);
		}
		if (!string.IsNullOrEmpty(strHeight))
		{
			height = VariableObjectManager(height, "Height", num -= offsetY, strHeight, fontSize);
		}
		if (!string.IsNullOrEmpty(strDepth))
		{
			depth = VariableObjectManager(depth, "Depth", num -= offsetY, strDepth, fontSize);
		}
		if (!string.IsNullOrEmpty(strResolutionEyeTexture))
		{
			resolutionEyeTexture = VariableObjectManager(resolutionEyeTexture, "Resolution", num -= offsetY, strResolutionEyeTexture, fontSize);
		}
		if (!string.IsNullOrEmpty(strLatencies))
		{
			latencies = VariableObjectManager(latencies, "Latency", num -= offsetY, strLatencies, 17);
			num = 0f;
		}
		initUIComponent = false;
		isInited = true;
	}

	private void UpdateVariable()
	{
		UpdateIPD();
		UpdateEyeHeightOffset();
		UpdateEyeDepthOffset();
		UpdateFOV();
		UpdateResolutionEyeTexture();
		UpdateLatencyValues();
		UpdateFPS();
	}

	private void UpdateStrings()
	{
		if (!(debugUIObject == null))
		{
			if (!string.IsNullOrEmpty(strFPS))
			{
				fps.GetComponentInChildren<Text>().text = strFPS;
			}
			if (!string.IsNullOrEmpty(strIPD))
			{
				ipd.GetComponentInChildren<Text>().text = strIPD;
			}
			if (!string.IsNullOrEmpty(strFOV))
			{
				fov.GetComponentInChildren<Text>().text = strFOV;
			}
			if (!string.IsNullOrEmpty(strResolutionEyeTexture))
			{
				resolutionEyeTexture.GetComponentInChildren<Text>().text = strResolutionEyeTexture;
			}
			if (!string.IsNullOrEmpty(strLatencies))
			{
				latencies.GetComponentInChildren<Text>().text = strLatencies;
				latencies.GetComponentInChildren<Text>().fontSize = 14;
			}
			if (!string.IsNullOrEmpty(strHeight))
			{
				height.GetComponentInChildren<Text>().text = strHeight;
			}
			if (!string.IsNullOrEmpty(strDepth))
			{
				depth.GetComponentInChildren<Text>().text = strDepth;
			}
		}
	}

	private void RiftPresentGUI(GameObject guiMainOBj)
	{
		riftPresent = ComponentComposition(riftPresent);
		riftPresent.transform.SetParent(guiMainOBj.transform);
		riftPresent.name = "RiftPresent";
		RectTransform component = riftPresent.GetComponent<RectTransform>();
		component.localPosition = new Vector3(0f, 0f, 0f);
		component.localScale = new Vector3(1f, 1f, 1f);
		component.localEulerAngles = Vector3.zero;
		Text componentInChildren = riftPresent.GetComponentInChildren<Text>();
		componentInChildren.text = strRiftPresent;
		componentInChildren.fontSize = 20;
	}

	private void UpdateDeviceDetection()
	{
		if (riftPresentTimeout >= 0f)
		{
			riftPresentTimeout -= Time.deltaTime;
		}
	}

	private GameObject VariableObjectManager(GameObject gameObject, string name, float posY, string str, int fontSize)
	{
		gameObject = ComponentComposition(gameObject);
		gameObject.name = name;
		gameObject.transform.SetParent(debugUIObject.transform);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.localPosition = new Vector3(0f, posY -= offsetY, 0f);
		Text componentInChildren = gameObject.GetComponentInChildren<Text>();
		componentInChildren.text = str;
		componentInChildren.fontSize = fontSize;
		gameObject.transform.localEulerAngles = Vector3.zero;
		component.localScale = new Vector3(1f, 1f, 1f);
		return gameObject;
	}

	private GameObject ComponentComposition(GameObject GO)
	{
		GO = new GameObject();
		GO.AddComponent<RectTransform>();
		GO.AddComponent<CanvasRenderer>();
		GO.AddComponent<UnityEngine.UI.Image>();
		GO.GetComponent<RectTransform>().sizeDelta = new Vector2(350f, 50f);
		GO.GetComponent<UnityEngine.UI.Image>().color = new UnityEngine.Color(0.02745098f, 0.1764706f, 0.2784314f, 40f / 51f);
		texts = new GameObject();
		texts.AddComponent<RectTransform>();
		texts.AddComponent<CanvasRenderer>();
		texts.AddComponent<Text>();
		texts.GetComponent<RectTransform>().sizeDelta = new Vector2(350f, 50f);
		texts.GetComponent<Text>().font = Resources.GetBuiltinResource(typeof(UnityEngine.Font), "Arial.ttf") as UnityEngine.Font;
		texts.GetComponent<Text>().alignment = TextAnchor.MiddleCenter;
		texts.transform.SetParent(GO.transform);
		texts.name = "TextBox";
		return GO;
	}

	private void UpdateIPD()
	{
		strIPD = $"IPD (mm): {OVRManager.profile.ipd * 1000f:F4}";
	}

	private void UpdateEyeHeightOffset()
	{
		float eyeHeight = OVRManager.profile.eyeHeight;
		strHeight = $"Eye Height (m): {eyeHeight:F3}";
	}

	private void UpdateEyeDepthOffset()
	{
		float eyeDepth = OVRManager.profile.eyeDepth;
		strDepth = $"Eye Depth (m): {eyeDepth:F3}";
	}

	private void UpdateFOV()
	{
		strFOV = $"FOV (deg): {OVRManager.display.GetEyeRenderDesc(VRNode.LeftEye).fov.y:F3}";
	}

	private void UpdateResolutionEyeTexture()
	{
		OVRDisplay.EyeRenderDesc eyeRenderDesc = OVRManager.display.GetEyeRenderDesc(VRNode.LeftEye);
		OVRDisplay.EyeRenderDesc eyeRenderDesc2 = OVRManager.display.GetEyeRenderDesc(VRNode.RightEye);
		float renderViewportScale = VRSettings.renderViewportScale;
		float num = (int)(renderViewportScale * (eyeRenderDesc.resolution.x + eyeRenderDesc2.resolution.x));
		float num2 = (int)(renderViewportScale * Mathf.Max(eyeRenderDesc.resolution.y, eyeRenderDesc2.resolution.y));
		strResolutionEyeTexture = $"Resolution : {num} x {num2}";
	}

	private void UpdateLatencyValues()
	{
	}

	private void UpdateFPS()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFPS = $"FPS: {num:F2}";
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class OVRGazePointer : UnityEngine.MonoBehaviour
{
	private Transform trailFollower;

	[Tooltip("Should the pointer be hidden when not over interactive objects.")]
	public bool hideByDefault = true;

	[Tooltip("Time after leaving interactive object before pointer fades.")]
	public float showTimeoutPeriod = 1f;

	[Tooltip("Time after mouse pointer becoming inactive before pointer unfades.")]
	public float hideTimeoutPeriod = 0.1f;

	[Tooltip("Keep a faint version of the pointer visible while using a mouse")]
	public bool dimOnHideRequest = true;

	[Tooltip("Angular scale of pointer")]
	public float depthScaleMultiplier = 0.03f;

	public Transform rayTransform;

	private float depth;

	private float hideUntilTime;

	private int positionSetsThisFrame;

	private Vector3 lastPosition;

	private float lastShowRequestTime;

	private float lastHideRequestTime;

	[Tooltip("Radius of the cursor. Used for preventing geometry intersections.")]
	public float cursorRadius = 1f;

	private OVRProgressIndicator progressIndicator;

	private static OVRGazePointer _instance;

	public bool hidden { get; private set; }

	public float currentScale { get; private set; }

	public Vector3 positionDelta { get; private set; }

	public static OVRGazePointer instance
	{
		get
		{
			if (_instance == null)
			{
				UnityEngine.Debug.Log(string.Format("Instanciating GazePointer", 0));
				_instance = UnityEngine.Object.Instantiate((OVRGazePointer)Resources.Load("Prefabs/GazePointerRing", typeof(OVRGazePointer)));
			}
			return _instance;
		}
	}

	public float visibilityStrength
	{
		get
		{
			float a = ((!hideByDefault) ? 1f : Mathf.Clamp01(1f - (Time.time - lastShowRequestTime) / showTimeoutPeriod));
			float b = ((!(lastHideRequestTime + hideTimeoutPeriod > Time.time)) ? 1f : ((!dimOnHideRequest) ? 0f : 0.1f));
			return Mathf.Min(a, b);
		}
	}

	public float SelectionProgress
	{
		get
		{
			return (!progressIndicator) ? 0f : progressIndicator.currentProgress;
		}
		set
		{
			if ((bool)progressIndicator)
			{
				progressIndicator.currentProgress = value;
			}
		}
	}

	public void Awake()
	{
		currentScale = 1f;
		if (_instance != null && _instance != this)
		{
			base.enabled = false;
			UnityEngine.Object.DestroyImmediate(this);
		}
		else
		{
			_instance = this;
			trailFollower = base.transform.Find("TrailFollower");
			progressIndicator = base.transform.GetComponent<OVRProgressIndicator>();
		}
	}

	private void Update()
	{
		if (rayTransform == null && Camera.main != null)
		{
			rayTransform = Camera.main.transform;
		}
		base.transform.position = rayTransform.position + rayTransform.forward * depth;
		if (visibilityStrength == 0f && !hidden)
		{
			Hide();
		}
		else if (visibilityStrength > 0f && hidden)
		{
			Show();
		}
	}

	public void SetPosition(Vector3 pos, Vector3 normal)
	{
		base.transform.position = pos;
		Quaternion rotation = base.transform.rotation;
		rotation.SetLookRotation(normal, rayTransform.up);
		base.transform.rotation = rotation;
		depth = (rayTransform.position - pos).magnitude;
		currentScale = depth * depthScaleMultiplier;
		base.transform.localScale = new Vector3(currentScale, currentScale, currentScale);
		positionSetsThisFrame++;
	}

	public void SetPosition(Vector3 pos)
	{
		SetPosition(pos, rayTransform.forward);
	}

	public float GetCurrentRadius()
	{
		return cursorRadius * currentScale;
	}

	private void LateUpdate()
	{
		if (positionSetsThisFrame == 0)
		{
			Quaternion rotation = base.transform.rotation;
			rotation.SetLookRotation(rayTransform.forward, rayTransform.up);
			base.transform.rotation = rotation;
		}
		Quaternion rotation2 = trailFollower.rotation;
		rotation2.SetLookRotation(base.transform.rotation * new Vector3(0f, 0f, 1f), (lastPosition - base.transform.position).normalized);
		trailFollower.rotation = rotation2;
		positionDelta = base.transform.position - lastPosition;
		lastPosition = base.transform.position;
		positionSetsThisFrame = 0;
	}

	public void RequestHide()
	{
		if (!dimOnHideRequest)
		{
			Hide();
		}
		lastHideRequestTime = Time.time;
	}

	public void RequestShow()
	{
		Show();
		lastShowRequestTime = Time.time;
	}

	private void Hide()
	{
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(value: false);
		}
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().enabled = false;
		}
		hidden = true;
	}

	private void Show()
	{
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(value: true);
		}
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().enabled = true;
		}
		hidden = false;
	}
}
public class OVRGearVrControllerTest : UnityEngine.MonoBehaviour
{
	public class BoolMonitor
	{
		public delegate bool BoolGenerator();

		private string m_name = string.Empty;

		private BoolGenerator m_generator;

		private bool m_prevValue;

		private bool m_currentValue;

		private bool m_currentValueRecentlyChanged;

		private float m_displayTimeout;

		private float m_displayTimer;

		public BoolMonitor(string name, BoolGenerator generator, float displayTimeout = 0.5f)
		{
			m_name = name;
			m_generator = generator;
			m_displayTimeout = displayTimeout;
		}

		public void Update()
		{
			m_prevValue = m_currentValue;
			m_currentValue = m_generator();
			if (m_currentValue != m_prevValue)
			{
				m_currentValueRecentlyChanged = true;
				m_displayTimer = m_displayTimeout;
			}
			if (m_displayTimer > 0f)
			{
				m_displayTimer -= Time.deltaTime;
				if (m_displayTimer <= 0f)
				{
					m_currentValueRecentlyChanged = false;
					m_displayTimer = 0f;
				}
			}
		}

		public void AppendToStringBuilder(ref StringBuilder sb)
		{
			sb.Append(m_name);
			if (m_currentValue && m_currentValueRecentlyChanged)
			{
				sb.Append(": *True*\n");
			}
			else if (m_currentValue)
			{
				sb.Append(":  True \n");
			}
			else if (!m_currentValue && m_currentValueRecentlyChanged)
			{
				sb.Append(": *False*\n");
			}
			else if (!m_currentValue)
			{
				sb.Append(":  False \n");
			}
		}
	}

	public Text uiText;

	private List<BoolMonitor> monitors;

	private StringBuilder data;

	private static string prevConnected = string.Empty;

	private static BoolMonitor controllers = new BoolMonitor("Controllers Changed", () => OVRInput.GetConnectedControllers().ToString() != prevConnected);

	private void Start()
	{
		if (uiText != null)
		{
			uiText.supportRichText = false;
		}
		data = new StringBuilder(2048);
		monitors = new List<BoolMonitor>
		{
			new BoolMonitor("WasRecentered", () => OVRInput.GetControllerWasRecentered()),
			new BoolMonitor("One", () => OVRInput.Get(OVRInput.Button.One)),
			new BoolMonitor("OneDown", () => OVRInput.GetDown(OVRInput.Button.One)),
			new BoolMonitor("OneUp", () => OVRInput.GetUp(OVRInput.Button.One)),
			new BoolMonitor("One (Touch)", () => OVRInput.Get(OVRInput.Touch.One)),
			new BoolMonitor("OneDown (Touch)", () => OVRInput.GetDown(OVRInput.Touch.One)),
			new BoolMonitor("OneUp (Touch)", () => OVRInput.GetUp(OVRInput.Touch.One)),
			new BoolMonitor("Two", () => OVRInput.Get(OVRInput.Button.Two)),
			new BoolMonitor("TwoDown", () => OVRInput.GetDown(OVRInput.Button.Two)),
			new BoolMonitor("TwoUp", () => OVRInput.GetUp(OVRInput.Button.Two)),
			new BoolMonitor("PrimaryIndexTrigger", () => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerDown", () => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerUp", () => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTrigger (Touch)", () => OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerDown (Touch)", () => OVRInput.GetDown(OVRInput.Touch.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerUp (Touch)", () => OVRInput.GetUp(OVRInput.Touch.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryHandTrigger", () => OVRInput.Get(OVRInput.Button.PrimaryHandTrigger)),
			new BoolMonitor("PrimaryHandTriggerDown", () => OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger)),
			new BoolMonitor("PrimaryHandTriggerUp", () => OVRInput.GetUp(OVRInput.Button.PrimaryHandTrigger)),
			new BoolMonitor("Up", () => OVRInput.Get(OVRInput.Button.Up)),
			new BoolMonitor("Down", () => OVRInput.Get(OVRInput.Button.Down)),
			new BoolMonitor("Left", () => OVRInput.Get(OVRInput.Button.Left)),
			new BoolMonitor("Right", () => OVRInput.Get(OVRInput.Button.Right)),
			new BoolMonitor("Touchpad (Click)", () => OVRInput.Get(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("TouchpadDown (Click)", () => OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("TouchpadUp (Click)", () => OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("Touchpad (Touch)", () => OVRInput.Get(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("TouchpadDown (Touch)", () => OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("TouchpadUp (Touch)", () => OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("Start", () => OVRInput.Get(OVRInput.RawButton.Start)),
			new BoolMonitor("StartDown", () => OVRInput.GetDown(OVRInput.RawButton.Start)),
			new BoolMonitor("StartUp", () => OVRInput.GetUp(OVRInput.RawButton.Start)),
			new BoolMonitor("Back", () => OVRInput.Get(OVRInput.RawButton.Back)),
			new BoolMonitor("BackDown", () => OVRInput.GetDown(OVRInput.RawButton.Back)),
			new BoolMonitor("BackUp", () => OVRInput.GetUp(OVRInput.RawButton.Back)),
			new BoolMonitor("A", () => OVRInput.Get(OVRInput.RawButton.A)),
			new BoolMonitor("ADown", () => OVRInput.GetDown(OVRInput.RawButton.A)),
			new BoolMonitor("AUp", () => OVRInput.GetUp(OVRInput.RawButton.A))
		};
	}

	private void Update()
	{
		OVRInput.Controller activeController = OVRInput.GetActiveController();
		data.Length = 0;
		byte controllerRecenterCount = OVRInput.GetControllerRecenterCount();
		data.AppendFormat("RecenterCount: {0}\n", controllerRecenterCount);
		byte controllerBatteryPercentRemaining = OVRInput.GetControllerBatteryPercentRemaining();
		data.AppendFormat("Battery: {0}\n", controllerBatteryPercentRemaining);
		float appFramerate = OVRPlugin.GetAppFramerate();
		data.AppendFormat("Framerate: {0:F2}\n", appFramerate);
		string arg = activeController.ToString();
		data.AppendFormat("Active: {0}\n", arg);
		string arg2 = OVRInput.GetConnectedControllers().ToString();
		data.AppendFormat("Connected: {0}\n", arg2);
		data.AppendFormat("PrevConnected: {0}\n", prevConnected);
		controllers.Update();
		controllers.AppendToStringBuilder(ref data);
		prevConnected = arg2;
		Quaternion localControllerRotation = OVRInput.GetLocalControllerRotation(activeController);
		data.AppendFormat("Orientation: ({0:F2}, {1:F2}, {2:F2}, {3:F2})\n", localControllerRotation.x, localControllerRotation.y, localControllerRotation.z, localControllerRotation.w);
		Vector3 localControllerAngularVelocity = OVRInput.GetLocalControllerAngularVelocity(activeController);
		data.AppendFormat("AngVel: ({0:F2}, {1:F2}, {2:F2})\n", localControllerAngularVelocity.x, localControllerAngularVelocity.y, localControllerAngularVelocity.z);
		Vector3 localControllerAngularAcceleration = OVRInput.GetLocalControllerAngularAcceleration(activeController);
		data.AppendFormat("AngAcc: ({0:F2}, {1:F2}, {2:F2})\n", localControllerAngularAcceleration.x, localControllerAngularAcceleration.y, localControllerAngularAcceleration.z);
		Vector3 localControllerPosition = OVRInput.GetLocalControllerPosition(activeController);
		data.AppendFormat("Position: ({0:F2}, {1:F2}, {2:F2})\n", localControllerPosition.x, localControllerPosition.y, localControllerPosition.z);
		Vector3 localControllerVelocity = OVRInput.GetLocalControllerVelocity(activeController);
		data.AppendFormat("Vel: ({0:F2}, {1:F2}, {2:F2})\n", localControllerVelocity.x, localControllerVelocity.y, localControllerVelocity.z);
		Vector3 localControllerAcceleration = OVRInput.GetLocalControllerAcceleration(activeController);
		data.AppendFormat("Acc: ({0:F2}, {1:F2}, {2:F2})\n", localControllerAcceleration.x, localControllerAcceleration.y, localControllerAcceleration.z);
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
		data.AppendFormat("PrimaryTouchpad: ({0:F2}, {1:F2})\n", vector.x, vector.y);
		Vector2 vector2 = OVRInput.Get(OVRInput.Axis2D.SecondaryTouchpad);
		data.AppendFormat("SecondaryTouchpad: ({0:F2}, {1:F2})\n", vector2.x, vector2.y);
		float num = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger);
		data.AppendFormat("PrimaryIndexTriggerAxis1D: ({0:F2})\n", num);
		float num2 = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger);
		data.AppendFormat("PrimaryHandTriggerAxis1D: ({0:F2})\n", num2);
		for (int i = 0; i < monitors.Count; i++)
		{
			monitors[i].Update();
			monitors[i].AppendToStringBuilder(ref data);
		}
		if (uiText != null)
		{
			uiText.text = data.ToString();
		}
	}
}
public class OVRGrabbable : UnityEngine.MonoBehaviour
{
	[SerializeField]
	protected bool m_allowOffhandGrab = true;

	[SerializeField]
	protected bool m_snapPosition;

	[SerializeField]
	protected bool m_snapOrientation;

	[SerializeField]
	protected Transform m_snapOffset;

	[SerializeField]
	protected Collider[] m_grabPoints;

	protected bool m_grabbedKinematic;

	protected Collider m_grabbedCollider;

	protected OVRGrabber m_grabbedBy;

	public bool allowOffhandGrab => m_allowOffhandGrab;

	public bool isGrabbed => m_grabbedBy != null;

	public bool snapPosition => m_snapPosition;

	public bool snapOrientation => m_snapOrientation;

	public Transform snapOffset => m_snapOffset;

	public OVRGrabber grabbedBy => m_grabbedBy;

	public Transform grabbedTransform => m_grabbedCollider.transform;

	public Rigidbody grabbedRigidbody => m_grabbedCollider.attachedRigidbody;

	public Collider[] grabPoints => m_grabPoints;

	public virtual void GrabBegin(OVRGrabber hand, Collider grabPoint)
	{
		m_grabbedBy = hand;
		m_grabbedCollider = grabPoint;
		base.gameObject.GetComponent<Rigidbody>().isKinematic = true;
	}

	public virtual void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		Rigidbody component = base.gameObject.GetComponent<Rigidbody>();
		component.isKinematic = m_grabbedKinematic;
		component.velocity = linearVelocity;
		component.angularVelocity = angularVelocity;
		m_grabbedBy = null;
		m_grabbedCollider = null;
	}

	private void Awake()
	{
		if (m_grabPoints.Length == 0)
		{
			Collider component = GetComponent<Collider>();
			if (component == null)
			{
				throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
			}
			m_grabPoints = new Collider[1] { component };
		}
	}

	protected virtual void Start()
	{
		m_grabbedKinematic = GetComponent<Rigidbody>().isKinematic;
	}

	private void OnDestroy()
	{
		if (m_grabbedBy != null)
		{
			m_grabbedBy.ForceRelease(this);
		}
	}
}
[RequireComponent(typeof(Rigidbody))]
public class OVRGrabber : UnityEngine.MonoBehaviour
{
	public float grabBegin = 0.55f;

	public float grabEnd = 0.35f;

	[SerializeField]
	protected bool m_parentHeldObject;

	[SerializeField]
	protected Transform m_gripTransform;

	[SerializeField]
	protected Collider[] m_grabVolumes;

	[SerializeField]
	protected OVRInput.Controller m_controller;

	[SerializeField]
	protected Transform m_parentTransform;

	protected bool m_grabVolumeEnabled = true;

	protected Vector3 m_lastPos;

	protected Quaternion m_lastRot;

	protected Quaternion m_anchorOffsetRotation;

	protected Vector3 m_anchorOffsetPosition;

	protected float m_prevFlex;

	protected OVRGrabbable m_grabbedObj;

	protected Vector3 m_grabbedObjectPosOff;

	protected Quaternion m_grabbedObjectRotOff;

	protected Dictionary<OVRGrabbable, int> m_grabCandidates = new Dictionary<OVRGrabbable, int>();

	protected bool operatingWithoutOVRCameraRig = true;

	public OVRGrabbable grabbedObject => m_grabbedObj;

	public void ForceRelease(OVRGrabbable grabbable)
	{
		if (m_grabbedObj != null && m_grabbedObj == grabbable)
		{
			GrabEnd();
		}
	}

	protected virtual void Awake()
	{
		m_anchorOffsetPosition = base.transform.localPosition;
		m_anchorOffsetRotation = base.transform.localRotation;
		OVRCameraRig oVRCameraRig = null;
		if (base.transform.parent != null && base.transform.parent.parent != null)
		{
			oVRCameraRig = base.transform.parent.parent.GetComponent<OVRCameraRig>();
		}
		if (oVRCameraRig != null)
		{
			oVRCameraRig.UpdatedAnchors += delegate
			{
				OnUpdatedAnchors();
			};
			operatingWithoutOVRCameraRig = false;
		}
	}

	protected virtual void Start()
	{
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_parentTransform == null)
		{
			if (base.gameObject.transform.parent != null)
			{
				m_parentTransform = base.gameObject.transform.parent.transform;
				return;
			}
			m_parentTransform = new GameObject().transform;
			m_parentTransform.position = Vector3.zero;
			m_parentTransform.rotation = Quaternion.identity;
		}
	}

	private void FixedUpdate()
	{
		if (operatingWithoutOVRCameraRig)
		{
			OnUpdatedAnchors();
		}
	}

	private void OnUpdatedAnchors()
	{
		Vector3 localControllerPosition = OVRInput.GetLocalControllerPosition(m_controller);
		Quaternion localControllerRotation = OVRInput.GetLocalControllerRotation(m_controller);
		Vector3 vector = m_parentTransform.TransformPoint(m_anchorOffsetPosition + localControllerPosition);
		Quaternion rot = m_parentTransform.rotation * localControllerRotation * m_anchorOffsetRotation;
		GetComponent<Rigidbody>().MovePosition(vector);
		GetComponent<Rigidbody>().MoveRotation(rot);
		if (!m_parentHeldObject)
		{
			MoveGrabbedObject(vector, rot);
		}
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		float prevFlex = m_prevFlex;
		m_prevFlex = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
		CheckForGrabOrRelease(prevFlex);
	}

	private void OnDestroy()
	{
		if (m_grabbedObj != null)
		{
			GrabEnd();
		}
	}

	private void OnTriggerEnter(Collider otherCollider)
	{
		OVRGrabbable oVRGrabbable = otherCollider.GetComponent<OVRGrabbable>() ?? otherCollider.GetComponentInParent<OVRGrabbable>();
		if (!(oVRGrabbable == null))
		{
			int value = 0;
			m_grabCandidates.TryGetValue(oVRGrabbable, out value);
			m_grabCandidates[oVRGrabbable] = value + 1;
		}
	}

	private void OnTriggerExit(Collider otherCollider)
	{
		OVRGrabbable oVRGrabbable = otherCollider.GetComponent<OVRGrabbable>() ?? otherCollider.GetComponentInParent<OVRGrabbable>();
		if (oVRGrabbable == null)
		{
			return;
		}
		int value = 0;
		if (m_grabCandidates.TryGetValue(oVRGrabbable, out value))
		{
			if (value > 1)
			{
				m_grabCandidates[oVRGrabbable] = value - 1;
			}
			else
			{
				m_grabCandidates.Remove(oVRGrabbable);
			}
		}
	}

	protected void CheckForGrabOrRelease(float prevFlex)
	{
		if (m_prevFlex >= grabBegin && prevFlex < grabBegin)
		{
			GrabBegin();
		}
		else if (m_prevFlex <= grabEnd && prevFlex > grabEnd)
		{
			GrabEnd();
		}
	}

	protected virtual void GrabBegin()
	{
		float num = float.MaxValue;
		OVRGrabbable oVRGrabbable = null;
		Collider grabPoint = null;
		foreach (OVRGrabbable key in m_grabCandidates.Keys)
		{
			if (key.isGrabbed && !key.allowOffhandGrab)
			{
				continue;
			}
			for (int i = 0; i < key.grabPoints.Length; i++)
			{
				Collider collider = key.grabPoints[i];
				Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
				float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					oVRGrabbable = key;
					grabPoint = collider;
				}
			}
		}
		GrabVolumeEnable(enabled: false);
		if (!(oVRGrabbable != null))
		{
			return;
		}
		if (oVRGrabbable.isGrabbed)
		{
			oVRGrabbable.grabbedBy.OffhandGrabbed(oVRGrabbable);
		}
		m_grabbedObj = oVRGrabbable;
		m_grabbedObj.GrabBegin(this, grabPoint);
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_grabbedObj.snapPosition)
		{
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
		}
		else
		{
			Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
			vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
			m_grabbedObjectPosOff = vector2;
		}
		if (m_grabbedObj.snapOrientation)
		{
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}
		else
		{
			Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
			m_grabbedObjectRotOff = grabbedObjectRotOff;
		}
		MoveGrabbedObject(m_lastPos, m_lastRot, forceTeleport: true);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = base.transform;
		}
	}

	protected virtual void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
	{
		if (!(m_grabbedObj == null))
		{
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 position = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (forceTeleport)
			{
				grabbedRigidbody.transform.position = position;
				grabbedRigidbody.transform.rotation = quaternion;
			}
			else
			{
				grabbedRigidbody.MovePosition(position);
				grabbedRigidbody.MoveRotation(quaternion);
			}
		}
	}

	protected void GrabEnd()
	{
		if (m_grabbedObj != null)
		{
			OVRPose oVRPose = default(OVRPose);
			oVRPose.position = OVRInput.GetLocalControllerPosition(m_controller);
			oVRPose.orientation = OVRInput.GetLocalControllerRotation(m_controller);
			OVRPose oVRPose2 = oVRPose;
			oVRPose = default(OVRPose);
			oVRPose.position = m_anchorOffsetPosition;
			oVRPose.orientation = m_anchorOffsetRotation;
			OVRPose oVRPose3 = oVRPose;
			oVRPose2 *= oVRPose3;
			OVRPose oVRPose4 = base.transform.ToOVRPose() * oVRPose2.Inverse();
			Vector3 linearVelocity = oVRPose4.orientation * OVRInput.GetLocalControllerVelocity(m_controller);
			Vector3 angularVelocity = oVRPose4.orientation * OVRInput.GetLocalControllerAngularVelocity(m_controller);
			GrabbableRelease(linearVelocity, angularVelocity);
		}
		GrabVolumeEnable(enabled: true);
	}

	protected void GrabbableRelease(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		m_grabbedObj.GrabEnd(linearVelocity, angularVelocity);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = null;
		}
		m_grabbedObj = null;
	}

	protected virtual void GrabVolumeEnable(bool enabled)
	{
		if (m_grabVolumeEnabled != enabled)
		{
			m_grabVolumeEnabled = enabled;
			for (int i = 0; i < m_grabVolumes.Length; i++)
			{
				Collider collider = m_grabVolumes[i];
				collider.enabled = m_grabVolumeEnabled;
			}
			if (!m_grabVolumeEnabled)
			{
				m_grabCandidates.Clear();
			}
		}
	}

	protected virtual void OffhandGrabbed(OVRGrabbable grabbable)
	{
		if (m_grabbedObj == grabbable)
		{
			GrabbableRelease(Vector3.zero, Vector3.zero);
		}
	}
}
public class OVRGridCube : UnityEngine.MonoBehaviour
{
	public KeyCode GridKey = KeyCode.G;

	private GameObject CubeGrid;

	private bool CubeGridOn;

	private bool CubeSwitchColorOld;

	private bool CubeSwitchColor;

	private int gridSizeX = 6;

	private int gridSizeY = 4;

	private int gridSizeZ = 6;

	private float gridScale = 0.3f;

	private float cubeScale = 0.03f;

	private OVRCameraRig CameraController;

	private void Update()
	{
		UpdateCubeGrid();
	}

	public void SetOVRCameraController(ref OVRCameraRig cameraController)
	{
		CameraController = cameraController;
	}

	private void UpdateCubeGrid()
	{
		if (Input.GetKeyDown(GridKey))
		{
			if (!CubeGridOn)
			{
				CubeGridOn = true;
				UnityEngine.Debug.LogWarning("CubeGrid ON");
				if (CubeGrid != null)
				{
					CubeGrid.SetActive(value: true);
				}
				else
				{
					CreateCubeGrid();
				}
			}
			else
			{
				CubeGridOn = false;
				UnityEngine.Debug.LogWarning("CubeGrid OFF");
				if (CubeGrid != null)
				{
					CubeGrid.SetActive(value: false);
				}
			}
		}
		if (CubeGrid != null)
		{
			CubeSwitchColor = !OVRManager.tracker.isPositionTracked;
			if (CubeSwitchColor != CubeSwitchColorOld)
			{
				CubeGridSwitchColor(CubeSwitchColor);
			}
			CubeSwitchColorOld = CubeSwitchColor;
		}
	}

	private void CreateCubeGrid()
	{
		UnityEngine.Debug.LogWarning("Create CubeGrid");
		CubeGrid = new GameObject("CubeGrid");
		CubeGrid.layer = CameraController.gameObject.layer;
		for (int i = -gridSizeX; i <= gridSizeX; i++)
		{
			for (int j = -gridSizeY; j <= gridSizeY; j++)
			{
				for (int k = -gridSizeZ; k <= gridSizeZ; k++)
				{
					int num = 0;
					if ((i == 0 && j == 0) || (i == 0 && k == 0) || (j == 0 && k == 0))
					{
						num = ((i != 0 || j != 0 || k != 0) ? 1 : 2);
					}
					GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
					BoxCollider component = gameObject.GetComponent<BoxCollider>();
					component.enabled = false;
					gameObject.layer = CameraController.gameObject.layer;
					Renderer component2 = gameObject.GetComponent<Renderer>();
					component2.shadowCastingMode = ShadowCastingMode.Off;
					component2.receiveShadows = false;
					switch (num)
					{
					case 0:
						component2.material.color = UnityEngine.Color.red;
						break;
					case 1:
						component2.material.color = UnityEngine.Color.white;
						break;
					default:
						component2.material.color = UnityEngine.Color.yellow;
						break;
					}
					gameObject.transform.position = new Vector3((float)i * gridScale, (float)j * gridScale, (float)k * gridScale);
					float num2 = 0.7f;
					if (num == 1)
					{
						num2 = 1f;
					}
					if (num == 2)
					{
						num2 = 2f;
					}
					gameObject.transform.localScale = new Vector3(cubeScale * num2, cubeScale * num2, cubeScale * num2);
					gameObject.transform.parent = CubeGrid.transform;
				}
			}
		}
	}

	private void CubeGridSwitchColor(bool CubeSwitchColor)
	{
		UnityEngine.Color color = UnityEngine.Color.red;
		if (CubeSwitchColor)
		{
			color = UnityEngine.Color.blue;
		}
		foreach (Transform item in CubeGrid.transform)
		{
			Material material = item.GetComponent<Renderer>().material;
			if (material.color == UnityEngine.Color.red || material.color == UnityEngine.Color.blue)
			{
				material.color = color;
			}
		}
	}
}
namespace UnityEngine.EventSystems
{
	public class OVRInputModule : PointerInputModule
	{
		[Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
		public enum InputMode
		{
			Mouse,
			Buttons
		}

		[Tooltip("Object which points with Z axis. E.g. CentreEyeAnchor from OVRCameraRig")]
		public Transform rayTransform;

		[Tooltip("Gamepad button to act as gaze click")]
		public OVRInput.Button joyPadClickButton = OVRInput.Button.One;

		[Tooltip("Keyboard button to act as gaze click")]
		public KeyCode gazeClickKey = KeyCode.Space;

		[Header("Physics")]
		[Tooltip("Perform an sphere cast to determine correct depth for gaze pointer")]
		public bool performSphereCastForGazepointer;

		[Tooltip("Match the gaze pointer normal to geometry normal for physics colliders")]
		public bool matchNormalOnPhysicsColliders;

		[Header("Gamepad Stick Scroll")]
		[Tooltip("Enable scrolling with the right stick on a gamepad")]
		public bool useRightStickScroll = true;

		[Tooltip("Deadzone for right stick to prevent accidental scrolling")]
		public float rightStickDeadZone = 0.15f;

		[Header("Touchpad Swipe Scroll")]
		[Tooltip("Enable scrolling by swiping the GearVR touchpad")]
		public bool useSwipeScroll = true;

		[Tooltip("Minimum trackpad movement in pixels to start swiping")]
		public float swipeDragThreshold = 2f;

		[Tooltip("Distance scrolled when swipe scroll occurs")]
		public float swipeDragScale = 1f;

		[Tooltip("Invert X axis on touchpad")]
		public bool InvertSwipeXAxis;

		[NonSerialized]
		public OVRRaycaster activeGraphicRaycaster;

		[Header("Dragging")]
		[Tooltip("Minimum pointer movement in degrees to start dragging")]
		public float angleDragThreshold = 1f;

		private float m_NextAction;

		private Vector2 m_LastMousePosition;

		private Vector2 m_MousePosition;

		[Header("Standalone Input Module")]
		[SerializeField]
		private string m_HorizontalAxis = "Horizontal";

		[SerializeField]
		private string m_VerticalAxis = "Vertical";

		[SerializeField]
		private string m_SubmitButton = "Submit";

		[SerializeField]
		private string m_CancelButton = "Cancel";

		[SerializeField]
		private float m_InputActionsPerSecond = 10f;

		[SerializeField]
		private bool m_AllowActivationOnMobileDevice;

		protected Dictionary<int, OVRPointerEventData> m_VRRayPointerData = new Dictionary<int, OVRPointerEventData>();

		private readonly MouseState m_MouseState = new MouseState();

		[Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
		public InputMode inputMode => InputMode.Mouse;

		public bool allowActivationOnMobileDevice
		{
			get
			{
				return m_AllowActivationOnMobileDevice;
			}
			set
			{
				m_AllowActivationOnMobileDevice = value;
			}
		}

		public float inputActionsPerSecond
		{
			get
			{
				return m_InputActionsPerSecond;
			}
			set
			{
				m_InputActionsPerSecond = value;
			}
		}

		public string horizontalAxis
		{
			get
			{
				return m_HorizontalAxis;
			}
			set
			{
				m_HorizontalAxis = value;
			}
		}

		public string verticalAxis
		{
			get
			{
				return m_VerticalAxis;
			}
			set
			{
				m_VerticalAxis = value;
			}
		}

		public string submitButton
		{
			get
			{
				return m_SubmitButton;
			}
			set
			{
				m_SubmitButton = value;
			}
		}

		public string cancelButton
		{
			get
			{
				return m_CancelButton;
			}
			set
			{
				m_CancelButton = value;
			}
		}

		protected OVRInputModule()
		{
		}

		public override void UpdateModule()
		{
			m_LastMousePosition = m_MousePosition;
			m_MousePosition = Input.mousePosition;
		}

		public override bool IsModuleSupported()
		{
			return m_AllowActivationOnMobileDevice || Input.mousePresent;
		}

		public override bool ShouldActivateModule()
		{
			if (!base.ShouldActivateModule())
			{
				return false;
			}
			bool buttonDown = Input.GetButtonDown(m_SubmitButton);
			buttonDown |= Input.GetButtonDown(m_CancelButton);
			buttonDown |= !Mathf.Approximately(Input.GetAxisRaw(m_HorizontalAxis), 0f);
			buttonDown |= !Mathf.Approximately(Input.GetAxisRaw(m_VerticalAxis), 0f);
			buttonDown |= (m_MousePosition - m_LastMousePosition).sqrMagnitude > 0f;
			return buttonDown | Input.GetMouseButtonDown(0);
		}

		public override void ActivateModule()
		{
			base.ActivateModule();
			m_MousePosition = Input.mousePosition;
			m_LastMousePosition = Input.mousePosition;
			GameObject gameObject = base.eventSystem.currentSelectedGameObject;
			if (gameObject == null)
			{
				gameObject = base.eventSystem.firstSelectedGameObject;
			}
			base.eventSystem.SetSelectedGameObject(gameObject, GetBaseEventData());
		}

		public override void DeactivateModule()
		{
			base.DeactivateModule();
			ClearSelection();
		}

		private bool SendSubmitEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			if (Input.GetButtonDown(m_SubmitButton))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.submitHandler);
			}
			if (Input.GetButtonDown(m_CancelButton))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.cancelHandler);
			}
			return baseEventData.used;
		}

		private bool AllowMoveEventProcessing(float time)
		{
			bool buttonDown = Input.GetButtonDown(m_HorizontalAxis);
			buttonDown |= Input.GetButtonDown(m_VerticalAxis);
			return buttonDown | (time > m_NextAction);
		}

		private Vector2 GetRawMoveVector()
		{
			Vector2 zero = Vector2.zero;
			zero.x = Input.GetAxisRaw(m_HorizontalAxis);
			zero.y = Input.GetAxisRaw(m_VerticalAxis);
			if (Input.GetButtonDown(m_HorizontalAxis))
			{
				if (zero.x < 0f)
				{
					zero.x = -1f;
				}
				if (zero.x > 0f)
				{
					zero.x = 1f;
				}
			}
			if (Input.GetButtonDown(m_VerticalAxis))
			{
				if (zero.y < 0f)
				{
					zero.y = -1f;
				}
				if (zero.y > 0f)
				{
					zero.y = 1f;
				}
			}
			return zero;
		}

		private bool SendMoveEventToSelectedObject()
		{
			float unscaledTime = Time.unscaledTime;
			if (!AllowMoveEventProcessing(unscaledTime))
			{
				return false;
			}
			Vector2 rawMoveVector = GetRawMoveVector();
			AxisEventData axisEventData = GetAxisEventData(rawMoveVector.x, rawMoveVector.y, 0.6f);
			if (!Mathf.Approximately(axisEventData.moveVector.x, 0f) || !Mathf.Approximately(axisEventData.moveVector.y, 0f))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, axisEventData, ExecuteEvents.moveHandler);
			}
			m_NextAction = unscaledTime + 1f / m_InputActionsPerSecond;
			return axisEventData.used;
		}

		private bool SendUpdateEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.updateSelectedHandler);
			return baseEventData.used;
		}

		private void ProcessMousePress(MouseButtonEventData data)
		{
			PointerEventData buttonData = data.buttonData;
			GameObject gameObject = buttonData.pointerCurrentRaycast.gameObject;
			if (data.PressedThisFrame())
			{
				buttonData.eligibleForClick = true;
				buttonData.delta = Vector2.zero;
				buttonData.dragging = false;
				buttonData.useDragThreshold = true;
				buttonData.pressPosition = buttonData.position;
				if (buttonData.IsVRPointer())
				{
					buttonData.SetSwipeStart(Input.mousePosition);
				}
				buttonData.pointerPressRaycast = buttonData.pointerCurrentRaycast;
				DeselectIfSelectionChanged(gameObject, buttonData);
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, buttonData, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				float unscaledTime = Time.unscaledTime;
				if (gameObject2 == buttonData.lastPress)
				{
					float num = unscaledTime - buttonData.clickTime;
					if (num < 0.3f)
					{
						buttonData.clickCount++;
					}
					else
					{
						buttonData.clickCount = 1;
					}
					buttonData.clickTime = unscaledTime;
				}
				else
				{
					buttonData.clickCount = 1;
				}
				buttonData.pointerPress = gameObject2;
				buttonData.rawPointerPress = gameObject;
				buttonData.clickTime = unscaledTime;
				buttonData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (buttonData.pointerDrag != null)
				{
					ExecuteEvents.Execute(buttonData.pointerDrag, buttonData, ExecuteEvents.initializePotentialDrag);
				}
			}
			if (data.ReleasedThisFrame())
			{
				ExecuteEvents.Execute(buttonData.pointerPress, buttonData, ExecuteEvents.pointerUpHandler);
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				if (buttonData.pointerPress == eventHandler && buttonData.eligibleForClick)
				{
					ExecuteEvents.Execute(buttonData.pointerPress, buttonData, ExecuteEvents.pointerClickHandler);
				}
				else if (buttonData.pointerDrag != null)
				{
					ExecuteEvents.ExecuteHierarchy(gameObject, buttonData, ExecuteEvents.dropHandler);
				}
				buttonData.eligibleForClick = false;
				buttonData.pointerPress = null;
				buttonData.rawPointerPress = null;
				if (buttonData.pointerDrag != null && buttonData.dragging)
				{
					ExecuteEvents.Execute(buttonData.pointerDrag, buttonData, ExecuteEvents.endDragHandler);
				}
				buttonData.dragging = false;
				buttonData.pointerDrag = null;
				if (gameObject != buttonData.pointerEnter)
				{
					HandlePointerExitAndEnter(buttonData, null);
					HandlePointerExitAndEnter(buttonData, gameObject);
				}
			}
		}

		private void ProcessMouseEvent(MouseState mouseData)
		{
			bool pressed = mouseData.AnyPressesThisFrame();
			bool released = mouseData.AnyReleasesThisFrame();
			MouseButtonEventData eventData = mouseData.GetButtonState(PointerEventData.InputButton.Left).eventData;
			if (UseMouse(pressed, released, eventData.buttonData))
			{
				ProcessMousePress(eventData);
				ProcessMove(eventData.buttonData);
				ProcessDrag(eventData.buttonData);
				ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData);
				ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData.buttonData);
				ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData);
				ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData.buttonData);
				if (!Mathf.Approximately(eventData.buttonData.scrollDelta.sqrMagnitude, 0f))
				{
					GameObject eventHandler = ExecuteEvents.GetEventHandler<IScrollHandler>(eventData.buttonData.pointerCurrentRaycast.gameObject);
					ExecuteEvents.ExecuteHierarchy(eventHandler, eventData.buttonData, ExecuteEvents.scrollHandler);
				}
			}
		}

		public override void Process()
		{
			bool flag = SendUpdateEventToSelectedObject();
			if (base.eventSystem.sendNavigationEvents)
			{
				if (!flag)
				{
					flag |= SendMoveEventToSelectedObject();
				}
				if (!flag)
				{
					SendSubmitEventToSelectedObject();
				}
			}
			ProcessMouseEvent(GetGazePointerData());
		}

		private static bool UseMouse(bool pressed, bool released, PointerEventData pointerData)
		{
			if (pressed || released || IsPointerMoving(pointerData) || pointerData.IsScrolling())
			{
				return true;
			}
			return false;
		}

		protected void CopyFromTo(OVRPointerEventData from, OVRPointerEventData to)
		{
			to.position = from.position;
			to.delta = from.delta;
			to.scrollDelta = from.scrollDelta;
			to.pointerCurrentRaycast = from.pointerCurrentRaycast;
			to.pointerEnter = from.pointerEnter;
			to.worldSpaceRay = from.worldSpaceRay;
		}

		protected new void CopyFromTo(PointerEventData from, PointerEventData to)
		{
			to.position = from.position;
			to.delta = from.delta;
			to.scrollDelta = from.scrollDelta;
			to.pointerCurrentRaycast = from.pointerCurrentRaycast;
			to.pointerEnter = from.pointerEnter;
		}

		protected bool GetPointerData(int id, out OVRPointerEventData data, bool create)
		{
			if (!m_VRRayPointerData.TryGetValue(id, out data) && create)
			{
				data = new OVRPointerEventData(base.eventSystem)
				{
					pointerId = id
				};
				m_VRRayPointerData.Add(id, data);
				return true;
			}
			return false;
		}

		protected new void ClearSelection()
		{
			BaseEventData baseEventData = GetBaseEventData();
			foreach (PointerEventData value in m_PointerData.Values)
			{
				HandlePointerExitAndEnter(value, null);
			}
			foreach (OVRPointerEventData value2 in m_VRRayPointerData.Values)
			{
				HandlePointerExitAndEnter(value2, null);
			}
			m_PointerData.Clear();
			base.eventSystem.SetSelectedGameObject(null, baseEventData);
		}

		private static Vector3 GetRectTransformNormal(RectTransform rectTransform)
		{
			Vector3[] array = new Vector3[4];
			rectTransform.GetWorldCorners(array);
			Vector3 lhs = array[3] - array[0];
			Vector3 rhs = array[1] - array[0];
			rectTransform.GetWorldCorners(array);
			return Vector3.Cross(lhs, rhs).normalized;
		}

		protected virtual MouseState GetGazePointerData()
		{
			GetPointerData(-1, out var data, create: true);
			data.Reset();
			data.worldSpaceRay = new Ray(rayTransform.position, rayTransform.forward);
			data.scrollDelta = GetExtraScrollDelta();
			data.button = PointerEventData.InputButton.Left;
			data.useDragThreshold = true;
			base.eventSystem.RaycastAll(data, m_RaycastResultCache);
			RaycastResult raycastResult2 = (data.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache));
			m_RaycastResultCache.Clear();
			OVRRaycaster oVRRaycaster = raycastResult2.module as OVRRaycaster;
			if ((bool)oVRRaycaster)
			{
				data.position = oVRRaycaster.GetScreenPosition(raycastResult2);
				RectTransform component = raycastResult2.gameObject.GetComponent<RectTransform>();
				if (component != null)
				{
					Vector3 worldPosition = raycastResult2.worldPosition;
					Vector3 rectTransformNormal = GetRectTransformNormal(component);
					OVRGazePointer.instance.SetPosition(worldPosition, rectTransformNormal);
					OVRGazePointer.instance.RequestShow();
				}
			}
			OVRPhysicsRaycaster oVRPhysicsRaycaster = raycastResult2.module as OVRPhysicsRaycaster;
			if ((bool)oVRPhysicsRaycaster)
			{
				Vector3 worldPosition2 = raycastResult2.worldPosition;
				if (performSphereCastForGazepointer)
				{
					List<RaycastResult> list = new List<RaycastResult>();
					oVRPhysicsRaycaster.Spherecast(data, list, OVRGazePointer.instance.GetCurrentRadius());
					if (list.Count > 0 && list[0].distance < raycastResult2.distance)
					{
						worldPosition2 = list[0].worldPosition;
					}
				}
				data.position = oVRPhysicsRaycaster.GetScreenPos(raycastResult2.worldPosition);
				OVRGazePointer.instance.RequestShow();
				if (matchNormalOnPhysicsColliders)
				{
					OVRGazePointer.instance.SetPosition(worldPosition2, raycastResult2.worldNormal);
				}
				else
				{
					OVRGazePointer.instance.SetPosition(worldPosition2);
				}
			}
			GetPointerData(-2, out var data2, create: true);
			CopyFromTo(data, data2);
			data2.button = PointerEventData.InputButton.Right;
			GetPointerData(-3, out var data3, create: true);
			CopyFromTo(data, data3);
			data3.button = PointerEventData.InputButton.Middle;
			m_MouseState.SetButtonState(PointerEventData.InputButton.Left, GetGazeButtonState(), data);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Right, PointerEventData.FramePressState.NotChanged, data2);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Middle, PointerEventData.FramePressState.NotChanged, data3);
			return m_MouseState;
		}

		protected MouseState GetCanvasPointerData()
		{
			GetPointerData(-1, out PointerEventData data, create: true);
			data.Reset();
			data.position = Vector2.zero;
			data.scrollDelta = Input.mouseScrollDelta;
			data.button = PointerEventData.InputButton.Left;
			if ((bool)activeGraphicRaycaster)
			{
				activeGraphicRaycaster.RaycastPointer(data, m_RaycastResultCache);
				RaycastResult raycastResult2 = (data.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache));
				m_RaycastResultCache.Clear();
				OVRRaycaster oVRRaycaster = raycastResult2.module as OVRRaycaster;
				if ((bool)oVRRaycaster)
				{
					Vector2 screenPosition = oVRRaycaster.GetScreenPosition(raycastResult2);
					data.delta = screenPosition - data.position;
					data.position = screenPosition;
				}
			}
			GetPointerData(-2, out PointerEventData data2, create: true);
			CopyFromTo(data, data2);
			data2.button = PointerEventData.InputButton.Right;
			GetPointerData(-3, out PointerEventData data3, create: true);
			CopyFromTo(data, data3);
			data3.button = PointerEventData.InputButton.Middle;
			m_MouseState.SetButtonState(PointerEventData.InputButton.Left, StateForMouseButton(0), data);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Right, StateForMouseButton(1), data2);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Middle, StateForMouseButton(2), data3);
			return m_MouseState;
		}

		private bool ShouldStartDrag(PointerEventData pointerEvent)
		{
			if (!pointerEvent.useDragThreshold)
			{
				return true;
			}
			if (!pointerEvent.IsVRPointer())
			{
				return (pointerEvent.pressPosition - pointerEvent.position).sqrMagnitude >= (float)(base.eventSystem.pixelDragThreshold * base.eventSystem.pixelDragThreshold);
			}
			if (useSwipeScroll && ((Vector3)pointerEvent.GetSwipeStart() - Input.mousePosition).magnitude > swipeDragThreshold)
			{
				return true;
			}
			Vector3 position = pointerEvent.pressEventCamera.transform.position;
			Vector3 normalized = (pointerEvent.pointerPressRaycast.worldPosition - position).normalized;
			Vector3 normalized2 = (pointerEvent.pointerCurrentRaycast.worldPosition - position).normalized;
			return Vector3.Dot(normalized, normalized2) < Mathf.Cos((float)Math.PI / 180f * angleDragThreshold);
		}

		private static bool IsPointerMoving(PointerEventData pointerEvent)
		{
			if (pointerEvent.IsVRPointer())
			{
				return true;
			}
			return pointerEvent.IsPointerMoving();
		}

		protected Vector2 SwipeAdjustedPosition(Vector2 originalPosition, PointerEventData pointerEvent)
		{
			if (useSwipeScroll)
			{
				Vector2 vector = (Vector2)Input.mousePosition - pointerEvent.GetSwipeStart();
				if (InvertSwipeXAxis)
				{
					vector.x *= -1f;
				}
				return originalPosition + vector * swipeDragScale;
			}
			return originalPosition;
		}

		protected override void ProcessDrag(PointerEventData pointerEvent)
		{
			Vector2 position = pointerEvent.position;
			bool flag = IsPointerMoving(pointerEvent);
			if (flag && pointerEvent.pointerDrag != null && !pointerEvent.dragging && ShouldStartDrag(pointerEvent))
			{
				if (pointerEvent.IsVRPointer())
				{
					pointerEvent.position = SwipeAdjustedPosition(position, pointerEvent);
				}
				ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.beginDragHandler);
				pointerEvent.dragging = true;
			}
			if (pointerEvent.dragging && flag && pointerEvent.pointerDrag != null)
			{
				if (pointerEvent.IsVRPointer())
				{
					pointerEvent.position = SwipeAdjustedPosition(position, pointerEvent);
				}
				if (pointerEvent.pointerPress != pointerEvent.pointerDrag)
				{
					ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);
					pointerEvent.eligibleForClick = false;
					pointerEvent.pointerPress = null;
					pointerEvent.rawPointerPress = null;
				}
				ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.dragHandler);
			}
		}

		protected virtual PointerEventData.FramePressState GetGazeButtonState()
		{
			bool flag = Input.GetKeyDown(gazeClickKey) || OVRInput.GetDown(joyPadClickButton);
			bool flag2 = Input.GetKeyUp(gazeClickKey) || OVRInput.GetUp(joyPadClickButton);
			flag |= Input.GetMouseButtonDown(0);
			flag2 |= Input.GetMouseButtonUp(0);
			if (flag && flag2)
			{
				return PointerEventData.FramePressState.PressedAndReleased;
			}
			if (flag)
			{
				return PointerEventData.FramePressState.Pressed;
			}
			if (flag2)
			{
				return PointerEventData.FramePressState.Released;
			}
			return PointerEventData.FramePressState.NotChanged;
		}

		protected Vector2 GetExtraScrollDelta()
		{
			Vector2 result = default(Vector2);
			if (useRightStickScroll)
			{
				Vector2 result2 = OVRInput.Get(OVRInput.Axis2D.SecondaryThumbstick);
				if (Mathf.Abs(result2.x) < rightStickDeadZone)
				{
					result2.x = 0f;
				}
				if (Mathf.Abs(result2.y) < rightStickDeadZone)
				{
					result2.y = 0f;
				}
				return result2;
			}
			return result;
		}
	}
}
public class OVRModeParms : UnityEngine.MonoBehaviour
{
	public OVRInput.RawButton resetButton = OVRInput.RawButton.X;

	private void Start()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
		else
		{
			InvokeRepeating("TestPowerStateMode", 10f, 10f);
		}
	}

	private void Update()
	{
		if (OVRInput.GetDown(resetButton))
		{
			OVRPlugin.cpuLevel = 0;
			OVRPlugin.gpuLevel = 1;
		}
	}

	private void TestPowerStateMode()
	{
		if (OVRPlugin.powerSaving)
		{
			UnityEngine.Debug.Log("POWER SAVE MODE ACTIVATED");
		}
	}
}
public class OVRMonoscopic : UnityEngine.MonoBehaviour
{
	public OVRInput.RawButton toggleButton = OVRInput.RawButton.B;

	private bool monoscopic;

	private void Update()
	{
		if (OVRInput.GetDown(toggleButton))
		{
			monoscopic = !monoscopic;
			OVRManager.instance.monoscopic = monoscopic;
		}
	}
}
[RequireComponent(typeof(OVRRaycaster))]
public class OVRMousePointer : UnityEngine.MonoBehaviour
{
	public enum MouseShowPolicy
	{
		always,
		withGaze,
		withActivity
	}

	[Tooltip("Period of inactivity before mouse disappears")]
	public float inactivityTimeout = 1f;

	[Tooltip("Policy regarding when mouse pointer should be shown")]
	public MouseShowPolicy mouseShowPolicy;

	[Tooltip("Should the mouse pointer being active cause the gaze pointer to fade")]
	public bool hideGazePointerWhenActive;

	[Tooltip("Move the pointer in response to mouse movement")]
	public bool defaultMouseMovement = true;

	public float mouseMoveSpeed = 5f;

	private float lastMouseActivityTime;

	private OVRRaycaster raycaster;

	public GameObject pointerObject => GetComponent<OVRRaycaster>().pointer;

	private void Awake()
	{
		raycaster = GetComponent<OVRRaycaster>();
		pointerObject.SetActive(value: false);
		base.enabled = false;
	}

	private void Update()
	{
		if (mouseShowPolicy == MouseShowPolicy.withActivity)
		{
			pointerObject.SetActive(HasMovedRecently() && raycaster.IsFocussed());
		}
		else if (mouseShowPolicy == MouseShowPolicy.withGaze)
		{
			pointerObject.SetActive(raycaster.IsFocussed());
		}
		if (hideGazePointerWhenActive && HasMovedRecently() && raycaster.IsFocussed())
		{
			OVRGazePointer.instance.RequestHide();
		}
		if (defaultMouseMovement && raycaster.IsFocussed())
		{
			Vector2 vector = pointerObject.GetComponent<RectTransform>().localPosition;
			vector += new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y")) * mouseMoveSpeed;
			float width = GetComponent<RectTransform>().rect.width;
			float height = GetComponent<RectTransform>().rect.height;
			vector.x = Mathf.Clamp(vector.x, (0f - width) / 2f, width / 2f);
			vector.y = Mathf.Clamp(vector.y, (0f - height) / 2f, height / 2f);
			SetLocalPosition(vector);
		}
	}

	public bool HasMovedRecently()
	{
		return lastMouseActivityTime + inactivityTimeout > Time.time;
	}

	public void SetLocalPosition(Vector3 pos)
	{
		if ((pointerObject.GetComponent<RectTransform>().localPosition - pos).magnitude > 0.001f)
		{
			lastMouseActivityTime = Time.time;
		}
		pointerObject.GetComponent<RectTransform>().localPosition = pos;
	}
}
namespace UnityEngine.EventSystems
{
	[RequireComponent(typeof(OVRCameraRig))]
	public class OVRPhysicsRaycaster : BaseRaycaster
	{
		protected const int kNoEventMaskSet = -1;

		[SerializeField]
		protected LayerMask m_EventMask = -1;

		public int sortOrder = 20;

		public override Camera eventCamera => GetComponent<OVRCameraRig>().leftEyeCamera;

		public virtual int depth => (!(eventCamera != null)) ? 16777215 : ((int)eventCamera.depth);

		public override int sortOrderPriority => sortOrder;

		public int finalEventMask => (!(eventCamera != null)) ? (-1) : (eventCamera.cullingMask & (int)m_EventMask);

		public LayerMask eventMask
		{
			get
			{
				return m_EventMask;
			}
			set
			{
				m_EventMask = value;
			}
		}

		protected OVRPhysicsRaycaster()
		{
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			if (eventCamera == null || !eventData.IsVRPointer())
			{
				return;
			}
			Ray ray = eventData.GetRay();
			float maxDistance = eventCamera.farClipPlane - eventCamera.nearClipPlane;
			RaycastHit[] array = Physics.RaycastAll(ray, maxDistance, finalEventMask);
			if (array.Length > 1)
			{
				Array.Sort(array, (RaycastHit r1, RaycastHit r2) => r1.distance.CompareTo(r2.distance));
			}
			if (array.Length != 0)
			{
				int i = 0;
				for (int num = array.Length; i < num; i++)
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = array[i].collider.gameObject;
					raycastResult.module = this;
					raycastResult.distance = array[i].distance;
					raycastResult.index = resultAppendList.Count;
					raycastResult.worldPosition = array[0].point;
					raycastResult.worldNormal = array[0].normal;
					RaycastResult item = raycastResult;
					resultAppendList.Add(item);
				}
			}
		}

		public void Spherecast(PointerEventData eventData, List<RaycastResult> resultAppendList, float radius)
		{
			if (eventCamera == null || !eventData.IsVRPointer())
			{
				return;
			}
			Ray ray = eventData.GetRay();
			float maxDistance = eventCamera.farClipPlane - eventCamera.nearClipPlane;
			RaycastHit[] array = Physics.SphereCastAll(ray, radius, maxDistance, finalEventMask);
			if (array.Length > 1)
			{
				Array.Sort(array, (RaycastHit r1, RaycastHit r2) => r1.distance.CompareTo(r2.distance));
			}
			if (array.Length != 0)
			{
				int i = 0;
				for (int num = array.Length; i < num; i++)
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = array[i].collider.gameObject;
					raycastResult.module = this;
					raycastResult.distance = array[i].distance;
					raycastResult.index = resultAppendList.Count;
					raycastResult.worldPosition = array[0].point;
					raycastResult.worldNormal = array[0].normal;
					RaycastResult item = raycastResult;
					resultAppendList.Add(item);
				}
			}
		}

		public Vector2 GetScreenPos(Vector3 worldPosition)
		{
			return eventCamera.WorldToScreenPoint(worldPosition);
		}
	}
}
[RequireComponent(typeof(CharacterController))]
public class OVRPlayerController : UnityEngine.MonoBehaviour
{
	public float Acceleration = 0.1f;

	public float Damping = 0.3f;

	public float BackAndSideDampen = 0.5f;

	public float JumpForce = 0.3f;

	public float RotationAmount = 1.5f;

	public float RotationRatchet = 45f;

	[Tooltip("The player will rotate in fixed steps if Snap Rotation is enabled.")]
	public bool SnapRotation = true;

	[Tooltip("How many fixed speeds to use with linear movement? 0=linear control")]
	public int FixedSpeedSteps;

	public bool HmdResetsY = true;

	public bool HmdRotatesY = true;

	public float GravityModifier = 0.379f;

	public bool useProfileData = true;

	[NonSerialized]
	public float CameraHeight;

	[NonSerialized]
	public bool Teleported;

	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	protected CharacterController Controller;

	protected OVRCameraRig CameraRig;

	private float MoveScale = 1f;

	private Vector3 MoveThrottle = Vector3.zero;

	private float FallSpeed;

	private OVRPose? InitialPose;

	private float MoveScaleMultiplier = 1f;

	private float RotationScaleMultiplier = 1f;

	private bool SkipMouseRotation = true;

	private bool HaltUpdateMovement;

	private bool prevHatLeft;

	private bool prevHatRight;

	private float SimulationRate = 60f;

	private float buttonRotation;

	private bool ReadyToSnapTurn;

	public float InitialYRotation { get; private set; }

	public event Action<Transform> TransformUpdated;

	public event Action CameraUpdated;

	public event Action PreCharacterMove;

	private void Start()
	{
		Vector3 localPosition = CameraRig.transform.localPosition;
		localPosition.z = OVRManager.profile.eyeDepth;
		CameraRig.transform.localPosition = localPosition;
	}

	private void Awake()
	{
		Controller = base.gameObject.GetComponent<CharacterController>();
		if (Controller == null)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: No CharacterController attached.");
		}
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: More then 1 OVRCameraRig attached.");
		}
		else
		{
			CameraRig = componentsInChildren[0];
		}
		InitialYRotation = base.transform.rotation.eulerAngles.y;
	}

	private void OnEnable()
	{
		OVRManager.display.RecenteredPose += ResetOrientation;
		if (CameraRig != null)
		{
			CameraRig.UpdatedAnchors += UpdateTransform;
		}
	}

	private void OnDisable()
	{
		OVRManager.display.RecenteredPose -= ResetOrientation;
		if (CameraRig != null)
		{
			CameraRig.UpdatedAnchors -= UpdateTransform;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Q))
		{
			buttonRotation -= RotationRatchet;
		}
		if (Input.GetKeyDown(KeyCode.E))
		{
			buttonRotation += RotationRatchet;
		}
	}

	protected virtual void UpdateController()
	{
		if (useProfileData)
		{
			OVRPose? initialPose = InitialPose;
			if (!initialPose.HasValue)
			{
				InitialPose = new OVRPose
				{
					position = CameraRig.transform.localPosition,
					orientation = CameraRig.transform.localRotation
				};
			}
			Vector3 localPosition = CameraRig.transform.localPosition;
			if (OVRManager.instance.trackingOriginType == OVRManager.TrackingOrigin.EyeLevel)
			{
				localPosition.y = OVRManager.profile.eyeHeight - 0.5f * Controller.height + Controller.center.y;
			}
			else if (OVRManager.instance.trackingOriginType == OVRManager.TrackingOrigin.FloorLevel)
			{
				localPosition.y = 0f - 0.5f * Controller.height + Controller.center.y;
			}
			CameraRig.transform.localPosition = localPosition;
		}
		else
		{
			OVRPose? initialPose2 = InitialPose;
			if (initialPose2.HasValue)
			{
				CameraRig.transform.localPosition = InitialPose.Value.position;
				CameraRig.transform.localRotation = InitialPose.Value.orientation;
				InitialPose = null;
			}
		}
		CameraHeight = CameraRig.centerEyeAnchor.localPosition.y;
		if (this.CameraUpdated != null)
		{
			this.CameraUpdated();
		}
		UpdateMovement();
		Vector3 zero = Vector3.zero;
		float num = 1f + Damping * SimulationRate * Time.deltaTime;
		MoveThrottle.x /= num;
		MoveThrottle.y = ((!(MoveThrottle.y > 0f)) ? MoveThrottle.y : (MoveThrottle.y / num));
		MoveThrottle.z /= num;
		zero += MoveThrottle * SimulationRate * Time.deltaTime;
		if (Controller.isGrounded && FallSpeed <= 0f)
		{
			FallSpeed = Physics.gravity.y * (GravityModifier * 0.002f);
		}
		else
		{
			FallSpeed += Physics.gravity.y * (GravityModifier * 0.002f) * SimulationRate * Time.deltaTime;
		}
		zero.y += FallSpeed * SimulationRate * Time.deltaTime;
		if (Controller.isGrounded && MoveThrottle.y <= base.transform.lossyScale.y * 0.001f)
		{
			float num2 = Mathf.Max(Controller.stepOffset, new Vector3(zero.x, 0f, zero.z).magnitude);
			zero -= num2 * Vector3.up;
		}
		if (this.PreCharacterMove != null)
		{
			this.PreCharacterMove();
			Teleported = false;
		}
		Vector3 vector = Vector3.Scale(Controller.transform.localPosition + zero, new Vector3(1f, 0f, 1f));
		Controller.Move(zero);
		Vector3 vector2 = Vector3.Scale(Controller.transform.localPosition, new Vector3(1f, 0f, 1f));
		if (vector != vector2)
		{
			MoveThrottle += (vector2 - vector) / (SimulationRate * Time.deltaTime);
		}
	}

	public virtual void UpdateMovement()
	{
		if (HaltUpdateMovement)
		{
			return;
		}
		if (EnableLinearMovement)
		{
			bool flag = Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow);
			bool flag2 = Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow);
			bool flag3 = Input.GetKey(KeyCode.D) || Input.GetKey(KeyCode.RightArrow);
			bool flag4 = Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow);
			bool flag5 = false;
			if (OVRInput.Get(OVRInput.Button.DpadUp))
			{
				flag = true;
				flag5 = true;
			}
			if (OVRInput.Get(OVRInput.Button.DpadDown))
			{
				flag4 = true;
				flag5 = true;
			}
			MoveScale = 1f;
			if ((flag && flag2) || (flag && flag3) || (flag4 && flag2) || (flag4 && flag3))
			{
				MoveScale = 0.70710677f;
			}
			if (!Controller.isGrounded)
			{
				MoveScale = 0f;
			}
			MoveScale *= SimulationRate * Time.deltaTime;
			float num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			if (flag5 || Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
			{
				num *= 2f;
			}
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			eulerAngles.z = (eulerAngles.x = 0f);
			Quaternion quaternion = Quaternion.Euler(eulerAngles);
			if (flag)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.z * num * Vector3.forward);
			}
			if (flag4)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.z * num * BackAndSideDampen * Vector3.back);
			}
			if (flag2)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.left);
			}
			if (flag3)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.right);
			}
			num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
			if (FixedSpeedSteps > 0)
			{
				vector.y = Mathf.Round(vector.y * (float)FixedSpeedSteps) / (float)FixedSpeedSteps;
				vector.x = Mathf.Round(vector.x * (float)FixedSpeedSteps) / (float)FixedSpeedSteps;
			}
			if (vector.y > 0f)
			{
				MoveThrottle += quaternion * (vector.y * base.transform.lossyScale.z * num * Vector3.forward);
			}
			if (vector.y < 0f)
			{
				MoveThrottle += quaternion * (Mathf.Abs(vector.y) * base.transform.lossyScale.z * num * BackAndSideDampen * Vector3.back);
			}
			if (vector.x < 0f)
			{
				MoveThrottle += quaternion * (Mathf.Abs(vector.x) * base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.left);
			}
			if (vector.x > 0f)
			{
				MoveThrottle += quaternion * (vector.x * base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.right);
			}
		}
		if (!EnableRotation)
		{
			return;
		}
		Vector3 eulerAngles2 = base.transform.rotation.eulerAngles;
		float num2 = SimulationRate * Time.deltaTime * RotationAmount * RotationScaleMultiplier;
		bool flag6 = OVRInput.Get(OVRInput.Button.PrimaryShoulder);
		if (flag6 && !prevHatLeft)
		{
			eulerAngles2.y -= RotationRatchet;
		}
		prevHatLeft = flag6;
		bool flag7 = OVRInput.Get(OVRInput.Button.SecondaryShoulder);
		if (flag7 && !prevHatRight)
		{
			eulerAngles2.y += RotationRatchet;
		}
		prevHatRight = flag7;
		eulerAngles2.y += buttonRotation;
		buttonRotation = 0f;
		if (SnapRotation)
		{
			if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickLeft))
			{
				if (ReadyToSnapTurn)
				{
					eulerAngles2.y -= RotationRatchet;
					ReadyToSnapTurn = false;
				}
			}
			else if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickRight))
			{
				if (ReadyToSnapTurn)
				{
					eulerAngles2.y += RotationRatchet;
					ReadyToSnapTurn = false;
				}
			}
			else
			{
				ReadyToSnapTurn = true;
			}
		}
		else
		{
			eulerAngles2.y += OVRInput.Get(OVRInput.Axis2D.SecondaryThumbstick).x * num2;
		}
		base.transform.rotation = Quaternion.Euler(eulerAngles2);
	}

	public void UpdateTransform(OVRCameraRig rig)
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		if (HmdRotatesY && !Teleported)
		{
			Vector3 position = trackingSpace.position;
			Quaternion rotation = trackingSpace.rotation;
			base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
			trackingSpace.position = position;
			trackingSpace.rotation = rotation;
		}
		UpdateController();
		if (this.TransformUpdated != null)
		{
			this.TransformUpdated(trackingSpace);
		}
	}

	public bool Jump()
	{
		if (!Controller.isGrounded)
		{
			return false;
		}
		MoveThrottle += new Vector3(0f, base.transform.lossyScale.y * JumpForce, 0f);
		return true;
	}

	public void Stop()
	{
		Controller.Move(Vector3.zero);
		MoveThrottle = Vector3.zero;
		FallSpeed = 0f;
	}

	public void GetMoveScaleMultiplier(ref float moveScaleMultiplier)
	{
		moveScaleMultiplier = MoveScaleMultiplier;
	}

	public void SetMoveScaleMultiplier(float moveScaleMultiplier)
	{
		MoveScaleMultiplier = moveScaleMultiplier;
	}

	public void GetRotationScaleMultiplier(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplier;
	}

	public void SetRotationScaleMultiplier(float rotationScaleMultiplier)
	{
		RotationScaleMultiplier = rotationScaleMultiplier;
	}

	public void GetSkipMouseRotation(ref bool skipMouseRotation)
	{
		skipMouseRotation = SkipMouseRotation;
	}

	public void SetSkipMouseRotation(bool skipMouseRotation)
	{
		SkipMouseRotation = skipMouseRotation;
	}

	public void GetHaltUpdateMovement(ref bool haltUpdateMovement)
	{
		haltUpdateMovement = HaltUpdateMovement;
	}

	public void SetHaltUpdateMovement(bool haltUpdateMovement)
	{
		HaltUpdateMovement = haltUpdateMovement;
	}

	public void ResetOrientation()
	{
		if (HmdResetsY && !HmdRotatesY)
		{
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			eulerAngles.y = InitialYRotation;
			base.transform.rotation = Quaternion.Euler(eulerAngles);
		}
	}
}
namespace UnityEngine.EventSystems
{
	public class OVRPointerEventData : PointerEventData
	{
		public Ray worldSpaceRay;

		public Vector2 swipeStart;

		public OVRPointerEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("<b>Position</b>: " + base.position);
			stringBuilder.AppendLine("<b>delta</b>: " + base.delta);
			stringBuilder.AppendLine("<b>eligibleForClick</b>: " + base.eligibleForClick);
			stringBuilder.AppendLine("<b>pointerEnter</b>: " + base.pointerEnter);
			stringBuilder.AppendLine("<b>pointerPress</b>: " + base.pointerPress);
			stringBuilder.AppendLine("<b>lastPointerPress</b>: " + base.lastPress);
			stringBuilder.AppendLine("<b>pointerDrag</b>: " + base.pointerDrag);
			stringBuilder.AppendLine("<b>worldSpaceRay</b>: " + worldSpaceRay);
			stringBuilder.AppendLine("<b>swipeStart</b>: " + swipeStart);
			stringBuilder.AppendLine("<b>Use Drag Threshold</b>: " + base.useDragThreshold);
			return stringBuilder.ToString();
		}
	}
	public static class PointerEventDataExtension
	{
		public static bool IsVRPointer(this PointerEventData pointerEventData)
		{
			return pointerEventData is OVRPointerEventData;
		}

		public static Ray GetRay(this PointerEventData pointerEventData)
		{
			OVRPointerEventData oVRPointerEventData = pointerEventData as OVRPointerEventData;
			return oVRPointerEventData.worldSpaceRay;
		}

		public static Vector2 GetSwipeStart(this PointerEventData pointerEventData)
		{
			OVRPointerEventData oVRPointerEventData = pointerEventData as OVRPointerEventData;
			return oVRPointerEventData.swipeStart;
		}

		public static void SetSwipeStart(this PointerEventData pointerEventData, Vector2 start)
		{
			OVRPointerEventData oVRPointerEventData = pointerEventData as OVRPointerEventData;
			oVRPointerEventData.swipeStart = start;
		}
	}
}
public class OVRProgressIndicator : UnityEngine.MonoBehaviour
{
	public MeshRenderer progressImage;

	[Range(0f, 1f)]
	public float currentProgress = 0.7f;

	private void Awake()
	{
		progressImage.sortingOrder = 150;
	}

	private void Update()
	{
		progressImage.sharedMaterial.SetFloat("_AlphaCutoff", 1f - currentProgress);
	}
}
public class OVRRTOverlayConnector : UnityEngine.MonoBehaviour
{
	public int alphaBorderSizePixels = 3;

	private const int overlayRTChainSize = 3;

	private int overlayRTIndex;

	private IntPtr[] overlayTexturePtrs = new IntPtr[3];

	private RenderTexture[] overlayRTChain = new RenderTexture[3];

	public GameObject ovrOverlayObj;

	private RenderTexture srcRT;

	private Camera ownerCamera;

	private bool borderCleaned;

	public void RefreshRenderTextureChain()
	{
		srcRT = ownerCamera.targetTexture;
		ConstructRenderTextureChain();
	}

	private void ConstructRenderTextureChain()
	{
		for (int i = 0; i < 3; i++)
		{
			overlayRTChain[i] = new RenderTexture(srcRT.width, srcRT.height, 1, srcRT.format, RenderTextureReadWrite.sRGB);
			overlayRTChain[i].antiAliasing = 1;
			overlayRTChain[i].depth = 0;
			overlayRTChain[i].wrapMode = TextureWrapMode.Clamp;
			overlayRTChain[i].hideFlags = HideFlags.HideAndDontSave;
			overlayRTChain[i].Create();
			ref IntPtr reference = ref overlayTexturePtrs[i];
			reference = overlayRTChain[i].GetNativeTexturePtr();
		}
	}

	private void Start()
	{
		ownerCamera = GetComponent<Camera>();
		srcRT = ownerCamera.targetTexture;
		ConstructRenderTextureChain();
	}

	private void OnPreRender()
	{
		if (!borderCleaned)
		{
			GL.Clear(clearDepth: false, clearColor: true, new UnityEngine.Color(0f, 0f, 0f, 0f));
			GetComponent<Camera>().pixelRect = new Rect(alphaBorderSizePixels, alphaBorderSizePixels, srcRT.width - 2 * alphaBorderSizePixels, srcRT.height - 2 * alphaBorderSizePixels);
			borderCleaned = true;
		}
	}

	private void OnPostRender()
	{
		if ((bool)srcRT && ovrOverlayObj != null)
		{
			UnityEngine.Graphics.Blit(srcRT, overlayRTChain[overlayRTIndex]);
			OVROverlay component = ovrOverlayObj.GetComponent<OVROverlay>();
			component.OverrideOverlayTextureInfo(overlayRTChain[overlayRTIndex], overlayTexturePtrs[overlayRTIndex], VRNode.LeftEye);
			overlayRTIndex++;
			overlayRTIndex %= 3;
		}
	}
}
[RequireComponent(typeof(Canvas))]
public class OVRRaycaster : GraphicRaycaster, IPointerEnterHandler, IEventSystemHandler
{
	private struct RaycastHit
	{
		public Graphic graphic;

		public Vector3 worldPos;

		public bool fromMouse;
	}

	[Tooltip("A world space pointer for this canvas")]
	public GameObject pointer;

	public int sortOrder;

	[NonSerialized]
	private Canvas m_Canvas;

	[NonSerialized]
	private List<RaycastHit> m_RaycastResults = new List<RaycastHit>();

	[NonSerialized]
	private static readonly List<RaycastHit> s_SortedGraphics = new List<RaycastHit>();

	private Canvas canvas
	{
		get
		{
			if (m_Canvas != null)
			{
				return m_Canvas;
			}
			m_Canvas = GetComponent<Canvas>();
			return m_Canvas;
		}
	}

	public override Camera eventCamera => canvas.worldCamera;

	public override int sortOrderPriority => sortOrder;

	protected OVRRaycaster()
	{
	}

	private void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList, Ray ray, bool checkForBlocking)
	{
		if (canvas == null)
		{
			return;
		}
		float num = float.MaxValue;
		if (checkForBlocking && base.blockingObjects != 0)
		{
			float farClipPlane = eventCamera.farClipPlane;
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				UnityEngine.RaycastHit[] array = Physics.RaycastAll(ray, farClipPlane, m_BlockingMask);
				if (array.Length > 0 && array[0].distance < num)
				{
					num = array[0].distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D[] rayIntersectionAll = Physics2D.GetRayIntersectionAll(ray, farClipPlane, m_BlockingMask);
				if (rayIntersectionAll.Length > 0 && rayIntersectionAll[0].fraction * farClipPlane < num)
				{
					num = rayIntersectionAll[0].fraction * farClipPlane;
				}
			}
		}
		m_RaycastResults.Clear();
		GraphicRaycast(canvas, ray, m_RaycastResults);
		for (int i = 0; i < m_RaycastResults.Count; i++)
		{
			GameObject gameObject = m_RaycastResults[i].graphic.gameObject;
			bool flag = true;
			if (base.ignoreReversedGraphics)
			{
				Vector3 direction = ray.direction;
				Vector3 rhs = gameObject.transform.rotation * Vector3.forward;
				flag = Vector3.Dot(direction, rhs) > 0f;
			}
			if (eventCamera.transform.InverseTransformPoint(m_RaycastResults[i].worldPos).z <= 0f)
			{
				flag = false;
			}
			if (flag)
			{
				float num2 = Vector3.Distance(ray.origin, m_RaycastResults[i].worldPos);
				if (!(num2 >= num))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = gameObject;
					raycastResult.module = this;
					raycastResult.distance = num2;
					raycastResult.index = resultAppendList.Count;
					raycastResult.depth = m_RaycastResults[i].graphic.depth;
					raycastResult.worldPosition = m_RaycastResults[i].worldPos;
					RaycastResult item = raycastResult;
					resultAppendList.Add(item);
				}
			}
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (eventData.IsVRPointer())
		{
			Raycast(eventData, resultAppendList, eventData.GetRay(), checkForBlocking: true);
		}
	}

	public void RaycastPointer(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (pointer != null && pointer.activeInHierarchy)
		{
			Raycast(eventData, resultAppendList, new Ray(eventCamera.transform.position, (pointer.transform.position - eventCamera.transform.position).normalized), checkForBlocking: false);
		}
	}

	private void GraphicRaycast(Canvas canvas, Ray ray, List<RaycastHit> results)
	{
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		s_SortedGraphics.Clear();
		RaycastHit item = default(RaycastHit);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth != -1 && !(pointer == graphic.gameObject) && RayIntersectsRectTransform(graphic.rectTransform, ray, out var worldPos))
			{
				Vector2 sp = eventCamera.WorldToScreenPoint(worldPos);
				if (graphic.Raycast(sp, eventCamera))
				{
					item.graphic = graphic;
					item.worldPos = worldPos;
					item.fromMouse = false;
					s_SortedGraphics.Add(item);
				}
			}
		}
		s_SortedGraphics.Sort((RaycastHit g1, RaycastHit g2) => g2.graphic.depth.CompareTo(g1.graphic.depth));
		for (int j = 0; j < s_SortedGraphics.Count; j++)
		{
			results.Add(s_SortedGraphics[j]);
		}
	}

	public Vector2 GetScreenPosition(RaycastResult raycastResult)
	{
		return eventCamera.WorldToScreenPoint(raycastResult.worldPosition);
	}

	private static bool RayIntersectsRectTransform(RectTransform rectTransform, Ray ray, out Vector3 worldPos)
	{
		Vector3[] array = new Vector3[4];
		rectTransform.GetWorldCorners(array);
		if (!new Plane(array[0], array[1], array[2]).Raycast(ray, out var enter))
		{
			worldPos = Vector3.zero;
			return false;
		}
		Vector3 point = ray.GetPoint(enter);
		Vector3 vector = array[3] - array[0];
		Vector3 vector2 = array[1] - array[0];
		float num = Vector3.Dot(point - array[0], vector);
		float num2 = Vector3.Dot(point - array[0], vector2);
		if (num < vector.sqrMagnitude && num2 < vector2.sqrMagnitude && num >= 0f && num2 >= 0f)
		{
			worldPos = array[0] + num2 * vector2 / vector2.sqrMagnitude + num * vector / vector.sqrMagnitude;
			return true;
		}
		worldPos = Vector3.zero;
		return false;
	}

	public bool IsFocussed()
	{
		OVRInputModule oVRInputModule = EventSystem.current.currentInputModule as OVRInputModule;
		return (bool)oVRInputModule && oVRInputModule.activeGraphicRaycaster == this;
	}

	public void OnPointerEnter(PointerEventData e)
	{
		if (e.IsVRPointer())
		{
			OVRInputModule oVRInputModule = EventSystem.current.currentInputModule as OVRInputModule;
			oVRInputModule.activeGraphicRaycaster = this;
		}
	}
}
public class OVRResetOrientation : UnityEngine.MonoBehaviour
{
	public OVRInput.RawButton resetButton = OVRInput.RawButton.Y;

	private void Update()
	{
		if (OVRInput.GetDown(resetButton))
		{
			OVRManager.display.RecenterPose();
		}
	}
}
public class OVRSceneSampleController : UnityEngine.MonoBehaviour
{
	public KeyCode quitKey = KeyCode.Escape;

	public Texture fadeInTexture;

	public float speedRotationIncrement = 0.05f;

	private OVRPlayerController playerController;

	private OVRCameraRig cameraController;

	public string layerName = "Default";

	private bool visionMode = true;

	private OVRGridCube gridCube;

	private void Awake()
	{
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: More then 1 OVRCameraRig attached.");
		}
		else
		{
			cameraController = componentsInChildren[0];
		}
		OVRPlayerController[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<OVRPlayerController>();
		if (componentsInChildren2.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: No OVRPlayerController attached.");
		}
		else if (componentsInChildren2.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: More then 1 OVRPlayerController attached.");
		}
		else
		{
			playerController = componentsInChildren2[0];
		}
	}

	private void Start()
	{
		if (!UnityEngine.Application.isEditor)
		{
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
		}
		if (cameraController != null)
		{
			gridCube = base.gameObject.AddComponent<OVRGridCube>();
			gridCube.SetOVRCameraController(ref cameraController);
		}
	}

	private void Update()
	{
		UpdateRecenterPose();
		UpdateVisionMode();
		if (playerController != null)
		{
			UpdateSpeedAndRotationScaleMultiplier();
		}
		if (Input.GetKeyDown(KeyCode.F11))
		{
			Screen.fullScreen = !Screen.fullScreen;
		}
		if (Input.GetKeyDown(KeyCode.M))
		{
			VRSettings.showDeviceView = !VRSettings.showDeviceView;
		}
	}

	private void UpdateVisionMode()
	{
		if (Input.GetKeyDown(KeyCode.F2))
		{
			visionMode ^= visionMode;
			OVRManager.tracker.isEnabled = visionMode;
		}
	}

	private void UpdateSpeedAndRotationScaleMultiplier()
	{
		float moveScaleMultiplier = 0f;
		playerController.GetMoveScaleMultiplier(ref moveScaleMultiplier);
		if (Input.GetKeyDown(KeyCode.Alpha7))
		{
			moveScaleMultiplier -= speedRotationIncrement;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha8))
		{
			moveScaleMultiplier += speedRotationIncrement;
		}
		playerController.SetMoveScaleMultiplier(moveScaleMultiplier);
		float rotationScaleMultiplier = 0f;
		playerController.GetRotationScaleMultiplier(ref rotationScaleMultiplier);
		if (Input.GetKeyDown(KeyCode.Alpha9))
		{
			rotationScaleMultiplier -= speedRotationIncrement;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha0))
		{
			rotationScaleMultiplier += speedRotationIncrement;
		}
		playerController.SetRotationScaleMultiplier(rotationScaleMultiplier);
	}

	private void UpdateRecenterPose()
	{
		if (Input.GetKeyDown(KeyCode.R))
		{
			OVRManager.display.RecenterPose();
		}
	}
}
public class OVRScreenFade : UnityEngine.MonoBehaviour
{
	[Tooltip("Fade duration")]
	public float fadeTime = 2f;

	[Tooltip("Screen color at maximum fade")]
	public UnityEngine.Color fadeColor = new UnityEngine.Color(0.01f, 0.01f, 0.01f, 1f);

	public bool fadeOnStart = true;

	public int renderQueue = 5000;

	private float uiFadeAlpha;

	private MeshRenderer fadeRenderer;

	private MeshFilter fadeMesh;

	private Material fadeMaterial;

	private bool isFading;

	public float currentAlpha { get; private set; }

	private void Awake()
	{
		fadeMaterial = new Material(Shader.Find("Oculus/Unlit Transparent Color"));
		fadeMesh = base.gameObject.AddComponent<MeshFilter>();
		fadeRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMesh.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		ref Vector3 reference = ref array[0];
		reference = new Vector3(0f - num, 0f - num2, z);
		ref Vector3 reference2 = ref array[1];
		reference2 = new Vector3(num, 0f - num2, z);
		ref Vector3 reference3 = ref array[2];
		reference3 = new Vector3(0f - num, num2, z);
		ref Vector3 reference4 = ref array[3];
		reference4 = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
		SetFadeLevel(0f);
	}

	public void FadeOut()
	{
		StartCoroutine(Fade(0f, 1f));
	}

	private void OnLevelFinishedLoading(int level)
	{
		StartCoroutine(Fade(1f, 0f));
	}

	private void Start()
	{
		if (fadeOnStart)
		{
			StartCoroutine(Fade(1f, 0f));
		}
	}

	private void OnEnable()
	{
		if (!fadeOnStart)
		{
			SetFadeLevel(0f);
		}
	}

	private void OnDestroy()
	{
		if (fadeRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMesh != null)
		{
			UnityEngine.Object.Destroy(fadeMesh);
		}
	}

	public void SetUIFade(float level)
	{
		uiFadeAlpha = Mathf.Clamp01(level);
		SetMaterialAlpha();
	}

	public void SetFadeLevel(float level)
	{
		currentAlpha = level;
		SetMaterialAlpha();
	}

	private IEnumerator Fade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			currentAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		UnityEngine.Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, uiFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeRenderer.material = fadeMaterial;
			fadeRenderer.enabled = isFading;
		}
	}
}
public class OVRTrackedRemote : UnityEngine.MonoBehaviour
{
	public GameObject m_modelGearVrController;

	public GameObject m_modelOculusGoController;

	public OVRInput.Controller m_controller;

	private bool m_isOculusGo;

	private bool m_prevControllerConnected;

	private bool m_prevControllerConnectedCached;

	private void Start()
	{
		m_isOculusGo = OVRPlugin.productName == "Oculus Go";
	}

	private void Update()
	{
		bool flag = OVRInput.IsControllerConnected(m_controller);
		if (flag != m_prevControllerConnected || !m_prevControllerConnectedCached)
		{
			m_modelOculusGoController.SetActive(flag && m_isOculusGo);
			m_modelGearVrController.SetActive(flag && !m_isOculusGo);
			m_prevControllerConnected = flag;
			m_prevControllerConnectedCached = true;
		}
		if (flag)
		{
		}
	}
}
public class OVRWaitCursor : UnityEngine.MonoBehaviour
{
	public Vector3 rotateSpeeds = new Vector3(0f, 0f, -60f);

	private void Update()
	{
		base.transform.Rotate(rotateSpeeds * Time.smoothDeltaTime);
	}
}
namespace Oculus.Platform
{
	public enum AchievementType : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class AndroidPlatform
	{
		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return CAPI.ovr_UnityInitWrapper(appId);
		}
	}
}
public class BufferedAudioStream
{
	private const bool VerboseLogging = false;

	private AudioSource audio;

	private float[] audioBuffer;

	private int writePos;

	private const float bufferLengthSeconds = 0.25f;

	private const int sampleRate = 48000;

	private const int bufferSize = 12000;

	private const float playbackDelayTimeSeconds = 0.05f;

	private float playbackDelayRemaining;

	private float remainingBufferTime;

	public BufferedAudioStream(AudioSource audio)
	{
		audioBuffer = new float[12000];
		this.audio = audio;
		audio.loop = true;
		audio.clip = AudioClip.Create(string.Empty, 12000, 1, 48000, stream: false);
		Stop();
	}

	public void Update()
	{
		if (remainingBufferTime > 0f)
		{
			if (!audio.isPlaying && remainingBufferTime > 0.05f)
			{
				playbackDelayRemaining -= Time.deltaTime;
				if (playbackDelayRemaining <= 0f)
				{
					audio.Play();
				}
			}
			if (audio.isPlaying)
			{
				remainingBufferTime -= Time.deltaTime;
				if (remainingBufferTime < 0f)
				{
					remainingBufferTime = 0f;
				}
			}
		}
		if (remainingBufferTime <= 0f)
		{
			if (audio.isPlaying)
			{
				UnityEngine.Debug.Log("Buffer empty, stopping " + DateTime.Now);
				Stop();
			}
			else if (writePos != 0)
			{
				UnityEngine.Debug.LogError("writePos non zero while not playing, how did this happen?");
			}
		}
	}

	private void Stop()
	{
		audio.Stop();
		audio.time = 0f;
		writePos = 0;
		playbackDelayRemaining = 0.05f;
	}

	public void AddData(float[] samples)
	{
		int num = samples.Length;
		if (writePos > audioBuffer.Length)
		{
			throw new Exception();
		}
		do
		{
			int num2 = num;
			int num3 = audioBuffer.Length - writePos;
			if (num2 > num3)
			{
				num2 = num3;
			}
			Array.Copy(samples, 0, audioBuffer, writePos, num2);
			num -= num2;
			writePos += num2;
			if (writePos > audioBuffer.Length)
			{
				throw new Exception();
			}
			if (writePos == audioBuffer.Length)
			{
				writePos = 0;
			}
		}
		while (num > 0);
		remainingBufferTime += (float)samples.Length / 48000f;
		audio.clip.SetData(audioBuffer, 0);
	}
}
namespace Oculus.Platform
{
	public class CAPI
	{
		public struct ovrKeyValuePair
		{
			public string key_;

			private KeyValuePairType valueType_;

			public string stringValue_;

			public int intValue_;

			public double doubleValue_;

			public ovrKeyValuePair(string key, string value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.String;
				stringValue_ = value;
				intValue_ = 0;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, int value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Int;
				intValue_ = value;
				stringValue_ = null;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, double value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Double;
				doubleValue_ = value;
				stringValue_ = null;
				intValue_ = 0;
			}
		}

		public struct ovrMatchmakingCriterion
		{
			public string key_;

			public MatchmakingCriterionImportance importance_;

			public IntPtr parameterArray;

			public uint parameterArrayCount;

			public ovrMatchmakingCriterion(string key, MatchmakingCriterionImportance importance)
			{
				key_ = key;
				importance_ = importance;
				parameterArray = IntPtr.Zero;
				parameterArrayCount = 0u;
			}
		}

		public struct ovrMatchmakingCustomQueryData
		{
			public IntPtr dataArray;

			public uint dataArrayCount;

			public IntPtr criterionArray;

			public uint criterionArrayCount;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void FilterCallback([In][Out][MarshalAs(UnmanagedType.LPArray, SizeConst = 480)] short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels);

		public const string DLL_NAME = "ovrplatformloader";

		private static UTF8Encoding nativeStringEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public const int VoipFilterBufferSize = 480;

		public static IntPtr ArrayOfStructsToIntPtr(Array ar)
		{
			int num = 0;
			for (int i = 0; i < ar.Length; i++)
			{
				num += Marshal.SizeOf(ar.GetValue(i));
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			IntPtr intPtr2 = intPtr;
			for (int j = 0; j < ar.Length; j++)
			{
				Marshal.StructureToPtr(ar.GetValue(j), intPtr2, fDeleteOld: false);
				intPtr2 = (IntPtr)((long)intPtr2 + Marshal.SizeOf(ar.GetValue(j)));
			}
			return intPtr;
		}

		public static ovrKeyValuePair[] DictionaryToOVRKeyValuePairs(Dictionary<string, object> dict)
		{
			if (dict == null || dict.Count == 0)
			{
				return null;
			}
			ovrKeyValuePair[] array = new ovrKeyValuePair[dict.Count];
			int num = 0;
			foreach (KeyValuePair<string, object> item in dict)
			{
				if (item.Value.GetType() == typeof(int))
				{
					ref ovrKeyValuePair reference = ref array[num];
					reference = new ovrKeyValuePair(item.Key, (int)item.Value);
				}
				else if (item.Value.GetType() == typeof(string))
				{
					ref ovrKeyValuePair reference2 = ref array[num];
					reference2 = new ovrKeyValuePair(item.Key, (string)item.Value);
				}
				else
				{
					if (item.Value.GetType() != typeof(double))
					{
						throw new Exception("Only int, double or string are allowed types in CustomQuery.data");
					}
					ref ovrKeyValuePair reference3 = ref array[num];
					reference3 = new ovrKeyValuePair(item.Key, (double)item.Value);
				}
				num++;
			}
			return array;
		}

		public static byte[] IntPtrToByteArray(IntPtr data, ulong size)
		{
			byte[] array = new byte[size];
			Marshal.Copy(data, array, 0, (int)size);
			return array;
		}

		public static Dictionary<string, string> DataStoreFromNative(IntPtr pointer)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			int num = (int)(uint)ovr_DataStore_GetNumKeys(pointer);
			for (int i = 0; i < num; i++)
			{
				string key = ovr_DataStore_GetKey(pointer, i);
				dictionary[key] = ovr_DataStore_GetValue(pointer, key);
			}
			return dictionary;
		}

		public static string StringFromNative(IntPtr pointer)
		{
			if (pointer == IntPtr.Zero)
			{
				return null;
			}
			int nativeStringLengthNotIncludingNullTerminator = GetNativeStringLengthNotIncludingNullTerminator(pointer);
			byte[] array = new byte[nativeStringLengthNotIncludingNullTerminator];
			Marshal.Copy(pointer, array, 0, nativeStringLengthNotIncludingNullTerminator);
			return nativeStringEncoding.GetString(array);
		}

		public static int GetNativeStringLengthNotIncludingNullTerminator(IntPtr pointer)
		{
			int i;
			for (i = 0; Marshal.ReadByte(pointer, i) != 0; i++)
			{
			}
			return i;
		}

		public static DateTime DateTimeFromNative(ulong seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		public static byte[] BlobFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			for (int i = 0; i < (int)size; i++)
			{
				array[i] = Marshal.ReadByte(pointer, i);
			}
			return array;
		}

		public static byte[] FiledataFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			Marshal.Copy(pointer, array, 0, (int)size);
			return array;
		}

		public static IntPtr StringToNative(string s)
		{
			if (s == null)
			{
				throw new Exception("StringFromNative: null argument");
			}
			int byteCount = nativeStringEncoding.GetByteCount(s);
			byte[] array = new byte[byteCount + 1];
			nativeStringEncoding.GetBytes(s, 0, s.Length, array, 0);
			IntPtr intPtr = Marshal.AllocCoTaskMem(byteCount + 1);
			Marshal.Copy(array, 0, intPtr, byteCount + 1);
			return intPtr;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapper(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperStandalone(string accessToken, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperWindows(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SetDeveloperAccessToken(string accessToken);

		public static string ovr_GetLoggedInUserLocale()
		{
			return StringFromNative(ovr_GetLoggedInUserLocale_Native());
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GetLoggedInUserLocale")]
		private static extern IntPtr ovr_GetLoggedInUserLocale_Native();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PopMessage();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_FreeMessage(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_NetworkingPeer_GetSendPolicy(IntPtr networkingPeer);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateEncoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyEncoder(IntPtr encoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateDecoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyDecoder(IntPtr decoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, ulong compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Microphone_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Destroy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipPassthrough(bool passthrough);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipMicrophoneMuted(VoipMuteState muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityResetTestPlatform();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HTTP_GetWithMessageType(string url, int messageType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_CrashApplication();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallback(FilterCallback cb);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(FilterCallback cb, UIntPtr bufferSizeElements);

		public static void LogNewEvent(string eventName, Dictionary<string, string> values)
		{
			IntPtr intPtr = StringToNative(eventName);
			int num = values?.Count ?? 0;
			IntPtr[] array = new IntPtr[num * 2];
			if (num > 0)
			{
				int num2 = 0;
				foreach (KeyValuePair<string, string> value in values)
				{
					ref IntPtr reference = ref array[num2 * 2];
					reference = StringToNative(value.Key);
					ref IntPtr reference2 = ref array[num2 * 2 + 1];
					reference2 = StringToNative(value.Value);
					num2++;
				}
			}
			ovr_Log_NewEvent(intPtr, array, (UIntPtr)(ulong)num);
			Marshal.FreeCoTaskMem(intPtr);
			IntPtr[] array2 = array;
			foreach (IntPtr ptr in array2)
			{
				Marshal.FreeCoTaskMem(ptr);
			}
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Log_NewEvent(IntPtr eventName, IntPtr[] values, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationLifecycle_GetLaunchDetails();

		public static ulong ovr_HTTP_StartTransfer(string url, ovrKeyValuePair[] headers, UIntPtr count)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_StartTransfer_Native(intPtr, headers, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_StartTransfer")]
		private static extern ulong ovr_HTTP_StartTransfer_Native(IntPtr url, ovrKeyValuePair[] headers, UIntPtr count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HTTP_Write(ulong transferId, byte[] bytes, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_HTTP_WriteEOM(ulong transferId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Accept(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_AcceptForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Close(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_CloseForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Connect(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_IsConnected(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Net_Ping(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Net_ReadPacket();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacket(ulong userID, UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacketToCurrentRoom(UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Accept(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetOutputBufferMaxSize();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCM(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMSize(ulong senderID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Voip_GetSystemVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Voip_GetSystemVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneMuted(VoipMuteState state);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetOutputSampleRate(VoipSampleRate rate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Start(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Stop(ulong userID);

		public static ulong ovr_Achievements_AddCount(string name, ulong count)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_AddCount_Native(intPtr, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddCount")]
		private static extern ulong ovr_Achievements_AddCount_Native(IntPtr name, ulong count);

		public static ulong ovr_Achievements_AddFields(string name, string fields)
		{
			IntPtr intPtr = StringToNative(name);
			IntPtr intPtr2 = StringToNative(fields);
			ulong result = ovr_Achievements_AddFields_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddFields")]
		private static extern ulong ovr_Achievements_AddFields_Native(IntPtr name, IntPtr fields);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllDefinitions();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllProgress();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetDefinitionsByName(string[] names, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetProgressByName(string[] names, int count);

		public static ulong ovr_Achievements_Unlock(string name)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_Unlock_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_Unlock")]
		private static extern ulong ovr_Achievements_Unlock_Native(IntPtr name);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_ExecuteCoordinatedLaunch(ulong appID, ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetInstalledApplications();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetVersion();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetRegisteredPIDs();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetSessionKey();

		public static ulong ovr_ApplicationLifecycle_RegisterSessionKey(string sessionKey)
		{
			IntPtr intPtr = StringToNative(sessionKey);
			ulong result = ovr_ApplicationLifecycle_RegisterSessionKey_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationLifecycle_RegisterSessionKey")]
		private static extern ulong ovr_ApplicationLifecycle_RegisterSessionKey_Native(IntPtr sessionKey);

		public static ulong ovr_CloudStorage_Delete(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Delete_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Delete")]
		private static extern ulong ovr_CloudStorage_Delete_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_Load(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Load_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Load")]
		private static extern ulong ovr_CloudStorage_Load_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadBucketMetadata(string bucket)
		{
			IntPtr intPtr = StringToNative(bucket);
			ulong result = ovr_CloudStorage_LoadBucketMetadata_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadBucketMetadata")]
		private static extern ulong ovr_CloudStorage_LoadBucketMetadata_Native(IntPtr bucket);

		public static ulong ovr_CloudStorage_LoadConflictMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadConflictMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadConflictMetadata")]
		private static extern ulong ovr_CloudStorage_LoadConflictMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadHandle(string handle)
		{
			IntPtr intPtr = StringToNative(handle);
			ulong result = ovr_CloudStorage_LoadHandle_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadHandle")]
		private static extern ulong ovr_CloudStorage_LoadHandle_Native(IntPtr handle);

		public static ulong ovr_CloudStorage_LoadMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadMetadata")]
		private static extern ulong ovr_CloudStorage_LoadMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepLocal_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepLocal")]
		private static extern ulong ovr_CloudStorage_ResolveKeepLocal_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepRemote_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepRemote")]
		private static extern ulong ovr_CloudStorage_ResolveKeepRemote_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_Save(string bucket, string key, byte[] data, uint dataSize, long counter, string extraData)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(extraData);
			ulong result = ovr_CloudStorage_Save_Native(intPtr, intPtr2, data, dataSize, counter, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Save")]
		private static extern ulong ovr_CloudStorage_Save_Native(IntPtr bucket, IntPtr key, byte[] data, uint dataSize, long counter, IntPtr extraData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Entitlement_GetIsViewerEntitled();

		public static ulong ovr_GraphAPI_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Get")]
		private static extern ulong ovr_GraphAPI_Get_Native(IntPtr url);

		public static ulong ovr_GraphAPI_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Post")]
		private static extern ulong ovr_GraphAPI_Post_Native(IntPtr url);

		public static ulong ovr_HTTP_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Get")]
		private static extern ulong ovr_HTTP_Get_Native(IntPtr url);

		public static ulong ovr_HTTP_GetToFile(string url, string diskFile)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(diskFile);
			ulong result = ovr_HTTP_GetToFile_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_GetToFile")]
		private static extern ulong ovr_HTTP_GetToFile_Native(IntPtr url, IntPtr diskFile);

		public static ulong ovr_HTTP_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Post")]
		private static extern ulong ovr_HTTP_Post_Native(IntPtr url);

		public static ulong ovr_IAP_ConsumePurchase(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_ConsumePurchase_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_ConsumePurchase")]
		private static extern ulong ovr_IAP_ConsumePurchase_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetProductsBySKU(string[] skus, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchases();

		public static ulong ovr_IAP_LaunchCheckoutFlow(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_LaunchCheckoutFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_LaunchCheckoutFlow")]
		private static extern ulong ovr_IAP_LaunchCheckoutFlow_Native(IntPtr sku);

		public static ulong ovr_Leaderboard_GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntries_Native(intPtr, limit, filter, startAt);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntries")]
		private static extern ulong ovr_Leaderboard_GetEntries_Native(IntPtr leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt);

		public static ulong ovr_Leaderboard_GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntriesAfterRank_Native(intPtr, limit, afterRank);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntriesAfterRank")]
		private static extern ulong ovr_Leaderboard_GetEntriesAfterRank_Native(IntPtr leaderboardName, int limit, ulong afterRank);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetNextEntries(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetPreviousEntries(IntPtr handle);

		public static ulong ovr_Leaderboard_WriteEntry(string leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_WriteEntry_Native(intPtr, score, extraData, extraDataLength, forceUpdate);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_WriteEntry")]
		private static extern ulong ovr_Leaderboard_WriteEntry_Native(IntPtr leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_GetStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_PauseStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_ResumeStream();

		public static ulong ovr_Matchmaking_Browse(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse")]
		private static extern ulong ovr_Matchmaking_Browse_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Browse2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse2")]
		private static extern ulong ovr_Matchmaking_Browse2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Cancel(string pool, string requestHash)
		{
			IntPtr intPtr = StringToNative(pool);
			IntPtr intPtr2 = StringToNative(requestHash);
			ulong result = ovr_Matchmaking_Cancel_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Cancel")]
		private static extern ulong ovr_Matchmaking_Cancel_Native(IntPtr pool, IntPtr requestHash);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_Cancel2();

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom_Native(intPtr, maxUsers, subscribeToUpdates, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom2")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom_Native(intPtr, maxUsers, subscribeToUpdates);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom")]
		private static extern ulong ovr_Matchmaking_CreateRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_CreateRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom2")]
		private static extern ulong ovr_Matchmaking_CreateRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Enqueue(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue")]
		private static extern ulong ovr_Matchmaking_Enqueue_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Enqueue2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue2")]
		private static extern ulong ovr_Matchmaking_Enqueue2_Native(IntPtr pool, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom(ulong roomID, IntPtr customQueryData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom2(ulong roomID, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_GetAdminSnapshot();

		public static ulong ovr_Matchmaking_GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_GetStats_Native(intPtr, maxLevel, approach);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_GetStats")]
		private static extern ulong ovr_Matchmaking_GetStats_Native(IntPtr pool, uint maxLevel, MatchmakingStatApproach approach);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_JoinRoom(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_ReportResultInsecure(ulong roomID, ovrKeyValuePair[] data, uint numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_StartMatch(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_GetRoomInvites();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_MarkAsRead(ulong notificationID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GatherInApplication(ulong partyID, ulong appID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Get(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Invite(ulong partyID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Join(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Leave(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Get(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers2(IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetModeratedRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetSocialRooms(ulong appID);

		public static ulong ovr_Room_InviteUser(ulong roomID, string inviteToken)
		{
			IntPtr intPtr = StringToNative(inviteToken);
			ulong result = ovr_Room_InviteUser_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_InviteUser")]
		private static extern ulong ovr_Room_InviteUser_Native(ulong roomID, IntPtr inviteToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join2(ulong roomID, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_KickUser(ulong roomID, ulong userID, int kickDurationSeconds);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_LaunchInvitableUserFlow(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Leave(ulong roomID);

		public static ulong ovr_Room_SetDescription(ulong roomID, string description)
		{
			IntPtr intPtr = StringToNative(description);
			ulong result = ovr_Room_SetDescription_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_SetDescription")]
		private static extern ulong ovr_Room_SetDescription_Native(ulong roomID, IntPtr description);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateDataStore(ulong roomID, ovrKeyValuePair[] data, uint numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateOwner(ulong roomID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_Get(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetAccessToken();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriendsAndRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetOrgScopedID(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetUserProof();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewEntitledTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Voip_SetSystemVoipSuppressed(bool suppressed);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AchievementDefinition_GetBitfieldLength(IntPtr obj);

		public static string ovr_AchievementDefinition_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinition_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinition_GetName")]
		private static extern IntPtr ovr_AchievementDefinition_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementDefinition_GetTarget(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern AchievementType ovr_AchievementDefinition_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementDefinitionArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementDefinitionArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinitionArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinitionArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementDefinitionArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementDefinitionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementDefinitionArray_HasNextPage(IntPtr obj);

		public static string ovr_AchievementProgress_GetBitfield(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetBitfield_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetBitfield")]
		private static extern IntPtr ovr_AchievementProgress_GetBitfield_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementProgress_GetCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgress_GetIsUnlocked(IntPtr obj);

		public static string ovr_AchievementProgress_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetName")]
		private static extern IntPtr ovr_AchievementProgress_GetName_Native(IntPtr obj);

		public static DateTime ovr_AchievementProgress_GetUnlockTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_AchievementProgress_GetUnlockTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetUnlockTime")]
		private static extern ulong ovr_AchievementProgress_GetUnlockTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementProgressArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementProgressArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgressArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgressArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementProgressArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementProgressArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgressArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementUpdate_GetJustUnlocked(IntPtr obj);

		public static string ovr_AchievementUpdate_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementUpdate_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementUpdate_GetName")]
		private static extern IntPtr ovr_AchievementUpdate_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetCurrentCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetCurrentName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetCurrentName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetCurrentName")]
		private static extern IntPtr ovr_ApplicationVersion_GetCurrentName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetLatestCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetLatestName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetLatestName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetLatestName")]
		private static extern IntPtr ovr_ApplicationVersion_GetLatestName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetLocal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetRemote(IntPtr obj);

		public static string ovr_CloudStorageData_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetBucket")]
		private static extern IntPtr ovr_CloudStorageData_GetBucket_Native(IntPtr obj);

		public static byte[] ovr_CloudStorageData_GetData(IntPtr obj)
		{
			return FiledataFromNative(ovr_CloudStorageData_GetDataSize(obj), ovr_CloudStorageData_GetData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetData")]
		private static extern IntPtr ovr_CloudStorageData_GetData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageData_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageData_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetKey")]
		private static extern IntPtr ovr_CloudStorageData_GetKey_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetBucket")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetBucket_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_CloudStorageMetadata_GetCounter(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageMetadata_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetExtraData(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetExtraData")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetExtraData_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetKey")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorageMetadata_GetSaveTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageDataStatus ovr_CloudStorageMetadata_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetVersionHandle_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageMetadataArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_CloudStorageMetadataArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadataArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadataArray_GetNextUrl")]
		private static extern IntPtr ovr_CloudStorageMetadataArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CloudStorageMetadataArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_CloudStorageMetadataArray_HasNextPage(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetBucket")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetBucket_Native(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetKey")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageUpdateStatus ovr_CloudStorageUpdateResponse_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(IntPtr obj);

		public static uint ovr_DataStore_Contains(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			uint result = ovr_DataStore_Contains_Native(obj, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_Contains")]
		private static extern uint ovr_DataStore_Contains_Native(IntPtr obj, IntPtr key);

		public static string ovr_DataStore_GetKey(IntPtr obj, int index)
		{
			return StringFromNative(ovr_DataStore_GetKey_Native(obj, index));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetKey")]
		private static extern IntPtr ovr_DataStore_GetKey_Native(IntPtr obj, int index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DataStore_GetNumKeys(IntPtr obj);

		public static string ovr_DataStore_GetValue(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			string result = StringFromNative(ovr_DataStore_GetValue_Native(obj, intPtr));
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetValue")]
		private static extern IntPtr ovr_DataStore_GetValue_Native(IntPtr obj, IntPtr key);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetCode(IntPtr obj);

		public static string ovr_Error_GetDisplayableMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetDisplayableMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetDisplayableMessage")]
		private static extern IntPtr ovr_Error_GetDisplayableMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetHttpCode(IntPtr obj);

		public static string ovr_Error_GetMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetMessage")]
		private static extern IntPtr ovr_Error_GetMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_HttpTransferUpdate_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HttpTransferUpdate_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_HttpTransferUpdate_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HttpTransferUpdate_IsCompleted(IntPtr obj);

		public static string ovr_InstalledApplication_GetApplicationId(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetApplicationId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetApplicationId")]
		private static extern IntPtr ovr_InstalledApplication_GetApplicationId_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetPackageName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetPackageName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetPackageName")]
		private static extern IntPtr ovr_InstalledApplication_GetPackageName_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetStatus(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetStatus")]
		private static extern IntPtr ovr_InstalledApplication_GetStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_InstalledApplication_GetVersionCode(IntPtr obj);

		public static string ovr_InstalledApplication_GetVersionName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetVersionName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetVersionName")]
		private static extern IntPtr ovr_InstalledApplication_GetVersionName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_InstalledApplicationArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_InstalledApplicationArray_GetSize(IntPtr obj);

		public static string ovr_LaunchDetails_GetDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetDeeplinkMessage")]
		private static extern IntPtr ovr_LaunchDetails_GetDeeplinkMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LaunchType ovr_LaunchDetails_GetLaunchType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchDetails_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LaunchDetails_GetUsers(IntPtr obj);

		public static byte[] ovr_LeaderboardEntry_GetExtraData(IntPtr obj)
		{
			return BlobFromNative(ovr_LeaderboardEntry_GetExtraDataLength(obj), ovr_LeaderboardEntry_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetExtraData")]
		private static extern IntPtr ovr_LeaderboardEntry_GetExtraData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_LeaderboardEntry_GetExtraDataLength(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LeaderboardEntry_GetRank(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_LeaderboardEntry_GetScore(IntPtr obj);

		public static DateTime ovr_LeaderboardEntry_GetTimestamp(IntPtr obj)
		{
			return DateTimeFromNative(ovr_LeaderboardEntry_GetTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetTimestamp")]
		private static extern ulong ovr_LeaderboardEntry_GetTimestamp_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntry_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntryArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_LeaderboardEntryArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetNextUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetNextUrl_Native(IntPtr obj);

		public static string ovr_LeaderboardEntryArray_GetPreviousUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetPreviousUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetPreviousUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetPreviousUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LeaderboardEntryArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LeaderboardEntryArray_GetTotalCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasPreviousPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardUpdateStatus_GetDidUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetIsPaused(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetLivestreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetMicEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshot_GetCandidates(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(IntPtr obj);

		public static string ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingAdminSnapshotCandidate_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetRooms(IntPtr obj);

		public static string ovr_MatchmakingCandidate_GetEntryHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidate_GetEntryHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidate_GetEntryHash")]
		private static extern IntPtr ovr_MatchmakingCandidate_GetEntryHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingCandidate_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_MatchmakingCandidateArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidateArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidateArray_GetNextUrl")]
		private static extern IntPtr ovr_MatchmakingCandidateArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingCandidateArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResult_GetAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetAverageWait(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetPool(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetPool_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetPool")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetPool_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetRequestHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetRequestHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetRequestHash")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetRequestHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingEnqueuedUser_GetAdditionalUserID(IntPtr obj, uint index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueuedUser_GetAdditionalUserIDsSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetCustomData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUserArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingEnqueuedUserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingNotification_GetAddedByUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingNotification_GetRoom(IntPtr obj);

		public static string ovr_MatchmakingNotification_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingNotification_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingNotification_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingNotification_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingRoom_GetPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingRoom_HasPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoomArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetDrawCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetLossCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetSkillLevel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetWinCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementDefinitionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementProgressArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetApplicationVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageConflictMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadataArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageUpdateResponse(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetHttpTransferUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetInstalledApplicationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardEntryArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardUpdateStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingBrowseResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResultAndRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNativeMessage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetworkingPeer(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetOrgScopedID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetParty(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPidArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetProductArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchase(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchaseArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Message_GetRequestID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotificationArray(IntPtr obj);

		public static string ovr_Message_GetString(IntPtr obj)
		{
			return StringFromNative(ovr_Message_GetString_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetString")]
		private static extern IntPtr ovr_Message_GetString_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemVoipState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern Message.MessageType ovr_Message_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserAndRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserProof(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Message_IsError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetOutputBufferMaxSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCM(IntPtr obj, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCMFloat(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_ReadData(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_SetAcceptableRecordingDelayHint(IntPtr obj, UIntPtr delayMs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Start(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Stop(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetworkingPeer_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PeerConnectionState ovr_NetworkingPeer_GetState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_OrgScopedID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Packet_Free(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Packet_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Packet_GetSenderID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SendPolicy ovr_Packet_GetSendPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Packet_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetLeader(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyID_GetID(IntPtr obj);

		public static string ovr_Pid_GetId(IntPtr obj)
		{
			return StringFromNative(ovr_Pid_GetId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Pid_GetId")]
		private static extern IntPtr ovr_Pid_GetId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PidArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PidArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetPingTimeUsec(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PingResult_IsTimeout(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Price_GetAmountInHundredths(IntPtr obj);

		public static string ovr_Price_GetCurrency(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetCurrency_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetCurrency")]
		private static extern IntPtr ovr_Price_GetCurrency_Native(IntPtr obj);

		public static string ovr_Price_GetFormatted(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetFormatted_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetFormatted")]
		private static extern IntPtr ovr_Price_GetFormatted_Native(IntPtr obj);

		public static string ovr_Product_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetDescription")]
		private static extern IntPtr ovr_Product_GetDescription_Native(IntPtr obj);

		public static string ovr_Product_GetFormattedPrice(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetFormattedPrice_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetFormattedPrice")]
		private static extern IntPtr ovr_Product_GetFormattedPrice_Native(IntPtr obj);

		public static string ovr_Product_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetName")]
		private static extern IntPtr ovr_Product_GetName_Native(IntPtr obj);

		public static string ovr_Product_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetSKU")]
		private static extern IntPtr ovr_Product_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ProductArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_ProductArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_ProductArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ProductArray_GetNextUrl")]
		private static extern IntPtr ovr_ProductArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_ProductArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_ProductArray_HasNextPage(IntPtr obj);

		public static DateTime ovr_Purchase_GetExpirationTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetExpirationTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetExpirationTime")]
		private static extern ulong ovr_Purchase_GetExpirationTime_Native(IntPtr obj);

		public static DateTime ovr_Purchase_GetGrantTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetGrantTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetGrantTime")]
		private static extern ulong ovr_Purchase_GetGrantTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Purchase_GetPurchaseID(IntPtr obj);

		public static string ovr_Purchase_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Purchase_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetSKU")]
		private static extern IntPtr ovr_Purchase_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PurchaseArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_PurchaseArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_PurchaseArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PurchaseArray_GetNextUrl")]
		private static extern IntPtr ovr_PurchaseArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PurchaseArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PurchaseArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetApplicationID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetDataStore(IntPtr obj);

		public static string ovr_Room_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetDescription")]
		private static extern IntPtr ovr_Room_GetDescription_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Room_GetIsMembershipLocked(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinPolicy ovr_Room_GetJoinPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinability ovr_Room_GetJoinability(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetMatchedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetMaxUsers(IntPtr obj);

		public static string ovr_Room_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetName")]
		private static extern IntPtr ovr_Room_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetOwner(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomType ovr_Room_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetRoomID(IntPtr obj);

		public static DateTime ovr_RoomInviteNotification_GetSentTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_RoomInviteNotification_GetSentTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotification_GetSentTime")]
		private static extern ulong ovr_RoomInviteNotification_GetSentTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomInviteNotificationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomInviteNotificationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomInviteNotificationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotificationArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomInviteNotificationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomInviteNotificationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomInviteNotificationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_SystemVoipState_GetMicrophoneMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_SystemVoipState_GetStatus(IntPtr obj);

		public static string ovr_TestUser_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetAccessToken")]
		private static extern IntPtr ovr_TestUser_GetAccessToken_Native(IntPtr obj);

		public static string ovr_TestUser_GetFriendAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetFriendAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetFriendAccessToken")]
		private static extern IntPtr ovr_TestUser_GetFriendAccessToken_Native(IntPtr obj);

		public static string ovr_TestUser_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetUserAlias")]
		private static extern IntPtr ovr_TestUser_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetID(IntPtr obj);

		public static string ovr_User_GetImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetImageUrl")]
		private static extern IntPtr ovr_User_GetImageUrl_Native(IntPtr obj);

		public static string ovr_User_GetInviteToken(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetInviteToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetInviteToken")]
		private static extern IntPtr ovr_User_GetInviteToken_Native(IntPtr obj);

		public static string ovr_User_GetOculusID(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetOculusID_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetOculusID")]
		private static extern IntPtr ovr_User_GetOculusID_Native(IntPtr obj);

		public static string ovr_User_GetPresence(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresence_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresence")]
		private static extern IntPtr ovr_User_GetPresence_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UserPresenceStatus ovr_User_GetPresenceStatus(IntPtr obj);

		public static string ovr_User_GetSmallImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetSmallImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetSmallImageUrl")]
		private static extern IntPtr ovr_User_GetSmallImageUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserAndRoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserAndRoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserAndRoomArray_GetNextUrl")]
		private static extern IntPtr ovr_UserAndRoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserAndRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserAndRoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserArray_GetNextUrl")]
		private static extern IntPtr ovr_UserArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserArray_HasNextPage(IntPtr obj);

		public static string ovr_UserProof_GetNonce(IntPtr obj)
		{
			return StringFromNative(ovr_UserProof_GetNonce_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserProof_GetNonce")]
		private static extern IntPtr ovr_UserProof_GetNonce_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, UIntPtr compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipDecoder_GetDecodedPCM(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipEncoder_AddPCM(IntPtr obj, float[] inputData, uint inputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedData(IntPtr obj, byte[] outputBuffer, UIntPtr intputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedDataSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_Destroy(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetCreateRoomDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetCreateRoomDataStoreString")]
		private static extern void ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearCreateRoomDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(IntPtr handle, RoomJoinPolicy value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_AddEnqueueAdditionalUser(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(IntPtr handle, string key, int value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsInt")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(IntPtr handle, IntPtr key, int value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(IntPtr handle, string key, double value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(IntPtr handle, IntPtr key, double value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsString")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueDataSettings(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetEnqueueIsDebug(IntPtr handle, bool value);

		public static void ovr_MatchmakingOptions_SetEnqueueQueryKey(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueQueryKey")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_Destroy(IntPtr handle);

		public static void ovr_RoomOptions_SetDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_RoomOptions_SetDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomOptions_SetDataStoreString")]
		private static extern void ovr_RoomOptions_SetDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_ClearDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetOrdering(IntPtr handle, UserOrdering value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRoomId(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetTurnOffUpdates(IntPtr handle, bool value);
	}
	public static class Callback
	{
		private class RequestCallback
		{
			private Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Message<T>.Callback callback;

			public RequestCallback(Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Message msg)
			{
				if (callback != null)
				{
					if (!hasRegisteredRoomInviteNotificationHandler && msg.Type == Message.MessageType.Notification_Room_InviteAccepted)
					{
						pendingRoomInviteNotifications.Add(msg);
					}
					else if (msg is Message<T>)
					{
						callback((Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<ulong, RequestCallback> requestIDsToCallbacks = new Dictionary<ulong, RequestCallback>();

		private static Dictionary<Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Message.MessageType, RequestCallback>();

		private static bool hasRegisteredRoomInviteNotificationHandler = false;

		private static List<Message> pendingRoomInviteNotifications = new List<Message>();

		internal static void SetNotificationCallback<T>(Message.MessageType type, Message<T>.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback<T>(callback);
			if (type == Message.MessageType.Notification_Room_InviteAccepted)
			{
				FlushRoomInviteNotificationQueue();
			}
		}

		internal static void SetNotificationCallback(Message.MessageType type, Message.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback(callback);
		}

		internal static void OnComplete<T>(Request<T> request, Message<T>.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback<T>(callback);
		}

		internal static void OnComplete(Request request, Message.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback(callback);
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		private static void FlushRoomInviteNotificationQueue()
		{
			hasRegisteredRoomInviteNotificationHandler = true;
			foreach (Message pendingRoomInviteNotification in pendingRoomInviteNotifications)
			{
				HandleMessage(pendingRoomInviteNotification);
			}
			pendingRoomInviteNotifications.Clear();
		}

		private static void HandleMessage(Message msg)
		{
			if (requestIDsToCallbacks.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToCallbacks.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out value))
			{
				value.HandleMessage(msg);
			}
		}
	}
	public class CallbackRunner : UnityEngine.MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		[DllImport("ovrplatformloader")]
		private static extern void ovr_UnityResetTestPlatform();

		private void Awake()
		{
			CallbackRunner callbackRunner = UnityEngine.Object.FindObjectOfType<CallbackRunner>();
			if (callbackRunner != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnDestroy()
		{
		}
	}
	public enum CloudStorageDataStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("IN_SYNC")]
		InSync,
		[Description("NEEDS_DOWNLOAD")]
		NeedsDownload,
		[Description("REMOTE_DOWNLOADING")]
		RemoteDownloading,
		[Description("NEEDS_UPLOAD")]
		NeedsUpload,
		[Description("LOCAL_UPLOADING")]
		LocalUploading,
		[Description("IN_CONFLICT")]
		InConflict
	}
	public enum CloudStorageUpdateStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OK")]
		Ok,
		[Description("BETTER_VERSION_STORED")]
		BetterVersionStored,
		[Description("MANUAL_MERGE_REQUIRED")]
		ManualMergeRequired
	}
	public interface IVoipPCMSource
	{
		int GetPCM(float[] dest, int length);

		void SetSenderID(ulong senderID);

		void Update();

		int PeekSizeElements();
	}
	public enum KeyValuePairType : uint
	{
		[Description("STRING")]
		String,
		[Description("INTEGER")]
		Int,
		[Description("DOUBLE")]
		Double,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LaunchType : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NORMAL")]
		Normal,
		[Description("INVITE")]
		Invite,
		[Description("COORDINATED")]
		Coordinated,
		[Description("DEEPLINK")]
		Deeplink
	}
	public enum LeaderboardFilterType : uint
	{
		[Description("NONE")]
		None,
		[Description("FRIENDS")]
		Friends,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LeaderboardStartAt : uint
	{
		[Description("TOP")]
		Top,
		[Description("CENTERED_ON_VIEWER")]
		CenteredOnViewer,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum MatchmakingCriterionImportance : uint
	{
		[Description("REQUIRED")]
		Required,
		[Description("HIGH")]
		High,
		[Description("MEDIUM")]
		Medium,
		[Description("LOW")]
		Low,
		[Description("UNKNOWN")]
		Unknown
	}
	public class MatchmakingOptions
	{
		private IntPtr Handle;

		public MatchmakingOptions()
		{
			Handle = CAPI.ovr_MatchmakingOptions_Create();
		}

		public void SetCreateRoomDataStore(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomDataStoreString(Handle, key, value);
		}

		public void ClearCreateRoomDataStore()
		{
			CAPI.ovr_MatchmakingOptions_ClearCreateRoomDataStore(Handle);
		}

		public void SetCreateRoomJoinPolicy(RoomJoinPolicy value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(Handle, value);
		}

		public void SetCreateRoomMaxUsers(uint value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomMaxUsers(Handle, value);
		}

		public void AddEnqueueAdditionalUser(ulong userID)
		{
			CAPI.ovr_MatchmakingOptions_AddEnqueueAdditionalUser(Handle, userID);
		}

		public void ClearEnqueueAdditionalUsers()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(Handle);
		}

		public void SetEnqueueDataSettings(string key, int value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, double value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsString(Handle, key, value);
		}

		public void ClearEnqueueDataSettings()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueDataSettings(Handle);
		}

		public void SetEnqueueIsDebug(bool value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueIsDebug(Handle, value);
		}

		public void SetEnqueueQueryKey(string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueQueryKey(Handle, value);
		}

		public static explicit operator IntPtr(MatchmakingOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~MatchmakingOptions()
		{
			CAPI.ovr_MatchmakingOptions_Destroy(Handle);
		}
	}
	public enum MatchmakingStatApproach : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("TRAILING")]
		Trailing,
		[Description("SWINGY")]
		Swingy
	}
	public abstract class Message<T> : Message
	{
		public new delegate void Callback(Message<T> message);

		private T data;

		public T Data => data;

		public Message(IntPtr c_message)
			: base(c_message)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(c_message);
			}
		}

		protected abstract T GetDataFromMessage(IntPtr c_message);
	}
	public class Message
	{
		public delegate void Callback(Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			ApplicationLifecycle_GetRegisteredPIDs = 82169698u,
			ApplicationLifecycle_GetSessionKey = 984570141u,
			ApplicationLifecycle_RegisterSessionKey = 1303818232u,
			Application_GetVersion = 1751583246u,
			CloudStorage_Delete = 685393261u,
			CloudStorage_GetNextCloudStorageMetadataArrayPage = 1544004335u,
			CloudStorage_Load = 1082420033u,
			CloudStorage_LoadBucketMetadata = 1931977997u,
			CloudStorage_LoadConflictMetadata = 1146770162u,
			CloudStorage_LoadHandle = 845863478u,
			CloudStorage_LoadMetadata = 65446546u,
			CloudStorage_ResolveKeepLocal = 811109637u,
			CloudStorage_ResolveKeepRemote = 1965400838u,
			CloudStorage_Save = 1270570030u,
			Entitlement_GetIsViewerEntitled = 409688241u,
			IAP_ConsumePurchase = 532378329u,
			IAP_GetNextProductArrayPage = 467225263u,
			IAP_GetNextPurchaseArrayPage = 1196886677u,
			IAP_GetProductsBySKU = 2124073717u,
			IAP_GetViewerPurchases = 974095385u,
			IAP_LaunchCheckoutFlow = 1067126029u,
			Leaderboard_GetEntries = 1572030284u,
			Leaderboard_GetEntriesAfterRank = 406293487u,
			Leaderboard_GetNextEntries = 1310751961u,
			Leaderboard_GetPreviousEntries = 1224858304u,
			Leaderboard_WriteEntry = 293587198u,
			Livestreaming_GetStatus = 1218079125u,
			Livestreaming_PauseStream = 916223619u,
			Livestreaming_ResumeStream = 575827343u,
			Matchmaking_Browse = 509948616u,
			Matchmaking_Browse2 = 1715641947u,
			Matchmaking_Cancel = 543705519u,
			Matchmaking_Cancel2 = 285117908u,
			Matchmaking_CreateAndEnqueueRoom = 1615617480u,
			Matchmaking_CreateAndEnqueueRoom2 = 693889755u,
			Matchmaking_CreateRoom = 54203178u,
			Matchmaking_CreateRoom2 = 1231922052u,
			Matchmaking_Enqueue = 1086418033u,
			Matchmaking_Enqueue2 = 303174325u,
			Matchmaking_EnqueueRoom = 1888108644u,
			Matchmaking_EnqueueRoom2 = 1428741028u,
			Matchmaking_GetAdminSnapshot = 1008820116u,
			Matchmaking_GetStats = 1123849272u,
			Matchmaking_JoinRoom = 1295177725u,
			Matchmaking_ReportResultInsecure = 439800205u,
			Matchmaking_StartMatch = 1154746693u,
			Notification_GetNextRoomInviteNotificationArrayPage = 102890359u,
			Notification_GetRoomInvites = 1871801234u,
			Notification_MarkAsRead = 1903319523u,
			Party_GetCurrent = 1200830304u,
			Room_CreateAndJoinPrivate = 1977017207u,
			Room_CreateAndJoinPrivate2 = 1513775683u,
			Room_Get = 1704628152u,
			Room_GetCurrent = 161916164u,
			Room_GetCurrentForUser = 234887141u,
			Room_GetInvitableUsers = 506615698u,
			Room_GetInvitableUsers2 = 1330899120u,
			Room_GetModeratedRooms = 159645047u,
			Room_GetNextRoomArrayPage = 1317239238u,
			Room_InviteUser = 1093266451u,
			Room_Join = 382373641u,
			Room_Join2 = 1303059522u,
			Room_KickUser = 1233344310u,
			Room_LaunchInvitableUserFlow = 843047539u,
			Room_Leave = 1916281973u,
			Room_SetDescription = 809796911u,
			Room_UpdateDataStore = 40779816u,
			Room_UpdateMembershipLockStatus = 923514796u,
			Room_UpdateOwner = 850803997u,
			Room_UpdatePrivateRoomJoinPolicy = 289473179u,
			User_Get = 1808768583u,
			User_GetAccessToken = 111696574u,
			User_GetLoggedInUser = 1131361373u,
			User_GetLoggedInUserFriends = 1484532365u,
			User_GetLoggedInUserFriendsAndRooms = 1585908615u,
			User_GetNextUserAndRoomArrayPage = 2143146719u,
			User_GetNextUserArrayPage = 645723971u,
			User_GetOrgScopedID = 418426907u,
			User_GetUserProof = 578880643u,
			Voip_SetSystemVoipSuppressed = 1161808298u,
			Notification_HTTP_Transfer = 2111073839u,
			Notification_Livestreaming_StatusChange = 575101294u,
			Notification_Matchmaking_MatchFound = 197393623u,
			Notification_Networking_ConnectionStateChange = 1577243802u,
			Notification_Networking_PeerConnectRequest = 1295114959u,
			Notification_Networking_PingResult = 1360343058u,
			Notification_Room_InviteAccepted = 1829794225u,
			Notification_Room_RoomUpdate = 1626094639u,
			Notification_Voip_ConnectRequest = 908343318u,
			Notification_Voip_StateChange = 888120928u,
			Notification_Voip_SystemVoipState = 1490179237u
		}

		internal delegate Message ExtraMessageTypesHandler(IntPtr messageHandle, MessageType message_type);

		private MessageType type;

		private ulong requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public ulong RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Message(IntPtr c_message)
		{
			type = CAPI.ovr_Message_GetType(c_message);
			bool flag = CAPI.ovr_Message_IsError(c_message);
			requestID = CAPI.ovr_Message_GetRequestID(c_message);
			if (flag)
			{
				IntPtr obj = CAPI.ovr_Message_GetError(c_message);
				error = new Error(CAPI.ovr_Error_GetCode(obj), CAPI.ovr_Error_GetMessage(obj), CAPI.ovr_Error_GetHttpCode(obj));
			}
			else if (Core.LogMessages)
			{
				string text = CAPI.ovr_Message_GetString(c_message);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {c_message}");
				}
			}
		}

		~Message()
		{
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual PingResult GetPingResult()
		{
			return null;
		}

		public virtual Oculus.Platform.Models.NetworkingPeer GetNetworkingPeer()
		{
			return null;
		}

		public virtual HttpTransferUpdate GetHttpTransferUpdate()
		{
			return null;
		}

		public virtual AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual ApplicationVersion GetApplicationVersion()
		{
			return null;
		}

		public virtual CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return null;
		}

		public virtual CloudStorageData GetCloudStorageData()
		{
			return null;
		}

		public virtual CloudStorageMetadata GetCloudStorageMetadata()
		{
			return null;
		}

		public virtual CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return null;
		}

		public virtual CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return null;
		}

		public virtual InstalledApplicationList GetInstalledApplicationList()
		{
			return null;
		}

		public virtual bool GetLeaderboardDidUpdate()
		{
			return false;
		}

		public virtual LeaderboardEntryList GetLeaderboardEntryList()
		{
			return null;
		}

		public virtual LivestreamingStatus GetLivestreamingStatus()
		{
			return null;
		}

		public virtual MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return null;
		}

		public virtual MatchmakingBrowseResult GetMatchmakingBrowseResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return null;
		}

		public virtual MatchmakingStats GetMatchmakingStats()
		{
			return null;
		}

		public virtual OrgScopedID GetOrgScopedID()
		{
			return null;
		}

		public virtual Party GetParty()
		{
			return null;
		}

		public virtual PidList GetPidList()
		{
			return null;
		}

		public virtual ProductList GetProductList()
		{
			return null;
		}

		public virtual Purchase GetPurchase()
		{
			return null;
		}

		public virtual PurchaseList GetPurchaseList()
		{
			return null;
		}

		public virtual Oculus.Platform.Models.Room GetRoom()
		{
			return null;
		}

		public virtual RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return null;
		}

		public virtual RoomList GetRoomList()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		public virtual SystemVoipState GetSystemVoipState()
		{
			return null;
		}

		public virtual User GetUser()
		{
			return null;
		}

		public virtual UserAndRoomList GetUserAndRoomList()
		{
			return null;
		}

		public virtual UserList GetUserList()
		{
			return null;
		}

		public virtual UserProof GetUserProof()
		{
			return null;
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle)
		{
			if (messageHandle.ToInt64() == 0)
			{
				return null;
			}
			Message message = null;
			MessageType messageType = CAPI.ovr_Message_GetType(messageHandle);
			switch (messageType)
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				message = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				message = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				message = new MessageWithAchievementUpdate(messageHandle);
				break;
			case MessageType.Application_GetVersion:
				message = new MessageWithApplicationVersion(messageHandle);
				break;
			case MessageType.CloudStorage_LoadConflictMetadata:
				message = new MessageWithCloudStorageConflictMetadata(messageHandle);
				break;
			case MessageType.CloudStorage_LoadHandle:
			case MessageType.CloudStorage_Load:
				message = new MessageWithCloudStorageData(messageHandle);
				break;
			case MessageType.CloudStorage_LoadMetadata:
				message = new MessageWithCloudStorageMetadataUnderLocal(messageHandle);
				break;
			case MessageType.CloudStorage_GetNextCloudStorageMetadataArrayPage:
			case MessageType.CloudStorage_LoadBucketMetadata:
				message = new MessageWithCloudStorageMetadataList(messageHandle);
				break;
			case MessageType.CloudStorage_Delete:
			case MessageType.CloudStorage_ResolveKeepLocal:
			case MessageType.CloudStorage_Save:
			case MessageType.CloudStorage_ResolveKeepRemote:
				message = new MessageWithCloudStorageUpdateResponse(messageHandle);
				break;
			case MessageType.Matchmaking_Cancel2:
			case MessageType.Entitlement_GetIsViewerEntitled:
			case MessageType.Matchmaking_ReportResultInsecure:
			case MessageType.IAP_ConsumePurchase:
			case MessageType.Matchmaking_Cancel:
			case MessageType.Room_LaunchInvitableUserFlow:
			case MessageType.Room_UpdateOwner:
			case MessageType.Matchmaking_StartMatch:
			case MessageType.ApplicationLifecycle_RegisterSessionKey:
			case MessageType.Notification_MarkAsRead:
				message = new Message(messageHandle);
				break;
			case MessageType.Leaderboard_GetEntriesAfterRank:
			case MessageType.Leaderboard_GetPreviousEntries:
			case MessageType.Leaderboard_GetNextEntries:
			case MessageType.Leaderboard_GetEntries:
				message = new MessageWithLeaderboardEntryList(messageHandle);
				break;
			case MessageType.Leaderboard_WriteEntry:
				message = new MessageWithLeaderboardDidUpdate(messageHandle);
				break;
			case MessageType.Notification_Livestreaming_StatusChange:
			case MessageType.Livestreaming_ResumeStream:
			case MessageType.Livestreaming_PauseStream:
			case MessageType.Livestreaming_GetStatus:
				message = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageType.Matchmaking_GetAdminSnapshot:
				message = new MessageWithMatchmakingAdminSnapshot(messageHandle);
				break;
			case MessageType.Matchmaking_Browse:
			case MessageType.Matchmaking_Browse2:
				message = new MessageWithMatchmakingBrowseResult(messageHandle);
				break;
			case MessageType.Matchmaking_Enqueue2:
			case MessageType.Matchmaking_Enqueue:
			case MessageType.Matchmaking_EnqueueRoom2:
			case MessageType.Matchmaking_EnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResult(messageHandle);
				break;
			case MessageType.Matchmaking_CreateAndEnqueueRoom2:
			case MessageType.Matchmaking_CreateAndEnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResultAndRoom(messageHandle);
				break;
			case MessageType.Matchmaking_GetStats:
				message = new MessageWithMatchmakingStatsUnderMatchmakingStats(messageHandle);
				break;
			case MessageType.User_GetOrgScopedID:
				message = new MessageWithOrgScopedID(messageHandle);
				break;
			case MessageType.Party_GetCurrent:
				message = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageType.ApplicationLifecycle_GetRegisteredPIDs:
				message = new MessageWithPidList(messageHandle);
				break;
			case MessageType.IAP_GetNextProductArrayPage:
			case MessageType.IAP_GetProductsBySKU:
				message = new MessageWithProductList(messageHandle);
				break;
			case MessageType.IAP_LaunchCheckoutFlow:
				message = new MessageWithPurchase(messageHandle);
				break;
			case MessageType.IAP_GetViewerPurchases:
			case MessageType.IAP_GetNextPurchaseArrayPage:
				message = new MessageWithPurchaseList(messageHandle);
				break;
			case MessageType.Room_Get:
				message = new MessageWithRoom(messageHandle);
				break;
			case MessageType.Room_GetCurrent:
			case MessageType.Room_GetCurrentForUser:
				message = new MessageWithRoomUnderCurrentRoom(messageHandle);
				break;
			case MessageType.Room_UpdateDataStore:
			case MessageType.Matchmaking_CreateRoom:
			case MessageType.Room_UpdatePrivateRoomJoinPolicy:
			case MessageType.Room_Join:
			case MessageType.Room_SetDescription:
			case MessageType.Room_UpdateMembershipLockStatus:
			case MessageType.Room_InviteUser:
			case MessageType.Matchmaking_CreateRoom2:
			case MessageType.Room_KickUser:
			case MessageType.Matchmaking_JoinRoom:
			case MessageType.Room_Join2:
			case MessageType.Room_CreateAndJoinPrivate2:
			case MessageType.Notification_Room_RoomUpdate:
			case MessageType.Room_Leave:
			case MessageType.Room_CreateAndJoinPrivate:
				message = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageType.Room_GetModeratedRooms:
			case MessageType.Room_GetNextRoomArrayPage:
				message = new MessageWithRoomList(messageHandle);
				break;
			case MessageType.Notification_GetNextRoomInviteNotificationArrayPage:
			case MessageType.Notification_GetRoomInvites:
				message = new MessageWithRoomInviteNotificationList(messageHandle);
				break;
			case MessageType.User_GetAccessToken:
			case MessageType.ApplicationLifecycle_GetSessionKey:
			case MessageType.Notification_Room_InviteAccepted:
				message = new MessageWithString(messageHandle);
				break;
			case MessageType.Voip_SetSystemVoipSuppressed:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.User_GetLoggedInUser:
			case MessageType.User_Get:
				message = new MessageWithUser(messageHandle);
				break;
			case MessageType.User_GetLoggedInUserFriendsAndRooms:
			case MessageType.User_GetNextUserAndRoomArrayPage:
				message = new MessageWithUserAndRoomList(messageHandle);
				break;
			case MessageType.Room_GetInvitableUsers:
			case MessageType.User_GetNextUserArrayPage:
			case MessageType.Room_GetInvitableUsers2:
			case MessageType.User_GetLoggedInUserFriends:
				message = new MessageWithUserList(messageHandle);
				break;
			case MessageType.User_GetUserProof:
				message = new MessageWithUserProof(messageHandle);
				break;
			case MessageType.Notification_Networking_PeerConnectRequest:
			case MessageType.Notification_Networking_ConnectionStateChange:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Networking_PingResult:
				message = new MessageWithPingResult(messageHandle);
				break;
			case MessageType.Notification_Matchmaking_MatchFound:
				message = new MessageWithMatchmakingNotification(messageHandle);
				break;
			case MessageType.Notification_Voip_StateChange:
			case MessageType.Notification_Voip_ConnectRequest:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Voip_SystemVoipState:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.Notification_HTTP_Transfer:
				message = new MessageWithHttpTransferUpdate(messageHandle);
				break;
			default:
				message = PlatformInternal.ParseMessageHandle(messageHandle, messageType);
				if (message == null)
				{
					UnityEngine.Debug.LogError($"Unrecognized message type {messageType}\n");
				}
				break;
			}
			return message;
		}

		public static Message PopMessage()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_PopMessage();
			Message result = ParseMessageHandle(intPtr);
			CAPI.ovr_FreeMessage(intPtr);
			return result;
		}
	}
	public class MessageWithAchievementDefinitions : Message<AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override AchievementDefinitionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementDefinitionArray(obj);
			return new AchievementDefinitionList(a);
		}
	}
	public class MessageWithAchievementProgressList : Message<AchievementProgressList>
	{
		public MessageWithAchievementProgressList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override AchievementProgressList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementProgressArray(obj);
			return new AchievementProgressList(a);
		}
	}
	public class MessageWithAchievementUpdate : Message<AchievementUpdate>
	{
		public MessageWithAchievementUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override AchievementUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAchievementUpdate(obj);
			return new AchievementUpdate(o);
		}
	}
	public class MessageWithApplicationVersion : Message<ApplicationVersion>
	{
		public MessageWithApplicationVersion(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ApplicationVersion GetApplicationVersion()
		{
			return base.Data;
		}

		protected override ApplicationVersion GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetApplicationVersion(obj);
			return new ApplicationVersion(o);
		}
	}
	public class MessageWithCloudStorageConflictMetadata : Message<CloudStorageConflictMetadata>
	{
		public MessageWithCloudStorageConflictMetadata(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageConflictMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageConflictMetadata(obj);
			return new CloudStorageConflictMetadata(o);
		}
	}
	public class MessageWithCloudStorageData : Message<CloudStorageData>
	{
		public MessageWithCloudStorageData(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageData GetCloudStorageData()
		{
			return base.Data;
		}

		protected override CloudStorageData GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageData(obj);
			return new CloudStorageData(o);
		}
	}
	public class MessageWithCloudStorageMetadataUnderLocal : Message<CloudStorageMetadata>
	{
		public MessageWithCloudStorageMetadataUnderLocal(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadata GetCloudStorageMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageMetadata(obj);
			return new CloudStorageMetadata(o);
		}
	}
	public class MessageWithCloudStorageMetadataList : Message<CloudStorageMetadataList>
	{
		public MessageWithCloudStorageMetadataList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return base.Data;
		}

		protected override CloudStorageMetadataList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCloudStorageMetadataArray(obj);
			return new CloudStorageMetadataList(a);
		}
	}
	public class MessageWithCloudStorageUpdateResponse : Message<CloudStorageUpdateResponse>
	{
		public MessageWithCloudStorageUpdateResponse(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return base.Data;
		}

		protected override CloudStorageUpdateResponse GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageUpdateResponse(obj);
			return new CloudStorageUpdateResponse(o);
		}
	}
	public class MessageWithInstalledApplicationList : Message<InstalledApplicationList>
	{
		public MessageWithInstalledApplicationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override InstalledApplicationList GetInstalledApplicationList()
		{
			return base.Data;
		}

		protected override InstalledApplicationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetInstalledApplicationArray(obj);
			return new InstalledApplicationList(a);
		}
	}
	public class MessageWithLeaderboardEntryList : Message<LeaderboardEntryList>
	{
		public MessageWithLeaderboardEntryList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LeaderboardEntryList GetLeaderboardEntryList()
		{
			return base.Data;
		}

		protected override LeaderboardEntryList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLeaderboardEntryArray(obj);
			return new LeaderboardEntryList(a);
		}
	}
	public class MessageWithLivestreamingStatus : Message<LivestreamingStatus>
	{
		public MessageWithLivestreamingStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStatus GetLivestreamingStatus()
		{
			return base.Data;
		}

		protected override LivestreamingStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStatus(obj);
			return new LivestreamingStatus(o);
		}
	}
	public class MessageWithMatchmakingAdminSnapshot : Message<MatchmakingAdminSnapshot>
	{
		public MessageWithMatchmakingAdminSnapshot(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return base.Data;
		}

		protected override MatchmakingAdminSnapshot GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingAdminSnapshot(obj);
			return new MatchmakingAdminSnapshot(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResult : Message<MatchmakingEnqueueResult>
	{
		public MessageWithMatchmakingEnqueueResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResult(obj);
			return new MatchmakingEnqueueResult(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResultAndRoom : Message<MatchmakingEnqueueResultAndRoom>
	{
		public MessageWithMatchmakingEnqueueResultAndRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResultAndRoom GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResultAndRoom(obj);
			return new MatchmakingEnqueueResultAndRoom(o);
		}
	}
	public class MessageWithMatchmakingStatsUnderMatchmakingStats : Message<MatchmakingStats>
	{
		public MessageWithMatchmakingStatsUnderMatchmakingStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingStats GetMatchmakingStats()
		{
			return base.Data;
		}

		protected override MatchmakingStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingStats(obj);
			return new MatchmakingStats(o);
		}
	}
	public class MessageWithOrgScopedID : Message<OrgScopedID>
	{
		public MessageWithOrgScopedID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override OrgScopedID GetOrgScopedID()
		{
			return base.Data;
		}

		protected override OrgScopedID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetOrgScopedID(obj);
			return new OrgScopedID(o);
		}
	}
	public class MessageWithParty : Message<Party>
	{
		public MessageWithParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPartyUnderCurrentParty : Message<Party>
	{
		public MessageWithPartyUnderCurrentParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPidList : Message<PidList>
	{
		public MessageWithPidList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PidList GetPidList()
		{
			return base.Data;
		}

		protected override PidList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPidArray(obj);
			return new PidList(a);
		}
	}
	public class MessageWithProductList : Message<ProductList>
	{
		public MessageWithProductList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ProductList GetProductList()
		{
			return base.Data;
		}

		protected override ProductList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetProductArray(obj);
			return new ProductList(a);
		}
	}
	public class MessageWithPurchase : Message<Purchase>
	{
		public MessageWithPurchase(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Purchase GetPurchase()
		{
			return base.Data;
		}

		protected override Purchase GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPurchase(obj);
			return new Purchase(o);
		}
	}
	public class MessageWithPurchaseList : Message<PurchaseList>
	{
		public MessageWithPurchaseList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PurchaseList GetPurchaseList()
		{
			return base.Data;
		}

		protected override PurchaseList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPurchaseArray(obj);
			return new PurchaseList(a);
		}
	}
	public class MessageWithRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithRoomUnderCurrentRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoomUnderCurrentRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithRoomUnderViewerRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoomUnderViewerRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithRoomList : Message<RoomList>
	{
		public MessageWithRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomList GetRoomList()
		{
			return base.Data;
		}

		protected override RoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomArray(obj);
			return new RoomList(a);
		}
	}
	public class MessageWithRoomInviteNotificationList : Message<RoomInviteNotificationList>
	{
		public MessageWithRoomInviteNotificationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return base.Data;
		}

		protected override RoomInviteNotificationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomInviteNotificationArray(obj);
			return new RoomInviteNotificationList(a);
		}
	}
	public class MessageWithString : Message<string>
	{
		public MessageWithString(IntPtr c_message)
			: base(c_message)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_Message_GetString(c_message);
		}
	}
	public class MessageWithSystemVoipState : Message<SystemVoipState>
	{
		public MessageWithSystemVoipState(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemVoipState GetSystemVoipState()
		{
			return base.Data;
		}

		protected override SystemVoipState GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemVoipState(obj);
			return new SystemVoipState(o);
		}
	}
	public class MessageWithUser : Message<User>
	{
		public MessageWithUser(IntPtr c_message)
			: base(c_message)
		{
		}

		public override User GetUser()
		{
			return base.Data;
		}

		protected override User GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUser(obj);
			return new User(o);
		}
	}
	public class MessageWithUserAndRoomList : Message<UserAndRoomList>
	{
		public MessageWithUserAndRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserAndRoomList GetUserAndRoomList()
		{
			return base.Data;
		}

		protected override UserAndRoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserAndRoomArray(obj);
			return new UserAndRoomList(a);
		}
	}
	public class MessageWithUserList : Message<UserList>
	{
		public MessageWithUserList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserList GetUserList()
		{
			return base.Data;
		}

		protected override UserList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserArray(obj);
			return new UserList(a);
		}
	}
	public class MessageWithUserProof : Message<UserProof>
	{
		public MessageWithUserProof(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserProof GetUserProof()
		{
			return base.Data;
		}

		protected override UserProof GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserProof(obj);
			return new UserProof(o);
		}
	}
	public class MessageWithNetworkingPeer : Message<Oculus.Platform.Models.NetworkingPeer>
	{
		public MessageWithNetworkingPeer(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.NetworkingPeer GetNetworkingPeer()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.NetworkingPeer GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNetworkingPeer(c_message);
			return new Oculus.Platform.Models.NetworkingPeer(CAPI.ovr_NetworkingPeer_GetID(obj), CAPI.ovr_NetworkingPeer_GetState(obj));
		}
	}
	public class MessageWithPingResult : Message<PingResult>
	{
		public MessageWithPingResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PingResult GetPingResult()
		{
			return base.Data;
		}

		protected override PingResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetPingResult(c_message);
			bool flag = CAPI.ovr_PingResult_IsTimeout(obj);
			return new PingResult(CAPI.ovr_PingResult_GetID(obj), (!flag) ? new ulong?(CAPI.ovr_PingResult_GetPingTimeUsec(obj)) : null);
		}
	}
	public class MessageWithLeaderboardDidUpdate : Message<bool>
	{
		public MessageWithLeaderboardDidUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override bool GetLeaderboardDidUpdate()
		{
			return base.Data;
		}

		protected override bool GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr obj2 = CAPI.ovr_Message_GetLeaderboardUpdateStatus(obj);
			return CAPI.ovr_LeaderboardUpdateStatus_GetDidUpdate(obj2);
		}
	}
	public class MessageWithMatchmakingNotification : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithMatchmakingNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithMatchmakingBrowseResult : Message<MatchmakingBrowseResult>
	{
		public MessageWithMatchmakingBrowseResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data.EnqueueResult;
		}

		public override RoomList GetRoomList()
		{
			return base.Data.Rooms;
		}

		protected override MatchmakingBrowseResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingBrowseResult(obj);
			return new MatchmakingBrowseResult(o);
		}
	}
	public class MessageWithHttpTransferUpdate : Message<HttpTransferUpdate>
	{
		public MessageWithHttpTransferUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override HttpTransferUpdate GetHttpTransferUpdate()
		{
			return base.Data;
		}

		protected override HttpTransferUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetHttpTransferUpdate(obj);
			return new HttpTransferUpdate(o);
		}
	}
}
namespace Oculus.Platform.Models
{
	public class AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly uint BitfieldLength;

		public readonly ulong Target;

		public AchievementDefinition(IntPtr o)
		{
			Type = CAPI.ovr_AchievementDefinition_GetType(o);
			Name = CAPI.ovr_AchievementDefinition_GetName(o);
			BitfieldLength = CAPI.ovr_AchievementDefinition_GetBitfieldLength(o);
			Target = CAPI.ovr_AchievementDefinition_GetTarget(o);
		}
	}
	public class AchievementDefinitionList : DeserializableList<AchievementDefinition>
	{
		public AchievementDefinitionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementDefinitionArray_GetSize(a);
			_Data = new List<AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementDefinition(CAPI.ovr_AchievementDefinitionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementDefinitionArray_GetNextUrl(a);
		}
	}
	public class AchievementProgress
	{
		public readonly string Bitfield;

		public readonly ulong Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public AchievementProgress(IntPtr o)
		{
			Bitfield = CAPI.ovr_AchievementProgress_GetBitfield(o);
			Count = CAPI.ovr_AchievementProgress_GetCount(o);
			IsUnlocked = CAPI.ovr_AchievementProgress_GetIsUnlocked(o);
			Name = CAPI.ovr_AchievementProgress_GetName(o);
			UnlockTime = CAPI.ovr_AchievementProgress_GetUnlockTime(o);
		}
	}
	public class AchievementProgressList : DeserializableList<AchievementProgress>
	{
		public AchievementProgressList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementProgressArray_GetSize(a);
			_Data = new List<AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementProgress(CAPI.ovr_AchievementProgressArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementProgressArray_GetNextUrl(a);
		}
	}
	public class AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public AchievementUpdate(IntPtr o)
		{
			JustUnlocked = CAPI.ovr_AchievementUpdate_GetJustUnlocked(o);
			Name = CAPI.ovr_AchievementUpdate_GetName(o);
		}
	}
	public class ApplicationVersion
	{
		public readonly int CurrentCode;

		public readonly string CurrentName;

		public readonly int LatestCode;

		public readonly string LatestName;

		public ApplicationVersion(IntPtr o)
		{
			CurrentCode = CAPI.ovr_ApplicationVersion_GetCurrentCode(o);
			CurrentName = CAPI.ovr_ApplicationVersion_GetCurrentName(o);
			LatestCode = CAPI.ovr_ApplicationVersion_GetLatestCode(o);
			LatestName = CAPI.ovr_ApplicationVersion_GetLatestName(o);
		}
	}
	public class CloudStorageConflictMetadata
	{
		public readonly CloudStorageMetadata Local;

		public readonly CloudStorageMetadata Remote;

		public CloudStorageConflictMetadata(IntPtr o)
		{
			Local = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetLocal(o));
			Remote = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetRemote(o));
		}
	}
	public class CloudStorageData
	{
		public readonly string Bucket;

		public readonly byte[] Data;

		public readonly uint DataSize;

		public readonly string Key;

		public CloudStorageData(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageData_GetBucket(o);
			Data = CAPI.ovr_CloudStorageData_GetData(o);
			DataSize = CAPI.ovr_CloudStorageData_GetDataSize(o);
			Key = CAPI.ovr_CloudStorageData_GetKey(o);
		}
	}
	public class CloudStorageMetadata
	{
		public readonly string Bucket;

		public readonly long Counter;

		public readonly uint DataSize;

		public readonly string ExtraData;

		public readonly string Key;

		public readonly ulong SaveTime;

		public readonly CloudStorageDataStatus Status;

		public readonly string VersionHandle;

		public CloudStorageMetadata(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageMetadata_GetBucket(o);
			Counter = CAPI.ovr_CloudStorageMetadata_GetCounter(o);
			DataSize = CAPI.ovr_CloudStorageMetadata_GetDataSize(o);
			ExtraData = CAPI.ovr_CloudStorageMetadata_GetExtraData(o);
			Key = CAPI.ovr_CloudStorageMetadata_GetKey(o);
			SaveTime = CAPI.ovr_CloudStorageMetadata_GetSaveTime(o);
			Status = CAPI.ovr_CloudStorageMetadata_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageMetadata_GetVersionHandle(o);
		}
	}
	public class CloudStorageMetadataList : DeserializableList<CloudStorageMetadata>
	{
		public CloudStorageMetadataList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CloudStorageMetadataArray_GetSize(a);
			_Data = new List<CloudStorageMetadata>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CloudStorageMetadata(CAPI.ovr_CloudStorageMetadataArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_CloudStorageMetadataArray_GetNextUrl(a);
		}
	}
	public class CloudStorageUpdateResponse
	{
		public readonly string Bucket;

		public readonly string Key;

		public readonly CloudStorageUpdateStatus Status;

		public readonly string VersionHandle;

		public CloudStorageUpdateResponse(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageUpdateResponse_GetBucket(o);
			Key = CAPI.ovr_CloudStorageUpdateResponse_GetKey(o);
			Status = CAPI.ovr_CloudStorageUpdateResponse_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageUpdateResponse_GetVersionHandle(o);
		}
	}
	public class DeserializableList<T> : IList<T>, IEnumerable, ICollection<T>, IEnumerable<T>
	{
		protected List<T> _Data;

		protected string _NextUrl;

		protected string _PreviousUrl;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)_Data).IsReadOnly;

		public int Count => _Data.Count;

		public T this[int index]
		{
			get
			{
				return _Data[index];
			}
			set
			{
				_Data[index] = value;
			}
		}

		[Obsolete("Use IList interface on the DeserializableList object instead.", false)]
		public List<T> Data => _Data;

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => _NextUrl;

		public string PreviousUrl => _PreviousUrl;

		public int IndexOf(T obj)
		{
			return _Data.IndexOf(obj);
		}

		public void Add(T item)
		{
			_Data.Add(item);
		}

		public void Clear()
		{
			_Data.Clear();
		}

		public bool Contains(T item)
		{
			return _Data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			_Data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _Data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			_Data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return _Data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			_Data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public class HttpTransferUpdate
	{
		public readonly ulong ID;

		public readonly byte[] Payload;

		public readonly bool IsCompleted;

		public HttpTransferUpdate(IntPtr o)
		{
			ID = CAPI.ovr_HttpTransferUpdate_GetID(o);
			IsCompleted = CAPI.ovr_HttpTransferUpdate_IsCompleted(o);
			long num = (long)(ulong)CAPI.ovr_HttpTransferUpdate_GetSize(o);
			Payload = new byte[num];
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(o), Payload, 0, (int)num);
		}
	}
	public class InstalledApplication
	{
		public readonly string ApplicationId;

		public readonly string PackageName;

		public readonly string Status;

		public readonly int VersionCode;

		public readonly string VersionName;

		public InstalledApplication(IntPtr o)
		{
			ApplicationId = CAPI.ovr_InstalledApplication_GetApplicationId(o);
			PackageName = CAPI.ovr_InstalledApplication_GetPackageName(o);
			Status = CAPI.ovr_InstalledApplication_GetStatus(o);
			VersionCode = CAPI.ovr_InstalledApplication_GetVersionCode(o);
			VersionName = CAPI.ovr_InstalledApplication_GetVersionName(o);
		}
	}
	public class InstalledApplicationList : DeserializableList<InstalledApplication>
	{
		public InstalledApplicationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_InstalledApplicationArray_GetSize(a);
			_Data = new List<InstalledApplication>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new InstalledApplication(CAPI.ovr_InstalledApplicationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LaunchDetails
	{
		public readonly string DeeplinkMessage;

		public readonly LaunchType LaunchType;

		public readonly ulong RoomID;

		public readonly UserList Users;

		public LaunchDetails(IntPtr o)
		{
			DeeplinkMessage = CAPI.ovr_LaunchDetails_GetDeeplinkMessage(o);
			LaunchType = CAPI.ovr_LaunchDetails_GetLaunchType(o);
			RoomID = CAPI.ovr_LaunchDetails_GetRoomID(o);
			Users = new UserList(CAPI.ovr_LaunchDetails_GetUsers(o));
		}
	}
	public class LeaderboardEntry
	{
		public readonly byte[] ExtraData;

		public readonly int Rank;

		public readonly long Score;

		public readonly DateTime Timestamp;

		public readonly User User;

		public LeaderboardEntry(IntPtr o)
		{
			ExtraData = CAPI.ovr_LeaderboardEntry_GetExtraData(o);
			Rank = CAPI.ovr_LeaderboardEntry_GetRank(o);
			Score = CAPI.ovr_LeaderboardEntry_GetScore(o);
			Timestamp = CAPI.ovr_LeaderboardEntry_GetTimestamp(o);
			User = new User(CAPI.ovr_LeaderboardEntry_GetUser(o));
		}
	}
	public class LeaderboardEntryList : DeserializableList<LeaderboardEntry>
	{
		public readonly ulong TotalCount;

		public LeaderboardEntryList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LeaderboardEntryArray_GetSize(a);
			_Data = new List<LeaderboardEntry>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LeaderboardEntry(CAPI.ovr_LeaderboardEntryArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			TotalCount = CAPI.ovr_LeaderboardEntryArray_GetTotalCount(a);
			_PreviousUrl = CAPI.ovr_LeaderboardEntryArray_GetPreviousUrl(a);
			_NextUrl = CAPI.ovr_LeaderboardEntryArray_GetNextUrl(a);
		}
	}
	public class LivestreamingStatus
	{
		public readonly bool IsPaused;

		public readonly bool LivestreamingEnabled;

		public readonly bool MicEnabled;

		public LivestreamingStatus(IntPtr o)
		{
			IsPaused = CAPI.ovr_LivestreamingStatus_GetIsPaused(o);
			LivestreamingEnabled = CAPI.ovr_LivestreamingStatus_GetLivestreamingEnabled(o);
			MicEnabled = CAPI.ovr_LivestreamingStatus_GetMicEnabled(o);
		}
	}
	public class MatchmakingAdminSnapshot
	{
		public readonly MatchmakingAdminSnapshotCandidateList Candidates;

		public readonly double MyCurrentThreshold;

		public MatchmakingAdminSnapshot(IntPtr o)
		{
			Candidates = new MatchmakingAdminSnapshotCandidateList(CAPI.ovr_MatchmakingAdminSnapshot_GetCandidates(o));
			MyCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidate
	{
		public readonly bool CanMatch;

		public readonly double MyTotalScore;

		public readonly double TheirCurrentThreshold;

		public readonly double TheirTotalScore;

		public readonly string TraceId;

		public MatchmakingAdminSnapshotCandidate(IntPtr o)
		{
			CanMatch = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(o);
			MyTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(o);
			TheirCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(o);
			TheirTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(o);
			TraceId = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidateList : DeserializableList<MatchmakingAdminSnapshotCandidate>
	{
		public MatchmakingAdminSnapshotCandidateList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(a);
			_Data = new List<MatchmakingAdminSnapshotCandidate>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingAdminSnapshotCandidate(CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingBrowseResult
	{
		public readonly MatchmakingEnqueueResult EnqueueResult;

		public readonly RoomList Rooms;

		public MatchmakingBrowseResult(IntPtr o)
		{
			EnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingBrowseResult_GetEnqueueResult(o));
			Rooms = new RoomList(CAPI.ovr_MatchmakingBrowseResult_GetRooms(o));
		}
	}
	public class MatchmakingEnqueueResult
	{
		public readonly MatchmakingAdminSnapshot AdminSnapshot;

		public readonly uint AverageWait;

		public readonly uint MatchesInLastHourCount;

		public readonly uint MaxExpectedWait;

		public readonly string Pool;

		public readonly uint RecentMatchPercentage;

		public readonly string RequestHash;

		public MatchmakingEnqueueResult(IntPtr o)
		{
			AdminSnapshot = new MatchmakingAdminSnapshot(CAPI.ovr_MatchmakingEnqueueResult_GetAdminSnapshot(o));
			AverageWait = CAPI.ovr_MatchmakingEnqueueResult_GetAverageWait(o);
			MatchesInLastHourCount = CAPI.ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(o);
			MaxExpectedWait = CAPI.ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(o);
			Pool = CAPI.ovr_MatchmakingEnqueueResult_GetPool(o);
			RecentMatchPercentage = CAPI.ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(o);
			RequestHash = CAPI.ovr_MatchmakingEnqueueResult_GetRequestHash(o);
		}
	}
	public class MatchmakingEnqueueResultAndRoom
	{
		public readonly MatchmakingEnqueueResult MatchmakingEnqueueResult;

		public readonly Room Room;

		public MatchmakingEnqueueResultAndRoom(IntPtr o)
		{
			MatchmakingEnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(o));
			Room = new Room(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetRoom(o));
		}
	}
	public class MatchmakingEnqueuedUser
	{
		public readonly Dictionary<string, string> CustomData;

		public readonly User User;

		public MatchmakingEnqueuedUser(IntPtr o)
		{
			CustomData = CAPI.DataStoreFromNative(CAPI.ovr_MatchmakingEnqueuedUser_GetCustomData(o));
			User = new User(CAPI.ovr_MatchmakingEnqueuedUser_GetUser(o));
		}
	}
	public class MatchmakingEnqueuedUserList : DeserializableList<MatchmakingEnqueuedUser>
	{
		public MatchmakingEnqueuedUserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingEnqueuedUserArray_GetSize(a);
			_Data = new List<MatchmakingEnqueuedUser>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingEnqueuedUser(CAPI.ovr_MatchmakingEnqueuedUserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingStats
	{
		public readonly uint DrawCount;

		public readonly uint LossCount;

		public readonly uint SkillLevel;

		public readonly uint WinCount;

		public MatchmakingStats(IntPtr o)
		{
			DrawCount = CAPI.ovr_MatchmakingStats_GetDrawCount(o);
			LossCount = CAPI.ovr_MatchmakingStats_GetLossCount(o);
			SkillLevel = CAPI.ovr_MatchmakingStats_GetSkillLevel(o);
			WinCount = CAPI.ovr_MatchmakingStats_GetWinCount(o);
		}
	}
	public class NetworkingPeer
	{
		public ulong ID { get; private set; }

		public PeerConnectionState State { get; private set; }

		public NetworkingPeer(ulong id, PeerConnectionState state)
		{
			ID = id;
			State = state;
		}
	}
	public class OrgScopedID
	{
		public readonly ulong ID;

		public OrgScopedID(IntPtr o)
		{
			ID = CAPI.ovr_OrgScopedID_GetID(o);
		}
	}
	public class Party
	{
		public readonly ulong ID;

		public readonly UserList InvitedUsers;

		public readonly User Leader;

		public readonly Room Room;

		public readonly UserList Users;

		public Party(IntPtr o)
		{
			ID = CAPI.ovr_Party_GetID(o);
			InvitedUsers = new UserList(CAPI.ovr_Party_GetInvitedUsers(o));
			Leader = new User(CAPI.ovr_Party_GetLeader(o));
			Room = new Room(CAPI.ovr_Party_GetRoom(o));
			Users = new UserList(CAPI.ovr_Party_GetUsers(o));
		}
	}
	public class Pid
	{
		public readonly string Id;

		public Pid(IntPtr o)
		{
			Id = CAPI.ovr_Pid_GetId(o);
		}
	}
	public class PidList : DeserializableList<Pid>
	{
		public PidList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PidArray_GetSize(a);
			_Data = new List<Pid>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Pid(CAPI.ovr_PidArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class PingResult
	{
		private ulong? pingTimeUsec;

		public ulong ID { get; private set; }

		public ulong PingTimeUsec => (!pingTimeUsec.HasValue) ? 0 : pingTimeUsec.Value;

		public bool IsTimeout => !pingTimeUsec.HasValue;

		public PingResult(ulong id, ulong? pingTimeUsec)
		{
			ID = id;
			this.pingTimeUsec = pingTimeUsec;
		}
	}
	public class Product
	{
		public readonly string Description;

		public readonly string FormattedPrice;

		public readonly string Name;

		public readonly string Sku;

		public Product(IntPtr o)
		{
			Description = CAPI.ovr_Product_GetDescription(o);
			FormattedPrice = CAPI.ovr_Product_GetFormattedPrice(o);
			Name = CAPI.ovr_Product_GetName(o);
			Sku = CAPI.ovr_Product_GetSKU(o);
		}
	}
	public class ProductList : DeserializableList<Product>
	{
		public ProductList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_ProductArray_GetSize(a);
			_Data = new List<Product>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Product(CAPI.ovr_ProductArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_ProductArray_GetNextUrl(a);
		}
	}
	public class Purchase
	{
		public readonly DateTime ExpirationTime;

		public readonly DateTime GrantTime;

		public readonly ulong ID;

		public readonly string Sku;

		public Purchase(IntPtr o)
		{
			ExpirationTime = CAPI.ovr_Purchase_GetExpirationTime(o);
			GrantTime = CAPI.ovr_Purchase_GetGrantTime(o);
			ID = CAPI.ovr_Purchase_GetPurchaseID(o);
			Sku = CAPI.ovr_Purchase_GetSKU(o);
		}
	}
	public class PurchaseList : DeserializableList<Purchase>
	{
		public PurchaseList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PurchaseArray_GetSize(a);
			_Data = new List<Purchase>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Purchase(CAPI.ovr_PurchaseArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_PurchaseArray_GetNextUrl(a);
		}
	}
	public class Room
	{
		public readonly ulong ApplicationID;

		public readonly Dictionary<string, string> DataStore;

		public readonly string Description;

		public readonly ulong ID;

		public readonly UserList InvitedUsers;

		public readonly bool IsMembershipLocked;

		public readonly RoomJoinPolicy JoinPolicy;

		public readonly RoomJoinability Joinability;

		public readonly MatchmakingEnqueuedUserList MatchedUsers;

		public readonly uint MaxUsers;

		public readonly string Name;

		public readonly User Owner;

		public readonly RoomType Type;

		public readonly UserList Users;

		public readonly uint Version;

		public Room(IntPtr o)
		{
			ApplicationID = CAPI.ovr_Room_GetApplicationID(o);
			DataStore = CAPI.DataStoreFromNative(CAPI.ovr_Room_GetDataStore(o));
			Description = CAPI.ovr_Room_GetDescription(o);
			ID = CAPI.ovr_Room_GetID(o);
			InvitedUsers = new UserList(CAPI.ovr_Room_GetInvitedUsers(o));
			IsMembershipLocked = CAPI.ovr_Room_GetIsMembershipLocked(o);
			JoinPolicy = CAPI.ovr_Room_GetJoinPolicy(o);
			Joinability = CAPI.ovr_Room_GetJoinability(o);
			MatchedUsers = new MatchmakingEnqueuedUserList(CAPI.ovr_Room_GetMatchedUsers(o));
			MaxUsers = CAPI.ovr_Room_GetMaxUsers(o);
			Name = CAPI.ovr_Room_GetName(o);
			Owner = new User(CAPI.ovr_Room_GetOwner(o));
			Type = CAPI.ovr_Room_GetType(o);
			Users = new UserList(CAPI.ovr_Room_GetUsers(o));
			Version = CAPI.ovr_Room_GetVersion(o);
		}
	}
	public class RoomList : DeserializableList<Room>
	{
		public RoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomArray_GetSize(a);
			_Data = new List<Room>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Room(CAPI.ovr_RoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomArray_GetNextUrl(a);
		}
	}
	public class RoomInviteNotification
	{
		public readonly ulong ID;

		public readonly ulong RoomID;

		public readonly DateTime SentTime;

		public RoomInviteNotification(IntPtr o)
		{
			ID = CAPI.ovr_RoomInviteNotification_GetID(o);
			RoomID = CAPI.ovr_RoomInviteNotification_GetRoomID(o);
			SentTime = CAPI.ovr_RoomInviteNotification_GetSentTime(o);
		}
	}
	public class RoomInviteNotificationList : DeserializableList<RoomInviteNotification>
	{
		public RoomInviteNotificationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomInviteNotificationArray_GetSize(a);
			_Data = new List<RoomInviteNotification>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new RoomInviteNotification(CAPI.ovr_RoomInviteNotificationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomInviteNotificationArray_GetNextUrl(a);
		}
	}
	public class SystemVoipState
	{
		public readonly VoipMuteState MicrophoneMuted;

		public readonly SystemVoipStatus Status;

		public SystemVoipState(IntPtr o)
		{
			MicrophoneMuted = CAPI.ovr_SystemVoipState_GetMicrophoneMuted(o);
			Status = CAPI.ovr_SystemVoipState_GetStatus(o);
		}
	}
	public class User
	{
		public readonly ulong ID;

		public readonly string ImageURL;

		public readonly string InviteToken;

		public readonly string OculusID;

		public readonly string Presence;

		public readonly UserPresenceStatus PresenceStatus;

		public readonly string SmallImageUrl;

		public User(IntPtr o)
		{
			ID = CAPI.ovr_User_GetID(o);
			ImageURL = CAPI.ovr_User_GetImageUrl(o);
			InviteToken = CAPI.ovr_User_GetInviteToken(o);
			OculusID = CAPI.ovr_User_GetOculusID(o);
			Presence = CAPI.ovr_User_GetPresence(o);
			PresenceStatus = CAPI.ovr_User_GetPresenceStatus(o);
			SmallImageUrl = CAPI.ovr_User_GetSmallImageUrl(o);
		}
	}
	public class UserList : DeserializableList<User>
	{
		public UserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserArray_GetSize(a);
			_Data = new List<User>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new User(CAPI.ovr_UserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserArray_GetNextUrl(a);
		}
	}
	public class UserAndRoom
	{
		public readonly Room Room;

		public readonly User User;

		public UserAndRoom(IntPtr o)
		{
			Room = new Room(CAPI.ovr_UserAndRoom_GetRoom(o));
			User = new User(CAPI.ovr_UserAndRoom_GetUser(o));
		}
	}
	public class UserAndRoomList : DeserializableList<UserAndRoom>
	{
		public UserAndRoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserAndRoomArray_GetSize(a);
			_Data = new List<UserAndRoom>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new UserAndRoom(CAPI.ovr_UserAndRoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserAndRoomArray_GetNextUrl(a);
		}
	}
	public class UserProof
	{
		public readonly string Value;

		public UserProof(IntPtr o)
		{
			Value = CAPI.ovr_UserProof_GetNonce(o);
		}
	}
}
namespace Oculus.Platform
{
	public sealed class Packet : IDisposable
	{
		private readonly ulong size;

		private readonly IntPtr packetHandle;

		public ulong SenderID => CAPI.ovr_Packet_GetSenderID(packetHandle);

		public ulong Size => size;

		public SendPolicy Policy => CAPI.ovr_Packet_GetSendPolicy(packetHandle);

		public Packet(IntPtr packetHandle)
		{
			this.packetHandle = packetHandle;
			size = (ulong)CAPI.ovr_Packet_GetSize(packetHandle);
		}

		public ulong ReadBytes(byte[] destination)
		{
			if ((ulong)destination.LongLength < size)
			{
				throw new ArgumentException($"Destination array was not big enough to hold {size} bytes");
			}
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(packetHandle), destination, 0, (int)size);
			return size;
		}

		~Packet()
		{
			Dispose();
		}

		public void Dispose()
		{
			CAPI.ovr_Packet_Free(packetHandle);
			GC.SuppressFinalize(this);
		}
	}
	public enum PeerConnectionState : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTED")]
		Connected,
		[Description("TIMEOUT")]
		Timeout,
		[Description("CLOSED")]
		Closed
	}
	public sealed class Core
	{
		private static bool IsPlatformInitialized;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		internal static void ForceInitialized()
		{
			IsPlatformInitialized = true;
		}

		public static void Initialize(string appId = null)
		{
			bool flag = UnityEngine.Application.platform == RuntimePlatform.WindowsEditor && !PlatformSettings.UseStandalonePlatform;
			if (!UnityEngine.Application.isEditor || flag)
			{
				string appIDFromConfig = GetAppIDFromConfig(flag);
				if (string.IsNullOrEmpty(appId))
				{
					if (string.IsNullOrEmpty(appIDFromConfig))
					{
						throw new UnityException("Update your app id by selecting 'Oculus Platform' -> 'Edit Settings'");
					}
					appId = appIDFromConfig;
				}
				else if (!string.IsNullOrEmpty(appIDFromConfig))
				{
					UnityEngine.Debug.LogWarningFormat("The 'Oculus App Id ({0})' field in 'Oculus Platform/Edit Settings' is clobbering appId ({1}) that you passed in to Platform.Core.Init.  You should only specify this in one place.  We recommend the menu location.", appIDFromConfig, appId);
				}
			}
			if (flag)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				IsPlatformInitialized = windowsPlatform.Initialize(appId);
			}
			else if (UnityEngine.Application.isEditor)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				IsPlatformInitialized = standalonePlatform.InitializeInEditor();
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				AndroidPlatform androidPlatform = new AndroidPlatform();
				IsPlatformInitialized = androidPlatform.Initialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.WindowsPlayer)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				WindowsPlatform windowsPlatform2 = new WindowsPlatform();
				IsPlatformInitialized = windowsPlatform2.Initialize(appId);
			}
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
		}

		private static string GetAppIDFromConfig(bool forceWindows)
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return PlatformSettings.MobileAppID;
			}
			if (UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer || forceWindows)
			{
				return PlatformSettings.AppID;
			}
			return null;
		}
	}
	public static class Rooms
	{
		public static Request<Oculus.Platform.Models.Room> UpdateDataStore(ulong roomID, Dictionary<string, string> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, string> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdateDataStore(roomID, array, (uint)array.Length));
			}
			return null;
		}

		public static void SetUpdateNotificationCallback(Message<Oculus.Platform.Models.Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_RoomUpdate, callback);
		}

		public static void SetRoomInviteNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteAccepted, callback);
		}

		public static Request<Oculus.Platform.Models.Room> CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_CreateAndJoinPrivate(joinPolicy, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_CreateAndJoinPrivate2(joinPolicy, maxUsers, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Get(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Get(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_GetCurrent());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> GetCurrentForUser(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_GetCurrentForUser(userID));
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers());
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers2(RoomOptions roomOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers2((IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<RoomList> GetModeratedRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_Room_GetModeratedRooms());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> InviteUser(ulong roomID, string inviteToken)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_InviteUser(roomID, inviteToken));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Join(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Join(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Join2(ulong roomID, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Join2(roomID, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> KickUser(ulong roomID, ulong userID, int kickDurationSeconds)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_KickUser(roomID, userID, kickDurationSeconds));
			}
			return null;
		}

		public static Request LaunchInvitableUserFlow(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_LaunchInvitableUserFlow(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Leave(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Leave(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> SetDescription(ulong roomID, string description)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_SetDescription(roomID, description));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdateMembershipLockStatus(roomID, membershipLockStatus));
			}
			return null;
		}

		public static Request UpdateOwner(ulong roomID, ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_UpdateOwner(roomID, userID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdatePrivateRoomJoinPolicy(roomID, newJoinPolicy));
			}
			return null;
		}

		public static Request<RoomList> GetNextRoomListPage(RoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1317239238));
			}
			return null;
		}
	}
	public static class Livestreaming
	{
		public static void SetStatusUpdateNotificationCallback(Message<LivestreamingStatus>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Livestreaming_StatusChange, callback);
		}

		public static Request<LivestreamingStatus> GetStatus()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_GetStatus());
			}
			return null;
		}

		public static Request<LivestreamingStatus> PauseStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_PauseStream());
			}
			return null;
		}

		public static Request<LivestreamingStatus> ResumeStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_ResumeStream());
			}
			return null;
		}
	}
	public static class Matchmaking
	{
		public class CustomQuery
		{
			public struct Criterion
			{
				public string key;

				public MatchmakingCriterionImportance importance;

				public Dictionary<string, object> parameters;

				public Criterion(string key_, MatchmakingCriterionImportance importance_)
				{
					key = key_;
					importance = importance_;
					parameters = null;
				}
			}

			public Dictionary<string, object> data;

			public Criterion[] criteria;

			public IntPtr ToUnmanaged()
			{
				CAPI.ovrMatchmakingCustomQueryData ovrMatchmakingCustomQueryData = default(CAPI.ovrMatchmakingCustomQueryData);
				if (criteria != null && criteria.Length > 0)
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = (uint)criteria.Length;
					CAPI.ovrMatchmakingCriterion[] array = new CAPI.ovrMatchmakingCriterion[criteria.Length];
					for (int i = 0; i < criteria.Length; i++)
					{
						array[i].importance_ = criteria[i].importance;
						array[i].key_ = criteria[i].key;
						if (criteria[i].parameters != null && criteria[i].parameters.Count > 0)
						{
							array[i].parameterArrayCount = (uint)criteria[i].parameters.Count;
							array[i].parameterArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(criteria[i].parameters));
						}
						else
						{
							array[i].parameterArrayCount = 0u;
							array[i].parameterArray = IntPtr.Zero;
						}
					}
					ovrMatchmakingCustomQueryData.criterionArray = CAPI.ArrayOfStructsToIntPtr(array);
				}
				else
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = 0u;
					ovrMatchmakingCustomQueryData.criterionArray = IntPtr.Zero;
				}
				if (data != null && data.Count > 0)
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = (uint)data.Count;
					ovrMatchmakingCustomQueryData.dataArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(data));
				}
				else
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = 0u;
					ovrMatchmakingCustomQueryData.dataArray = IntPtr.Zero;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ovrMatchmakingCustomQueryData));
				Marshal.StructureToPtr(ovrMatchmakingCustomQueryData, intPtr, fDeleteOld: true);
				return intPtr;
			}
		}

		public static Request ReportResultsInsecure(ulong roomID, Dictionary<string, int> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, int> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request(CAPI.ovr_Matchmaking_ReportResultInsecure(roomID, array, (uint)array.Length));
			}
			return null;
		}

		public static void SetMatchFoundNotificationCallback(Message<Oculus.Platform.Models.Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Matchmaking_MatchFound, callback);
		}

		public static Request<MatchmakingStats> GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach = MatchmakingStatApproach.Trailing)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingStats>(CAPI.ovr_Matchmaking_GetStats(pool, maxLevel, approach));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request Cancel(string pool, string requestHash)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel(pool, requestHash));
			}
			return null;
		}

		public static Request Cancel()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel2());
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates = false, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom(pool, maxUsers, subscribeToUpdates, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_CreateRoom(pool, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_CreateRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom(ulong roomID, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom(roomID, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom2(ulong roomID, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom2(roomID, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingAdminSnapshot> GetAdminSnapshot()
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingAdminSnapshot>(CAPI.ovr_Matchmaking_GetAdminSnapshot());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> JoinRoom(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_JoinRoom(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request StartMatch(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_StartMatch(roomID));
			}
			return null;
		}
	}
	public static class Net
	{
		public static Packet ReadPacket()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_Net_ReadPacket();
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return new Packet(intPtr);
		}

		public static bool SendPacket(ulong userID, byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacket(userID, (UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static void Connect(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Connect(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Accept(userID);
			}
		}

		public static void Close(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Close(userID);
			}
		}

		public static bool IsConnected(ulong userID)
		{
			return Core.IsInitialized() && CAPI.ovr_Net_IsConnected(userID);
		}

		public static bool SendPacketToCurrentRoom(byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacketToCurrentRoom((UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static bool AcceptForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_AcceptForCurrentRoom();
			}
			return false;
		}

		public static void CloseForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_CloseForCurrentRoom();
			}
		}

		public static Request<PingResult> Ping(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<PingResult>(CAPI.ovr_Net_Ping(userID));
			}
			return null;
		}

		public static void SetPeerConnectRequestCallback(Message<Oculus.Platform.Models.NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PeerConnectRequest, callback);
		}

		public static void SetConnectionStateChangedCallback(Message<Oculus.Platform.Models.NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_ConnectionStateChange, callback);
		}
	}
	public static class Leaderboards
	{
		public static Request<LeaderboardEntryList> GetNextEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1310751961));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetPreviousEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.PreviousUrl, 1224858304));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntries(leaderboardName, limit, filter, startAt));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntriesAfterRank(leaderboardName, limit, afterRank));
			}
			return null;
		}

		public static Request<bool> WriteEntry(string leaderboardName, long score, byte[] extraData = null, bool forceUpdate = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<bool>(CAPI.ovr_Leaderboard_WriteEntry(leaderboardName, score, extraData, (extraData != null) ? ((uint)extraData.Length) : 0u, forceUpdate));
			}
			return null;
		}
	}
	public static class Voip
	{
		public static void Start(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Start(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Accept(userID);
			}
		}

		public static void Stop(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Stop(userID);
			}
		}

		public static void SetVoipConnectRequestCallback(Message<Oculus.Platform.Models.NetworkingPeer>.Callback callback)
		{
			if (Core.IsInitialized())
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_ConnectRequest, callback);
			}
		}

		public static void SetVoipStateChangeCallback(Message<Oculus.Platform.Models.NetworkingPeer>.Callback callback)
		{
			if (Core.IsInitialized())
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_StateChange, callback);
			}
		}

		public static void SetMicrophoneFilterCallback(CAPI.FilterCallback callback)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(callback, (UIntPtr)480uL);
			}
		}

		public static void SetMicrophoneMuted(VoipMuteState state)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneMuted(state);
			}
		}

		public static VoipMuteState GetSystemVoipMicrophoneMuted()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipMicrophoneMuted();
			}
			return VoipMuteState.Unknown;
		}

		public static SystemVoipStatus GetSystemVoipStatus()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipStatus();
			}
			return SystemVoipStatus.Unknown;
		}

		public static void SetSystemVoipStateNotificationCallback(Message<SystemVoipState>.Callback callback)
		{
			if (Core.IsInitialized())
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_SystemVoipState, callback);
			}
		}

		public static Request<SystemVoipState> SetSystemVoipSuppressed(bool suppressed)
		{
			if (Core.IsInitialized())
			{
				return new Request<SystemVoipState>(CAPI.ovr_Voip_SetSystemVoipSuppressed(suppressed));
			}
			return null;
		}
	}
	public static class Achievements
	{
		public static Request<AchievementUpdate> AddCount(string name, ulong count)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Request<AchievementUpdate> AddFields(string name, string fields)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetAllDefinitions()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Request<AchievementProgressList> GetAllProgress()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetProgressByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementUpdate> Unlock(string name)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetNextAchievementDefinitionListPage(AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 712888917));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetNextAchievementProgressListPage(AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 792913703));
			}
			return null;
		}
	}
	public static class Application
	{
		public static Request<ApplicationVersion> GetVersion()
		{
			if (Core.IsInitialized())
			{
				return new Request<ApplicationVersion>(CAPI.ovr_Application_GetVersion());
			}
			return null;
		}
	}
	public static class CloudStorage
	{
		public static Request<CloudStorageUpdateResponse> Delete(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Delete(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> Load(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_Load(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> LoadBucketMetadata(string bucket)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_CloudStorage_LoadBucketMetadata(bucket));
			}
			return null;
		}

		public static Request<CloudStorageConflictMetadata> LoadConflictMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageConflictMetadata>(CAPI.ovr_CloudStorage_LoadConflictMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> LoadHandle(string handle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_LoadHandle(handle));
			}
			return null;
		}

		public static Request<CloudStorageMetadata> LoadMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadata>(CAPI.ovr_CloudStorage_LoadMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepLocal(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepRemote(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> Save(string bucket, string key, byte[] data, long counter, string extraData)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Save(bucket, key, data, (data != null) ? ((uint)data.Length) : 0u, counter, extraData));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> GetNextCloudStorageMetadataListPage(CloudStorageMetadataList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextCloudStorageMetadataListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1544004335));
			}
			return null;
		}
	}
	public static class Entitlements
	{
		public static Request IsUserEntitledToApplication()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Entitlement_GetIsViewerEntitled());
			}
			return null;
		}
	}
	public static class GraphAPI
	{
	}
	public static class HTTP
	{
	}
	public static class IAP
	{
		public static Request ConsumePurchase(string sku)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_IAP_ConsumePurchase(sku));
			}
			return null;
		}

		public static Request<ProductList> GetProductsBySKU(string[] skus)
		{
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_IAP_GetProductsBySKU(skus, (skus != null) ? skus.Length : 0));
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchases()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchases());
			}
			return null;
		}

		public static Request<Purchase> LaunchCheckoutFlow(string sku)
		{
			if (Core.IsInitialized())
			{
				if (UnityEngine.Application.isEditor)
				{
					throw new NotImplementedException("LaunchCheckoutFlow() is not implemented in the editor yet.");
				}
				return new Request<Purchase>(CAPI.ovr_IAP_LaunchCheckoutFlow(sku));
			}
			return null;
		}

		public static Request<ProductList> GetNextProductListPage(ProductList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextProductListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 467225263));
			}
			return null;
		}

		public static Request<PurchaseList> GetNextPurchaseListPage(PurchaseList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextPurchaseListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1196886677));
			}
			return null;
		}
	}
	public static class Notifications
	{
		public static Request<RoomInviteNotificationList> GetRoomInviteNotifications()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_Notification_GetRoomInvites());
			}
			return null;
		}

		public static Request MarkAsRead(ulong notificationID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Notification_MarkAsRead(notificationID));
			}
			return null;
		}

		public static Request<RoomInviteNotificationList> GetNextRoomInviteNotificationListPage(RoomInviteNotificationList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomInviteNotificationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 102890359));
			}
			return null;
		}
	}
	public static class Parties
	{
		public static Request<Party> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Party>(CAPI.ovr_Party_GetCurrent());
			}
			return null;
		}
	}
	public static class Users
	{
		public static Request<User> Get(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_Get(userID));
			}
			return null;
		}

		public static Request<string> GetAccessToken()
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_User_GetAccessToken());
			}
			return null;
		}

		public static Request<User> GetLoggedInUser()
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_GetLoggedInUser());
			}
			return null;
		}

		public static Request<UserList> GetLoggedInUserFriends()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_User_GetLoggedInUserFriends());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserFriendsAndRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserFriendsAndRooms());
			}
			return null;
		}

		public static Request<OrgScopedID> GetOrgScopedID(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<OrgScopedID>(CAPI.ovr_User_GetOrgScopedID(userID));
			}
			return null;
		}

		public static Request<UserProof> GetUserProof()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserProof>(CAPI.ovr_User_GetUserProof());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetNextUserAndRoomListPage(UserAndRoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserAndRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 2143146719));
			}
			return null;
		}

		public static Request<UserList> GetNextUserListPage(UserList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 645723971));
			}
			return null;
		}
	}
	public static class PlatformInternal
	{
		public enum MessageTypeInternal : uint
		{
			Application_ExecuteCoordinatedLaunch = 645772532u,
			Application_GetInstalledApplications = 1376744524u,
			GraphAPI_Get = 822018158u,
			GraphAPI_Post = 1990567876u,
			HTTP_Get = 1874211363u,
			HTTP_GetToFile = 1317133401u,
			HTTP_Post = 1798743375u,
			Party_Create = 450042703u,
			Party_GatherInApplication = 1921499523u,
			Party_Get = 1586058173u,
			Party_GetCurrentForUser = 1489764138u,
			Party_Invite = 901104867u,
			Party_Join = 1744993395u,
			Party_Leave = 848430801u,
			Room_CreateOrUpdateAndJoinNamed = 2089683601u,
			Room_GetNamedRooms = 125660812u,
			Room_GetSocialRooms = 1636310390u,
			User_NewEntitledTestUser = 292822787u,
			User_NewTestUser = 921194380u,
			User_NewTestUserFriends = 517416647u
		}

		public static class HTTP
		{
			public static void SetHttpTransferUpdateCallback(Message<HttpTransferUpdate>.Callback callback)
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_HTTP_Transfer, callback);
			}
		}

		public static void CrashApplication()
		{
			CAPI.ovr_CrashApplication();
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle, Message.MessageType messageType)
		{
			Message result = null;
			switch ((MessageTypeInternal)messageType)
			{
			case MessageTypeInternal.Application_ExecuteCoordinatedLaunch:
			case MessageTypeInternal.Party_Leave:
				result = new Message(messageHandle);
				break;
			case MessageTypeInternal.Application_GetInstalledApplications:
				result = new MessageWithInstalledApplicationList(messageHandle);
				break;
			case MessageTypeInternal.Party_Get:
				result = new MessageWithParty(messageHandle);
				break;
			case MessageTypeInternal.Party_GetCurrentForUser:
				result = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageTypeInternal.Room_CreateOrUpdateAndJoinNamed:
				result = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageTypeInternal.Room_GetNamedRooms:
			case MessageTypeInternal.Room_GetSocialRooms:
				result = new MessageWithRoomList(messageHandle);
				break;
			case MessageTypeInternal.User_NewEntitledTestUser:
			case MessageTypeInternal.User_NewTestUserFriends:
			case MessageTypeInternal.GraphAPI_Get:
			case MessageTypeInternal.User_NewTestUser:
			case MessageTypeInternal.HTTP_GetToFile:
			case MessageTypeInternal.HTTP_Post:
			case MessageTypeInternal.HTTP_Get:
			case MessageTypeInternal.GraphAPI_Post:
				result = new MessageWithString(messageHandle);
				break;
			}
			return result;
		}
	}
	public sealed class PlatformSettings : ScriptableObject
	{
		[SerializeField]
		private string ovrAppID = string.Empty;

		[SerializeField]
		private string ovrMobileAppID = string.Empty;

		[SerializeField]
		private bool ovrUseStandalonePlatform = true;

		private static PlatformSettings instance;

		public static string AppID
		{
			get
			{
				return Instance.ovrAppID;
			}
			set
			{
				Instance.ovrAppID = value;
			}
		}

		public static string MobileAppID
		{
			get
			{
				return Instance.ovrMobileAppID;
			}
			set
			{
				Instance.ovrMobileAppID = value;
			}
		}

		public static bool UseStandalonePlatform
		{
			get
			{
				return Instance.ovrUseStandalonePlatform;
			}
			set
			{
				Instance.ovrUseStandalonePlatform = value;
			}
		}

		public static PlatformSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<PlatformSettings>("OculusPlatformSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<PlatformSettings>();
					}
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public sealed class Request<T> : Request
	{
		public Request(ulong requestID)
			: base(requestID)
		{
		}

		public Request<T> OnComplete(Message<T>.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}
	}
	public class Request
	{
		public ulong RequestID { get; set; }

		public Request(ulong requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Message.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Callback.RunCallbacks();
			}
			else
			{
				Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum RoomJoinPolicy : uint
	{
		[Description("NONE")]
		None,
		[Description("EVERYONE")]
		Everyone,
		[Description("FRIENDS_OF_MEMBERS")]
		FriendsOfMembers,
		[Description("FRIENDS_OF_OWNER")]
		FriendsOfOwner,
		[Description("INVITED_USERS")]
		InvitedUsers,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum RoomJoinability : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ARE_IN")]
		AreIn,
		[Description("ARE_KICKED")]
		AreKicked,
		[Description("CAN_JOIN")]
		CanJoin,
		[Description("IS_FULL")]
		IsFull,
		[Description("NO_VIEWER")]
		NoViewer,
		[Description("POLICY_PREVENTS")]
		PolicyPrevents
	}
	public enum RoomMembershipLockStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCK")]
		Lock,
		[Description("UNLOCK")]
		Unlock
	}
	public class RoomOptions
	{
		private IntPtr Handle;

		public RoomOptions()
		{
			Handle = CAPI.ovr_RoomOptions_Create();
		}

		public void SetDataStore(string key, string value)
		{
			CAPI.ovr_RoomOptions_SetDataStoreString(Handle, key, value);
		}

		public void ClearDataStore()
		{
			CAPI.ovr_RoomOptions_ClearDataStore(Handle);
		}

		public void SetOrdering(UserOrdering value)
		{
			CAPI.ovr_RoomOptions_SetOrdering(Handle, value);
		}

		public void SetRoomId(ulong value)
		{
			CAPI.ovr_RoomOptions_SetRoomId(Handle, value);
		}

		public void SetTurnOffUpdates(bool value)
		{
			CAPI.ovr_RoomOptions_SetTurnOffUpdates(Handle, value);
		}

		public static explicit operator IntPtr(RoomOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RoomOptions()
		{
			CAPI.ovr_RoomOptions_Destroy(Handle);
		}
	}
	public enum RoomType : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MATCHMAKING")]
		Matchmaking,
		[Description("MODERATED")]
		Moderated,
		[Description("PRIVATE")]
		Private,
		[Description("SOLO")]
		Solo
	}
	public enum SendPolicy : uint
	{
		[Description("UNRELIABLE")]
		Unreliable,
		[Description("RELIABLE")]
		Reliable,
		[Description("UNKNOWN")]
		Unknown
	}
	public sealed class StandalonePlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			UnityEngine.Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		public bool InitializeInEditor()
		{
			if (string.IsNullOrEmpty(StandalonePlatformSettings.OculusPlatformAccessToken))
			{
				throw new UnityException("Update your access token by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			return Initialize(StandalonePlatformSettings.OculusPlatformAccessToken);
		}

		public bool Initialize(string accessToken)
		{
			CAPI.ovr_UnityResetTestPlatform();
			CAPI.ovr_UnityInitWrapperStandalone(accessToken, IntPtr.Zero);
			return true;
		}
	}
	public sealed class StandalonePlatformSettings : ScriptableObject
	{
		private const string OculusPlatformAccessTokenKey = "OculusPlatformAccessToken";

		public static string OculusPlatformAccessToken
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}
	}
	public enum SystemVoipStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("UNAVAILABLE")]
		Unavailable,
		[Description("SUPPRESSED")]
		Suppressed,
		[Description("ACTIVE")]
		Active
	}
	public enum UserOrdering : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("PRESENCE_ALPHABETICAL")]
		PresenceAlphabetical
	}
	public enum UserPresenceStatus : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONLINE")]
		Online,
		[Description("OFFLINE")]
		Offline
	}
	public class VoipAudioSourceHiLevel : UnityEngine.MonoBehaviour
	{
		public class FilterReadDelegate : UnityEngine.MonoBehaviour
		{
			public VoipAudioSourceHiLevel parent;

			private float[] scratchBuffer;

			private void Awake()
			{
				int num = (int)(uint)CAPI.ovr_Voip_GetOutputBufferMaxSize();
				scratchBuffer = new float[num];
			}

			private void OnAudioFilterRead(float[] data, int channels)
			{
				int num = data.Length / channels;
				int num2 = num;
				if (num2 > scratchBuffer.Length)
				{
					Array.Clear(data, 0, data.Length);
					throw new Exception($"Audio system tried to pull {num} bytes, max voip internal ring buffer size {scratchBuffer.Length}");
				}
				int num3 = parent.pcmSource.PeekSizeElements();
				if (num3 < num2)
				{
					if (verboseLogging)
					{
						UnityEngine.Debug.LogFormat("Voip starved! Want {0}, but only have {1} available", num2, num3);
					}
					return;
				}
				int pCM = parent.pcmSource.GetPCM(scratchBuffer, num2);
				if (pCM < num2)
				{
					UnityEngine.Debug.LogWarningFormat("GetPCM() returned {0} samples, expected {1}", pCM, num2);
					return;
				}
				int num4 = 0;
				for (int i = 0; i < num; i++)
				{
					float num5 = scratchBuffer[i];
					for (int j = 0; j < channels; j++)
					{
						data[num4++] = num5;
					}
				}
			}
		}

		private int initialPlaybackDelayMS;

		public AudioSource audioSource;

		protected IVoipPCMSource pcmSource;

		private static int audioSystemPlaybackFrequency;

		private static bool verboseLogging;

		public ulong senderID
		{
			set
			{
				pcmSource.SetSenderID(value);
			}
		}

		protected void Stop()
		{
		}

		private VoipSampleRate SampleRateToEnum(int rate)
		{
			return rate switch
			{
				48000 => VoipSampleRate.HZ48000, 
				44100 => VoipSampleRate.HZ44100, 
				24000 => VoipSampleRate.HZ24000, 
				_ => VoipSampleRate.Unknown, 
			};
		}

		protected void Awake()
		{
			CreatePCMSource();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.gameObject.AddComponent<FilterReadDelegate>();
			FilterReadDelegate component = audioSource.gameObject.GetComponent<FilterReadDelegate>();
			component.parent = this;
			initialPlaybackDelayMS = 40;
			audioSystemPlaybackFrequency = AudioSettings.outputSampleRate;
			CAPI.ovr_Voip_SetOutputSampleRate(SampleRateToEnum(audioSystemPlaybackFrequency));
			if (verboseLogging)
			{
				UnityEngine.Debug.LogFormat("freq {0}", audioSystemPlaybackFrequency);
			}
		}

		private void Start()
		{
			audioSource.Stop();
		}

		protected virtual void CreatePCMSource()
		{
			pcmSource = new VoipPCMSourceNative();
		}

		protected static int MSToElements(int ms)
		{
			return ms * audioSystemPlaybackFrequency / 1000;
		}

		private void Update()
		{
			pcmSource.Update();
			if (!audioSource.isPlaying && pcmSource.PeekSizeElements() >= MSToElements(initialPlaybackDelayMS))
			{
				if (verboseLogging)
				{
					UnityEngine.Debug.LogFormat("buffered {0} elements, starting playback", pcmSource.PeekSizeElements());
				}
				audioSource.Play();
			}
		}
	}
	public enum VoipMuteState : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MUTED")]
		Muted,
		[Description("UNMUTED")]
		Unmuted
	}
	public class VoipPCMSourceNative : IVoipPCMSource
	{
		private ulong senderID;

		public int GetPCM(float[] dest, int length)
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMFloat(senderID, dest, (UIntPtr)(ulong)length);
		}

		public void SetSenderID(ulong senderID)
		{
			this.senderID = senderID;
		}

		public int PeekSizeElements()
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMSize(senderID);
		}

		public void Update()
		{
		}
	}
	public enum VoipSampleRate : uint
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("HZ24000")]
		HZ24000,
		[Description("HZ44100")]
		HZ44100,
		[Description("HZ48000")]
		HZ48000
	}
	public class WindowsPlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			UnityEngine.Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			CAPI.ovr_UnityInitWrapperWindows(appId, IntPtr.Zero);
			return true;
		}
	}
}
internal static class CustomTypes
{
	public static readonly byte[] memVector3 = new byte[12];

	public static readonly byte[] memVector2 = new byte[8];

	public static readonly byte[] memQuarternion = new byte[16];

	public static readonly byte[] memPlayer = new byte[4];

	internal static void Register()
	{
		PhotonPeer.RegisterType(typeof(Vector2), 87, SerializeVector2, DeserializeVector2);
		PhotonPeer.RegisterType(typeof(Vector3), 86, SerializeVector3, DeserializeVector3);
		PhotonPeer.RegisterType(typeof(Quaternion), 81, SerializeQuaternion, DeserializeQuaternion);
		PhotonPeer.RegisterType(typeof(PhotonPlayer), 80, SerializePhotonPlayer, DeserializePhotonPlayer);
	}

	private static short SerializeVector3(StreamBuffer outStream, object customobject)
	{
		Vector3 vector = (Vector3)customobject;
		int targetOffset = 0;
		lock (memVector3)
		{
			byte[] array = memVector3;
			Protocol.Serialize(vector.x, array, ref targetOffset);
			Protocol.Serialize(vector.y, array, ref targetOffset);
			Protocol.Serialize(vector.z, array, ref targetOffset);
			outStream.Write(array, 0, 12);
		}
		return 12;
	}

	private static object DeserializeVector3(StreamBuffer inStream, short length)
	{
		Vector3 vector = default(Vector3);
		lock (memVector3)
		{
			inStream.Read(memVector3, 0, 12);
			int offset = 0;
			Protocol.Deserialize(out vector.x, memVector3, ref offset);
			Protocol.Deserialize(out vector.y, memVector3, ref offset);
			Protocol.Deserialize(out vector.z, memVector3, ref offset);
		}
		return vector;
	}

	private static short SerializeVector2(StreamBuffer outStream, object customobject)
	{
		Vector2 vector = (Vector2)customobject;
		lock (memVector2)
		{
			byte[] array = memVector2;
			int targetOffset = 0;
			Protocol.Serialize(vector.x, array, ref targetOffset);
			Protocol.Serialize(vector.y, array, ref targetOffset);
			outStream.Write(array, 0, 8);
		}
		return 8;
	}

	private static object DeserializeVector2(StreamBuffer inStream, short length)
	{
		Vector2 vector = default(Vector2);
		lock (memVector2)
		{
			inStream.Read(memVector2, 0, 8);
			int offset = 0;
			Protocol.Deserialize(out vector.x, memVector2, ref offset);
			Protocol.Deserialize(out vector.y, memVector2, ref offset);
		}
		return vector;
	}

	private static short SerializeQuaternion(StreamBuffer outStream, object customobject)
	{
		Quaternion quaternion = (Quaternion)customobject;
		lock (memQuarternion)
		{
			byte[] array = memQuarternion;
			int targetOffset = 0;
			Protocol.Serialize(quaternion.w, array, ref targetOffset);
			Protocol.Serialize(quaternion.x, array, ref targetOffset);
			Protocol.Serialize(quaternion.y, array, ref targetOffset);
			Protocol.Serialize(quaternion.z, array, ref targetOffset);
			outStream.Write(array, 0, 16);
		}
		return 16;
	}

	private static object DeserializeQuaternion(StreamBuffer inStream, short length)
	{
		Quaternion quaternion = default(Quaternion);
		lock (memQuarternion)
		{
			inStream.Read(memQuarternion, 0, 16);
			int offset = 0;
			Protocol.Deserialize(out quaternion.w, memQuarternion, ref offset);
			Protocol.Deserialize(out quaternion.x, memQuarternion, ref offset);
			Protocol.Deserialize(out quaternion.y, memQuarternion, ref offset);
			Protocol.Deserialize(out quaternion.z, memQuarternion, ref offset);
		}
		return quaternion;
	}

	private static short SerializePhotonPlayer(StreamBuffer outStream, object customobject)
	{
		int iD = ((PhotonPlayer)customobject).ID;
		lock (memPlayer)
		{
			byte[] array = memPlayer;
			int targetOffset = 0;
			Protocol.Serialize(iD, array, ref targetOffset);
			outStream.Write(array, 0, 4);
			return 4;
		}
	}

	private static object DeserializePhotonPlayer(StreamBuffer inStream, short length)
	{
		int value;
		lock (memPlayer)
		{
			inStream.Read(memPlayer, 0, length);
			int offset = 0;
			Protocol.Deserialize(out value, memPlayer, ref offset);
		}
		if (PhotonNetwork.networkingPeer.mActors.ContainsKey(value))
		{
			return PhotonNetwork.networkingPeer.mActors[value];
		}
		return null;
	}
}
public enum PhotonNetworkingMessage
{
	OnConnectedToPhoton,
	OnLeftRoom,
	OnMasterClientSwitched,
	OnPhotonCreateRoomFailed,
	OnPhotonJoinRoomFailed,
	OnCreatedRoom,
	OnJoinedLobby,
	OnLeftLobby,
	OnDisconnectedFromPhoton,
	OnConnectionFail,
	OnFailedToConnectToPhoton,
	OnReceivedRoomListUpdate,
	OnJoinedRoom,
	OnPhotonPlayerConnected,
	OnPhotonPlayerDisconnected,
	OnPhotonRandomJoinFailed,
	OnConnectedToMaster,
	OnPhotonSerializeView,
	OnPhotonInstantiate,
	OnPhotonMaxCccuReached,
	OnPhotonCustomRoomPropertiesChanged,
	OnPhotonPlayerPropertiesChanged,
	OnUpdatedFriendList,
	OnCustomAuthenticationFailed,
	OnCustomAuthenticationResponse,
	OnWebRpcResponse,
	OnOwnershipRequest,
	OnLobbyStatisticsUpdate,
	OnPhotonPlayerActivityChanged,
	OnOwnershipTransfered
}
public enum PhotonLogLevel
{
	ErrorsOnly,
	Informational,
	Full
}
public enum PhotonTargets
{
	All,
	Others,
	MasterClient,
	AllBuffered,
	OthersBuffered,
	AllViaServer,
	AllBufferedViaServer
}
public enum CloudRegionCode
{
	eu = 0,
	us = 1,
	asia = 2,
	jp = 3,
	au = 5,
	usw = 6,
	sa = 7,
	cae = 8,
	kr = 9,
	@in = 10,
	ru = 11,
	rue = 12,
	none = 4
}
[Flags]
public enum CloudRegionFlag
{
	eu = 1,
	us = 2,
	asia = 4,
	jp = 8,
	au = 0x10,
	usw = 0x20,
	sa = 0x40,
	cae = 0x80,
	kr = 0x100,
	@in = 0x200,
	ru = 0x400,
	rue = 0x800
}
public enum ConnectionState
{
	Disconnected,
	Connecting,
	Connected,
	Disconnecting,
	InitializingApplication
}
public enum EncryptionMode
{
	PayloadEncryption = 0,
	DatagramEncryption = 10
}
public static class EncryptionDataParameters
{
	public const byte Mode = 0;

	public const byte Secret1 = 1;

	public const byte Secret2 = 2;
}
public static class Extensions
{
	public static Dictionary<MethodInfo, ParameterInfo[]> ParametersOfMethods = new Dictionary<MethodInfo, ParameterInfo[]>();

	public static ParameterInfo[] GetCachedParemeters(this MethodInfo mo)
	{
		if (!ParametersOfMethods.TryGetValue(mo, out var value))
		{
			value = mo.GetParameters();
			ParametersOfMethods[mo] = value;
		}
		return value;
	}

	public static PhotonView[] GetPhotonViewsInChildren(this GameObject go)
	{
		return go.GetComponentsInChildren<PhotonView>(includeInactive: true);
	}

	public static PhotonView GetPhotonView(this GameObject go)
	{
		return go.GetComponent<PhotonView>();
	}

	public static bool AlmostEquals(this Vector3 target, Vector3 second, float sqrMagnitudePrecision)
	{
		return (target - second).sqrMagnitude < sqrMagnitudePrecision;
	}

	public static bool AlmostEquals(this Vector2 target, Vector2 second, float sqrMagnitudePrecision)
	{
		return (target - second).sqrMagnitude < sqrMagnitudePrecision;
	}

	public static bool AlmostEquals(this Quaternion target, Quaternion second, float maxAngle)
	{
		return Quaternion.Angle(target, second) < maxAngle;
	}

	public static bool AlmostEquals(this float target, float second, float floatDiff)
	{
		return Mathf.Abs(target - second) < floatDiff;
	}

	public static void Merge(this IDictionary target, IDictionary addHash)
	{
		if (addHash == null || target.Equals(addHash))
		{
			return;
		}
		foreach (object key in addHash.Keys)
		{
			target[key] = addHash[key];
		}
	}

	public static void MergeStringKeys(this IDictionary target, IDictionary addHash)
	{
		if (addHash == null || target.Equals(addHash))
		{
			return;
		}
		foreach (object key in addHash.Keys)
		{
			if (key is string)
			{
				target[key] = addHash[key];
			}
		}
	}

	public static string ToStringFull(this IDictionary origin)
	{
		return SupportClass.DictionaryToString(origin, includeTypes: false);
	}

	public static string ToStringFull(this object[] data)
	{
		if (data == null)
		{
			return "null";
		}
		string[] array = new string[data.Length];
		for (int i = 0; i < data.Length; i++)
		{
			object obj = data[i];
			array[i] = ((obj == null) ? "null" : obj.ToString());
		}
		return string.Join(", ", array);
	}

	public static ExitGames.Client.Photon.Hashtable StripToStringKeys(this IDictionary original)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		if (original != null)
		{
			foreach (object key in original.Keys)
			{
				if (key is string)
				{
					hashtable[key] = original[key];
				}
			}
		}
		return hashtable;
	}

	public static void StripKeysWithNullValues(this IDictionary original)
	{
		object[] array = new object[original.Count];
		int num = 0;
		foreach (object key2 in original.Keys)
		{
			array[num++] = key2;
		}
		foreach (object key in array)
		{
			if (original[key] == null)
			{
				original.Remove(key);
			}
		}
	}

	public static bool Contains(this int[] target, int nr)
	{
		if (target == null)
		{
			return false;
		}
		for (int i = 0; i < target.Length; i++)
		{
			if (target[i] == nr)
			{
				return true;
			}
		}
		return false;
	}
}
public static class GameObjectExtensions
{
	public static bool GetActive(this GameObject target)
	{
		return target.activeInHierarchy;
	}
}
public class FriendInfo
{
	[Obsolete("Use UserId.")]
	public string Name => UserId;

	public string UserId { get; protected internal set; }

	public bool IsOnline { get; protected internal set; }

	public string Room { get; protected internal set; }

	public bool IsInRoom => IsOnline && !string.IsNullOrEmpty(Room);

	public override string ToString()
	{
		return string.Format("{0}\t is: {1}", UserId, (!IsOnline) ? "offline" : ((!IsInRoom) ? "on master" : "playing"));
	}
}
namespace ExitGames.Client.GUI
{
	public enum GizmoType
	{
		WireSphere,
		Sphere,
		WireCube,
		Cube
	}
	public class GizmoTypeDrawer
	{
		public static void Draw(Vector3 center, GizmoType type, UnityEngine.Color color, float size)
		{
			Gizmos.color = color;
			switch (type)
			{
			case GizmoType.Cube:
				Gizmos.DrawCube(center, Vector3.one * size);
				break;
			case GizmoType.Sphere:
				Gizmos.DrawSphere(center, size * 0.5f);
				break;
			case GizmoType.WireCube:
				Gizmos.DrawWireCube(center, Vector3.one * size);
				break;
			case GizmoType.WireSphere:
				Gizmos.DrawWireSphere(center, size * 0.5f);
				break;
			}
		}
	}
}
internal class LoadBalancingPeer : PhotonPeer
{
	private enum RoomOptionBit
	{
		CheckUserOnJoin = 1,
		DeleteCacheOnLeave = 2,
		SuppressRoomEvents = 4,
		PublishUserId = 8,
		DeleteNullProps = 0x10,
		BroadcastPropsChangeToAll = 0x20
	}

	private readonly Dictionary<byte, object> opParameters = new Dictionary<byte, object>();

	internal bool IsProtocolSecure => base.UsedProtocol == ConnectionProtocol.WebSocketSecure;

	public LoadBalancingPeer(ConnectionProtocol protocolType)
		: base(protocolType)
	{
	}

	public LoadBalancingPeer(IPhotonPeerListener listener, ConnectionProtocol protocolType)
		: this(protocolType)
	{
		base.Listener = listener;
	}

	public virtual bool OpGetRegions(string appId)
	{
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		dictionary[224] = appId;
		return OpCustom(220, dictionary, sendReliable: true, 0, encrypt: true);
	}

	public virtual bool OpJoinLobby(TypedLobby lobby = null)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpJoinLobby()");
		}
		Dictionary<byte, object> dictionary = null;
		if (lobby != null && !lobby.IsDefault)
		{
			dictionary = new Dictionary<byte, object>();
			dictionary[213] = lobby.Name;
			dictionary[212] = (byte)lobby.Type;
		}
		return OpCustom(229, dictionary, sendReliable: true);
	}

	public virtual bool OpLeaveLobby()
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpLeaveLobby()");
		}
		return OpCustom(228, null, sendReliable: true);
	}

	private void RoomOptionsToOpParameters(Dictionary<byte, object> op, RoomOptions roomOptions)
	{
		if (roomOptions == null)
		{
			roomOptions = new RoomOptions();
		}
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)253] = roomOptions.IsOpen;
		hashtable[(byte)254] = roomOptions.IsVisible;
		hashtable[(byte)250] = ((roomOptions.CustomRoomPropertiesForLobby != null) ? roomOptions.CustomRoomPropertiesForLobby : new string[0]);
		hashtable.MergeStringKeys(roomOptions.CustomRoomProperties);
		if (roomOptions.MaxPlayers > 0)
		{
			hashtable[byte.MaxValue] = roomOptions.MaxPlayers;
		}
		op[248] = hashtable;
		int num = 0;
		op[241] = roomOptions.CleanupCacheOnLeave;
		if (roomOptions.CleanupCacheOnLeave)
		{
			num |= 2;
			hashtable[(byte)249] = true;
		}
		num |= 1;
		op[232] = true;
		if (roomOptions.PlayerTtl > 0 || roomOptions.PlayerTtl == -1)
		{
			op[235] = roomOptions.PlayerTtl;
		}
		if (roomOptions.EmptyRoomTtl > 0)
		{
			op[236] = roomOptions.EmptyRoomTtl;
		}
		if (roomOptions.SuppressRoomEvents)
		{
			num |= 4;
			op[237] = true;
		}
		if (roomOptions.Plugins != null)
		{
			op[204] = roomOptions.Plugins;
		}
		if (roomOptions.PublishUserId)
		{
			num |= 8;
			op[239] = true;
		}
		if (roomOptions.DeleteNullProperties)
		{
			num |= 0x10;
		}
		op[191] = num;
	}

	public virtual bool OpCreateRoom(EnterRoomParams opParams)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpCreateRoom()");
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		if (!string.IsNullOrEmpty(opParams.RoomName))
		{
			dictionary[byte.MaxValue] = opParams.RoomName;
		}
		if (opParams.Lobby != null && !string.IsNullOrEmpty(opParams.Lobby.Name))
		{
			dictionary[213] = opParams.Lobby.Name;
			dictionary[212] = (byte)opParams.Lobby.Type;
		}
		if (opParams.ExpectedUsers != null && opParams.ExpectedUsers.Length > 0)
		{
			dictionary[238] = opParams.ExpectedUsers;
		}
		if (opParams.OnGameServer)
		{
			if (opParams.PlayerProperties != null && opParams.PlayerProperties.Count > 0)
			{
				dictionary[249] = opParams.PlayerProperties;
				dictionary[250] = true;
			}
			RoomOptionsToOpParameters(dictionary, opParams.RoomOptions);
		}
		return OpCustom(227, dictionary, sendReliable: true);
	}

	public virtual bool OpJoinRoom(EnterRoomParams opParams)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpJoinRoom()");
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		if (!string.IsNullOrEmpty(opParams.RoomName))
		{
			dictionary[byte.MaxValue] = opParams.RoomName;
		}
		if (opParams.CreateIfNotExists)
		{
			dictionary[215] = (byte)1;
			if (opParams.Lobby != null)
			{
				dictionary[213] = opParams.Lobby.Name;
				dictionary[212] = (byte)opParams.Lobby.Type;
			}
		}
		if (opParams.RejoinOnly)
		{
			dictionary[215] = (byte)3;
		}
		if (opParams.ExpectedUsers != null && opParams.ExpectedUsers.Length > 0)
		{
			dictionary[238] = opParams.ExpectedUsers;
		}
		if (opParams.OnGameServer)
		{
			if (opParams.PlayerProperties != null && opParams.PlayerProperties.Count > 0)
			{
				dictionary[249] = opParams.PlayerProperties;
				dictionary[250] = true;
			}
			if (opParams.CreateIfNotExists)
			{
				RoomOptionsToOpParameters(dictionary, opParams.RoomOptions);
			}
		}
		return OpCustom(226, dictionary, sendReliable: true);
	}

	public virtual bool OpJoinRandomRoom(OpJoinRandomRoomParams opJoinRandomRoomParams)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpJoinRandomRoom()");
		}
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable.MergeStringKeys(opJoinRandomRoomParams.ExpectedCustomRoomProperties);
		if (opJoinRandomRoomParams.ExpectedMaxPlayers > 0)
		{
			hashtable[byte.MaxValue] = opJoinRandomRoomParams.ExpectedMaxPlayers;
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		if (hashtable.Count > 0)
		{
			dictionary[248] = hashtable;
		}
		if (opJoinRandomRoomParams.MatchingType != 0)
		{
			dictionary[223] = (byte)opJoinRandomRoomParams.MatchingType;
		}
		if (opJoinRandomRoomParams.TypedLobby != null && !string.IsNullOrEmpty(opJoinRandomRoomParams.TypedLobby.Name))
		{
			dictionary[213] = opJoinRandomRoomParams.TypedLobby.Name;
			dictionary[212] = (byte)opJoinRandomRoomParams.TypedLobby.Type;
		}
		if (!string.IsNullOrEmpty(opJoinRandomRoomParams.SqlLobbyFilter))
		{
			dictionary[245] = opJoinRandomRoomParams.SqlLobbyFilter;
		}
		if (opJoinRandomRoomParams.ExpectedUsers != null && opJoinRandomRoomParams.ExpectedUsers.Length > 0)
		{
			dictionary[238] = opJoinRandomRoomParams.ExpectedUsers;
		}
		return OpCustom(225, dictionary, sendReliable: true);
	}

	public virtual bool OpLeaveRoom(bool becomeInactive)
	{
		Dictionary<byte, object> dictionary = null;
		if (becomeInactive)
		{
			dictionary = new Dictionary<byte, object>();
			dictionary[233] = becomeInactive;
		}
		return OpCustom(254, dictionary, sendReliable: true);
	}

	public virtual bool OpGetGameList(TypedLobby lobby, string queryData)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpGetGameList()");
		}
		if (lobby == null)
		{
			if ((int)DebugOut >= 3)
			{
				base.Listener.DebugReturn(DebugLevel.INFO, "OpGetGameList not sent. Lobby cannot be null.");
			}
			return false;
		}
		if (lobby.Type != LobbyType.SqlLobby)
		{
			if ((int)DebugOut >= 3)
			{
				base.Listener.DebugReturn(DebugLevel.INFO, "OpGetGameList not sent. LobbyType must be SqlLobby.");
			}
			return false;
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		dictionary[213] = lobby.Name;
		dictionary[212] = (byte)lobby.Type;
		dictionary[245] = queryData;
		return OpCustom(217, dictionary, sendReliable: true);
	}

	public virtual bool OpFindFriends(string[] friendsToFind)
	{
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		if (friendsToFind != null && friendsToFind.Length > 0)
		{
			dictionary[1] = friendsToFind;
		}
		return OpCustom(222, dictionary, sendReliable: true);
	}

	public bool OpSetCustomPropertiesOfActor(int actorNr, ExitGames.Client.Photon.Hashtable actorProperties)
	{
		return OpSetPropertiesOfActor(actorNr, actorProperties.StripToStringKeys());
	}

	protected internal bool OpSetPropertiesOfActor(int actorNr, ExitGames.Client.Photon.Hashtable actorProperties, ExitGames.Client.Photon.Hashtable expectedProperties = null, bool webForward = false)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpSetPropertiesOfActor()");
		}
		if (actorNr <= 0 || actorProperties == null)
		{
			if ((int)DebugOut >= 3)
			{
				base.Listener.DebugReturn(DebugLevel.INFO, "OpSetPropertiesOfActor not sent. ActorNr must be > 0 and actorProperties != null.");
			}
			return false;
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		dictionary.Add(251, actorProperties);
		dictionary.Add(254, actorNr);
		dictionary.Add(250, true);
		if (expectedProperties != null && expectedProperties.Count != 0)
		{
			dictionary.Add(231, expectedProperties);
		}
		if (webForward)
		{
			dictionary[234] = true;
		}
		return OpCustom(252, dictionary, sendReliable: true, 0, encrypt: false);
	}

	protected internal void OpSetPropertyOfRoom(byte propCode, object value)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[propCode] = value;
		OpSetPropertiesOfRoom(hashtable);
	}

	public bool OpSetCustomPropertiesOfRoom(ExitGames.Client.Photon.Hashtable gameProperties, bool broadcast, byte channelId)
	{
		return OpSetPropertiesOfRoom(gameProperties.StripToStringKeys());
	}

	protected internal bool OpSetPropertiesOfRoom(ExitGames.Client.Photon.Hashtable gameProperties, ExitGames.Client.Photon.Hashtable expectedProperties = null, bool webForward = false)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpSetPropertiesOfRoom()");
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		dictionary.Add(251, gameProperties);
		dictionary.Add(250, true);
		if (expectedProperties != null && expectedProperties.Count != 0)
		{
			dictionary.Add(231, expectedProperties);
		}
		if (webForward)
		{
			dictionary[234] = true;
		}
		return OpCustom(252, dictionary, sendReliable: true, 0, encrypt: false);
	}

	public virtual bool OpAuthenticate(string appId, string appVersion, AuthenticationValues authValues, string regionCode, bool getLobbyStatistics)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpAuthenticate()");
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		if (getLobbyStatistics)
		{
			dictionary[211] = true;
		}
		if (authValues != null && authValues.Token != null)
		{
			dictionary[221] = authValues.Token;
			return OpCustom(230, dictionary, sendReliable: true, 0, encrypt: false);
		}
		dictionary[220] = appVersion;
		dictionary[224] = appId;
		if (!string.IsNullOrEmpty(regionCode))
		{
			dictionary[210] = regionCode;
		}
		if (authValues != null)
		{
			if (!string.IsNullOrEmpty(authValues.UserId))
			{
				dictionary[225] = authValues.UserId;
			}
			if (authValues.AuthType != CustomAuthenticationType.None)
			{
				if (!IsProtocolSecure && !base.IsEncryptionAvailable)
				{
					base.Listener.DebugReturn(DebugLevel.ERROR, "OpAuthenticate() failed. When you want Custom Authentication encryption is mandatory.");
					return false;
				}
				dictionary[217] = (byte)authValues.AuthType;
				if (!string.IsNullOrEmpty(authValues.Token))
				{
					dictionary[221] = authValues.Token;
				}
				else
				{
					if (!string.IsNullOrEmpty(authValues.AuthGetParameters))
					{
						dictionary[216] = authValues.AuthGetParameters;
					}
					if (authValues.AuthPostData != null)
					{
						dictionary[214] = authValues.AuthPostData;
					}
				}
			}
		}
		bool flag = OpCustom(230, dictionary, sendReliable: true, 0, base.IsEncryptionAvailable);
		if (!flag)
		{
			base.Listener.DebugReturn(DebugLevel.ERROR, "Error calling OpAuthenticate! Did not work. Check log output, AuthValues and if you're connected.");
		}
		return flag;
	}

	public virtual bool OpAuthenticateOnce(string appId, string appVersion, AuthenticationValues authValues, string regionCode, EncryptionMode encryptionMode, ConnectionProtocol expectedProtocol)
	{
		if ((int)DebugOut >= 3)
		{
			base.Listener.DebugReturn(DebugLevel.INFO, "OpAuthenticate()");
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		if (authValues != null && authValues.Token != null)
		{
			dictionary[221] = authValues.Token;
			return OpCustom(231, dictionary, sendReliable: true, 0, encrypt: false);
		}
		if (encryptionMode == EncryptionMode.DatagramEncryption && expectedProtocol != 0)
		{
			UnityEngine.Debug.LogWarning("Expected protocol set to UDP, due to encryption mode DatagramEncryption. Changing protocol in PhotonServerSettings from: " + PhotonNetwork.PhotonServerSettings.Protocol);
			PhotonNetwork.PhotonServerSettings.Protocol = ConnectionProtocol.Udp;
			expectedProtocol = ConnectionProtocol.Udp;
		}
		dictionary[195] = (byte)expectedProtocol;
		dictionary[193] = (byte)encryptionMode;
		dictionary[220] = appVersion;
		dictionary[224] = appId;
		if (!string.IsNullOrEmpty(regionCode))
		{
			dictionary[210] = regionCode;
		}
		if (authValues != null)
		{
			if (!string.IsNullOrEmpty(authValues.UserId))
			{
				dictionary[225] = authValues.UserId;
			}
			if (authValues.AuthType != CustomAuthenticationType.None)
			{
				dictionary[217] = (byte)authValues.AuthType;
				if (!string.IsNullOrEmpty(authValues.Token))
				{
					dictionary[221] = authValues.Token;
				}
				else
				{
					if (!string.IsNullOrEmpty(authValues.AuthGetParameters))
					{
						dictionary[216] = authValues.AuthGetParameters;
					}
					if (authValues.AuthPostData != null)
					{
						dictionary[214] = authValues.AuthPostData;
					}
				}
			}
		}
		return OpCustom(231, dictionary, sendReliable: true, 0, base.IsEncryptionAvailable);
	}

	public virtual bool OpChangeGroups(byte[] groupsToRemove, byte[] groupsToAdd)
	{
		if ((int)DebugOut >= 5)
		{
			base.Listener.DebugReturn(DebugLevel.ALL, "OpChangeGroups()");
		}
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		if (groupsToRemove != null)
		{
			dictionary[239] = groupsToRemove;
		}
		if (groupsToAdd != null)
		{
			dictionary[238] = groupsToAdd;
		}
		return OpCustom(248, dictionary, sendReliable: true, 0);
	}

	public virtual bool OpRaiseEvent(byte eventCode, object customEventContent, bool sendReliable, RaiseEventOptions raiseEventOptions)
	{
		opParameters.Clear();
		opParameters[244] = eventCode;
		if (customEventContent != null)
		{
			opParameters[245] = customEventContent;
		}
		if (raiseEventOptions == null)
		{
			raiseEventOptions = RaiseEventOptions.Default;
		}
		else
		{
			if (raiseEventOptions.CachingOption != 0)
			{
				opParameters[247] = (byte)raiseEventOptions.CachingOption;
			}
			if (raiseEventOptions.Receivers != 0)
			{
				opParameters[246] = (byte)raiseEventOptions.Receivers;
			}
			if (raiseEventOptions.InterestGroup != 0)
			{
				opParameters[240] = raiseEventOptions.InterestGroup;
			}
			if (raiseEventOptions.TargetActors != null)
			{
				opParameters[252] = raiseEventOptions.TargetActors;
			}
			if (raiseEventOptions.ForwardToWebhook)
			{
				opParameters[234] = true;
			}
		}
		return OpCustom(253, opParameters, sendReliable, raiseEventOptions.SequenceChannel, raiseEventOptions.Encrypt);
	}

	public virtual bool OpSettings(bool receiveLobbyStats)
	{
		if ((int)DebugOut >= 5)
		{
			base.Listener.DebugReturn(DebugLevel.ALL, "OpSettings()");
		}
		opParameters.Clear();
		if (receiveLobbyStats)
		{
			opParameters[0] = receiveLobbyStats;
		}
		if (opParameters.Count == 0)
		{
			return true;
		}
		return OpCustom(218, opParameters, sendReliable: true);
	}
}
internal class OpJoinRandomRoomParams
{
	public ExitGames.Client.Photon.Hashtable ExpectedCustomRoomProperties;

	public byte ExpectedMaxPlayers;

	public MatchmakingMode MatchingType;

	public TypedLobby TypedLobby;

	public string SqlLobbyFilter;

	public string[] ExpectedUsers;
}
internal class EnterRoomParams
{
	public string RoomName;

	public RoomOptions RoomOptions;

	public TypedLobby Lobby;

	public ExitGames.Client.Photon.Hashtable PlayerProperties;

	public bool OnGameServer = true;

	public bool CreateIfNotExists;

	public bool RejoinOnly;

	public string[] ExpectedUsers;
}
public class ErrorCode
{
	public const int Ok = 0;

	public const int OperationNotAllowedInCurrentState = -3;

	[Obsolete("Use InvalidOperation.")]
	public const int InvalidOperationCode = -2;

	public const int InvalidOperation = -2;

	public const int InternalServerError = -1;

	public const int InvalidAuthentication = 32767;

	public const int GameIdAlreadyExists = 32766;

	public const int GameFull = 32765;

	public const int GameClosed = 32764;

	[Obsolete("No longer used, cause random matchmaking is no longer a process.")]
	public const int AlreadyMatched = 32763;

	public const int ServerFull = 32762;

	public const int UserBlocked = 32761;

	public const int NoRandomMatchFound = 32760;

	public const int GameDoesNotExist = 32758;

	public const int MaxCcuReached = 32757;

	public const int InvalidRegion = 32756;

	public const int CustomAuthenticationFailed = 32755;

	public const int AuthenticationTicketExpired = 32753;

	public const int PluginReportedError = 32752;

	public const int PluginMismatch = 32751;

	public const int JoinFailedPeerAlreadyJoined = 32750;

	public const int JoinFailedFoundInactiveJoiner = 32749;

	public const int JoinFailedWithRejoinerNotFound = 32748;

	public const int JoinFailedFoundExcludedUserId = 32747;

	public const int JoinFailedFoundActiveJoiner = 32746;

	public const int HttpLimitReached = 32745;

	public const int ExternalHttpCallFailed = 32744;

	public const int SlotError = 32742;

	public const int InvalidEncryptionParameters = 32741;
}
public class ActorProperties
{
	public const byte PlayerName = byte.MaxValue;

	public const byte IsInactive = 254;

	public const byte UserId = 253;
}
public class GamePropertyKey
{
	public const byte MaxPlayers = byte.MaxValue;

	public const byte IsVisible = 254;

	public const byte IsOpen = 253;

	public const byte PlayerCount = 252;

	public const byte Removed = 251;

	public const byte PropsListedInLobby = 250;

	public const byte CleanupCacheOnLeave = 249;

	public const byte MasterClientId = 248;

	public const byte ExpectedUsers = 247;

	public const byte PlayerTtl = 246;

	public const byte EmptyRoomTtl = 245;
}
public class EventCode
{
	public const byte GameList = 230;

	public const byte GameListUpdate = 229;

	public const byte QueueState = 228;

	public const byte Match = 227;

	public const byte AppStats = 226;

	public const byte LobbyStats = 224;

	[Obsolete("TCP routing was removed after becoming obsolete.")]
	public const byte AzureNodeInfo = 210;

	public const byte Join = byte.MaxValue;

	public const byte Leave = 254;

	public const byte PropertiesChanged = 253;

	[Obsolete("Use PropertiesChanged now.")]
	public const byte SetProperties = 253;

	public const byte ErrorInfo = 251;

	public const byte CacheSliceChanged = 250;

	public const byte AuthEvent = 223;
}
public class ParameterCode
{
	public const byte SuppressRoomEvents = 237;

	public const byte EmptyRoomTTL = 236;

	public const byte PlayerTTL = 235;

	public const byte EventForward = 234;

	[Obsolete("Use: IsInactive")]
	public const byte IsComingBack = 233;

	public const byte IsInactive = 233;

	public const byte CheckUserOnJoin = 232;

	public const byte ExpectedValues = 231;

	public const byte Address = 230;

	public const byte PeerCount = 229;

	public const byte GameCount = 228;

	public const byte MasterPeerCount = 227;

	public const byte UserId = 225;

	public const byte ApplicationId = 224;

	public const byte Position = 223;

	public const byte MatchMakingType = 223;

	public const byte GameList = 222;

	public const byte Secret = 221;

	public const byte AppVersion = 220;

	[Obsolete("TCP routing was removed after becoming obsolete.")]
	public const byte AzureNodeInfo = 210;

	[Obsolete("TCP routing was removed after becoming obsolete.")]
	public const byte AzureLocalNodeId = 209;

	[Obsolete("TCP routing was removed after becoming obsolete.")]
	public const byte AzureMasterNodeId = 208;

	public const byte RoomName = byte.MaxValue;

	public const byte Broadcast = 250;

	public const byte ActorList = 252;

	public const byte ActorNr = 254;

	public const byte PlayerProperties = 249;

	public const byte CustomEventContent = 245;

	public const byte Data = 245;

	public const byte Code = 244;

	public const byte GameProperties = 248;

	public const byte Properties = 251;

	public const byte TargetActorNr = 253;

	public const byte ReceiverGroup = 246;

	public const byte Cache = 247;

	public const byte CleanupCacheOnLeave = 241;

	public const byte Group = 240;

	public const byte Remove = 239;

	public const byte PublishUserId = 239;

	public const byte Add = 238;

	public const byte Info = 218;

	public const byte ClientAuthenticationType = 217;

	public const byte ClientAuthenticationParams = 216;

	public const byte JoinMode = 215;

	public const byte ClientAuthenticationData = 214;

	public const byte MasterClientId = 203;

	public const byte FindFriendsRequestList = 1;

	public const byte FindFriendsResponseOnlineList = 1;

	public const byte FindFriendsResponseRoomIdList = 2;

	public const byte LobbyName = 213;

	public const byte LobbyType = 212;

	public const byte LobbyStats = 211;

	public const byte Region = 210;

	public const byte UriPath = 209;

	public const byte WebRpcParameters = 208;

	public const byte WebRpcReturnCode = 207;

	public const byte WebRpcReturnMessage = 206;

	public const byte CacheSliceIndex = 205;

	public const byte Plugins = 204;

	public const byte NickName = 202;

	public const byte PluginName = 201;

	public const byte PluginVersion = 200;

	public const byte ExpectedProtocol = 195;

	public const byte CustomInitData = 194;

	public const byte EncryptionMode = 193;

	public const byte EncryptionData = 192;

	public const byte RoomOptionFlags = 191;
}
public class OperationCode
{
	[Obsolete("Exchanging encrpytion keys is done internally in the lib now. Don't expect this operation-result.")]
	public const byte ExchangeKeysForEncryption = 250;

	[Obsolete]
	public const byte Join = byte.MaxValue;

	public const byte AuthenticateOnce = 231;

	public const byte Authenticate = 230;

	public const byte JoinLobby = 229;

	public const byte LeaveLobby = 228;

	public const byte CreateGame = 227;

	public const byte JoinGame = 226;

	public const byte JoinRandomGame = 225;

	public const byte Leave = 254;

	public const byte RaiseEvent = 253;

	public const byte SetProperties = 252;

	public const byte GetProperties = 251;

	public const byte ChangeGroups = 248;

	public const byte FindFriends = 222;

	public const byte GetLobbyStats = 221;

	public const byte GetRegions = 220;

	public const byte WebRpc = 219;

	public const byte ServerSettings = 218;

	public const byte GetGameList = 217;
}
public enum JoinMode : byte
{
	Default,
	CreateIfNotExists,
	JoinOrRejoin,
	RejoinOnly
}
public enum MatchmakingMode : byte
{
	FillRoom,
	SerialMatching,
	RandomMatching
}
public enum ReceiverGroup : byte
{
	Others,
	All,
	MasterClient
}
public enum EventCaching : byte
{
	DoNotCache = 0,
	[Obsolete]
	MergeCache = 1,
	[Obsolete]
	ReplaceCache = 2,
	[Obsolete]
	RemoveCache = 3,
	AddToRoomCache = 4,
	AddToRoomCacheGlobal = 5,
	RemoveFromRoomCache = 6,
	RemoveFromRoomCacheForActorsLeft = 7,
	SliceIncreaseIndex = 10,
	SliceSetIndex = 11,
	SlicePurgeIndex = 12,
	SlicePurgeUpToIndex = 13
}
[Flags]
public enum PropertyTypeFlag : byte
{
	None = 0,
	Game = 1,
	Actor = 2,
	GameAndActor = 3
}
public class RoomOptions
{
	private bool isVisibleField = true;

	private bool isOpenField = true;

	public byte MaxPlayers;

	public int PlayerTtl;

	public int EmptyRoomTtl;

	private bool cleanupCacheOnLeaveField = PhotonNetwork.autoCleanUpPlayerObjects;

	public ExitGames.Client.Photon.Hashtable CustomRoomProperties;

	public string[] CustomRoomPropertiesForLobby = new string[0];

	public string[] Plugins;

	private bool suppressRoomEventsField;

	private bool publishUserIdField;

	private bool deleteNullPropertiesField;

	public bool IsVisible
	{
		get
		{
			return isVisibleField;
		}
		set
		{
			isVisibleField = value;
		}
	}

	public bool IsOpen
	{
		get
		{
			return isOpenField;
		}
		set
		{
			isOpenField = value;
		}
	}

	public bool CleanupCacheOnLeave
	{
		get
		{
			return cleanupCacheOnLeaveField;
		}
		set
		{
			cleanupCacheOnLeaveField = value;
		}
	}

	public bool SuppressRoomEvents => suppressRoomEventsField;

	public bool PublishUserId
	{
		get
		{
			return publishUserIdField;
		}
		set
		{
			publishUserIdField = value;
		}
	}

	public bool DeleteNullProperties
	{
		get
		{
			return deleteNullPropertiesField;
		}
		set
		{
			deleteNullPropertiesField = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public bool isVisible
	{
		get
		{
			return isVisibleField;
		}
		set
		{
			isVisibleField = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public bool isOpen
	{
		get
		{
			return isOpenField;
		}
		set
		{
			isOpenField = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public byte maxPlayers
	{
		get
		{
			return MaxPlayers;
		}
		set
		{
			MaxPlayers = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public bool cleanupCacheOnLeave
	{
		get
		{
			return cleanupCacheOnLeaveField;
		}
		set
		{
			cleanupCacheOnLeaveField = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public ExitGames.Client.Photon.Hashtable customRoomProperties
	{
		get
		{
			return CustomRoomProperties;
		}
		set
		{
			CustomRoomProperties = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public string[] customRoomPropertiesForLobby
	{
		get
		{
			return CustomRoomPropertiesForLobby;
		}
		set
		{
			CustomRoomPropertiesForLobby = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public string[] plugins
	{
		get
		{
			return Plugins;
		}
		set
		{
			Plugins = value;
		}
	}

	[Obsolete("Use property with uppercase naming instead.")]
	public bool suppressRoomEvents => suppressRoomEventsField;

	[Obsolete("Use property with uppercase naming instead.")]
	public bool publishUserId
	{
		get
		{
			return publishUserIdField;
		}
		set
		{
			publishUserIdField = value;
		}
	}
}
public class RaiseEventOptions
{
	public static readonly RaiseEventOptions Default = new RaiseEventOptions();

	public EventCaching CachingOption;

	public byte InterestGroup;

	public int[] TargetActors;

	public ReceiverGroup Receivers;

	public byte SequenceChannel;

	public bool ForwardToWebhook;

	public bool Encrypt;

	public void Reset()
	{
		CachingOption = Default.CachingOption;
		InterestGroup = Default.InterestGroup;
		TargetActors = Default.TargetActors;
		Receivers = Default.Receivers;
		SequenceChannel = Default.SequenceChannel;
		ForwardToWebhook = Default.ForwardToWebhook;
		Encrypt = Default.Encrypt;
	}
}
public enum LobbyType : byte
{
	Default = 0,
	SqlLobby = 2,
	AsyncRandomLobby = 3
}
public class TypedLobby
{
	public string Name;

	public LobbyType Type;

	public static readonly TypedLobby Default = new TypedLobby();

	public bool IsDefault => Type == LobbyType.Default && string.IsNullOrEmpty(Name);

	public TypedLobby()
	{
		Name = string.Empty;
		Type = LobbyType.Default;
	}

	public TypedLobby(string name, LobbyType type)
	{
		Name = name;
		Type = type;
	}

	public override string ToString()
	{
		return $"lobby '{Name}'[{Type}]";
	}
}
public class TypedLobbyInfo : TypedLobby
{
	public int PlayerCount;

	public int RoomCount;

	public override string ToString()
	{
		return $"TypedLobbyInfo '{Name}'[{Type}] rooms: {RoomCount} players: {PlayerCount}";
	}
}
public enum AuthModeOption
{
	Auth,
	AuthOnce,
	AuthOnceWss
}
public enum CustomAuthenticationType : byte
{
	Custom = 0,
	Steam = 1,
	Facebook = 2,
	Oculus = 3,
	PlayStation = 4,
	Xbox = 5,
	None = byte.MaxValue
}
public class AuthenticationValues
{
	private CustomAuthenticationType authType = CustomAuthenticationType.None;

	public CustomAuthenticationType AuthType
	{
		get
		{
			return authType;
		}
		set
		{
			authType = value;
		}
	}

	public string AuthGetParameters { get; set; }

	public object AuthPostData { get; private set; }

	public string Token { get; set; }

	public string UserId { get; set; }

	public AuthenticationValues()
	{
	}

	public AuthenticationValues(string userId)
	{
		UserId = userId;
	}

	public virtual void SetAuthPostData(string stringData)
	{
		AuthPostData = ((!string.IsNullOrEmpty(stringData)) ? stringData : null);
	}

	public virtual void SetAuthPostData(byte[] byteData)
	{
		AuthPostData = byteData;
	}

	public virtual void SetAuthPostData(Dictionary<string, object> dictData)
	{
		AuthPostData = dictData;
	}

	public virtual void AddAuthParameter(string key, string value)
	{
		string text = ((!string.IsNullOrEmpty(AuthGetParameters)) ? "&" : string.Empty);
		AuthGetParameters = $"{AuthGetParameters}{text}{Uri.EscapeDataString(key)}={Uri.EscapeDataString(value)}";
	}

	public override string ToString()
	{
		return $"AuthenticationValues UserId: {UserId}, GetParameters: {AuthGetParameters} Token available: {Token != null}";
	}
}
public enum ClientState
{
	Uninitialized,
	PeerCreated,
	Queued,
	Authenticated,
	JoinedLobby,
	DisconnectingFromMasterserver,
	ConnectingToGameserver,
	ConnectedToGameserver,
	Joining,
	Joined,
	Leaving,
	DisconnectingFromGameserver,
	ConnectingToMasterserver,
	QueuedComingFromGameserver,
	Disconnecting,
	Disconnected,
	ConnectedToMaster,
	ConnectingToNameServer,
	ConnectedToNameServer,
	DisconnectingFromNameServer,
	Authenticating
}
internal enum JoinType
{
	CreateRoom,
	JoinRoom,
	JoinRandomRoom,
	JoinOrCreateRoom
}
public enum DisconnectCause
{
	DisconnectByServerUserLimit = 1042,
	ExceptionOnConnect = 1023,
	DisconnectByServerTimeout = 1041,
	DisconnectByServerLogic = 1043,
	Exception = 1026,
	InvalidAuthentication = 32767,
	MaxCcuReached = 32757,
	InvalidRegion = 32756,
	SecurityExceptionOnConnect = 1022,
	DisconnectByClientTimeout = 1040,
	InternalReceiveException = 1039,
	AuthenticationTicketExpired = 32753
}
public enum ServerConnection
{
	MasterServer,
	GameServer,
	NameServer
}
internal class NetworkingPeer : LoadBalancingPeer, IPhotonPeerListener
{
	protected internal string AppId;

	private string tokenCache;

	public AuthModeOption AuthMode;

	public EncryptionMode EncryptionMode;

	public const string NameServerHost = "ns.exitgames.com";

	public const string NameServerHttp = "http://ns.exitgamescloud.com:80/photon/n";

	private static readonly Dictionary<ConnectionProtocol, int> ProtocolToNameServerPort = new Dictionary<ConnectionProtocol, int>
	{
		{
			ConnectionProtocol.Udp,
			5058
		},
		{
			ConnectionProtocol.Tcp,
			4533
		},
		{
			ConnectionProtocol.WebSocket,
			9093
		},
		{
			ConnectionProtocol.WebSocketSecure,
			19093
		}
	};

	public bool IsInitialConnect;

	public bool insideLobby;

	protected internal List<TypedLobbyInfo> LobbyStatistics = new List<TypedLobbyInfo>();

	public Dictionary<string, RoomInfo> mGameList = new Dictionary<string, RoomInfo>();

	public RoomInfo[] mGameListCopy = new RoomInfo[0];

	private string playername = string.Empty;

	private bool mPlayernameHasToBeUpdated;

	private Room currentRoom;

	private JoinType lastJoinType;

	protected internal EnterRoomParams enterRoomParamsCache;

	private bool didAuthenticate;

	private string[] friendListRequested;

	private int friendListTimestamp;

	private bool isFetchingFriendList;

	public Dictionary<int, PhotonPlayer> mActors = new Dictionary<int, PhotonPlayer>();

	public PhotonPlayer[] mOtherPlayerListCopy = new PhotonPlayer[0];

	public PhotonPlayer[] mPlayerListCopy = new PhotonPlayer[0];

	public bool hasSwitchedMC;

	private HashSet<byte> allowedReceivingGroups = new HashSet<byte>();

	private HashSet<byte> blockSendingGroups = new HashSet<byte>();

	protected internal Dictionary<int, PhotonView> photonViewList = new Dictionary<int, PhotonView>();

	private readonly PhotonStream readStream = new PhotonStream(write: false, null);

	private readonly PhotonStream pStream = new PhotonStream(write: true, null);

	private readonly Dictionary<int, ExitGames.Client.Photon.Hashtable> dataPerGroupReliable = new Dictionary<int, ExitGames.Client.Photon.Hashtable>();

	private readonly Dictionary<int, ExitGames.Client.Photon.Hashtable> dataPerGroupUnreliable = new Dictionary<int, ExitGames.Client.Photon.Hashtable>();

	protected internal short currentLevelPrefix;

	protected internal bool loadingLevelAndPausedNetwork;

	protected internal const string CurrentSceneProperty = "curScn";

	public static bool UsePrefabCache = true;

	internal IPunPrefabPool ObjectPool;

	public static Dictionary<string, GameObject> PrefabCache = new Dictionary<string, GameObject>();

	private Dictionary<Type, List<MethodInfo>> monoRPCMethodsCache = new Dictionary<Type, List<MethodInfo>>();

	private readonly Dictionary<string, int> rpcShortcuts;

	private static readonly string OnPhotonInstantiateString = PhotonNetworkingMessage.OnPhotonInstantiate.ToString();

	private string cachedServerAddress;

	private string cachedApplicationName;

	private ServerConnection cachedServerType;

	private bool _isReconnecting;

	private Dictionary<int, object[]> tempInstantiationData = new Dictionary<int, object[]>();

	public static int ObjectsInOneUpdate = 10;

	private RaiseEventOptions options = new RaiseEventOptions();

	public const int SyncViewId = 0;

	public const int SyncCompressed = 1;

	public const int SyncNullValues = 2;

	public const int SyncFirstValue = 3;

	protected internal string AppVersion => string.Format("{0}_{1}", PhotonNetwork.gameVersion, "1.88");

	public AuthenticationValues AuthValues { get; set; }

	private string TokenForInit
	{
		get
		{
			if (AuthMode == AuthModeOption.Auth)
			{
				return null;
			}
			return (AuthValues == null) ? null : AuthValues.Token;
		}
	}

	public bool IsUsingNameServer { get; protected internal set; }

	public string NameServerAddress => GetNameServerAddress();

	public string MasterServerAddress { get; protected internal set; }

	public string GameServerAddress { get; protected internal set; }

	protected internal ServerConnection Server { get; private set; }

	public ClientState State { get; internal set; }

	public TypedLobby lobby { get; set; }

	private bool requestLobbyStatistics => PhotonNetwork.EnableLobbyStatistics && Server == ServerConnection.MasterServer;

	public string PlayerName
	{
		get
		{
			return playername;
		}
		set
		{
			if (!string.IsNullOrEmpty(value) && !value.Equals(playername))
			{
				if (LocalPlayer != null)
				{
					LocalPlayer.NickName = value;
				}
				playername = value;
				if (CurrentRoom != null)
				{
					SendPlayerName();
				}
			}
		}
	}

	public Room CurrentRoom
	{
		get
		{
			if (currentRoom != null && currentRoom.IsLocalClientInside)
			{
				return currentRoom;
			}
			return null;
		}
		private set
		{
			currentRoom = value;
		}
	}

	public PhotonPlayer LocalPlayer { get; internal set; }

	public int PlayersOnMasterCount { get; internal set; }

	public int PlayersInRoomsCount { get; internal set; }

	public int RoomsCount { get; internal set; }

	protected internal int FriendListAge => (!isFetchingFriendList && friendListTimestamp != 0) ? (Environment.TickCount - friendListTimestamp) : 0;

	public bool IsAuthorizeSecretAvailable => AuthValues != null && !string.IsNullOrEmpty(AuthValues.Token);

	public List<Region> AvailableRegions { get; protected internal set; }

	public CloudRegionCode CloudRegion { get; protected internal set; }

	public int mMasterClientId
	{
		get
		{
			if (PhotonNetwork.offlineMode)
			{
				return LocalPlayer.ID;
			}
			return (CurrentRoom != null) ? CurrentRoom.MasterClientId : 0;
		}
		private set
		{
			if (CurrentRoom != null)
			{
				CurrentRoom.MasterClientId = value;
			}
		}
	}

	public NetworkingPeer(string playername, ConnectionProtocol connectionProtocol)
		: base(connectionProtocol)
	{
		base.Listener = this;
		base.LimitOfUnreliableCommands = 40;
		lobby = TypedLobby.Default;
		PlayerName = playername;
		LocalPlayer = new PhotonPlayer(isLocal: true, -1, this.playername);
		AddNewPlayer(LocalPlayer.ID, LocalPlayer);
		rpcShortcuts = new Dictionary<string, int>(PhotonNetwork.PhotonServerSettings.RpcList.Count);
		for (int i = 0; i < PhotonNetwork.PhotonServerSettings.RpcList.Count; i++)
		{
			string key = PhotonNetwork.PhotonServerSettings.RpcList[i];
			rpcShortcuts[key] = i;
		}
		State = ClientState.PeerCreated;
	}

	private string GetNameServerAddress()
	{
		ConnectionProtocol transportProtocol = base.TransportProtocol;
		int value = 0;
		ProtocolToNameServerPort.TryGetValue(transportProtocol, out value);
		string arg = string.Empty;
		switch (transportProtocol)
		{
		case ConnectionProtocol.WebSocket:
			arg = "ws://";
			break;
		case ConnectionProtocol.WebSocketSecure:
			arg = "wss://";
			break;
		}
		if (PhotonNetwork.UseAlternativeUdpPorts && base.TransportProtocol == ConnectionProtocol.Udp)
		{
			value = 27000;
		}
		return string.Format("{0}{1}:{2}", arg, "ns.exitgames.com", value);
	}

	public override bool Connect(string serverAddress, string applicationName)
	{
		UnityEngine.Debug.LogError("Avoid using this directly. Thanks.");
		return false;
	}

	public bool ReconnectToMaster()
	{
		if (AuthValues == null)
		{
			UnityEngine.Debug.LogWarning("ReconnectToMaster() with AuthValues == null is not correct!");
			AuthValues = new AuthenticationValues();
		}
		AuthValues.Token = tokenCache;
		return Connect(MasterServerAddress, ServerConnection.MasterServer);
	}

	public bool ReconnectAndRejoin()
	{
		if (AuthValues == null)
		{
			UnityEngine.Debug.LogWarning("ReconnectAndRejoin() with AuthValues == null is not correct!");
			AuthValues = new AuthenticationValues();
		}
		AuthValues.Token = tokenCache;
		if (!string.IsNullOrEmpty(GameServerAddress) && enterRoomParamsCache != null)
		{
			lastJoinType = JoinType.JoinRoom;
			enterRoomParamsCache.RejoinOnly = true;
			return Connect(GameServerAddress, ServerConnection.GameServer);
		}
		return false;
	}

	public bool Connect(string serverAddress, ServerConnection type)
	{
		if (PhotonHandler.AppQuits)
		{
			UnityEngine.Debug.LogWarning("Ignoring Connect() because app gets closed. If this is an error, check PhotonHandler.AppQuits.");
			return false;
		}
		if (State == ClientState.Disconnecting)
		{
			UnityEngine.Debug.LogError("Connect() failed. Can't connect while disconnecting (still). Current state: " + PhotonNetwork.connectionStateDetailed);
			return false;
		}
		cachedServerType = type;
		cachedServerAddress = serverAddress;
		cachedApplicationName = string.Empty;
		SetupProtocol(type);
		bool flag = base.Connect(serverAddress, string.Empty, TokenForInit);
		if (flag)
		{
			switch (type)
			{
			case ServerConnection.NameServer:
				State = ClientState.ConnectingToNameServer;
				break;
			case ServerConnection.MasterServer:
				State = ClientState.ConnectingToMasterserver;
				break;
			case ServerConnection.GameServer:
				State = ClientState.ConnectingToGameserver;
				break;
			}
		}
		return flag;
	}

	private bool Reconnect()
	{
		_isReconnecting = true;
		PhotonNetwork.SwitchToProtocol(PhotonNetwork.PhotonServerSettings.Protocol);
		SetupProtocol(cachedServerType);
		bool flag = base.Connect(cachedServerAddress, cachedApplicationName, TokenForInit);
		if (flag)
		{
			switch (cachedServerType)
			{
			case ServerConnection.NameServer:
				State = ClientState.ConnectingToNameServer;
				break;
			case ServerConnection.MasterServer:
				State = ClientState.ConnectingToMasterserver;
				break;
			case ServerConnection.GameServer:
				State = ClientState.ConnectingToGameserver;
				break;
			}
		}
		return flag;
	}

	public bool ConnectToNameServer()
	{
		if (PhotonHandler.AppQuits)
		{
			UnityEngine.Debug.LogWarning("Ignoring Connect() because app gets closed. If this is an error, check PhotonHandler.AppQuits.");
			return false;
		}
		IsUsingNameServer = true;
		CloudRegion = CloudRegionCode.none;
		if (State == ClientState.ConnectedToNameServer)
		{
			return true;
		}
		SetupProtocol(ServerConnection.NameServer);
		cachedServerType = ServerConnection.NameServer;
		cachedServerAddress = NameServerAddress;
		cachedApplicationName = "ns";
		if (!base.Connect(NameServerAddress, "ns", TokenForInit))
		{
			return false;
		}
		State = ClientState.ConnectingToNameServer;
		return true;
	}

	public bool ConnectToRegionMaster(CloudRegionCode region)
	{
		if (PhotonHandler.AppQuits)
		{
			UnityEngine.Debug.LogWarning("Ignoring Connect() because app gets closed. If this is an error, check PhotonHandler.AppQuits.");
			return false;
		}
		IsUsingNameServer = true;
		CloudRegion = region;
		if (State == ClientState.ConnectedToNameServer)
		{
			return CallAuthenticate();
		}
		cachedServerType = ServerConnection.NameServer;
		cachedServerAddress = NameServerAddress;
		cachedApplicationName = "ns";
		SetupProtocol(ServerConnection.NameServer);
		if (!base.Connect(NameServerAddress, "ns", TokenForInit))
		{
			return false;
		}
		State = ClientState.ConnectingToNameServer;
		return true;
	}

	protected internal void SetupProtocol(ServerConnection serverType)
	{
		ConnectionProtocol connectionProtocol = base.TransportProtocol;
		if (AuthMode == AuthModeOption.AuthOnceWss)
		{
			if (serverType != ServerConnection.NameServer)
			{
				if (PhotonNetwork.logLevel >= PhotonLogLevel.ErrorsOnly)
				{
					UnityEngine.Debug.LogWarning("Using PhotonServerSettings.Protocol when leaving the NameServer (AuthMode is AuthOnceWss): " + PhotonNetwork.PhotonServerSettings.Protocol);
				}
				connectionProtocol = PhotonNetwork.PhotonServerSettings.Protocol;
			}
			else
			{
				if (PhotonNetwork.logLevel >= PhotonLogLevel.ErrorsOnly)
				{
					UnityEngine.Debug.LogWarning("Using WebSocket to connect NameServer (AuthMode is AuthOnceWss).");
				}
				connectionProtocol = ConnectionProtocol.WebSocketSecure;
			}
		}
		Type type = null;
		type = Type.GetType("ExitGames.Client.Photon.SocketWebTcp, Assembly-CSharp", throwOnError: false);
		if (type == null)
		{
			type = Type.GetType("ExitGames.Client.Photon.SocketWebTcp, Assembly-CSharp-firstpass", throwOnError: false);
		}
		if (type != null)
		{
			SocketImplementationConfig[ConnectionProtocol.WebSocket] = type;
			SocketImplementationConfig[ConnectionProtocol.WebSocketSecure] = type;
		}
		if (PhotonHandler.PingImplementation == null)
		{
			PhotonHandler.PingImplementation = typeof(PingMono);
		}
		if (base.TransportProtocol != connectionProtocol)
		{
			if (PhotonNetwork.logLevel >= PhotonLogLevel.ErrorsOnly)
			{
				UnityEngine.Debug.LogWarning(string.Concat("Protocol switch from: ", base.TransportProtocol, " to: ", connectionProtocol, "."));
			}
			base.TransportProtocol = connectionProtocol;
		}
	}

	public override void Disconnect()
	{
		if (base.PeerState == PeerStateValue.Disconnected)
		{
			if (!PhotonHandler.AppQuits)
			{
				UnityEngine.Debug.LogWarning($"Can't execute Disconnect() while not connected. Nothing changed. State: {State}");
			}
		}
		else
		{
			State = ClientState.Disconnecting;
			base.Disconnect();
		}
	}

	private bool CallAuthenticate()
	{
		AuthenticationValues authenticationValues = AuthValues;
		if (authenticationValues == null)
		{
			AuthenticationValues authenticationValues2 = new AuthenticationValues();
			authenticationValues2.UserId = PlayerName;
			authenticationValues = authenticationValues2;
		}
		AuthenticationValues authValues = authenticationValues;
		if (AuthMode == AuthModeOption.Auth)
		{
			return OpAuthenticate(AppId, AppVersion, authValues, CloudRegion.ToString(), requestLobbyStatistics);
		}
		return OpAuthenticateOnce(AppId, AppVersion, authValues, CloudRegion.ToString(), EncryptionMode, PhotonNetwork.PhotonServerSettings.Protocol);
	}

	private void DisconnectToReconnect()
	{
		switch (Server)
		{
		case ServerConnection.NameServer:
			State = ClientState.DisconnectingFromNameServer;
			base.Disconnect();
			break;
		case ServerConnection.MasterServer:
			State = ClientState.DisconnectingFromMasterserver;
			base.Disconnect();
			break;
		case ServerConnection.GameServer:
			State = ClientState.DisconnectingFromGameserver;
			base.Disconnect();
			break;
		}
	}

	public bool GetRegions()
	{
		if (Server != ServerConnection.NameServer)
		{
			return false;
		}
		bool flag = OpGetRegions(AppId);
		if (flag)
		{
			AvailableRegions = null;
		}
		return flag;
	}

	public override bool OpFindFriends(string[] friendsToFind)
	{
		if (isFetchingFriendList)
		{
			return false;
		}
		friendListRequested = friendsToFind;
		isFetchingFriendList = true;
		return base.OpFindFriends(friendsToFind);
	}

	public bool OpCreateGame(EnterRoomParams enterRoomParams)
	{
		bool flag = (enterRoomParams.OnGameServer = Server == ServerConnection.GameServer);
		enterRoomParams.PlayerProperties = GetLocalActorProperties();
		if (!flag)
		{
			enterRoomParamsCache = enterRoomParams;
		}
		lastJoinType = JoinType.CreateRoom;
		return base.OpCreateRoom(enterRoomParams);
	}

	public override bool OpJoinRoom(EnterRoomParams opParams)
	{
		if (!(opParams.OnGameServer = Server == ServerConnection.GameServer))
		{
			enterRoomParamsCache = opParams;
		}
		lastJoinType = ((!opParams.CreateIfNotExists) ? JoinType.JoinRoom : JoinType.JoinOrCreateRoom);
		return base.OpJoinRoom(opParams);
	}

	public override bool OpJoinRandomRoom(OpJoinRandomRoomParams opJoinRandomRoomParams)
	{
		enterRoomParamsCache = new EnterRoomParams();
		enterRoomParamsCache.Lobby = opJoinRandomRoomParams.TypedLobby;
		enterRoomParamsCache.ExpectedUsers = opJoinRandomRoomParams.ExpectedUsers;
		lastJoinType = JoinType.JoinRandomRoom;
		return base.OpJoinRandomRoom(opJoinRandomRoomParams);
	}

	public override bool OpRaiseEvent(byte eventCode, object customEventContent, bool sendReliable, RaiseEventOptions raiseEventOptions)
	{
		if (PhotonNetwork.offlineMode)
		{
			return false;
		}
		return base.OpRaiseEvent(eventCode, customEventContent, sendReliable, raiseEventOptions);
	}

	private void ReadoutProperties(ExitGames.Client.Photon.Hashtable gameProperties, ExitGames.Client.Photon.Hashtable pActorProperties, int targetActorNr)
	{
		if (pActorProperties != null && pActorProperties.Count > 0)
		{
			if (targetActorNr > 0)
			{
				PhotonPlayer playerWithId = GetPlayerWithId(targetActorNr);
				if (playerWithId != null)
				{
					ExitGames.Client.Photon.Hashtable hashtable = ReadoutPropertiesForActorNr(pActorProperties, targetActorNr);
					playerWithId.InternalCacheProperties(hashtable);
					SendMonoMessage(PhotonNetworkingMessage.OnPhotonPlayerPropertiesChanged, playerWithId, hashtable);
				}
			}
			else
			{
				foreach (object key in pActorProperties.Keys)
				{
					int num = (int)key;
					ExitGames.Client.Photon.Hashtable hashtable2 = (ExitGames.Client.Photon.Hashtable)pActorProperties[key];
					string name = (string)hashtable2[byte.MaxValue];
					PhotonPlayer photonPlayer = GetPlayerWithId(num);
					if (photonPlayer == null)
					{
						photonPlayer = new PhotonPlayer(isLocal: false, num, name);
						AddNewPlayer(num, photonPlayer);
					}
					photonPlayer.InternalCacheProperties(hashtable2);
					SendMonoMessage(PhotonNetworkingMessage.OnPhotonPlayerPropertiesChanged, photonPlayer, hashtable2);
				}
			}
		}
		if (CurrentRoom != null && gameProperties != null)
		{
			CurrentRoom.InternalCacheProperties(gameProperties);
			SendMonoMessage(PhotonNetworkingMessage.OnPhotonCustomRoomPropertiesChanged, gameProperties);
			if (PhotonNetwork.automaticallySyncScene)
			{
				LoadLevelIfSynced();
			}
		}
	}

	private ExitGames.Client.Photon.Hashtable ReadoutPropertiesForActorNr(ExitGames.Client.Photon.Hashtable actorProperties, int actorNr)
	{
		if (actorProperties.ContainsKey(actorNr))
		{
			return (ExitGames.Client.Photon.Hashtable)actorProperties[actorNr];
		}
		return actorProperties;
	}

	public void ChangeLocalID(int newID)
	{
		if (LocalPlayer == null)
		{
			UnityEngine.Debug.LogWarning($"LocalPlayer is null or not in mActors! LocalPlayer: {LocalPlayer} mActors==null: {mActors == null} newID: {newID}");
		}
		if (mActors.ContainsKey(LocalPlayer.ID))
		{
			mActors.Remove(LocalPlayer.ID);
		}
		LocalPlayer.InternalChangeLocalID(newID);
		mActors[LocalPlayer.ID] = LocalPlayer;
		RebuildPlayerListCopies();
	}

	private void LeftLobbyCleanup()
	{
		mGameList = new Dictionary<string, RoomInfo>();
		mGameListCopy = new RoomInfo[0];
		if (insideLobby)
		{
			insideLobby = false;
			SendMonoMessage(PhotonNetworkingMessage.OnLeftLobby);
		}
	}

	private void LeftRoomCleanup()
	{
		bool flag = CurrentRoom != null;
		bool flag2 = ((CurrentRoom == null) ? PhotonNetwork.autoCleanUpPlayerObjects : CurrentRoom.AutoCleanUp);
		hasSwitchedMC = false;
		CurrentRoom = null;
		mActors = new Dictionary<int, PhotonPlayer>();
		mPlayerListCopy = new PhotonPlayer[0];
		mOtherPlayerListCopy = new PhotonPlayer[0];
		allowedReceivingGroups = new HashSet<byte>();
		blockSendingGroups = new HashSet<byte>();
		mGameList = new Dictionary<string, RoomInfo>();
		mGameListCopy = new RoomInfo[0];
		isFetchingFriendList = false;
		ChangeLocalID(-1);
		if (flag2)
		{
			LocalCleanupAnythingInstantiated(destroyInstantiatedGameObjects: true);
			PhotonNetwork.manuallyAllocatedViewIds = new List<int>();
		}
		if (flag)
		{
			SendMonoMessage(PhotonNetworkingMessage.OnLeftRoom);
		}
	}

	protected internal void LocalCleanupAnythingInstantiated(bool destroyInstantiatedGameObjects)
	{
		if (tempInstantiationData.Count > 0)
		{
			UnityEngine.Debug.LogWarning("It seems some instantiation is not completed, as instantiation data is used. You should make sure instantiations are paused when calling this method. Cleaning now, despite this.");
		}
		if (destroyInstantiatedGameObjects)
		{
			HashSet<GameObject> hashSet = new HashSet<GameObject>();
			foreach (PhotonView value in photonViewList.Values)
			{
				if (value.isRuntimeInstantiated)
				{
					hashSet.Add(value.gameObject);
				}
			}
			foreach (GameObject item in hashSet)
			{
				RemoveInstantiatedGO(item, localOnly: true);
			}
		}
		tempInstantiationData.Clear();
		PhotonNetwork.lastUsedViewSubId = 0;
		PhotonNetwork.lastUsedViewSubIdStatic = 0;
	}

	private void GameEnteredOnGameServer(OperationResponse operationResponse)
	{
		if (operationResponse.ReturnCode != 0)
		{
			switch (operationResponse.OperationCode)
			{
			case 227:
				if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
				{
					UnityEngine.Debug.Log("Create failed on GameServer. Changing back to MasterServer. Msg: " + operationResponse.DebugMessage);
				}
				SendMonoMessage(PhotonNetworkingMessage.OnPhotonCreateRoomFailed, operationResponse.ReturnCode, operationResponse.DebugMessage);
				break;
			case 226:
				if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
				{
					UnityEngine.Debug.Log("Join failed on GameServer. Changing back to MasterServer. Msg: " + operationResponse.DebugMessage);
					if (operationResponse.ReturnCode == 32758)
					{
						UnityEngine.Debug.Log("Most likely the game became empty during the switch to GameServer.");
					}
				}
				SendMonoMessage(PhotonNetworkingMessage.OnPhotonJoinRoomFailed, operationResponse.ReturnCode, operationResponse.DebugMessage);
				break;
			case 225:
				if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
				{
					UnityEngine.Debug.Log("Join failed on GameServer. Changing back to MasterServer. Msg: " + operationResponse.DebugMessage);
					if (operationResponse.ReturnCode == 32758)
					{
						UnityEngine.Debug.Log("Most likely the game became empty during the switch to GameServer.");
					}
				}
				SendMonoMessage(PhotonNetworkingMessage.OnPhotonRandomJoinFailed, operationResponse.ReturnCode, operationResponse.DebugMessage);
				break;
			}
			DisconnectToReconnect();
		}
		else
		{
			Room room = new Room(enterRoomParamsCache.RoomName, null);
			room.IsLocalClientInside = true;
			CurrentRoom = room;
			State = ClientState.Joined;
			if (operationResponse.Parameters.ContainsKey(252))
			{
				int[] actorsInRoom = (int[])operationResponse.Parameters[252];
				UpdatedActorList(actorsInRoom);
			}
			int newID = (int)operationResponse[254];
			ChangeLocalID(newID);
			ExitGames.Client.Photon.Hashtable pActorProperties = (ExitGames.Client.Photon.Hashtable)operationResponse[249];
			ExitGames.Client.Photon.Hashtable gameProperties = (ExitGames.Client.Photon.Hashtable)operationResponse[248];
			ReadoutProperties(gameProperties, pActorProperties, 0);
			if (!CurrentRoom.serverSideMasterClient)
			{
				CheckMasterClient(-1);
			}
			if (mPlayernameHasToBeUpdated)
			{
				SendPlayerName();
			}
			switch (operationResponse.OperationCode)
			{
			case 227:
				SendMonoMessage(PhotonNetworkingMessage.OnCreatedRoom);
				break;
			}
		}
	}

	private void AddNewPlayer(int ID, PhotonPlayer player)
	{
		if (!mActors.ContainsKey(ID))
		{
			mActors[ID] = player;
			RebuildPlayerListCopies();
		}
		else
		{
			UnityEngine.Debug.LogError("Adding player twice: " + ID);
		}
	}

	private void RemovePlayer(int ID, PhotonPlayer player)
	{
		mActors.Remove(ID);
		if (!player.IsLocal)
		{
			RebuildPlayerListCopies();
		}
	}

	private void RebuildPlayerListCopies()
	{
		mPlayerListCopy = new PhotonPlayer[mActors.Count];
		mActors.Values.CopyTo(mPlayerListCopy, 0);
		List<PhotonPlayer> list = new List<PhotonPlayer>();
		for (int i = 0; i < mPlayerListCopy.Length; i++)
		{
			PhotonPlayer photonPlayer = mPlayerListCopy[i];
			if (!photonPlayer.IsLocal)
			{
				list.Add(photonPlayer);
			}
		}
		mOtherPlayerListCopy = list.ToArray();
	}

	private void ResetPhotonViewsOnSerialize()
	{
		foreach (PhotonView value in photonViewList.Values)
		{
			value.lastOnSerializeDataSent = null;
		}
	}

	private void HandleEventLeave(int actorID, EventData evLeave)
	{
		if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
		{
			UnityEngine.Debug.Log("HandleEventLeave for player ID: " + actorID + " evLeave: " + evLeave.ToStringFull());
		}
		PhotonPlayer playerWithId = GetPlayerWithId(actorID);
		if (playerWithId == null)
		{
			UnityEngine.Debug.LogError($"Received event Leave for unknown player ID: {actorID}");
			return;
		}
		bool isInactive = playerWithId.IsInactive;
		if (evLeave.Parameters.ContainsKey(233))
		{
			playerWithId.IsInactive = (bool)evLeave.Parameters[233];
			if (playerWithId.IsInactive != isInactive)
			{
				SendMonoMessage(PhotonNetworkingMessage.OnPhotonPlayerActivityChanged, playerWithId);
			}
			if (playerWithId.IsInactive && isInactive)
			{
				UnityEngine.Debug.LogWarning("HandleEventLeave for player ID: " + actorID + " isInactive: " + playerWithId.IsInactive + ". Stopping handling if inactive.");
				return;
			}
		}
		if (evLeave.Parameters.ContainsKey(203))
		{
			if ((int)evLeave[203] != 0)
			{
				mMasterClientId = (int)evLeave[203];
				UpdateMasterClient();
			}
		}
		else if (!CurrentRoom.serverSideMasterClient)
		{
			CheckMasterClient(actorID);
		}
		if (!playerWithId.IsInactive || isInactive)
		{
			if (CurrentRoom != null && CurrentRoom.AutoCleanUp)
			{
				DestroyPlayerObjects(actorID, localOnly: true);
			}
			RemovePlayer(actorID, playerWithId);
			SendMonoMessage(PhotonNetworkingMessage.OnPhotonPlayerDisconnected, playerWithId);
		}
	}

	private void CheckMasterClient(int leavingPlayerId)
	{
		bool flag = mMasterClientId == leavingPlayerId;
		bool flag2 = leavingPlayerId > 0;
		if (flag2 && !flag)
		{
			return;
		}
		int num;
		if (mActors.Count <= 1)
		{
			num = LocalPlayer.ID;
		}
		else
		{
			num = int.MaxValue;
			foreach (int key in mActors.Keys)
			{
				if (key < num && key != leavingPlayerId)
				{
					num = key;
				}
			}
		}
		mMasterClientId = num;
		if (flag2)
		{
			SendMonoMessage(PhotonNetworkingMessage.OnMasterClientSwitched, GetPlayerWithId(num));
		}
	}

	protected internal void UpdateMasterClient()
	{
		SendMonoMessage(PhotonNetworkingMessage.OnMasterClientSwitched, PhotonNetwork.masterClient);
	}

	private static int ReturnLowestPlayerId(PhotonPlayer[] players, int playerIdToIgnore)
	{
		if (players == null || players.Length == 0)
		{
			return -1;
		}
		int num = int.MaxValue;
		foreach (PhotonPlayer photonPlayer in players)
		{
			if (photonPlayer.ID != playerIdToIgnore && photonPlayer.ID < num)
			{
				num = photonPlayer.ID;
			}
		}
		return num;
	}

	protected internal bool SetMasterClient(int playerId, bool sync)
	{
		if (mMasterClientId == playerId || !mActors.ContainsKey(playerId))
		{
			return false;
		}
		if (sync && !OpRaiseEvent(208, new ExitGames.Client.Photon.Hashtable { 
		{
			(byte)1,
			playerId
		} }, sendReliable: true, null))
		{
			return false;
		}
		hasSwitchedMC = true;
		CurrentRoom.MasterClientId = playerId;
		SendMonoMessage(PhotonNetworkingMessage.OnMasterClientSwitched, GetPlayerWithId(playerId));
		return true;
	}

	public bool SetMasterClient(int nextMasterId)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable.Add((byte)248, nextMasterId);
		ExitGames.Client.Photon.Hashtable gameProperties = hashtable;
		hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable.Add((byte)248, mMasterClientId);
		ExitGames.Client.Photon.Hashtable expectedProperties = hashtable;
		return OpSetPropertiesOfRoom(gameProperties, expectedProperties);
	}

	protected internal PhotonPlayer GetPlayerWithId(int number)
	{
		if (mActors == null)
		{
			return null;
		}
		PhotonPlayer value = null;
		mActors.TryGetValue(number, out value);
		return value;
	}

	private void SendPlayerName()
	{
		if (State == ClientState.Joining)
		{
			mPlayernameHasToBeUpdated = true;
		}
		else if (LocalPlayer != null)
		{
			LocalPlayer.NickName = PlayerName;
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable[byte.MaxValue] = PlayerName;
			if (LocalPlayer.ID > 0)
			{
				OpSetPropertiesOfActor(LocalPlayer.ID, hashtable);
				mPlayernameHasToBeUpdated = false;
			}
		}
	}

	private ExitGames.Client.Photon.Hashtable GetLocalActorProperties()
	{
		if (PhotonNetwork.player != null)
		{
			return PhotonNetwork.player.AllProperties;
		}
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[byte.MaxValue] = PlayerName;
		return hashtable;
	}

	public void DebugReturn(DebugLevel level, string message)
	{
		switch (level)
		{
		case DebugLevel.ERROR:
			UnityEngine.Debug.LogError(message);
			return;
		case DebugLevel.WARNING:
			UnityEngine.Debug.LogWarning(message);
			return;
		case DebugLevel.INFO:
			if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
			{
				UnityEngine.Debug.Log(message);
				return;
			}
			break;
		}
		if (level == DebugLevel.ALL && PhotonNetwork.logLevel == PhotonLogLevel.Full)
		{
			UnityEngine.Debug.Log(message);
		}
	}

	public void OnOperationResponse(OperationResponse operationResponse)
	{
		if (PhotonNetwork.networkingPeer.State == ClientState.Disconnecting)
		{
			if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
			{
				UnityEngine.Debug.Log("OperationResponse ignored while disconnecting. Code: " + operationResponse.OperationCode);
			}
			return;
		}
		if (operationResponse.ReturnCode == 0)
		{
			if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
			{
				UnityEngine.Debug.Log(operationResponse.ToString());
			}
		}
		else if (operationResponse.ReturnCode == -3)
		{
			UnityEngine.Debug.LogError("Operation " + operationResponse.OperationCode + " could not be executed (yet). Wait for state JoinedLobby or ConnectedToMaster and their callbacks before calling operations. WebRPCs need a server-side configuration. Enum OperationCode helps identify the operation.");
		}
		else if (operationResponse.ReturnCode == 32752)
		{
			UnityEngine.Debug.LogError("Operation " + operationResponse.OperationCode + " failed in a server-side plugin. Check the configuration in the Dashboard. Message from server-plugin: " + operationResponse.DebugMessage);
		}
		else if (operationResponse.ReturnCode == 32760)
		{
			UnityEngine.Debug.LogWarning("Operation failed: " + operationResponse.ToStringFull());
		}
		else
		{
			UnityEngine.Debug.LogError("Operation failed: " + operationResponse.ToStringFull() + " Server: " + Server);
		}
		if (operationResponse.Parameters.ContainsKey(221))
		{
			if (AuthValues == null)
			{
				AuthValues = new AuthenticationValues();
			}
			AuthValues.Token = operationResponse[221] as string;
			tokenCache = AuthValues.Token;
		}
		switch (operationResponse.OperationCode)
		{
		case 230:
		case 231:
			if (operationResponse.ReturnCode != 0)
			{
				if (operationResponse.ReturnCode == -2)
				{
					UnityEngine.Debug.LogError(string.Format("If you host Photon yourself, make sure to start the 'Instance LoadBalancing' " + base.ServerAddress));
				}
				else if (operationResponse.ReturnCode == short.MaxValue)
				{
					UnityEngine.Debug.LogError($"The appId this client sent is unknown on the server (Cloud). Check settings. If using the Cloud, check account.");
					SendMonoMessage(PhotonNetworkingMessage.OnFailedToConnectToPhoton, DisconnectCause.InvalidAuthentication);
				}
				else if (operationResponse.ReturnCode == 32755)
				{
					UnityEngine.Debug.LogError($"Custom Authentication failed (either due to user-input or configuration or AuthParameter string format). Calling: OnCustomAuthenticationFailed()");
					SendMonoMessage(PhotonNetworkingMessage.OnCustomAuthenticationFailed, operationResponse.DebugMessage);
				}
				else
				{
					UnityEngine.Debug.LogError($"Authentication failed: '{operationResponse.DebugMessage}' Code: {operationResponse.ReturnCode}");
				}
				State = ClientState.Disconnecting;
				Disconnect();
				if (operationResponse.ReturnCode == 32757)
				{
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						UnityEngine.Debug.LogWarning($"Currently, the limit of users is reached for this title. Try again later. Disconnecting");
					}
					SendMonoMessage(PhotonNetworkingMessage.OnPhotonMaxCccuReached);
					SendMonoMessage(PhotonNetworkingMessage.OnConnectionFail, DisconnectCause.MaxCcuReached);
				}
				else if (operationResponse.ReturnCode == 32756)
				{
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						UnityEngine.Debug.LogError($"The used master server address is not available with the subscription currently used. Got to Photon Cloud Dashboard or change URL. Disconnecting.");
					}
					SendMonoMessage(PhotonNetworkingMessage.OnConnectionFail, DisconnectCause.InvalidRegion);
				}
				else if (operationResponse.ReturnCode == 32753)
				{
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						UnityEngine.Debug.LogError($"The authentication ticket expired. You need to connect (and authenticate) again. Disconnecting.");
					}
					SendMonoMessage(PhotonNetworkingMessage.OnConnectionFail, DisconnectCause.AuthenticationTicketExpired);
				}
				break;
			}
			if (Server == ServerConnection.NameServer || Server == ServerConnection.MasterServer)
			{
				if (operationResponse.Parameters.ContainsKey(225))
				{
					string text4 = (string)operationResponse.Parameters[225];
					if (!string.IsNullOrEmpty(text4))
					{
						if (AuthValues == null)
						{
							AuthValues = new AuthenticationValues();
						}
						AuthValues.UserId = text4;
						PhotonNetwork.player.UserId = text4;
						if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
						{
							DebugReturn(DebugLevel.INFO, $"Received your UserID from server. Updating local value to: {text4}");
						}
					}
				}
				if (operationResponse.Parameters.ContainsKey(202))
				{
					PlayerName = (string)operationResponse.Parameters[202];
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						DebugReturn(DebugLevel.INFO, $"Received your NickName from server. Updating local value to: {playername}");
					}
				}
				if (operationResponse.Parameters.ContainsKey(192))
				{
					SetupEncryption((Dictionary<byte, object>)operationResponse.Parameters[192]);
				}
			}
			if (Server == ServerConnection.NameServer)
			{
				MasterServerAddress = operationResponse[230] as string;
				if (PhotonNetwork.UseAlternativeUdpPorts && base.TransportProtocol == ConnectionProtocol.Udp)
				{
					MasterServerAddress = MasterServerAddress.Replace("5058", "27000").Replace("5055", "27001").Replace("5056", "27002");
				}
				DisconnectToReconnect();
			}
			else if (Server == ServerConnection.MasterServer)
			{
				if (AuthMode != 0)
				{
					OpSettings(requestLobbyStatistics);
				}
				if (PhotonNetwork.autoJoinLobby)
				{
					State = ClientState.Authenticated;
					OpJoinLobby(lobby);
				}
				else
				{
					State = ClientState.ConnectedToMaster;
					SendMonoMessage(PhotonNetworkingMessage.OnConnectedToMaster);
				}
			}
			else if (Server == ServerConnection.GameServer)
			{
				State = ClientState.Joining;
				enterRoomParamsCache.PlayerProperties = GetLocalActorProperties();
				enterRoomParamsCache.OnGameServer = true;
				if (lastJoinType == JoinType.JoinRoom || lastJoinType == JoinType.JoinRandomRoom || lastJoinType == JoinType.JoinOrCreateRoom)
				{
					OpJoinRoom(enterRoomParamsCache);
				}
				else if (lastJoinType == JoinType.CreateRoom)
				{
					OpCreateGame(enterRoomParamsCache);
				}
			}
			if (operationResponse.Parameters.ContainsKey(245))
			{
				Dictionary<string, object> dictionary = (Dictionary<string, object>)operationResponse.Parameters[245];
				if (dictionary != null)
				{
					SendMonoMessage(PhotonNetworkingMessage.OnCustomAuthenticationResponse, dictionary);
				}
			}
			break;
		case 220:
		{
			if (operationResponse.ReturnCode == short.MaxValue)
			{
				UnityEngine.Debug.LogError($"The appId this client sent is unknown on the server (Cloud). Check settings. If using the Cloud, check account.");
				SendMonoMessage(PhotonNetworkingMessage.OnFailedToConnectToPhoton, DisconnectCause.InvalidAuthentication);
				State = ClientState.Disconnecting;
				Disconnect();
				break;
			}
			if (operationResponse.ReturnCode != 0)
			{
				UnityEngine.Debug.LogError("GetRegions failed. Can't provide regions list. Error: " + operationResponse.ReturnCode + ": " + operationResponse.DebugMessage);
				break;
			}
			string[] array3 = operationResponse[210] as string[];
			string[] array4 = operationResponse[230] as string[];
			if (array3 == null || array4 == null || array3.Length != array4.Length)
			{
				UnityEngine.Debug.LogError("The region arrays from Name Server are not ok. Must be non-null and same length. " + (array3 == null) + " " + (array4 == null) + "\n" + operationResponse.ToStringFull());
				break;
			}
			AvailableRegions = new List<Region>(array3.Length);
			for (int j = 0; j < array3.Length; j++)
			{
				string text2 = array3[j];
				if (string.IsNullOrEmpty(text2))
				{
					continue;
				}
				text2 = text2.ToLower();
				CloudRegionCode cloudRegionCode = Region.Parse(text2);
				bool flag = true;
				if (PhotonNetwork.PhotonServerSettings.HostType == ServerSettings.HostingOption.BestRegion && PhotonNetwork.PhotonServerSettings.EnabledRegions != 0)
				{
					CloudRegionFlag cloudRegionFlag = Region.ParseFlag(cloudRegionCode);
					flag = (PhotonNetwork.PhotonServerSettings.EnabledRegions & cloudRegionFlag) != 0;
					if (!flag && PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						UnityEngine.Debug.Log("Skipping region because it's not in PhotonServerSettings.EnabledRegions: " + cloudRegionCode);
					}
				}
				if (flag)
				{
					AvailableRegions.Add(new Region(cloudRegionCode, text2, array4[j]));
				}
			}
			if (PhotonNetwork.PhotonServerSettings.HostType == ServerSettings.HostingOption.BestRegion)
			{
				PhotonHandler.PingAvailableRegionsAndConnectToBest();
			}
			break;
		}
		case 227:
		{
			if (Server == ServerConnection.GameServer)
			{
				GameEnteredOnGameServer(operationResponse);
				break;
			}
			if (operationResponse.ReturnCode != 0)
			{
				if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
				{
					UnityEngine.Debug.LogWarning($"CreateRoom failed, client stays on masterserver: {operationResponse.ToStringFull()}.");
				}
				State = ((!insideLobby) ? ClientState.ConnectedToMaster : ClientState.JoinedLobby);
				SendMonoMessage(PhotonNetworkingMessage.OnPhotonCreateRoomFailed, operationResponse.ReturnCode, operationResponse.DebugMessage);
				break;
			}
			string text3 = (string)operationResponse[byte.MaxValue];
			if (!string.IsNullOrEmpty(text3))
			{
				enterRoomParamsCache.RoomName = text3;
			}
			GameServerAddress = (string)operationResponse[230];
			if (PhotonNetwork.UseAlternativeUdpPorts && base.TransportProtocol == ConnectionProtocol.Udp)
			{
				GameServerAddress = GameServerAddress.Replace("5058", "27000").Replace("5055", "27001").Replace("5056", "27002");
			}
			DisconnectToReconnect();
			break;
		}
		case 226:
			if (Server != ServerConnection.GameServer)
			{
				if (operationResponse.ReturnCode != 0)
				{
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						UnityEngine.Debug.Log($"JoinRoom failed (room maybe closed by now). Client stays on masterserver: {operationResponse.ToStringFull()}. State: {State}");
					}
					SendMonoMessage(PhotonNetworkingMessage.OnPhotonJoinRoomFailed, operationResponse.ReturnCode, operationResponse.DebugMessage);
				}
				else
				{
					GameServerAddress = (string)operationResponse[230];
					if (PhotonNetwork.UseAlternativeUdpPorts && base.TransportProtocol == ConnectionProtocol.Udp)
					{
						GameServerAddress = GameServerAddress.Replace("5058", "27000").Replace("5055", "27001").Replace("5056", "27002");
					}
					DisconnectToReconnect();
				}
			}
			else
			{
				GameEnteredOnGameServer(operationResponse);
			}
			break;
		case 225:
			if (operationResponse.ReturnCode != 0)
			{
				if (operationResponse.ReturnCode == 32760)
				{
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
					{
						UnityEngine.Debug.Log("JoinRandom failed: No open game. Calling: OnPhotonRandomJoinFailed() and staying on master server.");
					}
				}
				else if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
				{
					UnityEngine.Debug.LogWarning($"JoinRandom failed: {operationResponse.ToStringFull()}.");
				}
				SendMonoMessage(PhotonNetworkingMessage.OnPhotonRandomJoinFailed, operationResponse.ReturnCode, operationResponse.DebugMessage);
			}
			else
			{
				string roomName = (string)operationResponse[byte.MaxValue];
				enterRoomParamsCache.RoomName = roomName;
				GameServerAddress = (string)operationResponse[230];
				if (PhotonNetwork.UseAlternativeUdpPorts && base.TransportProtocol == ConnectionProtocol.Udp)
				{
					GameServerAddress = GameServerAddress.Replace("5058", "27000").Replace("5055", "27001").Replace("5056", "27002");
				}
				DisconnectToReconnect();
			}
			break;
		case 217:
		{
			if (operationResponse.ReturnCode != 0)
			{
				DebugReturn(DebugLevel.ERROR, "GetGameList failed: " + operationResponse.ToStringFull());
				break;
			}
			mGameList = new Dictionary<string, RoomInfo>();
			ExitGames.Client.Photon.Hashtable hashtable = (ExitGames.Client.Photon.Hashtable)operationResponse[222];
			foreach (object key in hashtable.Keys)
			{
				string text = (string)key;
				mGameList[text] = new RoomInfo(text, (ExitGames.Client.Photon.Hashtable)hashtable[key]);
			}
			mGameListCopy = new RoomInfo[mGameList.Count];
			mGameList.Values.CopyTo(mGameListCopy, 0);
			SendMonoMessage(PhotonNetworkingMessage.OnReceivedRoomListUpdate);
			break;
		}
		case 229:
			State = ClientState.JoinedLobby;
			insideLobby = true;
			SendMonoMessage(PhotonNetworkingMessage.OnJoinedLobby);
			break;
		case 228:
			State = ClientState.Authenticated;
			LeftLobbyCleanup();
			break;
		case 254:
			DisconnectToReconnect();
			break;
		case 251:
		{
			ExitGames.Client.Photon.Hashtable pActorProperties = (ExitGames.Client.Photon.Hashtable)operationResponse[249];
			ExitGames.Client.Photon.Hashtable gameProperties = (ExitGames.Client.Photon.Hashtable)operationResponse[248];
			ReadoutProperties(gameProperties, pActorProperties, 0);
			break;
		}
		case 252:
		case 253:
			break;
		case 222:
		{
			bool[] array = operationResponse[1] as bool[];
			string[] array2 = operationResponse[2] as string[];
			if (array != null && array2 != null && friendListRequested != null && array.Length == friendListRequested.Length)
			{
				List<FriendInfo> list = new List<FriendInfo>(friendListRequested.Length);
				for (int i = 0; i < friendListRequested.Length; i++)
				{
					FriendInfo friendInfo = new FriendInfo();
					friendInfo.UserId = friendListRequested[i];
					friendInfo.Room = array2[i];
					friendInfo.IsOnline = array[i];
					list.Insert(i, friendInfo);
				}
				PhotonNetwork.Friends = list;
			}
			else
			{
				UnityEngine.Debug.LogError("FindFriends failed to apply the result, as a required value wasn't provided or the friend list length differed from result.");
			}
			friendListRequested = null;
			isFetchingFriendList = false;
			friendListTimestamp = Environment.TickCount;
			if (friendListTimestamp == 0)
			{
				friendListTimestamp = 1;
			}
			SendMonoMessage(PhotonNetworkingMessage.OnUpdatedFriendList);
			break;
		}
		case 219:
			SendMonoMessage(PhotonNetworkingMessage.OnWebRpcResponse, operationResponse);
			break;
		default:
			UnityEngine.Debug.LogWarning($"OperationResponse unhandled: {operationResponse.ToString()}");
			break;
		}
	}

	public void OnStatusChanged(StatusCode statusCode)
	{
		if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
		{
			UnityEngine.Debug.Log($"OnStatusChanged: {statusCode.ToString()} current State: {State}");
		}
		switch (statusCode)
		{
		case StatusCode.Connect:
			if (State == ClientState.ConnectingToNameServer)
			{
				if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
				{
					UnityEngine.Debug.Log("Connected to NameServer.");
				}
				Server = ServerConnection.NameServer;
				if (AuthValues != null)
				{
					AuthValues.Token = null;
				}
			}
			if (State == ClientState.ConnectingToGameserver)
			{
				if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
				{
					UnityEngine.Debug.Log("Connected to gameserver.");
				}
				Server = ServerConnection.GameServer;
				State = ClientState.ConnectedToGameserver;
			}
			if (State == ClientState.ConnectingToMasterserver)
			{
				if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
				{
					UnityEngine.Debug.Log("Connected to masterserver.");
				}
				Server = ServerConnection.MasterServer;
				State = ClientState.Authenticating;
				if (IsInitialConnect)
				{
					IsInitialConnect = false;
					SendMonoMessage(PhotonNetworkingMessage.OnConnectedToPhoton);
				}
			}
			if (base.TransportProtocol != ConnectionProtocol.WebSocketSecure)
			{
				if ((Server == ServerConnection.NameServer || AuthMode == AuthModeOption.Auth) && !PhotonNetwork.offlineMode)
				{
					EstablishEncryption();
				}
				break;
			}
			if (DebugOut == DebugLevel.INFO)
			{
				UnityEngine.Debug.Log("Skipping EstablishEncryption. Protocol is secure.");
			}
			goto case StatusCode.EncryptionEstablished;
		case StatusCode.EncryptionEstablished:
			_isReconnecting = false;
			if (Server == ServerConnection.NameServer)
			{
				State = ClientState.ConnectedToNameServer;
				if (!didAuthenticate && CloudRegion == CloudRegionCode.none)
				{
					OpGetRegions(AppId);
				}
			}
			if (Server != ServerConnection.NameServer && (AuthMode == AuthModeOption.AuthOnce || AuthMode == AuthModeOption.AuthOnceWss))
			{
				UnityEngine.Debug.Log("didAuthenticate " + didAuthenticate + " AuthMode " + AuthMode);
			}
			else if (!didAuthenticate && (!IsUsingNameServer || CloudRegion != CloudRegionCode.none))
			{
				didAuthenticate = CallAuthenticate();
				if (didAuthenticate)
				{
					State = ClientState.Authenticating;
				}
			}
			break;
		case StatusCode.EncryptionFailedToEstablish:
		{
			UnityEngine.Debug.LogError(string.Concat("Encryption wasn't established: ", statusCode, ". Going to authenticate anyways."));
			AuthenticationValues authenticationValues = AuthValues;
			if (authenticationValues == null)
			{
				AuthenticationValues authenticationValues2 = new AuthenticationValues();
				authenticationValues2.UserId = PlayerName;
				authenticationValues = authenticationValues2;
			}
			AuthenticationValues authValues = authenticationValues;
			OpAuthenticate(AppId, AppVersion, authValues, CloudRegion.ToString(), requestLobbyStatistics);
			break;
		}
		case StatusCode.Disconnect:
			didAuthenticate = false;
			isFetchingFriendList = false;
			if (Server == ServerConnection.GameServer)
			{
				LeftRoomCleanup();
			}
			if (Server == ServerConnection.MasterServer)
			{
				LeftLobbyCleanup();
			}
			if (State == ClientState.DisconnectingFromMasterserver)
			{
				if (Connect(GameServerAddress, ServerConnection.GameServer))
				{
					State = ClientState.ConnectingToGameserver;
				}
			}
			else if (State == ClientState.DisconnectingFromGameserver || State == ClientState.DisconnectingFromNameServer)
			{
				SetupProtocol(ServerConnection.MasterServer);
				if (Connect(MasterServerAddress, ServerConnection.MasterServer))
				{
					State = ClientState.ConnectingToMasterserver;
				}
			}
			else if (!_isReconnecting)
			{
				if (AuthValues != null)
				{
					AuthValues.Token = null;
				}
				IsInitialConnect = false;
				State = ClientState.PeerCreated;
				SendMonoMessage(PhotonNetworkingMessage.OnDisconnectedFromPhoton);
			}
			break;
		case StatusCode.SecurityExceptionOnConnect:
		case StatusCode.ExceptionOnConnect:
		{
			IsInitialConnect = false;
			State = ClientState.PeerCreated;
			if (AuthValues != null)
			{
				AuthValues.Token = null;
			}
			DisconnectCause disconnectCause = (DisconnectCause)statusCode;
			SendMonoMessage(PhotonNetworkingMessage.OnFailedToConnectToPhoton, disconnectCause);
			break;
		}
		case StatusCode.Exception:
			if (IsInitialConnect)
			{
				UnityEngine.Debug.LogError("Exception while connecting to: " + base.ServerAddress + ". Check if the server is available.");
				if (base.ServerAddress == null || base.ServerAddress.StartsWith("127.0.0.1"))
				{
					UnityEngine.Debug.LogWarning("The server address is 127.0.0.1 (localhost): Make sure the server is running on this machine. Android and iOS emulators have their own localhost.");
					if (base.ServerAddress == GameServerAddress)
					{
						UnityEngine.Debug.LogWarning("This might be a misconfiguration in the game server config. You need to edit it to a (public) address.");
					}
				}
				State = ClientState.PeerCreated;
				DisconnectCause disconnectCause = (DisconnectCause)statusCode;
				IsInitialConnect = false;
				SendMonoMessage(PhotonNetworkingMessage.OnFailedToConnectToPhoton, disconnectCause);
			}
			else
			{
				State = ClientState.PeerCreated;
				DisconnectCause disconnectCause = (DisconnectCause)statusCode;
				SendMonoMessage(PhotonNetworkingMessage.OnConnectionFail, disconnectCause);
			}
			Disconnect();
			break;
		case StatusCode.TimeoutDisconnect:
			if (IsInitialConnect)
			{
				if (!_isReconnecting)
				{
					UnityEngine.Debug.LogWarning(string.Concat(statusCode, " while connecting to: ", base.ServerAddress, ". Check if the server is available."));
					IsInitialConnect = false;
					DisconnectCause disconnectCause = (DisconnectCause)statusCode;
					SendMonoMessage(PhotonNetworkingMessage.OnFailedToConnectToPhoton, disconnectCause);
				}
			}
			else
			{
				DisconnectCause disconnectCause = (DisconnectCause)statusCode;
				SendMonoMessage(PhotonNetworkingMessage.OnConnectionFail, disconnectCause);
			}
			if (AuthValues != null)
			{
				AuthValues.Token = null;
			}
			Disconnect();
			break;
		case StatusCode.ExceptionOnReceive:
		case StatusCode.DisconnectByServer:
		case StatusCode.DisconnectByServerUserLimit:
		case StatusCode.DisconnectByServerLogic:
			if (IsInitialConnect)
			{
				UnityEngine.Debug.LogWarning(string.Concat(statusCode, " while connecting to: ", base.ServerAddress, ". Check if the server is available."));
				IsInitialConnect = false;
				DisconnectCause disconnectCause = (DisconnectCause)statusCode;
				SendMonoMessage(PhotonNetworkingMessage.OnFailedToConnectToPhoton, disconnectCause);
			}
			else
			{
				DisconnectCause disconnectCause = (DisconnectCause)statusCode;
				SendMonoMessage(PhotonNetworkingMessage.OnConnectionFail, disconnectCause);
			}
			if (AuthValues != null)
			{
				AuthValues.Token = null;
			}
			Disconnect();
			break;
		case StatusCode.SendError:
			break;
		default:
			UnityEngine.Debug.LogError("Received unknown status code: " + statusCode);
			break;
		}
	}

	public void OnEvent(EventData photonEvent)
	{
		if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
		{
			UnityEngine.Debug.Log($"OnEvent: {photonEvent.ToString()}");
		}
		int num = -1;
		PhotonPlayer photonPlayer = null;
		if (photonEvent.Parameters.ContainsKey(254))
		{
			num = (int)photonEvent[254];
			photonPlayer = GetPlayerWithId(num);
		}
		switch (photonEvent.Code)
		{
		case 209:
		{
			int[] array = (int[])photonEvent.Parameters[245];
			int num2 = array[0];
			int num3 = array[1];
			PhotonView photonView = PhotonView.Find(num2);
			if (photonView == null)
			{
				UnityEngine.Debug.LogWarning("Can't find PhotonView of incoming OwnershipRequest. ViewId not found: " + num2);
				return;
			}
			if (PhotonNetwork.logLevel == PhotonLogLevel.Informational)
			{
				UnityEngine.Debug.Log(string.Concat("Ev OwnershipRequest ", photonView.ownershipTransfer, ". ActorNr: ", num, " takes from: ", num3, ". local RequestedView.ownerId: ", photonView.ownerId, " isOwnerActive: ", photonView.isOwnerActive, ". MasterClient: ", mMasterClientId, ". This client's player: ", PhotonNetwork.player.ToStringFull()));
			}
			switch (photonView.ownershipTransfer)
			{
			case OwnershipOption.Fixed:
				UnityEngine.Debug.LogWarning("Ownership mode == fixed. Ignoring request.");
				break;
			case OwnershipOption.Takeover:
				if (num3 == photonView.ownerId || (num3 == 0 && photonView.ownerId == mMasterClientId) || photonView.ownerId == 0)
				{
					photonView.OwnerShipWasTransfered = true;
					int ownerId = photonView.ownerId;
					PhotonPlayer playerWithId = GetPlayerWithId(ownerId);
					photonView.ownerId = num;
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						UnityEngine.Debug.LogWarning(string.Concat(photonView, " ownership transfered to: ", num));
					}
					SendMonoMessage(PhotonNetworkingMessage.OnOwnershipTransfered, photonView, photonPlayer, playerWithId);
				}
				break;
			case OwnershipOption.Request:
				if ((num3 == PhotonNetwork.player.ID || PhotonNetwork.player.IsMasterClient) && (photonView.ownerId == PhotonNetwork.player.ID || (PhotonNetwork.player.IsMasterClient && !photonView.isOwnerActive)))
				{
					SendMonoMessage(PhotonNetworkingMessage.OnOwnershipRequest, photonView, photonPlayer);
				}
				break;
			}
			return;
		}
		case 210:
		{
			int[] array6 = (int[])photonEvent.Parameters[245];
			if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
			{
				UnityEngine.Debug.Log("Ev OwnershipTransfer. ViewID " + array6[0] + " to: " + array6[1] + " Time: " + Environment.TickCount % 1000);
			}
			int viewID = array6[0];
			int num5 = array6[1];
			PhotonView photonView2 = PhotonView.Find(viewID);
			if (photonView2 != null)
			{
				int ownerId2 = photonView2.ownerId;
				photonView2.OwnerShipWasTransfered = true;
				photonView2.ownerId = num5;
				SendMonoMessage(PhotonNetworkingMessage.OnOwnershipTransfered, photonView2, PhotonPlayer.Find(num5), PhotonPlayer.Find(ownerId2));
			}
			return;
		}
		case 230:
		{
			mGameList = new Dictionary<string, RoomInfo>();
			ExitGames.Client.Photon.Hashtable hashtable = (ExitGames.Client.Photon.Hashtable)photonEvent[222];
			foreach (object key in hashtable.Keys)
			{
				string text = (string)key;
				mGameList[text] = new RoomInfo(text, (ExitGames.Client.Photon.Hashtable)hashtable[key]);
			}
			mGameListCopy = new RoomInfo[mGameList.Count];
			mGameList.Values.CopyTo(mGameListCopy, 0);
			SendMonoMessage(PhotonNetworkingMessage.OnReceivedRoomListUpdate);
			return;
		}
		case 229:
		{
			ExitGames.Client.Photon.Hashtable hashtable4 = (ExitGames.Client.Photon.Hashtable)photonEvent[222];
			foreach (object key2 in hashtable4.Keys)
			{
				string text2 = (string)key2;
				RoomInfo roomInfo = new RoomInfo(text2, (ExitGames.Client.Photon.Hashtable)hashtable4[key2]);
				if (roomInfo.removedFromList)
				{
					mGameList.Remove(text2);
				}
				else
				{
					mGameList[text2] = roomInfo;
				}
			}
			mGameListCopy = new RoomInfo[mGameList.Count];
			mGameList.Values.CopyTo(mGameListCopy, 0);
			SendMonoMessage(PhotonNetworkingMessage.OnReceivedRoomListUpdate);
			return;
		}
		case 226:
			PlayersInRoomsCount = (int)photonEvent[229];
			PlayersOnMasterCount = (int)photonEvent[227];
			RoomsCount = (int)photonEvent[228];
			return;
		case byte.MaxValue:
		{
			bool flag = false;
			ExitGames.Client.Photon.Hashtable properties = (ExitGames.Client.Photon.Hashtable)photonEvent[249];
			if (photonPlayer == null)
			{
				bool isLocal = LocalPlayer.ID == num;
				AddNewPlayer(num, new PhotonPlayer(isLocal, num, properties));
				ResetPhotonViewsOnSerialize();
			}
			else
			{
				flag = photonPlayer.IsInactive;
				photonPlayer.InternalCacheProperties(properties);
				photonPlayer.IsInactive = false;
			}
			if (num == LocalPlayer.ID)
			{
				int[] actorsInRoom = (int[])photonEvent[252];
				UpdatedActorList(actorsInRoom);
				if (lastJoinType == JoinType.JoinOrCreateRoom && LocalPlayer.ID == 1)
				{
					SendMonoMessage(PhotonNetworkingMessage.OnCreatedRoom);
				}
				SendMonoMessage(PhotonNetworkingMessage.OnJoinedRoom);
			}
			else
			{
				SendMonoMessage(PhotonNetworkingMessage.OnPhotonPlayerConnected, mActors[num]);
				if (flag)
				{
					SendMonoMessage(PhotonNetworkingMessage.OnPhotonPlayerActivityChanged, mActors[num]);
				}
			}
			return;
		}
		case 254:
			HandleEventLeave(num, photonEvent);
			return;
		case 253:
		{
			int num4 = (int)photonEvent[253];
			ExitGames.Client.Photon.Hashtable gameProperties = null;
			ExitGames.Client.Photon.Hashtable pActorProperties = null;
			if (num4 == 0)
			{
				gameProperties = (ExitGames.Client.Photon.Hashtable)photonEvent[251];
			}
			else
			{
				pActorProperties = (ExitGames.Client.Photon.Hashtable)photonEvent[251];
			}
			ReadoutProperties(gameProperties, pActorProperties, num4);
			return;
		}
		case 200:
			ExecuteRpc(photonEvent[245] as ExitGames.Client.Photon.Hashtable, num);
			return;
		case 201:
		case 206:
		{
			ExitGames.Client.Photon.Hashtable hashtable3 = (ExitGames.Client.Photon.Hashtable)photonEvent[245];
			int networkTime = (int)hashtable3[(byte)0];
			short correctPrefix = -1;
			byte b = 10;
			int num7 = 1;
			if (hashtable3.ContainsKey((byte)1))
			{
				correctPrefix = (short)hashtable3[(byte)1];
				num7 = 2;
			}
			byte b2 = b;
			while (b2 - b < hashtable3.Count - num7)
			{
				OnSerializeRead(hashtable3[b2] as object[], photonPlayer, networkTime, correctPrefix);
				b2++;
			}
			return;
		}
		case 202:
			DoInstantiate((ExitGames.Client.Photon.Hashtable)photonEvent[245], photonPlayer, null);
			return;
		case 203:
			if (photonPlayer == null || !photonPlayer.IsMasterClient)
			{
				UnityEngine.Debug.LogError(string.Concat("Error: Someone else(", photonPlayer, ") then the masterserver requests a disconnect!"));
			}
			else
			{
				PhotonNetwork.LeaveRoom();
			}
			return;
		case 207:
		{
			ExitGames.Client.Photon.Hashtable hashtable2 = (ExitGames.Client.Photon.Hashtable)photonEvent[245];
			int num8 = (int)hashtable2[(byte)0];
			if (num8 >= 0)
			{
				DestroyPlayerObjects(num8, localOnly: true);
				return;
			}
			if ((int)DebugOut >= 3)
			{
				UnityEngine.Debug.Log("Ev DestroyAll! By PlayerId: " + num);
			}
			DestroyAll(localOnly: true);
			return;
		}
		case 204:
		{
			ExitGames.Client.Photon.Hashtable hashtable2 = (ExitGames.Client.Photon.Hashtable)photonEvent[245];
			int num6 = (int)hashtable2[(byte)0];
			PhotonView value = null;
			if (photonViewList.TryGetValue(num6, out value))
			{
				RemoveInstantiatedGO(value.gameObject, localOnly: true);
			}
			else if ((int)DebugOut >= 1)
			{
				UnityEngine.Debug.LogError("Ev Destroy Failed. Could not find PhotonView with instantiationId " + num6 + ". Sent by actorNr: " + num);
			}
			return;
		}
		case 208:
		{
			ExitGames.Client.Photon.Hashtable hashtable2 = (ExitGames.Client.Photon.Hashtable)photonEvent[245];
			int playerId = (int)hashtable2[(byte)1];
			SetMasterClient(playerId, sync: false);
			return;
		}
		case 224:
		{
			string[] array2 = photonEvent[213] as string[];
			byte[] array3 = photonEvent[212] as byte[];
			int[] array4 = photonEvent[229] as int[];
			int[] array5 = photonEvent[228] as int[];
			LobbyStatistics.Clear();
			for (int i = 0; i < array2.Length; i++)
			{
				TypedLobbyInfo typedLobbyInfo = new TypedLobbyInfo();
				typedLobbyInfo.Name = array2[i];
				typedLobbyInfo.Type = (LobbyType)array3[i];
				typedLobbyInfo.PlayerCount = array4[i];
				typedLobbyInfo.RoomCount = array5[i];
				LobbyStatistics.Add(typedLobbyInfo);
			}
			SendMonoMessage(PhotonNetworkingMessage.OnLobbyStatisticsUpdate);
			return;
		}
		case 251:
			if (PhotonNetwork.OnEventCall != null)
			{
				object content = photonEvent[218];
				PhotonNetwork.OnEventCall(photonEvent.Code, content, num);
			}
			else
			{
				UnityEngine.Debug.LogWarning("Warning: Unhandled Event ErrorInfo (251). Set PhotonNetwork.OnEventCall to the method PUN should call for this event.");
			}
			return;
		case 223:
			if (AuthValues == null)
			{
				AuthValues = new AuthenticationValues();
			}
			AuthValues.Token = photonEvent[221] as string;
			tokenCache = AuthValues.Token;
			return;
		}
		if (photonEvent.Code < 200)
		{
			if (PhotonNetwork.OnEventCall != null)
			{
				object content2 = photonEvent[245];
				PhotonNetwork.OnEventCall(photonEvent.Code, content2, num);
			}
			else
			{
				UnityEngine.Debug.LogWarning(string.Concat("Warning: Unhandled event ", photonEvent, ". Set PhotonNetwork.OnEventCall."));
			}
		}
	}

	public void OnMessage(object messages)
	{
	}

	private void SetupEncryption(Dictionary<byte, object> encryptionData)
	{
		if (AuthMode == AuthModeOption.Auth && DebugOut == DebugLevel.ERROR)
		{
			UnityEngine.Debug.LogWarning("SetupEncryption() called but ignored. Not XB1 compiled. EncryptionData: " + encryptionData.ToStringFull());
			return;
		}
		if (DebugOut == DebugLevel.INFO)
		{
			UnityEngine.Debug.Log("SetupEncryption() got called. " + encryptionData.ToStringFull());
		}
		switch ((EncryptionMode)(byte)encryptionData[0])
		{
		case EncryptionMode.PayloadEncryption:
		{
			byte[] secret = (byte[])encryptionData[1];
			InitPayloadEncryption(secret);
			break;
		}
		case EncryptionMode.DatagramEncryption:
		{
			byte[] encryptionSecret = (byte[])encryptionData[1];
			byte[] hmacSecret = (byte[])encryptionData[2];
			InitDatagramEncryption(encryptionSecret, hmacSecret);
			break;
		}
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	protected internal void UpdatedActorList(int[] actorsInRoom)
	{
		foreach (int num in actorsInRoom)
		{
			if (LocalPlayer.ID != num && !mActors.ContainsKey(num))
			{
				AddNewPlayer(num, new PhotonPlayer(isLocal: false, num, string.Empty));
			}
		}
	}

	private void SendVacantViewIds()
	{
		UnityEngine.Debug.Log("SendVacantViewIds()");
		List<int> list = new List<int>();
		foreach (PhotonView value in photonViewList.Values)
		{
			if (!value.isOwnerActive)
			{
				list.Add(value.viewID);
			}
		}
		UnityEngine.Debug.Log("Sending vacant view IDs. Length: " + list.Count);
		OpRaiseEvent(211, list.ToArray(), sendReliable: true, null);
	}

	public static void SendMonoMessage(PhotonNetworkingMessage methodString, params object[] parameters)
	{
		HashSet<GameObject> hashSet = ((PhotonNetwork.SendMonoMessageTargets == null) ? PhotonNetwork.FindGameObjectsWithComponent(PhotonNetwork.SendMonoMessageTargetType) : PhotonNetwork.SendMonoMessageTargets);
		string methodName = methodString.ToString();
		object value = ((parameters == null || parameters.Length != 1) ? parameters : parameters[0]);
		foreach (GameObject item in hashSet)
		{
			if (item != null)
			{
				item.SendMessage(methodName, value, SendMessageOptions.DontRequireReceiver);
			}
		}
	}

	protected internal void ExecuteRpc(ExitGames.Client.Photon.Hashtable rpcData, int senderID = 0)
	{
		if (rpcData == null || !rpcData.ContainsKey((byte)0))
		{
			UnityEngine.Debug.LogError("Malformed RPC; this should never occur. Content: " + SupportClass.DictionaryToString(rpcData));
			return;
		}
		int num = (int)rpcData[(byte)0];
		int num2 = 0;
		if (rpcData.ContainsKey((byte)1))
		{
			num2 = (short)rpcData[(byte)1];
		}
		string text;
		if (rpcData.ContainsKey((byte)5))
		{
			int num3 = (byte)rpcData[(byte)5];
			if (num3 > PhotonNetwork.PhotonServerSettings.RpcList.Count - 1)
			{
				UnityEngine.Debug.LogError("Could not find RPC with index: " + num3 + ". Going to ignore! Check PhotonServerSettings.RpcList");
				return;
			}
			text = PhotonNetwork.PhotonServerSettings.RpcList[num3];
		}
		else
		{
			text = (string)rpcData[(byte)3];
		}
		object[] array = null;
		if (rpcData.ContainsKey((byte)4))
		{
			array = (object[])rpcData[(byte)4];
		}
		if (array == null)
		{
			array = new object[0];
		}
		PhotonView photonView = GetPhotonView(num);
		if (photonView == null)
		{
			int num4 = num / PhotonNetwork.MAX_VIEW_IDS;
			bool flag = num4 == LocalPlayer.ID;
			bool flag2 = num4 == senderID;
			if (flag)
			{
				UnityEngine.Debug.LogWarning("Received RPC \"" + text + "\" for viewID " + num + " but this PhotonView does not exist! View was/is ours." + ((!flag2) ? " Remote called." : " Owner called.") + " By: " + senderID);
			}
			else
			{
				UnityEngine.Debug.LogWarning("Received RPC \"" + text + "\" for viewID " + num + " but this PhotonView does not exist! Was remote PV." + ((!flag2) ? " Remote called." : " Owner called.") + " By: " + senderID + " Maybe GO was destroyed but RPC not cleaned up.");
			}
			return;
		}
		if (photonView.prefix != num2)
		{
			UnityEngine.Debug.LogError("Received RPC \"" + text + "\" on viewID " + num + " with a prefix of " + num2 + ", our prefix is " + photonView.prefix + ". The RPC has been ignored.");
			return;
		}
		if (string.IsNullOrEmpty(text))
		{
			UnityEngine.Debug.LogError("Malformed RPC; this should never occur. Content: " + SupportClass.DictionaryToString(rpcData));
			return;
		}
		if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
		{
			UnityEngine.Debug.Log("Received RPC: " + text);
		}
		if (photonView.group != 0 && !allowedReceivingGroups.Contains(photonView.group))
		{
			return;
		}
		Type[] array2 = new Type[0];
		if (array.Length > 0)
		{
			array2 = new Type[array.Length];
			int num5 = 0;
			foreach (object obj in array)
			{
				if (obj == null)
				{
					array2[num5] = null;
				}
				else
				{
					array2[num5] = obj.GetType();
				}
				num5++;
			}
		}
		int num6 = 0;
		int num7 = 0;
		if (!PhotonNetwork.UseRpcMonoBehaviourCache || photonView.RpcMonoBehaviours == null || photonView.RpcMonoBehaviours.Length == 0)
		{
			photonView.RefreshRpcMonoBehaviourCache();
		}
		for (int j = 0; j < photonView.RpcMonoBehaviours.Length; j++)
		{
			UnityEngine.MonoBehaviour monoBehaviour = photonView.RpcMonoBehaviours[j];
			if (monoBehaviour == null)
			{
				UnityEngine.Debug.LogError("ERROR You have missing MonoBehaviours on your gameobjects!");
				continue;
			}
			Type type = monoBehaviour.GetType();
			List<MethodInfo> value = null;
			if (!monoRPCMethodsCache.TryGetValue(type, out value))
			{
				List<MethodInfo> methods = SupportClass.GetMethods(type, typeof(PunRPC));
				monoRPCMethodsCache[type] = methods;
				value = methods;
			}
			if (value == null)
			{
				continue;
			}
			for (int k = 0; k < value.Count; k++)
			{
				MethodInfo methodInfo = value[k];
				if (!methodInfo.Name.Equals(text))
				{
					continue;
				}
				num7++;
				ParameterInfo[] cachedParemeters = methodInfo.GetCachedParemeters();
				if (cachedParemeters.Length == array2.Length)
				{
					if (CheckTypeMatch(cachedParemeters, array2))
					{
						num6++;
						object obj2 = methodInfo.Invoke(monoBehaviour, array);
						if (PhotonNetwork.StartRpcsAsCoroutine && methodInfo.ReturnType == typeof(IEnumerator))
						{
							monoBehaviour.StartCoroutine((IEnumerator)obj2);
						}
					}
				}
				else if (cachedParemeters.Length - 1 == array2.Length)
				{
					if (CheckTypeMatch(cachedParemeters, array2) && cachedParemeters[cachedParemeters.Length - 1].ParameterType == typeof(PhotonMessageInfo))
					{
						num6++;
						int timestamp = (int)rpcData[(byte)2];
						object[] array3 = new object[array.Length + 1];
						array.CopyTo(array3, 0);
						array3[array3.Length - 1] = new PhotonMessageInfo(GetPlayerWithId(senderID), timestamp, photonView);
						object obj3 = methodInfo.Invoke(monoBehaviour, array3);
						if (PhotonNetwork.StartRpcsAsCoroutine && methodInfo.ReturnType == typeof(IEnumerator))
						{
							monoBehaviour.StartCoroutine((IEnumerator)obj3);
						}
					}
				}
				else if (cachedParemeters.Length == 1 && cachedParemeters[0].ParameterType.IsArray)
				{
					num6++;
					object obj4 = methodInfo.Invoke(monoBehaviour, new object[1] { array });
					if (PhotonNetwork.StartRpcsAsCoroutine && methodInfo.ReturnType == typeof(IEnumerator))
					{
						monoBehaviour.StartCoroutine((IEnumerator)obj4);
					}
				}
			}
		}
		if (num6 == 1)
		{
			return;
		}
		string text2 = string.Empty;
		foreach (Type type2 in array2)
		{
			if (text2 != string.Empty)
			{
				text2 += ", ";
			}
			text2 = ((type2 != null) ? (text2 + type2.Name) : (text2 + "null"));
		}
		if (num6 == 0)
		{
			if (num7 == 0)
			{
				UnityEngine.Debug.LogError("PhotonView with ID " + num + " has no method \"" + text + "\" marked with the [PunRPC](C#) or @PunRPC(JS) property! Args: " + text2);
			}
			else
			{
				UnityEngine.Debug.LogError("PhotonView with ID " + num + " has no method \"" + text + "\" that takes " + array2.Length + " argument(s): " + text2);
			}
		}
		else
		{
			UnityEngine.Debug.LogError("PhotonView with ID " + num + " has " + num6 + " methods \"" + text + "\" that takes " + array2.Length + " argument(s): " + text2 + ". Should be just one?");
		}
	}

	private bool CheckTypeMatch(ParameterInfo[] methodParameters, Type[] callParameterTypes)
	{
		if (methodParameters.Length < callParameterTypes.Length)
		{
			return false;
		}
		for (int i = 0; i < callParameterTypes.Length; i++)
		{
			Type parameterType = methodParameters[i].ParameterType;
			if (callParameterTypes[i] != null && !parameterType.IsAssignableFrom(callParameterTypes[i]) && (!parameterType.IsEnum || !Enum.GetUnderlyingType(parameterType).IsAssignableFrom(callParameterTypes[i])))
			{
				return false;
			}
		}
		return true;
	}

	internal ExitGames.Client.Photon.Hashtable SendInstantiate(string prefabName, Vector3 position, Quaternion rotation, byte group, int[] viewIDs, object[] data, bool isGlobalObject)
	{
		int num = viewIDs[0];
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)0] = prefabName;
		if (position != Vector3.zero)
		{
			hashtable[(byte)1] = position;
		}
		if (rotation != Quaternion.identity)
		{
			hashtable[(byte)2] = rotation;
		}
		if (group != 0)
		{
			hashtable[(byte)3] = group;
		}
		if (viewIDs.Length > 1)
		{
			hashtable[(byte)4] = viewIDs;
		}
		if (data != null)
		{
			hashtable[(byte)5] = data;
		}
		if (currentLevelPrefix > 0)
		{
			hashtable[(byte)8] = currentLevelPrefix;
		}
		hashtable[(byte)6] = PhotonNetwork.ServerTimestamp;
		hashtable[(byte)7] = num;
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.CachingOption = ((!isGlobalObject) ? EventCaching.AddToRoomCache : EventCaching.AddToRoomCacheGlobal);
		OpRaiseEvent(202, hashtable, sendReliable: true, raiseEventOptions);
		return hashtable;
	}

	internal GameObject DoInstantiate(ExitGames.Client.Photon.Hashtable evData, PhotonPlayer photonPlayer, GameObject resourceGameObject)
	{
		string text = (string)evData[(byte)0];
		int timestamp = (int)evData[(byte)6];
		int num = (int)evData[(byte)7];
		Vector3 position = ((!evData.ContainsKey((byte)1)) ? Vector3.zero : ((Vector3)evData[(byte)1]));
		Quaternion rotation = Quaternion.identity;
		if (evData.ContainsKey((byte)2))
		{
			rotation = (Quaternion)evData[(byte)2];
		}
		byte b = 0;
		if (evData.ContainsKey((byte)3))
		{
			b = (byte)evData[(byte)3];
		}
		short prefix = 0;
		if (evData.ContainsKey((byte)8))
		{
			prefix = (short)evData[(byte)8];
		}
		int[] array = ((!evData.ContainsKey((byte)4)) ? new int[1] { num } : ((int[])evData[(byte)4]));
		object[] array2 = ((!evData.ContainsKey((byte)5)) ? null : ((object[])evData[(byte)5]));
		if (b != 0 && !allowedReceivingGroups.Contains(b))
		{
			return null;
		}
		if (ObjectPool != null)
		{
			GameObject gameObject = ObjectPool.Instantiate(text, position, rotation);
			PhotonView[] photonViewsInChildren = gameObject.GetPhotonViewsInChildren();
			if (photonViewsInChildren.Length != array.Length)
			{
				throw new Exception("Error in Instantiation! The resource's PhotonView count is not the same as in incoming data.");
			}
			for (int i = 0; i < photonViewsInChildren.Length; i++)
			{
				photonViewsInChildren[i].didAwake = false;
				photonViewsInChildren[i].viewID = 0;
				photonViewsInChildren[i].prefix = prefix;
				photonViewsInChildren[i].instantiationId = num;
				photonViewsInChildren[i].isRuntimeInstantiated = true;
				photonViewsInChildren[i].instantiationDataField = array2;
				photonViewsInChildren[i].didAwake = true;
				photonViewsInChildren[i].viewID = array[i];
			}
			gameObject.SendMessage(OnPhotonInstantiateString, new PhotonMessageInfo(photonPlayer, timestamp, null), SendMessageOptions.DontRequireReceiver);
			return gameObject;
		}
		if (resourceGameObject == null)
		{
			if (!UsePrefabCache || !PrefabCache.TryGetValue(text, out resourceGameObject))
			{
				resourceGameObject = (GameObject)Resources.Load(text, typeof(GameObject));
				if (UsePrefabCache)
				{
					PrefabCache.Add(text, resourceGameObject);
				}
			}
			if (resourceGameObject == null)
			{
				UnityEngine.Debug.LogError("PhotonNetwork error: Could not Instantiate the prefab [" + text + "]. Please verify you have this gameobject in a Resources folder.");
				return null;
			}
		}
		PhotonView[] photonViewsInChildren2 = resourceGameObject.GetPhotonViewsInChildren();
		if (photonViewsInChildren2.Length != array.Length)
		{
			throw new Exception("Error in Instantiation! The resource's PhotonView count is not the same as in incoming data.");
		}
		for (int j = 0; j < array.Length; j++)
		{
			photonViewsInChildren2[j].viewID = array[j];
			photonViewsInChildren2[j].prefix = prefix;
			photonViewsInChildren2[j].instantiationId = num;
			photonViewsInChildren2[j].isRuntimeInstantiated = true;
		}
		StoreInstantiationData(num, array2);
		GameObject gameObject2 = UnityEngine.Object.Instantiate(resourceGameObject, position, rotation);
		for (int k = 0; k < array.Length; k++)
		{
			photonViewsInChildren2[k].viewID = 0;
			photonViewsInChildren2[k].prefix = -1;
			photonViewsInChildren2[k].prefixBackup = -1;
			photonViewsInChildren2[k].instantiationId = -1;
			photonViewsInChildren2[k].isRuntimeInstantiated = false;
		}
		RemoveInstantiationData(num);
		gameObject2.SendMessage(OnPhotonInstantiateString, new PhotonMessageInfo(photonPlayer, timestamp, null), SendMessageOptions.DontRequireReceiver);
		return gameObject2;
	}

	private void StoreInstantiationData(int instantiationId, object[] instantiationData)
	{
		tempInstantiationData[instantiationId] = instantiationData;
	}

	public object[] FetchInstantiationData(int instantiationId)
	{
		object[] value = null;
		if (instantiationId == 0)
		{
			return null;
		}
		tempInstantiationData.TryGetValue(instantiationId, out value);
		return value;
	}

	private void RemoveInstantiationData(int instantiationId)
	{
		tempInstantiationData.Remove(instantiationId);
	}

	public void DestroyPlayerObjects(int playerId, bool localOnly)
	{
		if (playerId <= 0)
		{
			UnityEngine.Debug.LogError("Failed to Destroy objects of playerId: " + playerId);
			return;
		}
		if (!localOnly)
		{
			OpRemoveFromServerInstantiationsOfPlayer(playerId);
			OpCleanRpcBuffer(playerId);
			SendDestroyOfPlayer(playerId);
		}
		HashSet<GameObject> hashSet = new HashSet<GameObject>();
		foreach (PhotonView value in photonViewList.Values)
		{
			if (value != null && value.CreatorActorNr == playerId)
			{
				hashSet.Add(value.gameObject);
			}
		}
		foreach (GameObject item in hashSet)
		{
			RemoveInstantiatedGO(item, localOnly: true);
		}
		foreach (PhotonView value2 in photonViewList.Values)
		{
			if (value2.ownerId == playerId)
			{
				value2.ownerId = value2.CreatorActorNr;
			}
		}
	}

	public void DestroyAll(bool localOnly)
	{
		if (!localOnly)
		{
			OpRemoveCompleteCache();
			SendDestroyOfAll();
		}
		LocalCleanupAnythingInstantiated(destroyInstantiatedGameObjects: true);
	}

	protected internal void RemoveInstantiatedGO(GameObject go, bool localOnly)
	{
		if (go == null)
		{
			UnityEngine.Debug.LogError("Failed to 'network-remove' GameObject because it's null.");
			return;
		}
		PhotonView[] componentsInChildren = go.GetComponentsInChildren<PhotonView>(includeInactive: true);
		if (componentsInChildren == null || componentsInChildren.Length <= 0)
		{
			UnityEngine.Debug.LogError("Failed to 'network-remove' GameObject because has no PhotonView components: " + go);
			return;
		}
		PhotonView photonView = componentsInChildren[0];
		int creatorActorNr = photonView.CreatorActorNr;
		int instantiationId = photonView.instantiationId;
		if (!localOnly)
		{
			if (!photonView.isMine)
			{
				UnityEngine.Debug.LogError("Failed to 'network-remove' GameObject. Client is neither owner nor masterClient taking over for owner who left: " + photonView);
				return;
			}
			if (instantiationId < 1)
			{
				UnityEngine.Debug.LogError(string.Concat("Failed to 'network-remove' GameObject because it is missing a valid InstantiationId on view: ", photonView, ". Not Destroying GameObject or PhotonViews!"));
				return;
			}
		}
		if (!localOnly)
		{
			ServerCleanInstantiateAndDestroy(instantiationId, creatorActorNr, photonView.isRuntimeInstantiated);
		}
		for (int num = componentsInChildren.Length - 1; num >= 0; num--)
		{
			PhotonView photonView2 = componentsInChildren[num];
			if (!(photonView2 == null))
			{
				if (photonView2.instantiationId >= 1)
				{
					LocalCleanPhotonView(photonView2);
				}
				if (!localOnly)
				{
					OpCleanRpcBuffer(photonView2);
				}
			}
		}
		if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
		{
			UnityEngine.Debug.Log("Network destroy Instantiated GO: " + go.name);
		}
		if (ObjectPool != null)
		{
			PhotonView[] photonViewsInChildren = go.GetPhotonViewsInChildren();
			for (int i = 0; i < photonViewsInChildren.Length; i++)
			{
				photonViewsInChildren[i].viewID = 0;
			}
			ObjectPool.Destroy(go);
		}
		else
		{
			UnityEngine.Object.Destroy(go);
		}
	}

	private void ServerCleanInstantiateAndDestroy(int instantiateId, int creatorId, bool isRuntimeInstantiated)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)7] = instantiateId;
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.CachingOption = EventCaching.RemoveFromRoomCache;
		raiseEventOptions.TargetActors = new int[1] { creatorId };
		RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
		OpRaiseEvent(202, hashtable, sendReliable: true, raiseEventOptions2);
		ExitGames.Client.Photon.Hashtable hashtable2 = new ExitGames.Client.Photon.Hashtable();
		hashtable2[(byte)0] = instantiateId;
		raiseEventOptions2 = null;
		if (!isRuntimeInstantiated)
		{
			raiseEventOptions2 = new RaiseEventOptions();
			raiseEventOptions2.CachingOption = EventCaching.AddToRoomCacheGlobal;
			UnityEngine.Debug.Log("Destroying GO as global. ID: " + instantiateId);
		}
		OpRaiseEvent(204, hashtable2, sendReliable: true, raiseEventOptions2);
	}

	private void SendDestroyOfPlayer(int actorNr)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)0] = actorNr;
		OpRaiseEvent(207, hashtable, sendReliable: true, null);
	}

	private void SendDestroyOfAll()
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)0] = -1;
		OpRaiseEvent(207, hashtable, sendReliable: true, null);
	}

	private void OpRemoveFromServerInstantiationsOfPlayer(int actorNr)
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.CachingOption = EventCaching.RemoveFromRoomCache;
		raiseEventOptions.TargetActors = new int[1] { actorNr };
		RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
		OpRaiseEvent(202, null, sendReliable: true, raiseEventOptions2);
	}

	protected internal void RequestOwnership(int viewID, int fromOwner)
	{
		UnityEngine.Debug.Log("RequestOwnership(): " + viewID + " from: " + fromOwner + " Time: " + Environment.TickCount % 1000);
		OpRaiseEvent(209, new int[2] { viewID, fromOwner }, sendReliable: true, new RaiseEventOptions
		{
			Receivers = ReceiverGroup.All
		});
	}

	protected internal void TransferOwnership(int viewID, int playerID)
	{
		UnityEngine.Debug.Log("TransferOwnership() view " + viewID + " to: " + playerID + " Time: " + Environment.TickCount % 1000);
		OpRaiseEvent(210, new int[2] { viewID, playerID }, sendReliable: true, new RaiseEventOptions
		{
			Receivers = ReceiverGroup.All
		});
	}

	public bool LocalCleanPhotonView(PhotonView view)
	{
		view.removedFromLocalViewList = true;
		return photonViewList.Remove(view.viewID);
	}

	public PhotonView GetPhotonView(int viewID)
	{
		PhotonView value = null;
		photonViewList.TryGetValue(viewID, out value);
		if (value == null)
		{
			PhotonView[] array = UnityEngine.Object.FindObjectsOfType(typeof(PhotonView)) as PhotonView[];
			foreach (PhotonView photonView in array)
			{
				if (photonView.viewID == viewID)
				{
					if (photonView.didAwake)
					{
						UnityEngine.Debug.LogWarning("Had to lookup view that wasn't in photonViewList: " + photonView);
					}
					return photonView;
				}
			}
		}
		return value;
	}

	public void RegisterPhotonView(PhotonView netView)
	{
		if (!UnityEngine.Application.isPlaying)
		{
			photonViewList = new Dictionary<int, PhotonView>();
			return;
		}
		if (netView.viewID == 0)
		{
			UnityEngine.Debug.Log("PhotonView register is ignored, because viewID is 0. No id assigned yet to: " + netView);
			return;
		}
		PhotonView value = null;
		if (photonViewList.TryGetValue(netView.viewID, out value))
		{
			if (!(netView != value))
			{
				return;
			}
			UnityEngine.Debug.LogError($"PhotonView ID duplicate found: {netView.viewID}. New: {netView} old: {value}. Maybe one wasn't destroyed on scene load?! Check for 'DontDestroyOnLoad'. Destroying old entry, adding new.");
			RemoveInstantiatedGO(value.gameObject, localOnly: true);
		}
		photonViewList.Add(netView.viewID, netView);
		if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
		{
			UnityEngine.Debug.Log("Registered PhotonView: " + netView.viewID);
		}
	}

	public void OpCleanRpcBuffer(int actorNumber)
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.CachingOption = EventCaching.RemoveFromRoomCache;
		raiseEventOptions.TargetActors = new int[1] { actorNumber };
		RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
		OpRaiseEvent(200, null, sendReliable: true, raiseEventOptions2);
	}

	public void OpRemoveCompleteCacheOfPlayer(int actorNumber)
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.CachingOption = EventCaching.RemoveFromRoomCache;
		raiseEventOptions.TargetActors = new int[1] { actorNumber };
		RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
		OpRaiseEvent(0, null, sendReliable: true, raiseEventOptions2);
	}

	public void OpRemoveCompleteCache()
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.CachingOption = EventCaching.RemoveFromRoomCache;
		raiseEventOptions.Receivers = ReceiverGroup.MasterClient;
		RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
		OpRaiseEvent(0, null, sendReliable: true, raiseEventOptions2);
	}

	private void RemoveCacheOfLeftPlayers()
	{
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		dictionary[244] = (byte)0;
		dictionary[247] = (byte)7;
		OpCustom(253, dictionary, sendReliable: true, 0);
	}

	public void CleanRpcBufferIfMine(PhotonView view)
	{
		if (view.ownerId != LocalPlayer.ID && !LocalPlayer.IsMasterClient)
		{
			UnityEngine.Debug.LogError(string.Concat("Cannot remove cached RPCs on a PhotonView thats not ours! ", view.owner, " scene: ", view.isSceneView));
		}
		else
		{
			OpCleanRpcBuffer(view);
		}
	}

	public void OpCleanRpcBuffer(PhotonView view)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)0] = view.viewID;
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.CachingOption = EventCaching.RemoveFromRoomCache;
		RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
		OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions2);
	}

	public void RemoveRPCsInGroup(int group)
	{
		foreach (PhotonView value in photonViewList.Values)
		{
			if (value.group == group)
			{
				CleanRpcBufferIfMine(value);
			}
		}
	}

	public void SetLevelPrefix(short prefix)
	{
		currentLevelPrefix = prefix;
	}

	internal void RPC(PhotonView view, string methodName, PhotonTargets target, PhotonPlayer player, bool encrypt, params object[] parameters)
	{
		if (blockSendingGroups.Contains(view.group))
		{
			return;
		}
		if (view.viewID < 1)
		{
			UnityEngine.Debug.LogError("Illegal view ID:" + view.viewID + " method: " + methodName + " GO:" + view.gameObject.name);
		}
		if (PhotonNetwork.logLevel >= PhotonLogLevel.Full)
		{
			UnityEngine.Debug.Log(string.Concat("Sending RPC \"", methodName, "\" to target: ", target, " or player:", player, "."));
		}
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)0] = view.viewID;
		if (view.prefix > 0)
		{
			hashtable[(byte)1] = (short)view.prefix;
		}
		hashtable[(byte)2] = PhotonNetwork.ServerTimestamp;
		int value = 0;
		if (rpcShortcuts.TryGetValue(methodName, out value))
		{
			hashtable[(byte)5] = (byte)value;
		}
		else
		{
			hashtable[(byte)3] = methodName;
		}
		if (parameters != null && parameters.Length > 0)
		{
			hashtable[(byte)4] = parameters;
		}
		if (player != null)
		{
			if (LocalPlayer.ID == player.ID)
			{
				ExecuteRpc(hashtable, player.ID);
				return;
			}
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.TargetActors = new int[1] { player.ID };
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions2);
			return;
		}
		switch (target)
		{
		case PhotonTargets.All:
		{
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.InterestGroup = view.group;
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions9 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions9);
			ExecuteRpc(hashtable, LocalPlayer.ID);
			break;
		}
		case PhotonTargets.Others:
		{
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.InterestGroup = view.group;
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions8 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions8);
			break;
		}
		case PhotonTargets.AllBuffered:
		{
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.CachingOption = EventCaching.AddToRoomCache;
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions6 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions6);
			ExecuteRpc(hashtable, LocalPlayer.ID);
			break;
		}
		case PhotonTargets.OthersBuffered:
		{
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.CachingOption = EventCaching.AddToRoomCache;
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions4 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions4);
			break;
		}
		case PhotonTargets.MasterClient:
		{
			if (mMasterClientId == LocalPlayer.ID)
			{
				ExecuteRpc(hashtable, LocalPlayer.ID);
				break;
			}
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.Receivers = ReceiverGroup.MasterClient;
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions7 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions7);
			break;
		}
		case PhotonTargets.AllViaServer:
		{
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.InterestGroup = view.group;
			raiseEventOptions.Receivers = ReceiverGroup.All;
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions5 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions5);
			if (PhotonNetwork.offlineMode)
			{
				ExecuteRpc(hashtable, LocalPlayer.ID);
			}
			break;
		}
		case PhotonTargets.AllBufferedViaServer:
		{
			RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
			raiseEventOptions.InterestGroup = view.group;
			raiseEventOptions.Receivers = ReceiverGroup.All;
			raiseEventOptions.CachingOption = EventCaching.AddToRoomCache;
			raiseEventOptions.Encrypt = encrypt;
			RaiseEventOptions raiseEventOptions3 = raiseEventOptions;
			OpRaiseEvent(200, hashtable, sendReliable: true, raiseEventOptions3);
			if (PhotonNetwork.offlineMode)
			{
				ExecuteRpc(hashtable, LocalPlayer.ID);
			}
			break;
		}
		default:
			UnityEngine.Debug.LogError("Unsupported target enum: " + target);
			break;
		}
	}

	public void SetInterestGroups(byte[] disableGroups, byte[] enableGroups)
	{
		if (disableGroups != null)
		{
			if (disableGroups.Length == 0)
			{
				allowedReceivingGroups.Clear();
			}
			else
			{
				foreach (byte b in disableGroups)
				{
					if (b <= 0)
					{
						UnityEngine.Debug.LogError("Error: PhotonNetwork.SetInterestGroups was called with an illegal group number: " + b + ". The group number should be at least 1.");
					}
					else if (allowedReceivingGroups.Contains(b))
					{
						allowedReceivingGroups.Remove(b);
					}
				}
			}
		}
		if (enableGroups != null)
		{
			if (enableGroups.Length == 0)
			{
				for (byte b2 = 0; b2 < byte.MaxValue; b2++)
				{
					allowedReceivingGroups.Add(b2);
				}
				allowedReceivingGroups.Add(byte.MaxValue);
			}
			else
			{
				foreach (byte b3 in enableGroups)
				{
					if (b3 <= 0)
					{
						UnityEngine.Debug.LogError("Error: PhotonNetwork.SetInterestGroups was called with an illegal group number: " + b3 + ". The group number should be at least 1.");
					}
					else
					{
						allowedReceivingGroups.Add(b3);
					}
				}
			}
		}
		OpChangeGroups(disableGroups, enableGroups);
	}

	public void SetSendingEnabled(byte group, bool enabled)
	{
		if (!enabled)
		{
			blockSendingGroups.Add(group);
		}
		else
		{
			blockSendingGroups.Remove(group);
		}
	}

	public void SetSendingEnabled(byte[] disableGroups, byte[] enableGroups)
	{
		if (disableGroups != null)
		{
			foreach (byte item in disableGroups)
			{
				blockSendingGroups.Add(item);
			}
		}
		if (enableGroups != null)
		{
			foreach (byte item2 in enableGroups)
			{
				blockSendingGroups.Remove(item2);
			}
		}
	}

	public void NewSceneLoaded()
	{
		if (loadingLevelAndPausedNetwork)
		{
			loadingLevelAndPausedNetwork = false;
			PhotonNetwork.isMessageQueueRunning = true;
		}
		List<int> list = new List<int>();
		foreach (KeyValuePair<int, PhotonView> photonView in photonViewList)
		{
			PhotonView value = photonView.Value;
			if (value == null)
			{
				list.Add(photonView.Key);
			}
		}
		for (int i = 0; i < list.Count; i++)
		{
			int key = list[i];
			photonViewList.Remove(key);
		}
		if (list.Count > 0 && PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
		{
			UnityEngine.Debug.Log("New level loaded. Removed " + list.Count + " scene view IDs from last level.");
		}
	}

	public void RunViewUpdate()
	{
		if (!PhotonNetwork.connected || PhotonNetwork.offlineMode || mActors == null || mActors.Count <= 1)
		{
			return;
		}
		int num = 0;
		options.Reset();
		List<int> list = null;
		Dictionary<int, PhotonView>.Enumerator enumerator = photonViewList.GetEnumerator();
		while (enumerator.MoveNext())
		{
			PhotonView value = enumerator.Current.Value;
			if (value == null)
			{
				UnityEngine.Debug.LogError($"PhotonView with ID {enumerator.Current.Key} wasn't properly unregistered! Please report this case to developer@photonengine.com");
				if (list == null)
				{
					list = new List<int>(4);
				}
				list.Add(enumerator.Current.Key);
			}
			else
			{
				if (value.synchronization == ViewSynchronization.Off || !value.isMine || !value.gameObject.activeInHierarchy || blockSendingGroups.Contains(value.group))
				{
					continue;
				}
				object[] array = OnSerializeWrite(value);
				if (array == null)
				{
					continue;
				}
				if (value.synchronization == ViewSynchronization.ReliableDeltaCompressed || value.mixedModeIsReliable)
				{
					ExitGames.Client.Photon.Hashtable value2 = null;
					if (!dataPerGroupReliable.TryGetValue(value.group, out value2))
					{
						value2 = new ExitGames.Client.Photon.Hashtable(ObjectsInOneUpdate);
						dataPerGroupReliable[value.group] = value2;
					}
					value2.Add((byte)(value2.Count + 10), array);
					num++;
					if (value2.Count >= ObjectsInOneUpdate)
					{
						num -= value2.Count;
						options.InterestGroup = value.group;
						value2[(byte)0] = PhotonNetwork.ServerTimestamp;
						if (currentLevelPrefix >= 0)
						{
							value2[(byte)1] = currentLevelPrefix;
						}
						OpRaiseEvent(206, value2, sendReliable: true, options);
						value2.Clear();
					}
					continue;
				}
				ExitGames.Client.Photon.Hashtable value3 = null;
				if (!dataPerGroupUnreliable.TryGetValue(value.group, out value3))
				{
					value3 = new ExitGames.Client.Photon.Hashtable(ObjectsInOneUpdate);
					dataPerGroupUnreliable[value.group] = value3;
				}
				value3.Add((byte)(value3.Count + 10), array);
				num++;
				if (value3.Count >= ObjectsInOneUpdate)
				{
					num -= value3.Count;
					options.InterestGroup = value.group;
					value3[(byte)0] = PhotonNetwork.ServerTimestamp;
					if (currentLevelPrefix >= 0)
					{
						value3[(byte)1] = currentLevelPrefix;
					}
					OpRaiseEvent(201, value3, sendReliable: false, options);
					value3.Clear();
				}
			}
		}
		if (list != null)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				photonViewList.Remove(list[i]);
			}
		}
		if (num == 0)
		{
			return;
		}
		foreach (int key in dataPerGroupReliable.Keys)
		{
			options.InterestGroup = (byte)key;
			ExitGames.Client.Photon.Hashtable hashtable = dataPerGroupReliable[key];
			if (hashtable.Count != 0)
			{
				hashtable[(byte)0] = PhotonNetwork.ServerTimestamp;
				if (currentLevelPrefix >= 0)
				{
					hashtable[(byte)1] = currentLevelPrefix;
				}
				OpRaiseEvent(206, hashtable, sendReliable: true, options);
				hashtable.Clear();
			}
		}
		foreach (int key2 in dataPerGroupUnreliable.Keys)
		{
			options.InterestGroup = (byte)key2;
			ExitGames.Client.Photon.Hashtable hashtable2 = dataPerGroupUnreliable[key2];
			if (hashtable2.Count != 0)
			{
				hashtable2[(byte)0] = PhotonNetwork.ServerTimestamp;
				if (currentLevelPrefix >= 0)
				{
					hashtable2[(byte)1] = currentLevelPrefix;
				}
				OpRaiseEvent(201, hashtable2, sendReliable: false, options);
				hashtable2.Clear();
			}
		}
	}

	private object[] OnSerializeWrite(PhotonView view)
	{
		if (view.synchronization == ViewSynchronization.Off)
		{
			return null;
		}
		PhotonMessageInfo info = new PhotonMessageInfo(LocalPlayer, PhotonNetwork.ServerTimestamp, view);
		pStream.ResetWriteStream();
		pStream.SendNext(null);
		pStream.SendNext(null);
		pStream.SendNext(null);
		view.SerializeView(pStream, info);
		if (pStream.Count <= 3)
		{
			return null;
		}
		object[] array = pStream.ToArray();
		array[0] = view.viewID;
		array[1] = false;
		array[2] = null;
		if (view.synchronization == ViewSynchronization.Unreliable)
		{
			return array;
		}
		if (view.synchronization == ViewSynchronization.UnreliableOnChange)
		{
			if (AlmostEquals(array, view.lastOnSerializeDataSent))
			{
				if (view.mixedModeIsReliable)
				{
					return null;
				}
				view.mixedModeIsReliable = true;
				view.lastOnSerializeDataSent = array;
			}
			else
			{
				view.mixedModeIsReliable = false;
				view.lastOnSerializeDataSent = array;
			}
			return array;
		}
		if (view.synchronization == ViewSynchronization.ReliableDeltaCompressed)
		{
			object[] result = DeltaCompressionWrite(view.lastOnSerializeDataSent, array);
			view.lastOnSerializeDataSent = array;
			return result;
		}
		return null;
	}

	private void OnSerializeRead(object[] data, PhotonPlayer sender, int networkTime, short correctPrefix)
	{
		int num = (int)data[0];
		PhotonView photonView = GetPhotonView(num);
		if (photonView == null)
		{
			UnityEngine.Debug.LogWarning("Received OnSerialization for view ID " + num + ". We have no such PhotonView! Ignored this if you're leaving a room. State: " + State);
		}
		else if (photonView.prefix > 0 && correctPrefix != photonView.prefix)
		{
			UnityEngine.Debug.LogError("Received OnSerialization for view ID " + num + " with prefix " + correctPrefix + ". Our prefix is " + photonView.prefix);
		}
		else
		{
			if (photonView.group != 0 && !allowedReceivingGroups.Contains(photonView.group))
			{
				return;
			}
			if (photonView.synchronization == ViewSynchronization.ReliableDeltaCompressed)
			{
				object[] array = DeltaCompressionRead(photonView.lastOnSerializeDataReceived, data);
				if (array == null)
				{
					if (PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
					{
						UnityEngine.Debug.Log("Skipping packet for " + photonView.name + " [" + photonView.viewID + "] as we haven't received a full packet for delta compression yet. This is OK if it happens for the first few frames after joining a game.");
					}
					return;
				}
				photonView.lastOnSerializeDataReceived = array;
				data = array;
			}
			if (sender.ID != photonView.ownerId && (!photonView.OwnerShipWasTransfered || photonView.ownerId == 0) && photonView.currentMasterID == -1)
			{
				photonView.ownerId = sender.ID;
			}
			readStream.SetReadStream(data, 3);
			photonView.DeserializeView(info: new PhotonMessageInfo(sender, networkTime, photonView), stream: readStream);
		}
	}

	private object[] DeltaCompressionWrite(object[] previousContent, object[] currentContent)
	{
		if (currentContent == null || previousContent == null || previousContent.Length != currentContent.Length)
		{
			return currentContent;
		}
		if (currentContent.Length <= 3)
		{
			return null;
		}
		previousContent[1] = false;
		int num = 0;
		Queue<int> queue = null;
		for (int i = 3; i < currentContent.Length; i++)
		{
			object obj = currentContent[i];
			object two = previousContent[i];
			if (AlmostEquals(obj, two))
			{
				num++;
				previousContent[i] = null;
				continue;
			}
			previousContent[i] = obj;
			if (obj == null)
			{
				if (queue == null)
				{
					queue = new Queue<int>(currentContent.Length);
				}
				queue.Enqueue(i);
			}
		}
		if (num > 0)
		{
			if (num == currentContent.Length - 3)
			{
				return null;
			}
			previousContent[1] = true;
			if (queue != null)
			{
				previousContent[2] = queue.ToArray();
			}
		}
		previousContent[0] = currentContent[0];
		return previousContent;
	}

	private object[] DeltaCompressionRead(object[] lastOnSerializeDataReceived, object[] incomingData)
	{
		if (!(bool)incomingData[1])
		{
			return incomingData;
		}
		if (lastOnSerializeDataReceived == null)
		{
			return null;
		}
		int[] array = incomingData[2] as int[];
		for (int i = 3; i < incomingData.Length; i++)
		{
			if ((array == null || !array.Contains(i)) && incomingData[i] == null)
			{
				object obj = lastOnSerializeDataReceived[i];
				incomingData[i] = obj;
			}
		}
		return incomingData;
	}

	private bool AlmostEquals(object[] lastData, object[] currentContent)
	{
		if (lastData == null && currentContent == null)
		{
			return true;
		}
		if (lastData == null || currentContent == null || lastData.Length != currentContent.Length)
		{
			return false;
		}
		for (int i = 0; i < currentContent.Length; i++)
		{
			object one = currentContent[i];
			object two = lastData[i];
			if (!AlmostEquals(one, two))
			{
				return false;
			}
		}
		return true;
	}

	private bool AlmostEquals(object one, object two)
	{
		if (one == null || two == null)
		{
			return one == null && two == null;
		}
		if (!one.Equals(two))
		{
			if (one is Vector3 target)
			{
				Vector3 second = (Vector3)two;
				if (target.AlmostEquals(second, PhotonNetwork.precisionForVectorSynchronization))
				{
					return true;
				}
			}
			else if (one is Vector2 target2)
			{
				Vector2 second2 = (Vector2)two;
				if (target2.AlmostEquals(second2, PhotonNetwork.precisionForVectorSynchronization))
				{
					return true;
				}
			}
			else if (one is Quaternion target3)
			{
				Quaternion second3 = (Quaternion)two;
				if (target3.AlmostEquals(second3, PhotonNetwork.precisionForQuaternionSynchronization))
				{
					return true;
				}
			}
			else if (one is float target4)
			{
				float second4 = (float)two;
				if (target4.AlmostEquals(second4, PhotonNetwork.precisionForFloatSynchronization))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	protected internal static bool GetMethod(UnityEngine.MonoBehaviour monob, string methodType, out MethodInfo mi)
	{
		mi = null;
		if (monob == null || string.IsNullOrEmpty(methodType))
		{
			return false;
		}
		List<MethodInfo> methods = SupportClass.GetMethods(monob.GetType(), null);
		for (int i = 0; i < methods.Count; i++)
		{
			MethodInfo methodInfo = methods[i];
			if (methodInfo.Name.Equals(methodType))
			{
				mi = methodInfo;
				return true;
			}
		}
		return false;
	}

	protected internal void LoadLevelIfSynced()
	{
		if (!PhotonNetwork.automaticallySyncScene || PhotonNetwork.isMasterClient || PhotonNetwork.room == null || !PhotonNetwork.room.CustomProperties.ContainsKey("curScn"))
		{
			return;
		}
		object obj = PhotonNetwork.room.CustomProperties["curScn"];
		if (obj is int)
		{
			if (SceneManagerHelper.ActiveSceneBuildIndex != (int)obj)
			{
				PhotonNetwork.LoadLevel((int)obj);
			}
		}
		else if (obj is string && SceneManagerHelper.ActiveSceneName != (string)obj)
		{
			PhotonNetwork.LoadLevel((string)obj);
		}
	}

	protected internal void SetLevelInPropsIfSynced(object levelId)
	{
		if (!PhotonNetwork.automaticallySyncScene || !PhotonNetwork.isMasterClient || PhotonNetwork.room == null)
		{
			return;
		}
		if (levelId == null)
		{
			UnityEngine.Debug.LogError("Parameter levelId can't be null!");
			return;
		}
		if (PhotonNetwork.room.CustomProperties.ContainsKey("curScn"))
		{
			object obj = PhotonNetwork.room.CustomProperties["curScn"];
			if ((obj is int && SceneManagerHelper.ActiveSceneBuildIndex == (int)obj) || (obj is string && SceneManagerHelper.ActiveSceneName != null && SceneManagerHelper.ActiveSceneName.Equals((string)obj)))
			{
				return;
			}
		}
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		if (levelId is int)
		{
			hashtable["curScn"] = (int)levelId;
		}
		else if (levelId is string)
		{
			hashtable["curScn"] = (string)levelId;
		}
		else
		{
			UnityEngine.Debug.LogError("Parameter levelId must be int or string!");
		}
		PhotonNetwork.room.SetCustomProperties(hashtable);
		SendOutgoingCommands();
	}

	public void SetApp(string appId, string gameVersion)
	{
		AppId = appId.Trim();
		if (!string.IsNullOrEmpty(gameVersion))
		{
			PhotonNetwork.gameVersion = gameVersion.Trim();
		}
	}

	public bool WebRpc(string uriPath, object parameters)
	{
		Dictionary<byte, object> dictionary = new Dictionary<byte, object>();
		dictionary.Add(209, uriPath);
		dictionary.Add(208, parameters);
		return OpCustom(219, dictionary, sendReliable: true);
	}
}
public interface IPunObservable
{
	void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info);
}
public interface IPunCallbacks
{
	void OnConnectedToPhoton();

	void OnLeftRoom();

	void OnMasterClientSwitched(PhotonPlayer newMasterClient);

	void OnPhotonCreateRoomFailed(object[] codeAndMsg);

	void OnPhotonJoinRoomFailed(object[] codeAndMsg);

	void OnCreatedRoom();

	void OnJoinedLobby();

	void OnLeftLobby();

	void OnFailedToConnectToPhoton(DisconnectCause cause);

	void OnConnectionFail(DisconnectCause cause);

	void OnDisconnectedFromPhoton();

	void OnPhotonInstantiate(PhotonMessageInfo info);

	void OnReceivedRoomListUpdate();

	void OnJoinedRoom();

	void OnPhotonPlayerConnected(PhotonPlayer newPlayer);

	void OnPhotonPlayerDisconnected(PhotonPlayer otherPlayer);

	void OnPhotonRandomJoinFailed(object[] codeAndMsg);

	void OnConnectedToMaster();

	void OnPhotonMaxCccuReached();

	void OnPhotonCustomRoomPropertiesChanged(ExitGames.Client.Photon.Hashtable propertiesThatChanged);

	void OnPhotonPlayerPropertiesChanged(object[] playerAndUpdatedProps);

	void OnUpdatedFriendList();

	void OnCustomAuthenticationFailed(string debugMessage);

	void OnCustomAuthenticationResponse(Dictionary<string, object> data);

	void OnWebRpcResponse(OperationResponse response);

	void OnOwnershipRequest(object[] viewAndPlayer);

	void OnLobbyStatisticsUpdate();

	void OnPhotonPlayerActivityChanged(PhotonPlayer otherPlayer);

	void OnOwnershipTransfered(object[] viewAndPlayers);
}
public interface IPunPrefabPool
{
	GameObject Instantiate(string prefabId, Vector3 position, Quaternion rotation);

	void Destroy(GameObject gameObject);
}
namespace Photon
{
	public class MonoBehaviour : UnityEngine.MonoBehaviour
	{
		private PhotonView pvCache;

		public PhotonView photonView
		{
			get
			{
				if (pvCache == null)
				{
					pvCache = PhotonView.Get(this);
				}
				return pvCache;
			}
		}
	}
	public class PunBehaviour : MonoBehaviour, IPunCallbacks
	{
		public virtual void OnConnectedToPhoton()
		{
		}

		public virtual void OnLeftRoom()
		{
		}

		public virtual void OnMasterClientSwitched(PhotonPlayer newMasterClient)
		{
		}

		public virtual void OnPhotonCreateRoomFailed(object[] codeAndMsg)
		{
		}

		public virtual void OnPhotonJoinRoomFailed(object[] codeAndMsg)
		{
		}

		public virtual void OnCreatedRoom()
		{
		}

		public virtual void OnJoinedLobby()
		{
		}

		public virtual void OnLeftLobby()
		{
		}

		public virtual void OnFailedToConnectToPhoton(DisconnectCause cause)
		{
		}

		public virtual void OnDisconnectedFromPhoton()
		{
		}

		public virtual void OnConnectionFail(DisconnectCause cause)
		{
		}

		public virtual void OnPhotonInstantiate(PhotonMessageInfo info)
		{
		}

		public virtual void OnReceivedRoomListUpdate()
		{
		}

		public virtual void OnJoinedRoom()
		{
		}

		public virtual void OnPhotonPlayerConnected(PhotonPlayer newPlayer)
		{
		}

		public virtual void OnPhotonPlayerDisconnected(PhotonPlayer otherPlayer)
		{
		}

		public virtual void OnPhotonRandomJoinFailed(object[] codeAndMsg)
		{
		}

		public virtual void OnConnectedToMaster()
		{
		}

		public virtual void OnPhotonMaxCccuReached()
		{
		}

		public virtual void OnPhotonCustomRoomPropertiesChanged(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
		}

		public virtual void OnPhotonPlayerPropertiesChanged(object[] playerAndUpdatedProps)
		{
		}

		public virtual void OnUpdatedFriendList()
		{
		}

		public virtual void OnCustomAuthenticationFailed(string debugMessage)
		{
		}

		public virtual void OnCustomAuthenticationResponse(Dictionary<string, object> data)
		{
		}

		public virtual void OnWebRpcResponse(OperationResponse response)
		{
		}

		public virtual void OnOwnershipRequest(object[] viewAndPlayer)
		{
		}

		public virtual void OnLobbyStatisticsUpdate()
		{
		}

		public virtual void OnPhotonPlayerActivityChanged(PhotonPlayer otherPlayer)
		{
		}

		public virtual void OnOwnershipTransfered(object[] viewAndPlayers)
		{
		}
	}
}
public struct PhotonMessageInfo
{
	private readonly int timeInt;

	public readonly PhotonPlayer sender;

	public readonly PhotonView photonView;

	public double timestamp
	{
		get
		{
			uint num = (uint)timeInt;
			double num2 = num;
			return num2 / 1000.0;
		}
	}

	public PhotonMessageInfo(PhotonPlayer player, int timestamp, PhotonView view)
	{
		sender = player;
		timeInt = timestamp;
		photonView = view;
	}

	public override string ToString()
	{
		return string.Format("[PhotonMessageInfo: Sender='{1}' Senttime={0}]", timestamp, sender);
	}
}
internal class PunEvent
{
	public const byte RPC = 200;

	public const byte SendSerialize = 201;

	public const byte Instantiation = 202;

	public const byte CloseConnection = 203;

	public const byte Destroy = 204;

	public const byte RemoveCachedRPCs = 205;

	public const byte SendSerializeReliable = 206;

	public const byte DestroyPlayer = 207;

	public const byte AssignMaster = 208;

	public const byte OwnershipRequest = 209;

	public const byte OwnershipTransfer = 210;

	public const byte VacantViewIds = 211;
}
public class PhotonStream
{
	private bool write;

	private Queue<object> writeData;

	private object[] readData;

	internal byte currentItem;

	public bool isWriting => write;

	public bool isReading => !write;

	public int Count => (!isWriting) ? readData.Length : writeData.Count;

	public PhotonStream(bool write, object[] incomingData)
	{
		this.write = write;
		if (incomingData == null)
		{
			writeData = new Queue<object>(10);
		}
		else
		{
			readData = incomingData;
		}
	}

	public void SetReadStream(object[] incomingData, byte pos = 0)
	{
		readData = incomingData;
		currentItem = pos;
		write = false;
	}

	internal void ResetWriteStream()
	{
		writeData.Clear();
	}

	public object ReceiveNext()
	{
		if (write)
		{
			UnityEngine.Debug.LogError("Error: you cannot read this stream that you are writing!");
			return null;
		}
		object result = readData[currentItem];
		currentItem++;
		return result;
	}

	public object PeekNext()
	{
		if (write)
		{
			UnityEngine.Debug.LogError("Error: you cannot read this stream that you are writing!");
			return null;
		}
		return readData[currentItem];
	}

	public void SendNext(object obj)
	{
		if (!write)
		{
			UnityEngine.Debug.LogError("Error: you cannot write/send to this stream that you are reading!");
		}
		else
		{
			writeData.Enqueue(obj);
		}
	}

	public object[] ToArray()
	{
		return (!isWriting) ? readData : writeData.ToArray();
	}

	public void Serialize(ref bool myBool)
	{
		if (write)
		{
			writeData.Enqueue(myBool);
		}
		else if (readData.Length > currentItem)
		{
			myBool = (bool)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref int myInt)
	{
		if (write)
		{
			writeData.Enqueue(myInt);
		}
		else if (readData.Length > currentItem)
		{
			myInt = (int)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref string value)
	{
		if (write)
		{
			writeData.Enqueue(value);
		}
		else if (readData.Length > currentItem)
		{
			value = (string)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref char value)
	{
		if (write)
		{
			writeData.Enqueue(value);
		}
		else if (readData.Length > currentItem)
		{
			value = (char)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref short value)
	{
		if (write)
		{
			writeData.Enqueue(value);
		}
		else if (readData.Length > currentItem)
		{
			value = (short)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref float obj)
	{
		if (write)
		{
			writeData.Enqueue(obj);
		}
		else if (readData.Length > currentItem)
		{
			obj = (float)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref PhotonPlayer obj)
	{
		if (write)
		{
			writeData.Enqueue(obj);
		}
		else if (readData.Length > currentItem)
		{
			obj = (PhotonPlayer)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref Vector3 obj)
	{
		if (write)
		{
			writeData.Enqueue(obj);
		}
		else if (readData.Length > currentItem)
		{
			obj = (Vector3)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref Vector2 obj)
	{
		if (write)
		{
			writeData.Enqueue(obj);
		}
		else if (readData.Length > currentItem)
		{
			obj = (Vector2)readData[currentItem];
			currentItem++;
		}
	}

	public void Serialize(ref Quaternion obj)
	{
		if (write)
		{
			writeData.Enqueue(obj);
		}
		else if (readData.Length > currentItem)
		{
			obj = (Quaternion)readData[currentItem];
			currentItem++;
		}
	}
}
public class SceneManagerHelper
{
	public static string ActiveSceneName => SceneManager.GetActiveScene().name;

	public static int ActiveSceneBuildIndex => SceneManager.GetActiveScene().buildIndex;
}
public class WebRpcResponse
{
	public string Name { get; private set; }

	public int ReturnCode { get; private set; }

	public string DebugMessage { get; private set; }

	public Dictionary<string, object> Parameters { get; private set; }

	public WebRpcResponse(OperationResponse response)
	{
		response.Parameters.TryGetValue(209, out var value);
		Name = value as string;
		response.Parameters.TryGetValue(207, out value);
		ReturnCode = ((value == null) ? (-1) : ((byte)value));
		response.Parameters.TryGetValue(208, out value);
		Parameters = value as Dictionary<string, object>;
		response.Parameters.TryGetValue(206, out value);
		DebugMessage = value as string;
	}

	public string ToStringFull()
	{
		return string.Format("{0}={2}: {1} \"{3}\"", Name, SupportClass.DictionaryToString(Parameters), ReturnCode, DebugMessage);
	}
}
internal class PhotonHandler : UnityEngine.MonoBehaviour
{
	public static PhotonHandler SP;

	public int updateInterval;

	public int updateIntervalOnSerialize;

	private int nextSendTickCount;

	private int nextSendTickCountOnSerialize;

	private static bool sendThreadShouldRun;

	private static Stopwatch timerToStopConnectionInBackground;

	protected internal static bool AppQuits;

	protected internal static Type PingImplementation;

	private const string PlayerPrefsKey = "PUNCloudBestRegion";

	internal static CloudRegionCode BestRegionCodeInPreferences
	{
		get
		{
			string @string = PlayerPrefs.GetString("PUNCloudBestRegion", string.Empty);
			if (!string.IsNullOrEmpty(@string))
			{
				return Region.Parse(@string);
			}
			return CloudRegionCode.none;
		}
		set
		{
			if (value == CloudRegionCode.none)
			{
				PlayerPrefs.DeleteKey("PUNCloudBestRegion");
			}
			else
			{
				PlayerPrefs.SetString("PUNCloudBestRegion", value.ToString());
			}
		}
	}

	protected void Awake()
	{
		if (SP != null && SP != this && SP.gameObject != null)
		{
			UnityEngine.Object.DestroyImmediate(SP.gameObject);
		}
		SP = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		updateInterval = 1000 / PhotonNetwork.sendRate;
		updateIntervalOnSerialize = 1000 / PhotonNetwork.sendRateOnSerialize;
		StartFallbackSendAckThread();
	}

	protected void Start()
	{
		SceneManager.sceneLoaded += delegate
		{
			PhotonNetwork.networkingPeer.NewSceneLoaded();
			PhotonNetwork.networkingPeer.SetLevelInPropsIfSynced(SceneManagerHelper.ActiveSceneName);
		};
	}

	protected void OnApplicationQuit()
	{
		AppQuits = true;
		StopFallbackSendAckThread();
		PhotonNetwork.Disconnect();
	}

	protected void OnApplicationPause(bool pause)
	{
		if (PhotonNetwork.BackgroundTimeout > 0.1f)
		{
			if (timerToStopConnectionInBackground == null)
			{
				timerToStopConnectionInBackground = new Stopwatch();
			}
			timerToStopConnectionInBackground.Reset();
			if (pause)
			{
				timerToStopConnectionInBackground.Start();
			}
			else
			{
				timerToStopConnectionInBackground.Stop();
			}
		}
	}

	protected void OnDestroy()
	{
		StopFallbackSendAckThread();
	}

	protected void Update()
	{
		if (PhotonNetwork.networkingPeer == null)
		{
			UnityEngine.Debug.LogError("NetworkPeer broke!");
		}
		else
		{
			if (PhotonNetwork.connectionStateDetailed == ClientState.PeerCreated || PhotonNetwork.connectionStateDetailed == ClientState.Disconnected || PhotonNetwork.offlineMode || !PhotonNetwork.isMessageQueueRunning)
			{
				return;
			}
			bool flag = true;
			while (PhotonNetwork.isMessageQueueRunning && flag)
			{
				flag = PhotonNetwork.networkingPeer.DispatchIncomingCommands();
			}
			int num = (int)(Time.realtimeSinceStartup * 1000f);
			if (PhotonNetwork.isMessageQueueRunning && num > nextSendTickCountOnSerialize)
			{
				PhotonNetwork.networkingPeer.RunViewUpdate();
				nextSendTickCountOnSerialize = num + updateIntervalOnSerialize;
				nextSendTickCount = 0;
			}
			num = (int)(Time.realtimeSinceStartup * 1000f);
			if (num > nextSendTickCount)
			{
				bool flag2 = true;
				while (PhotonNetwork.isMessageQueueRunning && flag2)
				{
					flag2 = PhotonNetwork.networkingPeer.SendOutgoingCommands();
				}
				nextSendTickCount = num + updateInterval;
			}
		}
	}

	protected void OnJoinedRoom()
	{
		PhotonNetwork.networkingPeer.LoadLevelIfSynced();
	}

	protected void OnCreatedRoom()
	{
		PhotonNetwork.networkingPeer.SetLevelInPropsIfSynced(SceneManagerHelper.ActiveSceneName);
	}

	public static void StartFallbackSendAckThread()
	{
		if (!sendThreadShouldRun)
		{
			sendThreadShouldRun = true;
			SupportClass.StartBackgroundCalls(FallbackSendAckThread, 100, string.Empty);
		}
	}

	public static void StopFallbackSendAckThread()
	{
		sendThreadShouldRun = false;
	}

	public static bool FallbackSendAckThread()
	{
		if (sendThreadShouldRun && !PhotonNetwork.offlineMode && PhotonNetwork.networkingPeer != null)
		{
			if (timerToStopConnectionInBackground != null && PhotonNetwork.BackgroundTimeout > 0.1f && (float)timerToStopConnectionInBackground.ElapsedMilliseconds > PhotonNetwork.BackgroundTimeout * 1000f)
			{
				if (PhotonNetwork.connected)
				{
					PhotonNetwork.Disconnect();
				}
				timerToStopConnectionInBackground.Stop();
				timerToStopConnectionInBackground.Reset();
				return sendThreadShouldRun;
			}
			if (!PhotonNetwork.isMessageQueueRunning || PhotonNetwork.networkingPeer.ConnectionTime - PhotonNetwork.networkingPeer.LastSendOutgoingTime > 200)
			{
				PhotonNetwork.networkingPeer.SendAcksOnly();
			}
		}
		return sendThreadShouldRun;
	}

	protected internal static void PingAvailableRegionsAndConnectToBest()
	{
		SP.StartCoroutine(SP.PingAvailableRegionsCoroutine(connectToBest: true));
	}

	internal IEnumerator PingAvailableRegionsCoroutine(bool connectToBest)
	{
		while (PhotonNetwork.networkingPeer.AvailableRegions == null)
		{
			if (PhotonNetwork.connectionStateDetailed != ClientState.ConnectingToNameServer && PhotonNetwork.connectionStateDetailed != ClientState.ConnectedToNameServer)
			{
				UnityEngine.Debug.LogError("Call ConnectToNameServer to ping available regions.");
				yield break;
			}
			UnityEngine.Debug.Log(string.Concat("Waiting for AvailableRegions. State: ", PhotonNetwork.connectionStateDetailed, " Server: ", PhotonNetwork.Server, " PhotonNetwork.networkingPeer.AvailableRegions ", PhotonNetwork.networkingPeer.AvailableRegions != null));
			yield return new WaitForSeconds(0.25f);
		}
		if (PhotonNetwork.networkingPeer.AvailableRegions == null || PhotonNetwork.networkingPeer.AvailableRegions.Count == 0)
		{
			UnityEngine.Debug.LogError("No regions available. Are you sure your appid is valid and setup?");
			yield break;
		}
		PhotonPingManager pingManager = new PhotonPingManager();
		foreach (Region availableRegion in PhotonNetwork.networkingPeer.AvailableRegions)
		{
			SP.StartCoroutine(pingManager.PingSocket(availableRegion));
		}
		while (!pingManager.Done)
		{
			yield return new WaitForSeconds(0.1f);
		}
		Region best = pingManager.BestRegion;
		BestRegionCodeInPreferences = best.Code;
		UnityEngine.Debug.Log(string.Concat("Found best region: '", best.Code, "' ping: ", best.Ping, ". Calling ConnectToRegionMaster() is: ", connectToBest));
		if (connectToBest)
		{
			PhotonNetwork.networkingPeer.ConnectToRegionMaster(best.Code);
		}
	}
}
public class PhotonLagSimulationGui : UnityEngine.MonoBehaviour
{
	public Rect WindowRect = new Rect(0f, 100f, 120f, 100f);

	public int WindowId = 101;

	public bool Visible = true;

	public PhotonPeer Peer { get; set; }

	public void Start()
	{
		Peer = PhotonNetwork.networkingPeer;
	}

	public void OnGUI()
	{
		if (Visible)
		{
			if (Peer == null)
			{
				WindowRect = GUILayout.Window(WindowId, WindowRect, NetSimHasNoPeerWindow, "Netw. Sim.");
			}
			else
			{
				WindowRect = GUILayout.Window(WindowId, WindowRect, NetSimWindow, "Netw. Sim.");
			}
		}
	}

	private void NetSimHasNoPeerWindow(int windowId)
	{
		GUILayout.Label("No peer to communicate with. ");
	}

	private void NetSimWindow(int windowId)
	{
		GUILayout.Label($"Rtt:{Peer.RoundTripTime,4} +/-{Peer.RoundTripTimeVariance,3}");
		bool isSimulationEnabled = Peer.IsSimulationEnabled;
		bool flag = GUILayout.Toggle(isSimulationEnabled, "Simulate");
		if (flag != isSimulationEnabled)
		{
			Peer.IsSimulationEnabled = flag;
		}
		float num = Peer.NetworkSimulationSettings.IncomingLag;
		GUILayout.Label("Lag " + num);
		num = GUILayout.HorizontalSlider(num, 0f, 500f);
		Peer.NetworkSimulationSettings.IncomingLag = (int)num;
		Peer.NetworkSimulationSettings.OutgoingLag = (int)num;
		float num2 = Peer.NetworkSimulationSettings.IncomingJitter;
		GUILayout.Label("Jit " + num2);
		num2 = GUILayout.HorizontalSlider(num2, 0f, 100f);
		Peer.NetworkSimulationSettings.IncomingJitter = (int)num2;
		Peer.NetworkSimulationSettings.OutgoingJitter = (int)num2;
		float num3 = Peer.NetworkSimulationSettings.IncomingLossPercentage;
		GUILayout.Label("Loss " + num3);
		num3 = GUILayout.HorizontalSlider(num3, 0f, 10f);
		Peer.NetworkSimulationSettings.IncomingLossPercentage = (int)num3;
		Peer.NetworkSimulationSettings.OutgoingLossPercentage = (int)num3;
		if (GUI.changed)
		{
			WindowRect.height = 100f;
		}
		GUI.DragWindow();
	}
}
public static class PhotonNetwork
{
	public delegate void EventCallback(byte eventCode, object content, int senderId);

	public const string versionPUN = "1.88";

	internal static readonly PhotonHandler photonMono;

	internal static NetworkingPeer networkingPeer;

	public static readonly int MAX_VIEW_IDS;

	internal const string serverSettingsAssetFile = "PhotonServerSettings";

	public static ServerSettings PhotonServerSettings;

	public static bool InstantiateInRoomOnly;

	public static PhotonLogLevel logLevel;

	public static float precisionForVectorSynchronization;

	public static float precisionForQuaternionSynchronization;

	public static float precisionForFloatSynchronization;

	public static bool UseRpcMonoBehaviourCache;

	public static bool UsePrefabCache;

	public static Dictionary<string, GameObject> PrefabCache;

	public static HashSet<GameObject> SendMonoMessageTargets;

	public static Type SendMonoMessageTargetType;

	public static bool StartRpcsAsCoroutine;

	private static bool isOfflineMode;

	private static Room offlineModeRoom;

	[Obsolete("Used for compatibility with Unity networking only.")]
	public static int maxConnections;

	private static bool _mAutomaticallySyncScene;

	private static bool m_autoCleanUpPlayerObjects;

	private static int sendInterval;

	private static int sendIntervalOnSerialize;

	private static bool m_isMessageQueueRunning;

	private static bool UsePreciseTimer;

	private static Stopwatch startupStopwatch;

	public static float BackgroundTimeout;

	public static EventCallback OnEventCall;

	internal static int lastUsedViewSubId;

	internal static int lastUsedViewSubIdStatic;

	internal static List<int> manuallyAllocatedViewIds;

	public static string gameVersion { get; set; }

	public static string ServerAddress => (networkingPeer == null) ? "<not connected>" : networkingPeer.ServerAddress;

	public static CloudRegionCode CloudRegion => (networkingPeer == null || !connected || Server == ServerConnection.NameServer) ? CloudRegionCode.none : networkingPeer.CloudRegion;

	public static bool connected
	{
		get
		{
			if (offlineMode)
			{
				return true;
			}
			if (networkingPeer == null)
			{
				return false;
			}
			return !networkingPeer.IsInitialConnect && networkingPeer.State != ClientState.PeerCreated && networkingPeer.State != ClientState.Disconnected && networkingPeer.State != ClientState.Disconnecting && networkingPeer.State != ClientState.ConnectingToNameServer;
		}
	}

	public static bool connecting => networkingPeer.IsInitialConnect && !offlineMode;

	public static bool connectedAndReady
	{
		get
		{
			if (!connected)
			{
				return false;
			}
			if (offlineMode)
			{
				return true;
			}
			switch (connectionStateDetailed)
			{
			case ClientState.PeerCreated:
			case ClientState.ConnectingToGameserver:
			case ClientState.Joining:
			case ClientState.ConnectingToMasterserver:
			case ClientState.Disconnecting:
			case ClientState.Disconnected:
			case ClientState.ConnectingToNameServer:
			case ClientState.Authenticating:
				return false;
			default:
				return true;
			}
		}
	}

	public static ConnectionState connectionState
	{
		get
		{
			if (offlineMode)
			{
				return ConnectionState.Connected;
			}
			if (networkingPeer == null)
			{
				return ConnectionState.Disconnected;
			}
			return networkingPeer.PeerState switch
			{
				PeerStateValue.Disconnected => ConnectionState.Disconnected, 
				PeerStateValue.Connecting => ConnectionState.Connecting, 
				PeerStateValue.Connected => ConnectionState.Connected, 
				PeerStateValue.Disconnecting => ConnectionState.Disconnecting, 
				PeerStateValue.InitializingApplication => ConnectionState.InitializingApplication, 
				_ => ConnectionState.Disconnected, 
			};
		}
	}

	public static ClientState connectionStateDetailed
	{
		get
		{
			if (offlineMode)
			{
				return (offlineModeRoom == null) ? ClientState.ConnectedToMaster : ClientState.Joined;
			}
			if (networkingPeer == null)
			{
				return ClientState.Disconnected;
			}
			return networkingPeer.State;
		}
	}

	public static ServerConnection Server => (networkingPeer == null) ? ServerConnection.NameServer : networkingPeer.Server;

	public static AuthenticationValues AuthValues
	{
		get
		{
			return (networkingPeer == null) ? null : networkingPeer.AuthValues;
		}
		set
		{
			if (networkingPeer != null)
			{
				networkingPeer.AuthValues = value;
			}
		}
	}

	public static Room room
	{
		get
		{
			if (isOfflineMode)
			{
				return offlineModeRoom;
			}
			return networkingPeer.CurrentRoom;
		}
	}

	public static PhotonPlayer player
	{
		get
		{
			if (networkingPeer == null)
			{
				return null;
			}
			return networkingPeer.LocalPlayer;
		}
	}

	public static PhotonPlayer masterClient
	{
		get
		{
			if (offlineMode)
			{
				return player;
			}
			if (networkingPeer == null)
			{
				return null;
			}
			return networkingPeer.GetPlayerWithId(networkingPeer.mMasterClientId);
		}
	}

	public static string playerName
	{
		get
		{
			return networkingPeer.PlayerName;
		}
		set
		{
			networkingPeer.PlayerName = value;
		}
	}

	public static PhotonPlayer[] playerList
	{
		get
		{
			if (networkingPeer == null)
			{
				return new PhotonPlayer[0];
			}
			return networkingPeer.mPlayerListCopy;
		}
	}

	public static PhotonPlayer[] otherPlayers
	{
		get
		{
			if (networkingPeer == null)
			{
				return new PhotonPlayer[0];
			}
			return networkingPeer.mOtherPlayerListCopy;
		}
	}

	public static List<FriendInfo> Friends { get; internal set; }

	public static int FriendsListAge => (networkingPeer != null) ? networkingPeer.FriendListAge : 0;

	public static IPunPrefabPool PrefabPool
	{
		get
		{
			return networkingPeer.ObjectPool;
		}
		set
		{
			networkingPeer.ObjectPool = value;
		}
	}

	public static bool offlineMode
	{
		get
		{
			return isOfflineMode;
		}
		set
		{
			if (value == isOfflineMode)
			{
				return;
			}
			if (value && connected)
			{
				UnityEngine.Debug.LogError("Can't start OFFLINE mode while connected!");
				return;
			}
			if (networkingPeer.PeerState != 0)
			{
				networkingPeer.Disconnect();
			}
			isOfflineMode = value;
			if (isOfflineMode)
			{
				networkingPeer.ChangeLocalID(-1);
				NetworkingPeer.SendMonoMessage(PhotonNetworkingMessage.OnConnectedToMaster);
			}
			else
			{
				offlineModeRoom = null;
				networkingPeer.ChangeLocalID(-1);
			}
		}
	}

	public static bool automaticallySyncScene
	{
		get
		{
			return _mAutomaticallySyncScene;
		}
		set
		{
			_mAutomaticallySyncScene = value;
			if (_mAutomaticallySyncScene && room != null)
			{
				networkingPeer.LoadLevelIfSynced();
			}
		}
	}

	public static bool autoCleanUpPlayerObjects
	{
		get
		{
			return m_autoCleanUpPlayerObjects;
		}
		set
		{
			if (room != null)
			{
				UnityEngine.Debug.LogError("Setting autoCleanUpPlayerObjects while in a room is not supported.");
			}
			else
			{
				m_autoCleanUpPlayerObjects = value;
			}
		}
	}

	public static bool autoJoinLobby
	{
		get
		{
			return PhotonServerSettings.JoinLobby;
		}
		set
		{
			PhotonServerSettings.JoinLobby = value;
		}
	}

	public static bool EnableLobbyStatistics
	{
		get
		{
			return PhotonServerSettings.EnableLobbyStatistics;
		}
		set
		{
			PhotonServerSettings.EnableLobbyStatistics = value;
		}
	}

	public static List<TypedLobbyInfo> LobbyStatistics
	{
		get
		{
			return networkingPeer.LobbyStatistics;
		}
		private set
		{
			networkingPeer.LobbyStatistics = value;
		}
	}

	public static bool insideLobby => networkingPeer.insideLobby;

	public static TypedLobby lobby
	{
		get
		{
			return networkingPeer.lobby;
		}
		set
		{
			networkingPeer.lobby = value;
		}
	}

	public static int sendRate
	{
		get
		{
			return 1000 / sendInterval;
		}
		set
		{
			sendInterval = 1000 / value;
			if (photonMono != null)
			{
				photonMono.updateInterval = sendInterval;
			}
			if (value < sendRateOnSerialize)
			{
				sendRateOnSerialize = value;
			}
		}
	}

	public static int sendRateOnSerialize
	{
		get
		{
			return 1000 / sendIntervalOnSerialize;
		}
		set
		{
			if (value > sendRate)
			{
				UnityEngine.Debug.LogError("Error: Can not set the OnSerialize rate higher than the overall SendRate.");
				value = sendRate;
			}
			sendIntervalOnSerialize = 1000 / value;
			if (photonMono != null)
			{
				photonMono.updateIntervalOnSerialize = sendIntervalOnSerialize;
			}
		}
	}

	public static bool isMessageQueueRunning
	{
		get
		{
			return m_isMessageQueueRunning;
		}
		set
		{
			if (value)
			{
				PhotonHandler.StartFallbackSendAckThread();
			}
			networkingPeer.IsSendingOnlyAcks = !value;
			m_isMessageQueueRunning = value;
		}
	}

	public static int unreliableCommandsLimit
	{
		get
		{
			return networkingPeer.LimitOfUnreliableCommands;
		}
		set
		{
			networkingPeer.LimitOfUnreliableCommands = value;
		}
	}

	public static double time
	{
		get
		{
			uint serverTimestamp = (uint)ServerTimestamp;
			double num = serverTimestamp;
			return num / 1000.0;
		}
	}

	public static int ServerTimestamp
	{
		get
		{
			if (offlineMode)
			{
				if (UsePreciseTimer && startupStopwatch != null && startupStopwatch.IsRunning)
				{
					return (int)startupStopwatch.ElapsedMilliseconds;
				}
				return Environment.TickCount;
			}
			return networkingPeer.ServerTimeInMilliSeconds;
		}
	}

	public static bool isMasterClient
	{
		get
		{
			if (offlineMode)
			{
				return true;
			}
			return networkingPeer.mMasterClientId == player.ID;
		}
	}

	public static bool inRoom => connectionStateDetailed == ClientState.Joined;

	public static bool isNonMasterClientInRoom => !isMasterClient && room != null;

	public static int countOfPlayersOnMaster => networkingPeer.PlayersOnMasterCount;

	public static int countOfPlayersInRooms => networkingPeer.PlayersInRoomsCount;

	public static int countOfPlayers => networkingPeer.PlayersInRoomsCount + networkingPeer.PlayersOnMasterCount;

	public static int countOfRooms => networkingPeer.RoomsCount;

	public static bool NetworkStatisticsEnabled
	{
		get
		{
			return networkingPeer.TrafficStatsEnabled;
		}
		set
		{
			networkingPeer.TrafficStatsEnabled = value;
		}
	}

	public static int ResentReliableCommands => networkingPeer.ResentReliableCommands;

	public static bool CrcCheckEnabled
	{
		get
		{
			return networkingPeer.CrcEnabled;
		}
		set
		{
			if (!connected && !connecting)
			{
				networkingPeer.CrcEnabled = value;
			}
			else
			{
				UnityEngine.Debug.Log("Can't change CrcCheckEnabled while being connected. CrcCheckEnabled stays " + networkingPeer.CrcEnabled);
			}
		}
	}

	public static int PacketLossByCrcCheck => networkingPeer.PacketLossByCrc;

	public static int MaxResendsBeforeDisconnect
	{
		get
		{
			return networkingPeer.SentCountAllowance;
		}
		set
		{
			if (value < 3)
			{
				value = 3;
			}
			if (value > 10)
			{
				value = 10;
			}
			networkingPeer.SentCountAllowance = value;
		}
	}

	public static int QuickResends
	{
		get
		{
			return networkingPeer.QuickResendAttempts;
		}
		set
		{
			if (value < 0)
			{
				value = 0;
			}
			if (value > 3)
			{
				value = 3;
			}
			networkingPeer.QuickResendAttempts = (byte)value;
		}
	}

	public static bool UseAlternativeUdpPorts { get; set; }

	static PhotonNetwork()
	{
		MAX_VIEW_IDS = 1000;
		PhotonServerSettings = (ServerSettings)Resources.Load("PhotonServerSettings", typeof(ServerSettings));
		InstantiateInRoomOnly = true;
		logLevel = PhotonLogLevel.ErrorsOnly;
		precisionForVectorSynchronization = 9.9E-05f;
		precisionForQuaternionSynchronization = 1f;
		precisionForFloatSynchronization = 0.01f;
		UsePrefabCache = true;
		PrefabCache = new Dictionary<string, GameObject>();
		SendMonoMessageTargetType = typeof(UnityEngine.MonoBehaviour);
		StartRpcsAsCoroutine = true;
		isOfflineMode = false;
		offlineModeRoom = null;
		_mAutomaticallySyncScene = false;
		m_autoCleanUpPlayerObjects = true;
		sendInterval = 50;
		sendIntervalOnSerialize = 100;
		m_isMessageQueueRunning = true;
		UsePreciseTimer = false;
		BackgroundTimeout = 60f;
		lastUsedViewSubId = 0;
		lastUsedViewSubIdStatic = 0;
		manuallyAllocatedViewIds = new List<int>();
		if (PhotonServerSettings != null)
		{
			UnityEngine.Application.runInBackground = PhotonServerSettings.RunInBackground;
		}
		GameObject gameObject = new GameObject();
		photonMono = gameObject.AddComponent<PhotonHandler>();
		gameObject.name = "PhotonMono";
		gameObject.hideFlags = HideFlags.HideInHierarchy;
		ConnectionProtocol protocol = PhotonServerSettings.Protocol;
		networkingPeer = new NetworkingPeer(string.Empty, protocol);
		networkingPeer.QuickResendAttempts = 2;
		networkingPeer.SentCountAllowance = 7;
		if (UsePreciseTimer)
		{
			UnityEngine.Debug.Log("Using Stopwatch as precision timer for PUN.");
			startupStopwatch = new Stopwatch();
			startupStopwatch.Start();
			networkingPeer.LocalMsTimestampDelegate = () => (int)startupStopwatch.ElapsedMilliseconds;
		}
		CustomTypes.Register();
	}

	public static void SwitchToProtocol(ConnectionProtocol cp)
	{
		networkingPeer.TransportProtocol = cp;
	}

	public static bool ConnectUsingSettings(string gameVersion)
	{
		if (networkingPeer.PeerState != 0)
		{
			UnityEngine.Debug.LogWarning("ConnectUsingSettings() failed. Can only connect while in state 'Disconnected'. Current state: " + networkingPeer.PeerState);
			return false;
		}
		if (PhotonServerSettings == null)
		{
			UnityEngine.Debug.LogError("Can't connect: Loading settings failed. ServerSettings asset must be in any 'Resources' folder as: PhotonServerSettings");
			return false;
		}
		if (PhotonServerSettings.HostType == ServerSettings.HostingOption.NotSet)
		{
			UnityEngine.Debug.LogError("You did not select a Hosting Type in your PhotonServerSettings. Please set it up or don't use ConnectUsingSettings().");
			return false;
		}
		if (logLevel == PhotonLogLevel.ErrorsOnly)
		{
			logLevel = PhotonServerSettings.PunLogging;
		}
		if (networkingPeer.DebugOut == DebugLevel.ERROR)
		{
			networkingPeer.DebugOut = PhotonServerSettings.NetworkLogging;
		}
		SwitchToProtocol(PhotonServerSettings.Protocol);
		networkingPeer.SetApp(PhotonServerSettings.AppID, gameVersion);
		if (PhotonServerSettings.HostType == ServerSettings.HostingOption.OfflineMode)
		{
			offlineMode = true;
			return true;
		}
		if (offlineMode)
		{
			UnityEngine.Debug.LogWarning("ConnectUsingSettings() disabled the offline mode. No longer offline.");
		}
		offlineMode = false;
		isMessageQueueRunning = true;
		networkingPeer.IsInitialConnect = true;
		if (PhotonServerSettings.HostType == ServerSettings.HostingOption.SelfHosted)
		{
			networkingPeer.IsUsingNameServer = false;
			networkingPeer.MasterServerAddress = ((PhotonServerSettings.ServerPort != 0) ? (PhotonServerSettings.ServerAddress + ":" + PhotonServerSettings.ServerPort) : PhotonServerSettings.ServerAddress);
			return networkingPeer.Connect(networkingPeer.MasterServerAddress, ServerConnection.MasterServer);
		}
		if (PhotonServerSettings.HostType == ServerSettings.HostingOption.BestRegion)
		{
			return ConnectToBestCloudServer(gameVersion);
		}
		return networkingPeer.ConnectToRegionMaster(PhotonServerSettings.PreferredRegion);
	}

	public static bool ConnectToMaster(string masterServerAddress, int port, string appID, string gameVersion)
	{
		if (networkingPeer.PeerState != 0)
		{
			UnityEngine.Debug.LogWarning("ConnectToMaster() failed. Can only connect while in state 'Disconnected'. Current state: " + networkingPeer.PeerState);
			return false;
		}
		if (offlineMode)
		{
			offlineMode = false;
			UnityEngine.Debug.LogWarning("ConnectToMaster() disabled the offline mode. No longer offline.");
		}
		if (!isMessageQueueRunning)
		{
			isMessageQueueRunning = true;
			UnityEngine.Debug.LogWarning("ConnectToMaster() enabled isMessageQueueRunning. Needs to be able to dispatch incoming messages.");
		}
		networkingPeer.SetApp(appID, gameVersion);
		networkingPeer.IsUsingNameServer = false;
		networkingPeer.IsInitialConnect = true;
		networkingPeer.MasterServerAddress = ((port != 0) ? (masterServerAddress + ":" + port) : masterServerAddress);
		return networkingPeer.Connect(networkingPeer.MasterServerAddress, ServerConnection.MasterServer);
	}

	public static bool Reconnect()
	{
		if (string.IsNullOrEmpty(networkingPeer.MasterServerAddress))
		{
			UnityEngine.Debug.LogWarning("Reconnect() failed. It seems the client wasn't connected before?! Current state: " + networkingPeer.PeerState);
			return false;
		}
		if (networkingPeer.PeerState != 0)
		{
			UnityEngine.Debug.LogWarning("Reconnect() failed. Can only connect while in state 'Disconnected'. Current state: " + networkingPeer.PeerState);
			return false;
		}
		if (offlineMode)
		{
			offlineMode = false;
			UnityEngine.Debug.LogWarning("Reconnect() disabled the offline mode. No longer offline.");
		}
		if (!isMessageQueueRunning)
		{
			isMessageQueueRunning = true;
			UnityEngine.Debug.LogWarning("Reconnect() enabled isMessageQueueRunning. Needs to be able to dispatch incoming messages.");
		}
		networkingPeer.IsUsingNameServer = false;
		networkingPeer.IsInitialConnect = false;
		return networkingPeer.ReconnectToMaster();
	}

	public static bool ReconnectAndRejoin()
	{
		if (networkingPeer.PeerState != 0)
		{
			UnityEngine.Debug.LogWarning("ReconnectAndRejoin() failed. Can only connect while in state 'Disconnected'. Current state: " + networkingPeer.PeerState);
			return false;
		}
		if (offlineMode)
		{
			offlineMode = false;
			UnityEngine.Debug.LogWarning("ReconnectAndRejoin() disabled the offline mode. No longer offline.");
		}
		if (string.IsNullOrEmpty(networkingPeer.GameServerAddress))
		{
			UnityEngine.Debug.LogWarning("ReconnectAndRejoin() failed. It seems the client wasn't connected to a game server before (no address).");
			return false;
		}
		if (networkingPeer.enterRoomParamsCache == null)
		{
			UnityEngine.Debug.LogWarning("ReconnectAndRejoin() failed. It seems the client doesn't have any previous room to re-join.");
			return false;
		}
		if (!isMessageQueueRunning)
		{
			isMessageQueueRunning = true;
			UnityEngine.Debug.LogWarning("ReconnectAndRejoin() enabled isMessageQueueRunning. Needs to be able to dispatch incoming messages.");
		}
		networkingPeer.IsUsingNameServer = false;
		networkingPeer.IsInitialConnect = false;
		return networkingPeer.ReconnectAndRejoin();
	}

	public static bool ConnectToBestCloudServer(string gameVersion)
	{
		if (networkingPeer.PeerState != 0)
		{
			UnityEngine.Debug.LogWarning("ConnectToBestCloudServer() failed. Can only connect while in state 'Disconnected'. Current state: " + networkingPeer.PeerState);
			return false;
		}
		if (PhotonServerSettings == null)
		{
			UnityEngine.Debug.LogError("Can't connect: Loading settings failed. ServerSettings asset must be in any 'Resources' folder as: PhotonServerSettings");
			return false;
		}
		if (PhotonServerSettings.HostType == ServerSettings.HostingOption.OfflineMode)
		{
			return ConnectUsingSettings(gameVersion);
		}
		networkingPeer.IsInitialConnect = true;
		networkingPeer.SetApp(PhotonServerSettings.AppID, gameVersion);
		CloudRegionCode bestRegionCodeInPreferences = PhotonHandler.BestRegionCodeInPreferences;
		if (bestRegionCodeInPreferences != CloudRegionCode.none)
		{
			UnityEngine.Debug.Log("Best region found in PlayerPrefs. Connecting to: " + bestRegionCodeInPreferences);
			return networkingPeer.ConnectToRegionMaster(bestRegionCodeInPreferences);
		}
		return networkingPeer.ConnectToNameServer();
	}

	public static bool ConnectToRegion(CloudRegionCode region, string gameVersion)
	{
		if (networkingPeer.PeerState != 0)
		{
			UnityEngine.Debug.LogWarning("ConnectToRegion() failed. Can only connect while in state 'Disconnected'. Current state: " + networkingPeer.PeerState);
			return false;
		}
		if (PhotonServerSettings == null)
		{
			UnityEngine.Debug.LogError("Can't connect: ServerSettings asset must be in any 'Resources' folder as: PhotonServerSettings");
			return false;
		}
		if (PhotonServerSettings.HostType == ServerSettings.HostingOption.OfflineMode)
		{
			return ConnectUsingSettings(gameVersion);
		}
		networkingPeer.IsInitialConnect = true;
		networkingPeer.SetApp(PhotonServerSettings.AppID, gameVersion);
		if (region != CloudRegionCode.none)
		{
			UnityEngine.Debug.Log("ConnectToRegion: " + region);
			return networkingPeer.ConnectToRegionMaster(region);
		}
		return false;
	}

	public static void OverrideBestCloudServer(CloudRegionCode region)
	{
		PhotonHandler.BestRegionCodeInPreferences = region;
	}

	public static void RefreshCloudServerRating()
	{
		throw new NotImplementedException("not available at the moment");
	}

	public static void NetworkStatisticsReset()
	{
		networkingPeer.TrafficStatsReset();
	}

	public static string NetworkStatisticsToString()
	{
		if (networkingPeer == null || offlineMode)
		{
			return "Offline or in OfflineMode. No VitalStats available.";
		}
		return networkingPeer.VitalStatsToString(all: false);
	}

	[Obsolete("Used for compatibility with Unity networking only. Encryption is automatically initialized while connecting.")]
	public static void InitializeSecurity()
	{
	}

	private static bool VerifyCanUseNetwork()
	{
		if (connected)
		{
			return true;
		}
		UnityEngine.Debug.LogError("Cannot send messages when not connected. Either connect to Photon OR use offline mode!");
		return false;
	}

	public static void Disconnect()
	{
		if (offlineMode)
		{
			offlineMode = false;
			offlineModeRoom = null;
			networkingPeer.State = ClientState.Disconnecting;
			networkingPeer.OnStatusChanged(StatusCode.Disconnect);
		}
		else if (networkingPeer != null)
		{
			networkingPeer.Disconnect();
		}
	}

	public static bool FindFriends(string[] friendsToFind)
	{
		if (networkingPeer == null || isOfflineMode)
		{
			return false;
		}
		return networkingPeer.OpFindFriends(friendsToFind);
	}

	public static bool CreateRoom(string roomName)
	{
		return CreateRoom(roomName, null, null, null);
	}

	public static bool CreateRoom(string roomName, RoomOptions roomOptions, TypedLobby typedLobby)
	{
		return CreateRoom(roomName, roomOptions, typedLobby, null);
	}

	public static bool CreateRoom(string roomName, RoomOptions roomOptions, TypedLobby typedLobby, string[] expectedUsers)
	{
		if (offlineMode)
		{
			if (offlineModeRoom != null)
			{
				UnityEngine.Debug.LogError("CreateRoom failed. In offline mode you still have to leave a room to enter another.");
				return false;
			}
			EnterOfflineRoom(roomName, roomOptions, createdRoom: true);
			return true;
		}
		if (networkingPeer.Server != 0 || !connectedAndReady)
		{
			UnityEngine.Debug.LogError("CreateRoom failed. Client is not on Master Server or not yet ready to call operations. Wait for callback: OnJoinedLobby or OnConnectedToMaster.");
			return false;
		}
		typedLobby = typedLobby ?? ((!networkingPeer.insideLobby) ? null : networkingPeer.lobby);
		EnterRoomParams enterRoomParams = new EnterRoomParams();
		enterRoomParams.RoomName = roomName;
		enterRoomParams.RoomOptions = roomOptions;
		enterRoomParams.Lobby = typedLobby;
		enterRoomParams.ExpectedUsers = expectedUsers;
		return networkingPeer.OpCreateGame(enterRoomParams);
	}

	public static bool JoinRoom(string roomName)
	{
		return JoinRoom(roomName, null);
	}

	public static bool JoinRoom(string roomName, string[] expectedUsers)
	{
		if (offlineMode)
		{
			if (offlineModeRoom != null)
			{
				UnityEngine.Debug.LogError("JoinRoom failed. In offline mode you still have to leave a room to enter another.");
				return false;
			}
			EnterOfflineRoom(roomName, null, createdRoom: true);
			return true;
		}
		if (networkingPeer.Server != 0 || !connectedAndReady)
		{
			UnityEngine.Debug.LogError("JoinRoom failed. Client is not on Master Server or not yet ready to call operations. Wait for callback: OnJoinedLobby or OnConnectedToMaster.");
			return false;
		}
		if (string.IsNullOrEmpty(roomName))
		{
			UnityEngine.Debug.LogError("JoinRoom failed. A roomname is required. If you don't know one, how will you join?");
			return false;
		}
		EnterRoomParams enterRoomParams = new EnterRoomParams();
		enterRoomParams.RoomName = roomName;
		enterRoomParams.ExpectedUsers = expectedUsers;
		return networkingPeer.OpJoinRoom(enterRoomParams);
	}

	public static bool JoinOrCreateRoom(string roomName, RoomOptions roomOptions, TypedLobby typedLobby)
	{
		return JoinOrCreateRoom(roomName, roomOptions, typedLobby, null);
	}

	public static bool JoinOrCreateRoom(string roomName, RoomOptions roomOptions, TypedLobby typedLobby, string[] expectedUsers)
	{
		if (offlineMode)
		{
			if (offlineModeRoom != null)
			{
				UnityEngine.Debug.LogError("JoinOrCreateRoom failed. In offline mode you still have to leave a room to enter another.");
				return false;
			}
			EnterOfflineRoom(roomName, roomOptions, createdRoom: true);
			return true;
		}
		if (networkingPeer.Server != 0 || !connectedAndReady)
		{
			UnityEngine.Debug.LogError("JoinOrCreateRoom failed. Client is not on Master Server or not yet ready to call operations. Wait for callback: OnJoinedLobby or OnConnectedToMaster.");
			return false;
		}
		if (string.IsNullOrEmpty(roomName))
		{
			UnityEngine.Debug.LogError("JoinOrCreateRoom failed. A roomname is required. If you don't know one, how will you join?");
			return false;
		}
		typedLobby = typedLobby ?? ((!networkingPeer.insideLobby) ? null : networkingPeer.lobby);
		EnterRoomParams enterRoomParams = new EnterRoomParams();
		enterRoomParams.RoomName = roomName;
		enterRoomParams.RoomOptions = roomOptions;
		enterRoomParams.Lobby = typedLobby;
		enterRoomParams.CreateIfNotExists = true;
		enterRoomParams.PlayerProperties = player.CustomProperties;
		enterRoomParams.ExpectedUsers = expectedUsers;
		return networkingPeer.OpJoinRoom(enterRoomParams);
	}

	public static bool JoinRandomRoom()
	{
		return JoinRandomRoom(null, 0, MatchmakingMode.FillRoom, null, null);
	}

	public static bool JoinRandomRoom(ExitGames.Client.Photon.Hashtable expectedCustomRoomProperties, byte expectedMaxPlayers)
	{
		return JoinRandomRoom(expectedCustomRoomProperties, expectedMaxPlayers, MatchmakingMode.FillRoom, null, null);
	}

	public static bool JoinRandomRoom(ExitGames.Client.Photon.Hashtable expectedCustomRoomProperties, byte expectedMaxPlayers, MatchmakingMode matchingType, TypedLobby typedLobby, string sqlLobbyFilter, string[] expectedUsers = null)
	{
		if (offlineMode)
		{
			if (offlineModeRoom != null)
			{
				UnityEngine.Debug.LogError("JoinRandomRoom failed. In offline mode you still have to leave a room to enter another.");
				return false;
			}
			EnterOfflineRoom("offline room", null, createdRoom: true);
			return true;
		}
		if (networkingPeer.Server != 0 || !connectedAndReady)
		{
			UnityEngine.Debug.LogError("JoinRandomRoom failed. Client is not on Master Server or not yet ready to call operations. Wait for callback: OnJoinedLobby or OnConnectedToMaster.");
			return false;
		}
		typedLobby = typedLobby ?? ((!networkingPeer.insideLobby) ? null : networkingPeer.lobby);
		OpJoinRandomRoomParams opJoinRandomRoomParams = new OpJoinRandomRoomParams();
		opJoinRandomRoomParams.ExpectedCustomRoomProperties = expectedCustomRoomProperties;
		opJoinRandomRoomParams.ExpectedMaxPlayers = expectedMaxPlayers;
		opJoinRandomRoomParams.MatchingType = matchingType;
		opJoinRandomRoomParams.TypedLobby = typedLobby;
		opJoinRandomRoomParams.SqlLobbyFilter = sqlLobbyFilter;
		opJoinRandomRoomParams.ExpectedUsers = expectedUsers;
		return networkingPeer.OpJoinRandomRoom(opJoinRandomRoomParams);
	}

	public static bool ReJoinRoom(string roomName)
	{
		if (offlineMode)
		{
			UnityEngine.Debug.LogError("ReJoinRoom failed due to offline mode.");
			return false;
		}
		if (networkingPeer.Server != 0 || !connectedAndReady)
		{
			UnityEngine.Debug.LogError("ReJoinRoom failed. Client is not on Master Server or not yet ready to call operations. Wait for callback: OnJoinedLobby or OnConnectedToMaster.");
			return false;
		}
		if (string.IsNullOrEmpty(roomName))
		{
			UnityEngine.Debug.LogError("ReJoinRoom failed. A roomname is required. If you don't know one, how will you join?");
			return false;
		}
		EnterRoomParams enterRoomParams = new EnterRoomParams();
		enterRoomParams.RoomName = roomName;
		enterRoomParams.RejoinOnly = true;
		enterRoomParams.PlayerProperties = player.CustomProperties;
		return networkingPeer.OpJoinRoom(enterRoomParams);
	}

	private static void EnterOfflineRoom(string roomName, RoomOptions roomOptions, bool createdRoom)
	{
		offlineModeRoom = new Room(roomName, roomOptions);
		networkingPeer.ChangeLocalID(1);
		networkingPeer.State = ClientState.ConnectingToGameserver;
		networkingPeer.OnStatusChanged(StatusCode.Connect);
		offlineModeRoom.MasterClientId = 1;
		if (createdRoom)
		{
			NetworkingPeer.SendMonoMessage(PhotonNetworkingMessage.OnCreatedRoom);
		}
		NetworkingPeer.SendMonoMessage(PhotonNetworkingMessage.OnJoinedRoom);
	}

	public static bool JoinLobby()
	{
		return JoinLobby(null);
	}

	public static bool JoinLobby(TypedLobby typedLobby)
	{
		if (connected && Server == ServerConnection.MasterServer)
		{
			if (typedLobby == null)
			{
				typedLobby = TypedLobby.Default;
			}
			bool flag = networkingPeer.OpJoinLobby(typedLobby);
			if (flag)
			{
				networkingPeer.lobby = typedLobby;
			}
			return flag;
		}
		return false;
	}

	public static bool LeaveLobby()
	{
		if (connected && Server == ServerConnection.MasterServer)
		{
			return networkingPeer.OpLeaveLobby();
		}
		return false;
	}

	public static bool LeaveRoom(bool becomeInactive = true)
	{
		if (offlineMode)
		{
			offlineModeRoom = null;
			NetworkingPeer.SendMonoMessage(PhotonNetworkingMessage.OnLeftRoom);
			return true;
		}
		if (room == null)
		{
			UnityEngine.Debug.LogWarning("PhotonNetwork.room is null. You don't have to call LeaveRoom() when you're not in one. State: " + connectionStateDetailed);
		}
		else
		{
			becomeInactive = becomeInactive && room.PlayerTtl != 0;
		}
		return networkingPeer.OpLeaveRoom(becomeInactive);
	}

	public static bool GetCustomRoomList(TypedLobby typedLobby, string sqlLobbyFilter)
	{
		return networkingPeer.OpGetGameList(typedLobby, sqlLobbyFilter);
	}

	public static RoomInfo[] GetRoomList()
	{
		if (offlineMode || networkingPeer == null)
		{
			return new RoomInfo[0];
		}
		return networkingPeer.mGameListCopy;
	}

	public static void SetPlayerCustomProperties(ExitGames.Client.Photon.Hashtable customProperties)
	{
		if (customProperties == null)
		{
			customProperties = new ExitGames.Client.Photon.Hashtable();
			foreach (object key in player.CustomProperties.Keys)
			{
				customProperties[(string)key] = null;
			}
		}
		if (room != null && room.IsLocalClientInside)
		{
			player.SetCustomProperties(customProperties);
		}
		else
		{
			player.InternalCacheProperties(customProperties);
		}
	}

	public static void RemovePlayerCustomProperties(string[] customPropertiesToDelete)
	{
		if (customPropertiesToDelete == null || customPropertiesToDelete.Length == 0 || player.CustomProperties == null)
		{
			player.CustomProperties = new ExitGames.Client.Photon.Hashtable();
			return;
		}
		foreach (string key in customPropertiesToDelete)
		{
			if (player.CustomProperties.ContainsKey(key))
			{
				player.CustomProperties.Remove(key);
			}
		}
	}

	public static bool RaiseEvent(byte eventCode, object eventContent, bool sendReliable, RaiseEventOptions options)
	{
		if (!inRoom || eventCode >= 200)
		{
			UnityEngine.Debug.LogWarning("RaiseEvent() failed. Your event is not being sent! Check if your are in a Room and the eventCode must be less than 200 (0..199).");
			return false;
		}
		return networkingPeer.OpRaiseEvent(eventCode, eventContent, sendReliable, options);
	}

	public static int AllocateViewID()
	{
		int num = AllocateViewID(player.ID);
		manuallyAllocatedViewIds.Add(num);
		return num;
	}

	public static int AllocateSceneViewID()
	{
		if (!isMasterClient)
		{
			UnityEngine.Debug.LogError("Only the Master Client can AllocateSceneViewID(). Check PhotonNetwork.isMasterClient!");
			return -1;
		}
		int num = AllocateViewID(0);
		manuallyAllocatedViewIds.Add(num);
		return num;
	}

	private static int AllocateViewID(int ownerId)
	{
		if (ownerId == 0)
		{
			int num = lastUsedViewSubIdStatic;
			int num2 = ownerId * MAX_VIEW_IDS;
			for (int i = 1; i < MAX_VIEW_IDS; i++)
			{
				num = (num + 1) % MAX_VIEW_IDS;
				if (num != 0)
				{
					int num3 = num + num2;
					if (!networkingPeer.photonViewList.ContainsKey(num3))
					{
						lastUsedViewSubIdStatic = num;
						return num3;
					}
				}
			}
			throw new Exception($"AllocateViewID() failed. Room (user {ownerId}) is out of 'scene' viewIDs. It seems all available are in use.");
		}
		int num4 = lastUsedViewSubId;
		int num5 = ownerId * MAX_VIEW_IDS;
		for (int j = 1; j < MAX_VIEW_IDS; j++)
		{
			num4 = (num4 + 1) % MAX_VIEW_IDS;
			if (num4 != 0)
			{
				int num6 = num4 + num5;
				if (!networkingPeer.photonViewList.ContainsKey(num6) && !manuallyAllocatedViewIds.Contains(num6))
				{
					lastUsedViewSubId = num4;
					return num6;
				}
			}
		}
		throw new Exception($"AllocateViewID() failed. User {ownerId} is out of subIds, as all viewIDs are used.");
	}

	private static int[] AllocateSceneViewIDs(int countOfNewViews)
	{
		int[] array = new int[countOfNewViews];
		for (int i = 0; i < countOfNewViews; i++)
		{
			array[i] = AllocateViewID(0);
		}
		return array;
	}

	public static void UnAllocateViewID(int viewID)
	{
		manuallyAllocatedViewIds.Remove(viewID);
		if (networkingPeer.photonViewList.ContainsKey(viewID))
		{
			UnityEngine.Debug.LogWarning($"UnAllocateViewID() should be called after the PhotonView was destroyed (GameObject.Destroy()). ViewID: {viewID} still found in: {networkingPeer.photonViewList[viewID]}");
		}
	}

	public static GameObject Instantiate(string prefabName, Vector3 position, Quaternion rotation, byte group)
	{
		return Instantiate(prefabName, position, rotation, group, null);
	}

	public static GameObject Instantiate(string prefabName, Vector3 position, Quaternion rotation, byte group, object[] data)
	{
		if (!connected || (InstantiateInRoomOnly && !inRoom))
		{
			UnityEngine.Debug.LogError("Failed to Instantiate prefab: " + prefabName + ". Client should be in a room. Current connectionStateDetailed: " + connectionStateDetailed);
			return null;
		}
		if (!UsePrefabCache || !PrefabCache.TryGetValue(prefabName, out var value))
		{
			value = (GameObject)Resources.Load(prefabName, typeof(GameObject));
			if (UsePrefabCache)
			{
				PrefabCache.Add(prefabName, value);
			}
		}
		if (value == null)
		{
			UnityEngine.Debug.LogError("Failed to Instantiate prefab: " + prefabName + ". Verify the Prefab is in a Resources folder (and not in a subfolder)");
			return null;
		}
		if (value.GetComponent<PhotonView>() == null)
		{
			UnityEngine.Debug.LogError("Failed to Instantiate prefab:" + prefabName + ". Prefab must have a PhotonView component.");
			return null;
		}
		UnityEngine.Component[] photonViewsInChildren = value.GetPhotonViewsInChildren();
		int[] array = new int[photonViewsInChildren.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = AllocateViewID(player.ID);
		}
		ExitGames.Client.Photon.Hashtable evData = networkingPeer.SendInstantiate(prefabName, position, rotation, group, array, data, isGlobalObject: false);
		return networkingPeer.DoInstantiate(evData, networkingPeer.LocalPlayer, value);
	}

	public static GameObject InstantiateSceneObject(string prefabName, Vector3 position, Quaternion rotation, byte group, object[] data)
	{
		if (!connected || (InstantiateInRoomOnly && !inRoom))
		{
			UnityEngine.Debug.LogError("Failed to InstantiateSceneObject prefab: " + prefabName + ". Client should be in a room. Current connectionStateDetailed: " + connectionStateDetailed);
			return null;
		}
		if (!isMasterClient)
		{
			UnityEngine.Debug.LogError("Failed to InstantiateSceneObject prefab: " + prefabName + ". Client is not the MasterClient in this room.");
			return null;
		}
		if (!UsePrefabCache || !PrefabCache.TryGetValue(prefabName, out var value))
		{
			value = (GameObject)Resources.Load(prefabName, typeof(GameObject));
			if (UsePrefabCache)
			{
				PrefabCache.Add(prefabName, value);
			}
		}
		if (value == null)
		{
			UnityEngine.Debug.LogError("Failed to InstantiateSceneObject prefab: " + prefabName + ". Verify the Prefab is in a Resources folder (and not in a subfolder)");
			return null;
		}
		if (value.GetComponent<PhotonView>() == null)
		{
			UnityEngine.Debug.LogError("Failed to InstantiateSceneObject prefab:" + prefabName + ". Prefab must have a PhotonView component.");
			return null;
		}
		UnityEngine.Component[] photonViewsInChildren = value.GetPhotonViewsInChildren();
		int[] array = AllocateSceneViewIDs(photonViewsInChildren.Length);
		if (array == null)
		{
			UnityEngine.Debug.LogError("Failed to InstantiateSceneObject prefab: " + prefabName + ". No ViewIDs are free to use. Max is: " + MAX_VIEW_IDS);
			return null;
		}
		ExitGames.Client.Photon.Hashtable evData = networkingPeer.SendInstantiate(prefabName, position, rotation, group, array, data, isGlobalObject: true);
		return networkingPeer.DoInstantiate(evData, networkingPeer.LocalPlayer, value);
	}

	public static int GetPing()
	{
		return networkingPeer.RoundTripTime;
	}

	public static void FetchServerTimestamp()
	{
		if (networkingPeer != null)
		{
			networkingPeer.FetchServerTimestamp();
		}
	}

	public static void SendOutgoingCommands()
	{
		if (VerifyCanUseNetwork())
		{
			while (networkingPeer.SendOutgoingCommands())
			{
			}
		}
	}

	public static bool CloseConnection(PhotonPlayer kickPlayer)
	{
		if (!VerifyCanUseNetwork())
		{
			return false;
		}
		if (!player.IsMasterClient)
		{
			UnityEngine.Debug.LogError("CloseConnection: Only the masterclient can kick another player.");
			return false;
		}
		if (kickPlayer == null)
		{
			UnityEngine.Debug.LogError("CloseConnection: No such player connected!");
			return false;
		}
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.TargetActors = new int[1] { kickPlayer.ID };
		RaiseEventOptions raiseEventOptions2 = raiseEventOptions;
		return networkingPeer.OpRaiseEvent(203, null, sendReliable: true, raiseEventOptions2);
	}

	public static bool SetMasterClient(PhotonPlayer masterClientPlayer)
	{
		if (!inRoom || !VerifyCanUseNetwork() || offlineMode)
		{
			if (logLevel == PhotonLogLevel.Informational)
			{
				UnityEngine.Debug.Log("Can not SetMasterClient(). Not in room or in offlineMode.");
			}
			return false;
		}
		if (room.serverSideMasterClient)
		{
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Add((byte)248, masterClientPlayer.ID);
			ExitGames.Client.Photon.Hashtable gameProperties = hashtable;
			hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Add((byte)248, networkingPeer.mMasterClientId);
			ExitGames.Client.Photon.Hashtable expectedProperties = hashtable;
			return networkingPeer.OpSetPropertiesOfRoom(gameProperties, expectedProperties);
		}
		if (!isMasterClient)
		{
			return false;
		}
		return networkingPeer.SetMasterClient(masterClientPlayer.ID, sync: true);
	}

	public static void Destroy(PhotonView targetView)
	{
		if (targetView != null)
		{
			networkingPeer.RemoveInstantiatedGO(targetView.gameObject, !inRoom);
		}
		else
		{
			UnityEngine.Debug.LogError("Destroy(targetPhotonView) failed, cause targetPhotonView is null.");
		}
	}

	public static void Destroy(GameObject targetGo)
	{
		networkingPeer.RemoveInstantiatedGO(targetGo, !inRoom);
	}

	public static void DestroyPlayerObjects(PhotonPlayer targetPlayer)
	{
		if (player == null)
		{
			UnityEngine.Debug.LogError("DestroyPlayerObjects() failed, cause parameter 'targetPlayer' was null.");
		}
		DestroyPlayerObjects(targetPlayer.ID);
	}

	public static void DestroyPlayerObjects(int targetPlayerId)
	{
		if (VerifyCanUseNetwork())
		{
			if (player.IsMasterClient || targetPlayerId == player.ID)
			{
				networkingPeer.DestroyPlayerObjects(targetPlayerId, localOnly: false);
			}
			else
			{
				UnityEngine.Debug.LogError("DestroyPlayerObjects() failed, cause players can only destroy their own GameObjects. A Master Client can destroy anyone's. This is master: " + isMasterClient);
			}
		}
	}

	public static void DestroyAll()
	{
		if (isMasterClient)
		{
			networkingPeer.DestroyAll(localOnly: false);
		}
		else
		{
			UnityEngine.Debug.LogError("Couldn't call DestroyAll() as only the master client is allowed to call this.");
		}
	}

	public static void RemoveRPCs(PhotonPlayer targetPlayer)
	{
		if (VerifyCanUseNetwork())
		{
			if (!targetPlayer.IsLocal && !isMasterClient)
			{
				UnityEngine.Debug.LogError("Error; Only the MasterClient can call RemoveRPCs for other players.");
			}
			else
			{
				networkingPeer.OpCleanRpcBuffer(targetPlayer.ID);
			}
		}
	}

	public static void RemoveRPCs(PhotonView targetPhotonView)
	{
		if (VerifyCanUseNetwork())
		{
			networkingPeer.CleanRpcBufferIfMine(targetPhotonView);
		}
	}

	public static void RemoveRPCsInGroup(int targetGroup)
	{
		if (VerifyCanUseNetwork())
		{
			networkingPeer.RemoveRPCsInGroup(targetGroup);
		}
	}

	internal static void RPC(PhotonView view, string methodName, PhotonTargets target, bool encrypt, params object[] parameters)
	{
		if (!VerifyCanUseNetwork())
		{
			return;
		}
		if (room == null)
		{
			UnityEngine.Debug.LogWarning("RPCs can only be sent in rooms. Call of \"" + methodName + "\" gets executed locally only, if at all.");
		}
		else if (networkingPeer != null)
		{
			if (room.serverSideMasterClient)
			{
				networkingPeer.RPC(view, methodName, target, null, encrypt, parameters);
			}
			else if (networkingPeer.hasSwitchedMC && target == PhotonTargets.MasterClient)
			{
				networkingPeer.RPC(view, methodName, PhotonTargets.Others, masterClient, encrypt, parameters);
			}
			else
			{
				networkingPeer.RPC(view, methodName, target, null, encrypt, parameters);
			}
		}
		else
		{
			UnityEngine.Debug.LogWarning("Could not execute RPC " + methodName + ". Possible scene loading in progress?");
		}
	}

	internal static void RPC(PhotonView view, string methodName, PhotonPlayer targetPlayer, bool encrpyt, params object[] parameters)
	{
		if (!VerifyCanUseNetwork())
		{
			return;
		}
		if (room == null)
		{
			UnityEngine.Debug.LogWarning("RPCs can only be sent in rooms. Call of \"" + methodName + "\" gets executed locally only, if at all.");
			return;
		}
		if (player == null)
		{
			UnityEngine.Debug.LogError("RPC can't be sent to target PhotonPlayer being null! Did not send \"" + methodName + "\" call.");
		}
		if (networkingPeer != null)
		{
			networkingPeer.RPC(view, methodName, PhotonTargets.Others, targetPlayer, encrpyt, parameters);
		}
		else
		{
			UnityEngine.Debug.LogWarning("Could not execute RPC " + methodName + ". Possible scene loading in progress?");
		}
	}

	public static void CacheSendMonoMessageTargets(Type type)
	{
		if (type == null)
		{
			type = SendMonoMessageTargetType;
		}
		SendMonoMessageTargets = FindGameObjectsWithComponent(type);
	}

	public static HashSet<GameObject> FindGameObjectsWithComponent(Type type)
	{
		HashSet<GameObject> hashSet = new HashSet<GameObject>();
		UnityEngine.Component[] array = (UnityEngine.Component[])UnityEngine.Object.FindObjectsOfType(type);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != null)
			{
				hashSet.Add(array[i].gameObject);
			}
		}
		return hashSet;
	}

	[Obsolete("Use SetInterestGroups(byte group, bool enabled) instead.")]
	public static void SetReceivingEnabled(int group, bool enabled)
	{
		if (VerifyCanUseNetwork())
		{
			SetInterestGroups((byte)group, enabled);
		}
	}

	public static void SetInterestGroups(byte group, bool enabled)
	{
		if (VerifyCanUseNetwork())
		{
			if (enabled)
			{
				byte[] enableGroups = new byte[1] { group };
				networkingPeer.SetInterestGroups(null, enableGroups);
			}
			else
			{
				byte[] disableGroups = new byte[1] { group };
				networkingPeer.SetInterestGroups(disableGroups, null);
			}
		}
	}

	[Obsolete("Use SetInterestGroups(byte[] disableGroups, byte[] enableGroups) instead. Mind the parameter order!")]
	public static void SetReceivingEnabled(int[] enableGroups, int[] disableGroups)
	{
		if (VerifyCanUseNetwork())
		{
			byte[] array = null;
			byte[] array2 = null;
			if (enableGroups != null)
			{
				array2 = new byte[enableGroups.Length];
				Array.Copy(enableGroups, array2, enableGroups.Length);
			}
			if (disableGroups != null)
			{
				array = new byte[disableGroups.Length];
				Array.Copy(disableGroups, array, disableGroups.Length);
			}
			networkingPeer.SetInterestGroups(array, array2);
		}
	}

	public static void SetInterestGroups(byte[] disableGroups, byte[] enableGroups)
	{
		if (VerifyCanUseNetwork())
		{
			networkingPeer.SetInterestGroups(disableGroups, enableGroups);
		}
	}

	[Obsolete("Use SetSendingEnabled(byte group, bool enabled). Interest Groups have a byte-typed ID. Mind the parameter order.")]
	public static void SetSendingEnabled(int group, bool enabled)
	{
		SetSendingEnabled((byte)group, enabled);
	}

	public static void SetSendingEnabled(byte group, bool enabled)
	{
		if (VerifyCanUseNetwork())
		{
			networkingPeer.SetSendingEnabled(group, enabled);
		}
	}

	[Obsolete("Use SetSendingEnabled(byte group, bool enabled). Interest Groups have a byte-typed ID. Mind the parameter order.")]
	public static void SetSendingEnabled(int[] enableGroups, int[] disableGroups)
	{
		byte[] array = null;
		byte[] array2 = null;
		if (enableGroups != null)
		{
			array2 = new byte[enableGroups.Length];
			Array.Copy(enableGroups, array2, enableGroups.Length);
		}
		if (disableGroups != null)
		{
			array = new byte[disableGroups.Length];
			Array.Copy(disableGroups, array, disableGroups.Length);
		}
		SetSendingEnabled(array, array2);
	}

	public static void SetSendingEnabled(byte[] disableGroups, byte[] enableGroups)
	{
		if (VerifyCanUseNetwork())
		{
			networkingPeer.SetSendingEnabled(disableGroups, enableGroups);
		}
	}

	public static void SetLevelPrefix(short prefix)
	{
		if (VerifyCanUseNetwork())
		{
			networkingPeer.SetLevelPrefix(prefix);
		}
	}

	public static void LoadLevel(int levelNumber)
	{
		networkingPeer.SetLevelInPropsIfSynced(levelNumber);
		isMessageQueueRunning = false;
		networkingPeer.loadingLevelAndPausedNetwork = true;
		SceneManager.LoadScene(levelNumber);
	}

	public static void LoadLevel(string levelName)
	{
		networkingPeer.SetLevelInPropsIfSynced(levelName);
		isMessageQueueRunning = false;
		networkingPeer.loadingLevelAndPausedNetwork = true;
		SceneManager.LoadScene(levelName);
	}

	public static bool WebRpc(string name, object parameters)
	{
		return networkingPeer.WebRpc(name, parameters);
	}
}
public class PhotonPlayer : IComparable<PhotonPlayer>, IComparable<int>, IEquatable<PhotonPlayer>, IEquatable<int>
{
	private int actorID = -1;

	private string nameField = string.Empty;

	public readonly bool IsLocal;

	public object TagObject;

	public int ID => actorID;

	public string NickName
	{
		get
		{
			return nameField;
		}
		set
		{
			if (!IsLocal)
			{
				UnityEngine.Debug.LogError("Error: Cannot change the name of a remote player!");
			}
			else if (!string.IsNullOrEmpty(value) && !value.Equals(nameField))
			{
				nameField = value;
				PhotonNetwork.playerName = value;
			}
		}
	}

	public string UserId { get; internal set; }

	public bool IsMasterClient => PhotonNetwork.networkingPeer.mMasterClientId == ID;

	public bool IsInactive { get; set; }

	public ExitGames.Client.Photon.Hashtable CustomProperties { get; internal set; }

	public ExitGames.Client.Photon.Hashtable AllProperties
	{
		get
		{
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable.Merge(CustomProperties);
			hashtable[byte.MaxValue] = NickName;
			return hashtable;
		}
	}

	[Obsolete("Please use NickName (updated case for naming).")]
	public string name
	{
		get
		{
			return NickName;
		}
		set
		{
			NickName = value;
		}
	}

	[Obsolete("Please use UserId (updated case for naming).")]
	public string userId
	{
		get
		{
			return UserId;
		}
		internal set
		{
			UserId = value;
		}
	}

	[Obsolete("Please use IsLocal (updated case for naming).")]
	public bool isLocal => IsLocal;

	[Obsolete("Please use IsMasterClient (updated case for naming).")]
	public bool isMasterClient => IsMasterClient;

	[Obsolete("Please use IsInactive (updated case for naming).")]
	public bool isInactive
	{
		get
		{
			return IsInactive;
		}
		set
		{
			IsInactive = value;
		}
	}

	[Obsolete("Please use CustomProperties (updated case for naming).")]
	public ExitGames.Client.Photon.Hashtable customProperties
	{
		get
		{
			return CustomProperties;
		}
		internal set
		{
			CustomProperties = value;
		}
	}

	[Obsolete("Please use AllProperties (updated case for naming).")]
	public ExitGames.Client.Photon.Hashtable allProperties => AllProperties;

	public PhotonPlayer(bool isLocal, int actorID, string name)
	{
		CustomProperties = new ExitGames.Client.Photon.Hashtable();
		IsLocal = isLocal;
		this.actorID = actorID;
		nameField = name;
	}

	protected internal PhotonPlayer(bool isLocal, int actorID, ExitGames.Client.Photon.Hashtable properties)
	{
		CustomProperties = new ExitGames.Client.Photon.Hashtable();
		IsLocal = isLocal;
		this.actorID = actorID;
		InternalCacheProperties(properties);
	}

	public override bool Equals(object p)
	{
		return p is PhotonPlayer photonPlayer && GetHashCode() == photonPlayer.GetHashCode();
	}

	public override int GetHashCode()
	{
		return ID;
	}

	internal void InternalChangeLocalID(int newID)
	{
		if (!IsLocal)
		{
			UnityEngine.Debug.LogError("ERROR You should never change PhotonPlayer IDs!");
		}
		else
		{
			actorID = newID;
		}
	}

	internal void InternalCacheProperties(ExitGames.Client.Photon.Hashtable properties)
	{
		if (properties != null && properties.Count != 0 && !CustomProperties.Equals(properties))
		{
			if (properties.ContainsKey(byte.MaxValue))
			{
				nameField = (string)properties[byte.MaxValue];
			}
			if (properties.ContainsKey((byte)253))
			{
				UserId = (string)properties[(byte)253];
			}
			if (properties.ContainsKey((byte)254))
			{
				IsInactive = (bool)properties[(byte)254];
			}
			CustomProperties.MergeStringKeys(properties);
			CustomProperties.StripKeysWithNullValues();
		}
	}

	public void SetCustomProperties(ExitGames.Client.Photon.Hashtable propertiesToSet, ExitGames.Client.Photon.Hashtable expectedValues = null, bool webForward = false)
	{
		if (propertiesToSet != null)
		{
			ExitGames.Client.Photon.Hashtable hashtable = propertiesToSet.StripToStringKeys();
			ExitGames.Client.Photon.Hashtable hashtable2 = expectedValues.StripToStringKeys();
			bool flag = hashtable2 == null || hashtable2.Count == 0;
			bool flag2 = actorID > 0 && !PhotonNetwork.offlineMode;
			if (flag)
			{
				CustomProperties.Merge(hashtable);
				CustomProperties.StripKeysWithNullValues();
			}
			if (flag2)
			{
				PhotonNetwork.networkingPeer.OpSetPropertiesOfActor(actorID, hashtable, hashtable2, webForward);
			}
			if (!flag2 || flag)
			{
				InternalCacheProperties(hashtable);
				NetworkingPeer.SendMonoMessage(PhotonNetworkingMessage.OnPhotonPlayerPropertiesChanged, this, hashtable);
			}
		}
	}

	public static PhotonPlayer Find(int ID)
	{
		if (PhotonNetwork.networkingPeer != null)
		{
			return PhotonNetwork.networkingPeer.GetPlayerWithId(ID);
		}
		return null;
	}

	public PhotonPlayer Get(int id)
	{
		return Find(id);
	}

	public PhotonPlayer GetNext()
	{
		return GetNextFor(ID);
	}

	public PhotonPlayer GetNextFor(PhotonPlayer currentPlayer)
	{
		if (currentPlayer == null)
		{
			return null;
		}
		return GetNextFor(currentPlayer.ID);
	}

	public PhotonPlayer GetNextFor(int currentPlayerId)
	{
		if (PhotonNetwork.networkingPeer == null || PhotonNetwork.networkingPeer.mActors == null || PhotonNetwork.networkingPeer.mActors.Count < 2)
		{
			return null;
		}
		Dictionary<int, PhotonPlayer> mActors = PhotonNetwork.networkingPeer.mActors;
		int num = int.MaxValue;
		int num2 = currentPlayerId;
		foreach (int key in mActors.Keys)
		{
			if (key < num2)
			{
				num2 = key;
			}
			else if (key > currentPlayerId && key < num)
			{
				num = key;
			}
		}
		return (num == int.MaxValue) ? mActors[num2] : mActors[num];
	}

	public int CompareTo(PhotonPlayer other)
	{
		if (other == null)
		{
			return 0;
		}
		return GetHashCode().CompareTo(other.GetHashCode());
	}

	public int CompareTo(int other)
	{
		return GetHashCode().CompareTo(other);
	}

	public bool Equals(PhotonPlayer other)
	{
		if (other == null)
		{
			return false;
		}
		return GetHashCode().Equals(other.GetHashCode());
	}

	public bool Equals(int other)
	{
		return GetHashCode().Equals(other);
	}

	public override string ToString()
	{
		if (string.IsNullOrEmpty(NickName))
		{
			return string.Format("#{0:00}{1}{2}", ID, (!IsInactive) ? " " : " (inactive)", (!IsMasterClient) ? string.Empty : "(master)");
		}
		return string.Format("'{0}'{1}{2}", NickName, (!IsInactive) ? " " : " (inactive)", (!IsMasterClient) ? string.Empty : "(master)");
	}

	public string ToStringFull()
	{
		return string.Format("#{0:00} '{1}'{2} {3}", ID, NickName, (!IsInactive) ? string.Empty : " (inactive)", CustomProperties.ToStringFull());
	}
}
public class PhotonStatsGui : UnityEngine.MonoBehaviour
{
	public bool statsWindowOn = true;

	public bool statsOn = true;

	public bool healthStatsVisible;

	public bool trafficStatsOn;

	public bool buttonsOn;

	public Rect statsRect = new Rect(0f, 100f, 200f, 50f);

	public int WindowId = 100;

	public void Start()
	{
		if (statsRect.x <= 0f)
		{
			statsRect.x = (float)Screen.width - statsRect.width;
		}
	}

	public void Update()
	{
		if (Input.GetKeyDown(KeyCode.Tab) && Input.GetKey(KeyCode.LeftShift))
		{
			statsWindowOn = !statsWindowOn;
			statsOn = true;
		}
	}

	public void OnGUI()
	{
		if (PhotonNetwork.networkingPeer.TrafficStatsEnabled != statsOn)
		{
			PhotonNetwork.networkingPeer.TrafficStatsEnabled = statsOn;
		}
		if (statsWindowOn)
		{
			statsRect = GUILayout.Window(WindowId, statsRect, TrafficStatsWindow, "Messages (shift+tab)");
		}
	}

	public void TrafficStatsWindow(int windowID)
	{
		bool flag = false;
		TrafficStatsGameLevel trafficStatsGameLevel = PhotonNetwork.networkingPeer.TrafficStatsGameLevel;
		long num = PhotonNetwork.networkingPeer.TrafficStatsElapsedMs / 1000;
		if (num == 0)
		{
			num = 1L;
		}
		GUILayout.BeginHorizontal();
		buttonsOn = GUILayout.Toggle(buttonsOn, "buttons");
		healthStatsVisible = GUILayout.Toggle(healthStatsVisible, "health");
		trafficStatsOn = GUILayout.Toggle(trafficStatsOn, "traffic");
		GUILayout.EndHorizontal();
		string text = $"Out {trafficStatsGameLevel.TotalOutgoingMessageCount,4} | In {trafficStatsGameLevel.TotalIncomingMessageCount,4} | Sum {trafficStatsGameLevel.TotalMessageCount,4}";
		string text2 = $"{num}sec average:";
		string text3 = $"Out {trafficStatsGameLevel.TotalOutgoingMessageCount / num,4} | In {trafficStatsGameLevel.TotalIncomingMessageCount / num,4} | Sum {trafficStatsGameLevel.TotalMessageCount / num,4}";
		GUILayout.Label(text);
		GUILayout.Label(text2);
		GUILayout.Label(text3);
		if (buttonsOn)
		{
			GUILayout.BeginHorizontal();
			statsOn = GUILayout.Toggle(statsOn, "stats on");
			if (GUILayout.Button("Reset"))
			{
				PhotonNetwork.networkingPeer.TrafficStatsReset();
				PhotonNetwork.networkingPeer.TrafficStatsEnabled = true;
			}
			flag = GUILayout.Button("To Log");
			GUILayout.EndHorizontal();
		}
		string text4 = string.Empty;
		string text5 = string.Empty;
		if (trafficStatsOn)
		{
			GUILayout.Box("Traffic Stats");
			text4 = "Incoming: \n" + PhotonNetwork.networkingPeer.TrafficStatsIncoming.ToString();
			text5 = "Outgoing: \n" + PhotonNetwork.networkingPeer.TrafficStatsOutgoing.ToString();
			GUILayout.Label(text4);
			GUILayout.Label(text5);
		}
		string text6 = string.Empty;
		if (healthStatsVisible)
		{
			GUILayout.Box("Health Stats");
			text6 = string.Format("ping: {6}[+/-{7}]ms resent:{8} \n\nmax ms between\nsend: {0,4} \ndispatch: {1,4} \n\nlongest dispatch for: \nev({3}):{2,3}ms \nop({5}):{4,3}ms", trafficStatsGameLevel.LongestDeltaBetweenSending, trafficStatsGameLevel.LongestDeltaBetweenDispatching, trafficStatsGameLevel.LongestEventCallback, trafficStatsGameLevel.LongestEventCallbackCode, trafficStatsGameLevel.LongestOpResponseCallback, trafficStatsGameLevel.LongestOpResponseCallbackOpCode, PhotonNetwork.networkingPeer.RoundTripTime, PhotonNetwork.networkingPeer.RoundTripTimeVariance, PhotonNetwork.networkingPeer.ResentReliableCommands);
			GUILayout.Label(text6);
		}
		if (flag)
		{
			string message = $"{text}\n{text2}\n{text3}\n{text4}\n{text5}\n{text6}";
			UnityEngine.Debug.Log(message);
		}
		if (GUI.changed)
		{
			statsRect.height = 100f;
		}
		GUI.DragWindow();
	}
}
public class PhotonStreamQueue
{
	private int m_SampleRate;

	private int m_SampleCount;

	private int m_ObjectsPerSample = -1;

	private float m_LastSampleTime = float.NegativeInfinity;

	private int m_LastFrameCount = -1;

	private int m_NextObjectIndex = -1;

	private List<object> m_Objects = new List<object>();

	private bool m_IsWriting;

	public PhotonStreamQueue(int sampleRate)
	{
		m_SampleRate = sampleRate;
	}

	private void BeginWritePackage()
	{
		if (Time.realtimeSinceStartup < m_LastSampleTime + 1f / (float)m_SampleRate)
		{
			m_IsWriting = false;
			return;
		}
		if (m_SampleCount == 1)
		{
			m_ObjectsPerSample = m_Objects.Count;
		}
		else if (m_SampleCount > 1 && m_Objects.Count / m_SampleCount != m_ObjectsPerSample)
		{
			UnityEngine.Debug.LogWarning("The number of objects sent via a PhotonStreamQueue has to be the same each frame");
			UnityEngine.Debug.LogWarning("Objects in List: " + m_Objects.Count + " / Sample Count: " + m_SampleCount + " = " + m_Objects.Count / m_SampleCount + " != " + m_ObjectsPerSample);
		}
		m_IsWriting = true;
		m_SampleCount++;
		m_LastSampleTime = Time.realtimeSinceStartup;
	}

	public void Reset()
	{
		m_SampleCount = 0;
		m_ObjectsPerSample = -1;
		m_LastSampleTime = float.NegativeInfinity;
		m_LastFrameCount = -1;
		m_Objects.Clear();
	}

	public void SendNext(object obj)
	{
		if (Time.frameCount != m_LastFrameCount)
		{
			BeginWritePackage();
		}
		m_LastFrameCount = Time.frameCount;
		if (m_IsWriting)
		{
			m_Objects.Add(obj);
		}
	}

	public bool HasQueuedObjects()
	{
		return m_NextObjectIndex != -1;
	}

	public object ReceiveNext()
	{
		if (m_NextObjectIndex == -1)
		{
			return null;
		}
		if (m_NextObjectIndex >= m_Objects.Count)
		{
			m_NextObjectIndex -= m_ObjectsPerSample;
		}
		return m_Objects[m_NextObjectIndex++];
	}

	public void Serialize(PhotonStream stream)
	{
		if (m_Objects.Count > 0 && m_ObjectsPerSample < 0)
		{
			m_ObjectsPerSample = m_Objects.Count;
		}
		stream.SendNext(m_SampleCount);
		stream.SendNext(m_ObjectsPerSample);
		for (int i = 0; i < m_Objects.Count; i++)
		{
			stream.SendNext(m_Objects[i]);
		}
		m_Objects.Clear();
		m_SampleCount = 0;
	}

	public void Deserialize(PhotonStream stream)
	{
		m_Objects.Clear();
		m_SampleCount = (int)stream.ReceiveNext();
		m_ObjectsPerSample = (int)stream.ReceiveNext();
		for (int i = 0; i < m_SampleCount * m_ObjectsPerSample; i++)
		{
			m_Objects.Add(stream.ReceiveNext());
		}
		if (m_Objects.Count > 0)
		{
			m_NextObjectIndex = 0;
		}
		else
		{
			m_NextObjectIndex = -1;
		}
	}
}
public enum ViewSynchronization
{
	Off,
	ReliableDeltaCompressed,
	Unreliable,
	UnreliableOnChange
}
public enum OnSerializeTransform
{
	OnlyPosition,
	OnlyRotation,
	OnlyScale,
	PositionAndRotation,
	All
}
public enum OnSerializeRigidBody
{
	OnlyVelocity,
	OnlyAngularVelocity,
	All
}
public enum OwnershipOption
{
	Fixed,
	Takeover,
	Request
}
[AddComponentMenu("Photon Networking/Photon View &v")]
public class PhotonView : Photon.MonoBehaviour
{
	public int ownerId;

	public byte group;

	protected internal bool mixedModeIsReliable;

	public bool OwnerShipWasTransfered;

	public int prefixBackup = -1;

	internal object[] instantiationDataField;

	protected internal object[] lastOnSerializeDataSent;

	protected internal object[] lastOnSerializeDataReceived;

	public ViewSynchronization synchronization;

	public OnSerializeTransform onSerializeTransformOption = OnSerializeTransform.PositionAndRotation;

	public OnSerializeRigidBody onSerializeRigidBodyOption = OnSerializeRigidBody.All;

	public OwnershipOption ownershipTransfer;

	public List<UnityEngine.Component> ObservedComponents;

	private Dictionary<UnityEngine.Component, MethodInfo> m_OnSerializeMethodInfos = new Dictionary<UnityEngine.Component, MethodInfo>(3);

	[SerializeField]
	private int viewIdField;

	public int instantiationId;

	public int currentMasterID = -1;

	protected internal bool didAwake;

	[SerializeField]
	protected internal bool isRuntimeInstantiated;

	protected internal bool removedFromLocalViewList;

	internal UnityEngine.MonoBehaviour[] RpcMonoBehaviours;

	private MethodInfo OnSerializeMethodInfo;

	private bool failedToFindOnSerialize;

	public int prefix
	{
		get
		{
			if (prefixBackup == -1 && PhotonNetwork.networkingPeer != null)
			{
				prefixBackup = PhotonNetwork.networkingPeer.currentLevelPrefix;
			}
			return prefixBackup;
		}
		set
		{
			prefixBackup = value;
		}
	}

	public object[] instantiationData
	{
		get
		{
			if (!didAwake)
			{
				instantiationDataField = PhotonNetwork.networkingPeer.FetchInstantiationData(instantiationId);
			}
			return instantiationDataField;
		}
		set
		{
			instantiationDataField = value;
		}
	}

	public int viewID
	{
		get
		{
			return viewIdField;
		}
		set
		{
			bool flag = didAwake && viewIdField == 0;
			ownerId = value / PhotonNetwork.MAX_VIEW_IDS;
			viewIdField = value;
			if (flag)
			{
				PhotonNetwork.networkingPeer.RegisterPhotonView(this);
			}
		}
	}

	public bool isSceneView => CreatorActorNr == 0;

	public PhotonPlayer owner => PhotonPlayer.Find(ownerId);

	public int OwnerActorNr => ownerId;

	public bool isOwnerActive => ownerId != 0 && PhotonNetwork.networkingPeer.mActors.ContainsKey(ownerId);

	public int CreatorActorNr => viewIdField / PhotonNetwork.MAX_VIEW_IDS;

	public bool isMine => ownerId == PhotonNetwork.player.ID || (!isOwnerActive && PhotonNetwork.isMasterClient);

	protected internal void Awake()
	{
		if (viewID != 0)
		{
			PhotonNetwork.networkingPeer.RegisterPhotonView(this);
			instantiationDataField = PhotonNetwork.networkingPeer.FetchInstantiationData(instantiationId);
		}
		didAwake = true;
	}

	public void RequestOwnership()
	{
		PhotonNetwork.networkingPeer.RequestOwnership(viewID, ownerId);
	}

	public void TransferOwnership(PhotonPlayer newOwner)
	{
		TransferOwnership(newOwner.ID);
	}

	public void TransferOwnership(int newOwnerId)
	{
		PhotonNetwork.networkingPeer.TransferOwnership(viewID, newOwnerId);
		ownerId = newOwnerId;
	}

	public void OnMasterClientSwitched(PhotonPlayer newMasterClient)
	{
		if (CreatorActorNr == 0 && !OwnerShipWasTransfered && (currentMasterID == -1 || ownerId == currentMasterID))
		{
			ownerId = newMasterClient.ID;
		}
		currentMasterID = newMasterClient.ID;
	}

	protected internal void OnDestroy()
	{
		if (!removedFromLocalViewList)
		{
			bool flag = PhotonNetwork.networkingPeer.LocalCleanPhotonView(this);
			bool flag2 = false;
			if (flag && !flag2 && instantiationId > 0 && !PhotonHandler.AppQuits && PhotonNetwork.logLevel >= PhotonLogLevel.Informational)
			{
				UnityEngine.Debug.Log("PUN-instantiated '" + base.gameObject.name + "' got destroyed by engine. This is OK when loading levels. Otherwise use: PhotonNetwork.Destroy().");
			}
		}
	}

	public void SerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (ObservedComponents != null && ObservedComponents.Count > 0)
		{
			for (int i = 0; i < ObservedComponents.Count; i++)
			{
				SerializeComponent(ObservedComponents[i], stream, info);
			}
		}
	}

	public void DeserializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (ObservedComponents != null && ObservedComponents.Count > 0)
		{
			for (int i = 0; i < ObservedComponents.Count; i++)
			{
				DeserializeComponent(ObservedComponents[i], stream, info);
			}
		}
	}

	protected internal void DeserializeComponent(UnityEngine.Component component, PhotonStream stream, PhotonMessageInfo info)
	{
		if (component == null)
		{
			return;
		}
		if (component is UnityEngine.MonoBehaviour)
		{
			ExecuteComponentOnSerialize(component, stream, info);
		}
		else if (component is Transform)
		{
			Transform transform = (Transform)component;
			switch (onSerializeTransformOption)
			{
			case OnSerializeTransform.All:
				transform.localPosition = (Vector3)stream.ReceiveNext();
				transform.localRotation = (Quaternion)stream.ReceiveNext();
				transform.localScale = (Vector3)stream.ReceiveNext();
				break;
			case OnSerializeTransform.OnlyPosition:
				transform.localPosition = (Vector3)stream.ReceiveNext();
				break;
			case OnSerializeTransform.OnlyRotation:
				transform.localRotation = (Quaternion)stream.ReceiveNext();
				break;
			case OnSerializeTransform.OnlyScale:
				transform.localScale = (Vector3)stream.ReceiveNext();
				break;
			case OnSerializeTransform.PositionAndRotation:
				transform.localPosition = (Vector3)stream.ReceiveNext();
				transform.localRotation = (Quaternion)stream.ReceiveNext();
				break;
			}
		}
		else if (component is Rigidbody)
		{
			Rigidbody rigidbody = (Rigidbody)component;
			switch (onSerializeRigidBodyOption)
			{
			case OnSerializeRigidBody.All:
				rigidbody.velocity = (Vector3)stream.ReceiveNext();
				rigidbody.angularVelocity = (Vector3)stream.ReceiveNext();
				break;
			case OnSerializeRigidBody.OnlyAngularVelocity:
				rigidbody.angularVelocity = (Vector3)stream.ReceiveNext();
				break;
			case OnSerializeRigidBody.OnlyVelocity:
				rigidbody.velocity = (Vector3)stream.ReceiveNext();
				break;
			}
		}
		else if (component is Rigidbody2D)
		{
			Rigidbody2D rigidbody2D = (Rigidbody2D)component;
			switch (onSerializeRigidBodyOption)
			{
			case OnSerializeRigidBody.All:
				rigidbody2D.velocity = (Vector2)stream.ReceiveNext();
				rigidbody2D.angularVelocity = (float)stream.ReceiveNext();
				break;
			case OnSerializeRigidBody.OnlyAngularVelocity:
				rigidbody2D.angularVelocity = (float)stream.ReceiveNext();
				break;
			case OnSerializeRigidBody.OnlyVelocity:
				rigidbody2D.velocity = (Vector2)stream.ReceiveNext();
				break;
			}
		}
		else
		{
			UnityEngine.Debug.LogError("Type of observed is unknown when receiving.");
		}
	}

	protected internal void SerializeComponent(UnityEngine.Component component, PhotonStream stream, PhotonMessageInfo info)
	{
		if (component == null)
		{
			return;
		}
		if (component is UnityEngine.MonoBehaviour)
		{
			ExecuteComponentOnSerialize(component, stream, info);
		}
		else if (component is Transform)
		{
			Transform transform = (Transform)component;
			switch (onSerializeTransformOption)
			{
			case OnSerializeTransform.All:
				stream.SendNext(transform.localPosition);
				stream.SendNext(transform.localRotation);
				stream.SendNext(transform.localScale);
				break;
			case OnSerializeTransform.OnlyPosition:
				stream.SendNext(transform.localPosition);
				break;
			case OnSerializeTransform.OnlyRotation:
				stream.SendNext(transform.localRotation);
				break;
			case OnSerializeTransform.OnlyScale:
				stream.SendNext(transform.localScale);
				break;
			case OnSerializeTransform.PositionAndRotation:
				stream.SendNext(transform.localPosition);
				stream.SendNext(transform.localRotation);
				break;
			}
		}
		else if (component is Rigidbody)
		{
			Rigidbody rigidbody = (Rigidbody)component;
			switch (onSerializeRigidBodyOption)
			{
			case OnSerializeRigidBody.All:
				stream.SendNext(rigidbody.velocity);
				stream.SendNext(rigidbody.angularVelocity);
				break;
			case OnSerializeRigidBody.OnlyAngularVelocity:
				stream.SendNext(rigidbody.angularVelocity);
				break;
			case OnSerializeRigidBody.OnlyVelocity:
				stream.SendNext(rigidbody.velocity);
				break;
			}
		}
		else if (component is Rigidbody2D)
		{
			Rigidbody2D rigidbody2D = (Rigidbody2D)component;
			switch (onSerializeRigidBodyOption)
			{
			case OnSerializeRigidBody.All:
				stream.SendNext(rigidbody2D.velocity);
				stream.SendNext(rigidbody2D.angularVelocity);
				break;
			case OnSerializeRigidBody.OnlyAngularVelocity:
				stream.SendNext(rigidbody2D.angularVelocity);
				break;
			case OnSerializeRigidBody.OnlyVelocity:
				stream.SendNext(rigidbody2D.velocity);
				break;
			}
		}
		else
		{
			UnityEngine.Debug.LogError("Observed type is not serializable: " + component.GetType());
		}
	}

	protected internal void ExecuteComponentOnSerialize(UnityEngine.Component component, PhotonStream stream, PhotonMessageInfo info)
	{
		if (component is IPunObservable punObservable)
		{
			punObservable.OnPhotonSerializeView(stream, info);
		}
		else
		{
			if (!(component != null))
			{
				return;
			}
			MethodInfo value = null;
			if (!m_OnSerializeMethodInfos.TryGetValue(component, out value))
			{
				if (!NetworkingPeer.GetMethod(component as UnityEngine.MonoBehaviour, PhotonNetworkingMessage.OnPhotonSerializeView.ToString(), out value))
				{
					UnityEngine.Debug.LogError("The observed monobehaviour (" + component.name + ") of this PhotonView does not implement OnPhotonSerializeView()!");
					value = null;
				}
				m_OnSerializeMethodInfos.Add(component, value);
			}
			value?.Invoke(component, new object[2] { stream, info });
		}
	}

	public void RefreshRpcMonoBehaviourCache()
	{
		RpcMonoBehaviours = GetComponents<UnityEngine.MonoBehaviour>();
	}

	public void RPC(string methodName, PhotonTargets target, params object[] parameters)
	{
		PhotonNetwork.RPC(this, methodName, target, encrypt: false, parameters);
	}

	public void RpcSecure(string methodName, PhotonTargets target, bool encrypt, params object[] parameters)
	{
		PhotonNetwork.RPC(this, methodName, target, encrypt, parameters);
	}

	public void RPC(string methodName, PhotonPlayer targetPlayer, params object[] parameters)
	{
		PhotonNetwork.RPC(this, methodName, targetPlayer, encrpyt: false, parameters);
	}

	public void RpcSecure(string methodName, PhotonPlayer targetPlayer, bool encrypt, params object[] parameters)
	{
		PhotonNetwork.RPC(this, methodName, targetPlayer, encrypt, parameters);
	}

	public static PhotonView Get(UnityEngine.Component component)
	{
		return component.GetComponent<PhotonView>();
	}

	public static PhotonView Get(GameObject gameObj)
	{
		return gameObj.GetComponent<PhotonView>();
	}

	public static PhotonView Find(int viewID)
	{
		return PhotonNetwork.networkingPeer.GetPhotonView(viewID);
	}

	public override string ToString()
	{
		return string.Format("View ({3}){0} on {1} {2}", viewID, (!(base.gameObject != null)) ? "GO==null" : base.gameObject.name, (!isSceneView) ? string.Empty : "(scene)", prefix);
	}
}
public class PhotonPingManager
{
	public bool UseNative;

	public static int Attempts = 5;

	public static bool IgnoreInitialAttempt = true;

	public static int MaxMilliseconsPerPing = 800;

	private const string wssProtocolString = "wss://";

	private int PingsRunning;

	public Region BestRegion
	{
		get
		{
			Region result = null;
			int num = int.MaxValue;
			foreach (Region availableRegion in PhotonNetwork.networkingPeer.AvailableRegions)
			{
				UnityEngine.Debug.Log("BestRegion checks region: " + availableRegion);
				if (availableRegion.Ping != 0 && availableRegion.Ping < num)
				{
					num = availableRegion.Ping;
					result = availableRegion;
				}
			}
			return result;
		}
	}

	public bool Done => PingsRunning == 0;

	public IEnumerator PingSocket(Region region)
	{
		region.Ping = Attempts * MaxMilliseconsPerPing;
		PingsRunning++;
		PhotonPing ping;
		if (PhotonHandler.PingImplementation == typeof(PingNativeDynamic))
		{
			UnityEngine.Debug.Log("Using constructor for new PingNativeDynamic()");
			ping = new PingNativeDynamic();
		}
		else if (PhotonHandler.PingImplementation != typeof(PingNativeStatic))
		{
			ping = ((PhotonHandler.PingImplementation != typeof(PingMono)) ? ((PhotonPing)Activator.CreateInstance(PhotonHandler.PingImplementation)) : new PingMono());
		}
		else
		{
			UnityEngine.Debug.Log("Using constructor for new PingNativeStatic()");
			ping = new PingNativeStatic();
		}
		float rttSum = 0f;
		int replyCount = 0;
		string regionAddress = region.HostAndPort;
		int indexOfColon = regionAddress.LastIndexOf(':');
		if (indexOfColon > 1)
		{
			regionAddress = regionAddress.Substring(0, indexOfColon);
		}
		int indexOfProtocol = regionAddress.IndexOf("wss://");
		if (indexOfProtocol > -1)
		{
			regionAddress = regionAddress.Substring(indexOfProtocol + "wss://".Length);
		}
		regionAddress = ResolveHost(regionAddress);
		UnityEngine.Debug.Log(string.Concat("Ping Debug - PhotonHandler.PingImplementation: ", PhotonHandler.PingImplementation, " ping.GetType():", ping.GetType(), " regionAddress:", regionAddress));
		for (int i = 0; i < Attempts; i++)
		{
			bool overtime = false;
			Stopwatch sw = new Stopwatch();
			sw.Start();
			try
			{
				ping.StartPing(regionAddress);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("catched: " + ex);
				PingsRunning--;
				break;
			}
			while (!ping.Done())
			{
				if (sw.ElapsedMilliseconds >= MaxMilliseconsPerPing)
				{
					overtime = true;
					break;
				}
				yield return 0;
			}
			int rtt = (int)sw.ElapsedMilliseconds;
			if ((!IgnoreInitialAttempt || i != 0) && ping.Successful && !overtime)
			{
				rttSum += (float)rtt;
				replyCount++;
				region.Ping = (int)(rttSum / (float)replyCount);
			}
			yield return new WaitForSeconds(0.1f);
		}
		ping.Dispose();
		PingsRunning--;
		yield return null;
	}

	public static string ResolveHost(string hostName)
	{
		string text = string.Empty;
		try
		{
			IPAddress[] hostAddresses = Dns.GetHostAddresses(hostName);
			if (hostAddresses.Length == 1)
			{
				return hostAddresses[0].ToString();
			}
			foreach (IPAddress iPAddress in hostAddresses)
			{
				if (iPAddress != null)
				{
					if (iPAddress.ToString().Contains(":"))
					{
						return iPAddress.ToString();
					}
					if (string.IsNullOrEmpty(text))
					{
						text = hostAddresses.ToString();
					}
				}
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("Exception caught! " + ex.Source + " Message: " + ex.Message);
		}
		return text;
	}
}
public class PunRPC : Attribute
{
}
public class Room : RoomInfo
{
	public new string Name
	{
		get
		{
			return nameField;
		}
		internal set
		{
			nameField = value;
		}
	}

	public new bool IsOpen
	{
		get
		{
			return openField;
		}
		set
		{
			if (!Equals(PhotonNetwork.room))
			{
				UnityEngine.Debug.LogWarning("Can't set open when not in that room.");
			}
			if (value != openField && !PhotonNetwork.offlineMode)
			{
				PhotonNetwork.networkingPeer.OpSetPropertiesOfRoom(new ExitGames.Client.Photon.Hashtable { 
				{
					(byte)253,
					value
				} });
			}
			openField = value;
		}
	}

	public new bool IsVisible
	{
		get
		{
			return visibleField;
		}
		set
		{
			if (!Equals(PhotonNetwork.room))
			{
				UnityEngine.Debug.LogWarning("Can't set visible when not in that room.");
			}
			if (value != visibleField && !PhotonNetwork.offlineMode)
			{
				PhotonNetwork.networkingPeer.OpSetPropertiesOfRoom(new ExitGames.Client.Photon.Hashtable { 
				{
					(byte)254,
					value
				} });
			}
			visibleField = value;
		}
	}

	public string[] PropertiesListedInLobby { get; private set; }

	public bool AutoCleanUp => autoCleanUpField;

	public new int MaxPlayers
	{
		get
		{
			return maxPlayersField;
		}
		set
		{
			if (!Equals(PhotonNetwork.room))
			{
				UnityEngine.Debug.LogWarning("Can't set MaxPlayers when not in that room.");
			}
			if (value > 255)
			{
				UnityEngine.Debug.LogWarning("Can't set Room.MaxPlayers to: " + value + ". Using max value: 255.");
				value = 255;
			}
			if (value != maxPlayersField && !PhotonNetwork.offlineMode)
			{
				PhotonNetwork.networkingPeer.OpSetPropertiesOfRoom(new ExitGames.Client.Photon.Hashtable { 
				{
					byte.MaxValue,
					(byte)value
				} });
			}
			maxPlayersField = (byte)value;
		}
	}

	public new int PlayerCount
	{
		get
		{
			if (PhotonNetwork.playerList != null)
			{
				return PhotonNetwork.playerList.Length;
			}
			return 0;
		}
	}

	public string[] ExpectedUsers => expectedUsersField;

	public int PlayerTtl
	{
		get
		{
			return playerTtlField;
		}
		set
		{
			if (!Equals(PhotonNetwork.room))
			{
				UnityEngine.Debug.LogWarning("Can't set PlayerTtl when not in a room.");
			}
			if (value != playerTtlField && !PhotonNetwork.offlineMode)
			{
				PhotonNetwork.networkingPeer.OpSetPropertyOfRoom(246, value);
			}
			playerTtlField = value;
		}
	}

	public int EmptyRoomTtl
	{
		get
		{
			return emptyRoomTtlField;
		}
		set
		{
			if (!Equals(PhotonNetwork.room))
			{
				UnityEngine.Debug.LogWarning("Can't set EmptyRoomTtl when not in a room.");
			}
			if (value != emptyRoomTtlField && !PhotonNetwork.offlineMode)
			{
				PhotonNetwork.networkingPeer.OpSetPropertyOfRoom(245, value);
			}
			emptyRoomTtlField = value;
		}
	}

	protected internal int MasterClientId
	{
		get
		{
			return masterClientIdField;
		}
		set
		{
			masterClientIdField = value;
		}
	}

	[Obsolete("Please use Name (updated case for naming).")]
	public new string name
	{
		get
		{
			return Name;
		}
		internal set
		{
			Name = value;
		}
	}

	[Obsolete("Please use IsOpen (updated case for naming).")]
	public new bool open
	{
		get
		{
			return IsOpen;
		}
		set
		{
			IsOpen = value;
		}
	}

	[Obsolete("Please use IsVisible (updated case for naming).")]
	public new bool visible
	{
		get
		{
			return IsVisible;
		}
		set
		{
			IsVisible = value;
		}
	}

	[Obsolete("Please use PropertiesListedInLobby (updated case for naming).")]
	public string[] propertiesListedInLobby
	{
		get
		{
			return PropertiesListedInLobby;
		}
		private set
		{
			PropertiesListedInLobby = value;
		}
	}

	[Obsolete("Please use AutoCleanUp (updated case for naming).")]
	public bool autoCleanUp => AutoCleanUp;

	[Obsolete("Please use MaxPlayers (updated case for naming).")]
	public new int maxPlayers
	{
		get
		{
			return MaxPlayers;
		}
		set
		{
			MaxPlayers = value;
		}
	}

	[Obsolete("Please use PlayerCount (updated case for naming).")]
	public new int playerCount => PlayerCount;

	[Obsolete("Please use ExpectedUsers (updated case for naming).")]
	public string[] expectedUsers => ExpectedUsers;

	[Obsolete("Please use MasterClientId (updated case for naming).")]
	protected internal int masterClientId
	{
		get
		{
			return MasterClientId;
		}
		set
		{
			MasterClientId = value;
		}
	}

	internal Room(string roomName, RoomOptions options)
		: base(roomName, null)
	{
		if (options == null)
		{
			options = new RoomOptions();
		}
		visibleField = options.IsVisible;
		openField = options.IsOpen;
		maxPlayersField = options.MaxPlayers;
		autoCleanUpField = false;
		InternalCacheProperties(options.CustomRoomProperties);
		PropertiesListedInLobby = options.CustomRoomPropertiesForLobby;
	}

	public void SetCustomProperties(ExitGames.Client.Photon.Hashtable propertiesToSet, ExitGames.Client.Photon.Hashtable expectedValues = null, bool webForward = false)
	{
		if (propertiesToSet != null)
		{
			ExitGames.Client.Photon.Hashtable hashtable = propertiesToSet.StripToStringKeys();
			ExitGames.Client.Photon.Hashtable hashtable2 = expectedValues.StripToStringKeys();
			bool flag = hashtable2 == null || hashtable2.Count == 0;
			if (PhotonNetwork.offlineMode || flag)
			{
				base.CustomProperties.Merge(hashtable);
				base.CustomProperties.StripKeysWithNullValues();
			}
			if (!PhotonNetwork.offlineMode)
			{
				PhotonNetwork.networkingPeer.OpSetPropertiesOfRoom(hashtable, hashtable2, webForward);
			}
			if (PhotonNetwork.offlineMode || flag)
			{
				NetworkingPeer.SendMonoMessage(PhotonNetworkingMessage.OnPhotonCustomRoomPropertiesChanged, hashtable);
			}
		}
	}

	public void SetPropertiesListedInLobby(string[] propsListedInLobby)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)250] = propsListedInLobby;
		PhotonNetwork.networkingPeer.OpSetPropertiesOfRoom(hashtable);
		PropertiesListedInLobby = propsListedInLobby;
	}

	public void ClearExpectedUsers()
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)247] = new string[0];
		ExitGames.Client.Photon.Hashtable hashtable2 = new ExitGames.Client.Photon.Hashtable();
		hashtable2[(byte)247] = ExpectedUsers;
		PhotonNetwork.networkingPeer.OpSetPropertiesOfRoom(hashtable, hashtable2);
	}

	public void SetExpectedUsers(string[] expectedUsers)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)247] = expectedUsers;
		ExitGames.Client.Photon.Hashtable hashtable2 = new ExitGames.Client.Photon.Hashtable();
		hashtable2[(byte)247] = ExpectedUsers;
		PhotonNetwork.networkingPeer.OpSetPropertiesOfRoom(hashtable, hashtable2);
	}

	public override string ToString()
	{
		return string.Format("Room: '{0}' {1},{2} {4}/{3} players.", nameField, (!visibleField) ? "hidden" : "visible", (!openField) ? "closed" : "open", maxPlayersField, PlayerCount);
	}

	public new string ToStringFull()
	{
		return string.Format("Room: '{0}' {1},{2} {4}/{3} players.\ncustomProps: {5}", nameField, (!visibleField) ? "hidden" : "visible", (!openField) ? "closed" : "open", maxPlayersField, PlayerCount, base.CustomProperties.ToStringFull());
	}
}
public class RoomInfo
{
	private ExitGames.Client.Photon.Hashtable customPropertiesField = new ExitGames.Client.Photon.Hashtable();

	protected byte maxPlayersField;

	protected int emptyRoomTtlField;

	protected int playerTtlField;

	protected string[] expectedUsersField;

	protected bool openField = true;

	protected bool visibleField = true;

	protected bool autoCleanUpField = PhotonNetwork.autoCleanUpPlayerObjects;

	protected string nameField;

	protected internal int masterClientIdField;

	public bool removedFromList { get; internal set; }

	protected internal bool serverSideMasterClient { get; private set; }

	public ExitGames.Client.Photon.Hashtable CustomProperties => customPropertiesField;

	public string Name => nameField;

	public int PlayerCount { get; private set; }

	public bool IsLocalClientInside { get; set; }

	public byte MaxPlayers => maxPlayersField;

	public bool IsOpen => openField;

	public bool IsVisible => visibleField;

	[Obsolete("Please use CustomProperties (updated case for naming).")]
	public ExitGames.Client.Photon.Hashtable customProperties => CustomProperties;

	[Obsolete("Please use Name (updated case for naming).")]
	public string name => Name;

	[Obsolete("Please use PlayerCount (updated case for naming).")]
	public int playerCount
	{
		get
		{
			return PlayerCount;
		}
		set
		{
			PlayerCount = value;
		}
	}

	[Obsolete("Please use IsLocalClientInside (updated case for naming).")]
	public bool isLocalClientInside
	{
		get
		{
			return IsLocalClientInside;
		}
		set
		{
			IsLocalClientInside = value;
		}
	}

	[Obsolete("Please use MaxPlayers (updated case for naming).")]
	public byte maxPlayers => MaxPlayers;

	[Obsolete("Please use IsOpen (updated case for naming).")]
	public bool open => IsOpen;

	[Obsolete("Please use IsVisible (updated case for naming).")]
	public bool visible => IsVisible;

	protected internal RoomInfo(string roomName, ExitGames.Client.Photon.Hashtable properties)
	{
		InternalCacheProperties(properties);
		nameField = roomName;
	}

	public override bool Equals(object other)
	{
		return other is RoomInfo roomInfo && Name.Equals(roomInfo.nameField);
	}

	public override int GetHashCode()
	{
		return nameField.GetHashCode();
	}

	public override string ToString()
	{
		return string.Format("Room: '{0}' {1},{2} {4}/{3} players.", nameField, (!visibleField) ? "hidden" : "visible", (!openField) ? "closed" : "open", maxPlayersField, PlayerCount);
	}

	public string ToStringFull()
	{
		return string.Format("Room: '{0}' {1},{2} {4}/{3} players.\ncustomProps: {5}", nameField, (!visibleField) ? "hidden" : "visible", (!openField) ? "closed" : "open", maxPlayersField, PlayerCount, customPropertiesField.ToStringFull());
	}

	protected internal void InternalCacheProperties(ExitGames.Client.Photon.Hashtable propertiesToCache)
	{
		if (propertiesToCache == null || propertiesToCache.Count == 0 || customPropertiesField.Equals(propertiesToCache))
		{
			return;
		}
		if (propertiesToCache.ContainsKey((byte)251))
		{
			removedFromList = (bool)propertiesToCache[(byte)251];
			if (removedFromList)
			{
				return;
			}
		}
		if (propertiesToCache.ContainsKey(byte.MaxValue))
		{
			maxPlayersField = (byte)propertiesToCache[byte.MaxValue];
		}
		if (propertiesToCache.ContainsKey((byte)253))
		{
			openField = (bool)propertiesToCache[(byte)253];
		}
		if (propertiesToCache.ContainsKey((byte)254))
		{
			visibleField = (bool)propertiesToCache[(byte)254];
		}
		if (propertiesToCache.ContainsKey((byte)252))
		{
			PlayerCount = (byte)propertiesToCache[(byte)252];
		}
		if (propertiesToCache.ContainsKey((byte)249))
		{
			autoCleanUpField = (bool)propertiesToCache[(byte)249];
		}
		if (propertiesToCache.ContainsKey((byte)248))
		{
			serverSideMasterClient = true;
			bool flag = masterClientIdField != 0;
			masterClientIdField = (int)propertiesToCache[(byte)248];
			if (flag)
			{
				PhotonNetwork.networkingPeer.UpdateMasterClient();
			}
		}
		if (propertiesToCache.ContainsKey((byte)247))
		{
			expectedUsersField = (string[])propertiesToCache[(byte)247];
		}
		if (propertiesToCache.ContainsKey((byte)245))
		{
			emptyRoomTtlField = (int)propertiesToCache[(byte)245];
		}
		if (propertiesToCache.ContainsKey((byte)246))
		{
			playerTtlField = (int)propertiesToCache[(byte)246];
		}
		customPropertiesField.MergeStringKeys(propertiesToCache);
		customPropertiesField.StripKeysWithNullValues();
	}
}
public class Region
{
	public CloudRegionCode Code;

	public string Cluster;

	public string HostAndPort;

	public int Ping;

	public Region(CloudRegionCode code)
	{
		Code = code;
		Cluster = code.ToString();
	}

	public Region(CloudRegionCode code, string regionCodeString, string address)
	{
		Code = code;
		Cluster = regionCodeString;
		HostAndPort = address;
	}

	public static CloudRegionCode Parse(string codeAsString)
	{
		if (codeAsString == null)
		{
			return CloudRegionCode.none;
		}
		int num = codeAsString.IndexOf('/');
		if (num > 0)
		{
			codeAsString = codeAsString.Substring(0, num);
		}
		codeAsString = codeAsString.ToLower();
		if (Enum.IsDefined(typeof(CloudRegionCode), codeAsString))
		{
			return (CloudRegionCode)Enum.Parse(typeof(CloudRegionCode), codeAsString);
		}
		return CloudRegionCode.none;
	}

	internal static CloudRegionFlag ParseFlag(CloudRegionCode region)
	{
		if (Enum.IsDefined(typeof(CloudRegionFlag), region.ToString()))
		{
			return (CloudRegionFlag)Enum.Parse(typeof(CloudRegionFlag), region.ToString());
		}
		return (CloudRegionFlag)0;
	}

	[Obsolete]
	internal static CloudRegionFlag ParseFlag(string codeAsString)
	{
		codeAsString = codeAsString.ToLower();
		CloudRegionFlag result = (CloudRegionFlag)0;
		if (Enum.IsDefined(typeof(CloudRegionFlag), codeAsString))
		{
			result = (CloudRegionFlag)Enum.Parse(typeof(CloudRegionFlag), codeAsString);
		}
		return result;
	}

	public override string ToString()
	{
		return $"'{Cluster}' \t{Ping}ms \t{HostAndPort}";
	}
}
[Serializable]
public class ServerSettings : ScriptableObject
{
	public enum HostingOption
	{
		NotSet,
		PhotonCloud,
		SelfHosted,
		OfflineMode,
		BestRegion
	}

	public string AppID = string.Empty;

	public string VoiceAppID = string.Empty;

	public string ChatAppID = string.Empty;

	public HostingOption HostType;

	public CloudRegionCode PreferredRegion;

	public CloudRegionFlag EnabledRegions = (CloudRegionFlag)(-1);

	public ConnectionProtocol Protocol;

	public string ServerAddress = string.Empty;

	public int ServerPort = 5055;

	public int VoiceServerPort = 5055;

	public bool JoinLobby;

	public bool EnableLobbyStatistics;

	public PhotonLogLevel PunLogging;

	public DebugLevel NetworkLogging = DebugLevel.ERROR;

	public bool RunInBackground = true;

	public List<string> RpcList = new List<string>();

	[HideInInspector]
	public bool DisableAutoOpenWizard;

	public static CloudRegionCode BestRegionCodeInPreferences => PhotonHandler.BestRegionCodeInPreferences;

	public void UseCloudBestRegion(string cloudAppid)
	{
		HostType = HostingOption.BestRegion;
		AppID = cloudAppid;
	}

	public void UseCloud(string cloudAppid)
	{
		HostType = HostingOption.PhotonCloud;
		AppID = cloudAppid;
	}

	public void UseCloud(string cloudAppid, CloudRegionCode code)
	{
		HostType = HostingOption.PhotonCloud;
		AppID = cloudAppid;
		PreferredRegion = code;
	}

	public void UseMyServer(string serverAddress, int serverPort, string application)
	{
		HostType = HostingOption.SelfHosted;
		AppID = ((application == null) ? "master" : application);
		ServerAddress = serverAddress;
		ServerPort = serverPort;
	}

	public static bool IsAppId(string val)
	{
		try
		{
			new Guid(val);
		}
		catch
		{
			return false;
		}
		return true;
	}

	public static void ResetBestRegionCodeInPreferences()
	{
		PhotonHandler.BestRegionCodeInPreferences = CloudRegionCode.none;
	}

	public override string ToString()
	{
		return string.Concat("ServerSettings: ", HostType, " ", ServerAddress);
	}
}
[RequireComponent(typeof(Animator))]
[RequireComponent(typeof(PhotonView))]
[AddComponentMenu("Photon Networking/Photon Animator View")]
public class PhotonAnimatorView : UnityEngine.MonoBehaviour, IPunObservable
{
	public enum ParameterType
	{
		Float = 1,
		Int = 3,
		Bool = 4,
		Trigger = 9
	}

	public enum SynchronizeType
	{
		Disabled,
		Discrete,
		Continuous
	}

	[Serializable]
	public class SynchronizedParameter
	{
		public ParameterType Type;

		public SynchronizeType SynchronizeType;

		public string Name;
	}

	[Serializable]
	public class SynchronizedLayer
	{
		public SynchronizeType SynchronizeType;

		public int LayerIndex;
	}

	private Animator m_Animator;

	private PhotonStreamQueue m_StreamQueue;

	[HideInInspector]
	[SerializeField]
	private bool ShowLayerWeightsInspector = true;

	[HideInInspector]
	[SerializeField]
	private bool ShowParameterInspector = true;

	[HideInInspector]
	[SerializeField]
	private List<SynchronizedParameter> m_SynchronizeParameters = new List<SynchronizedParameter>();

	[HideInInspector]
	[SerializeField]
	private List<SynchronizedLayer> m_SynchronizeLayers = new List<SynchronizedLayer>();

	private Vector3 m_ReceiverPosition;

	private float m_LastDeserializeTime;

	private bool m_WasSynchronizeTypeChanged = true;

	private PhotonView m_PhotonView;

	private List<string> m_raisedDiscreteTriggersCache = new List<string>();

	private void Awake()
	{
		m_PhotonView = GetComponent<PhotonView>();
		m_StreamQueue = new PhotonStreamQueue(120);
		m_Animator = GetComponent<Animator>();
	}

	private void Update()
	{
		if (m_Animator.applyRootMotion && !m_PhotonView.isMine && PhotonNetwork.connected)
		{
			m_Animator.applyRootMotion = false;
		}
		if (!PhotonNetwork.inRoom || PhotonNetwork.room.PlayerCount <= 1)
		{
			m_StreamQueue.Reset();
		}
		else if (m_PhotonView.isMine)
		{
			SerializeDataContinuously();
			CacheDiscreteTriggers();
		}
		else
		{
			DeserializeDataContinuously();
		}
	}

	public void CacheDiscreteTriggers()
	{
		for (int i = 0; i < m_SynchronizeParameters.Count; i++)
		{
			SynchronizedParameter synchronizedParameter = m_SynchronizeParameters[i];
			if (synchronizedParameter.SynchronizeType == SynchronizeType.Discrete && synchronizedParameter.Type == ParameterType.Trigger && m_Animator.GetBool(synchronizedParameter.Name) && synchronizedParameter.Type == ParameterType.Trigger)
			{
				m_raisedDiscreteTriggersCache.Add(synchronizedParameter.Name);
				break;
			}
		}
	}

	public bool DoesLayerSynchronizeTypeExist(int layerIndex)
	{
		return m_SynchronizeLayers.FindIndex((SynchronizedLayer item) => item.LayerIndex == layerIndex) != -1;
	}

	public bool DoesParameterSynchronizeTypeExist(string name)
	{
		return m_SynchronizeParameters.FindIndex((SynchronizedParameter item) => item.Name == name) != -1;
	}

	public List<SynchronizedLayer> GetSynchronizedLayers()
	{
		return m_SynchronizeLayers;
	}

	public List<SynchronizedParameter> GetSynchronizedParameters()
	{
		return m_SynchronizeParameters;
	}

	public SynchronizeType GetLayerSynchronizeType(int layerIndex)
	{
		int num = m_SynchronizeLayers.FindIndex((SynchronizedLayer item) => item.LayerIndex == layerIndex);
		if (num == -1)
		{
			return SynchronizeType.Disabled;
		}
		return m_SynchronizeLayers[num].SynchronizeType;
	}

	public SynchronizeType GetParameterSynchronizeType(string name)
	{
		int num = m_SynchronizeParameters.FindIndex((SynchronizedParameter item) => item.Name == name);
		if (num == -1)
		{
			return SynchronizeType.Disabled;
		}
		return m_SynchronizeParameters[num].SynchronizeType;
	}

	public void SetLayerSynchronized(int layerIndex, SynchronizeType synchronizeType)
	{
		if (UnityEngine.Application.isPlaying)
		{
			m_WasSynchronizeTypeChanged = true;
		}
		int num = m_SynchronizeLayers.FindIndex((SynchronizedLayer item) => item.LayerIndex == layerIndex);
		if (num == -1)
		{
			m_SynchronizeLayers.Add(new SynchronizedLayer
			{
				LayerIndex = layerIndex,
				SynchronizeType = synchronizeType
			});
		}
		else
		{
			m_SynchronizeLayers[num].SynchronizeType = synchronizeType;
		}
	}

	public void SetParameterSynchronized(string name, ParameterType type, SynchronizeType synchronizeType)
	{
		if (UnityEngine.Application.isPlaying)
		{
			m_WasSynchronizeTypeChanged = true;
		}
		int num = m_SynchronizeParameters.FindIndex((SynchronizedParameter item) => item.Name == name);
		if (num == -1)
		{
			m_SynchronizeParameters.Add(new SynchronizedParameter
			{
				Name = name,
				Type = type,
				SynchronizeType = synchronizeType
			});
		}
		else
		{
			m_SynchronizeParameters[num].SynchronizeType = synchronizeType;
		}
	}

	private void SerializeDataContinuously()
	{
		if (m_Animator == null)
		{
			return;
		}
		for (int i = 0; i < m_SynchronizeLayers.Count; i++)
		{
			if (m_SynchronizeLayers[i].SynchronizeType == SynchronizeType.Continuous)
			{
				m_StreamQueue.SendNext(m_Animator.GetLayerWeight(m_SynchronizeLayers[i].LayerIndex));
			}
		}
		for (int j = 0; j < m_SynchronizeParameters.Count; j++)
		{
			SynchronizedParameter synchronizedParameter = m_SynchronizeParameters[j];
			if (synchronizedParameter.SynchronizeType == SynchronizeType.Continuous)
			{
				switch (synchronizedParameter.Type)
				{
				case ParameterType.Bool:
					m_StreamQueue.SendNext(m_Animator.GetBool(synchronizedParameter.Name));
					break;
				case ParameterType.Float:
					m_StreamQueue.SendNext(m_Animator.GetFloat(synchronizedParameter.Name));
					break;
				case ParameterType.Int:
					m_StreamQueue.SendNext(m_Animator.GetInteger(synchronizedParameter.Name));
					break;
				case ParameterType.Trigger:
					m_StreamQueue.SendNext(m_Animator.GetBool(synchronizedParameter.Name));
					break;
				}
			}
		}
	}

	private void DeserializeDataContinuously()
	{
		if (!m_StreamQueue.HasQueuedObjects())
		{
			return;
		}
		for (int i = 0; i < m_SynchronizeLayers.Count; i++)
		{
			if (m_SynchronizeLayers[i].SynchronizeType == SynchronizeType.Continuous)
			{
				m_Animator.SetLayerWeight(m_SynchronizeLayers[i].LayerIndex, (float)m_StreamQueue.ReceiveNext());
			}
		}
		for (int j = 0; j < m_SynchronizeParameters.Count; j++)
		{
			SynchronizedParameter synchronizedParameter = m_SynchronizeParameters[j];
			if (synchronizedParameter.SynchronizeType == SynchronizeType.Continuous)
			{
				switch (synchronizedParameter.Type)
				{
				case ParameterType.Bool:
					m_Animator.SetBool(synchronizedParameter.Name, (bool)m_StreamQueue.ReceiveNext());
					break;
				case ParameterType.Float:
					m_Animator.SetFloat(synchronizedParameter.Name, (float)m_StreamQueue.ReceiveNext());
					break;
				case ParameterType.Int:
					m_Animator.SetInteger(synchronizedParameter.Name, (int)m_StreamQueue.ReceiveNext());
					break;
				case ParameterType.Trigger:
					m_Animator.SetBool(synchronizedParameter.Name, (bool)m_StreamQueue.ReceiveNext());
					break;
				}
			}
		}
	}

	private void SerializeDataDiscretly(PhotonStream stream)
	{
		for (int i = 0; i < m_SynchronizeLayers.Count; i++)
		{
			if (m_SynchronizeLayers[i].SynchronizeType == SynchronizeType.Discrete)
			{
				stream.SendNext(m_Animator.GetLayerWeight(m_SynchronizeLayers[i].LayerIndex));
			}
		}
		for (int j = 0; j < m_SynchronizeParameters.Count; j++)
		{
			SynchronizedParameter synchronizedParameter = m_SynchronizeParameters[j];
			if (synchronizedParameter.SynchronizeType == SynchronizeType.Discrete)
			{
				switch (synchronizedParameter.Type)
				{
				case ParameterType.Bool:
					stream.SendNext(m_Animator.GetBool(synchronizedParameter.Name));
					break;
				case ParameterType.Float:
					stream.SendNext(m_Animator.GetFloat(synchronizedParameter.Name));
					break;
				case ParameterType.Int:
					stream.SendNext(m_Animator.GetInteger(synchronizedParameter.Name));
					break;
				case ParameterType.Trigger:
					stream.SendNext(m_raisedDiscreteTriggersCache.Contains(synchronizedParameter.Name));
					break;
				}
			}
		}
		m_raisedDiscreteTriggersCache.Clear();
	}

	private void DeserializeDataDiscretly(PhotonStream stream)
	{
		for (int i = 0; i < m_SynchronizeLayers.Count; i++)
		{
			if (m_SynchronizeLayers[i].SynchronizeType == SynchronizeType.Discrete)
			{
				m_Animator.SetLayerWeight(m_SynchronizeLayers[i].LayerIndex, (float)stream.ReceiveNext());
			}
		}
		for (int j = 0; j < m_SynchronizeParameters.Count; j++)
		{
			SynchronizedParameter synchronizedParameter = m_SynchronizeParameters[j];
			if (synchronizedParameter.SynchronizeType != SynchronizeType.Discrete)
			{
				continue;
			}
			switch (synchronizedParameter.Type)
			{
			case ParameterType.Bool:
				if (!(stream.PeekNext() is bool))
				{
					return;
				}
				m_Animator.SetBool(synchronizedParameter.Name, (bool)stream.ReceiveNext());
				break;
			case ParameterType.Float:
				if (!(stream.PeekNext() is float))
				{
					return;
				}
				m_Animator.SetFloat(synchronizedParameter.Name, (float)stream.ReceiveNext());
				break;
			case ParameterType.Int:
				if (!(stream.PeekNext() is int))
				{
					return;
				}
				m_Animator.SetInteger(synchronizedParameter.Name, (int)stream.ReceiveNext());
				break;
			case ParameterType.Trigger:
				if (!(stream.PeekNext() is bool))
				{
					return;
				}
				if ((bool)stream.ReceiveNext())
				{
					m_Animator.SetTrigger(synchronizedParameter.Name);
				}
				break;
			}
		}
	}

	private void SerializeSynchronizationTypeState(PhotonStream stream)
	{
		byte[] array = new byte[m_SynchronizeLayers.Count + m_SynchronizeParameters.Count];
		for (int i = 0; i < m_SynchronizeLayers.Count; i++)
		{
			array[i] = (byte)m_SynchronizeLayers[i].SynchronizeType;
		}
		for (int j = 0; j < m_SynchronizeParameters.Count; j++)
		{
			array[m_SynchronizeLayers.Count + j] = (byte)m_SynchronizeParameters[j].SynchronizeType;
		}
		stream.SendNext(array);
	}

	private void DeserializeSynchronizationTypeState(PhotonStream stream)
	{
		byte[] array = (byte[])stream.ReceiveNext();
		for (int i = 0; i < m_SynchronizeLayers.Count; i++)
		{
			m_SynchronizeLayers[i].SynchronizeType = (SynchronizeType)array[i];
		}
		for (int j = 0; j < m_SynchronizeParameters.Count; j++)
		{
			m_SynchronizeParameters[j].SynchronizeType = (SynchronizeType)array[m_SynchronizeLayers.Count + j];
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (m_Animator == null)
		{
			return;
		}
		if (stream.isWriting)
		{
			if (m_WasSynchronizeTypeChanged)
			{
				m_StreamQueue.Reset();
				SerializeSynchronizationTypeState(stream);
				m_WasSynchronizeTypeChanged = false;
			}
			m_StreamQueue.Serialize(stream);
			SerializeDataDiscretly(stream);
		}
		else
		{
			if (stream.PeekNext() is byte[])
			{
				DeserializeSynchronizationTypeState(stream);
			}
			m_StreamQueue.Deserialize(stream);
			DeserializeDataDiscretly(stream);
		}
	}
}
[RequireComponent(typeof(PhotonView))]
[RequireComponent(typeof(Rigidbody2D))]
[AddComponentMenu("Photon Networking/Photon Rigidbody 2D View")]
public class PhotonRigidbody2DView : UnityEngine.MonoBehaviour, IPunObservable
{
	[SerializeField]
	private bool m_SynchronizeVelocity = true;

	[SerializeField]
	private bool m_SynchronizeAngularVelocity = true;

	private Rigidbody2D m_Body;

	private void Awake()
	{
		m_Body = GetComponent<Rigidbody2D>();
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.isWriting)
		{
			if (m_SynchronizeVelocity)
			{
				stream.SendNext(m_Body.velocity);
			}
			if (m_SynchronizeAngularVelocity)
			{
				stream.SendNext(m_Body.angularVelocity);
			}
		}
		else
		{
			if (m_SynchronizeVelocity)
			{
				m_Body.velocity = (Vector2)stream.ReceiveNext();
			}
			if (m_SynchronizeAngularVelocity)
			{
				m_Body.angularVelocity = (float)stream.ReceiveNext();
			}
		}
	}
}
[RequireComponent(typeof(PhotonView))]
[RequireComponent(typeof(Rigidbody))]
[AddComponentMenu("Photon Networking/Photon Rigidbody View")]
public class PhotonRigidbodyView : UnityEngine.MonoBehaviour, IPunObservable
{
	[SerializeField]
	private bool m_SynchronizeVelocity = true;

	[SerializeField]
	private bool m_SynchronizeAngularVelocity = true;

	private Rigidbody m_Body;

	private void Awake()
	{
		m_Body = GetComponent<Rigidbody>();
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.isWriting)
		{
			if (m_SynchronizeVelocity)
			{
				stream.SendNext(m_Body.velocity);
			}
			if (m_SynchronizeAngularVelocity)
			{
				stream.SendNext(m_Body.angularVelocity);
			}
		}
		else
		{
			if (m_SynchronizeVelocity)
			{
				m_Body.velocity = (Vector3)stream.ReceiveNext();
			}
			if (m_SynchronizeAngularVelocity)
			{
				m_Body.angularVelocity = (Vector3)stream.ReceiveNext();
			}
		}
	}
}
[RequireComponent(typeof(PhotonView))]
[AddComponentMenu("Photon Networking/Photon Transform View")]
public class PhotonTransformView : UnityEngine.MonoBehaviour, IPunObservable
{
	[SerializeField]
	public PhotonTransformViewPositionModel m_PositionModel = new PhotonTransformViewPositionModel();

	[SerializeField]
	public PhotonTransformViewRotationModel m_RotationModel = new PhotonTransformViewRotationModel();

	[SerializeField]
	public PhotonTransformViewScaleModel m_ScaleModel = new PhotonTransformViewScaleModel();

	private PhotonTransformViewPositionControl m_PositionControl;

	private PhotonTransformViewRotationControl m_RotationControl;

	private PhotonTransformViewScaleControl m_ScaleControl;

	private PhotonView m_PhotonView;

	private bool m_ReceivedNetworkUpdate;

	private bool m_firstTake;

	private void Awake()
	{
		m_PhotonView = GetComponent<PhotonView>();
		m_PositionControl = new PhotonTransformViewPositionControl(m_PositionModel);
		m_RotationControl = new PhotonTransformViewRotationControl(m_RotationModel);
		m_ScaleControl = new PhotonTransformViewScaleControl(m_ScaleModel);
	}

	private void OnEnable()
	{
		m_firstTake = true;
	}

	private void Update()
	{
		if (!(m_PhotonView == null) && !m_PhotonView.isMine && PhotonNetwork.connected)
		{
			UpdatePosition();
			UpdateRotation();
			UpdateScale();
		}
	}

	private void UpdatePosition()
	{
		if (m_PositionModel.SynchronizeEnabled && m_ReceivedNetworkUpdate)
		{
			base.transform.localPosition = m_PositionControl.UpdatePosition(base.transform.localPosition);
		}
	}

	private void UpdateRotation()
	{
		if (m_RotationModel.SynchronizeEnabled && m_ReceivedNetworkUpdate)
		{
			base.transform.localRotation = m_RotationControl.GetRotation(base.transform.localRotation);
		}
	}

	private void UpdateScale()
	{
		if (m_ScaleModel.SynchronizeEnabled && m_ReceivedNetworkUpdate)
		{
			base.transform.localScale = m_ScaleControl.GetScale(base.transform.localScale);
		}
	}

	public void SetSynchronizedValues(Vector3 speed, float turnSpeed)
	{
		m_PositionControl.SetSynchronizedValues(speed, turnSpeed);
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		m_PositionControl.OnPhotonSerializeView(base.transform.localPosition, stream, info);
		m_RotationControl.OnPhotonSerializeView(base.transform.localRotation, stream, info);
		m_ScaleControl.OnPhotonSerializeView(base.transform.localScale, stream, info);
		if (!m_PhotonView.isMine && m_PositionModel.DrawErrorGizmo)
		{
			DoDrawEstimatedPositionError();
		}
		if (!stream.isReading)
		{
			return;
		}
		m_ReceivedNetworkUpdate = true;
		if (m_firstTake)
		{
			m_firstTake = false;
			if (m_PositionModel.SynchronizeEnabled)
			{
				base.transform.localPosition = m_PositionControl.GetNetworkPosition();
			}
			if (m_RotationModel.SynchronizeEnabled)
			{
				base.transform.localRotation = m_RotationControl.GetNetworkRotation();
			}
			if (m_ScaleModel.SynchronizeEnabled)
			{
				base.transform.localScale = m_ScaleControl.GetNetworkScale();
			}
		}
	}

	private void DoDrawEstimatedPositionError()
	{
		Vector3 vector = m_PositionControl.GetNetworkPosition();
		if (base.transform.parent != null)
		{
			vector = base.transform.parent.position + vector;
		}
		UnityEngine.Debug.DrawLine(vector, base.transform.position, UnityEngine.Color.red, 2f);
		UnityEngine.Debug.DrawLine(base.transform.position, base.transform.position + Vector3.up, UnityEngine.Color.green, 2f);
		UnityEngine.Debug.DrawLine(vector, vector + Vector3.up, UnityEngine.Color.red, 2f);
	}
}
public class PhotonTransformViewPositionControl
{
	private PhotonTransformViewPositionModel m_Model;

	private float m_CurrentSpeed;

	private double m_LastSerializeTime;

	private Vector3 m_SynchronizedSpeed = Vector3.zero;

	private float m_SynchronizedTurnSpeed;

	private Vector3 m_NetworkPosition;

	private Queue<Vector3> m_OldNetworkPositions = new Queue<Vector3>();

	private bool m_UpdatedPositionAfterOnSerialize = true;

	public PhotonTransformViewPositionControl(PhotonTransformViewPositionModel model)
	{
		m_Model = model;
	}

	private Vector3 GetOldestStoredNetworkPosition()
	{
		Vector3 result = m_NetworkPosition;
		if (m_OldNetworkPositions.Count > 0)
		{
			result = m_OldNetworkPositions.Peek();
		}
		return result;
	}

	public void SetSynchronizedValues(Vector3 speed, float turnSpeed)
	{
		m_SynchronizedSpeed = speed;
		m_SynchronizedTurnSpeed = turnSpeed;
	}

	public Vector3 UpdatePosition(Vector3 currentPosition)
	{
		Vector3 vector = GetNetworkPosition() + GetExtrapolatedPositionOffset();
		switch (m_Model.InterpolateOption)
		{
		case PhotonTransformViewPositionModel.InterpolateOptions.Disabled:
			if (!m_UpdatedPositionAfterOnSerialize)
			{
				currentPosition = vector;
				m_UpdatedPositionAfterOnSerialize = true;
			}
			break;
		case PhotonTransformViewPositionModel.InterpolateOptions.FixedSpeed:
			currentPosition = Vector3.MoveTowards(currentPosition, vector, Time.deltaTime * m_Model.InterpolateMoveTowardsSpeed);
			break;
		case PhotonTransformViewPositionModel.InterpolateOptions.EstimatedSpeed:
			if (m_OldNetworkPositions.Count != 0)
			{
				float num = Vector3.Distance(m_NetworkPosition, GetOldestStoredNetworkPosition()) / (float)m_OldNetworkPositions.Count * (float)PhotonNetwork.sendRateOnSerialize;
				currentPosition = Vector3.MoveTowards(currentPosition, vector, Time.deltaTime * num);
			}
			break;
		case PhotonTransformViewPositionModel.InterpolateOptions.SynchronizeValues:
			currentPosition = ((m_SynchronizedSpeed.magnitude != 0f) ? Vector3.MoveTowards(currentPosition, vector, Time.deltaTime * m_SynchronizedSpeed.magnitude) : vector);
			break;
		case PhotonTransformViewPositionModel.InterpolateOptions.Lerp:
			currentPosition = Vector3.Lerp(currentPosition, vector, Time.deltaTime * m_Model.InterpolateLerpSpeed);
			break;
		}
		if (m_Model.TeleportEnabled && Vector3.Distance(currentPosition, GetNetworkPosition()) > m_Model.TeleportIfDistanceGreaterThan)
		{
			currentPosition = GetNetworkPosition();
		}
		return currentPosition;
	}

	public Vector3 GetNetworkPosition()
	{
		return m_NetworkPosition;
	}

	public Vector3 GetExtrapolatedPositionOffset()
	{
		float num = (float)(PhotonNetwork.time - m_LastSerializeTime);
		if (m_Model.ExtrapolateIncludingRoundTripTime)
		{
			num += (float)PhotonNetwork.GetPing() / 1000f;
		}
		Vector3 result = Vector3.zero;
		switch (m_Model.ExtrapolateOption)
		{
		case PhotonTransformViewPositionModel.ExtrapolateOptions.SynchronizeValues:
		{
			Quaternion quaternion = Quaternion.Euler(0f, m_SynchronizedTurnSpeed * num, 0f);
			result = quaternion * (m_SynchronizedSpeed * num);
			break;
		}
		case PhotonTransformViewPositionModel.ExtrapolateOptions.FixedSpeed:
		{
			Vector3 normalized = (m_NetworkPosition - GetOldestStoredNetworkPosition()).normalized;
			result = normalized * m_Model.ExtrapolateSpeed * num;
			break;
		}
		case PhotonTransformViewPositionModel.ExtrapolateOptions.EstimateSpeedAndTurn:
		{
			Vector3 vector = (m_NetworkPosition - GetOldestStoredNetworkPosition()) * PhotonNetwork.sendRateOnSerialize;
			result = vector * num;
			break;
		}
		}
		return result;
	}

	public void OnPhotonSerializeView(Vector3 currentPosition, PhotonStream stream, PhotonMessageInfo info)
	{
		if (m_Model.SynchronizeEnabled)
		{
			if (stream.isWriting)
			{
				SerializeData(currentPosition, stream, info);
			}
			else
			{
				DeserializeData(stream, info);
			}
			m_LastSerializeTime = PhotonNetwork.time;
			m_UpdatedPositionAfterOnSerialize = false;
		}
	}

	private void SerializeData(Vector3 currentPosition, PhotonStream stream, PhotonMessageInfo info)
	{
		stream.SendNext(currentPosition);
		m_NetworkPosition = currentPosition;
		if (m_Model.ExtrapolateOption == PhotonTransformViewPositionModel.ExtrapolateOptions.SynchronizeValues || m_Model.InterpolateOption == PhotonTransformViewPositionModel.InterpolateOptions.SynchronizeValues)
		{
			stream.SendNext(m_SynchronizedSpeed);
			stream.SendNext(m_SynchronizedTurnSpeed);
		}
	}

	private void DeserializeData(PhotonStream stream, PhotonMessageInfo info)
	{
		Vector3 networkPosition = (Vector3)stream.ReceiveNext();
		if (m_Model.ExtrapolateOption == PhotonTransformViewPositionModel.ExtrapolateOptions.SynchronizeValues || m_Model.InterpolateOption == PhotonTransformViewPositionModel.InterpolateOptions.SynchronizeValues)
		{
			m_SynchronizedSpeed = (Vector3)stream.ReceiveNext();
			m_SynchronizedTurnSpeed = (float)stream.ReceiveNext();
		}
		if (m_OldNetworkPositions.Count == 0)
		{
			m_NetworkPosition = networkPosition;
		}
		m_OldNetworkPositions.Enqueue(m_NetworkPosition);
		m_NetworkPosition = networkPosition;
		while (m_OldNetworkPositions.Count > m_Model.ExtrapolateNumberOfStoredPositions)
		{
			m_OldNetworkPositions.Dequeue();
		}
	}
}
[Serializable]
public class PhotonTransformViewPositionModel
{
	public enum InterpolateOptions
	{
		Disabled,
		FixedSpeed,
		EstimatedSpeed,
		SynchronizeValues,
		Lerp
	}

	public enum ExtrapolateOptions
	{
		Disabled,
		SynchronizeValues,
		EstimateSpeedAndTurn,
		FixedSpeed
	}

	public bool SynchronizeEnabled;

	public bool TeleportEnabled = true;

	public float TeleportIfDistanceGreaterThan = 3f;

	public InterpolateOptions InterpolateOption = InterpolateOptions.EstimatedSpeed;

	public float InterpolateMoveTowardsSpeed = 1f;

	public float InterpolateLerpSpeed = 1f;

	public float InterpolateMoveTowardsAcceleration = 2f;

	public float InterpolateMoveTowardsDeceleration = 2f;

	public AnimationCurve InterpolateSpeedCurve = new AnimationCurve(new Keyframe(-1f, 0f, 0f, float.PositiveInfinity), new Keyframe(0f, 1f, 0f, 0f), new Keyframe(1f, 1f, 0f, 1f), new Keyframe(4f, 4f, 1f, 0f));

	public ExtrapolateOptions ExtrapolateOption;

	public float ExtrapolateSpeed = 1f;

	public bool ExtrapolateIncludingRoundTripTime = true;

	public int ExtrapolateNumberOfStoredPositions = 1;

	public bool DrawErrorGizmo = true;
}
public class PhotonTransformViewRotationControl
{
	private PhotonTransformViewRotationModel m_Model;

	private Quaternion m_NetworkRotation;

	public PhotonTransformViewRotationControl(PhotonTransformViewRotationModel model)
	{
		m_Model = model;
	}

	public Quaternion GetNetworkRotation()
	{
		return m_NetworkRotation;
	}

	public Quaternion GetRotation(Quaternion currentRotation)
	{
		return m_Model.InterpolateOption switch
		{
			PhotonTransformViewRotationModel.InterpolateOptions.RotateTowards => Quaternion.RotateTowards(currentRotation, m_NetworkRotation, m_Model.InterpolateRotateTowardsSpeed * Time.deltaTime), 
			PhotonTransformViewRotationModel.InterpolateOptions.Lerp => Quaternion.Lerp(currentRotation, m_NetworkRotation, m_Model.InterpolateLerpSpeed * Time.deltaTime), 
			_ => m_NetworkRotation, 
		};
	}

	public void OnPhotonSerializeView(Quaternion currentRotation, PhotonStream stream, PhotonMessageInfo info)
	{
		if (m_Model.SynchronizeEnabled)
		{
			if (stream.isWriting)
			{
				stream.SendNext(currentRotation);
				m_NetworkRotation = currentRotation;
			}
			else
			{
				m_NetworkRotation = (Quaternion)stream.ReceiveNext();
			}
		}
	}
}
[Serializable]
public class PhotonTransformViewRotationModel
{
	public enum InterpolateOptions
	{
		Disabled,
		RotateTowards,
		Lerp
	}

	public bool SynchronizeEnabled;

	public InterpolateOptions InterpolateOption = InterpolateOptions.RotateTowards;

	public float InterpolateRotateTowardsSpeed = 180f;

	public float InterpolateLerpSpeed = 5f;
}
public class PhotonTransformViewScaleControl
{
	private PhotonTransformViewScaleModel m_Model;

	private Vector3 m_NetworkScale = Vector3.one;

	public PhotonTransformViewScaleControl(PhotonTransformViewScaleModel model)
	{
		m_Model = model;
	}

	public Vector3 GetNetworkScale()
	{
		return m_NetworkScale;
	}

	public Vector3 GetScale(Vector3 currentScale)
	{
		return m_Model.InterpolateOption switch
		{
			PhotonTransformViewScaleModel.InterpolateOptions.MoveTowards => Vector3.MoveTowards(currentScale, m_NetworkScale, m_Model.InterpolateMoveTowardsSpeed * Time.deltaTime), 
			PhotonTransformViewScaleModel.InterpolateOptions.Lerp => Vector3.Lerp(currentScale, m_NetworkScale, m_Model.InterpolateLerpSpeed * Time.deltaTime), 
			_ => m_NetworkScale, 
		};
	}

	public void OnPhotonSerializeView(Vector3 currentScale, PhotonStream stream, PhotonMessageInfo info)
	{
		if (m_Model.SynchronizeEnabled)
		{
			if (stream.isWriting)
			{
				stream.SendNext(currentScale);
				m_NetworkScale = currentScale;
			}
			else
			{
				m_NetworkScale = (Vector3)stream.ReceiveNext();
			}
		}
	}
}
[Serializable]
public class PhotonTransformViewScaleModel
{
	public enum InterpolateOptions
	{
		Disabled,
		MoveTowards,
		Lerp
	}

	public bool SynchronizeEnabled;

	public InterpolateOptions InterpolateOption;

	public float InterpolateMoveTowardsSpeed = 1f;

	public float InterpolateLerpSpeed;
}
public class ConnectAndJoinRandom : Photon.MonoBehaviour
{
	public bool AutoConnect = true;

	public byte Version = 1;

	private bool ConnectInUpdate = true;

	public virtual void Start()
	{
		PhotonNetwork.autoJoinLobby = false;
	}

	public virtual void Update()
	{
		if (ConnectInUpdate && AutoConnect && !PhotonNetwork.connected)
		{
			UnityEngine.Debug.Log("Update() was called by Unity. Scene is loaded. Let's connect to the Photon Master Server. Calling: PhotonNetwork.ConnectUsingSettings();");
			ConnectInUpdate = false;
			PhotonNetwork.ConnectUsingSettings(Version + "." + SceneManagerHelper.ActiveSceneBuildIndex);
		}
	}

	public virtual void OnConnectedToMaster()
	{
		UnityEngine.Debug.Log("OnConnectedToMaster() was called by PUN. Now this client is connected and could join a room. Calling: PhotonNetwork.JoinRandomRoom();");
		PhotonNetwork.JoinRandomRoom();
	}

	public virtual void OnJoinedLobby()
	{
		UnityEngine.Debug.Log("OnJoinedLobby(). This client is connected and does get a room-list, which gets stored as PhotonNetwork.GetRoomList(). This script now calls: PhotonNetwork.JoinRandomRoom();");
		PhotonNetwork.JoinRandomRoom();
	}

	public virtual void OnPhotonRandomJoinFailed()
	{
		UnityEngine.Debug.Log("OnPhotonRandomJoinFailed() was called by PUN. No random room available, so we create one. Calling: PhotonNetwork.CreateRoom(null, new RoomOptions() {maxPlayers = 4}, null);");
		PhotonNetwork.CreateRoom(null, new RoomOptions
		{
			MaxPlayers = 4
		}, null);
	}

	public virtual void OnFailedToConnectToPhoton(DisconnectCause cause)
	{
		UnityEngine.Debug.LogError("Cause: " + cause);
	}

	public void OnJoinedRoom()
	{
		UnityEngine.Debug.Log("OnJoinedRoom() called by PUN. Now this client is in a room. From here on, your game would be running. For reference, all callbacks are listed in enum: PhotonNetworkingMessage");
	}
}
[HelpURL("https://doc.photonengine.com/en-us/pun/current/manuals-and-demos/culling-demo")]
public class CullArea : UnityEngine.MonoBehaviour
{
	private const int MAX_NUMBER_OF_ALLOWED_CELLS = 250;

	public const int MAX_NUMBER_OF_SUBDIVISIONS = 3;

	public readonly byte FIRST_GROUP_ID = 1;

	public readonly int[] SUBDIVISION_FIRST_LEVEL_ORDER = new int[4] { 0, 1, 1, 1 };

	public readonly int[] SUBDIVISION_SECOND_LEVEL_ORDER = new int[8] { 0, 2, 1, 2, 0, 2, 1, 2 };

	public readonly int[] SUBDIVISION_THIRD_LEVEL_ORDER = new int[12]
	{
		0, 3, 2, 3, 1, 3, 2, 3, 1, 3,
		2, 3
	};

	public Vector2 Center;

	public Vector2 Size = new Vector2(25f, 25f);

	public Vector2[] Subdivisions = new Vector2[3];

	public int NumberOfSubdivisions;

	public bool YIsUpAxis;

	public bool RecreateCellHierarchy;

	private byte idCounter;

	public int CellCount { get; private set; }

	public CellTree CellTree { get; private set; }

	public Dictionary<int, GameObject> Map { get; private set; }

	private void Awake()
	{
		idCounter = FIRST_GROUP_ID;
		CreateCellHierarchy();
	}

	public void OnDrawGizmos()
	{
		idCounter = FIRST_GROUP_ID;
		if (RecreateCellHierarchy)
		{
			CreateCellHierarchy();
		}
		DrawCells();
	}

	private void CreateCellHierarchy()
	{
		if (!IsCellCountAllowed())
		{
			if (UnityEngine.Debug.isDebugBuild)
			{
				UnityEngine.Debug.LogError("There are too many cells created by your subdivision options. Maximum allowed number of cells is " + (250 - FIRST_GROUP_ID) + ". Current number of cells is " + CellCount + ".");
				return;
			}
			UnityEngine.Application.Quit();
		}
		CellTreeNode cellTreeNode = new CellTreeNode(idCounter++, CellTreeNode.ENodeType.Root, null);
		if (YIsUpAxis)
		{
			Center = new Vector2(base.transform.position.x, base.transform.position.y);
			Size = new Vector2(base.transform.localScale.x, base.transform.localScale.y);
			cellTreeNode.Center = new Vector3(Center.x, Center.y, 0f);
			cellTreeNode.Size = new Vector3(Size.x, Size.y, 0f);
			cellTreeNode.TopLeft = new Vector3(Center.x - Size.x / 2f, Center.y - Size.y / 2f, 0f);
			cellTreeNode.BottomRight = new Vector3(Center.x + Size.x / 2f, Center.y + Size.y / 2f, 0f);
		}
		else
		{
			Center = new Vector2(base.transform.position.x, base.transform.position.z);
			Size = new Vector2(base.transform.localScale.x, base.transform.localScale.z);
			cellTreeNode.Center = new Vector3(Center.x, 0f, Center.y);
			cellTreeNode.Size = new Vector3(Size.x, 0f, Size.y);
			cellTreeNode.TopLeft = new Vector3(Center.x - Size.x / 2f, 0f, Center.y - Size.y / 2f);
			cellTreeNode.BottomRight = new Vector3(Center.x + Size.x / 2f, 0f, Center.y + Size.y / 2f);
		}
		CreateChildCells(cellTreeNode, 1);
		CellTree = new CellTree(cellTreeNode);
		RecreateCellHierarchy = false;
	}

	private void CreateChildCells(CellTreeNode parent, int cellLevelInHierarchy)
	{
		if (cellLevelInHierarchy > NumberOfSubdivisions)
		{
			return;
		}
		int num = (int)Subdivisions[cellLevelInHierarchy - 1].x;
		int num2 = (int)Subdivisions[cellLevelInHierarchy - 1].y;
		float num3 = parent.Center.x - parent.Size.x / 2f;
		float num4 = parent.Size.x / (float)num;
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num2; j++)
			{
				float num5 = num3 + (float)i * num4 + num4 / 2f;
				CellTreeNode cellTreeNode = new CellTreeNode(idCounter++, (NumberOfSubdivisions != cellLevelInHierarchy) ? CellTreeNode.ENodeType.Node : CellTreeNode.ENodeType.Leaf, parent);
				if (YIsUpAxis)
				{
					float num6 = parent.Center.y - parent.Size.y / 2f;
					float num7 = parent.Size.y / (float)num2;
					float num8 = num6 + (float)j * num7 + num7 / 2f;
					cellTreeNode.Center = new Vector3(num5, num8, 0f);
					cellTreeNode.Size = new Vector3(num4, num7, 0f);
					cellTreeNode.TopLeft = new Vector3(num5 - num4 / 2f, num8 - num7 / 2f, 0f);
					cellTreeNode.BottomRight = new Vector3(num5 + num4 / 2f, num8 + num7 / 2f, 0f);
				}
				else
				{
					float num9 = parent.Center.z - parent.Size.z / 2f;
					float num10 = parent.Size.z / (float)num2;
					float num11 = num9 + (float)j * num10 + num10 / 2f;
					cellTreeNode.Center = new Vector3(num5, 0f, num11);
					cellTreeNode.Size = new Vector3(num4, 0f, num10);
					cellTreeNode.TopLeft = new Vector3(num5 - num4 / 2f, 0f, num11 - num10 / 2f);
					cellTreeNode.BottomRight = new Vector3(num5 + num4 / 2f, 0f, num11 + num10 / 2f);
				}
				parent.AddChild(cellTreeNode);
				CreateChildCells(cellTreeNode, cellLevelInHierarchy + 1);
			}
		}
	}

	private void DrawCells()
	{
		if (CellTree != null && CellTree.RootNode != null)
		{
			CellTree.RootNode.Draw();
		}
		else
		{
			RecreateCellHierarchy = true;
		}
	}

	private bool IsCellCountAllowed()
	{
		int num = 1;
		int num2 = 1;
		Vector2[] subdivisions = Subdivisions;
		for (int i = 0; i < subdivisions.Length; i++)
		{
			Vector2 vector = subdivisions[i];
			num *= (int)vector.x;
			num2 *= (int)vector.y;
		}
		CellCount = num * num2;
		return CellCount <= 250 - FIRST_GROUP_ID;
	}

	public List<byte> GetActiveCells(Vector3 position)
	{
		List<byte> list = new List<byte>(0);
		CellTree.RootNode.GetActiveCells(list, YIsUpAxis, position);
		return list;
	}
}
public class CellTree
{
	public CellTreeNode RootNode { get; private set; }

	public CellTree()
	{
	}

	public CellTree(CellTreeNode root)
	{
		RootNode = root;
	}
}
public class CellTreeNode
{
	public enum ENodeType
	{
		Root,
		Node,
		Leaf
	}

	public byte Id;

	public Vector3 Center;

	public Vector3 Size;

	public Vector3 TopLeft;

	public Vector3 BottomRight;

	public ENodeType NodeType;

	public CellTreeNode Parent;

	public List<CellTreeNode> Childs;

	private float maxDistance;

	public CellTreeNode()
	{
	}

	public CellTreeNode(byte id, ENodeType nodeType, CellTreeNode parent)
	{
		Id = id;
		NodeType = nodeType;
		Parent = parent;
	}

	public void AddChild(CellTreeNode child)
	{
		if (Childs == null)
		{
			Childs = new List<CellTreeNode>(1);
		}
		Childs.Add(child);
	}

	public void Draw()
	{
	}

	public void GetActiveCells(List<byte> activeCells, bool yIsUpAxis, Vector3 position)
	{
		if (NodeType != ENodeType.Leaf)
		{
			foreach (CellTreeNode child in Childs)
			{
				child.GetActiveCells(activeCells, yIsUpAxis, position);
			}
			return;
		}
		if (!IsPointNearCell(yIsUpAxis, position))
		{
			return;
		}
		if (IsPointInsideCell(yIsUpAxis, position))
		{
			activeCells.Insert(0, Id);
			for (CellTreeNode parent = Parent; parent != null; parent = parent.Parent)
			{
				activeCells.Insert(0, parent.Id);
			}
		}
		else
		{
			activeCells.Add(Id);
		}
	}

	public bool IsPointInsideCell(bool yIsUpAxis, Vector3 point)
	{
		if (point.x < TopLeft.x || point.x > BottomRight.x)
		{
			return false;
		}
		if (yIsUpAxis)
		{
			if (point.y >= TopLeft.y && point.y <= BottomRight.y)
			{
				return true;
			}
		}
		else if (point.z >= TopLeft.z && point.z <= BottomRight.z)
		{
			return true;
		}
		return false;
	}

	public bool IsPointNearCell(bool yIsUpAxis, Vector3 point)
	{
		if (maxDistance == 0f)
		{
			maxDistance = (Size.x + Size.y + Size.z) / 2f;
		}
		return (point - Center).sqrMagnitude <= maxDistance * maxDistance;
	}
}
[RequireComponent(typeof(PhotonView))]
public class InRoomChat : Photon.MonoBehaviour
{
	public Rect GuiRect = new Rect(0f, 0f, 250f, 300f);

	public bool IsVisible = true;

	public bool AlignBottom;

	public List<string> messages = new List<string>();

	private string inputLine = string.Empty;

	private Vector2 scrollPos = Vector2.zero;

	public static readonly string ChatRPC = "Chat";

	public void Start()
	{
		if (AlignBottom)
		{
			GuiRect.y = (float)Screen.height - GuiRect.height;
		}
	}

	public void OnGUI()
	{
		if (!IsVisible || !PhotonNetwork.inRoom)
		{
			return;
		}
		if (Event.current.type == EventType.KeyDown && (Event.current.keyCode == KeyCode.KeypadEnter || Event.current.keyCode == KeyCode.Return))
		{
			if (!string.IsNullOrEmpty(inputLine))
			{
				base.photonView.RPC("Chat", PhotonTargets.All, inputLine);
				inputLine = string.Empty;
				GUI.FocusControl(string.Empty);
				return;
			}
			GUI.FocusControl("ChatInput");
		}
		GUI.SetNextControlName(string.Empty);
		GUILayout.BeginArea(GuiRect);
		scrollPos = GUILayout.BeginScrollView(scrollPos);
		GUILayout.FlexibleSpace();
		for (int num = messages.Count - 1; num >= 0; num--)
		{
			GUILayout.Label(messages[num]);
		}
		GUILayout.EndScrollView();
		GUILayout.BeginHorizontal();
		GUI.SetNextControlName("ChatInput");
		inputLine = GUILayout.TextField(inputLine);
		if (GUILayout.Button("Send", GUILayout.ExpandWidth(expand: false)))
		{
			base.photonView.RPC("Chat", PhotonTargets.All, inputLine);
			inputLine = string.Empty;
			GUI.FocusControl(string.Empty);
		}
		GUILayout.EndHorizontal();
		GUILayout.EndArea();
	}

	[PunRPC]
	public void Chat(string newLine, PhotonMessageInfo mi)
	{
		string text = "anonymous";
		if (mi.sender != null)
		{
			text = (string.IsNullOrEmpty(mi.sender.NickName) ? ("player " + mi.sender.ID) : mi.sender.NickName);
		}
		messages.Add(text + ": " + newLine);
	}

	public void AddLine(string newLine)
	{
		messages.Add(newLine);
	}
}
public class InputToEvent : UnityEngine.MonoBehaviour
{
	private GameObject lastGo;

	public static Vector3 inputHitPos;

	public bool DetectPointedAtGameObject;

	private Vector2 pressedPosition = Vector2.zero;

	private Vector2 currentPos = Vector2.zero;

	public bool Dragging;

	private Camera m_Camera;

	public static GameObject goPointedAt { get; private set; }

	public Vector2 DragVector => (!Dragging) ? Vector2.zero : (currentPos - pressedPosition);

	private void Start()
	{
		m_Camera = GetComponent<Camera>();
	}

	private void Update()
	{
		if (DetectPointedAtGameObject)
		{
			goPointedAt = RaycastObject(Input.mousePosition);
		}
		if (Input.touchCount > 0)
		{
			Touch touch = Input.GetTouch(0);
			currentPos = touch.position;
			if (touch.phase == TouchPhase.Began)
			{
				Press(touch.position);
			}
			else if (touch.phase == TouchPhase.Ended)
			{
				Release(touch.position);
			}
			return;
		}
		currentPos = Input.mousePosition;
		if (Input.GetMouseButtonDown(0))
		{
			Press(Input.mousePosition);
		}
		if (Input.GetMouseButtonUp(0))
		{
			Release(Input.mousePosition);
		}
		if (Input.GetMouseButtonDown(1))
		{
			pressedPosition = Input.mousePosition;
			lastGo = RaycastObject(pressedPosition);
			if (lastGo != null)
			{
				lastGo.SendMessage("OnPressRight", SendMessageOptions.DontRequireReceiver);
			}
		}
	}

	private void Press(Vector2 screenPos)
	{
		pressedPosition = screenPos;
		Dragging = true;
		lastGo = RaycastObject(screenPos);
		if (lastGo != null)
		{
			lastGo.SendMessage("OnPress", SendMessageOptions.DontRequireReceiver);
		}
	}

	private void Release(Vector2 screenPos)
	{
		if (lastGo != null)
		{
			GameObject gameObject = RaycastObject(screenPos);
			if (gameObject == lastGo)
			{
				lastGo.SendMessage("OnClick", SendMessageOptions.DontRequireReceiver);
			}
			lastGo.SendMessage("OnRelease", SendMessageOptions.DontRequireReceiver);
			lastGo = null;
		}
		pressedPosition = Vector2.zero;
		Dragging = false;
	}

	private GameObject RaycastObject(Vector2 screenPos)
	{
		if (Physics.Raycast(m_Camera.ScreenPointToRay(screenPos), out var hitInfo, 200f))
		{
			inputHitPos = hitInfo.point;
			return hitInfo.collider.gameObject;
		}
		return null;
	}
}
[RequireComponent(typeof(PhotonView))]
public class ManualPhotonViewAllocator : UnityEngine.MonoBehaviour
{
	public GameObject Prefab;

	public void AllocateManualPhotonView()
	{
		PhotonView photonView = base.gameObject.GetPhotonView();
		if (photonView == null)
		{
			UnityEngine.Debug.LogError("Can't do manual instantiation without PhotonView component.");
			return;
		}
		int num = PhotonNetwork.AllocateViewID();
		photonView.RPC("InstantiateRpc", PhotonTargets.AllBuffered, num);
	}

	[PunRPC]
	public void InstantiateRpc(int viewID)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(Prefab, InputToEvent.inputHitPos + new Vector3(0f, 5f, 0f), Quaternion.identity);
		gameObject.GetPhotonView().viewID = viewID;
		OnClickDestroy component = gameObject.GetComponent<OnClickDestroy>();
		component.DestroyByRpc = true;
	}
}
[RequireComponent(typeof(PhotonView))]
public class MoveByKeys : Photon.MonoBehaviour
{
	public float Speed = 10f;

	public float JumpForce = 200f;

	public float JumpTimeout = 0.5f;

	private bool isSprite;

	private float jumpingTime;

	private Rigidbody body;

	private Rigidbody2D body2d;

	public void Start()
	{
		isSprite = GetComponent<SpriteRenderer>() != null;
		body2d = GetComponent<Rigidbody2D>();
		body = GetComponent<Rigidbody>();
	}

	public void FixedUpdate()
	{
		if (!base.photonView.isMine)
		{
			return;
		}
		if (Input.GetAxisRaw("Horizontal") < -0.1f || Input.GetAxisRaw("Horizontal") > 0.1f)
		{
			base.transform.position += Vector3.right * (Speed * Time.deltaTime) * Input.GetAxisRaw("Horizontal");
		}
		if (jumpingTime <= 0f)
		{
			if ((body != null || body2d != null) && Input.GetKey(KeyCode.Space))
			{
				jumpingTime = JumpTimeout;
				Vector2 vector = Vector2.up * JumpForce;
				if (body2d != null)
				{
					body2d.AddForce(vector);
				}
				else if (body != null)
				{
					body.AddForce(vector);
				}
			}
		}
		else
		{
			jumpingTime -= Time.deltaTime;
		}
		if (!isSprite && (Input.GetAxisRaw("Vertical") < -0.1f || Input.GetAxisRaw("Vertical") > 0.1f))
		{
			base.transform.position += Vector3.forward * (Speed * Time.deltaTime) * Input.GetAxisRaw("Vertical");
		}
	}
}
[RequireComponent(typeof(PhotonView))]
public class NetworkCullingHandler : UnityEngine.MonoBehaviour, IPunObservable
{
	private int orderIndex;

	private CullArea cullArea;

	private List<byte> previousActiveCells;

	private List<byte> activeCells;

	private PhotonView pView;

	private Vector3 lastPosition;

	private Vector3 currentPosition;

	private void OnEnable()
	{
		if (pView == null)
		{
			pView = GetComponent<PhotonView>();
			if (!pView.isMine)
			{
				return;
			}
		}
		if (cullArea == null)
		{
			cullArea = UnityEngine.Object.FindObjectOfType<CullArea>();
		}
		previousActiveCells = new List<byte>(0);
		activeCells = new List<byte>(0);
		currentPosition = (lastPosition = base.transform.position);
	}

	private void Start()
	{
		if (pView.isMine && PhotonNetwork.inRoom)
		{
			if (cullArea.NumberOfSubdivisions == 0)
			{
				pView.group = cullArea.FIRST_GROUP_ID;
				PhotonNetwork.SetInterestGroups(cullArea.FIRST_GROUP_ID, enabled: true);
			}
			else
			{
				pView.ObservedComponents.Add(this);
			}
		}
	}

	private void Update()
	{
		if (pView.isMine)
		{
			lastPosition = currentPosition;
			currentPosition = base.transform.position;
			if (currentPosition != lastPosition && HaveActiveCellsChanged())
			{
				UpdateInterestGroups();
			}
		}
	}

	private void OnGUI()
	{
		if (!pView.isMine)
		{
			return;
		}
		string text = "Inside cells:\n";
		string text2 = "Subscribed cells:\n";
		for (int i = 0; i < activeCells.Count; i++)
		{
			if (i <= cullArea.NumberOfSubdivisions)
			{
				text = text + activeCells[i] + " | ";
			}
			text2 = text2 + activeCells[i] + " | ";
		}
		GUI.Label(new Rect(20f, (float)Screen.height - 120f, 200f, 40f), "<color=white>PhotonView Group: " + pView.group + "</color>", new GUIStyle
		{
			alignment = TextAnchor.UpperLeft,
			fontSize = 16
		});
		GUI.Label(new Rect(20f, (float)Screen.height - 100f, 200f, 40f), "<color=white>" + text + "</color>", new GUIStyle
		{
			alignment = TextAnchor.UpperLeft,
			fontSize = 16
		});
		GUI.Label(new Rect(20f, (float)Screen.height - 60f, 200f, 40f), "<color=white>" + text2 + "</color>", new GUIStyle
		{
			alignment = TextAnchor.UpperLeft,
			fontSize = 16
		});
	}

	private bool HaveActiveCellsChanged()
	{
		if (cullArea.NumberOfSubdivisions == 0)
		{
			return false;
		}
		previousActiveCells = new List<byte>(activeCells);
		activeCells = cullArea.GetActiveCells(base.transform.position);
		while (activeCells.Count <= cullArea.NumberOfSubdivisions)
		{
			activeCells.Add(cullArea.FIRST_GROUP_ID);
		}
		if (activeCells.Count != previousActiveCells.Count)
		{
			return true;
		}
		if (activeCells[cullArea.NumberOfSubdivisions] != previousActiveCells[cullArea.NumberOfSubdivisions])
		{
			return true;
		}
		return false;
	}

	private void UpdateInterestGroups()
	{
		List<byte> list = new List<byte>(0);
		foreach (byte previousActiveCell in previousActiveCells)
		{
			if (!activeCells.Contains(previousActiveCell))
			{
				list.Add(previousActiveCell);
			}
		}
		PhotonNetwork.SetInterestGroups(list.ToArray(), activeCells.ToArray());
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		while (activeCells.Count <= cullArea.NumberOfSubdivisions)
		{
			activeCells.Add(cullArea.FIRST_GROUP_ID);
		}
		if (cullArea.NumberOfSubdivisions == 1)
		{
			orderIndex = ++orderIndex % cullArea.SUBDIVISION_FIRST_LEVEL_ORDER.Length;
			pView.group = activeCells[cullArea.SUBDIVISION_FIRST_LEVEL_ORDER[orderIndex]];
		}
		else if (cullArea.NumberOfSubdivisions == 2)
		{
			orderIndex = ++orderIndex % cullArea.SUBDIVISION_SECOND_LEVEL_ORDER.Length;
			pView.group = activeCells[cullArea.SUBDIVISION_SECOND_LEVEL_ORDER[orderIndex]];
		}
		else if (cullArea.NumberOfSubdivisions == 3)
		{
			orderIndex = ++orderIndex % cullArea.SUBDIVISION_THIRD_LEVEL_ORDER.Length;
			pView.group = activeCells[cullArea.SUBDIVISION_THIRD_LEVEL_ORDER[orderIndex]];
		}
	}
}
[RequireComponent(typeof(PhotonView))]
public class OnClickDestroy : Photon.MonoBehaviour
{
	public bool DestroyByRpc;

	public void OnClick()
	{
		if (!DestroyByRpc)
		{
			PhotonNetwork.Destroy(base.gameObject);
		}
		else
		{
			base.photonView.RPC("DestroyRpc", PhotonTargets.AllBuffered);
		}
	}

	[PunRPC]
	public IEnumerator DestroyRpc()
	{
		UnityEngine.Object.Destroy(base.gameObject);
		yield return 0;
		PhotonNetwork.UnAllocateViewID(base.photonView.viewID);
	}
}
public class OnClickInstantiate : UnityEngine.MonoBehaviour
{
	public GameObject Prefab;

	public int InstantiateType;

	private string[] InstantiateTypeNames = new string[2] { "Mine", "Scene" };

	public bool showGui;

	private void OnClick()
	{
		if (PhotonNetwork.inRoom)
		{
			switch (InstantiateType)
			{
			case 0:
				PhotonNetwork.Instantiate(Prefab.name, InputToEvent.inputHitPos + new Vector3(0f, 5f, 0f), Quaternion.identity, 0);
				break;
			case 1:
				PhotonNetwork.InstantiateSceneObject(Prefab.name, InputToEvent.inputHitPos + new Vector3(0f, 5f, 0f), Quaternion.identity, 0, null);
				break;
			}
		}
	}

	private void OnGUI()
	{
		if (showGui)
		{
			GUILayout.BeginArea(new Rect(Screen.width - 180, 0f, 180f, 50f));
			InstantiateType = GUILayout.Toolbar(InstantiateType, InstantiateTypeNames);
			GUILayout.EndArea();
		}
	}
}
public class OnJoinedInstantiate : UnityEngine.MonoBehaviour
{
	public Transform SpawnPosition;

	public float PositionOffset = 2f;

	public GameObject[] PrefabsToInstantiate;

	public void OnJoinedRoom()
	{
		if (PrefabsToInstantiate == null)
		{
			return;
		}
		GameObject[] prefabsToInstantiate = PrefabsToInstantiate;
		foreach (GameObject gameObject in prefabsToInstantiate)
		{
			UnityEngine.Debug.Log("Instantiating: " + gameObject.name);
			Vector3 vector = Vector3.up;
			if (SpawnPosition != null)
			{
				vector = SpawnPosition.position;
			}
			Vector3 insideUnitSphere = UnityEngine.Random.insideUnitSphere;
			insideUnitSphere.y = 0f;
			insideUnitSphere = insideUnitSphere.normalized;
			Vector3 position = vector + PositionOffset * insideUnitSphere;
			PhotonNetwork.Instantiate(gameObject.name, position, Quaternion.identity, 0);
		}
	}
}
public class OnStartDelete : UnityEngine.MonoBehaviour
{
	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
namespace ExitGames.UtilityScripts
{
	public class PlayerRoomIndexing : PunBehaviour
	{
		public delegate void RoomIndexingChanged();

		public static PlayerRoomIndexing instance;

		public RoomIndexingChanged OnRoomIndexingChanged;

		public const string RoomPlayerIndexedProp = "PlayerIndexes";

		private int[] _playerIds;

		private object _indexes;

		private Dictionary<int, int> _indexesLUT;

		private List<bool> _indexesPool;

		private PhotonPlayer _p;

		public int[] PlayerIds => _playerIds;

		public void Awake()
		{
			if (instance != null)
			{
				UnityEngine.Debug.LogError("Existing instance of PlayerRoomIndexing found. Only One instance is required at the most. Please correct and have only one at any time.");
			}
			instance = this;
			if (PhotonNetwork.room != null)
			{
				SanitizeIndexing(forceIndexing: true);
			}
		}

		public override void OnJoinedRoom()
		{
			if (PhotonNetwork.isMasterClient)
			{
				AssignIndex(PhotonNetwork.player);
			}
			else
			{
				RefreshData();
			}
		}

		public override void OnLeftRoom()
		{
			RefreshData();
		}

		public override void OnPhotonPlayerConnected(PhotonPlayer newPlayer)
		{
			if (PhotonNetwork.isMasterClient)
			{
				AssignIndex(newPlayer);
			}
		}

		public override void OnPhotonPlayerDisconnected(PhotonPlayer otherPlayer)
		{
			if (PhotonNetwork.isMasterClient)
			{
				UnAssignIndex(otherPlayer);
			}
		}

		public override void OnPhotonCustomRoomPropertiesChanged(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
			if (propertiesThatChanged.ContainsKey("PlayerIndexes"))
			{
				RefreshData();
			}
		}

		public override void OnMasterClientSwitched(PhotonPlayer newMasterClient)
		{
			if (PhotonNetwork.isMasterClient)
			{
				SanitizeIndexing();
			}
		}

		public int GetRoomIndex(PhotonPlayer player)
		{
			if (_indexesLUT != null && _indexesLUT.ContainsKey(player.ID))
			{
				return _indexesLUT[player.ID];
			}
			return -1;
		}

		private void SanitizeIndexing(bool forceIndexing = false)
		{
			if ((!forceIndexing && !PhotonNetwork.isMasterClient) || PhotonNetwork.room == null)
			{
				return;
			}
			Dictionary<int, int> dictionary = new Dictionary<int, int>();
			if (PhotonNetwork.room.CustomProperties.TryGetValue("PlayerIndexes", out _indexes))
			{
				dictionary = _indexes as Dictionary<int, int>;
			}
			if (dictionary.Count == PhotonNetwork.room.PlayerCount)
			{
				return;
			}
			PhotonPlayer[] playerList = PhotonNetwork.playerList;
			foreach (PhotonPlayer photonPlayer in playerList)
			{
				if (!dictionary.ContainsKey(photonPlayer.ID))
				{
					AssignIndex(photonPlayer);
				}
			}
		}

		private void RefreshData()
		{
			if (PhotonNetwork.room != null)
			{
				_playerIds = new int[PhotonNetwork.room.MaxPlayers];
				if (PhotonNetwork.room.CustomProperties.TryGetValue("PlayerIndexes", out _indexes))
				{
					_indexesLUT = _indexes as Dictionary<int, int>;
					foreach (KeyValuePair<int, int> item in _indexesLUT)
					{
						_p = PhotonPlayer.Find(item.Key);
						_playerIds[item.Value] = _p.ID;
					}
				}
			}
			else
			{
				_playerIds = new int[0];
			}
			if (OnRoomIndexingChanged != null)
			{
				OnRoomIndexingChanged();
			}
		}

		private void AssignIndex(PhotonPlayer player)
		{
			if (PhotonNetwork.room.CustomProperties.TryGetValue("PlayerIndexes", out _indexes))
			{
				_indexesLUT = _indexes as Dictionary<int, int>;
			}
			else
			{
				_indexesLUT = new Dictionary<int, int>();
			}
			List<bool> list = new List<bool>(new bool[PhotonNetwork.room.MaxPlayers]);
			foreach (KeyValuePair<int, int> item in _indexesLUT)
			{
				list[item.Value] = true;
			}
			_indexesLUT[player.ID] = Mathf.Max(0, list.IndexOf(item: false));
			PhotonNetwork.room.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { "PlayerIndexes", _indexesLUT } });
			RefreshData();
		}

		private void UnAssignIndex(PhotonPlayer player)
		{
			if (PhotonNetwork.room.CustomProperties.TryGetValue("PlayerIndexes", out _indexes))
			{
				_indexesLUT = _indexes as Dictionary<int, int>;
				_indexesLUT.Remove(player.ID);
				PhotonNetwork.room.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { { "PlayerIndexes", _indexesLUT } });
			}
			RefreshData();
		}
	}
	public static class PlayerRoomIndexingExtensions
	{
		public static int GetRoomIndex(this PhotonPlayer player)
		{
			if (PlayerRoomIndexing.instance == null)
			{
				UnityEngine.Debug.LogError("Missing PlayerRoomIndexing Component in Scene");
				return -1;
			}
			return PlayerRoomIndexing.instance.GetRoomIndex(player);
		}
	}
}
[RequireComponent(typeof(PhotonView))]
public class PickupItem : Photon.MonoBehaviour, IPunObservable
{
	public float SecondsBeforeRespawn = 2f;

	public bool PickupOnTrigger;

	public bool PickupIsMine;

	public UnityEngine.MonoBehaviour OnPickedUpCall;

	public bool SentPickup;

	public double TimeOfRespawn;

	public static HashSet<PickupItem> DisabledPickupItems = new HashSet<PickupItem>();

	public int ViewID => base.photonView.viewID;

	public void OnTriggerEnter(Collider other)
	{
		PhotonView component = other.GetComponent<PhotonView>();
		if (PickupOnTrigger && component != null && component.isMine)
		{
			Pickup();
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.isWriting && SecondsBeforeRespawn <= 0f)
		{
			stream.SendNext(base.gameObject.transform.position);
			return;
		}
		Vector3 position = (Vector3)stream.ReceiveNext();
		base.gameObject.transform.position = position;
	}

	public void Pickup()
	{
		if (!SentPickup)
		{
			SentPickup = true;
			base.photonView.RPC("PunPickup", PhotonTargets.AllViaServer);
		}
	}

	public void Drop()
	{
		if (PickupIsMine)
		{
			base.photonView.RPC("PunRespawn", PhotonTargets.AllViaServer);
		}
	}

	public void Drop(Vector3 newPosition)
	{
		if (PickupIsMine)
		{
			base.photonView.RPC("PunRespawn", PhotonTargets.AllViaServer, newPosition);
		}
	}

	[PunRPC]
	public void PunPickup(PhotonMessageInfo msgInfo)
	{
		if (msgInfo.sender.IsLocal)
		{
			SentPickup = false;
		}
		if (!base.gameObject.GetActive())
		{
			UnityEngine.Debug.Log(string.Concat("Ignored PU RPC, cause item is inactive. ", base.gameObject, " SecondsBeforeRespawn: ", SecondsBeforeRespawn, " TimeOfRespawn: ", TimeOfRespawn, " respawn in future: ", TimeOfRespawn > PhotonNetwork.time));
			return;
		}
		PickupIsMine = msgInfo.sender.IsLocal;
		if (OnPickedUpCall != null)
		{
			OnPickedUpCall.SendMessage("OnPickedUp", this);
		}
		if (SecondsBeforeRespawn <= 0f)
		{
			PickedUp(0f);
			return;
		}
		double num = PhotonNetwork.time - msgInfo.timestamp;
		double num2 = (double)SecondsBeforeRespawn - num;
		if (num2 > 0.0)
		{
			PickedUp((float)num2);
		}
	}

	internal void PickedUp(float timeUntilRespawn)
	{
		base.gameObject.SetActive(value: false);
		DisabledPickupItems.Add(this);
		TimeOfRespawn = 0.0;
		if (timeUntilRespawn > 0f)
		{
			TimeOfRespawn = PhotonNetwork.time + (double)timeUntilRespawn;
			Invoke("PunRespawn", timeUntilRespawn);
		}
	}

	[PunRPC]
	internal void PunRespawn(Vector3 pos)
	{
		UnityEngine.Debug.Log("PunRespawn with Position.");
		PunRespawn();
		base.gameObject.transform.position = pos;
	}

	[PunRPC]
	internal void PunRespawn()
	{
		DisabledPickupItems.Remove(this);
		TimeOfRespawn = 0.0;
		PickupIsMine = false;
		if (base.gameObject != null)
		{
			base.gameObject.SetActive(value: true);
		}
	}
}
[RequireComponent(typeof(PhotonView))]
public class PickupItemSimple : Photon.MonoBehaviour
{
	public float SecondsBeforeRespawn = 2f;

	public bool PickupOnCollide;

	public bool SentPickup;

	public void OnTriggerEnter(Collider other)
	{
		PhotonView component = other.GetComponent<PhotonView>();
		if (PickupOnCollide && component != null && component.isMine)
		{
			Pickup();
		}
	}

	public void Pickup()
	{
		if (!SentPickup)
		{
			SentPickup = true;
			base.photonView.RPC("PunPickupSimple", PhotonTargets.AllViaServer);
		}
	}

	[PunRPC]
	public void PunPickupSimple(PhotonMessageInfo msgInfo)
	{
		if (!SentPickup || !msgInfo.sender.IsLocal || base.gameObject.GetActive())
		{
		}
		SentPickup = false;
		if (!base.gameObject.GetActive())
		{
			UnityEngine.Debug.Log("Ignored PU RPC, cause item is inactive. " + base.gameObject);
			return;
		}
		double num = PhotonNetwork.time - msgInfo.timestamp;
		float num2 = SecondsBeforeRespawn - (float)num;
		if (num2 > 0f)
		{
			base.gameObject.SetActive(value: false);
			Invoke("RespawnAfter", num2);
		}
	}

	public void RespawnAfter()
	{
		if (base.gameObject != null)
		{
			base.gameObject.SetActive(value: true);
		}
	}
}
[RequireComponent(typeof(PhotonView))]
public class PickupItemSyncer : Photon.MonoBehaviour
{
	public bool IsWaitingForPickupInit;

	private const float TimeDeltaToIgnore = 0.2f;

	public void OnPhotonPlayerConnected(PhotonPlayer newPlayer)
	{
		if (PhotonNetwork.isMasterClient)
		{
			SendPickedUpItems(newPlayer);
		}
	}

	public void OnJoinedRoom()
	{
		UnityEngine.Debug.Log("Joined Room. isMasterClient: " + PhotonNetwork.isMasterClient + " id: " + PhotonNetwork.player.ID);
		IsWaitingForPickupInit = !PhotonNetwork.isMasterClient;
		if (PhotonNetwork.playerList.Length >= 2)
		{
			Invoke("AskForPickupItemSpawnTimes", 2f);
		}
	}

	public void AskForPickupItemSpawnTimes()
	{
		if (!IsWaitingForPickupInit)
		{
			return;
		}
		if (PhotonNetwork.playerList.Length < 2)
		{
			UnityEngine.Debug.Log("Cant ask anyone else for PickupItem spawn times.");
			IsWaitingForPickupInit = false;
			return;
		}
		PhotonPlayer next = PhotonNetwork.masterClient.GetNext();
		if (next == null || next.Equals(PhotonNetwork.player))
		{
			next = PhotonNetwork.player.GetNext();
		}
		if (next != null && !next.Equals(PhotonNetwork.player))
		{
			base.photonView.RPC("RequestForPickupItems", next);
			return;
		}
		UnityEngine.Debug.Log("No player left to ask");
		IsWaitingForPickupInit = false;
	}

	[PunRPC]
	[Obsolete("Use RequestForPickupItems(PhotonMessageInfo msgInfo) with corrected typing instead.")]
	public void RequestForPickupTimes(PhotonMessageInfo msgInfo)
	{
		RequestForPickupItems(msgInfo);
	}

	[PunRPC]
	public void RequestForPickupItems(PhotonMessageInfo msgInfo)
	{
		if (msgInfo.sender == null)
		{
			UnityEngine.Debug.LogError("Unknown player asked for PickupItems");
		}
		else
		{
			SendPickedUpItems(msgInfo.sender);
		}
	}

	private void SendPickedUpItems(PhotonPlayer targetPlayer)
	{
		if (targetPlayer == null)
		{
			UnityEngine.Debug.LogWarning("Cant send PickupItem spawn times to unknown targetPlayer.");
			return;
		}
		double time = PhotonNetwork.time;
		double num = time + 0.20000000298023224;
		PickupItem[] array = new PickupItem[PickupItem.DisabledPickupItems.Count];
		PickupItem.DisabledPickupItems.CopyTo(array);
		List<float> list = new List<float>(array.Length * 2);
		foreach (PickupItem pickupItem in array)
		{
			if (pickupItem.SecondsBeforeRespawn <= 0f)
			{
				list.Add(pickupItem.ViewID);
				list.Add(0f);
				continue;
			}
			double num2 = pickupItem.TimeOfRespawn - PhotonNetwork.time;
			if (pickupItem.TimeOfRespawn > num)
			{
				UnityEngine.Debug.Log(pickupItem.ViewID + " respawn: " + pickupItem.TimeOfRespawn + " timeUntilRespawn: " + num2 + " (now: " + PhotonNetwork.time + ")");
				list.Add(pickupItem.ViewID);
				list.Add((float)num2);
			}
		}
		UnityEngine.Debug.Log("Sent count: " + list.Count + " now: " + time);
		base.photonView.RPC("PickupItemInit", targetPlayer, PhotonNetwork.time, list.ToArray());
	}

	[PunRPC]
	public void PickupItemInit(double timeBase, float[] inactivePickupsAndTimes)
	{
		IsWaitingForPickupInit = false;
		for (int i = 0; i < inactivePickupsAndTimes.Length / 2; i++)
		{
			int num = i * 2;
			int viewID = (int)inactivePickupsAndTimes[num];
			float num2 = inactivePickupsAndTimes[num + 1];
			PhotonView photonView = PhotonView.Find(viewID);
			PickupItem component = photonView.GetComponent<PickupItem>();
			if (num2 <= 0f)
			{
				component.PickedUp(0f);
				continue;
			}
			double num3 = (double)num2 + timeBase;
			UnityEngine.Debug.Log(photonView.viewID + " respawn: " + num3 + " timeUntilRespawnBasedOnTimeBase:" + num2 + " SecondsBeforeRespawn: " + component.SecondsBeforeRespawn);
			double num4 = num3 - PhotonNetwork.time;
			if (num2 <= 0f)
			{
				num4 = 0.0;
			}
			component.PickedUp((float)num4);
		}
	}
}
[RequireComponent(typeof(InputToEvent))]
public class PointedAtGameObjectInfo : UnityEngine.MonoBehaviour
{
	private void OnGUI()
	{
		if (InputToEvent.goPointedAt != null)
		{
			PhotonView photonView = InputToEvent.goPointedAt.GetPhotonView();
			if (photonView != null)
			{
				GUI.Label(new Rect(Input.mousePosition.x + 5f, (float)Screen.height - Input.mousePosition.y - 15f, 300f, 30f), string.Format("ViewID {0} {1}{2}", photonView.viewID, (!photonView.isSceneView) ? string.Empty : "scene ", (!photonView.isMine) ? ("owner: " + photonView.ownerId) : "mine"));
			}
		}
	}
}
public class PunPlayerScores : UnityEngine.MonoBehaviour
{
	public const string PlayerScoreProp = "score";
}
public static class ScoreExtensions
{
	public static void SetScore(this PhotonPlayer player, int newScore)
	{
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable["score"] = newScore;
		player.SetCustomProperties(hashtable);
	}

	public static void AddScore(this PhotonPlayer player, int scoreToAddToCurrent)
	{
		int score = player.GetScore();
		score += scoreToAddToCurrent;
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable["score"] = score;
		player.SetCustomProperties(hashtable);
	}

	public static int GetScore(this PhotonPlayer player)
	{
		if (player.CustomProperties.TryGetValue("score", out var value))
		{
			return (int)value;
		}
		return 0;
	}
}
public class PunTeams : UnityEngine.MonoBehaviour
{
	public enum Team : byte
	{
		none,
		red,
		blue
	}

	public static Dictionary<Team, List<PhotonPlayer>> PlayersPerTeam;

	public const string TeamPlayerProp = "team";

	public void Start()
	{
		PlayersPerTeam = new Dictionary<Team, List<PhotonPlayer>>();
		Array values = Enum.GetValues(typeof(Team));
		foreach (object item in values)
		{
			PlayersPerTeam[(Team)item] = new List<PhotonPlayer>();
		}
	}

	public void OnDisable()
	{
		PlayersPerTeam = new Dictionary<Team, List<PhotonPlayer>>();
	}

	public void OnJoinedRoom()
	{
		UpdateTeams();
	}

	public void OnLeftRoom()
	{
		Start();
	}

	public void OnPhotonPlayerPropertiesChanged(object[] playerAndUpdatedProps)
	{
		UpdateTeams();
	}

	public void OnPhotonPlayerDisconnected(PhotonPlayer otherPlayer)
	{
		UpdateTeams();
	}

	public void OnPhotonPlayerConnected(PhotonPlayer newPlayer)
	{
		UpdateTeams();
	}

	public void UpdateTeams()
	{
		Array values = Enum.GetValues(typeof(Team));
		foreach (object item in values)
		{
			PlayersPerTeam[(Team)item].Clear();
		}
		for (int i = 0; i < PhotonNetwork.playerList.Length; i++)
		{
			PhotonPlayer photonPlayer = PhotonNetwork.playerList[i];
			Team team = photonPlayer.GetTeam();
			PlayersPerTeam[team].Add(photonPlayer);
		}
	}
}
public static class TeamExtensions
{
	public static PunTeams.Team GetTeam(this PhotonPlayer player)
	{
		if (player.CustomProperties.TryGetValue("team", out var value))
		{
			return (PunTeams.Team)value;
		}
		return PunTeams.Team.none;
	}

	public static void SetTeam(this PhotonPlayer player, PunTeams.Team team)
	{
		if (!PhotonNetwork.connectedAndReady)
		{
			UnityEngine.Debug.LogWarning(string.Concat("JoinTeam was called in state: ", PhotonNetwork.connectionStateDetailed, ". Not connectedAndReady."));
			return;
		}
		PunTeams.Team team2 = player.GetTeam();
		if (team2 != team)
		{
			player.SetCustomProperties(new ExitGames.Client.Photon.Hashtable { 
			{
				"team",
				(byte)team
			} });
		}
	}
}
public class PunTurnManager : PunBehaviour
{
	public float TurnDuration = 20f;

	public IPunTurnManagerCallbacks TurnManagerListener;

	private readonly HashSet<PhotonPlayer> finishedPlayers = new HashSet<PhotonPlayer>();

	public const byte TurnManagerEventOffset = 0;

	public const byte EvMove = 1;

	public const byte EvFinalMove = 2;

	private bool _isOverCallProcessed;

	public int Turn
	{
		get
		{
			return PhotonNetwork.room.GetTurn();
		}
		private set
		{
			_isOverCallProcessed = false;
			PhotonNetwork.room.SetTurn(value, setStartTime: true);
		}
	}

	public float ElapsedTimeInTurn => (float)(PhotonNetwork.ServerTimestamp - PhotonNetwork.room.GetTurnStart()) / 1000f;

	public float RemainingSecondsInTurn => Mathf.Max(0f, TurnDuration - ElapsedTimeInTurn);

	public bool IsCompletedByAll => PhotonNetwork.room != null && Turn > 0 && finishedPlayers.Count == PhotonNetwork.room.PlayerCount;

	public bool IsFinishedByMe => finishedPlayers.Contains(PhotonNetwork.player);

	public bool IsOver => RemainingSecondsInTurn <= 0f;

	private void Start()
	{
		PhotonNetwork.OnEventCall = OnEvent;
	}

	private void Update()
	{
		if (Turn > 0 && IsOver && !_isOverCallProcessed)
		{
			_isOverCallProcessed = true;
			TurnManagerListener.OnTurnTimeEnds(Turn);
		}
	}

	public void BeginTurn()
	{
		Turn++;
	}

	public void SendMove(object move, bool finished)
	{
		if (IsFinishedByMe)
		{
			UnityEngine.Debug.LogWarning("Can't SendMove. Turn is finished by this player.");
			return;
		}
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable.Add("turn", Turn);
		hashtable.Add("move", move);
		byte eventCode = (byte)((!finished) ? 1 : 2);
		PhotonNetwork.RaiseEvent(eventCode, hashtable, sendReliable: true, new RaiseEventOptions
		{
			CachingOption = EventCaching.AddToRoomCache
		});
		if (finished)
		{
			PhotonNetwork.player.SetFinishedTurn(Turn);
		}
		OnEvent(eventCode, hashtable, PhotonNetwork.player.ID);
	}

	public bool GetPlayerFinishedTurn(PhotonPlayer player)
	{
		if (player != null && finishedPlayers != null && finishedPlayers.Contains(player))
		{
			return true;
		}
		return false;
	}

	public void OnEvent(byte eventCode, object content, int senderId)
	{
		PhotonPlayer photonPlayer = PhotonPlayer.Find(senderId);
		switch (eventCode)
		{
		case 1:
		{
			ExitGames.Client.Photon.Hashtable hashtable2 = content as ExitGames.Client.Photon.Hashtable;
			int turn = (int)hashtable2["turn"];
			object move2 = hashtable2["move"];
			TurnManagerListener.OnPlayerMove(photonPlayer, turn, move2);
			break;
		}
		case 2:
		{
			ExitGames.Client.Photon.Hashtable hashtable = content as ExitGames.Client.Photon.Hashtable;
			int num = (int)hashtable["turn"];
			object move = hashtable["move"];
			if (num == Turn)
			{
				finishedPlayers.Add(photonPlayer);
				TurnManagerListener.OnPlayerFinished(photonPlayer, num, move);
			}
			if (IsCompletedByAll)
			{
				TurnManagerListener.OnTurnCompleted(Turn);
			}
			break;
		}
		}
	}

	public override void OnPhotonCustomRoomPropertiesChanged(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
	{
		if (propertiesThatChanged.ContainsKey("Turn"))
		{
			_isOverCallProcessed = false;
			finishedPlayers.Clear();
			TurnManagerListener.OnTurnBegins(Turn);
		}
	}
}
public interface IPunTurnManagerCallbacks
{
	void OnTurnBegins(int turn);

	void OnTurnCompleted(int turn);

	void OnPlayerMove(PhotonPlayer player, int turn, object move);

	void OnPlayerFinished(PhotonPlayer player, int turn, object move);

	void OnTurnTimeEnds(int turn);
}
public static class TurnExtensions
{
	public static readonly string TurnPropKey = "Turn";

	public static readonly string TurnStartPropKey = "TStart";

	public static readonly string FinishedTurnPropKey = "FToA";

	public static void SetTurn(this Room room, int turn, bool setStartTime = false)
	{
		if (room != null && room.CustomProperties != null)
		{
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable[TurnPropKey] = turn;
			if (setStartTime)
			{
				hashtable[TurnStartPropKey] = PhotonNetwork.ServerTimestamp;
			}
			room.SetCustomProperties(hashtable);
		}
	}

	public static int GetTurn(this RoomInfo room)
	{
		if (room == null || room.CustomProperties == null || !room.CustomProperties.ContainsKey(TurnPropKey))
		{
			return 0;
		}
		return (int)room.CustomProperties[TurnPropKey];
	}

	public static int GetTurnStart(this RoomInfo room)
	{
		if (room == null || room.CustomProperties == null || !room.CustomProperties.ContainsKey(TurnStartPropKey))
		{
			return 0;
		}
		return (int)room.CustomProperties[TurnStartPropKey];
	}

	public static int GetFinishedTurn(this PhotonPlayer player)
	{
		Room room = PhotonNetwork.room;
		if (room == null || room.CustomProperties == null || !room.CustomProperties.ContainsKey(TurnPropKey))
		{
			return 0;
		}
		string key = FinishedTurnPropKey + player.ID;
		return (int)room.CustomProperties[key];
	}

	public static void SetFinishedTurn(this PhotonPlayer player, int turn)
	{
		Room room = PhotonNetwork.room;
		if (room != null && room.CustomProperties != null)
		{
			string key = FinishedTurnPropKey + player.ID;
			ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
			hashtable[key] = turn;
			room.SetCustomProperties(hashtable);
		}
	}
}
public class QuitOnEscapeOrBack : UnityEngine.MonoBehaviour
{
	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class ShowStatusWhenConnecting : UnityEngine.MonoBehaviour
{
	public GUISkin Skin;

	private void OnGUI()
	{
		if (Skin != null)
		{
			GUI.skin = Skin;
		}
		float num = 400f;
		float num2 = 100f;
		Rect screenRect = new Rect(((float)Screen.width - num) / 2f, ((float)Screen.height - num2) / 2f, num, num2);
		GUILayout.BeginArea(screenRect, GUI.skin.box);
		GUILayout.Label("Connecting" + GetConnectingDots(), GUI.skin.customStyles[0]);
		GUILayout.Label("Status: " + PhotonNetwork.connectionStateDetailed);
		GUILayout.EndArea();
		if (PhotonNetwork.inRoom)
		{
			base.enabled = false;
		}
	}

	private string GetConnectingDots()
	{
		string text = string.Empty;
		int num = Mathf.FloorToInt(Time.timeSinceLevelLoad * 3f % 4f);
		for (int i = 0; i < num; i++)
		{
			text += " .";
		}
		return text;
	}
}
[RequireComponent(typeof(PhotonView))]
public class SmoothSyncMovement : Photon.MonoBehaviour, IPunObservable
{
	public float SmoothingDelay = 5f;

	private Vector3 correctPlayerPos = Vector3.zero;

	private Quaternion correctPlayerRot = Quaternion.identity;

	public void Awake()
	{
		bool flag = false;
		foreach (UnityEngine.Component observedComponent in base.photonView.ObservedComponents)
		{
			if (observedComponent == this)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			UnityEngine.Debug.LogWarning(string.Concat(this, " is not observed by this object's photonView! OnPhotonSerializeView() in this class won't be used."));
		}
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (stream.isWriting)
		{
			stream.SendNext(base.transform.position);
			stream.SendNext(base.transform.rotation);
		}
		else
		{
			correctPlayerPos = (Vector3)stream.ReceiveNext();
			correctPlayerRot = (Quaternion)stream.ReceiveNext();
		}
	}

	public void Update()
	{
		if (!base.photonView.isMine)
		{
			base.transform.position = Vector3.Lerp(base.transform.position, correctPlayerPos, Time.deltaTime * SmoothingDelay);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, correctPlayerRot, Time.deltaTime * SmoothingDelay);
		}
	}
}
public class SupportLogger : UnityEngine.MonoBehaviour
{
	public bool LogTrafficStats = true;

	public void Start()
	{
		GameObject gameObject = GameObject.Find("PunSupportLogger");
		if (gameObject == null)
		{
			gameObject = new GameObject("PunSupportLogger");
			UnityEngine.Object.DontDestroyOnLoad(gameObject);
			SupportLogging supportLogging = gameObject.AddComponent<SupportLogging>();
			supportLogging.LogTrafficStats = LogTrafficStats;
		}
	}
}
public class SupportLogging : UnityEngine.MonoBehaviour
{
	public bool LogTrafficStats;

	public void Start()
	{
		if (LogTrafficStats)
		{
			InvokeRepeating("LogStats", 10f, 10f);
		}
	}

	protected void OnApplicationPause(bool pause)
	{
		UnityEngine.Debug.Log("SupportLogger OnApplicationPause: " + pause + " connected: " + PhotonNetwork.connected);
	}

	public void OnApplicationQuit()
	{
		CancelInvoke();
	}

	public void LogStats()
	{
		if (LogTrafficStats)
		{
			UnityEngine.Debug.Log("SupportLogger " + PhotonNetwork.NetworkStatisticsToString());
		}
	}

	private void LogBasics()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendFormat("SupportLogger Info: PUN {0}: ", "1.88");
		stringBuilder.AppendFormat("AppID: {0}*** GameVersion: {1} PeerId: {2} ", PhotonNetwork.networkingPeer.AppId.Substring(0, 8), PhotonNetwork.networkingPeer.AppVersion, PhotonNetwork.networkingPeer.PeerID);
		stringBuilder.AppendFormat("Server: {0}. Region: {1} ", PhotonNetwork.ServerAddress, PhotonNetwork.networkingPeer.CloudRegion);
		stringBuilder.AppendFormat("HostType: {0} ", PhotonNetwork.PhotonServerSettings.HostType);
		UnityEngine.Debug.Log(stringBuilder.ToString());
	}

	public void OnConnectedToPhoton()
	{
		UnityEngine.Debug.Log("SupportLogger OnConnectedToPhoton().");
		LogBasics();
		if (LogTrafficStats)
		{
			PhotonNetwork.NetworkStatisticsEnabled = true;
		}
	}

	public void OnFailedToConnectToPhoton(DisconnectCause cause)
	{
		UnityEngine.Debug.Log(string.Concat("SupportLogger OnFailedToConnectToPhoton(", cause, ")."));
		LogBasics();
	}

	public void OnJoinedLobby()
	{
		UnityEngine.Debug.Log(string.Concat("SupportLogger OnJoinedLobby(", PhotonNetwork.lobby, ")."));
	}

	public void OnJoinedRoom()
	{
		UnityEngine.Debug.Log(string.Concat("SupportLogger OnJoinedRoom(", PhotonNetwork.room, "). ", PhotonNetwork.lobby, " GameServer:", PhotonNetwork.ServerAddress));
	}

	public void OnCreatedRoom()
	{
		UnityEngine.Debug.Log(string.Concat("SupportLogger OnCreatedRoom(", PhotonNetwork.room, "). ", PhotonNetwork.lobby, " GameServer:", PhotonNetwork.ServerAddress));
	}

	public void OnLeftRoom()
	{
		UnityEngine.Debug.Log("SupportLogger OnLeftRoom().");
	}

	public void OnDisconnectedFromPhoton()
	{
		UnityEngine.Debug.Log("SupportLogger OnDisconnectedFromPhoton().");
	}
}
namespace ExitGames.Client.DemoParticle
{
	public class TimeKeeper
	{
		private int lastExecutionTime = Environment.TickCount;

		private bool shouldExecute;

		public int Interval { get; set; }

		public bool IsEnabled { get; set; }

		public bool ShouldExecute
		{
			get
			{
				return IsEnabled && (shouldExecute || Environment.TickCount - lastExecutionTime > Interval);
			}
			set
			{
				shouldExecute = value;
			}
		}

		public TimeKeeper(int interval)
		{
			IsEnabled = true;
			Interval = interval;
		}

		public void Reset()
		{
			shouldExecute = false;
			lastExecutionTime = Environment.TickCount;
		}
	}
}
namespace ExitGames.UtilityScripts
{
	public class ButtonInsideScrollList : UnityEngine.MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IEventSystemHandler
	{
		private ScrollRect scrollRect;

		private void Start()
		{
			scrollRect = GetComponentInParent<ScrollRect>();
		}

		void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
		{
			if (scrollRect != null)
			{
				scrollRect.StopMovement();
				scrollRect.enabled = false;
			}
		}

		void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
		{
			if (scrollRect != null && !scrollRect.enabled)
			{
				scrollRect.enabled = true;
			}
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextButtonTransition : UnityEngine.MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IEventSystemHandler
	{
		private Text _text;

		public UnityEngine.Color NormalColor = UnityEngine.Color.white;

		public UnityEngine.Color HoverColor = UnityEngine.Color.black;

		public void Awake()
		{
			_text = GetComponent<Text>();
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			_text.color = HoverColor;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			_text.color = NormalColor;
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextToggleIsOnTransition : UnityEngine.MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IEventSystemHandler
	{
		public Toggle toggle;

		private Text _text;

		public UnityEngine.Color NormalOnColor = UnityEngine.Color.white;

		public UnityEngine.Color NormalOffColor = UnityEngine.Color.black;

		public UnityEngine.Color HoverOnColor = UnityEngine.Color.black;

		public UnityEngine.Color HoverOffColor = UnityEngine.Color.black;

		private bool isHover;

		public void OnEnable()
		{
			_text = GetComponent<Text>();
			toggle.onValueChanged.AddListener(OnValueChanged);
		}

		public void OnDisable()
		{
			toggle.onValueChanged.RemoveListener(OnValueChanged);
		}

		public void OnValueChanged(bool isOn)
		{
			_text.color = (isOn ? ((!isHover) ? HoverOffColor : HoverOnColor) : ((!isHover) ? NormalOffColor : NormalOnColor));
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHover = true;
			_text.color = ((!toggle.isOn) ? HoverOffColor : HoverOnColor);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHover = false;
			_text.color = ((!toggle.isOn) ? NormalOffColor : NormalOnColor);
		}
	}
}
public class PlayFabManager : UnityEngine.MonoBehaviour
{
	public string TitleId;

	public string callStatus = "** PlayFab Console ** \n Run on an Android or iOS device to see automatic device ID authentication.";

	private void Awake()
	{
		PlayFabSettings.TitleId = TitleId;
	}

	private void Start()
	{
		UnityEngine.Debug.Log("Starting Auto-login Process");
		LoginWithAndroidDeviceIDRequest loginWithAndroidDeviceIDRequest = new LoginWithAndroidDeviceIDRequest();
		loginWithAndroidDeviceIDRequest.AndroidDeviceId = SystemInfo.deviceUniqueIdentifier;
		loginWithAndroidDeviceIDRequest.OS = SystemInfo.operatingSystem;
		loginWithAndroidDeviceIDRequest.AndroidDevice = SystemInfo.deviceModel;
		loginWithAndroidDeviceIDRequest.CreateAccount = true;
		PlayFabClientAPI.LoginWithAndroidDeviceID(loginWithAndroidDeviceIDRequest, onLoginSuccess, null);
	}

	private void onLoginSuccess(LoginResult result)
	{
		callStatus = $"PlayFab Authentication Successful! -- Player ID:{result.PlayFabId}";
		UnityEngine.Debug.Log(callStatus);
	}

	private void onLoginError(PlayFabError error)
	{
		callStatus = $"Error {error.HttpCode}: {error.ErrorMessage}";
		UnityEngine.Debug.Log(callStatus);
	}
}
public class ScreenOutput : UnityEngine.MonoBehaviour
{
	public PlayFabManager pf_manager;

	public Text LoginResponse;

	public Button testCloudScript;

	public Text cloudScriptResponse;

	private void Start()
	{
		testCloudScript.onClick.RemoveAllListeners();
		testCloudScript.onClick.AddListener(delegate
		{
			TestCloudScript();
		});
	}

	private void Update()
	{
		if (pf_manager != null && !string.Equals(LoginResponse.text, pf_manager.callStatus))
		{
			LoginResponse.text = pf_manager.callStatus;
			EnableTestCSButton();
		}
	}

	private void EnableTestCSButton()
	{
		if (!testCloudScript.interactable && PlayFabClientAPI.IsClientLoggedIn())
		{
			testCloudScript.interactable = true;
		}
	}

	public void GetCloudScriptEndpoint(UnityAction callback = null)
	{
		if (string.IsNullOrEmpty(PlayFabSettings.LogicServerURL))
		{
			PlayFabClientAPI.GetCloudScriptUrl(new GetCloudScriptUrlRequest(), delegate
			{
				if (callback != null)
				{
					callback();
				}
			}, OnPlayFabError);
		}
		else
		{
			callback();
		}
	}

	private void TestCloudScript()
	{
		UnityAction callback = delegate
		{
			PlayFabClientAPI.RunCloudScript(new RunCloudScriptRequest
			{
				ActionId = "helloWorld"
			}, delegate(RunCloudScriptResult result)
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				dictionary = JsonConvert.DeserializeObject<Dictionary<string, string>>(result.ResultsEncoded);
				string value = string.Empty;
				if (dictionary.TryGetValue("messageValue", out value))
				{
					cloudScriptResponse.text = $"Cloud Script -- Version: {result.Version}, Revision: {result.Revision} \nResponse: {value}";
				}
				else
				{
					cloudScriptResponse.text = "Cloud Script call was successful, but there was an error deserializing the messageValue";
				}
			}, OnPlayFabError);
		};
		GetCloudScriptEndpoint(callback);
	}

	private void OnPlayFabError(PlayFabError error)
	{
		string text = $"Error {error.HttpCode}: {error.ErrorMessage}";
		cloudScriptResponse.text = text;
		UnityEngine.Debug.Log(text);
	}
}
namespace PlayFab.Internal
{
	public class Log
	{
		public static void Debug(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Debug) != 0)
			{
				UnityEngine.Debug.Log(Util.timeStamp + " DEBUG: " + Util.Format(text, args));
			}
		}

		public static void Info(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Info) != 0)
			{
				UnityEngine.Debug.Log(Util.timeStamp + " INFO: " + Util.Format(text, args));
			}
		}

		public static void Warning(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Warning) != 0)
			{
				UnityEngine.Debug.LogWarning(Util.timeStamp + " WARNING: " + Util.Format(text, args));
			}
		}

		public static void Error(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Error) != 0)
			{
				UnityEngine.Debug.LogError(Util.timeStamp + " ERROR: " + Util.Format(text, args));
			}
		}
	}
	public class PlayFabHTTP : SingletonMonoBehaviour<PlayFabHTTP>
	{
		private Queue<CallBackContainer> _RunOnMainThreadQueue = new Queue<CallBackContainer>();

		private int pendingMessages;

		private readonly Queue<CallBackContainer> _tempActions = new Queue<CallBackContainer>();

		public void Awake()
		{
			ServicePointManager.DefaultConnectionLimit = 10;
			ServicePointManager.Expect100Continue = false;
			RemoteCertificateValidationCallback serverCertificateValidationCallback = AcceptAllCertifications;
			ServicePointManager.ServerCertificateValidationCallback = serverCertificateValidationCallback;
		}

		public static void Post(string url, string data, string authType, string authKey, Action<string, PlayFabError> callback)
		{
			SingletonMonoBehaviour<PlayFabHTTP>.instance.InstPost(url, data, authType, authKey, callback);
		}

		public static void Post(string url, string data, string authType, string authKey, Action<string, PlayFabError> callback, bool IsBlocking)
		{
			if (IsBlocking)
			{
				SingletonMonoBehaviour<PlayFabHTTP>.instance.MakeRequestViaWebRequestSyncronous(url, data, authType, authKey, callback);
			}
			else
			{
				SingletonMonoBehaviour<PlayFabHTTP>.instance.InstPost(url, data, authType, authKey, callback);
			}
		}

		private void InstPost(string url, string data, string authType, string authKey, Action<string, PlayFabError> callback)
		{
			pendingMessages++;
			if (PlayFabSettings.RequestType == WebRequestType.HttpWebRequest)
			{
				MakeRequestViaWebRequest(url, data, authType, authKey, callback);
			}
			else
			{
				StartCoroutine(MakeRequestViaUnity(url, data, authType, authKey, callback));
			}
		}

		private void MakeRequestViaWebRequest(string url, string data, string authType, string authKey, Action<string, PlayFabError> callback)
		{
			byte[] payload = Encoding.UTF8.GetBytes(data);
			Thread thread = new Thread((ThreadStart)delegate
			{
				HttpWebRequest httpWebRequest = null;
				HttpWebResponse httpWebResponse = null;
				try
				{
					httpWebRequest = (HttpWebRequest)WebRequest.Create(url);
					httpWebRequest.Proxy = null;
					httpWebRequest.Headers.Add("X-ReportErrorAsSuccess", "true");
					httpWebRequest.Headers.Add("X-PlayFabSDK", PlayFabVersion.getVersionString());
					if (authType != null)
					{
						httpWebRequest.Headers.Add(authType, authKey);
					}
					httpWebRequest.ContentType = "application/json";
					httpWebRequest.Method = "POST";
					httpWebRequest.KeepAlive = PlayFabSettings.RequestKeepAlive;
					httpWebRequest.Timeout = PlayFabSettings.RequestTimeout;
					using (Stream stream = httpWebRequest.GetRequestStream())
					{
						stream.Write(payload, 0, payload.Length);
					}
					httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
					if (httpWebResponse.StatusCode == HttpStatusCode.OK)
					{
						using StreamReader streamReader = new StreamReader(httpWebResponse.GetResponseStream());
						string result = streamReader.ReadToEnd();
						lock (_RunOnMainThreadQueue)
						{
							CallBackContainer callBackContainer = default(CallBackContainer);
							callBackContainer.action = callback;
							callBackContainer.result = result;
							callBackContainer.error = null;
							CallBackContainer item = callBackContainer;
							_RunOnMainThreadQueue.Enqueue(item);
						}
					}
					else
					{
						PlayFabError error = GeneratePfError(httpWebResponse.StatusCode, PlayFabErrorCode.ServiceUnavailable, "Failed to connect to PlayFab server", null);
						lock (_RunOnMainThreadQueue)
						{
							CallBackContainer callBackContainer = default(CallBackContainer);
							callBackContainer.action = callback;
							callBackContainer.result = null;
							callBackContainer.error = error;
							CallBackContainer item2 = callBackContainer;
							_RunOnMainThreadQueue.Enqueue(item2);
						}
					}
				}
				catch (WebException ex)
				{
					HttpStatusCode httpCode = httpWebResponse?.StatusCode ?? HttpStatusCode.ServiceUnavailable;
					PlayFabError error2 = GeneratePfError(httpCode, PlayFabErrorCode.ServiceUnavailable, ex.ToString(), null);
					lock (_RunOnMainThreadQueue)
					{
						CallBackContainer callBackContainer = default(CallBackContainer);
						callBackContainer.action = callback;
						callBackContainer.result = null;
						callBackContainer.error = error2;
						CallBackContainer item3 = callBackContainer;
						_RunOnMainThreadQueue.Enqueue(item3);
					}
				}
				catch (Exception ex2)
				{
					UnityEngine.Debug.LogException(ex2);
					HttpStatusCode httpCode2 = httpWebResponse?.StatusCode ?? HttpStatusCode.ServiceUnavailable;
					PlayFabError error3 = GeneratePfError(httpCode2, PlayFabErrorCode.ServiceUnavailable, ex2.ToString(), null);
					lock (_RunOnMainThreadQueue)
					{
						CallBackContainer callBackContainer = default(CallBackContainer);
						callBackContainer.action = callback;
						callBackContainer.result = null;
						callBackContainer.error = error3;
						CallBackContainer item4 = callBackContainer;
						_RunOnMainThreadQueue.Enqueue(item4);
					}
				}
				pendingMessages--;
			});
			thread.Start();
		}

		private void MakeRequestViaWebRequestSyncronous(string url, string data, string authType, string authKey, Action<string, PlayFabError> callback)
		{
			HttpWebResponse httpWebResponse = null;
			try
			{
				byte[] bytes = Encoding.UTF8.GetBytes(data);
				HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(url);
				httpWebRequest.Proxy = null;
				httpWebRequest.Headers.Add("X-ReportErrorAsSuccess", "true");
				httpWebRequest.Headers.Add("X-PlayFabSDK", PlayFabVersion.getVersionString());
				if (authType != null)
				{
					httpWebRequest.Headers.Add(authType, authKey);
				}
				httpWebRequest.ContentType = "application/json";
				httpWebRequest.Method = "POST";
				httpWebRequest.KeepAlive = PlayFabSettings.RequestKeepAlive;
				httpWebRequest.Timeout = PlayFabSettings.RequestTimeout;
				using (Stream stream = httpWebRequest.GetRequestStream())
				{
					stream.Write(bytes, 0, bytes.Length);
				}
				httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
				if (httpWebResponse.StatusCode == HttpStatusCode.OK)
				{
					using StreamReader streamReader = new StreamReader(httpWebResponse.GetResponseStream());
					string arg = streamReader.ReadToEnd();
					callback(arg, null);
				}
				else
				{
					HttpStatusCode httpCode = httpWebResponse?.StatusCode ?? HttpStatusCode.ServiceUnavailable;
					PlayFabError arg2 = GeneratePfError(httpCode, PlayFabErrorCode.ServiceUnavailable, "Failed to connect to PlayFab server", null);
					callback(null, arg2);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogException(ex);
				HttpStatusCode httpCode2 = httpWebResponse?.StatusCode ?? HttpStatusCode.ServiceUnavailable;
				PlayFabError arg3 = GeneratePfError(httpCode2, PlayFabErrorCode.ServiceUnavailable, ex.ToString(), null);
				callback(null, arg3);
			}
			pendingMessages--;
		}

		private IEnumerator MakeRequestViaUnity(string url, string data, string authType, string authKey, Action<string, PlayFabError> callback)
		{
			byte[] bData = Encoding.UTF8.GetBytes(data);
			Dictionary<string, string> headers = new Dictionary<string, string> { { "Content-Type", "application/json" } };
			if (authType != null)
			{
				headers.Add(authType, authKey);
			}
			headers.Add("X-ReportErrorAsSuccess", "true");
			headers.Add("X-PlayFabSDK", PlayFabVersion.getVersionString());
			WWW www = new WWW(url, bData, headers);
			yield return www;
			if (!string.IsNullOrEmpty(www.error))
			{
				PlayFabError arg = GeneratePfError(HttpStatusCode.ServiceUnavailable, PlayFabErrorCode.ServiceUnavailable, www.error, null);
				callback(null, arg);
			}
			else
			{
				string text = www.text;
				callback(text, null);
			}
		}

		private string GetResonseCodeResult(HttpStatusCode code)
		{
			return code switch
			{
				HttpStatusCode.OK => $"Success: {code}", 
				HttpStatusCode.RequestTimeout => $"Request Timeout: {code}", 
				HttpStatusCode.BadRequest => $"BadRequest: {code}", 
				_ => $"Service Unavailable: {code}", 
			};
		}

		private PlayFabError GeneratePfError(HttpStatusCode httpCode, PlayFabErrorCode pfErrorCode, string errorMessage, string errorDetails)
		{
			PlayFabError playFabError = new PlayFabError();
			playFabError.HttpCode = (int)httpCode;
			playFabError.HttpStatus = GetResonseCodeResult(httpCode);
			playFabError.Error = pfErrorCode;
			playFabError.ErrorMessage = errorMessage;
			playFabError.ErrorDetails = null;
			return playFabError;
		}

		public void Update()
		{
			lock (_RunOnMainThreadQueue)
			{
				while (_RunOnMainThreadQueue.Count > 0)
				{
					CallBackContainer item = _RunOnMainThreadQueue.Dequeue();
					_tempActions.Enqueue(item);
				}
			}
			while (_tempActions.Count > 0)
			{
				CallBackContainer callBackContainer = _tempActions.Dequeue();
				callBackContainer.action(callBackContainer.result, callBackContainer.error);
			}
		}

		private bool AcceptAllCertifications(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
		{
			return true;
		}

		public int GetPendingMessages()
		{
			return pendingMessages;
		}
	}
	public struct CallBackContainer
	{
		public Action<string, PlayFabError> action;

		public string result;

		public PlayFabError error;
	}
	public class PlayFabVersion
	{
		public static string ApiRevision = "1.7.20151019";

		public static string SdkRevision = "0.7.151019";

		public static string getVersionString()
		{
			return "UnitySDK-" + SdkRevision + "-" + ApiRevision;
		}
	}
	public class ResultContainer<ResultType> where ResultType : class, new()
	{
		public int code;

		public string status;

		public string error;

		public int? errorCode;

		public string errorMessage;

		public Dictionary<string, List<string>> errorDetails;

		public ResultType data;

		public static void HandleResults(string responseStr, ref PlayFabError pfError, out ResultType result)
		{
			result = (ResultType)null;
			if (pfError != null)
			{
				if (PlayFabSettings.GlobalErrorHandler != null)
				{
					PlayFabSettings.GlobalErrorHandler(pfError);
				}
				return;
			}
			ResultContainer<ResultType> resultContainer = new ResultContainer<ResultType>();
			try
			{
				JsonConvert.PopulateObject(responseStr, resultContainer, Util.JsonSettings);
			}
			catch (Exception ex)
			{
				pfError = new PlayFabError();
				pfError.HttpCode = 200;
				pfError.HttpStatus = "Client failed to parse response from server";
				pfError.Error = PlayFabErrorCode.Unknown;
				pfError.ErrorMessage = ex.ToString();
				pfError.ErrorDetails = null;
				if (PlayFabSettings.GlobalErrorHandler != null)
				{
					PlayFabSettings.GlobalErrorHandler(pfError);
				}
				return;
			}
			if (resultContainer.errorCode.HasValue)
			{
				PlayFabErrorCode playFabErrorCode;
				try
				{
					playFabErrorCode = (PlayFabErrorCode)resultContainer.errorCode.Value;
				}
				catch
				{
					playFabErrorCode = PlayFabErrorCode.Unknown;
				}
				pfError = new PlayFabError
				{
					HttpCode = resultContainer.code,
					HttpStatus = resultContainer.status,
					Error = playFabErrorCode,
					ErrorMessage = resultContainer.errorMessage,
					ErrorDetails = resultContainer.errorDetails
				};
				if (PlayFabSettings.GlobalErrorHandler != null)
				{
					PlayFabSettings.GlobalErrorHandler(pfError);
				}
			}
			else
			{
				result = resultContainer.data;
			}
		}
	}
	public class SingletonMonoBehaviour<T> : UnityEngine.MonoBehaviour where T : SingletonMonoBehaviour<T>
	{
		private static T m_instance;

		public static T instance
		{
			get
			{
				if (m_instance == null)
				{
					m_instance = UnityEngine.Object.FindObjectOfType<T>();
					if (m_instance == null)
					{
						GameObject gameObject = new GameObject(typeof(T).Name);
						m_instance = gameObject.AddComponent<T>();
						UnityEngine.Object.DontDestroyOnLoad(gameObject);
					}
					if (!m_instance.initialized)
					{
						m_instance.Initialize();
						m_instance.initialized = true;
					}
				}
				return m_instance;
			}
		}

		protected bool initialized { get; set; }

		private void Awake()
		{
			if (m_instance != null)
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
		}

		protected virtual void Initialize()
		{
		}
	}
	internal class GMFB_327 : UUnitTestCase
	{
		private class ObjWithTimes
		{
			public DateTime timestamp = DateTime.UtcNow;
		}

		private enum testRegion
		{
			USCentral,
			USEast,
			EUWest,
			Singapore,
			Japan,
			Brazil,
			Australia
		}

		private class EnumConversionTestClass
		{
			public List<testRegion> enumList;

			public testRegion[] enumArray;

			public testRegion enumValue;

			public override bool Equals(object obj)
			{
				if (object.ReferenceEquals(obj, null) || !(obj is EnumConversionTestClass))
				{
					return false;
				}
				EnumConversionTestClass enumConversionTestClass = (EnumConversionTestClass)obj;
				if (enumList.Count != enumConversionTestClass.enumList.Count || enumArray.Length != enumConversionTestClass.enumArray.Length)
				{
					return false;
				}
				for (int i = 0; i < enumList.Count; i++)
				{
					if (enumList[i] != enumConversionTestClass.enumList[i])
					{
						return false;
					}
				}
				for (int j = 0; j < enumArray.Length; j++)
				{
					if (enumArray[j] != enumConversionTestClass.enumArray[j])
					{
						return false;
					}
				}
				return true;
			}

			public override int GetHashCode()
			{
				throw new NotImplementedException("EnumListTest is a test class, and not designed to be hashed.");
			}
		}

		private string[] examples = new string[16]
		{
			"2015-08-25T10:22:01.654321Z",
			"2015-08-25T10:22:01.8642Z",
			"2015-08-25T10:22:01.753Z",
			"2015-08-25T10:22:01.71Z",
			"2015-08-25T10:22:01Z",
			"2015-08-25 10:22:01.654321",
			"2015-08-25 10:22:01.8642",
			"2015-08-25 10:22:01.753",
			"2015-08-25 10:22:01.71",
			"2015-08-25 10:22:01",
			"2015-08-25 10:22.01.8642",
			"2015-08-25 10:22.01.753",
			"2015-08-25 10:22.01.71",
			"2015-08-25 10:22.01",
			Util.timeStamp,
			Util.utcTimeStamp
		};

		[UUnitTest]
		private void TimeStampHandlesAllFormats()
		{
			string[] defaultDateTimeFormats = PlayFab.Json.Converters.IsoDateTimeConverter._defaultDateTimeFormats;
			DateTime result;
			for (int i = 0; i < examples.Length; i++)
			{
				string text = ((i >= defaultDateTimeFormats.Length) ? "default" : defaultDateTimeFormats[i]);
				UUnitAssert.True(DateTime.TryParseExact(examples[i], defaultDateTimeFormats, CultureInfo.CurrentCulture, DateTimeStyles.RoundtripKind, out result), "Index: " + i + "/" + examples.Length + ", " + examples[i] + " with " + text);
			}
			DateTime now = DateTime.Now;
			for (int j = 0; j < defaultDateTimeFormats.Length; j++)
			{
				string text2 = now.ToString(defaultDateTimeFormats[j], CultureInfo.CurrentCulture);
				UUnitAssert.True(DateTime.TryParseExact(text2, defaultDateTimeFormats, CultureInfo.CurrentCulture, DateTimeStyles.RoundtripKind, out result), "Index: " + j + "/" + defaultDateTimeFormats.Length + ", " + defaultDateTimeFormats[j] + " with " + text2);
				UUnitAssert.True((result - now).TotalSeconds < 1.0, string.Concat("Expected: ", now, " vs actual:", result));
			}
		}

		[UUnitTest]
		private void JsonTimeStampHandlesAllFormats()
		{
			ObjWithTimes objWithTimes = new ObjWithTimes();
			for (int i = 0; i < examples.Length; i++)
			{
				UUnitAssert.True(DateTime.TryParseExact(examples[i], PlayFab.Json.Converters.IsoDateTimeConverter._defaultDateTimeFormats, CultureInfo.CurrentCulture, DateTimeStyles.RoundtripKind, out var result), "Index: " + i + "/" + examples.Length + ", " + examples[i]);
				string text = "{\"timestamp\":\"" + examples[i] + "\"}";
				JsonConvert.PopulateObject(text, objWithTimes, Util.JsonSettings);
				string text2 = JsonConvert.SerializeObject(objWithTimes, Util.JsonFormatting, Util.JsonSettings);
				if (i == 0)
				{
					UUnitAssert.Equals(text, text2);
				}
				double totalSeconds = (result - objWithTimes.timestamp).TotalSeconds;
				UUnitAssert.True(totalSeconds < 1.0, string.Concat("\nActual time: ", objWithTimes.timestamp, " vs expected time: ", result, ", diff: ", totalSeconds, "\nActual json: ", text2, " vs expected json: ", text));
			}
		}

		[UUnitTest]
		private void EnumConversionTest()
		{
			EnumConversionTestClass enumConversionTestClass = new EnumConversionTestClass();
			EnumConversionTestClass enumConversionTestClass2 = new EnumConversionTestClass();
			enumConversionTestClass.enumList = new List<testRegion>
			{
				testRegion.USEast,
				testRegion.USCentral,
				testRegion.Japan
			};
			enumConversionTestClass.enumArray = new testRegion[3]
			{
				testRegion.USEast,
				testRegion.USCentral,
				testRegion.Japan
			};
			enumConversionTestClass.enumValue = testRegion.Australia;
			string text = "{\"enumList\":[\"USEast\",\"USCentral\",\"Japan\"],\"enumArray\":[\"USEast\",\"USCentral\",\"Japan\"],\"enumValue\":\"Australia\"}";
			JsonConvert.PopulateObject(text, enumConversionTestClass2, Util.JsonSettings);
			string text2 = JsonConvert.SerializeObject(enumConversionTestClass2, Util.JsonFormatting, Util.JsonSettings);
			UUnitAssert.Equals(text.Replace(" ", string.Empty).Replace("\n", string.Empty), text2.Replace(" ", string.Empty).Replace("\n", string.Empty));
			UUnitAssert.ObjEquals(enumConversionTestClass, enumConversionTestClass2);
		}
	}
	internal class Util
	{
		public static JsonSerializerSettings JsonSettings = new JsonSerializerSettings
		{
			NullValueHandling = NullValueHandling.Ignore,
			Converters = 
			{
				(JsonConverter)new PlayFab.Json.Converters.IsoDateTimeConverter(),
				(JsonConverter)new PlayFab.Json.Converters.StringEnumConverter()
			}
		};

		public static PlayFab.Json.Formatting JsonFormatting = PlayFab.Json.Formatting.None;

		public static string timeStamp => DateTime.Now.ToString(PlayFab.Json.Converters.IsoDateTimeConverter._defaultDateTimeFormats[8]);

		public static string utcTimeStamp => DateTime.UtcNow.ToString(PlayFab.Json.Converters.IsoDateTimeConverter._defaultDateTimeFormats[0]);

		public static string Format(string text, params object[] args)
		{
			return (args.Length <= 0) ? text : string.Format(text, args);
		}
	}
}
namespace PlayFab.Json
{
	public enum ConstructorHandling
	{
		Default,
		AllowNonPublicDefaultConstructor
	}
}
namespace PlayFab.Json.Converters
{
	public abstract class DateTimeConverterBase : JsonConverter
	{
		public override bool CanConvert(Type objectType)
		{
			if (objectType == typeof(DateTime) || objectType == typeof(DateTime?))
			{
				return true;
			}
			if (objectType == typeof(DateTimeOffset) || objectType == typeof(DateTimeOffset?))
			{
				return true;
			}
			return false;
		}
	}
	public class IsoDateTimeConverter : DateTimeConverterBase
	{
		public static readonly string[] _defaultDateTimeFormats = new string[14]
		{
			"yyyy-MM-ddTHH:mm:ss.FFFFFFZ", "yyyy-MM-ddTHH:mm:ss.FFFFZ", "yyyy-MM-ddTHH:mm:ss.FFFZ", "yyyy-MM-ddTHH:mm:ss.FFZ", "yyyy-MM-ddTHH:mm:ssZ", "yyyy-MM-dd HH:mm:ss.FFFFFF", "yyyy-MM-dd HH:mm:ss.FFFF", "yyyy-MM-dd HH:mm:ss.FFF", "yyyy-MM-dd HH:mm:ss.FF", "yyyy-MM-dd HH:mm:ss",
			"yyyy-MM-dd HH:mm.ss.FFFF", "yyyy-MM-dd HH:mm.ss.FFF", "yyyy-MM-dd HH:mm.ss.FF", "yyyy-MM-dd HH:mm.ss"
		};

		public const int DEFAULT_UTC_OUTPUT_INDEX = 0;

		public const int DEFAULT_LOCAL_OUTPUT_INDEX = 8;

		private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;

		private string _dateTimeFormat;

		private CultureInfo _culture;

		public DateTimeStyles DateTimeStyles
		{
			get
			{
				return _dateTimeStyles;
			}
			set
			{
				_dateTimeStyles = value;
			}
		}

		public string DateTimeFormat
		{
			get
			{
				return _dateTimeFormat ?? string.Empty;
			}
			set
			{
				_dateTimeFormat = PlayFab.Json.Utilities.StringUtils.NullEmptyString(value);
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.CurrentCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			string value2;
			if (value is DateTime dateTime)
			{
				if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
				{
					dateTime = dateTime.ToUniversalTime();
				}
				value2 = dateTime.ToString(_dateTimeFormat ?? _defaultDateTimeFormats[0], Culture);
			}
			else
			{
				if (!(value is DateTimeOffset dateTimeOffset))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected value when converting date. Expected DateTime or DateTimeOffset, got {0}.", CultureInfo.InvariantCulture, PlayFab.Json.Utilities.ReflectionUtils.GetObjectType(value)));
				}
				if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
				{
					dateTimeOffset = dateTimeOffset.ToUniversalTime();
				}
				value2 = dateTimeOffset.ToString(_dateTimeFormat ?? _defaultDateTimeFormats[0], Culture);
			}
			writer.WriteValue(value2);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			bool flag = PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType);
			Type type = ((!flag) ? objectType : Nullable.GetUnderlyingType(objectType));
			if (reader.TokenType == JsonToken.Null)
			{
				if (!PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot convert null value to {0}.", CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType != JsonToken.String)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected token parsing date. Expected String, got {0}.", CultureInfo.InvariantCulture, reader.TokenType));
			}
			string text = reader.Value.ToString();
			if (string.IsNullOrEmpty(text) && flag)
			{
				return null;
			}
			if (type == typeof(DateTimeOffset))
			{
				if (!string.IsNullOrEmpty(_dateTimeFormat) && DateTimeOffset.TryParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles, out var result))
				{
					return result;
				}
				if (DateTimeOffset.TryParseExact(text, _defaultDateTimeFormats, Culture, _dateTimeStyles, out result))
				{
					return result;
				}
				return DateTimeOffset.Parse(text, Culture, _dateTimeStyles);
			}
			if (!string.IsNullOrEmpty(_dateTimeFormat) && DateTime.TryParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles, out var result2))
			{
				return result2;
			}
			if (DateTime.TryParseExact(text, _defaultDateTimeFormats, Culture, _dateTimeStyles, out result2))
			{
				return result2;
			}
			return DateTime.Parse(text, Culture, _dateTimeStyles);
		}
	}
	public class JavaScriptDateTimeConverter : DateTimeConverterBase
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			long value2;
			if (value is DateTime dateTime)
			{
				DateTime dateTime2 = dateTime.ToUniversalTime();
				value2 = JsonConvert.ConvertDateTimeToJavaScriptTicks(dateTime2);
			}
			else
			{
				if (!(value is DateTimeOffset dateTimeOffset))
				{
					throw new Exception("Expected date object value.");
				}
				value2 = JsonConvert.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.ToUniversalTime().UtcDateTime);
			}
			writer.WriteStartConstructor("Date");
			writer.WriteValue(value2);
			writer.WriteEndConstructor();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			Type type = ((!PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType)) ? objectType : Nullable.GetUnderlyingType(objectType));
			if (reader.TokenType == JsonToken.Null)
			{
				if (!PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot convert null value to {0}.", CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType != JsonToken.StartConstructor || string.Compare(reader.Value.ToString(), "Date", StringComparison.Ordinal) != 0)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected token or value when parsing date. Token: {0}, Value: {1}", CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
			}
			reader.Read();
			if (reader.TokenType != JsonToken.Integer)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected token parsing date. Expected Integer, got {0}.", CultureInfo.InvariantCulture, reader.TokenType));
			}
			long javaScriptTicks = (long)reader.Value;
			DateTime dateTime = JsonConvert.ConvertJavaScriptTicksToDateTime(javaScriptTicks);
			reader.Read();
			if (reader.TokenType != JsonToken.EndConstructor)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected token parsing date. Expected EndConstructor, got {0}.", CultureInfo.InvariantCulture, reader.TokenType));
			}
			if (type == typeof(DateTimeOffset))
			{
				return new DateTimeOffset(dateTime);
			}
			return dateTime;
		}
	}
	public enum JsonDateTimeSerializationMode
	{
		Local,
		Utc,
		Unspecified,
		RoundtripKind
	}
	public class KeyValuePairConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			Type type = value.GetType();
			PropertyInfo property = type.GetProperty("Key");
			PropertyInfo property2 = type.GetProperty("Value");
			writer.WriteStartObject();
			writer.WritePropertyName("Key");
			serializer.Serialize(writer, PlayFab.Json.Utilities.ReflectionUtils.GetMemberValue(property, value));
			writer.WritePropertyName("Value");
			serializer.Serialize(writer, PlayFab.Json.Utilities.ReflectionUtils.GetMemberValue(property2, value));
			writer.WriteEndObject();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			IList<Type> genericArguments = objectType.GetGenericArguments();
			Type objectType2 = genericArguments[0];
			Type objectType3 = genericArguments[1];
			reader.Read();
			reader.Read();
			object obj = serializer.Deserialize(reader, objectType2);
			reader.Read();
			reader.Read();
			object obj2 = serializer.Deserialize(reader, objectType3);
			reader.Read();
			return PlayFab.Json.Utilities.ReflectionUtils.CreateInstance(objectType, obj, obj2);
		}

		public override bool CanConvert(Type objectType)
		{
			if (objectType.IsValueType && objectType.IsGenericType)
			{
				return objectType.GetGenericTypeDefinition() == typeof(KeyValuePair<, >);
			}
			return false;
		}
	}
	public class StringEnumConverter : JsonConverter
	{
		private readonly Dictionary<Type, PlayFab.Json.Utilities.BidirectionalDictionary<string, string>> _enumMemberNamesPerType = new Dictionary<Type, PlayFab.Json.Utilities.BidirectionalDictionary<string, string>>();

		public bool CamelCaseText { get; set; }

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Enum @enum = (Enum)value;
			string text = @enum.ToString("G");
			if (char.IsNumber(text[0]) || text[0] == '-')
			{
				writer.WriteValue(value);
				return;
			}
			PlayFab.Json.Utilities.BidirectionalDictionary<string, string> enumNameMap = GetEnumNameMap(@enum.GetType());
			enumNameMap.TryGetByFirst(text, out var second);
			second = second ?? text;
			if (CamelCaseText)
			{
				second = PlayFab.Json.Utilities.StringUtils.ToCamelCase(second);
			}
			writer.WriteValue(second);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			Type type = ((!PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType)) ? objectType : Nullable.GetUnderlyingType(objectType));
			if (reader.TokenType == JsonToken.Null)
			{
				if (!PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot convert null value to {0}.", CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType == JsonToken.String)
			{
				PlayFab.Json.Utilities.BidirectionalDictionary<string, string> enumNameMap = GetEnumNameMap(type);
				enumNameMap.TryGetBySecond(reader.Value.ToString(), out var first);
				first = first ?? reader.Value.ToString();
				return Enum.Parse(type, first, ignoreCase: true);
			}
			if (reader.TokenType == JsonToken.Integer)
			{
				return PlayFab.Json.Utilities.ConvertUtils.ConvertOrCast(reader.Value, CultureInfo.InvariantCulture, type);
			}
			throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected token when parsing enum. Expected String or Integer, got {0}.", CultureInfo.InvariantCulture, reader.TokenType));
		}

		private PlayFab.Json.Utilities.BidirectionalDictionary<string, string> GetEnumNameMap(Type t)
		{
			if (!_enumMemberNamesPerType.TryGetValue(t, out var value))
			{
				lock (_enumMemberNamesPerType)
				{
					if (_enumMemberNamesPerType.TryGetValue(t, out value))
					{
						return value;
					}
					value = new PlayFab.Json.Utilities.BidirectionalDictionary<string, string>(StringComparer.OrdinalIgnoreCase, StringComparer.OrdinalIgnoreCase);
					FieldInfo[] fields = t.GetFields();
					foreach (FieldInfo fieldInfo in fields)
					{
						string name = fieldInfo.Name;
						string text = System.Linq.Enumerable.SingleOrDefault(System.Linq.Enumerable.Select(System.Linq.Enumerable.Cast<EnumMemberAttribute>(fieldInfo.GetCustomAttributes(typeof(EnumMemberAttribute), inherit: true)), (EnumMemberAttribute a) => a.Value)) ?? fieldInfo.Name;
						if (value.TryGetBySecond(text, out var _))
						{
							throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Enum name '{0}' already exists on enum '{1}'.", CultureInfo.InvariantCulture, text, t.Name));
						}
						value.Add(name, text);
					}
					_enumMemberNamesPerType[t] = value;
				}
			}
			return value;
		}

		public override bool CanConvert(Type objectType)
		{
			Type type = ((!PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType)) ? objectType : Nullable.GetUnderlyingType(objectType));
			return type.IsEnum;
		}
	}
}
namespace PlayFab.Json
{
	[Flags]
	public enum DefaultValueHandling
	{
		Include = 0,
		Ignore = 1,
		Populate = 2,
		IgnoreAndPopulate = 3
	}
	public interface IJsonLineInfo
	{
		int LineNumber { get; }

		int LinePosition { get; }

		bool HasLineInfo();
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonArrayAttribute : JsonContainerAttribute
	{
		private bool _allowNullItems;

		public bool AllowNullItems
		{
			get
			{
				return _allowNullItems;
			}
			set
			{
				_allowNullItems = value;
			}
		}

		public JsonArrayAttribute()
		{
		}

		public JsonArrayAttribute(bool allowNullItems)
		{
			_allowNullItems = allowNullItems;
		}

		public JsonArrayAttribute(string id)
			: base(id)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Property, AllowMultiple = false)]
	public sealed class JsonConstructorAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	public abstract class JsonContainerAttribute : Attribute
	{
		internal bool? _isReference;

		public string Id { get; set; }

		public string Title { get; set; }

		public string Description { get; set; }

		public bool IsReference
		{
			get
			{
				bool? isReference = _isReference;
				return isReference.HasValue && isReference.Value;
			}
			set
			{
				_isReference = value;
			}
		}

		protected JsonContainerAttribute()
		{
		}

		protected JsonContainerAttribute(string id)
		{
			Id = id;
		}
	}
	public static class JsonConvert
	{
		public static readonly string True = "true";

		public static readonly string False = "false";

		public static readonly string Null = "null";

		public static readonly string Undefined = "undefined";

		public static readonly string PositiveInfinity = "Infinity";

		public static readonly string NegativeInfinity = "-Infinity";

		public static readonly string NaN = "NaN";

		internal static readonly long InitialJavaScriptDateTicks = 621355968000000000L;

		public static string ToString(DateTime value)
		{
			using StringWriter stringWriter = PlayFab.Json.Utilities.StringUtils.CreateStringWriter(64);
			WriteDateTimeString(stringWriter, value, GetUtcOffset(value), value.Kind);
			return stringWriter.ToString();
		}

		public static string ToString(DateTimeOffset value)
		{
			using StringWriter stringWriter = PlayFab.Json.Utilities.StringUtils.CreateStringWriter(64);
			WriteDateTimeString(stringWriter, value.UtcDateTime, value.Offset, DateTimeKind.Local);
			return stringWriter.ToString();
		}

		private static TimeSpan GetUtcOffset(DateTime dateTime)
		{
			return TimeZone.CurrentTimeZone.GetUtcOffset(dateTime);
		}

		internal static void WriteDateTimeString(TextWriter writer, DateTime value)
		{
			WriteDateTimeString(writer, value, GetUtcOffset(value), value.Kind);
		}

		internal static void WriteDateTimeString(TextWriter writer, DateTime value, TimeSpan offset, DateTimeKind kind)
		{
			long value2 = ConvertDateTimeToJavaScriptTicks(value, offset);
			writer.Write("\"\\/Date(");
			writer.Write(value2);
			if (kind == DateTimeKind.Local || kind == DateTimeKind.Unspecified)
			{
				writer.Write((offset.Ticks < 0) ? "-" : "+");
				int num = Math.Abs(offset.Hours);
				if (num < 10)
				{
					writer.Write(0);
				}
				writer.Write(num);
				int num2 = Math.Abs(offset.Minutes);
				if (num2 < 10)
				{
					writer.Write(0);
				}
				writer.Write(num2);
			}
			writer.Write(")\\/\"");
		}

		private static long ToUniversalTicks(DateTime dateTime)
		{
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				return dateTime.Ticks;
			}
			return ToUniversalTicks(dateTime, GetUtcOffset(dateTime));
		}

		private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
		{
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				return dateTime.Ticks;
			}
			long num = dateTime.Ticks - offset.Ticks;
			if (num > 3155378975999999999L)
			{
				return 3155378975999999999L;
			}
			if (num < 0)
			{
				return 0L;
			}
			return num;
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
		{
			long universialTicks = ToUniversalTicks(dateTime, offset);
			return UniversialTicksToJavaScriptTicks(universialTicks);
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
		{
			return ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: true);
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
		{
			long universialTicks = ((!convertToUtc) ? dateTime.Ticks : ToUniversalTicks(dateTime));
			return UniversialTicksToJavaScriptTicks(universialTicks);
		}

		private static long UniversialTicksToJavaScriptTicks(long universialTicks)
		{
			return (universialTicks - InitialJavaScriptDateTicks) / 10000;
		}

		internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
		{
			return new DateTime(javaScriptTicks * 10000 + InitialJavaScriptDateTicks, DateTimeKind.Utc);
		}

		public static string ToString(bool value)
		{
			return (!value) ? False : True;
		}

		public static string ToString(char value)
		{
			return ToString(char.ToString(value));
		}

		public static string ToString(int value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(short value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(ushort value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(uint value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(long value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(ulong value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(float value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		public static string ToString(double value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		private static string EnsureDecimalPlace(double value, string text)
		{
			if (double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		private static string EnsureDecimalPlace(string text)
		{
			if (text.IndexOf('.') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		public static string ToString(byte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(sbyte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(decimal value)
		{
			return EnsureDecimalPlace(value.ToString(null, CultureInfo.InvariantCulture));
		}

		public static string ToString(Guid value)
		{
			return '"' + value.ToString("D", CultureInfo.InvariantCulture) + '"';
		}

		public static string ToString(TimeSpan value)
		{
			return '"' + value.ToString() + '"';
		}

		public static string ToString(Uri value)
		{
			return '"' + value.ToString() + '"';
		}

		public static string ToString(string value)
		{
			return ToString(value, '"');
		}

		public static string ToString(string value, char delimter)
		{
			return PlayFab.Json.Utilities.JavaScriptUtils.ToEscapedJavaScriptString(value, delimter, appendDelimiters: true);
		}

		private static bool IsJsonPrimitiveTypeCode(TypeCode typeCode)
		{
			switch (typeCode)
			{
			case TypeCode.DBNull:
			case TypeCode.Boolean:
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
			case TypeCode.DateTime:
			case TypeCode.String:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsJsonPrimitiveType(Type type)
		{
			if (PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(type))
			{
				type = Nullable.GetUnderlyingType(type);
			}
			if (type == typeof(DateTimeOffset))
			{
				return true;
			}
			if (type == typeof(byte[]))
			{
				return true;
			}
			if (type == typeof(Uri))
			{
				return true;
			}
			if (type == typeof(TimeSpan))
			{
				return true;
			}
			if (type == typeof(Guid))
			{
				return true;
			}
			return IsJsonPrimitiveTypeCode(Type.GetTypeCode(type));
		}

		internal static bool IsJsonPrimitive(object value)
		{
			if (value == null)
			{
				return true;
			}
			if (value is IConvertible convertible)
			{
				return IsJsonPrimitiveTypeCode(convertible.GetTypeCode());
			}
			if (value is DateTimeOffset)
			{
				return true;
			}
			if (value is byte[])
			{
				return true;
			}
			if (value is Uri)
			{
				return true;
			}
			if (value is TimeSpan)
			{
				return true;
			}
			if (value is Guid)
			{
				return true;
			}
			return false;
		}

		public static string SerializeObject(object value)
		{
			return SerializeObject(value, Formatting.None, (JsonSerializerSettings)null);
		}

		public static string SerializeObject(object value, Formatting formatting)
		{
			return SerializeObject(value, formatting, (JsonSerializerSettings)null);
		}

		public static string SerializeObject(object value, params JsonConverter[] converters)
		{
			return SerializeObject(value, Formatting.None, converters);
		}

		public static string SerializeObject(object value, Formatting formatting, params JsonConverter[] converters)
		{
			object obj;
			if (converters != null && converters.Length > 0)
			{
				JsonSerializerSettings jsonSerializerSettings = new JsonSerializerSettings();
				jsonSerializerSettings.Converters = converters;
				obj = jsonSerializerSettings;
			}
			else
			{
				obj = null;
			}
			JsonSerializerSettings settings = (JsonSerializerSettings)obj;
			return SerializeObject(value, formatting, settings);
		}

		public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.Create(settings);
			StringBuilder sb = new StringBuilder(128);
			StringWriter stringWriter = new StringWriter(sb, CultureInfo.InvariantCulture);
			using (JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter))
			{
				jsonTextWriter.Formatting = formatting;
				jsonSerializer.Serialize(jsonTextWriter, value);
			}
			return stringWriter.ToString();
		}

		public static T DeserializeObject<T>(string value)
		{
			return DeserializeObject<T>(value, (JsonSerializerSettings)null);
		}

		public static T DeserializeObject<T>(string value, params JsonConverter[] converters)
		{
			return (T)DeserializeObject(value, typeof(T), converters);
		}

		public static T DeserializeObject<T>(string value, JsonSerializerSettings settings)
		{
			return (T)DeserializeObject(value, typeof(T), settings);
		}

		private static object DeserializeObject(string value, Type type, params JsonConverter[] converters)
		{
			object obj;
			if (converters != null && converters.Length > 0)
			{
				JsonSerializerSettings jsonSerializerSettings = new JsonSerializerSettings();
				jsonSerializerSettings.Converters = converters;
				obj = jsonSerializerSettings;
			}
			else
			{
				obj = null;
			}
			JsonSerializerSettings settings = (JsonSerializerSettings)obj;
			return DeserializeObject(value, type, settings);
		}

		private static object DeserializeObject(string value, Type type, JsonSerializerSettings settings)
		{
			StringReader reader = new StringReader(value);
			JsonSerializer jsonSerializer = JsonSerializer.Create(settings);
			object result;
			using (JsonReader jsonReader = new JsonTextReader(reader))
			{
				result = jsonSerializer.Deserialize(jsonReader, type);
				if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
				{
					throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
				}
			}
			return result;
		}

		public static void PopulateObject(string value, object target)
		{
			PopulateObject(value, target, null);
		}

		public static void PopulateObject(string value, object target, JsonSerializerSettings settings)
		{
			StringReader reader = new StringReader(value);
			JsonSerializer jsonSerializer = JsonSerializer.Create(settings);
			using JsonReader jsonReader = new JsonTextReader(reader);
			jsonSerializer.Populate(jsonReader, target);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
			}
		}
	}
	public abstract class JsonConverter
	{
		public virtual bool CanRead => true;

		public virtual bool CanWrite => true;

		public abstract void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);

		public abstract object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);

		public abstract bool CanConvert(Type objectType);

		public virtual JsonSchema GetSchema()
		{
			return null;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter, AllowMultiple = false)]
	public sealed class JsonConverterAttribute : Attribute
	{
		private readonly Type _converterType;

		public Type ConverterType => _converterType;

		public JsonConverterAttribute(Type converterType)
		{
			if (converterType == null)
			{
				throw new ArgumentNullException("converterType");
			}
			_converterType = converterType;
		}

		internal static JsonConverter CreateJsonConverterInstance(Type converterType)
		{
			try
			{
				return (JsonConverter)Activator.CreateInstance(converterType);
			}
			catch (Exception innerException)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Error creating {0}", CultureInfo.InvariantCulture, converterType), innerException);
			}
		}
	}
	public class JsonConverterCollection : Collection<JsonConverter>
	{
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonIgnoreAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonObjectAttribute : JsonContainerAttribute
	{
		private MemberSerialization _memberSerialization;

		public MemberSerialization MemberSerialization
		{
			get
			{
				return _memberSerialization;
			}
			set
			{
				_memberSerialization = value;
			}
		}

		public JsonObjectAttribute()
		{
		}

		public JsonObjectAttribute(MemberSerialization memberSerialization)
		{
			MemberSerialization = memberSerialization;
		}

		public JsonObjectAttribute(string id)
			: base(id)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
	public sealed class JsonPropertyAttribute : Attribute
	{
		internal NullValueHandling? _nullValueHandling;

		internal DefaultValueHandling? _defaultValueHandling;

		internal ReferenceLoopHandling? _referenceLoopHandling;

		internal ObjectCreationHandling? _objectCreationHandling;

		internal TypeNameHandling? _typeNameHandling;

		internal bool? _isReference;

		internal int? _order;

		public NullValueHandling NullValueHandling
		{
			get
			{
				NullValueHandling? nullValueHandling = _nullValueHandling;
				return nullValueHandling.HasValue ? nullValueHandling.Value : NullValueHandling.Include;
			}
			set
			{
				_nullValueHandling = value;
			}
		}

		public DefaultValueHandling DefaultValueHandling
		{
			get
			{
				DefaultValueHandling? defaultValueHandling = _defaultValueHandling;
				return defaultValueHandling.HasValue ? defaultValueHandling.Value : DefaultValueHandling.Include;
			}
			set
			{
				_defaultValueHandling = value;
			}
		}

		public ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				ReferenceLoopHandling? referenceLoopHandling = _referenceLoopHandling;
				return referenceLoopHandling.HasValue ? referenceLoopHandling.Value : ReferenceLoopHandling.Error;
			}
			set
			{
				_referenceLoopHandling = value;
			}
		}

		public ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				ObjectCreationHandling? objectCreationHandling = _objectCreationHandling;
				return objectCreationHandling.HasValue ? objectCreationHandling.Value : ObjectCreationHandling.Auto;
			}
			set
			{
				_objectCreationHandling = value;
			}
		}

		public TypeNameHandling TypeNameHandling
		{
			get
			{
				TypeNameHandling? typeNameHandling = _typeNameHandling;
				return typeNameHandling.HasValue ? typeNameHandling.Value : TypeNameHandling.None;
			}
			set
			{
				_typeNameHandling = value;
			}
		}

		public bool IsReference
		{
			get
			{
				bool? isReference = _isReference;
				return isReference.HasValue && isReference.Value;
			}
			set
			{
				_isReference = value;
			}
		}

		public int Order
		{
			get
			{
				int? order = _order;
				return order.HasValue ? order.Value : 0;
			}
			set
			{
				_order = value;
			}
		}

		public string PropertyName { get; set; }

		public Required Required { get; set; }

		public JsonPropertyAttribute()
		{
		}

		public JsonPropertyAttribute(string propertyName)
		{
			PropertyName = propertyName;
		}
	}
	public abstract class JsonReader : IDisposable
	{
		protected enum State
		{
			Start,
			Complete,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			Closed,
			PostValue,
			ConstructorStart,
			Constructor,
			Error,
			Finished
		}

		private JsonToken _token;

		private object _value;

		private Type _valueType;

		private char _quoteChar;

		private State _currentState;

		private PlayFab.Json.Linq.JTokenType _currentTypeContext;

		private int _top;

		private readonly List<PlayFab.Json.Linq.JTokenType> _stack;

		protected State CurrentState => _currentState;

		public bool CloseInput { get; set; }

		public virtual char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			protected internal set
			{
				_quoteChar = value;
			}
		}

		public virtual JsonToken TokenType => _token;

		public virtual object Value => _value;

		public virtual Type ValueType => _valueType;

		public virtual int Depth
		{
			get
			{
				int num = _top - 1;
				if (IsStartToken(TokenType))
				{
					return num - 1;
				}
				return num;
			}
		}

		protected JsonReader()
		{
			_currentState = State.Start;
			_stack = new List<PlayFab.Json.Linq.JTokenType>();
			CloseInput = true;
			Push(PlayFab.Json.Linq.JTokenType.None);
		}

		private void Push(PlayFab.Json.Linq.JTokenType value)
		{
			_stack.Add(value);
			_top++;
			_currentTypeContext = value;
		}

		private PlayFab.Json.Linq.JTokenType Pop()
		{
			PlayFab.Json.Linq.JTokenType result = Peek();
			_stack.RemoveAt(_stack.Count - 1);
			_top--;
			_currentTypeContext = _stack[_top - 1];
			return result;
		}

		private PlayFab.Json.Linq.JTokenType Peek()
		{
			return _currentTypeContext;
		}

		public abstract bool Read();

		public abstract byte[] ReadAsBytes();

		public abstract decimal? ReadAsDecimal();

		public abstract DateTimeOffset? ReadAsDateTimeOffset();

		public void Skip()
		{
			if (IsStartToken(TokenType))
			{
				int depth = Depth;
				while (Read() && depth < Depth)
				{
				}
			}
		}

		protected void SetToken(JsonToken newToken)
		{
			SetToken(newToken, null);
		}

		protected virtual void SetToken(JsonToken newToken, object value)
		{
			_token = newToken;
			switch (newToken)
			{
			case JsonToken.StartObject:
				_currentState = State.ObjectStart;
				Push(PlayFab.Json.Linq.JTokenType.Object);
				break;
			case JsonToken.StartArray:
				_currentState = State.ArrayStart;
				Push(PlayFab.Json.Linq.JTokenType.Array);
				break;
			case JsonToken.StartConstructor:
				_currentState = State.ConstructorStart;
				Push(PlayFab.Json.Linq.JTokenType.Constructor);
				break;
			case JsonToken.EndObject:
				ValidateEnd(JsonToken.EndObject);
				_currentState = State.PostValue;
				break;
			case JsonToken.EndArray:
				ValidateEnd(JsonToken.EndArray);
				_currentState = State.PostValue;
				break;
			case JsonToken.EndConstructor:
				ValidateEnd(JsonToken.EndConstructor);
				_currentState = State.PostValue;
				break;
			case JsonToken.PropertyName:
				_currentState = State.Property;
				Push(PlayFab.Json.Linq.JTokenType.Property);
				break;
			case JsonToken.Raw:
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				_currentState = State.PostValue;
				break;
			}
			PlayFab.Json.Linq.JTokenType jTokenType = Peek();
			if (jTokenType == PlayFab.Json.Linq.JTokenType.Property && _currentState == State.PostValue)
			{
				Pop();
			}
			if (value != null)
			{
				_value = value;
				_valueType = value.GetType();
			}
			else
			{
				_value = null;
				_valueType = null;
			}
		}

		private void ValidateEnd(JsonToken endToken)
		{
			PlayFab.Json.Linq.JTokenType jTokenType = Pop();
			if (GetTypeForCloseToken(endToken) != jTokenType)
			{
				throw new JsonReaderException(PlayFab.Json.Utilities.StringUtils.FormatWith("JsonToken {0} is not valid for closing JsonType {1}.", CultureInfo.InvariantCulture, endToken, jTokenType));
			}
		}

		protected void SetStateBasedOnCurrent()
		{
			PlayFab.Json.Linq.JTokenType jTokenType = Peek();
			switch (jTokenType)
			{
			case PlayFab.Json.Linq.JTokenType.Object:
				_currentState = State.Object;
				break;
			case PlayFab.Json.Linq.JTokenType.Array:
				_currentState = State.Array;
				break;
			case PlayFab.Json.Linq.JTokenType.Constructor:
				_currentState = State.Constructor;
				break;
			case PlayFab.Json.Linq.JTokenType.None:
				_currentState = State.Finished;
				break;
			default:
				throw new JsonReaderException(PlayFab.Json.Utilities.StringUtils.FormatWith("While setting the reader state back to current object an unexpected JsonType was encountered: {0}", CultureInfo.InvariantCulture, jTokenType));
			}
		}

		internal static bool IsPrimitiveToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsStartToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.StartObject:
			case JsonToken.StartArray:
			case JsonToken.StartConstructor:
			case JsonToken.PropertyName:
				return true;
			case JsonToken.None:
			case JsonToken.Comment:
			case JsonToken.Raw:
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.EndObject:
			case JsonToken.EndArray:
			case JsonToken.EndConstructor:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return false;
			default:
				throw PlayFab.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("token", token, "Unexpected JsonToken value.");
			}
		}

		private PlayFab.Json.Linq.JTokenType GetTypeForCloseToken(JsonToken token)
		{
			return token switch
			{
				JsonToken.EndObject => PlayFab.Json.Linq.JTokenType.Object, 
				JsonToken.EndArray => PlayFab.Json.Linq.JTokenType.Array, 
				JsonToken.EndConstructor => PlayFab.Json.Linq.JTokenType.Constructor, 
				_ => throw new JsonReaderException(PlayFab.Json.Utilities.StringUtils.FormatWith("Not a valid close JsonToken: {0}", CultureInfo.InvariantCulture, token)), 
			};
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_currentState != State.Closed && disposing)
			{
				Close();
			}
		}

		public virtual void Close()
		{
			_currentState = State.Closed;
			_token = JsonToken.None;
			_value = null;
			_valueType = null;
		}
	}
	public class JsonReaderException : Exception
	{
		public int LineNumber { get; private set; }

		public int LinePosition { get; private set; }

		public JsonReaderException()
		{
		}

		public JsonReaderException(string message)
			: base(message)
		{
		}

		public JsonReaderException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		internal JsonReaderException(string message, Exception innerException, int lineNumber, int linePosition)
			: base(message, innerException)
		{
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}
	}
	public class JsonSerializationException : Exception
	{
		public JsonSerializationException()
		{
		}

		public JsonSerializationException(string message)
			: base(message)
		{
		}

		public JsonSerializationException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
	public class JsonSerializer
	{
		private TypeNameHandling _typeNameHandling;

		private FormatterAssemblyStyle _typeNameAssemblyFormat;

		private PreserveReferencesHandling _preserveReferencesHandling;

		private ReferenceLoopHandling _referenceLoopHandling;

		private MissingMemberHandling _missingMemberHandling;

		private ObjectCreationHandling _objectCreationHandling;

		private NullValueHandling _nullValueHandling;

		private DefaultValueHandling _defaultValueHandling;

		private ConstructorHandling _constructorHandling;

		private JsonConverterCollection _converters;

		private PlayFab.Json.Serialization.IContractResolver _contractResolver;

		private PlayFab.Json.Serialization.IReferenceResolver _referenceResolver;

		private SerializationBinder _binder;

		private StreamingContext _context;

		public virtual PlayFab.Json.Serialization.IReferenceResolver ReferenceResolver
		{
			get
			{
				if (_referenceResolver == null)
				{
					_referenceResolver = new PlayFab.Json.Serialization.DefaultReferenceResolver();
				}
				return _referenceResolver;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Reference resolver cannot be null.");
				}
				_referenceResolver = value;
			}
		}

		public virtual SerializationBinder Binder
		{
			get
			{
				return _binder;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Serialization binder cannot be null.");
				}
				_binder = value;
			}
		}

		public virtual TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling;
			}
			set
			{
				if (value < TypeNameHandling.None || value > TypeNameHandling.Auto)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameHandling = value;
			}
		}

		public virtual FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _typeNameAssemblyFormat;
			}
			set
			{
				if (value < FormatterAssemblyStyle.Simple || value > FormatterAssemblyStyle.Full)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameAssemblyFormat = value;
			}
		}

		public virtual PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _preserveReferencesHandling;
			}
			set
			{
				if (value < PreserveReferencesHandling.None || value > PreserveReferencesHandling.All)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_preserveReferencesHandling = value;
			}
		}

		public virtual ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling;
			}
			set
			{
				if (value < ReferenceLoopHandling.Error || value > ReferenceLoopHandling.Serialize)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_referenceLoopHandling = value;
			}
		}

		public virtual MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _missingMemberHandling;
			}
			set
			{
				if (value < MissingMemberHandling.Ignore || value > MissingMemberHandling.Error)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_missingMemberHandling = value;
			}
		}

		public virtual NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling;
			}
			set
			{
				if (value < NullValueHandling.Include || value > NullValueHandling.Ignore)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_nullValueHandling = value;
			}
		}

		public virtual DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling;
			}
			set
			{
				if (value < DefaultValueHandling.Include || value > DefaultValueHandling.IgnoreAndPopulate)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_defaultValueHandling = value;
			}
		}

		public virtual ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling;
			}
			set
			{
				if (value < ObjectCreationHandling.Auto || value > ObjectCreationHandling.Replace)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_objectCreationHandling = value;
			}
		}

		public virtual ConstructorHandling ConstructorHandling
		{
			get
			{
				return _constructorHandling;
			}
			set
			{
				if (value < ConstructorHandling.Default || value > ConstructorHandling.AllowNonPublicDefaultConstructor)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_constructorHandling = value;
			}
		}

		public virtual JsonConverterCollection Converters
		{
			get
			{
				if (_converters == null)
				{
					_converters = new JsonConverterCollection();
				}
				return _converters;
			}
		}

		public virtual PlayFab.Json.Serialization.IContractResolver ContractResolver
		{
			get
			{
				if (_contractResolver == null)
				{
					_contractResolver = PlayFab.Json.Serialization.DefaultContractResolver.Instance;
				}
				return _contractResolver;
			}
			set
			{
				_contractResolver = value;
			}
		}

		public virtual StreamingContext Context
		{
			get
			{
				return _context;
			}
			set
			{
				_context = value;
			}
		}

		public virtual event EventHandler<PlayFab.Json.Serialization.ErrorEventArgs> Error;

		public JsonSerializer()
		{
			_referenceLoopHandling = ReferenceLoopHandling.Error;
			_missingMemberHandling = MissingMemberHandling.Ignore;
			_nullValueHandling = NullValueHandling.Include;
			_defaultValueHandling = DefaultValueHandling.Include;
			_objectCreationHandling = ObjectCreationHandling.Auto;
			_preserveReferencesHandling = PreserveReferencesHandling.None;
			_constructorHandling = ConstructorHandling.Default;
			_typeNameHandling = TypeNameHandling.None;
			_context = JsonSerializerSettings.DefaultContext;
			_binder = PlayFab.Json.Serialization.DefaultSerializationBinder.Instance;
		}

		public static JsonSerializer Create(JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = new JsonSerializer();
			if (settings != null)
			{
				if (!PlayFab.Json.Utilities.CollectionUtils.IsNullOrEmpty(settings.Converters))
				{
					PlayFab.Json.Utilities.CollectionUtils.AddRange(jsonSerializer.Converters, settings.Converters);
				}
				jsonSerializer.TypeNameHandling = settings.TypeNameHandling;
				jsonSerializer.TypeNameAssemblyFormat = settings.TypeNameAssemblyFormat;
				jsonSerializer.PreserveReferencesHandling = settings.PreserveReferencesHandling;
				jsonSerializer.ReferenceLoopHandling = settings.ReferenceLoopHandling;
				jsonSerializer.MissingMemberHandling = settings.MissingMemberHandling;
				jsonSerializer.ObjectCreationHandling = settings.ObjectCreationHandling;
				jsonSerializer.NullValueHandling = settings.NullValueHandling;
				jsonSerializer.DefaultValueHandling = settings.DefaultValueHandling;
				jsonSerializer.ConstructorHandling = settings.ConstructorHandling;
				jsonSerializer.Context = settings.Context;
				if (settings.Error != null)
				{
					jsonSerializer.Error += settings.Error;
				}
				if (settings.ContractResolver != null)
				{
					jsonSerializer.ContractResolver = settings.ContractResolver;
				}
				if (settings.ReferenceResolver != null)
				{
					jsonSerializer.ReferenceResolver = settings.ReferenceResolver;
				}
				if (settings.Binder != null)
				{
					jsonSerializer.Binder = settings.Binder;
				}
			}
			return jsonSerializer;
		}

		public void Populate(TextReader reader, object target)
		{
			Populate(new JsonTextReader(reader), target);
		}

		public void Populate(JsonReader reader, object target)
		{
			PopulateInternal(reader, target);
		}

		internal virtual void PopulateInternal(JsonReader reader, object target)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(target, "target");
			PlayFab.Json.Serialization.JsonSerializerInternalReader jsonSerializerInternalReader = new PlayFab.Json.Serialization.JsonSerializerInternalReader(this);
			jsonSerializerInternalReader.Populate(reader, target);
		}

		public object Deserialize(JsonReader reader)
		{
			return Deserialize(reader, null);
		}

		public object Deserialize(TextReader reader, Type objectType)
		{
			return Deserialize(new JsonTextReader(reader), objectType);
		}

		public T Deserialize<T>(JsonReader reader)
		{
			return (T)Deserialize(reader, typeof(T));
		}

		public object Deserialize(JsonReader reader, Type objectType)
		{
			return DeserializeInternal(reader, objectType);
		}

		internal virtual object DeserializeInternal(JsonReader reader, Type objectType)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			PlayFab.Json.Serialization.JsonSerializerInternalReader jsonSerializerInternalReader = new PlayFab.Json.Serialization.JsonSerializerInternalReader(this);
			return jsonSerializerInternalReader.Deserialize(reader, objectType);
		}

		public void Serialize(TextWriter textWriter, object value)
		{
			Serialize(new JsonTextWriter(textWriter), value);
		}

		public void Serialize(JsonWriter jsonWriter, object value)
		{
			SerializeInternal(jsonWriter, value);
		}

		internal virtual void SerializeInternal(JsonWriter jsonWriter, object value)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(jsonWriter, "jsonWriter");
			PlayFab.Json.Serialization.JsonSerializerInternalWriter jsonSerializerInternalWriter = new PlayFab.Json.Serialization.JsonSerializerInternalWriter(this);
			jsonSerializerInternalWriter.Serialize(jsonWriter, value);
		}

		internal JsonConverter GetMatchingConverter(Type type)
		{
			return GetMatchingConverter(_converters, type);
		}

		internal static JsonConverter GetMatchingConverter(IList<JsonConverter> converters, Type objectType)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(objectType, "objectType");
			if (converters != null)
			{
				for (int i = 0; i < converters.Count; i++)
				{
					JsonConverter jsonConverter = converters[i];
					if (jsonConverter.CanConvert(objectType))
					{
						return jsonConverter;
					}
				}
			}
			return null;
		}

		internal void OnError(PlayFab.Json.Serialization.ErrorEventArgs e)
		{
			this.Error?.Invoke(this, e);
		}
	}
	public class JsonSerializerSettings
	{
		internal const ReferenceLoopHandling DefaultReferenceLoopHandling = ReferenceLoopHandling.Error;

		internal const MissingMemberHandling DefaultMissingMemberHandling = MissingMemberHandling.Ignore;

		internal const NullValueHandling DefaultNullValueHandling = NullValueHandling.Include;

		internal const DefaultValueHandling DefaultDefaultValueHandling = DefaultValueHandling.Include;

		internal const ObjectCreationHandling DefaultObjectCreationHandling = ObjectCreationHandling.Auto;

		internal const PreserveReferencesHandling DefaultPreserveReferencesHandling = PreserveReferencesHandling.None;

		internal const ConstructorHandling DefaultConstructorHandling = ConstructorHandling.Default;

		internal const TypeNameHandling DefaultTypeNameHandling = TypeNameHandling.None;

		internal const FormatterAssemblyStyle DefaultTypeNameAssemblyFormat = FormatterAssemblyStyle.Simple;

		internal static readonly StreamingContext DefaultContext = default(StreamingContext);

		public ReferenceLoopHandling ReferenceLoopHandling { get; set; }

		public MissingMemberHandling MissingMemberHandling { get; set; }

		public ObjectCreationHandling ObjectCreationHandling { get; set; }

		public NullValueHandling NullValueHandling { get; set; }

		public DefaultValueHandling DefaultValueHandling { get; set; }

		public IList<JsonConverter> Converters { get; set; }

		public PreserveReferencesHandling PreserveReferencesHandling { get; set; }

		public TypeNameHandling TypeNameHandling { get; set; }

		public FormatterAssemblyStyle TypeNameAssemblyFormat { get; set; }

		public ConstructorHandling ConstructorHandling { get; set; }

		public PlayFab.Json.Serialization.IContractResolver ContractResolver { get; set; }

		public PlayFab.Json.Serialization.IReferenceResolver ReferenceResolver { get; set; }

		public SerializationBinder Binder { get; set; }

		public EventHandler<PlayFab.Json.Serialization.ErrorEventArgs> Error { get; set; }

		public StreamingContext Context { get; set; }

		public JsonSerializerSettings()
		{
			ReferenceLoopHandling = ReferenceLoopHandling.Error;
			MissingMemberHandling = MissingMemberHandling.Ignore;
			ObjectCreationHandling = ObjectCreationHandling.Auto;
			NullValueHandling = NullValueHandling.Include;
			DefaultValueHandling = DefaultValueHandling.Include;
			PreserveReferencesHandling = PreserveReferencesHandling.None;
			TypeNameHandling = TypeNameHandling.None;
			TypeNameAssemblyFormat = FormatterAssemblyStyle.Simple;
			Context = DefaultContext;
			Converters = new List<JsonConverter>();
		}
	}
	public class JsonTextReader : JsonReader, IJsonLineInfo
	{
		private enum ReadType
		{
			Read,
			ReadAsBytes,
			ReadAsDecimal,
			ReadAsDateTimeOffset
		}

		private readonly TextReader _reader;

		private readonly PlayFab.Json.Utilities.StringBuffer _buffer;

		private char? _lastChar;

		private int _currentLinePosition;

		private int _currentLineNumber;

		private bool _end;

		private ReadType _readType;

		private CultureInfo _culture;

		private const int LineFeedValue = 10;

		private const int CarriageReturnValue = 13;

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.CurrentCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public int LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return _currentLineNumber;
			}
		}

		public int LinePosition => _currentLinePosition;

		public JsonTextReader(TextReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			_reader = reader;
			_buffer = new PlayFab.Json.Utilities.StringBuffer(4096);
			_currentLineNumber = 1;
		}

		private void ParseString(char quote)
		{
			ReadStringIntoBuffer(quote);
			if (_readType == ReadType.ReadAsBytes)
			{
				byte[] value;
				if (_buffer.Position == 0)
				{
					value = new byte[0];
				}
				else
				{
					value = Convert.FromBase64CharArray(_buffer.GetInternalBuffer(), 0, _buffer.Position);
					_buffer.Position = 0;
				}
				SetToken(JsonToken.Bytes, value);
				return;
			}
			string text = _buffer.ToString();
			_buffer.Position = 0;
			if (text.StartsWith("/Date(", StringComparison.Ordinal) && text.EndsWith(")/", StringComparison.Ordinal))
			{
				ParseDate(text);
				return;
			}
			SetToken(JsonToken.String, text);
			QuoteChar = quote;
		}

		private void ReadStringIntoBuffer(char quote)
		{
			while (true)
			{
				char c = MoveNext();
				switch (c)
				{
				case '\0':
					if (_end)
					{
						throw CreateJsonReaderException("Unterminated string. Expected delimiter: {0}. Line {1}, position {2}.", quote, _currentLineNumber, _currentLinePosition);
					}
					_buffer.Append('\0');
					break;
				case '\\':
					if ((c = MoveNext()) != 0 || !_end)
					{
						switch (c)
						{
						case 'b':
							_buffer.Append('\b');
							break;
						case 't':
							_buffer.Append('\t');
							break;
						case 'n':
							_buffer.Append('\n');
							break;
						case 'f':
							_buffer.Append('\f');
							break;
						case 'r':
							_buffer.Append('\r');
							break;
						case '\\':
							_buffer.Append('\\');
							break;
						case '"':
						case '\'':
						case '/':
							_buffer.Append(c);
							break;
						case 'u':
						{
							char[] array = new char[4];
							for (int i = 0; i < array.Length; i++)
							{
								if ((c = MoveNext()) != 0 || !_end)
								{
									array[i] = c;
									continue;
								}
								throw CreateJsonReaderException("Unexpected end while parsing unicode character. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
							}
							char value = Convert.ToChar(int.Parse(new string(array), NumberStyles.HexNumber, NumberFormatInfo.InvariantInfo));
							_buffer.Append(value);
							break;
						}
						default:
							throw CreateJsonReaderException("Bad JSON escape sequence: {0}. Line {1}, position {2}.", "\\" + c, _currentLineNumber, _currentLinePosition);
						}
						break;
					}
					throw CreateJsonReaderException("Unterminated string. Expected delimiter: {0}. Line {1}, position {2}.", quote, _currentLineNumber, _currentLinePosition);
				case '"':
				case '\'':
					if (c == quote)
					{
						return;
					}
					_buffer.Append(c);
					break;
				default:
					_buffer.Append(c);
					break;
				}
			}
		}

		private JsonReaderException CreateJsonReaderException(string format, params object[] args)
		{
			string message = format.FormatWith(CultureInfo.InvariantCulture, args);
			return new JsonReaderException(message, null, _currentLineNumber, _currentLinePosition);
		}

		private TimeSpan ReadOffset(string offsetText)
		{
			bool flag = offsetText[0] == '-';
			int num = int.Parse(offsetText.Substring(1, 2), NumberStyles.Integer, CultureInfo.InvariantCulture);
			int num2 = 0;
			if (offsetText.Length >= 5)
			{
				num2 = int.Parse(offsetText.Substring(3, 2), NumberStyles.Integer, CultureInfo.InvariantCulture);
			}
			TimeSpan result = TimeSpan.FromHours(num) + TimeSpan.FromMinutes(num2);
			if (flag)
			{
				result = result.Negate();
			}
			return result;
		}

		private void ParseDate(string text)
		{
			string text2 = text.Substring(6, text.Length - 8);
			DateTimeKind dateTimeKind = DateTimeKind.Utc;
			int num = text2.IndexOf('+', 1);
			if (num == -1)
			{
				num = text2.IndexOf('-', 1);
			}
			TimeSpan timeSpan = TimeSpan.Zero;
			if (num != -1)
			{
				dateTimeKind = DateTimeKind.Local;
				timeSpan = ReadOffset(text2.Substring(num));
				text2 = text2.Substring(0, num);
			}
			long javaScriptTicks = long.Parse(text2, NumberStyles.Integer, CultureInfo.InvariantCulture);
			DateTime dateTime = JsonConvert.ConvertJavaScriptTicksToDateTime(javaScriptTicks);
			if (_readType == ReadType.ReadAsDateTimeOffset)
			{
				SetToken(JsonToken.Date, new DateTimeOffset(dateTime.Add(timeSpan).Ticks, timeSpan));
				return;
			}
			SetToken(JsonToken.Date, dateTimeKind switch
			{
				DateTimeKind.Unspecified => DateTime.SpecifyKind(dateTime.ToLocalTime(), DateTimeKind.Unspecified), 
				DateTimeKind.Local => dateTime.ToLocalTime(), 
				_ => dateTime, 
			});
		}

		private char MoveNext()
		{
			int num = _reader.Read();
			switch (num)
			{
			case -1:
				_end = true;
				return '\0';
			case 13:
				if (_reader.Peek() == 10)
				{
					_reader.Read();
				}
				_currentLineNumber++;
				_currentLinePosition = 0;
				break;
			case 10:
				_currentLineNumber++;
				_currentLinePosition = 0;
				break;
			default:
				_currentLinePosition++;
				break;
			}
			return (char)num;
		}

		private bool HasNext()
		{
			return _reader.Peek() != -1;
		}

		private int PeekNext()
		{
			return _reader.Peek();
		}

		public override bool Read()
		{
			_readType = ReadType.Read;
			return ReadInternal();
		}

		public override byte[] ReadAsBytes()
		{
			_readType = ReadType.ReadAsBytes;
			do
			{
				if (!ReadInternal())
				{
					throw CreateJsonReaderException("Unexpected end when reading bytes: Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
				}
			}
			while (TokenType == JsonToken.Comment);
			if (TokenType == JsonToken.Null)
			{
				return null;
			}
			if (TokenType == JsonToken.Bytes)
			{
				return (byte[])Value;
			}
			if (TokenType == JsonToken.StartArray)
			{
				List<byte> list = new List<byte>();
				while (ReadInternal())
				{
					switch (TokenType)
					{
					case JsonToken.Integer:
						list.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));
						break;
					case JsonToken.EndArray:
					{
						byte[] array = list.ToArray();
						SetToken(JsonToken.Bytes, array);
						return array;
					}
					default:
						throw CreateJsonReaderException("Unexpected token when reading bytes: {0}. Line {1}, position {2}.", TokenType, _currentLineNumber, _currentLinePosition);
					case JsonToken.Comment:
						break;
					}
				}
				throw CreateJsonReaderException("Unexpected end when reading bytes: Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
			}
			throw CreateJsonReaderException("Unexpected token when reading bytes: {0}. Line {1}, position {2}.", TokenType, _currentLineNumber, _currentLinePosition);
		}

		public override decimal? ReadAsDecimal()
		{
			_readType = ReadType.ReadAsDecimal;
			do
			{
				if (!ReadInternal())
				{
					throw CreateJsonReaderException("Unexpected end when reading decimal: Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
				}
			}
			while (TokenType == JsonToken.Comment);
			if (TokenType == JsonToken.Null)
			{
				return null;
			}
			if (TokenType == JsonToken.Float)
			{
				return (decimal?)Value;
			}
			if (TokenType == JsonToken.String && decimal.TryParse((string)Value, NumberStyles.Number, Culture, out var result))
			{
				SetToken(JsonToken.Float, result);
				return result;
			}
			throw CreateJsonReaderException("Unexpected token when reading decimal: {0}. Line {1}, position {2}.", TokenType, _currentLineNumber, _currentLinePosition);
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			_readType = ReadType.ReadAsDateTimeOffset;
			do
			{
				if (!ReadInternal())
				{
					throw CreateJsonReaderException("Unexpected end when reading date: Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
				}
			}
			while (TokenType == JsonToken.Comment);
			if (TokenType == JsonToken.Null)
			{
				return null;
			}
			if (TokenType == JsonToken.Date)
			{
				return (DateTimeOffset)Value;
			}
			if (TokenType == JsonToken.String && DateTimeOffset.TryParse((string)Value, Culture, DateTimeStyles.None, out var result))
			{
				SetToken(JsonToken.Date, result);
				return result;
			}
			throw CreateJsonReaderException("Unexpected token when reading date: {0}. Line {1}, position {2}.", TokenType, _currentLineNumber, _currentLinePosition);
		}

		private bool ReadInternal()
		{
			while (true)
			{
				char? lastChar = _lastChar;
				char c;
				if (lastChar.HasValue)
				{
					c = _lastChar.Value;
					_lastChar = null;
				}
				else
				{
					c = MoveNext();
				}
				if (c == '\0' && _end)
				{
					break;
				}
				switch (base.CurrentState)
				{
				case State.Complete:
				case State.Closed:
				case State.Error:
					break;
				case State.Start:
				case State.Property:
				case State.ArrayStart:
				case State.Array:
				case State.ConstructorStart:
				case State.Constructor:
					return ParseValue(c);
				case State.ObjectStart:
				case State.Object:
					return ParseObject(c);
				case State.PostValue:
					if (ParsePostValue(c))
					{
						return true;
					}
					break;
				default:
					throw CreateJsonReaderException("Unexpected state: {0}. Line {1}, position {2}.", base.CurrentState, _currentLineNumber, _currentLinePosition);
				}
			}
			return false;
		}

		private bool ParsePostValue(char currentChar)
		{
			do
			{
				switch (currentChar)
				{
				case '}':
					SetToken(JsonToken.EndObject);
					return true;
				case ']':
					SetToken(JsonToken.EndArray);
					return true;
				case ')':
					SetToken(JsonToken.EndConstructor);
					return true;
				case '/':
					ParseComment();
					return true;
				case ',':
					SetStateBasedOnCurrent();
					return false;
				case '\t':
				case '\n':
				case '\r':
				case ' ':
					continue;
				}
				if (char.IsWhiteSpace(currentChar))
				{
					continue;
				}
				throw CreateJsonReaderException("After parsing a value an unexpected character was encountered: {0}. Line {1}, position {2}.", currentChar, _currentLineNumber, _currentLinePosition);
			}
			while ((currentChar = MoveNext()) != 0 || !_end);
			return false;
		}

		private bool ParseObject(char currentChar)
		{
			do
			{
				switch (currentChar)
				{
				case '}':
					SetToken(JsonToken.EndObject);
					return true;
				case '/':
					ParseComment();
					return true;
				case '\t':
				case '\n':
				case '\r':
				case ' ':
					continue;
				}
				if (char.IsWhiteSpace(currentChar))
				{
					continue;
				}
				return ParseProperty(currentChar);
			}
			while ((currentChar = MoveNext()) != 0 || !_end);
			return false;
		}

		private bool ParseProperty(char firstChar)
		{
			char c = firstChar;
			char c2;
			if (ValidIdentifierChar(c))
			{
				c2 = '\0';
				c = ParseUnquotedProperty(c);
			}
			else
			{
				if (c != '"' && c != '\'')
				{
					throw CreateJsonReaderException("Invalid property identifier character: {0}. Line {1}, position {2}.", c, _currentLineNumber, _currentLinePosition);
				}
				c2 = c;
				ReadStringIntoBuffer(c2);
				c = MoveNext();
			}
			if (c != ':')
			{
				c = MoveNext();
				EatWhitespace(c, oneOrMore: false, out c);
				if (c != ':')
				{
					throw CreateJsonReaderException("Invalid character after parsing property name. Expected ':' but got: {0}. Line {1}, position {2}.", c, _currentLineNumber, _currentLinePosition);
				}
			}
			SetToken(JsonToken.PropertyName, _buffer.ToString());
			QuoteChar = c2;
			_buffer.Position = 0;
			return true;
		}

		private bool ValidIdentifierChar(char value)
		{
			return char.IsLetterOrDigit(value) || value == '_' || value == '$';
		}

		private char ParseUnquotedProperty(char firstChar)
		{
			_buffer.Append(firstChar);
			char c;
			while ((c = MoveNext()) != 0 || !_end)
			{
				if (char.IsWhiteSpace(c) || c == ':')
				{
					return c;
				}
				if (ValidIdentifierChar(c))
				{
					_buffer.Append(c);
					continue;
				}
				throw CreateJsonReaderException("Invalid JavaScript property identifier character: {0}. Line {1}, position {2}.", c, _currentLineNumber, _currentLinePosition);
			}
			throw CreateJsonReaderException("Unexpected end when parsing unquoted property name. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private bool ParseValue(char currentChar)
		{
			do
			{
				switch (currentChar)
				{
				case '"':
				case '\'':
					ParseString(currentChar);
					return true;
				case 't':
					ParseTrue();
					return true;
				case 'f':
					ParseFalse();
					return true;
				case 'n':
					if (HasNext())
					{
						switch ((char)(ushort)PeekNext())
						{
						case 'u':
							ParseNull();
							break;
						case 'e':
							ParseConstructor();
							break;
						default:
							throw CreateJsonReaderException("Unexpected character encountered while parsing value: {0}. Line {1}, position {2}.", currentChar, _currentLineNumber, _currentLinePosition);
						}
						return true;
					}
					throw CreateJsonReaderException("Unexpected end. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
				case 'N':
					ParseNumberNaN();
					return true;
				case 'I':
					ParseNumberPositiveInfinity();
					return true;
				case '-':
					if (PeekNext() == 73)
					{
						ParseNumberNegativeInfinity();
					}
					else
					{
						ParseNumber(currentChar);
					}
					return true;
				case '/':
					ParseComment();
					return true;
				case 'u':
					ParseUndefined();
					return true;
				case '{':
					SetToken(JsonToken.StartObject);
					return true;
				case '[':
					SetToken(JsonToken.StartArray);
					return true;
				case '}':
					SetToken(JsonToken.EndObject);
					return true;
				case ']':
					SetToken(JsonToken.EndArray);
					return true;
				case ',':
					SetToken(JsonToken.Undefined);
					return true;
				case ')':
					SetToken(JsonToken.EndConstructor);
					return true;
				default:
					if (char.IsWhiteSpace(currentChar))
					{
						break;
					}
					if (char.IsNumber(currentChar) || currentChar == '-' || currentChar == '.')
					{
						ParseNumber(currentChar);
						return true;
					}
					throw CreateJsonReaderException("Unexpected character encountered while parsing value: {0}. Line {1}, position {2}.", currentChar, _currentLineNumber, _currentLinePosition);
				case '\t':
				case '\n':
				case '\r':
				case ' ':
					break;
				}
			}
			while ((currentChar = MoveNext()) != 0 || !_end);
			return false;
		}

		private bool EatWhitespace(char initialChar, bool oneOrMore, out char finalChar)
		{
			bool flag = false;
			char c = initialChar;
			while (c == ' ' || char.IsWhiteSpace(c))
			{
				flag = true;
				c = MoveNext();
			}
			finalChar = c;
			return !oneOrMore || flag;
		}

		private void ParseConstructor()
		{
			if (!MatchValue('n', "new", noTrailingNonSeperatorCharacters: true))
			{
				return;
			}
			char finalChar = MoveNext();
			if (EatWhitespace(finalChar, oneOrMore: true, out finalChar))
			{
				while (char.IsLetter(finalChar))
				{
					_buffer.Append(finalChar);
					finalChar = MoveNext();
				}
				EatWhitespace(finalChar, oneOrMore: false, out finalChar);
				if (finalChar != '(')
				{
					throw CreateJsonReaderException("Unexpected character while parsing constructor: {0}. Line {1}, position {2}.", finalChar, _currentLineNumber, _currentLinePosition);
				}
				string value = _buffer.ToString();
				_buffer.Position = 0;
				SetToken(JsonToken.StartConstructor, value);
			}
		}

		private void ParseNumber(char firstChar)
		{
			char c = firstChar;
			bool flag = false;
			do
			{
				if (IsSeperator(c))
				{
					flag = true;
					_lastChar = c;
				}
				else
				{
					_buffer.Append(c);
				}
			}
			while (!flag && ((c = MoveNext()) != 0 || !_end));
			string text = _buffer.ToString();
			bool flag2 = firstChar == '0' && !text.StartsWith("0.", StringComparison.OrdinalIgnoreCase);
			object value2;
			JsonToken newToken;
			if (_readType == ReadType.ReadAsDecimal)
			{
				if (flag2)
				{
					long value = ((!text.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) ? Convert.ToInt64(text, 8) : Convert.ToInt64(text, 16));
					value2 = Convert.ToDecimal(value);
				}
				else
				{
					value2 = decimal.Parse(text, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture);
				}
				newToken = JsonToken.Float;
			}
			else if (flag2)
			{
				value2 = ((!text.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) ? Convert.ToInt64(text, 8) : Convert.ToInt64(text, 16));
				newToken = JsonToken.Integer;
			}
			else if (text.IndexOf(".", StringComparison.OrdinalIgnoreCase) != -1 || text.IndexOf("e", StringComparison.OrdinalIgnoreCase) != -1)
			{
				value2 = Convert.ToDouble(text, CultureInfo.InvariantCulture);
				newToken = JsonToken.Float;
			}
			else
			{
				try
				{
					value2 = Convert.ToInt64(text, CultureInfo.InvariantCulture);
				}
				catch (OverflowException innerException)
				{
					throw new JsonReaderException(PlayFab.Json.Utilities.StringUtils.FormatWith("JSON integer {0} is too large or small for an Int64.", CultureInfo.InvariantCulture, text), innerException);
				}
				newToken = JsonToken.Integer;
			}
			_buffer.Position = 0;
			SetToken(newToken, value2);
		}

		private void ParseComment()
		{
			char c = MoveNext();
			if (c == '*')
			{
				while ((c = MoveNext()) != 0 || !_end)
				{
					if (c == '*')
					{
						if ((c = MoveNext()) != 0 || !_end)
						{
							if (c == '/')
							{
								break;
							}
							_buffer.Append('*');
							_buffer.Append(c);
						}
					}
					else
					{
						_buffer.Append(c);
					}
				}
				SetToken(JsonToken.Comment, _buffer.ToString());
				_buffer.Position = 0;
				return;
			}
			throw CreateJsonReaderException("Error parsing comment. Expected: *. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private bool MatchValue(char firstChar, string value)
		{
			char c = firstChar;
			int num = 0;
			while (c == value[num])
			{
				num++;
				if (num >= value.Length || ((c = MoveNext()) == '\0' && _end))
				{
					break;
				}
			}
			return num == value.Length;
		}

		private bool MatchValue(char firstChar, string value, bool noTrailingNonSeperatorCharacters)
		{
			bool flag = MatchValue(firstChar, value);
			if (!noTrailingNonSeperatorCharacters)
			{
				return flag;
			}
			int num = PeekNext();
			char c = ((num != -1) ? ((char)num) : '\0');
			return flag && (c == '\0' || IsSeperator(c));
		}

		private bool IsSeperator(char c)
		{
			switch (c)
			{
			case ',':
			case ']':
			case '}':
				return true;
			case '/':
				return HasNext() && PeekNext() == 42;
			case ')':
				if (base.CurrentState == State.Constructor || base.CurrentState == State.ConstructorStart)
				{
					return true;
				}
				break;
			case '\t':
			case '\n':
			case '\r':
			case ' ':
				return true;
			default:
				if (char.IsWhiteSpace(c))
				{
					return true;
				}
				break;
			}
			return false;
		}

		private void ParseTrue()
		{
			if (MatchValue('t', JsonConvert.True, noTrailingNonSeperatorCharacters: true))
			{
				SetToken(JsonToken.Boolean, true);
				return;
			}
			throw CreateJsonReaderException("Error parsing boolean value. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private void ParseNull()
		{
			if (MatchValue('n', JsonConvert.Null, noTrailingNonSeperatorCharacters: true))
			{
				SetToken(JsonToken.Null);
				return;
			}
			throw CreateJsonReaderException("Error parsing null value. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private void ParseUndefined()
		{
			if (MatchValue('u', JsonConvert.Undefined, noTrailingNonSeperatorCharacters: true))
			{
				SetToken(JsonToken.Undefined);
				return;
			}
			throw CreateJsonReaderException("Error parsing undefined value. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private void ParseFalse()
		{
			if (MatchValue('f', JsonConvert.False, noTrailingNonSeperatorCharacters: true))
			{
				SetToken(JsonToken.Boolean, false);
				return;
			}
			throw CreateJsonReaderException("Error parsing boolean value. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private void ParseNumberNegativeInfinity()
		{
			if (MatchValue('-', JsonConvert.NegativeInfinity, noTrailingNonSeperatorCharacters: true))
			{
				SetToken(JsonToken.Float, double.NegativeInfinity);
				return;
			}
			throw CreateJsonReaderException("Error parsing negative infinity value. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private void ParseNumberPositiveInfinity()
		{
			if (MatchValue('I', JsonConvert.PositiveInfinity, noTrailingNonSeperatorCharacters: true))
			{
				SetToken(JsonToken.Float, double.PositiveInfinity);
				return;
			}
			throw CreateJsonReaderException("Error parsing positive infinity value. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		private void ParseNumberNaN()
		{
			if (MatchValue('N', JsonConvert.NaN, noTrailingNonSeperatorCharacters: true))
			{
				SetToken(JsonToken.Float, double.NaN);
				return;
			}
			throw CreateJsonReaderException("Error parsing NaN value. Line {0}, position {1}.", _currentLineNumber, _currentLinePosition);
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseInput && _reader != null)
			{
				_reader.Close();
			}
			if (_buffer != null)
			{
				_buffer.Clear();
			}
		}

		public bool HasLineInfo()
		{
			return true;
		}
	}
	public class JsonTextWriter : JsonWriter
	{
		private readonly TextWriter _writer;

		private PlayFab.Json.Utilities.Base64Encoder _base64Encoder;

		private char _indentChar;

		private int _indentation;

		private char _quoteChar;

		private bool _quoteName;

		private PlayFab.Json.Utilities.Base64Encoder Base64Encoder
		{
			get
			{
				if (_base64Encoder == null)
				{
					_base64Encoder = new PlayFab.Json.Utilities.Base64Encoder(_writer);
				}
				return _base64Encoder;
			}
		}

		public int Indentation
		{
			get
			{
				return _indentation;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("Indentation value must be greater than 0.");
				}
				_indentation = value;
			}
		}

		public char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			set
			{
				if (value != '"' && value != '\'')
				{
					throw new ArgumentException("Invalid JavaScript string quote character. Valid quote characters are ' and \".");
				}
				_quoteChar = value;
			}
		}

		public char IndentChar
		{
			get
			{
				return _indentChar;
			}
			set
			{
				_indentChar = value;
			}
		}

		public bool QuoteName
		{
			get
			{
				return _quoteName;
			}
			set
			{
				_quoteName = value;
			}
		}

		public JsonTextWriter(TextWriter textWriter)
		{
			if (textWriter == null)
			{
				throw new ArgumentNullException("textWriter");
			}
			_writer = textWriter;
			_quoteChar = '"';
			_quoteName = true;
			_indentChar = ' ';
			_indentation = 2;
		}

		public override void Flush()
		{
			_writer.Flush();
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseOutput && _writer != null)
			{
				_writer.Close();
			}
		}

		public override void WriteStartObject()
		{
			base.WriteStartObject();
			_writer.Write("{");
		}

		public override void WriteStartArray()
		{
			base.WriteStartArray();
			_writer.Write("[");
		}

		public override void WriteStartConstructor(string name)
		{
			base.WriteStartConstructor(name);
			_writer.Write("new ");
			_writer.Write(name);
			_writer.Write("(");
		}

		protected override void WriteEnd(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.EndObject:
				_writer.Write("}");
				break;
			case JsonToken.EndArray:
				_writer.Write("]");
				break;
			case JsonToken.EndConstructor:
				_writer.Write(")");
				break;
			default:
				throw new JsonWriterException("Invalid JsonToken: " + token);
			}
		}

		public override void WritePropertyName(string name)
		{
			base.WritePropertyName(name);
			PlayFab.Json.Utilities.JavaScriptUtils.WriteEscapedJavaScriptString(_writer, name, _quoteChar, _quoteName);
			_writer.Write(':');
		}

		protected override void WriteIndent()
		{
			if (base.Formatting == Formatting.Indented)
			{
				_writer.Write(Environment.NewLine);
				int num = base.Top * _indentation;
				for (int i = 0; i < num; i++)
				{
					_writer.Write(_indentChar);
				}
			}
		}

		protected override void WriteValueDelimiter()
		{
			_writer.Write(',');
		}

		protected override void WriteIndentSpace()
		{
			_writer.Write(' ');
		}

		private void WriteValueInternal(string value, JsonToken token)
		{
			_writer.Write(value);
		}

		public override void WriteNull()
		{
			base.WriteNull();
			WriteValueInternal(JsonConvert.Null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			base.WriteUndefined();
			WriteValueInternal(JsonConvert.Undefined, JsonToken.Undefined);
		}

		public override void WriteRaw(string json)
		{
			base.WriteRaw(json);
			_writer.Write(json);
		}

		public override void WriteValue(string value)
		{
			base.WriteValue(value);
			if (value == null)
			{
				WriteValueInternal(JsonConvert.Null, JsonToken.Null);
			}
			else
			{
				PlayFab.Json.Utilities.JavaScriptUtils.WriteEscapedJavaScriptString(_writer, value, _quoteChar, appendDelimiters: true);
			}
		}

		public override void WriteValue(int value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(uint value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(long value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(ulong value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(float value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(ushort value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(char value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(byte value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(sbyte value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Integer);
		}

		public override void WriteValue(decimal value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			base.WriteValue(value);
			JsonConvert.WriteDateTimeString(_writer, value);
		}

		public override void WriteValue(byte[] value)
		{
			base.WriteValue(value);
			if (value != null)
			{
				_writer.Write(_quoteChar);
				Base64Encoder.Encode(value, 0, value.Length);
				Base64Encoder.Flush();
				_writer.Write(_quoteChar);
			}
		}

		public override void WriteValue(DateTimeOffset value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Date);
		}

		public override void WriteValue(Guid value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.String);
		}

		public override void WriteValue(TimeSpan value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Date);
		}

		public override void WriteValue(Uri value)
		{
			base.WriteValue(value);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Date);
		}

		public override void WriteComment(string text)
		{
			base.WriteComment(text);
			_writer.Write("/*");
			_writer.Write(text);
			_writer.Write("*/");
		}

		public override void WriteWhitespace(string ws)
		{
			base.WriteWhitespace(ws);
			_writer.Write(ws);
		}
	}
	public enum JsonToken
	{
		None,
		StartObject,
		StartArray,
		StartConstructor,
		PropertyName,
		Comment,
		Raw,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		EndObject,
		EndArray,
		EndConstructor,
		Date,
		Bytes
	}
	public class JsonValidatingReader : JsonReader, IJsonLineInfo
	{
		private class SchemaScope
		{
			private readonly PlayFab.Json.Linq.JTokenType _tokenType;

			private readonly IList<JsonSchemaModel> _schemas;

			private readonly Dictionary<string, bool> _requiredProperties;

			public string CurrentPropertyName { get; set; }

			public int ArrayItemCount { get; set; }

			public IList<JsonSchemaModel> Schemas => _schemas;

			public Dictionary<string, bool> RequiredProperties => _requiredProperties;

			public PlayFab.Json.Linq.JTokenType TokenType => _tokenType;

			public SchemaScope(PlayFab.Json.Linq.JTokenType tokenType, IList<JsonSchemaModel> schemas)
			{
				_tokenType = tokenType;
				_schemas = schemas;
				_requiredProperties = System.Linq.Enumerable.ToDictionary(System.Linq.Enumerable.Distinct(System.Linq.Enumerable.SelectMany(schemas, GetRequiredProperties)), (string p) => p, (string p) => false);
			}

			private IEnumerable<string> GetRequiredProperties(JsonSchemaModel schema)
			{
				if (schema == null || schema.Properties == null)
				{
					return System.Linq.Enumerable.Empty<string>();
				}
				return System.Linq.Enumerable.Select(System.Linq.Enumerable.Where(schema.Properties, (KeyValuePair<string, JsonSchemaModel> p) => p.Value.Required), (KeyValuePair<string, JsonSchemaModel> p) => p.Key);
			}
		}

		private readonly JsonReader _reader;

		private readonly Stack<SchemaScope> _stack;

		private JsonSchema _schema;

		private JsonSchemaModel _model;

		private SchemaScope _currentScope;

		int IJsonLineInfo.LineNumber => (_reader is IJsonLineInfo jsonLineInfo) ? jsonLineInfo.LineNumber : 0;

		int IJsonLineInfo.LinePosition => (_reader is IJsonLineInfo jsonLineInfo) ? jsonLineInfo.LinePosition : 0;

		public override object Value => _reader.Value;

		public override int Depth => _reader.Depth;

		public override char QuoteChar
		{
			get
			{
				return _reader.QuoteChar;
			}
			protected internal set
			{
			}
		}

		public override JsonToken TokenType => _reader.TokenType;

		public override Type ValueType => _reader.ValueType;

		private IEnumerable<JsonSchemaModel> CurrentSchemas => _currentScope.Schemas;

		private IEnumerable<JsonSchemaModel> CurrentMemberSchemas
		{
			get
			{
				if (_currentScope == null)
				{
					return new List<JsonSchemaModel>(new JsonSchemaModel[1] { _model });
				}
				if (_currentScope.Schemas == null || _currentScope.Schemas.Count == 0)
				{
					return System.Linq.Enumerable.Empty<JsonSchemaModel>();
				}
				switch (_currentScope.TokenType)
				{
				case PlayFab.Json.Linq.JTokenType.None:
					return _currentScope.Schemas;
				case PlayFab.Json.Linq.JTokenType.Object:
				{
					if (_currentScope.CurrentPropertyName == null)
					{
						throw new Exception("CurrentPropertyName has not been set on scope.");
					}
					IList<JsonSchemaModel> list2 = new List<JsonSchemaModel>();
					{
						foreach (JsonSchemaModel currentSchema in CurrentSchemas)
						{
							if (currentSchema.Properties != null && currentSchema.Properties.TryGetValue(_currentScope.CurrentPropertyName, out var value))
							{
								list2.Add(value);
							}
							if (currentSchema.PatternProperties != null)
							{
								foreach (KeyValuePair<string, JsonSchemaModel> patternProperty in currentSchema.PatternProperties)
								{
									if (Regex.IsMatch(_currentScope.CurrentPropertyName, patternProperty.Key))
									{
										list2.Add(patternProperty.Value);
									}
								}
							}
							if (list2.Count == 0 && currentSchema.AllowAdditionalProperties && currentSchema.AdditionalProperties != null)
							{
								list2.Add(currentSchema.AdditionalProperties);
							}
						}
						return list2;
					}
				}
				case PlayFab.Json.Linq.JTokenType.Array:
				{
					IList<JsonSchemaModel> list = new List<JsonSchemaModel>();
					{
						foreach (JsonSchemaModel currentSchema2 in CurrentSchemas)
						{
							if (!PlayFab.Json.Utilities.CollectionUtils.IsNullOrEmpty(currentSchema2.Items))
							{
								if (currentSchema2.Items.Count == 1)
								{
									list.Add(currentSchema2.Items[0]);
								}
								if (currentSchema2.Items.Count > _currentScope.ArrayItemCount - 1)
								{
									list.Add(currentSchema2.Items[_currentScope.ArrayItemCount - 1]);
								}
							}
							if (currentSchema2.AllowAdditionalProperties && currentSchema2.AdditionalProperties != null)
							{
								list.Add(currentSchema2.AdditionalProperties);
							}
						}
						return list;
					}
				}
				case PlayFab.Json.Linq.JTokenType.Constructor:
					return System.Linq.Enumerable.Empty<JsonSchemaModel>();
				default:
					throw new ArgumentOutOfRangeException("TokenType", PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected token type: {0}", CultureInfo.InvariantCulture, _currentScope.TokenType));
				}
			}
		}

		public JsonSchema Schema
		{
			get
			{
				return _schema;
			}
			set
			{
				if (TokenType != 0)
				{
					throw new Exception("Cannot change schema while validating JSON.");
				}
				_schema = value;
				_model = null;
			}
		}

		public JsonReader Reader => _reader;

		public event ValidationEventHandler ValidationEventHandler;

		public JsonValidatingReader(JsonReader reader)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			_reader = reader;
			_stack = new Stack<SchemaScope>();
		}

		private void Push(SchemaScope scope)
		{
			_stack.Push(scope);
			_currentScope = scope;
		}

		private SchemaScope Pop()
		{
			SchemaScope result = _stack.Pop();
			_currentScope = ((_stack.Count == 0) ? null : _stack.Peek());
			return result;
		}

		private void RaiseError(string message, JsonSchemaModel schema)
		{
			string message2 = ((!((IJsonLineInfo)this).HasLineInfo()) ? message : (message + PlayFab.Json.Utilities.StringUtils.FormatWith(" Line {0}, position {1}.", CultureInfo.InvariantCulture, ((IJsonLineInfo)this).LineNumber, ((IJsonLineInfo)this).LinePosition)));
			OnValidationEvent(new JsonSchemaException(message2, null, ((IJsonLineInfo)this).LineNumber, ((IJsonLineInfo)this).LinePosition));
		}

		private void OnValidationEvent(JsonSchemaException exception)
		{
			ValidationEventHandler validationEventHandler = this.ValidationEventHandler;
			if (validationEventHandler != null)
			{
				validationEventHandler(this, new ValidationEventArgs(exception));
				return;
			}
			throw exception;
		}

		private void ValidateInEnumAndNotDisallowed(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return;
			}
			PlayFab.Json.Linq.JToken jToken = new PlayFab.Json.Linq.JValue(_reader.Value);
			if (schema.Enum != null)
			{
				StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
				jToken.WriteTo(new JsonTextWriter(stringWriter));
				if (!PlayFab.Json.Utilities.CollectionUtils.ContainsValue(schema.Enum, jToken, new PlayFab.Json.Linq.JTokenEqualityComparer()))
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Value {0} is not defined in enum.", CultureInfo.InvariantCulture, stringWriter.ToString()), schema);
				}
			}
			JsonSchemaType? currentNodeSchemaType = GetCurrentNodeSchemaType();
			if (currentNodeSchemaType.HasValue && JsonSchemaGenerator.HasFlag(schema.Disallow, currentNodeSchemaType.Value))
			{
				RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Type {0} is disallowed.", CultureInfo.InvariantCulture, currentNodeSchemaType), schema);
			}
		}

		private JsonSchemaType? GetCurrentNodeSchemaType()
		{
			return _reader.TokenType switch
			{
				JsonToken.StartObject => JsonSchemaType.Object, 
				JsonToken.StartArray => JsonSchemaType.Array, 
				JsonToken.Integer => JsonSchemaType.Integer, 
				JsonToken.Float => JsonSchemaType.Float, 
				JsonToken.String => JsonSchemaType.String, 
				JsonToken.Boolean => JsonSchemaType.Boolean, 
				JsonToken.Null => JsonSchemaType.Null, 
				_ => null, 
			};
		}

		public override byte[] ReadAsBytes()
		{
			byte[] result = _reader.ReadAsBytes();
			ValidateCurrentToken();
			return result;
		}

		public override decimal? ReadAsDecimal()
		{
			decimal? result = _reader.ReadAsDecimal();
			ValidateCurrentToken();
			return result;
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			DateTimeOffset? result = _reader.ReadAsDateTimeOffset();
			ValidateCurrentToken();
			return result;
		}

		public override bool Read()
		{
			if (!_reader.Read())
			{
				return false;
			}
			if (_reader.TokenType == JsonToken.Comment)
			{
				return true;
			}
			ValidateCurrentToken();
			return true;
		}

		private void ValidateCurrentToken()
		{
			if (_model == null)
			{
				JsonSchemaModelBuilder jsonSchemaModelBuilder = new JsonSchemaModelBuilder();
				_model = jsonSchemaModelBuilder.Build(_schema);
			}
			switch (_reader.TokenType)
			{
			case JsonToken.StartObject:
			{
				ProcessValue();
				IList<JsonSchemaModel> schemas2 = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(CurrentMemberSchemas, ValidateObject));
				Push(new SchemaScope(PlayFab.Json.Linq.JTokenType.Object, schemas2));
				break;
			}
			case JsonToken.StartArray:
			{
				ProcessValue();
				IList<JsonSchemaModel> schemas = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(CurrentMemberSchemas, ValidateArray));
				Push(new SchemaScope(PlayFab.Json.Linq.JTokenType.Array, schemas));
				break;
			}
			case JsonToken.StartConstructor:
				Push(new SchemaScope(PlayFab.Json.Linq.JTokenType.Constructor, null));
				break;
			case JsonToken.PropertyName:
			{
				foreach (JsonSchemaModel currentSchema in CurrentSchemas)
				{
					ValidatePropertyName(currentSchema);
				}
				break;
			}
			case JsonToken.Raw:
				break;
			case JsonToken.Integer:
				ProcessValue();
				{
					foreach (JsonSchemaModel currentMemberSchema in CurrentMemberSchemas)
					{
						ValidateInteger(currentMemberSchema);
					}
					break;
				}
			case JsonToken.Float:
				ProcessValue();
				{
					foreach (JsonSchemaModel currentMemberSchema2 in CurrentMemberSchemas)
					{
						ValidateFloat(currentMemberSchema2);
					}
					break;
				}
			case JsonToken.String:
				ProcessValue();
				{
					foreach (JsonSchemaModel currentMemberSchema3 in CurrentMemberSchemas)
					{
						ValidateString(currentMemberSchema3);
					}
					break;
				}
			case JsonToken.Boolean:
				ProcessValue();
				{
					foreach (JsonSchemaModel currentMemberSchema4 in CurrentMemberSchemas)
					{
						ValidateBoolean(currentMemberSchema4);
					}
					break;
				}
			case JsonToken.Null:
				ProcessValue();
				{
					foreach (JsonSchemaModel currentMemberSchema5 in CurrentMemberSchemas)
					{
						ValidateNull(currentMemberSchema5);
					}
					break;
				}
			case JsonToken.Undefined:
				break;
			case JsonToken.EndObject:
				foreach (JsonSchemaModel currentSchema2 in CurrentSchemas)
				{
					ValidateEndObject(currentSchema2);
				}
				Pop();
				break;
			case JsonToken.EndArray:
				foreach (JsonSchemaModel currentSchema3 in CurrentSchemas)
				{
					ValidateEndArray(currentSchema3);
				}
				Pop();
				break;
			case JsonToken.EndConstructor:
				Pop();
				break;
			case JsonToken.Date:
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private void ValidateEndObject(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return;
			}
			Dictionary<string, bool> requiredProperties = _currentScope.RequiredProperties;
			if (requiredProperties != null)
			{
				List<string> list = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Select(System.Linq.Enumerable.Where(requiredProperties, (KeyValuePair<string, bool> kv) => !kv.Value), (KeyValuePair<string, bool> kv) => kv.Key));
				if (list.Count > 0)
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Required properties are missing from object: {0}.", CultureInfo.InvariantCulture, string.Join(", ", list.ToArray())), schema);
				}
			}
		}

		private void ValidateEndArray(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return;
			}
			int arrayItemCount = _currentScope.ArrayItemCount;
			if (schema.MaximumItems.HasValue)
			{
				int? maximumItems = schema.MaximumItems;
				if (maximumItems.HasValue && arrayItemCount > maximumItems.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Array item count {0} exceeds maximum count of {1}.", CultureInfo.InvariantCulture, arrayItemCount, schema.MaximumItems), schema);
				}
			}
			if (schema.MinimumItems.HasValue)
			{
				int? minimumItems = schema.MinimumItems;
				if (minimumItems.HasValue && arrayItemCount < minimumItems.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Array item count {0} is less than minimum count of {1}.", CultureInfo.InvariantCulture, arrayItemCount, schema.MinimumItems), schema);
				}
			}
		}

		private void ValidateNull(JsonSchemaModel schema)
		{
			if (schema != null && TestType(schema, JsonSchemaType.Null))
			{
				ValidateInEnumAndNotDisallowed(schema);
			}
		}

		private void ValidateBoolean(JsonSchemaModel schema)
		{
			if (schema != null && TestType(schema, JsonSchemaType.Boolean))
			{
				ValidateInEnumAndNotDisallowed(schema);
			}
		}

		private void ValidateString(JsonSchemaModel schema)
		{
			if (schema == null || !TestType(schema, JsonSchemaType.String))
			{
				return;
			}
			ValidateInEnumAndNotDisallowed(schema);
			string text = _reader.Value.ToString();
			if (schema.MaximumLength.HasValue)
			{
				int? maximumLength = schema.MaximumLength;
				if (maximumLength.HasValue && text.Length > maximumLength.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("String '{0}' exceeds maximum length of {1}.", CultureInfo.InvariantCulture, text, schema.MaximumLength), schema);
				}
			}
			if (schema.MinimumLength.HasValue)
			{
				int? minimumLength = schema.MinimumLength;
				if (minimumLength.HasValue && text.Length < minimumLength.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("String '{0}' is less than minimum length of {1}.", CultureInfo.InvariantCulture, text, schema.MinimumLength), schema);
				}
			}
			if (schema.Patterns == null)
			{
				return;
			}
			foreach (string pattern in schema.Patterns)
			{
				if (!Regex.IsMatch(text, pattern))
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("String '{0}' does not match regex pattern '{1}'.", CultureInfo.InvariantCulture, text, pattern), schema);
				}
			}
		}

		private void ValidateInteger(JsonSchemaModel schema)
		{
			if (schema == null || !TestType(schema, JsonSchemaType.Integer))
			{
				return;
			}
			ValidateInEnumAndNotDisallowed(schema);
			long num = Convert.ToInt64(_reader.Value, CultureInfo.InvariantCulture);
			if (schema.Maximum.HasValue)
			{
				double? maximum = schema.Maximum;
				if (maximum.HasValue && (double)num > maximum.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Integer {0} exceeds maximum value of {1}.", CultureInfo.InvariantCulture, num, schema.Maximum), schema);
				}
				if (schema.ExclusiveMaximum && (double)num == schema.Maximum)
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Integer {0} equals maximum value of {1} and exclusive maximum is true.", CultureInfo.InvariantCulture, num, schema.Maximum), schema);
				}
			}
			if (schema.Minimum.HasValue)
			{
				double? minimum = schema.Minimum;
				if (minimum.HasValue && (double)num < minimum.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Integer {0} is less than minimum value of {1}.", CultureInfo.InvariantCulture, num, schema.Minimum), schema);
				}
				if (schema.ExclusiveMinimum && (double)num == schema.Minimum)
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Integer {0} equals minimum value of {1} and exclusive minimum is true.", CultureInfo.InvariantCulture, num, schema.Minimum), schema);
				}
			}
			if (schema.DivisibleBy.HasValue && !IsZero((double)num % schema.DivisibleBy.Value))
			{
				RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Integer {0} is not evenly divisible by {1}.", CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.DivisibleBy), schema);
			}
		}

		private void ProcessValue()
		{
			if (_currentScope == null || _currentScope.TokenType != PlayFab.Json.Linq.JTokenType.Array)
			{
				return;
			}
			_currentScope.ArrayItemCount++;
			foreach (JsonSchemaModel currentSchema in CurrentSchemas)
			{
				if (currentSchema != null && currentSchema.Items != null && currentSchema.Items.Count > 1 && _currentScope.ArrayItemCount >= currentSchema.Items.Count)
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Index {0} has not been defined and the schema does not allow additional items.", CultureInfo.InvariantCulture, _currentScope.ArrayItemCount), currentSchema);
				}
			}
		}

		private void ValidateFloat(JsonSchemaModel schema)
		{
			if (schema == null || !TestType(schema, JsonSchemaType.Float))
			{
				return;
			}
			ValidateInEnumAndNotDisallowed(schema);
			double num = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
			if (schema.Maximum.HasValue)
			{
				double? maximum = schema.Maximum;
				if (maximum.HasValue && num > maximum.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Float {0} exceeds maximum value of {1}.", CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Maximum), schema);
				}
				if (schema.ExclusiveMaximum && num == schema.Maximum)
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Float {0} equals maximum value of {1} and exclusive maximum is true.", CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Maximum), schema);
				}
			}
			if (schema.Minimum.HasValue)
			{
				double? minimum = schema.Minimum;
				if (minimum.HasValue && num < minimum.GetValueOrDefault())
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Float {0} is less than minimum value of {1}.", CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Minimum), schema);
				}
				if (schema.ExclusiveMinimum && num == schema.Minimum)
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Float {0} equals minimum value of {1} and exclusive minimum is true.", CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.Minimum), schema);
				}
			}
			if (schema.DivisibleBy.HasValue && !IsZero(num % schema.DivisibleBy.Value))
			{
				RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Float {0} is not evenly divisible by {1}.", CultureInfo.InvariantCulture, JsonConvert.ToString(num), schema.DivisibleBy), schema);
			}
		}

		private static bool IsZero(double value)
		{
			double num = 2.220446049250313E-16;
			return Math.Abs(value) < 10.0 * num;
		}

		private void ValidatePropertyName(JsonSchemaModel schema)
		{
			if (schema != null)
			{
				string text = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
				if (_currentScope.RequiredProperties.ContainsKey(text))
				{
					_currentScope.RequiredProperties[text] = true;
				}
				if (!schema.AllowAdditionalProperties && !IsPropertyDefinied(schema, text))
				{
					RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Property '{0}' has not been defined and the schema does not allow additional properties.", CultureInfo.InvariantCulture, text), schema);
				}
				_currentScope.CurrentPropertyName = text;
			}
		}

		private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName)
		{
			if (schema.Properties != null && schema.Properties.ContainsKey(propertyName))
			{
				return true;
			}
			if (schema.PatternProperties != null)
			{
				foreach (string key in schema.PatternProperties.Keys)
				{
					if (Regex.IsMatch(propertyName, key))
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool ValidateArray(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return true;
			}
			return TestType(schema, JsonSchemaType.Array);
		}

		private bool ValidateObject(JsonSchemaModel schema)
		{
			if (schema == null)
			{
				return true;
			}
			return TestType(schema, JsonSchemaType.Object);
		}

		private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType)
		{
			if (!JsonSchemaGenerator.HasFlag(currentSchema.Type, currentType))
			{
				RaiseError(PlayFab.Json.Utilities.StringUtils.FormatWith("Invalid type. Expected {0} but got {1}.", CultureInfo.InvariantCulture, currentSchema.Type, currentType), currentSchema);
				return false;
			}
			return true;
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			return _reader is IJsonLineInfo jsonLineInfo && jsonLineInfo.HasLineInfo();
		}
	}
	public enum WriteState
	{
		Error,
		Closed,
		Object,
		Array,
		Constructor,
		Property,
		Start
	}
	public enum Formatting
	{
		None,
		Indented
	}
	public abstract class JsonWriter : IDisposable
	{
		private enum State
		{
			Start,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			ConstructorStart,
			Constructor,
			Bytes,
			Closed,
			Error
		}

		private static readonly State[][] stateArray = new State[8][]
		{
			new State[10]
			{
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.ObjectStart,
				State.ObjectStart,
				State.Error,
				State.Error,
				State.ObjectStart,
				State.ObjectStart,
				State.ObjectStart,
				State.ObjectStart,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.ArrayStart,
				State.ArrayStart,
				State.Error,
				State.Error,
				State.ArrayStart,
				State.ArrayStart,
				State.ArrayStart,
				State.ArrayStart,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.ConstructorStart,
				State.ConstructorStart,
				State.Error,
				State.Error,
				State.ConstructorStart,
				State.ConstructorStart,
				State.ConstructorStart,
				State.ConstructorStart,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Property,
				State.Error,
				State.Property,
				State.Property,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Start,
				State.Property,
				State.ObjectStart,
				State.Object,
				State.ArrayStart,
				State.Array,
				State.Constructor,
				State.Constructor,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Start,
				State.Property,
				State.ObjectStart,
				State.Object,
				State.ArrayStart,
				State.Array,
				State.Constructor,
				State.Constructor,
				State.Error,
				State.Error
			},
			new State[10]
			{
				State.Start,
				State.Object,
				State.Error,
				State.Error,
				State.Array,
				State.Array,
				State.Constructor,
				State.Constructor,
				State.Error,
				State.Error
			}
		};

		private int _top;

		private readonly List<PlayFab.Json.Linq.JTokenType> _stack;

		private State _currentState;

		private Formatting _formatting;

		public bool CloseOutput { get; set; }

		protected internal int Top => _top;

		public WriteState WriteState
		{
			get
			{
				switch (_currentState)
				{
				case State.Error:
					return WriteState.Error;
				case State.Closed:
					return WriteState.Closed;
				case State.ObjectStart:
				case State.Object:
					return WriteState.Object;
				case State.ArrayStart:
				case State.Array:
					return WriteState.Array;
				case State.ConstructorStart:
				case State.Constructor:
					return WriteState.Constructor;
				case State.Property:
					return WriteState.Property;
				case State.Start:
					return WriteState.Start;
				default:
					throw new JsonWriterException("Invalid state: " + _currentState);
				}
			}
		}

		public Formatting Formatting
		{
			get
			{
				return _formatting;
			}
			set
			{
				_formatting = value;
			}
		}

		protected JsonWriter()
		{
			_stack = new List<PlayFab.Json.Linq.JTokenType>(8);
			_stack.Add(PlayFab.Json.Linq.JTokenType.None);
			_currentState = State.Start;
			_formatting = Formatting.None;
			CloseOutput = true;
		}

		private void Push(PlayFab.Json.Linq.JTokenType value)
		{
			_top++;
			if (_stack.Count <= _top)
			{
				_stack.Add(value);
			}
			else
			{
				_stack[_top] = value;
			}
		}

		private PlayFab.Json.Linq.JTokenType Pop()
		{
			PlayFab.Json.Linq.JTokenType result = Peek();
			_top--;
			return result;
		}

		private PlayFab.Json.Linq.JTokenType Peek()
		{
			return _stack[_top];
		}

		public abstract void Flush();

		public virtual void Close()
		{
			AutoCompleteAll();
		}

		public virtual void WriteStartObject()
		{
			AutoComplete(JsonToken.StartObject);
			Push(PlayFab.Json.Linq.JTokenType.Object);
		}

		public virtual void WriteEndObject()
		{
			AutoCompleteClose(JsonToken.EndObject);
		}

		public virtual void WriteStartArray()
		{
			AutoComplete(JsonToken.StartArray);
			Push(PlayFab.Json.Linq.JTokenType.Array);
		}

		public virtual void WriteEndArray()
		{
			AutoCompleteClose(JsonToken.EndArray);
		}

		public virtual void WriteStartConstructor(string name)
		{
			AutoComplete(JsonToken.StartConstructor);
			Push(PlayFab.Json.Linq.JTokenType.Constructor);
		}

		public virtual void WriteEndConstructor()
		{
			AutoCompleteClose(JsonToken.EndConstructor);
		}

		public virtual void WritePropertyName(string name)
		{
			AutoComplete(JsonToken.PropertyName);
		}

		public virtual void WriteEnd()
		{
			WriteEnd(Peek());
		}

		public void WriteToken(JsonReader reader)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			int initialDepth = ((reader.TokenType == JsonToken.None) ? (-1) : (IsStartToken(reader.TokenType) ? reader.Depth : (reader.Depth + 1)));
			WriteToken(reader, initialDepth);
		}

		internal void WriteToken(JsonReader reader, int initialDepth)
		{
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.StartObject:
					WriteStartObject();
					break;
				case JsonToken.StartArray:
					WriteStartArray();
					break;
				case JsonToken.StartConstructor:
				{
					string strA = reader.Value.ToString();
					if (string.Compare(strA, "Date", StringComparison.Ordinal) == 0)
					{
						WriteConstructorDate(reader);
					}
					else
					{
						WriteStartConstructor(reader.Value.ToString());
					}
					break;
				}
				case JsonToken.PropertyName:
					WritePropertyName(reader.Value.ToString());
					break;
				case JsonToken.Comment:
					WriteComment(reader.Value.ToString());
					break;
				case JsonToken.Integer:
					WriteValue(Convert.ToInt64(reader.Value, CultureInfo.InvariantCulture));
					break;
				case JsonToken.Float:
					WriteValue(Convert.ToDouble(reader.Value, CultureInfo.InvariantCulture));
					break;
				case JsonToken.String:
					WriteValue(reader.Value.ToString());
					break;
				case JsonToken.Boolean:
					WriteValue(Convert.ToBoolean(reader.Value, CultureInfo.InvariantCulture));
					break;
				case JsonToken.Null:
					WriteNull();
					break;
				case JsonToken.Undefined:
					WriteUndefined();
					break;
				case JsonToken.EndObject:
					WriteEndObject();
					break;
				case JsonToken.EndArray:
					WriteEndArray();
					break;
				case JsonToken.EndConstructor:
					WriteEndConstructor();
					break;
				case JsonToken.Date:
					WriteValue((DateTime)reader.Value);
					break;
				case JsonToken.Raw:
					WriteRawValue((string)reader.Value);
					break;
				case JsonToken.Bytes:
					WriteValue((byte[])reader.Value);
					break;
				default:
					throw PlayFab.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", reader.TokenType, "Unexpected token type.");
				case JsonToken.None:
					break;
				}
			}
			while (initialDepth - 1 < reader.Depth - (IsEndToken(reader.TokenType) ? 1 : 0) && reader.Read());
		}

		private void WriteConstructorDate(JsonReader reader)
		{
			if (!reader.Read())
			{
				throw new Exception("Unexpected end while reading date constructor.");
			}
			if (reader.TokenType != JsonToken.Integer)
			{
				throw new Exception("Unexpected token while reading date constructor. Expected Integer, got " + reader.TokenType);
			}
			long javaScriptTicks = (long)reader.Value;
			DateTime value = JsonConvert.ConvertJavaScriptTicksToDateTime(javaScriptTicks);
			if (!reader.Read())
			{
				throw new Exception("Unexpected end while reading date constructor.");
			}
			if (reader.TokenType != JsonToken.EndConstructor)
			{
				throw new Exception("Unexpected token while reading date constructor. Expected EndConstructor, got " + reader.TokenType);
			}
			WriteValue(value);
		}

		private bool IsEndToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.EndObject:
			case JsonToken.EndArray:
			case JsonToken.EndConstructor:
				return true;
			default:
				return false;
			}
		}

		private bool IsStartToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.StartObject:
			case JsonToken.StartArray:
			case JsonToken.StartConstructor:
				return true;
			default:
				return false;
			}
		}

		private void WriteEnd(PlayFab.Json.Linq.JTokenType type)
		{
			switch (type)
			{
			case PlayFab.Json.Linq.JTokenType.Object:
				WriteEndObject();
				break;
			case PlayFab.Json.Linq.JTokenType.Array:
				WriteEndArray();
				break;
			case PlayFab.Json.Linq.JTokenType.Constructor:
				WriteEndConstructor();
				break;
			default:
				throw new JsonWriterException("Unexpected type when writing end: " + type);
			}
		}

		private void AutoCompleteAll()
		{
			while (_top > 0)
			{
				WriteEnd();
			}
		}

		private PlayFab.Json.Linq.JTokenType GetTypeForCloseToken(JsonToken token)
		{
			return token switch
			{
				JsonToken.EndObject => PlayFab.Json.Linq.JTokenType.Object, 
				JsonToken.EndArray => PlayFab.Json.Linq.JTokenType.Array, 
				JsonToken.EndConstructor => PlayFab.Json.Linq.JTokenType.Constructor, 
				_ => throw new JsonWriterException("No type for token: " + token), 
			};
		}

		private JsonToken GetCloseTokenForType(PlayFab.Json.Linq.JTokenType type)
		{
			return type switch
			{
				PlayFab.Json.Linq.JTokenType.Object => JsonToken.EndObject, 
				PlayFab.Json.Linq.JTokenType.Array => JsonToken.EndArray, 
				PlayFab.Json.Linq.JTokenType.Constructor => JsonToken.EndConstructor, 
				_ => throw new JsonWriterException("No close token for type: " + type), 
			};
		}

		private void AutoCompleteClose(JsonToken tokenBeingClosed)
		{
			int num = 0;
			for (int i = 0; i < _top; i++)
			{
				int index = _top - i;
				if (_stack[index] == GetTypeForCloseToken(tokenBeingClosed))
				{
					num = i + 1;
					break;
				}
			}
			if (num == 0)
			{
				throw new JsonWriterException("No token to close.");
			}
			for (int j = 0; j < num; j++)
			{
				JsonToken closeTokenForType = GetCloseTokenForType(Pop());
				if (_currentState != State.ObjectStart && _currentState != State.ArrayStart)
				{
					WriteIndent();
				}
				WriteEnd(closeTokenForType);
			}
			PlayFab.Json.Linq.JTokenType jTokenType = Peek();
			switch (jTokenType)
			{
			case PlayFab.Json.Linq.JTokenType.Object:
				_currentState = State.Object;
				break;
			case PlayFab.Json.Linq.JTokenType.Array:
				_currentState = State.Array;
				break;
			case PlayFab.Json.Linq.JTokenType.Constructor:
				_currentState = State.Array;
				break;
			case PlayFab.Json.Linq.JTokenType.None:
				_currentState = State.Start;
				break;
			default:
				throw new JsonWriterException("Unknown JsonType: " + jTokenType);
			}
		}

		protected virtual void WriteEnd(JsonToken token)
		{
		}

		protected virtual void WriteIndent()
		{
		}

		protected virtual void WriteValueDelimiter()
		{
		}

		protected virtual void WriteIndentSpace()
		{
		}

		internal void AutoComplete(JsonToken tokenBeingWritten)
		{
			int num;
			switch (tokenBeingWritten)
			{
			default:
				num = (int)tokenBeingWritten;
				break;
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				num = 7;
				break;
			}
			State state = stateArray[num][(int)_currentState];
			if (state == State.Error)
			{
				throw new JsonWriterException(PlayFab.Json.Utilities.StringUtils.FormatWith("Token {0} in state {1} would result in an invalid JavaScript object.", CultureInfo.InvariantCulture, tokenBeingWritten.ToString(), _currentState.ToString()));
			}
			if ((_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment)
			{
				WriteValueDelimiter();
			}
			else if (_currentState == State.Property && _formatting == Formatting.Indented)
			{
				WriteIndentSpace();
			}
			WriteState writeState = WriteState;
			if ((tokenBeingWritten == JsonToken.PropertyName && writeState != WriteState.Start) || writeState == WriteState.Array || writeState == WriteState.Constructor)
			{
				WriteIndent();
			}
			_currentState = state;
		}

		public virtual void WriteNull()
		{
			AutoComplete(JsonToken.Null);
		}

		public virtual void WriteUndefined()
		{
			AutoComplete(JsonToken.Undefined);
		}

		public virtual void WriteRaw(string json)
		{
		}

		public virtual void WriteRawValue(string json)
		{
			AutoComplete(JsonToken.Undefined);
			WriteRaw(json);
		}

		public virtual void WriteValue(string value)
		{
			AutoComplete(JsonToken.String);
		}

		public virtual void WriteValue(int value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(uint value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(long value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(ulong value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(float value)
		{
			AutoComplete(JsonToken.Float);
		}

		public virtual void WriteValue(double value)
		{
			AutoComplete(JsonToken.Float);
		}

		public virtual void WriteValue(bool value)
		{
			AutoComplete(JsonToken.Boolean);
		}

		public virtual void WriteValue(short value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(ushort value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(char value)
		{
			AutoComplete(JsonToken.String);
		}

		public virtual void WriteValue(byte value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(sbyte value)
		{
			AutoComplete(JsonToken.Integer);
		}

		public virtual void WriteValue(decimal value)
		{
			AutoComplete(JsonToken.Float);
		}

		public virtual void WriteValue(DateTime value)
		{
			AutoComplete(JsonToken.Date);
		}

		public virtual void WriteValue(DateTimeOffset value)
		{
			AutoComplete(JsonToken.Date);
		}

		public virtual void WriteValue(Guid value)
		{
			AutoComplete(JsonToken.String);
		}

		public virtual void WriteValue(TimeSpan value)
		{
			AutoComplete(JsonToken.String);
		}

		public virtual void WriteValue(int? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(uint? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(long? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(ulong? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(float? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(double? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(bool? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(short? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(ushort? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(char? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(byte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(sbyte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(decimal? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(DateTime? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(DateTimeOffset? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(Guid? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(TimeSpan? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(byte[] value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				AutoComplete(JsonToken.Bytes);
			}
		}

		public virtual void WriteValue(Uri value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				AutoComplete(JsonToken.String);
			}
		}

		public virtual void WriteValue(object value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			if (value is IConvertible)
			{
				IConvertible convertible = value as IConvertible;
				switch (convertible.GetTypeCode())
				{
				case TypeCode.String:
					WriteValue(convertible.ToString(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Char:
					WriteValue(convertible.ToChar(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Boolean:
					WriteValue(convertible.ToBoolean(CultureInfo.InvariantCulture));
					return;
				case TypeCode.SByte:
					WriteValue(convertible.ToSByte(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Int16:
					WriteValue(convertible.ToInt16(CultureInfo.InvariantCulture));
					return;
				case TypeCode.UInt16:
					WriteValue(convertible.ToUInt16(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Int32:
					WriteValue(convertible.ToInt32(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Byte:
					WriteValue(convertible.ToByte(CultureInfo.InvariantCulture));
					return;
				case TypeCode.UInt32:
					WriteValue(convertible.ToUInt32(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Int64:
					WriteValue(convertible.ToInt64(CultureInfo.InvariantCulture));
					return;
				case TypeCode.UInt64:
					WriteValue(convertible.ToUInt64(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Single:
					WriteValue(convertible.ToSingle(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Double:
					WriteValue(convertible.ToDouble(CultureInfo.InvariantCulture));
					return;
				case TypeCode.DateTime:
					WriteValue(convertible.ToDateTime(CultureInfo.InvariantCulture));
					return;
				case TypeCode.Decimal:
					WriteValue(convertible.ToDecimal(CultureInfo.InvariantCulture));
					return;
				case TypeCode.DBNull:
					WriteNull();
					return;
				}
			}
			else
			{
				if (value is DateTimeOffset)
				{
					WriteValue((DateTimeOffset)value);
					return;
				}
				if (value is byte[])
				{
					WriteValue((byte[])value);
					return;
				}
				if (value is Guid)
				{
					WriteValue((Guid)value);
					return;
				}
				if (value is Uri)
				{
					WriteValue((Uri)value);
					return;
				}
				if (value is TimeSpan)
				{
					WriteValue((TimeSpan)value);
					return;
				}
			}
			throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.", CultureInfo.InvariantCulture, value.GetType()));
		}

		public virtual void WriteComment(string text)
		{
			AutoComplete(JsonToken.Comment);
		}

		public virtual void WriteWhitespace(string ws)
		{
			if (ws != null && !PlayFab.Json.Utilities.StringUtils.IsWhiteSpace(ws))
			{
				throw new JsonWriterException("Only white space characters should be used.");
			}
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (WriteState != WriteState.Closed)
			{
				Close();
			}
		}
	}
	public class JsonWriterException : Exception
	{
		public JsonWriterException()
		{
		}

		public JsonWriterException(string message)
			: base(message)
		{
		}

		public JsonWriterException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
}
namespace PlayFab.Json.Linq
{
	public interface IJEnumerable<T> : IEnumerable<T>, IEnumerable where T : JToken
	{
		IJEnumerable<JToken> this[object key] { get; }
	}
	public class JArray : JContainer, IList<JToken>, IEnumerable, ICollection<JToken>, IEnumerable<JToken>
	{
		private IList<JToken> _values = new List<JToken>();

		bool ICollection<JToken>.IsReadOnly => false;

		protected override IList<JToken> ChildrenTokens => _values;

		public override JTokenType Type => JTokenType.Array;

		public override JToken this[object key]
		{
			get
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Accessed JArray values with invalid key value: {0}. Array position index expected.", CultureInfo.InvariantCulture, PlayFab.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				return GetItem((int)key);
			}
			set
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Set JArray values with invalid key value: {0}. Array position index expected.", CultureInfo.InvariantCulture, PlayFab.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				SetItem((int)key, value);
			}
		}

		public JToken this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		public JArray()
		{
		}

		public JArray(JArray other)
			: base(other)
		{
		}

		public JArray(params object[] content)
			: this((object)content)
		{
		}

		public JArray(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			return node is JArray container && ContentsEqual(container);
		}

		internal override JToken CloneToken()
		{
			return new JArray(this);
		}

		public new static JArray Load(JsonReader reader)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw new Exception("Error reading JArray from JsonReader.");
			}
			if (reader.TokenType != JsonToken.StartArray)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}", CultureInfo.InvariantCulture, reader.TokenType));
			}
			JArray jArray = new JArray();
			jArray.SetLineInfo(reader as IJsonLineInfo);
			jArray.ReadTokenFrom(reader);
			return jArray;
		}

		public new static JArray Parse(string json)
		{
			JsonReader reader = new JsonTextReader(new StringReader(json));
			return Load(reader);
		}

		public new static JArray FromObject(object o)
		{
			return FromObject(o, new JsonSerializer());
		}

		public new static JArray FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken.Type != JTokenType.Array)
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Object serialized to {0}. JArray instance expected.", CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JArray)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartArray();
			foreach (JToken childrenToken in ChildrenTokens)
			{
				childrenToken.WriteTo(writer, converters);
			}
			writer.WriteEndArray();
		}

		public int IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		public void Insert(int index, JToken item)
		{
			InsertItem(index, item);
		}

		public void RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		public void Add(JToken item)
		{
			Add((object)item);
		}

		public void Clear()
		{
			ClearItems();
		}

		public bool Contains(JToken item)
		{
			return ContainsItem(item);
		}

		void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		public bool Remove(JToken item)
		{
			return RemoveItem(item);
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}
	}
	public class JConstructor : JContainer
	{
		private string _name;

		private IList<JToken> _values = new List<JToken>();

		protected override IList<JToken> ChildrenTokens => _values;

		public string Name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public override JTokenType Type => JTokenType.Constructor;

		public override JToken this[object key]
		{
			get
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Accessed JConstructor values with invalid key value: {0}. Argument position index expected.", CultureInfo.InvariantCulture, PlayFab.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				return GetItem((int)key);
			}
			set
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Set JConstructor values with invalid key value: {0}. Argument position index expected.", CultureInfo.InvariantCulture, PlayFab.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				SetItem((int)key, value);
			}
		}

		public JConstructor()
		{
		}

		public JConstructor(JConstructor other)
			: base(other)
		{
			_name = other.Name;
		}

		public JConstructor(string name, params object[] content)
			: this(name, (object)content)
		{
		}

		public JConstructor(string name, object content)
			: this(name)
		{
			Add(content);
		}

		public JConstructor(string name)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNullOrEmpty(name, "name");
			_name = name;
		}

		internal override bool DeepEquals(JToken node)
		{
			return node is JConstructor jConstructor && _name == jConstructor.Name && ContentsEqual(jConstructor);
		}

		internal override JToken CloneToken()
		{
			return new JConstructor(this);
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartConstructor(_name);
			foreach (JToken item in Children())
			{
				item.WriteTo(writer, converters);
			}
			writer.WriteEndConstructor();
		}

		internal override int GetDeepHashCode()
		{
			return _name.GetHashCode() ^ ContentsHashCode();
		}

		public new static JConstructor Load(JsonReader reader)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw new Exception("Error reading JConstructor from JsonReader.");
			}
			if (reader.TokenType != JsonToken.StartConstructor)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}", CultureInfo.InvariantCulture, reader.TokenType));
			}
			JConstructor jConstructor = new JConstructor((string)reader.Value);
			jConstructor.SetLineInfo(reader as IJsonLineInfo);
			jConstructor.ReadTokenFrom(reader);
			return jConstructor;
		}
	}
	public abstract class JContainer : JToken, IList<JToken>, IList, IEnumerable, ICollection<JToken>, IEnumerable<JToken>, ICollection
	{
		private class JTokenReferenceEqualityComparer : IEqualityComparer<JToken>
		{
			public static readonly JTokenReferenceEqualityComparer Instance = new JTokenReferenceEqualityComparer();

			public bool Equals(JToken x, JToken y)
			{
				return object.ReferenceEquals(x, y);
			}

			public int GetHashCode(JToken obj)
			{
				return obj?.GetHashCode() ?? 0;
			}
		}

		private object _syncRoot;

		private bool _busy;

		JToken IList<JToken>.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		bool ICollection<JToken>.IsReadOnly => false;

		bool IList.IsFixedSize => false;

		bool IList.IsReadOnly => false;

		object IList.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, EnsureValue(value));
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		protected abstract IList<JToken> ChildrenTokens { get; }

		public override bool HasValues => ChildrenTokens.Count > 0;

		public override JToken First => System.Linq.Enumerable.FirstOrDefault(ChildrenTokens);

		public override JToken Last => System.Linq.Enumerable.LastOrDefault(ChildrenTokens);

		public int Count => ChildrenTokens.Count;

		internal JContainer()
		{
		}

		internal JContainer(JContainer other)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(other, "c");
			foreach (JToken item in (IEnumerable<JToken>)other)
			{
				Add(item);
			}
		}

		internal void CheckReentrancy()
		{
			if (_busy)
			{
				throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot change {0} during a collection change event.", CultureInfo.InvariantCulture, GetType()));
			}
		}

		internal bool ContentsEqual(JContainer container)
		{
			JToken jToken = First;
			JToken jToken2 = container.First;
			if (jToken == jToken2)
			{
				return true;
			}
			while (true)
			{
				if (jToken == null && jToken2 == null)
				{
					return true;
				}
				if (jToken == null || jToken2 == null || !jToken.DeepEquals(jToken2))
				{
					break;
				}
				jToken = ((jToken == Last) ? null : jToken.Next);
				jToken2 = ((jToken2 == container.Last) ? null : jToken2.Next);
			}
			return false;
		}

		public override JEnumerable<JToken> Children()
		{
			return new JEnumerable<JToken>(ChildrenTokens);
		}

		public override IEnumerable<T> Values<T>()
		{
			return ChildrenTokens.Convert<JToken, T>();
		}

		public IEnumerable<JToken> Descendants()
		{
			foreach (JToken o in ChildrenTokens)
			{
				yield return o;
				if (!(o is JContainer c))
				{
					continue;
				}
				foreach (JToken item in c.Descendants())
				{
					yield return item;
				}
			}
		}

		internal bool IsMultiContent(object content)
		{
			return content is IEnumerable && !(content is string) && !(content is JToken) && !(content is byte[]);
		}

		internal JToken EnsureParentToken(JToken item)
		{
			if (item == null)
			{
				return new JValue((object)null);
			}
			if (item.Parent != null)
			{
				item = item.CloneToken();
			}
			else
			{
				JContainer jContainer = this;
				while (jContainer.Parent != null)
				{
					jContainer = jContainer.Parent;
				}
				if (item == jContainer)
				{
					item = item.CloneToken();
				}
			}
			return item;
		}

		internal int IndexOfItem(JToken item)
		{
			return PlayFab.Json.Utilities.CollectionUtils.IndexOf(ChildrenTokens, item, JTokenReferenceEqualityComparer.Instance);
		}

		internal virtual void InsertItem(int index, JToken item)
		{
			if (index > ChildrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index must be within the bounds of the List.");
			}
			CheckReentrancy();
			item = EnsureParentToken(item);
			JToken jToken = ((index != 0) ? ChildrenTokens[index - 1] : null);
			JToken jToken2 = ((index != ChildrenTokens.Count) ? ChildrenTokens[index] : null);
			ValidateToken(item, null);
			item.Parent = this;
			item.Previous = jToken;
			if (jToken != null)
			{
				jToken.Next = item;
			}
			item.Next = jToken2;
			if (jToken2 != null)
			{
				jToken2.Previous = item;
			}
			ChildrenTokens.Insert(index, item);
		}

		internal virtual void RemoveItemAt(int index)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= ChildrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			CheckReentrancy();
			JToken jToken = ChildrenTokens[index];
			JToken jToken2 = ((index != 0) ? ChildrenTokens[index - 1] : null);
			JToken jToken3 = ((index != ChildrenTokens.Count - 1) ? ChildrenTokens[index + 1] : null);
			if (jToken2 != null)
			{
				jToken2.Next = jToken3;
			}
			if (jToken3 != null)
			{
				jToken3.Previous = jToken2;
			}
			jToken.Parent = null;
			jToken.Previous = null;
			jToken.Next = null;
			ChildrenTokens.RemoveAt(index);
		}

		internal virtual bool RemoveItem(JToken item)
		{
			int num = IndexOfItem(item);
			if (num >= 0)
			{
				RemoveItemAt(num);
				return true;
			}
			return false;
		}

		internal virtual JToken GetItem(int index)
		{
			return ChildrenTokens[index];
		}

		internal virtual void SetItem(int index, JToken item)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= ChildrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			JToken jToken = ChildrenTokens[index];
			if (!IsTokenUnchanged(jToken, item))
			{
				CheckReentrancy();
				item = EnsureParentToken(item);
				ValidateToken(item, jToken);
				JToken jToken2 = ((index != 0) ? ChildrenTokens[index - 1] : null);
				JToken jToken3 = ((index != ChildrenTokens.Count - 1) ? ChildrenTokens[index + 1] : null);
				item.Parent = this;
				item.Previous = jToken2;
				if (jToken2 != null)
				{
					jToken2.Next = item;
				}
				item.Next = jToken3;
				if (jToken3 != null)
				{
					jToken3.Previous = item;
				}
				ChildrenTokens[index] = item;
				jToken.Parent = null;
				jToken.Previous = null;
				jToken.Next = null;
			}
		}

		internal virtual void ClearItems()
		{
			CheckReentrancy();
			foreach (JToken childrenToken in ChildrenTokens)
			{
				childrenToken.Parent = null;
				childrenToken.Previous = null;
				childrenToken.Next = null;
			}
			ChildrenTokens.Clear();
		}

		internal virtual void ReplaceItem(JToken existing, JToken replacement)
		{
			if (existing != null && existing.Parent == this)
			{
				int index = IndexOfItem(existing);
				SetItem(index, replacement);
			}
		}

		internal virtual bool ContainsItem(JToken item)
		{
			return IndexOfItem(item) != -1;
		}

		internal virtual void CopyItemsTo(Array array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				array.SetValue(childrenToken, arrayIndex + num);
				num++;
			}
		}

		internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue)
		{
			if (currentValue is JValue jValue)
			{
				if (jValue.Type == JTokenType.Null && newValue == null)
				{
					return true;
				}
				return jValue.Equals(newValue);
			}
			return false;
		}

		internal virtual void ValidateToken(JToken o, JToken existing)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type == JTokenType.Property)
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not add {0} to {1}.", CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
		}

		public virtual void Add(object content)
		{
			AddInternal(ChildrenTokens.Count, content);
		}

		public void AddFirst(object content)
		{
			AddInternal(0, content);
		}

		internal void AddInternal(int index, object content)
		{
			if (IsMultiContent(content))
			{
				IEnumerable enumerable = (IEnumerable)content;
				int num = index;
				{
					foreach (object item2 in enumerable)
					{
						AddInternal(num, item2);
						num++;
					}
					return;
				}
			}
			JToken item = CreateFromContent(content);
			InsertItem(index, item);
		}

		internal JToken CreateFromContent(object content)
		{
			if (content is JToken)
			{
				return (JToken)content;
			}
			return new JValue(content);
		}

		public JsonWriter CreateWriter()
		{
			return new JTokenWriter(this);
		}

		public void ReplaceAll(object content)
		{
			ClearItems();
			Add(content);
		}

		public void RemoveAll()
		{
			ClearItems();
		}

		internal void ReadTokenFrom(JsonReader r)
		{
			int depth = r.Depth;
			if (!r.Read())
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading {0} from JsonReader.", CultureInfo.InvariantCulture, GetType().Name));
			}
			ReadContentFrom(r);
			int depth2 = r.Depth;
			if (depth2 > depth)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected end of content while loading {0}.", CultureInfo.InvariantCulture, GetType().Name));
			}
		}

		internal void ReadContentFrom(JsonReader r)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(r, "r");
			IJsonLineInfo lineInfo = r as IJsonLineInfo;
			JContainer jContainer = this;
			do
			{
				if (jContainer is JProperty && ((JProperty)jContainer).Value != null)
				{
					if (jContainer == this)
					{
						break;
					}
					jContainer = jContainer.Parent;
				}
				switch (r.TokenType)
				{
				case JsonToken.StartArray:
				{
					JArray jArray = new JArray();
					jArray.SetLineInfo(lineInfo);
					jContainer.Add(jArray);
					jContainer = jArray;
					break;
				}
				case JsonToken.EndArray:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartObject:
				{
					JObject jObject2 = new JObject();
					jObject2.SetLineInfo(lineInfo);
					jContainer.Add(jObject2);
					jContainer = jObject2;
					break;
				}
				case JsonToken.EndObject:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartConstructor:
				{
					JConstructor jConstructor = new JConstructor(r.Value.ToString());
					jConstructor.SetLineInfo(jConstructor);
					jContainer.Add(jConstructor);
					jContainer = jConstructor;
					break;
				}
				case JsonToken.EndConstructor:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
				{
					JValue jValue = new JValue(r.Value);
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Comment:
				{
					JValue jValue = JValue.CreateComment(r.Value.ToString());
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Null:
				{
					JValue jValue = new JValue(null, JTokenType.Null);
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Undefined:
				{
					JValue jValue = new JValue(null, JTokenType.Undefined);
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.PropertyName:
				{
					string name = r.Value.ToString();
					JProperty jProperty = new JProperty(name);
					jProperty.SetLineInfo(lineInfo);
					JObject jObject = (JObject)jContainer;
					JProperty jProperty2 = jObject.Property(name);
					if (jProperty2 == null)
					{
						jContainer.Add(jProperty);
					}
					else
					{
						jProperty2.Replace(jProperty);
					}
					jContainer = jProperty;
					break;
				}
				default:
					throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("The JsonReader should not be on a token of type {0}.", CultureInfo.InvariantCulture, r.TokenType));
				case JsonToken.None:
					break;
				}
			}
			while (r.Read());
		}

		internal int ContentsHashCode()
		{
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				num ^= childrenToken.GetDeepHashCode();
			}
			return num;
		}

		int IList<JToken>.IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		void IList<JToken>.Insert(int index, JToken item)
		{
			InsertItem(index, item);
		}

		void IList<JToken>.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection<JToken>.Add(JToken item)
		{
			Add(item);
		}

		void ICollection<JToken>.Clear()
		{
			ClearItems();
		}

		bool ICollection<JToken>.Contains(JToken item)
		{
			return ContainsItem(item);
		}

		void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		bool ICollection<JToken>.Remove(JToken item)
		{
			return RemoveItem(item);
		}

		private JToken EnsureValue(object value)
		{
			if (value == null)
			{
				return null;
			}
			if (value is JToken)
			{
				return (JToken)value;
			}
			throw new ArgumentException("Argument is not a JToken.");
		}

		int IList.Add(object value)
		{
			Add(EnsureValue(value));
			return Count - 1;
		}

		void IList.Clear()
		{
			ClearItems();
		}

		bool IList.Contains(object value)
		{
			return ContainsItem(EnsureValue(value));
		}

		int IList.IndexOf(object value)
		{
			return IndexOfItem(EnsureValue(value));
		}

		void IList.Insert(int index, object value)
		{
			InsertItem(index, EnsureValue(value));
		}

		void IList.Remove(object value)
		{
			RemoveItem(EnsureValue(value));
		}

		void IList.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			CopyItemsTo(array, index);
		}
	}
	public struct JEnumerable<T> : IJEnumerable<T>, IEnumerable<T>, IEnumerable where T : JToken
	{
		public static readonly JEnumerable<T> Empty = new JEnumerable<T>(System.Linq.Enumerable.Empty<T>());

		private IEnumerable<T> _enumerable;

		public IJEnumerable<JToken> this[object key] => new JEnumerable<JToken>(_enumerable.Values<T, JToken>(key));

		public JEnumerable(IEnumerable<T> enumerable)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(enumerable, "enumerable");
			_enumerable = enumerable;
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _enumerable.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public override bool Equals(object obj)
		{
			if (obj is JEnumerable<T>)
			{
				return _enumerable.Equals(((JEnumerable<T>)obj)._enumerable);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return _enumerable.GetHashCode();
		}
	}
	public class JObject : JContainer, IDictionary<string, JToken>, INotifyPropertyChanged, ICustomTypeDescriptor, IEnumerable, ICollection<KeyValuePair<string, JToken>>, IEnumerable<KeyValuePair<string, JToken>>
	{
		public class JPropertKeyedCollection : KeyedCollection<string, JToken>
		{
			public new IDictionary<string, JToken> Dictionary => base.Dictionary;

			public JPropertKeyedCollection(IEqualityComparer<string> comparer)
				: base(comparer)
			{
			}

			protected override string GetKeyForItem(JToken item)
			{
				return ((JProperty)item).Name;
			}

			protected override void InsertItem(int index, JToken item)
			{
				if (Dictionary == null)
				{
					base.InsertItem(index, item);
					return;
				}
				string keyForItem = GetKeyForItem(item);
				Dictionary[keyForItem] = item;
				base.Items.Insert(index, item);
			}
		}

		private JPropertKeyedCollection _properties = new JPropertKeyedCollection(StringComparer.Ordinal);

		ICollection<string> IDictionary<string, JToken>.Keys => _properties.Dictionary.Keys;

		ICollection<JToken> IDictionary<string, JToken>.Values => _properties.Dictionary.Values;

		bool ICollection<KeyValuePair<string, JToken>>.IsReadOnly => false;

		protected override IList<JToken> ChildrenTokens => _properties;

		public override JTokenType Type => JTokenType.Object;

		public override JToken this[object key]
		{
			get
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is string propertyName))
				{
					throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Accessed JObject values with invalid key value: {0}. Object property name expected.", CultureInfo.InvariantCulture, PlayFab.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				return this[propertyName];
			}
			set
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is string propertyName))
				{
					throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Set JObject values with invalid key value: {0}. Object property name expected.", CultureInfo.InvariantCulture, PlayFab.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				this[propertyName] = value;
			}
		}

		public JToken this[string propertyName]
		{
			get
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(propertyName, "propertyName");
				return Property(propertyName)?.Value;
			}
			set
			{
				JProperty jProperty = Property(propertyName);
				if (jProperty != null)
				{
					jProperty.Value = value;
					return;
				}
				Add(new JProperty(propertyName, value));
				OnPropertyChanged(propertyName);
			}
		}

		public event PropertyChangedEventHandler PropertyChanged;

		public JObject()
		{
		}

		public JObject(JObject other)
			: base(other)
		{
		}

		public JObject(params object[] content)
			: this((object)content)
		{
		}

		public JObject(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			return node is JObject container && ContentsEqual(container);
		}

		internal override void InsertItem(int index, JToken item)
		{
			if (item == null || item.Type != JTokenType.Comment)
			{
				base.InsertItem(index, item);
			}
		}

		internal override void ValidateToken(JToken o, JToken existing)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type != JTokenType.Property)
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not add {0} to {1}.", CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
			JProperty jProperty = (JProperty)o;
			if (existing != null)
			{
				JProperty jProperty2 = (JProperty)existing;
				if (jProperty.Name == jProperty2.Name)
				{
					return;
				}
			}
			if (_properties.Dictionary != null && _properties.Dictionary.TryGetValue(jProperty.Name, out existing))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not add property {0} to {1}. Property with the same name already exists on object.", CultureInfo.InvariantCulture, jProperty.Name, GetType()));
			}
		}

		internal void InternalPropertyChanged(JProperty childProperty)
		{
			OnPropertyChanged(childProperty.Name);
		}

		internal void InternalPropertyChanging(JProperty childProperty)
		{
		}

		internal override JToken CloneToken()
		{
			return new JObject(this);
		}

		public IEnumerable<JProperty> Properties()
		{
			return System.Linq.Enumerable.Cast<JProperty>(ChildrenTokens);
		}

		public JProperty Property(string name)
		{
			if (_properties.Dictionary == null)
			{
				return null;
			}
			if (name == null)
			{
				return null;
			}
			_properties.Dictionary.TryGetValue(name, out var value);
			return (JProperty)value;
		}

		public JEnumerable<JToken> PropertyValues()
		{
			return new JEnumerable<JToken>(System.Linq.Enumerable.Select(Properties(), (JProperty p) => p.Value));
		}

		public new static JObject Load(JsonReader reader)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw new Exception("Error reading JObject from JsonReader.");
			}
			if (reader.TokenType != JsonToken.StartObject)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}", CultureInfo.InvariantCulture, reader.TokenType));
			}
			JObject jObject = new JObject();
			jObject.SetLineInfo(reader as IJsonLineInfo);
			jObject.ReadTokenFrom(reader);
			return jObject;
		}

		public new static JObject Parse(string json)
		{
			JsonReader reader = new JsonTextReader(new StringReader(json));
			return Load(reader);
		}

		public new static JObject FromObject(object o)
		{
			return FromObject(o, new JsonSerializer());
		}

		public new static JObject FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken != null && jToken.Type != JTokenType.Object)
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Object serialized to {0}. JObject instance expected.", CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JObject)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartObject();
			foreach (JProperty childrenToken in ChildrenTokens)
			{
				childrenToken.WriteTo(writer, converters);
			}
			writer.WriteEndObject();
		}

		public void Add(string propertyName, JToken value)
		{
			Add(new JProperty(propertyName, value));
		}

		bool IDictionary<string, JToken>.ContainsKey(string key)
		{
			if (_properties.Dictionary == null)
			{
				return false;
			}
			return _properties.Dictionary.ContainsKey(key);
		}

		public bool Remove(string propertyName)
		{
			JProperty jProperty = Property(propertyName);
			if (jProperty == null)
			{
				return false;
			}
			jProperty.Remove();
			return true;
		}

		public bool TryGetValue(string propertyName, out JToken value)
		{
			JProperty jProperty = Property(propertyName);
			if (jProperty == null)
			{
				value = null;
				return false;
			}
			value = jProperty.Value;
			return true;
		}

		void ICollection<KeyValuePair<string, JToken>>.Add(KeyValuePair<string, JToken> item)
		{
			Add(new JProperty(item.Key, item.Value));
		}

		void ICollection<KeyValuePair<string, JToken>>.Clear()
		{
			RemoveAll();
		}

		bool ICollection<KeyValuePair<string, JToken>>.Contains(KeyValuePair<string, JToken> item)
		{
			JProperty jProperty = Property(item.Key);
			if (jProperty == null)
			{
				return false;
			}
			return jProperty.Value == item.Value;
		}

		void ICollection<KeyValuePair<string, JToken>>.CopyTo(KeyValuePair<string, JToken>[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (base.Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JProperty childrenToken in ChildrenTokens)
			{
				ref KeyValuePair<string, JToken> reference = ref array[arrayIndex + num];
				reference = new KeyValuePair<string, JToken>(childrenToken.Name, childrenToken.Value);
				num++;
			}
		}

		bool ICollection<KeyValuePair<string, JToken>>.Remove(KeyValuePair<string, JToken> item)
		{
			if (!((ICollection<KeyValuePair<string, JToken>>)this).Contains(item))
			{
				return false;
			}
			((IDictionary<string, JToken>)this).Remove(item.Key);
			return true;
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}

		public IEnumerator<KeyValuePair<string, JToken>> GetEnumerator()
		{
			foreach (JProperty property in ChildrenTokens)
			{
				yield return new KeyValuePair<string, JToken>(property.Name, property.Value);
			}
		}

		protected virtual void OnPropertyChanged(string propertyName)
		{
			if (this.PropertyChanged != null)
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
		{
			return ((ICustomTypeDescriptor)this).GetProperties((Attribute[])null);
		}

		private static Type GetTokenPropertyType(JToken token)
		{
			if (token is JValue)
			{
				JValue jValue = (JValue)token;
				return (jValue.Value == null) ? typeof(object) : jValue.Value.GetType();
			}
			return token.GetType();
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
		{
			PropertyDescriptorCollection propertyDescriptorCollection = new PropertyDescriptorCollection(null);
			using IEnumerator<KeyValuePair<string, JToken>> enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				KeyValuePair<string, JToken> current = enumerator.Current;
				propertyDescriptorCollection.Add(new JPropertyDescriptor(current.Key, GetTokenPropertyType(current.Value)));
			}
			return propertyDescriptorCollection;
		}

		AttributeCollection ICustomTypeDescriptor.GetAttributes()
		{
			return AttributeCollection.Empty;
		}

		string ICustomTypeDescriptor.GetClassName()
		{
			return null;
		}

		string ICustomTypeDescriptor.GetComponentName()
		{
			return null;
		}

		TypeConverter ICustomTypeDescriptor.GetConverter()
		{
			return new TypeConverter();
		}

		EventDescriptor ICustomTypeDescriptor.GetDefaultEvent()
		{
			return null;
		}

		PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty()
		{
			return null;
		}

		object ICustomTypeDescriptor.GetEditor(Type editorBaseType)
		{
			return null;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
		{
			return EventDescriptorCollection.Empty;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents()
		{
			return EventDescriptorCollection.Empty;
		}

		object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
		{
			return null;
		}
	}
	internal class JPath
	{
		private readonly string _expression;

		private int _currentIndex;

		public List<object> Parts { get; private set; }

		public JPath(string expression)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(expression, "expression");
			_expression = expression;
			Parts = new List<object>();
			ParseMain();
		}

		private void ParseMain()
		{
			int num = _currentIndex;
			bool flag = false;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				switch (c)
				{
				case '(':
				case '[':
					if (_currentIndex > num)
					{
						string item2 = _expression.Substring(num, _currentIndex - num);
						Parts.Add(item2);
					}
					ParseIndexer(c);
					num = _currentIndex + 1;
					flag = true;
					break;
				case ')':
				case ']':
					throw new Exception("Unexpected character while parsing path: " + c);
				case '.':
					if (_currentIndex > num)
					{
						string item = _expression.Substring(num, _currentIndex - num);
						Parts.Add(item);
					}
					num = _currentIndex + 1;
					flag = false;
					break;
				default:
					if (flag)
					{
						throw new Exception("Unexpected character following indexer: " + c);
					}
					break;
				}
				_currentIndex++;
			}
			if (_currentIndex > num)
			{
				string item3 = _expression.Substring(num, _currentIndex - num);
				Parts.Add(item3);
			}
		}

		private void ParseIndexer(char indexerOpenChar)
		{
			_currentIndex++;
			char c = ((indexerOpenChar != '[') ? ')' : ']');
			int currentIndex = _currentIndex;
			int num = 0;
			bool flag = false;
			while (_currentIndex < _expression.Length)
			{
				char c2 = _expression[_currentIndex];
				if (char.IsDigit(c2))
				{
					num++;
					_currentIndex++;
					continue;
				}
				if (c2 == c)
				{
					flag = true;
					break;
				}
				throw new Exception("Unexpected character while parsing path indexer: " + c2);
			}
			if (!flag)
			{
				throw new Exception("Path ended with open indexer. Expected " + c);
			}
			if (num == 0)
			{
				throw new Exception("Empty path indexer.");
			}
			string value = _expression.Substring(currentIndex, num);
			Parts.Add(Convert.ToInt32(value, CultureInfo.InvariantCulture));
		}

		internal JToken Evaluate(JToken root, bool errorWhenNoMatch)
		{
			JToken jToken = root;
			foreach (object part in Parts)
			{
				if (part is string text)
				{
					if (jToken is JObject jObject)
					{
						jToken = jObject[text];
						if (jToken == null && errorWhenNoMatch)
						{
							throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Property '{0}' does not exist on JObject.", CultureInfo.InvariantCulture, text));
						}
						continue;
					}
					if (errorWhenNoMatch)
					{
						throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Property '{0}' not valid on {1}.", CultureInfo.InvariantCulture, text, jToken.GetType().Name));
					}
					return null;
				}
				int num = (int)part;
				if (jToken is JArray jArray)
				{
					if (jArray.Count <= num)
					{
						if (errorWhenNoMatch)
						{
							throw new IndexOutOfRangeException(PlayFab.Json.Utilities.StringUtils.FormatWith("Index {0} outside the bounds of JArray.", CultureInfo.InvariantCulture, num));
						}
						return null;
					}
					jToken = jArray[num];
					continue;
				}
				if (errorWhenNoMatch)
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Index {0} not valid on {1}.", CultureInfo.InvariantCulture, num, jToken.GetType().Name));
				}
				return null;
			}
			return jToken;
		}
	}
	public class JProperty : JContainer
	{
		private readonly List<JToken> _content = new List<JToken>();

		private readonly string _name;

		protected override IList<JToken> ChildrenTokens => _content;

		public string Name
		{
			[DebuggerStepThrough]
			get
			{
				return _name;
			}
		}

		public new JToken Value
		{
			[DebuggerStepThrough]
			get
			{
				return (ChildrenTokens.Count <= 0) ? null : ChildrenTokens[0];
			}
			set
			{
				CheckReentrancy();
				JToken item = value ?? new JValue((object)null);
				if (ChildrenTokens.Count == 0)
				{
					InsertItem(0, item);
				}
				else
				{
					SetItem(0, item);
				}
			}
		}

		public override JTokenType Type
		{
			[DebuggerStepThrough]
			get
			{
				return JTokenType.Property;
			}
		}

		public JProperty(JProperty other)
			: base(other)
		{
			_name = other.Name;
		}

		internal JProperty(string name)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
		}

		public JProperty(string name, params object[] content)
			: this(name, (object)content)
		{
		}

		public JProperty(string name, object content)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
			Value = ((!IsMultiContent(content)) ? CreateFromContent(content) : new JArray(content));
		}

		internal override JToken GetItem(int index)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			return Value;
		}

		internal override void SetItem(int index, JToken item)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			if (!JContainer.IsTokenUnchanged(Value, item))
			{
				if (base.Parent != null)
				{
					((JObject)base.Parent).InternalPropertyChanging(this);
				}
				base.SetItem(0, item);
				if (base.Parent != null)
				{
					((JObject)base.Parent).InternalPropertyChanged(this);
				}
			}
		}

		internal override bool RemoveItem(JToken item)
		{
			throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot add or remove items from {0}.", CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override void RemoveItemAt(int index)
		{
			throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot add or remove items from {0}.", CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override void InsertItem(int index, JToken item)
		{
			if (Value != null)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("{0} cannot have multiple values.", CultureInfo.InvariantCulture, typeof(JProperty)));
			}
			base.InsertItem(0, item);
		}

		internal override bool ContainsItem(JToken item)
		{
			return Value == item;
		}

		internal override void ClearItems()
		{
			throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot add or remove items from {0}.", CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override bool DeepEquals(JToken node)
		{
			return node is JProperty jProperty && _name == jProperty.Name && ContentsEqual(jProperty);
		}

		internal override JToken CloneToken()
		{
			return new JProperty(this);
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WritePropertyName(_name);
			Value.WriteTo(writer, converters);
		}

		internal override int GetDeepHashCode()
		{
			return _name.GetHashCode() ^ ((Value != null) ? Value.GetDeepHashCode() : 0);
		}

		public new static JProperty Load(JsonReader reader)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw new Exception("Error reading JProperty from JsonReader.");
			}
			if (reader.TokenType != JsonToken.PropertyName)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}", CultureInfo.InvariantCulture, reader.TokenType));
			}
			JProperty jProperty = new JProperty((string)reader.Value);
			jProperty.SetLineInfo(reader as IJsonLineInfo);
			jProperty.ReadTokenFrom(reader);
			return jProperty;
		}
	}
	public class JPropertyDescriptor : PropertyDescriptor
	{
		private readonly Type _propertyType;

		public override Type ComponentType => typeof(JObject);

		public override bool IsReadOnly => false;

		public override Type PropertyType => _propertyType;

		protected override int NameHashCode => base.NameHashCode;

		public JPropertyDescriptor(string name, Type propertyType)
			: base(name, null)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(name, "name");
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(propertyType, "propertyType");
			_propertyType = propertyType;
		}

		private static JObject CastInstance(object instance)
		{
			return (JObject)instance;
		}

		public override bool CanResetValue(object component)
		{
			return false;
		}

		public override object GetValue(object component)
		{
			return CastInstance(component)[Name];
		}

		public override void ResetValue(object component)
		{
		}

		public override void SetValue(object component, object value)
		{
			JToken value2 = ((!(value is JToken)) ? new JValue(value) : ((JToken)value));
			CastInstance(component)[Name] = value2;
		}

		public override bool ShouldSerializeValue(object component)
		{
			return false;
		}
	}
	public class JRaw : JValue
	{
		public JRaw(JRaw other)
			: base(other)
		{
		}

		public JRaw(object rawJson)
			: base(rawJson, JTokenType.Raw)
		{
		}

		public static JRaw Create(JsonReader reader)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			using JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.WriteToken(reader);
			return new JRaw(stringWriter.ToString());
		}

		internal override JToken CloneToken()
		{
			return new JRaw(this);
		}
	}
	public abstract class JToken : IJEnumerable<JToken>, IJsonLineInfo, ICloneable, IEnumerable<JToken>, IEnumerable
	{
		private JContainer _parent;

		private JToken _previous;

		private JToken _next;

		private static JTokenEqualityComparer _equalityComparer;

		private int? _lineNumber;

		private int? _linePosition;

		IJEnumerable<JToken> IJEnumerable<JToken>.this[object key] => this[key];

		int IJsonLineInfo.LineNumber
		{
			get
			{
				int? lineNumber = _lineNumber;
				return lineNumber.HasValue ? lineNumber.Value : 0;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				int? linePosition = _linePosition;
				return linePosition.HasValue ? linePosition.Value : 0;
			}
		}

		public static JTokenEqualityComparer EqualityComparer
		{
			get
			{
				if (_equalityComparer == null)
				{
					_equalityComparer = new JTokenEqualityComparer();
				}
				return _equalityComparer;
			}
		}

		public JContainer Parent
		{
			[DebuggerStepThrough]
			get
			{
				return _parent;
			}
			internal set
			{
				_parent = value;
			}
		}

		public JToken Root
		{
			get
			{
				JContainer parent = Parent;
				if (parent == null)
				{
					return this;
				}
				while (parent.Parent != null)
				{
					parent = parent.Parent;
				}
				return parent;
			}
		}

		public abstract JTokenType Type { get; }

		public abstract bool HasValues { get; }

		public JToken Next
		{
			get
			{
				return _next;
			}
			internal set
			{
				_next = value;
			}
		}

		public JToken Previous
		{
			get
			{
				return _previous;
			}
			internal set
			{
				_previous = value;
			}
		}

		public virtual JToken this[object key]
		{
			get
			{
				throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot access child value on {0}.", CultureInfo.InvariantCulture, GetType()));
			}
			set
			{
				throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot set child value on {0}.", CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken First
		{
			get
			{
				throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot access child value on {0}.", CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken Last
		{
			get
			{
				throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot access child value on {0}.", CultureInfo.InvariantCulture, GetType()));
			}
		}

		internal JToken()
		{
		}

		internal abstract JToken CloneToken();

		internal abstract bool DeepEquals(JToken node);

		public static bool DeepEquals(JToken t1, JToken t2)
		{
			return t1 == t2 || (t1 != null && t2 != null && t1.DeepEquals(t2));
		}

		public void AddAfterSelf(object content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int num = _parent.IndexOfItem(this);
			_parent.AddInternal(num + 1, content);
		}

		public void AddBeforeSelf(object content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int index = _parent.IndexOfItem(this);
			_parent.AddInternal(index, content);
		}

		public IEnumerable<JToken> Ancestors()
		{
			for (JToken parent = Parent; parent != null; parent = parent.Parent)
			{
				yield return parent;
			}
		}

		public IEnumerable<JToken> AfterSelf()
		{
			if (Parent != null)
			{
				for (JToken o = Next; o != null; o = o.Next)
				{
					yield return o;
				}
			}
		}

		public IEnumerable<JToken> BeforeSelf()
		{
			for (JToken o = Parent.First; o != this; o = o.Next)
			{
				yield return o;
			}
		}

		public virtual T Value<T>(object key)
		{
			JToken token = this[key];
			return token.Convert<JToken, T>();
		}

		public virtual JEnumerable<JToken> Children()
		{
			return JEnumerable<JToken>.Empty;
		}

		public JEnumerable<T> Children<T>() where T : JToken
		{
			return new JEnumerable<T>(System.Linq.Enumerable.OfType<T>(Children()));
		}

		public virtual IEnumerable<T> Values<T>()
		{
			throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot access child value on {0}.", CultureInfo.InvariantCulture, GetType()));
		}

		public void Remove()
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.RemoveItem(this);
		}

		public void Replace(JToken value)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.ReplaceItem(this, value);
		}

		public abstract void WriteTo(JsonWriter writer, params JsonConverter[] converters);

		public override string ToString()
		{
			return ToString(Formatting.Indented);
		}

		public string ToString(Formatting formatting, params JsonConverter[] converters)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.Formatting = formatting;
			WriteTo(jsonTextWriter, converters);
			return stringWriter.ToString();
		}

		private static JValue EnsureValue(JToken value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value is JProperty)
			{
				value = ((JProperty)value).Value;
			}
			return value as JValue;
		}

		private static string GetType(JToken token)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(token, "token");
			if (token is JProperty)
			{
				token = ((JProperty)token).Value;
			}
			return token.Type.ToString();
		}

		private static bool IsNullable(JToken o)
		{
			return o.Type == JTokenType.Undefined || o.Type == JTokenType.Null;
		}

		private static bool ValidateFloat(JToken o, bool nullable)
		{
			return o.Type == JTokenType.Float || o.Type == JTokenType.Integer || (nullable && IsNullable(o));
		}

		private static bool ValidateInteger(JToken o, bool nullable)
		{
			return o.Type == JTokenType.Integer || (nullable && IsNullable(o));
		}

		private static bool ValidateDate(JToken o, bool nullable)
		{
			return o.Type == JTokenType.Date || (nullable && IsNullable(o));
		}

		private static bool ValidateBoolean(JToken o, bool nullable)
		{
			return o.Type == JTokenType.Boolean || (nullable && IsNullable(o));
		}

		private static bool ValidateString(JToken o)
		{
			return o.Type == JTokenType.String || o.Type == JTokenType.Comment || o.Type == JTokenType.Raw || IsNullable(o);
		}

		private static bool ValidateBytes(JToken o)
		{
			return o.Type == JTokenType.Bytes || IsNullable(o);
		}

		public static explicit operator bool(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateBoolean(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Boolean.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (bool)jValue.Value;
		}

		public static explicit operator DateTimeOffset(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateDate(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to DateTimeOffset.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (DateTimeOffset)jValue.Value;
		}

		public static explicit operator bool?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateBoolean(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Boolean.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (bool?)jValue.Value;
		}

		public static explicit operator long(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Int64.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (long)jValue.Value;
		}

		public static explicit operator DateTime?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateDate(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to DateTime.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (DateTime?)jValue.Value;
		}

		public static explicit operator DateTimeOffset?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateDate(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to DateTimeOffset.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (DateTimeOffset?)jValue.Value;
		}

		public static explicit operator decimal?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateFloat(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Decimal.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new decimal?(Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator double?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateFloat(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Double.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (double?)jValue.Value;
		}

		public static explicit operator int(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Int32.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator short(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Int16.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator ushort(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to UInt16.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator int?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Int32.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new int?(Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator short?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Int16.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new short?(Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator ushort?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to UInt16.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new ushort?((ushort)Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator DateTime(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateDate(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to DateTime.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (DateTime)jValue.Value;
		}

		public static explicit operator long?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Int64.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (long?)jValue.Value;
		}

		public static explicit operator float?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateFloat(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Single.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new float?(Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator decimal(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateFloat(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Decimal.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator uint?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to UInt32.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (uint?)jValue.Value;
		}

		public static explicit operator ulong?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: true))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to UInt64.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (ulong?)jValue.Value;
		}

		public static explicit operator double(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateFloat(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Double.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (double)jValue.Value;
		}

		public static explicit operator float(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateFloat(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to Single.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator string(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateString(jValue))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to String.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (string)jValue.Value;
		}

		public static explicit operator uint(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to UInt32.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator ulong(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateInteger(jValue, nullable: false))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to UInt64.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte[](JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateBytes(jValue))
			{
				throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Can not convert {0} to byte array.", CultureInfo.InvariantCulture, GetType(value)));
			}
			return (byte[])jValue.Value;
		}

		public static implicit operator JToken(bool value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTimeOffset value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(bool? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTimeOffset? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(short value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ushort value)
		{
			return new JValue((int)value);
		}

		public static implicit operator JToken(int value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(int? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(short? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ushort? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(uint? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ulong? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(string value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(uint value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ulong value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte[] value)
		{
			return new JValue(value);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<JToken>)this).GetEnumerator();
		}

		IEnumerator<JToken> IEnumerable<JToken>.GetEnumerator()
		{
			return Children().GetEnumerator();
		}

		internal abstract int GetDeepHashCode();

		public JsonReader CreateReader()
		{
			return new JTokenReader(this);
		}

		internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(o, "o");
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenWriter jTokenWriter = new JTokenWriter();
			jsonSerializer.Serialize(jTokenWriter, o);
			return jTokenWriter.Token;
		}

		public static JToken FromObject(object o)
		{
			return FromObjectInternal(o, new JsonSerializer());
		}

		public static JToken FromObject(object o, JsonSerializer jsonSerializer)
		{
			return FromObjectInternal(o, jsonSerializer);
		}

		public T ToObject<T>()
		{
			return ToObject<T>(new JsonSerializer());
		}

		public T ToObject<T>(JsonSerializer jsonSerializer)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenReader reader = new JTokenReader(this);
			return jsonSerializer.Deserialize<T>(reader);
		}

		public static JToken ReadFrom(JsonReader reader)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw new Exception("Error reading JToken from JsonReader.");
			}
			if (reader.TokenType == JsonToken.StartObject)
			{
				return JObject.Load(reader);
			}
			if (reader.TokenType == JsonToken.StartArray)
			{
				return JArray.Load(reader);
			}
			if (reader.TokenType == JsonToken.PropertyName)
			{
				return JProperty.Load(reader);
			}
			if (reader.TokenType == JsonToken.StartConstructor)
			{
				return JConstructor.Load(reader);
			}
			if (!JsonReader.IsStartToken(reader.TokenType))
			{
				return new JValue(reader.Value);
			}
			throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading JToken from JsonReader. Unexpected token: {0}", CultureInfo.InvariantCulture, reader.TokenType));
		}

		public static JToken Parse(string json)
		{
			JsonReader reader = new JsonTextReader(new StringReader(json));
			return Load(reader);
		}

		public static JToken Load(JsonReader reader)
		{
			return ReadFrom(reader);
		}

		internal void SetLineInfo(IJsonLineInfo lineInfo)
		{
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
			}
		}

		internal void SetLineInfo(int lineNumber, int linePosition)
		{
			_lineNumber = lineNumber;
			_linePosition = linePosition;
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			int? lineNumber = _lineNumber;
			int result;
			if (lineNumber.HasValue)
			{
				int? linePosition = _linePosition;
				result = (linePosition.HasValue ? 1 : 0);
			}
			else
			{
				result = 0;
			}
			return (byte)result != 0;
		}

		public JToken SelectToken(string path)
		{
			return SelectToken(path, errorWhenNoMatch: false);
		}

		public JToken SelectToken(string path, bool errorWhenNoMatch)
		{
			JPath jPath = new JPath(path);
			return jPath.Evaluate(this, errorWhenNoMatch);
		}

		object ICloneable.Clone()
		{
			return DeepClone();
		}

		public JToken DeepClone()
		{
			return CloneToken();
		}
	}
	public class JTokenEqualityComparer : IEqualityComparer<JToken>
	{
		public bool Equals(JToken x, JToken y)
		{
			return JToken.DeepEquals(x, y);
		}

		public int GetHashCode(JToken obj)
		{
			return obj?.GetDeepHashCode() ?? 0;
		}
	}
	public class JTokenReader : JsonReader, IJsonLineInfo
	{
		private readonly JToken _root;

		private JToken _parent;

		private JToken _current;

		int IJsonLineInfo.LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)((!IsEndElement) ? _current : null))?.LineNumber ?? 0;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)((!IsEndElement) ? _current : null))?.LinePosition ?? 0;
			}
		}

		private bool IsEndElement => _current == _parent;

		public JTokenReader(JToken token)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(token, "token");
			_root = token;
			_current = token;
		}

		public override byte[] ReadAsBytes()
		{
			Read();
			if (TokenType == JsonToken.String)
			{
				string text = (string)Value;
				byte[] value = ((text.Length != 0) ? Convert.FromBase64String(text) : new byte[0]);
				SetToken(JsonToken.Bytes, value);
			}
			if (TokenType == JsonToken.Null)
			{
				return null;
			}
			if (TokenType == JsonToken.Bytes)
			{
				return (byte[])Value;
			}
			throw new JsonReaderException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading bytes. Expected bytes but got {0}.", CultureInfo.InvariantCulture, TokenType));
		}

		public override decimal? ReadAsDecimal()
		{
			Read();
			if (TokenType == JsonToken.Null)
			{
				return null;
			}
			if (TokenType == JsonToken.Integer || TokenType == JsonToken.Float)
			{
				SetToken(JsonToken.Float, Convert.ToDecimal(Value, CultureInfo.InvariantCulture));
				return (decimal)Value;
			}
			throw new JsonReaderException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading decimal. Expected a number but got {0}.", CultureInfo.InvariantCulture, TokenType));
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			Read();
			if (TokenType == JsonToken.Null)
			{
				return null;
			}
			if (TokenType == JsonToken.Date)
			{
				SetToken(JsonToken.Date, new DateTimeOffset((DateTime)Value));
				return (DateTimeOffset)Value;
			}
			throw new JsonReaderException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error reading date. Expected bytes but got {0}.", CultureInfo.InvariantCulture, TokenType));
		}

		public override bool Read()
		{
			if (base.CurrentState != 0)
			{
				if (_current is JContainer jContainer && _parent != jContainer)
				{
					return ReadInto(jContainer);
				}
				return ReadOver(_current);
			}
			SetToken(_current);
			return true;
		}

		private bool ReadOver(JToken t)
		{
			if (t == _root)
			{
				return ReadToEnd();
			}
			JToken next = t.Next;
			if (next == null || next == t || t == t.Parent.Last)
			{
				if (t.Parent == null)
				{
					return ReadToEnd();
				}
				return SetEnd(t.Parent);
			}
			_current = next;
			SetToken(_current);
			return true;
		}

		private bool ReadToEnd()
		{
			return false;
		}

		private JsonToken? GetEndToken(JContainer c)
		{
			return c.Type switch
			{
				JTokenType.Object => JsonToken.EndObject, 
				JTokenType.Array => JsonToken.EndArray, 
				JTokenType.Constructor => JsonToken.EndConstructor, 
				JTokenType.Property => null, 
				_ => throw PlayFab.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", c.Type, "Unexpected JContainer type."), 
			};
		}

		private bool ReadInto(JContainer c)
		{
			JToken first = c.First;
			if (first == null)
			{
				return SetEnd(c);
			}
			SetToken(first);
			_current = first;
			_parent = c;
			return true;
		}

		private bool SetEnd(JContainer c)
		{
			JsonToken? endToken = GetEndToken(c);
			if (endToken.HasValue)
			{
				SetToken(endToken.Value);
				_current = c;
				_parent = c;
				return true;
			}
			return ReadOver(c);
		}

		private void SetToken(JToken token)
		{
			switch (token.Type)
			{
			case JTokenType.Object:
				SetToken(JsonToken.StartObject);
				break;
			case JTokenType.Array:
				SetToken(JsonToken.StartArray);
				break;
			case JTokenType.Constructor:
				SetToken(JsonToken.StartConstructor);
				break;
			case JTokenType.Property:
				SetToken(JsonToken.PropertyName, ((JProperty)token).Name);
				break;
			case JTokenType.Comment:
				SetToken(JsonToken.Comment, ((JValue)token).Value);
				break;
			case JTokenType.Integer:
				SetToken(JsonToken.Integer, ((JValue)token).Value);
				break;
			case JTokenType.Float:
				SetToken(JsonToken.Float, ((JValue)token).Value);
				break;
			case JTokenType.String:
				SetToken(JsonToken.String, ((JValue)token).Value);
				break;
			case JTokenType.Boolean:
				SetToken(JsonToken.Boolean, ((JValue)token).Value);
				break;
			case JTokenType.Null:
				SetToken(JsonToken.Null, ((JValue)token).Value);
				break;
			case JTokenType.Undefined:
				SetToken(JsonToken.Undefined, ((JValue)token).Value);
				break;
			case JTokenType.Date:
				SetToken(JsonToken.Date, ((JValue)token).Value);
				break;
			case JTokenType.Raw:
				SetToken(JsonToken.Raw, ((JValue)token).Value);
				break;
			case JTokenType.Bytes:
				SetToken(JsonToken.Bytes, ((JValue)token).Value);
				break;
			case JTokenType.Guid:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			case JTokenType.Uri:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			case JTokenType.TimeSpan:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			default:
				throw PlayFab.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", token.Type, "Unexpected JTokenType.");
			}
		}

		private string SafeToString(object value)
		{
			return value?.ToString();
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			if (base.CurrentState == State.Start)
			{
				return false;
			}
			return ((IJsonLineInfo)((!IsEndElement) ? _current : null))?.HasLineInfo() ?? false;
		}
	}
	public enum JTokenType
	{
		None,
		Object,
		Array,
		Constructor,
		Property,
		Comment,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		Date,
		Raw,
		Bytes,
		Guid,
		Uri,
		TimeSpan
	}
	public class JTokenWriter : JsonWriter
	{
		private JContainer _token;

		private JContainer _parent;

		private JValue _value;

		public JToken Token
		{
			get
			{
				if (_token != null)
				{
					return _token;
				}
				return _value;
			}
		}

		public JTokenWriter(JContainer container)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(container, "container");
			_token = container;
			_parent = container;
		}

		public JTokenWriter()
		{
		}

		public override void Flush()
		{
		}

		public override void Close()
		{
			base.Close();
		}

		public override void WriteStartObject()
		{
			base.WriteStartObject();
			AddParent(new JObject());
		}

		private void AddParent(JContainer container)
		{
			if (_parent == null)
			{
				_token = container;
			}
			else
			{
				_parent.Add(container);
			}
			_parent = container;
		}

		private void RemoveParent()
		{
			_parent = _parent.Parent;
			if (_parent != null && _parent.Type == JTokenType.Property)
			{
				_parent = _parent.Parent;
			}
		}

		public override void WriteStartArray()
		{
			base.WriteStartArray();
			AddParent(new JArray());
		}

		public override void WriteStartConstructor(string name)
		{
			base.WriteStartConstructor(name);
			AddParent(new JConstructor(name));
		}

		protected override void WriteEnd(JsonToken token)
		{
			RemoveParent();
		}

		public override void WritePropertyName(string name)
		{
			base.WritePropertyName(name);
			AddParent(new JProperty(name));
		}

		private void AddValue(object value, JsonToken token)
		{
			AddValue(new JValue(value), token);
		}

		internal void AddValue(JValue value, JsonToken token)
		{
			if (_parent != null)
			{
				_parent.Add(value);
				if (_parent.Type == JTokenType.Property)
				{
					_parent = _parent.Parent;
				}
			}
			else
			{
				_value = value;
			}
		}

		public override void WriteNull()
		{
			base.WriteNull();
			AddValue(null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			base.WriteUndefined();
			AddValue(null, JsonToken.Undefined);
		}

		public override void WriteRaw(string json)
		{
			base.WriteRaw(json);
			AddValue(new JRaw(json), JsonToken.Raw);
		}

		public override void WriteComment(string text)
		{
			base.WriteComment(text);
			AddValue(JValue.CreateComment(text), JsonToken.Comment);
		}

		public override void WriteValue(string value)
		{
			base.WriteValue(value);
			AddValue(value ?? string.Empty, JsonToken.String);
		}

		public override void WriteValue(int value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(uint value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(long value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(ulong value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(float value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(ushort value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(char value)
		{
			base.WriteValue(value);
			AddValue(value.ToString(), JsonToken.String);
		}

		public override void WriteValue(byte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(sbyte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(decimal value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Date);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Date);
		}

		public override void WriteValue(byte[] value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Bytes);
		}

		public override void WriteValue(TimeSpan value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Guid value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Uri value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}
	}
	public class JValue : JToken, IEquatable<JValue>, IFormattable, IComparable, IComparable<JValue>
	{
		private JTokenType _valueType;

		private object _value;

		public override bool HasValues => false;

		public override JTokenType Type => _valueType;

		public new object Value
		{
			get
			{
				return _value;
			}
			set
			{
				Type type = ((_value == null) ? null : _value.GetType());
				Type type2 = value?.GetType();
				if (type != type2)
				{
					_valueType = GetValueType(_valueType, value);
				}
				_value = value;
			}
		}

		internal JValue(object value, JTokenType type)
		{
			_value = value;
			_valueType = type;
		}

		public JValue(JValue other)
			: this(other.Value, other.Type)
		{
		}

		public JValue(long value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(ulong value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(double value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(DateTime value)
			: this(value, JTokenType.Date)
		{
		}

		public JValue(bool value)
			: this(value, JTokenType.Boolean)
		{
		}

		public JValue(string value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(Guid value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(Uri value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(TimeSpan value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(object value)
			: this(value, GetValueType(null, value))
		{
		}

		internal override bool DeepEquals(JToken node)
		{
			if (!(node is JValue v))
			{
				return false;
			}
			return ValuesEquals(this, v);
		}

		private static int Compare(JTokenType valueType, object objA, object objB)
		{
			if (objA == null && objB == null)
			{
				return 0;
			}
			if (objA != null && objB == null)
			{
				return 1;
			}
			if (objA == null && objB != null)
			{
				return -1;
			}
			switch (valueType)
			{
			case JTokenType.Integer:
				if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
				{
					return Convert.ToDecimal(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, CultureInfo.InvariantCulture));
				}
				if (objA is float || objB is float || objA is double || objB is double)
				{
					return CompareFloat(objA, objB);
				}
				return Convert.ToInt64(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB, CultureInfo.InvariantCulture));
			case JTokenType.Float:
				return CompareFloat(objA, objB);
			case JTokenType.Comment:
			case JTokenType.String:
			case JTokenType.Raw:
			{
				string text = Convert.ToString(objA, CultureInfo.InvariantCulture);
				string strB = Convert.ToString(objB, CultureInfo.InvariantCulture);
				return text.CompareTo(strB);
			}
			case JTokenType.Boolean:
			{
				bool flag = Convert.ToBoolean(objA, CultureInfo.InvariantCulture);
				bool value3 = Convert.ToBoolean(objB, CultureInfo.InvariantCulture);
				return flag.CompareTo(value3);
			}
			case JTokenType.Date:
			{
				if (objA is DateTime)
				{
					DateTime dateTime = Convert.ToDateTime(objA, CultureInfo.InvariantCulture);
					DateTime value2 = Convert.ToDateTime(objB, CultureInfo.InvariantCulture);
					return dateTime.CompareTo(value2);
				}
				if (!(objB is DateTimeOffset))
				{
					throw new ArgumentException("Object must be of type DateTimeOffset.");
				}
				DateTimeOffset dateTimeOffset = (DateTimeOffset)objA;
				DateTimeOffset other = (DateTimeOffset)objB;
				return dateTimeOffset.CompareTo(other);
			}
			case JTokenType.Bytes:
			{
				if (!(objB is byte[]))
				{
					throw new ArgumentException("Object must be of type byte[].");
				}
				byte[] array = objA as byte[];
				byte[] array2 = objB as byte[];
				if (array == null)
				{
					return -1;
				}
				if (array2 == null)
				{
					return 1;
				}
				return PlayFab.Json.Utilities.MiscellaneousUtils.ByteArrayCompare(array, array2);
			}
			case JTokenType.Guid:
			{
				if (!(objB is Guid))
				{
					throw new ArgumentException("Object must be of type Guid.");
				}
				Guid guid = (Guid)objA;
				Guid value4 = (Guid)objB;
				return guid.CompareTo(value4);
			}
			case JTokenType.Uri:
			{
				if (!(objB is Uri))
				{
					throw new ArgumentException("Object must be of type Uri.");
				}
				Uri uri = (Uri)objA;
				Uri uri2 = (Uri)objB;
				return Comparer<string>.Default.Compare(uri.ToString(), uri2.ToString());
			}
			case JTokenType.TimeSpan:
			{
				if (!(objB is TimeSpan))
				{
					throw new ArgumentException("Object must be of type TimeSpan.");
				}
				TimeSpan timeSpan = (TimeSpan)objA;
				TimeSpan value = (TimeSpan)objB;
				return timeSpan.CompareTo(value);
			}
			default:
				throw PlayFab.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("valueType", valueType, PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected value type: {0}", CultureInfo.InvariantCulture, valueType));
			}
		}

		private static int CompareFloat(object objA, object objB)
		{
			double d = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
			double num = Convert.ToDouble(objB, CultureInfo.InvariantCulture);
			if (PlayFab.Json.Utilities.MathUtils.ApproxEquals(d, num))
			{
				return 0;
			}
			return d.CompareTo(num);
		}

		internal override JToken CloneToken()
		{
			return new JValue(this);
		}

		public static JValue CreateComment(string value)
		{
			return new JValue(value, JTokenType.Comment);
		}

		public static JValue CreateString(string value)
		{
			return new JValue(value, JTokenType.String);
		}

		private static JTokenType GetValueType(JTokenType? current, object value)
		{
			if (value == null)
			{
				return JTokenType.Null;
			}
			if (value == DBNull.Value)
			{
				return JTokenType.Null;
			}
			if (value is string)
			{
				return GetStringValueType(current);
			}
			if (value is long || value is int || value is short || value is sbyte || value is ulong || value is uint || value is ushort || value is byte)
			{
				return JTokenType.Integer;
			}
			if (value is Enum)
			{
				return JTokenType.Integer;
			}
			if (value is double || value is float || value is decimal)
			{
				return JTokenType.Float;
			}
			if (value is DateTime)
			{
				return JTokenType.Date;
			}
			if (value is DateTimeOffset)
			{
				return JTokenType.Date;
			}
			if (value is byte[])
			{
				return JTokenType.Bytes;
			}
			if (value is bool)
			{
				return JTokenType.Boolean;
			}
			if (value is Guid)
			{
				return JTokenType.Guid;
			}
			if (value is Uri)
			{
				return JTokenType.Uri;
			}
			if (value is TimeSpan)
			{
				return JTokenType.TimeSpan;
			}
			throw new ArgumentException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not determine JSON object type for type {0}.", CultureInfo.InvariantCulture, value.GetType()));
		}

		private static JTokenType GetStringValueType(JTokenType? current)
		{
			if (!current.HasValue)
			{
				return JTokenType.String;
			}
			switch (current.Value)
			{
			case JTokenType.Comment:
			case JTokenType.String:
			case JTokenType.Raw:
				return current.Value;
			default:
				return JTokenType.String;
			}
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			switch (_valueType)
			{
			case JTokenType.Comment:
				writer.WriteComment(_value.ToString());
				return;
			case JTokenType.Raw:
				writer.WriteRawValue((_value == null) ? null : _value.ToString());
				return;
			case JTokenType.Null:
				writer.WriteNull();
				return;
			case JTokenType.Undefined:
				writer.WriteUndefined();
				return;
			}
			JsonConverter matchingConverter;
			if (_value != null && (matchingConverter = JsonSerializer.GetMatchingConverter(converters, _value.GetType())) != null)
			{
				matchingConverter.WriteJson(writer, _value, new JsonSerializer());
				return;
			}
			switch (_valueType)
			{
			case JTokenType.Integer:
				writer.WriteValue(Convert.ToInt64(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.Float:
				writer.WriteValue(Convert.ToDouble(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.String:
				writer.WriteValue((_value == null) ? null : _value.ToString());
				break;
			case JTokenType.Boolean:
				writer.WriteValue(Convert.ToBoolean(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.Date:
				if (_value is DateTimeOffset)
				{
					writer.WriteValue((DateTimeOffset)_value);
				}
				else
				{
					writer.WriteValue(Convert.ToDateTime(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.Bytes:
				writer.WriteValue((byte[])_value);
				break;
			case JTokenType.Guid:
			case JTokenType.Uri:
			case JTokenType.TimeSpan:
				writer.WriteValue((_value == null) ? null : _value.ToString());
				break;
			default:
				throw PlayFab.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", _valueType, "Unexpected token type.");
			}
		}

		internal override int GetDeepHashCode()
		{
			int num = ((_value != null) ? _value.GetHashCode() : 0);
			return _valueType.GetHashCode() ^ num;
		}

		private static bool ValuesEquals(JValue v1, JValue v2)
		{
			return v1 == v2 || (v1._valueType == v2._valueType && Compare(v1._valueType, v1._value, v2._value) == 0);
		}

		public bool Equals(JValue other)
		{
			if (other == null)
			{
				return false;
			}
			return ValuesEquals(this, other);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is JValue other)
			{
				return Equals(other);
			}
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			if (_value == null)
			{
				return 0;
			}
			return _value.GetHashCode();
		}

		public override string ToString()
		{
			if (_value == null)
			{
				return string.Empty;
			}
			return _value.ToString();
		}

		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		public string ToString(IFormatProvider formatProvider)
		{
			return ToString(null, formatProvider);
		}

		public string ToString(string format, IFormatProvider formatProvider)
		{
			if (_value == null)
			{
				return string.Empty;
			}
			if (_value is IFormattable formattable)
			{
				return formattable.ToString(format, formatProvider);
			}
			return _value.ToString();
		}

		int IComparable.CompareTo(object obj)
		{
			if (obj == null)
			{
				return 1;
			}
			object objB = ((!(obj is JValue)) ? obj : ((JValue)obj).Value);
			return Compare(_valueType, _value, objB);
		}

		public int CompareTo(JValue obj)
		{
			if (obj == null)
			{
				return 1;
			}
			return Compare(_valueType, _value, obj._value);
		}
	}
	public static class LinqExtensions
	{
		public static IJEnumerable<JToken> Ancestors<T>(this IEnumerable<T> source) where T : JToken
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return System.Linq.Enumerable.SelectMany(source, (T j) => j.Ancestors()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Descendants<T>(this IEnumerable<T> source) where T : JContainer
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return System.Linq.Enumerable.SelectMany(source, (T j) => j.Descendants()).AsJEnumerable();
		}

		public static IJEnumerable<JProperty> Properties(this IEnumerable<JObject> source)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return System.Linq.Enumerable.SelectMany(source, (JObject d) => d.Properties()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source, object key)
		{
			return source.Values<JToken, JToken>(key).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source)
		{
			return source.Values(null);
		}

		public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source, object key)
		{
			return source.Values<JToken, U>(key);
		}

		public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source)
		{
			return source.Values<JToken, U>(null);
		}

		public static U Value<U>(this IEnumerable<JToken> value)
		{
			return value.Value<JToken, U>();
		}

		public static U Value<T, U>(this IEnumerable<T> value) where T : JToken
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "source");
			if (!(value is JToken token))
			{
				throw new ArgumentException("Source value must be a JToken.");
			}
			return token.Convert<JToken, U>();
		}

		internal static IEnumerable<U> Values<T, U>(this IEnumerable<T> source, object key) where T : JToken
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			foreach (T token in source)
			{
				if (key == null)
				{
					if (token is JValue)
					{
						yield return ((JValue)(object)token).Convert<JValue, U>();
						continue;
					}
					foreach (JToken t in token.Children())
					{
						yield return t.Convert<JToken, U>();
					}
				}
				else
				{
					JToken value = token[key];
					if (value != null)
					{
						yield return value.Convert<JToken, U>();
					}
				}
			}
		}

		public static IJEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
		{
			return source.Children<T, JToken>().AsJEnumerable();
		}

		public static IEnumerable<U> Children<T, U>(this IEnumerable<T> source) where T : JToken
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return System.Linq.Enumerable.SelectMany(source, (T c) => c.Children()).Convert<JToken, U>();
		}

		internal static IEnumerable<U> Convert<T, U>(this IEnumerable<T> source) where T : JToken
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			foreach (T token in source)
			{
				yield return token.Convert<JToken, U>();
			}
		}

		internal static U Convert<T, U>(this T token) where T : JToken
		{
			if (token == null)
			{
				return default(U);
			}
			if (token is U && typeof(U) != typeof(IComparable) && typeof(U) != typeof(IFormattable))
			{
				return (U)(object)token;
			}
			if (!(token is JValue jValue))
			{
				throw new InvalidCastException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot cast {0} to {1}.", CultureInfo.InvariantCulture, token.GetType(), typeof(T)));
			}
			if (jValue.Value is U)
			{
				return (U)jValue.Value;
			}
			Type type = typeof(U);
			if (PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(type))
			{
				if (jValue.Value == null)
				{
					return default(U);
				}
				type = Nullable.GetUnderlyingType(type);
			}
			return (U)System.Convert.ChangeType(jValue.Value, type, CultureInfo.InvariantCulture);
		}

		public static IJEnumerable<JToken> AsJEnumerable(this IEnumerable<JToken> source)
		{
			return source.AsJEnumerable<JToken>();
		}

		public static IJEnumerable<T> AsJEnumerable<T>(this IEnumerable<T> source) where T : JToken
		{
			if (source == null)
			{
				return null;
			}
			if (source is IJEnumerable<T>)
			{
				return (IJEnumerable<T>)source;
			}
			return new JEnumerable<T>(source);
		}
	}
}
namespace PlayFab.Json
{
	public enum MemberSerialization
	{
		OptOut,
		OptIn
	}
	public enum MissingMemberHandling
	{
		Ignore,
		Error
	}
	public enum NullValueHandling
	{
		Include,
		Ignore
	}
	public enum ObjectCreationHandling
	{
		Auto,
		Reuse,
		Replace
	}
}
namespace PlayFab.Json.ObservableSupport
{
	public class AddingNewEventArgs
	{
		public object NewObject { get; set; }

		public AddingNewEventArgs()
		{
		}

		public AddingNewEventArgs(object newObject)
		{
			NewObject = newObject;
		}
	}
	public delegate void AddingNewEventHandler(object sender, AddingNewEventArgs e);
	public interface INotifyCollectionChanged
	{
		event NotifyCollectionChangedEventHandler CollectionChanged;
	}
	public interface INotifyPropertyChanging
	{
		event PropertyChangingEventHandler PropertyChanging;
	}
	public enum NotifyCollectionChangedAction
	{
		Add,
		Remove,
		Replace,
		Move,
		Reset
	}
	public class NotifyCollectionChangedEventArgs
	{
		internal NotifyCollectionChangedAction Action { get; set; }

		internal IList NewItems { get; set; }

		internal int NewStartingIndex { get; set; }

		internal IList OldItems { get; set; }

		internal int OldStartingIndex { get; set; }

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action)
		{
			Action = action;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems)
			: this(action)
		{
			NewItems = changedItems;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem)
			: this(action)
		{
			NewItems = new List<object> { changedItem };
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems)
			: this(action, newItems)
		{
			OldItems = oldItems;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
			: this(action, changedItems)
		{
			NewStartingIndex = startingIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index)
			: this(action, changedItem)
		{
			NewStartingIndex = index;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem)
			: this(action, newItem)
		{
			OldItems = new List<object> { oldItem };
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex)
			: this(action, newItems, oldItems)
		{
			NewStartingIndex = startingIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex)
			: this(action, changedItems, index)
		{
			OldStartingIndex = oldIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
			: this(action, changedItem, index)
		{
			OldStartingIndex = oldIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
			: this(action, newItem, oldItem)
		{
			NewStartingIndex = index;
		}
	}
	public delegate void NotifyCollectionChangedEventHandler(object sender, NotifyCollectionChangedEventArgs e);
	public class PropertyChangingEventArgs : EventArgs
	{
		public virtual string PropertyName { get; set; }

		public PropertyChangingEventArgs(string propertyName)
		{
			PropertyName = propertyName;
		}
	}
	public delegate void PropertyChangingEventHandler(object sender, PropertyChangingEventArgs e);
}
namespace PlayFab.Json
{
	[Flags]
	public enum PreserveReferencesHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		All = 3
	}
	public enum ReferenceLoopHandling
	{
		Error,
		Ignore,
		Serialize
	}
	public enum Required
	{
		Default,
		AllowNull,
		Always
	}
}
namespace PlayFab.Json.Schema
{
	public class JsonSchema
	{
		private readonly string _internalId = Guid.NewGuid().ToString("N");

		public string Id { get; set; }

		public string Title { get; set; }

		public bool? Required { get; set; }

		public bool? ReadOnly { get; set; }

		public bool? Hidden { get; set; }

		public bool? Transient { get; set; }

		public string Description { get; set; }

		public JsonSchemaType? Type { get; set; }

		public string Pattern { get; set; }

		public int? MinimumLength { get; set; }

		public int? MaximumLength { get; set; }

		public double? DivisibleBy { get; set; }

		public double? Minimum { get; set; }

		public double? Maximum { get; set; }

		public bool? ExclusiveMinimum { get; set; }

		public bool? ExclusiveMaximum { get; set; }

		public int? MinimumItems { get; set; }

		public int? MaximumItems { get; set; }

		public IList<JsonSchema> Items { get; set; }

		public IDictionary<string, JsonSchema> Properties { get; set; }

		public JsonSchema AdditionalProperties { get; set; }

		public IDictionary<string, JsonSchema> PatternProperties { get; set; }

		public bool AllowAdditionalProperties { get; set; }

		public string Requires { get; set; }

		public IList<string> Identity { get; set; }

		public IList<PlayFab.Json.Linq.JToken> Enum { get; set; }

		public IDictionary<PlayFab.Json.Linq.JToken, string> Options { get; set; }

		public JsonSchemaType? Disallow { get; set; }

		public PlayFab.Json.Linq.JToken Default { get; set; }

		public JsonSchema Extends { get; set; }

		public string Format { get; set; }

		internal string InternalId => _internalId;

		public JsonSchema()
		{
			AllowAdditionalProperties = true;
		}

		public static JsonSchema Read(JsonReader reader)
		{
			return Read(reader, new JsonSchemaResolver());
		}

		public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(resolver, "resolver");
			JsonSchemaBuilder jsonSchemaBuilder = new JsonSchemaBuilder(resolver);
			return jsonSchemaBuilder.Parse(reader);
		}

		public static JsonSchema Parse(string json)
		{
			return Parse(json, new JsonSchemaResolver());
		}

		public static JsonSchema Parse(string json, JsonSchemaResolver resolver)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(json, "json");
			JsonReader reader = new JsonTextReader(new StringReader(json));
			return Read(reader, resolver);
		}

		public void WriteTo(JsonWriter writer)
		{
			WriteTo(writer, new JsonSchemaResolver());
		}

		public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(writer, "writer");
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(resolver, "resolver");
			JsonSchemaWriter jsonSchemaWriter = new JsonSchemaWriter(writer, resolver);
			jsonSchemaWriter.WriteSchema(this);
		}

		public override string ToString()
		{
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.Formatting = Formatting.Indented;
			WriteTo(jsonTextWriter);
			return stringWriter.ToString();
		}
	}
	internal class JsonSchemaBuilder
	{
		private JsonReader _reader;

		private readonly IList<JsonSchema> _stack;

		private readonly JsonSchemaResolver _resolver;

		private JsonSchema _currentSchema;

		private JsonSchema CurrentSchema => _currentSchema;

		public JsonSchemaBuilder(JsonSchemaResolver resolver)
		{
			_stack = new List<JsonSchema>();
			_resolver = resolver;
		}

		private void Push(JsonSchema value)
		{
			_currentSchema = value;
			_stack.Add(value);
			_resolver.LoadedSchemas.Add(value);
		}

		private JsonSchema Pop()
		{
			JsonSchema currentSchema = _currentSchema;
			_stack.RemoveAt(_stack.Count - 1);
			_currentSchema = System.Linq.Enumerable.LastOrDefault(_stack);
			return currentSchema;
		}

		internal JsonSchema Parse(JsonReader reader)
		{
			_reader = reader;
			if (reader.TokenType == JsonToken.None)
			{
				_reader.Read();
			}
			return BuildSchema();
		}

		private JsonSchema BuildSchema()
		{
			if (_reader.TokenType != JsonToken.StartObject)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expected StartObject while parsing schema object, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
			}
			_reader.Read();
			if (_reader.TokenType == JsonToken.EndObject)
			{
				Push(new JsonSchema());
				return Pop();
			}
			string text = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
			_reader.Read();
			if (text == "$ref")
			{
				string text2 = (string)_reader.Value;
				while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
				{
					if (_reader.TokenType == JsonToken.StartObject)
					{
						throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Found StartObject within the schema reference with the Id '{0}'", CultureInfo.InvariantCulture, text2));
					}
				}
				JsonSchema schema = _resolver.GetSchema(text2);
				if (schema == null)
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not resolve schema reference for Id '{0}'.", CultureInfo.InvariantCulture, text2));
				}
				return schema;
			}
			Push(new JsonSchema());
			ProcessSchemaProperty(text);
			while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
			{
				text = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
				_reader.Read();
				ProcessSchemaProperty(text);
			}
			return Pop();
		}

		private void ProcessSchemaProperty(string propertyName)
		{
			switch (propertyName)
			{
			case "type":
				CurrentSchema.Type = ProcessType();
				break;
			case "id":
				CurrentSchema.Id = (string)_reader.Value;
				break;
			case "title":
				CurrentSchema.Title = (string)_reader.Value;
				break;
			case "description":
				CurrentSchema.Description = (string)_reader.Value;
				break;
			case "properties":
				ProcessProperties();
				break;
			case "items":
				ProcessItems();
				break;
			case "additionalProperties":
				ProcessAdditionalProperties();
				break;
			case "patternProperties":
				ProcessPatternProperties();
				break;
			case "required":
				CurrentSchema.Required = (bool)_reader.Value;
				break;
			case "requires":
				CurrentSchema.Requires = (string)_reader.Value;
				break;
			case "identity":
				ProcessIdentity();
				break;
			case "minimum":
				CurrentSchema.Minimum = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
				break;
			case "maximum":
				CurrentSchema.Maximum = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
				break;
			case "exclusiveMinimum":
				CurrentSchema.ExclusiveMinimum = (bool)_reader.Value;
				break;
			case "exclusiveMaximum":
				CurrentSchema.ExclusiveMaximum = (bool)_reader.Value;
				break;
			case "maxLength":
				CurrentSchema.MaximumLength = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
				break;
			case "minLength":
				CurrentSchema.MinimumLength = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
				break;
			case "maxItems":
				CurrentSchema.MaximumItems = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
				break;
			case "minItems":
				CurrentSchema.MinimumItems = Convert.ToInt32(_reader.Value, CultureInfo.InvariantCulture);
				break;
			case "divisibleBy":
				CurrentSchema.DivisibleBy = Convert.ToDouble(_reader.Value, CultureInfo.InvariantCulture);
				break;
			case "disallow":
				CurrentSchema.Disallow = ProcessType();
				break;
			case "default":
				ProcessDefault();
				break;
			case "hidden":
				CurrentSchema.Hidden = (bool)_reader.Value;
				break;
			case "readonly":
				CurrentSchema.ReadOnly = (bool)_reader.Value;
				break;
			case "format":
				CurrentSchema.Format = (string)_reader.Value;
				break;
			case "pattern":
				CurrentSchema.Pattern = (string)_reader.Value;
				break;
			case "options":
				ProcessOptions();
				break;
			case "enum":
				ProcessEnum();
				break;
			case "extends":
				ProcessExtends();
				break;
			default:
				_reader.Skip();
				break;
			}
		}

		private void ProcessExtends()
		{
			CurrentSchema.Extends = BuildSchema();
		}

		private void ProcessEnum()
		{
			if (_reader.TokenType != JsonToken.StartArray)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expected StartArray token while parsing enum values, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
			}
			CurrentSchema.Enum = new List<PlayFab.Json.Linq.JToken>();
			while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
			{
				PlayFab.Json.Linq.JToken item = PlayFab.Json.Linq.JToken.ReadFrom(_reader);
				CurrentSchema.Enum.Add(item);
			}
		}

		private void ProcessOptions()
		{
			CurrentSchema.Options = new Dictionary<PlayFab.Json.Linq.JToken, string>(new PlayFab.Json.Linq.JTokenEqualityComparer());
			JsonToken tokenType = _reader.TokenType;
			if (tokenType == JsonToken.StartArray)
			{
				while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
				{
					if (_reader.TokenType != JsonToken.StartObject)
					{
						throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expect object token, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
					}
					string value = null;
					PlayFab.Json.Linq.JToken jToken = null;
					while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
					{
						string text = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
						_reader.Read();
						switch (text)
						{
						case "value":
							jToken = PlayFab.Json.Linq.JToken.ReadFrom(_reader);
							break;
						case "label":
							value = (string)_reader.Value;
							break;
						default:
							throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected property in JSON schema option: {0}.", CultureInfo.InvariantCulture, text));
						}
					}
					if (jToken == null)
					{
						throw new Exception("No value specified for JSON schema option.");
					}
					if (CurrentSchema.Options.ContainsKey(jToken))
					{
						throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Duplicate value in JSON schema option collection: {0}", CultureInfo.InvariantCulture, jToken));
					}
					CurrentSchema.Options.Add(jToken, value);
				}
				return;
			}
			throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expected array token, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
		}

		private void ProcessDefault()
		{
			CurrentSchema.Default = PlayFab.Json.Linq.JToken.ReadFrom(_reader);
		}

		private void ProcessIdentity()
		{
			CurrentSchema.Identity = new List<string>();
			switch (_reader.TokenType)
			{
			case JsonToken.String:
				CurrentSchema.Identity.Add(_reader.Value.ToString());
				break;
			case JsonToken.StartArray:
				while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
				{
					if (_reader.TokenType != JsonToken.String)
					{
						throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Exception JSON property name string token, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
					}
					CurrentSchema.Identity.Add(_reader.Value.ToString());
				}
				break;
			default:
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expected array or JSON property name string token, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
			}
		}

		private void ProcessAdditionalProperties()
		{
			if (_reader.TokenType == JsonToken.Boolean)
			{
				CurrentSchema.AllowAdditionalProperties = (bool)_reader.Value;
			}
			else
			{
				CurrentSchema.AdditionalProperties = BuildSchema();
			}
		}

		private void ProcessPatternProperties()
		{
			Dictionary<string, JsonSchema> dictionary = new Dictionary<string, JsonSchema>();
			if (_reader.TokenType != JsonToken.StartObject)
			{
				throw new Exception("Expected start object token.");
			}
			while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
			{
				string text = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
				_reader.Read();
				if (dictionary.ContainsKey(text))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Property {0} has already been defined in schema.", CultureInfo.InvariantCulture, text));
				}
				dictionary.Add(text, BuildSchema());
			}
			CurrentSchema.PatternProperties = dictionary;
		}

		private void ProcessItems()
		{
			CurrentSchema.Items = new List<JsonSchema>();
			switch (_reader.TokenType)
			{
			case JsonToken.StartObject:
				CurrentSchema.Items.Add(BuildSchema());
				break;
			case JsonToken.StartArray:
				while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
				{
					CurrentSchema.Items.Add(BuildSchema());
				}
				break;
			default:
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expected array or JSON schema object token, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
			}
		}

		private void ProcessProperties()
		{
			IDictionary<string, JsonSchema> dictionary = new Dictionary<string, JsonSchema>();
			if (_reader.TokenType != JsonToken.StartObject)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expected StartObject token while parsing schema properties, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
			}
			while (_reader.Read() && _reader.TokenType != JsonToken.EndObject)
			{
				string text = Convert.ToString(_reader.Value, CultureInfo.InvariantCulture);
				_reader.Read();
				if (dictionary.ContainsKey(text))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Property {0} has already been defined in schema.", CultureInfo.InvariantCulture, text));
				}
				dictionary.Add(text, BuildSchema());
			}
			CurrentSchema.Properties = dictionary;
		}

		private JsonSchemaType? ProcessType()
		{
			switch (_reader.TokenType)
			{
			case JsonToken.String:
				return MapType(_reader.Value.ToString());
			case JsonToken.StartArray:
			{
				JsonSchemaType? result = JsonSchemaType.None;
				while (_reader.Read() && _reader.TokenType != JsonToken.EndArray)
				{
					if (_reader.TokenType != JsonToken.String)
					{
						throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Exception JSON schema type string token, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
					}
					result = ((!result.HasValue) ? null : new JsonSchemaType?(result.GetValueOrDefault() | MapType(_reader.Value.ToString())));
				}
				return result;
			}
			default:
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Expected array or JSON schema type string token, got {0}.", CultureInfo.InvariantCulture, _reader.TokenType));
			}
		}

		internal static JsonSchemaType MapType(string type)
		{
			if (!JsonSchemaConstants.JsonSchemaTypeMapping.TryGetValue(type, out var value))
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Invalid JSON schema type: {0}", CultureInfo.InvariantCulture, type));
			}
			return value;
		}

		internal static string MapType(JsonSchemaType type)
		{
			return System.Linq.Enumerable.Single(JsonSchemaConstants.JsonSchemaTypeMapping, (KeyValuePair<string, JsonSchemaType> kv) => kv.Value == type).Key;
		}
	}
	internal static class JsonSchemaConstants
	{
		public const string TypePropertyName = "type";

		public const string PropertiesPropertyName = "properties";

		public const string ItemsPropertyName = "items";

		public const string RequiredPropertyName = "required";

		public const string PatternPropertiesPropertyName = "patternProperties";

		public const string AdditionalPropertiesPropertyName = "additionalProperties";

		public const string RequiresPropertyName = "requires";

		public const string IdentityPropertyName = "identity";

		public const string MinimumPropertyName = "minimum";

		public const string MaximumPropertyName = "maximum";

		public const string ExclusiveMinimumPropertyName = "exclusiveMinimum";

		public const string ExclusiveMaximumPropertyName = "exclusiveMaximum";

		public const string MinimumItemsPropertyName = "minItems";

		public const string MaximumItemsPropertyName = "maxItems";

		public const string PatternPropertyName = "pattern";

		public const string MaximumLengthPropertyName = "maxLength";

		public const string MinimumLengthPropertyName = "minLength";

		public const string EnumPropertyName = "enum";

		public const string OptionsPropertyName = "options";

		public const string ReadOnlyPropertyName = "readonly";

		public const string TitlePropertyName = "title";

		public const string DescriptionPropertyName = "description";

		public const string FormatPropertyName = "format";

		public const string DefaultPropertyName = "default";

		public const string TransientPropertyName = "transient";

		public const string DivisibleByPropertyName = "divisibleBy";

		public const string HiddenPropertyName = "hidden";

		public const string DisallowPropertyName = "disallow";

		public const string ExtendsPropertyName = "extends";

		public const string IdPropertyName = "id";

		public const string OptionValuePropertyName = "value";

		public const string OptionLabelPropertyName = "label";

		public const string ReferencePropertyName = "$ref";

		public static readonly IDictionary<string, JsonSchemaType> JsonSchemaTypeMapping = new Dictionary<string, JsonSchemaType>
		{
			{
				"string",
				JsonSchemaType.String
			},
			{
				"object",
				JsonSchemaType.Object
			},
			{
				"integer",
				JsonSchemaType.Integer
			},
			{
				"number",
				JsonSchemaType.Float
			},
			{
				"null",
				JsonSchemaType.Null
			},
			{
				"boolean",
				JsonSchemaType.Boolean
			},
			{
				"array",
				JsonSchemaType.Array
			},
			{
				"any",
				JsonSchemaType.Any
			}
		};
	}
	public class JsonSchemaException : Exception
	{
		public int LineNumber { get; private set; }

		public int LinePosition { get; private set; }

		public JsonSchemaException()
		{
		}

		public JsonSchemaException(string message)
			: base(message)
		{
		}

		public JsonSchemaException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		internal JsonSchemaException(string message, Exception innerException, int lineNumber, int linePosition)
			: base(message, innerException)
		{
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}
	}
	public class JsonSchemaGenerator
	{
		private class TypeSchema
		{
			public Type Type { get; private set; }

			public JsonSchema Schema { get; private set; }

			public TypeSchema(Type type, JsonSchema schema)
			{
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(type, "type");
				PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(schema, "schema");
				Type = type;
				Schema = schema;
			}
		}

		private PlayFab.Json.Serialization.IContractResolver _contractResolver;

		private JsonSchemaResolver _resolver;

		private IList<TypeSchema> _stack = new List<TypeSchema>();

		private JsonSchema _currentSchema;

		public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; set; }

		public PlayFab.Json.Serialization.IContractResolver ContractResolver
		{
			get
			{
				if (_contractResolver == null)
				{
					return PlayFab.Json.Serialization.DefaultContractResolver.Instance;
				}
				return _contractResolver;
			}
			set
			{
				_contractResolver = value;
			}
		}

		private JsonSchema CurrentSchema => _currentSchema;

		private void Push(TypeSchema typeSchema)
		{
			_currentSchema = typeSchema.Schema;
			_stack.Add(typeSchema);
			_resolver.LoadedSchemas.Add(typeSchema.Schema);
		}

		private TypeSchema Pop()
		{
			TypeSchema result = _stack[_stack.Count - 1];
			_stack.RemoveAt(_stack.Count - 1);
			TypeSchema typeSchema = System.Linq.Enumerable.LastOrDefault(_stack);
			if (typeSchema != null)
			{
				_currentSchema = typeSchema.Schema;
			}
			else
			{
				_currentSchema = null;
			}
			return result;
		}

		public JsonSchema Generate(Type type)
		{
			return Generate(type, new JsonSchemaResolver(), rootSchemaNullable: false);
		}

		public JsonSchema Generate(Type type, JsonSchemaResolver resolver)
		{
			return Generate(type, resolver, rootSchemaNullable: false);
		}

		public JsonSchema Generate(Type type, bool rootSchemaNullable)
		{
			return Generate(type, new JsonSchemaResolver(), rootSchemaNullable);
		}

		public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(type, "type");
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(resolver, "resolver");
			_resolver = resolver;
			return GenerateInternal(type, (!rootSchemaNullable) ? Required.Always : Required.Default, required: false);
		}

		private string GetTitle(Type type)
		{
			JsonContainerAttribute jsonContainerAttribute = PlayFab.Json.Serialization.JsonTypeReflector.GetJsonContainerAttribute(type);
			if (jsonContainerAttribute != null && !string.IsNullOrEmpty(jsonContainerAttribute.Title))
			{
				return jsonContainerAttribute.Title;
			}
			return null;
		}

		private string GetDescription(Type type)
		{
			JsonContainerAttribute jsonContainerAttribute = PlayFab.Json.Serialization.JsonTypeReflector.GetJsonContainerAttribute(type);
			if (jsonContainerAttribute != null && !string.IsNullOrEmpty(jsonContainerAttribute.Description))
			{
				return jsonContainerAttribute.Description;
			}
			return PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<DescriptionAttribute>(type)?.Description;
		}

		private string GetTypeId(Type type, bool explicitOnly)
		{
			JsonContainerAttribute jsonContainerAttribute = PlayFab.Json.Serialization.JsonTypeReflector.GetJsonContainerAttribute(type);
			if (jsonContainerAttribute != null && !string.IsNullOrEmpty(jsonContainerAttribute.Id))
			{
				return jsonContainerAttribute.Id;
			}
			if (explicitOnly)
			{
				return null;
			}
			return UndefinedSchemaIdHandling switch
			{
				UndefinedSchemaIdHandling.UseTypeName => type.FullName, 
				UndefinedSchemaIdHandling.UseAssemblyQualifiedName => type.AssemblyQualifiedName, 
				_ => null, 
			};
		}

		private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(type, "type");
			string typeId = GetTypeId(type, explicitOnly: false);
			string typeId2 = GetTypeId(type, explicitOnly: true);
			if (!string.IsNullOrEmpty(typeId))
			{
				JsonSchema schema = _resolver.GetSchema(typeId);
				if (schema != null)
				{
					if (valueRequired != Required.Always && !HasFlag(schema.Type, JsonSchemaType.Null))
					{
						schema.Type |= JsonSchemaType.Null;
					}
					if (required && schema.Required != true)
					{
						schema.Required = true;
					}
					return schema;
				}
			}
			if (System.Linq.Enumerable.Any(_stack, (TypeSchema tc) => tc.Type == type))
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unresolved circular reference for type '{0}'. Explicitly define an Id for the type using a JsonObject/JsonArray attribute or automatically generate a type Id using the UndefinedSchemaIdHandling property.", CultureInfo.InvariantCulture, type));
			}
			PlayFab.Json.Serialization.JsonContract jsonContract = ContractResolver.ResolveContract(type);
			JsonConverter jsonConverter;
			if ((jsonConverter = jsonContract.Converter) != null || (jsonConverter = jsonContract.InternalConverter) != null)
			{
				JsonSchema schema2 = jsonConverter.GetSchema();
				if (schema2 != null)
				{
					return schema2;
				}
			}
			Push(new TypeSchema(type, new JsonSchema()));
			if (typeId2 != null)
			{
				CurrentSchema.Id = typeId2;
			}
			if (required)
			{
				CurrentSchema.Required = true;
			}
			CurrentSchema.Title = GetTitle(type);
			CurrentSchema.Description = GetDescription(type);
			if (jsonConverter != null)
			{
				CurrentSchema.Type = JsonSchemaType.Any;
			}
			else if (jsonContract is PlayFab.Json.Serialization.JsonDictionaryContract)
			{
				CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
				PlayFab.Json.Utilities.ReflectionUtils.GetDictionaryKeyValueTypes(type, out var keyType, out var valueType);
				if (keyType != null && typeof(IConvertible).IsAssignableFrom(keyType))
				{
					CurrentSchema.AdditionalProperties = GenerateInternal(valueType, Required.Default, required: false);
				}
			}
			else if (jsonContract is PlayFab.Json.Serialization.JsonArrayContract)
			{
				CurrentSchema.Type = AddNullType(JsonSchemaType.Array, valueRequired);
				CurrentSchema.Id = GetTypeId(type, explicitOnly: false);
				bool flag = !(PlayFab.Json.Serialization.JsonTypeReflector.GetJsonContainerAttribute(type) is JsonArrayAttribute jsonArrayAttribute) || jsonArrayAttribute.AllowNullItems;
				Type collectionItemType = PlayFab.Json.Utilities.ReflectionUtils.GetCollectionItemType(type);
				if (collectionItemType != null)
				{
					CurrentSchema.Items = new List<JsonSchema>();
					CurrentSchema.Items.Add(GenerateInternal(collectionItemType, (!flag) ? Required.Always : Required.Default, required: false));
				}
			}
			else if (jsonContract is PlayFab.Json.Serialization.JsonPrimitiveContract)
			{
				CurrentSchema.Type = GetJsonSchemaType(type, valueRequired);
				JsonSchemaType? type2 = CurrentSchema.Type;
				if (type2.GetValueOrDefault() == JsonSchemaType.Integer && type2.HasValue && type.IsEnum && !type.IsDefined(typeof(FlagsAttribute), inherit: true))
				{
					CurrentSchema.Enum = new List<PlayFab.Json.Linq.JToken>();
					CurrentSchema.Options = new Dictionary<PlayFab.Json.Linq.JToken, string>();
					EnumValues<long> namesAndValues = PlayFab.Json.Utilities.EnumUtils.GetNamesAndValues<long>(type);
					foreach (PlayFab.Json.Utilities.EnumValue<long> item in namesAndValues)
					{
						PlayFab.Json.Linq.JToken jToken = PlayFab.Json.Linq.JToken.FromObject(item.Value);
						CurrentSchema.Enum.Add(jToken);
						CurrentSchema.Options.Add(jToken, item.Name);
					}
				}
			}
			else if (jsonContract is PlayFab.Json.Serialization.JsonObjectContract)
			{
				CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
				CurrentSchema.Id = GetTypeId(type, explicitOnly: false);
				GenerateObjectSchema(type, (PlayFab.Json.Serialization.JsonObjectContract)jsonContract);
			}
			else if (jsonContract is PlayFab.Json.Serialization.JsonISerializableContract)
			{
				CurrentSchema.Type = AddNullType(JsonSchemaType.Object, valueRequired);
				CurrentSchema.Id = GetTypeId(type, explicitOnly: false);
				GenerateISerializableContract(type, (PlayFab.Json.Serialization.JsonISerializableContract)jsonContract);
			}
			else if (jsonContract is PlayFab.Json.Serialization.JsonStringContract)
			{
				JsonSchemaType value = ((!PlayFab.Json.Utilities.ReflectionUtils.IsNullable(jsonContract.UnderlyingType)) ? JsonSchemaType.String : AddNullType(JsonSchemaType.String, valueRequired));
				CurrentSchema.Type = value;
			}
			else
			{
				if (!(jsonContract is PlayFab.Json.Serialization.JsonLinqContract))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected contract type: {0}", CultureInfo.InvariantCulture, jsonContract));
				}
				CurrentSchema.Type = JsonSchemaType.Any;
			}
			return Pop().Schema;
		}

		private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired)
		{
			if (valueRequired != Required.Always)
			{
				return type | JsonSchemaType.Null;
			}
			return type;
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private void GenerateObjectSchema(Type type, PlayFab.Json.Serialization.JsonObjectContract contract)
		{
			CurrentSchema.Properties = new Dictionary<string, JsonSchema>();
			foreach (PlayFab.Json.Serialization.JsonProperty property in contract.Properties)
			{
				if (!property.Ignored)
				{
					bool flag = property.NullValueHandling == NullValueHandling.Ignore || HasFlag(property.DefaultValueHandling.GetValueOrDefault(), DefaultValueHandling.Ignore) || property.ShouldSerialize != null || property.GetIsSpecified != null;
					JsonSchema jsonSchema = GenerateInternal(property.PropertyType, property.Required, !flag);
					if (property.DefaultValue != null)
					{
						jsonSchema.Default = PlayFab.Json.Linq.JToken.FromObject(property.DefaultValue);
					}
					CurrentSchema.Properties.Add(property.PropertyName, jsonSchema);
				}
			}
			if (type.IsSealed)
			{
				CurrentSchema.AllowAdditionalProperties = false;
			}
		}

		private void GenerateISerializableContract(Type type, PlayFab.Json.Serialization.JsonISerializableContract contract)
		{
			CurrentSchema.AllowAdditionalProperties = true;
		}

		internal static bool HasFlag(JsonSchemaType? value, JsonSchemaType flag)
		{
			if (!value.HasValue)
			{
				return true;
			}
			return (value & flag) == flag;
		}

		private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired)
		{
			JsonSchemaType jsonSchemaType = JsonSchemaType.None;
			if (valueRequired != Required.Always && PlayFab.Json.Utilities.ReflectionUtils.IsNullable(type))
			{
				jsonSchemaType = JsonSchemaType.Null;
				if (PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(type))
				{
					type = Nullable.GetUnderlyingType(type);
				}
			}
			TypeCode typeCode = Type.GetTypeCode(type);
			switch (typeCode)
			{
			case TypeCode.Empty:
			case TypeCode.Object:
				return jsonSchemaType | JsonSchemaType.String;
			case TypeCode.DBNull:
				return jsonSchemaType | JsonSchemaType.Null;
			case TypeCode.Boolean:
				return jsonSchemaType | JsonSchemaType.Boolean;
			case TypeCode.Char:
				return jsonSchemaType | JsonSchemaType.String;
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				return jsonSchemaType | JsonSchemaType.Integer;
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
				return jsonSchemaType | JsonSchemaType.Float;
			case TypeCode.DateTime:
				return jsonSchemaType | JsonSchemaType.String;
			case TypeCode.String:
				return jsonSchemaType | JsonSchemaType.String;
			default:
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected type code '{0}' for type '{1}'.", CultureInfo.InvariantCulture, typeCode, type));
			}
		}
	}
	internal class JsonSchemaModel
	{
		public bool Required { get; set; }

		public JsonSchemaType Type { get; set; }

		public int? MinimumLength { get; set; }

		public int? MaximumLength { get; set; }

		public double? DivisibleBy { get; set; }

		public double? Minimum { get; set; }

		public double? Maximum { get; set; }

		public bool ExclusiveMinimum { get; set; }

		public bool ExclusiveMaximum { get; set; }

		public int? MinimumItems { get; set; }

		public int? MaximumItems { get; set; }

		public IList<string> Patterns { get; set; }

		public IList<JsonSchemaModel> Items { get; set; }

		public IDictionary<string, JsonSchemaModel> Properties { get; set; }

		public IDictionary<string, JsonSchemaModel> PatternProperties { get; set; }

		public JsonSchemaModel AdditionalProperties { get; set; }

		public bool AllowAdditionalProperties { get; set; }

		public IList<PlayFab.Json.Linq.JToken> Enum { get; set; }

		public JsonSchemaType Disallow { get; set; }

		public JsonSchemaModel()
		{
			Type = JsonSchemaType.Any;
			AllowAdditionalProperties = true;
			Required = false;
		}

		public static JsonSchemaModel Create(IList<JsonSchema> schemata)
		{
			JsonSchemaModel jsonSchemaModel = new JsonSchemaModel();
			foreach (JsonSchema schematum in schemata)
			{
				Combine(jsonSchemaModel, schematum);
			}
			return jsonSchemaModel;
		}

		private static void Combine(JsonSchemaModel model, JsonSchema schema)
		{
			int required2;
			if (!model.Required)
			{
				bool? required = schema.Required;
				required2 = ((required.HasValue && required.Value) ? 1 : 0);
			}
			else
			{
				required2 = 1;
			}
			model.Required = (byte)required2 != 0;
			JsonSchemaType type = model.Type;
			JsonSchemaType? type2 = schema.Type;
			model.Type = type & ((!type2.HasValue) ? JsonSchemaType.Any : type2.Value);
			model.MinimumLength = PlayFab.Json.Utilities.MathUtils.Max(model.MinimumLength, schema.MinimumLength);
			model.MaximumLength = PlayFab.Json.Utilities.MathUtils.Min(model.MaximumLength, schema.MaximumLength);
			model.DivisibleBy = PlayFab.Json.Utilities.MathUtils.Max(model.DivisibleBy, schema.DivisibleBy);
			model.Minimum = PlayFab.Json.Utilities.MathUtils.Max(model.Minimum, schema.Minimum);
			model.Maximum = PlayFab.Json.Utilities.MathUtils.Max(model.Maximum, schema.Maximum);
			int exclusiveMinimum2;
			if (!model.ExclusiveMinimum)
			{
				bool? exclusiveMinimum = schema.ExclusiveMinimum;
				exclusiveMinimum2 = ((exclusiveMinimum.HasValue && exclusiveMinimum.Value) ? 1 : 0);
			}
			else
			{
				exclusiveMinimum2 = 1;
			}
			model.ExclusiveMinimum = (byte)exclusiveMinimum2 != 0;
			int exclusiveMaximum2;
			if (!model.ExclusiveMaximum)
			{
				bool? exclusiveMaximum = schema.ExclusiveMaximum;
				exclusiveMaximum2 = ((exclusiveMaximum.HasValue && exclusiveMaximum.Value) ? 1 : 0);
			}
			else
			{
				exclusiveMaximum2 = 1;
			}
			model.ExclusiveMaximum = (byte)exclusiveMaximum2 != 0;
			model.MinimumItems = PlayFab.Json.Utilities.MathUtils.Max(model.MinimumItems, schema.MinimumItems);
			model.MaximumItems = PlayFab.Json.Utilities.MathUtils.Min(model.MaximumItems, schema.MaximumItems);
			model.AllowAdditionalProperties = model.AllowAdditionalProperties && schema.AllowAdditionalProperties;
			if (schema.Enum != null)
			{
				if (model.Enum == null)
				{
					model.Enum = new List<PlayFab.Json.Linq.JToken>();
				}
				PlayFab.Json.Utilities.CollectionUtils.AddRangeDistinct(model.Enum, schema.Enum, new PlayFab.Json.Linq.JTokenEqualityComparer());
			}
			JsonSchemaType disallow = model.Disallow;
			JsonSchemaType? disallow2 = schema.Disallow;
			model.Disallow = disallow | (disallow2.HasValue ? disallow2.Value : JsonSchemaType.None);
			if (schema.Pattern != null)
			{
				if (model.Patterns == null)
				{
					model.Patterns = new List<string>();
				}
				PlayFab.Json.Utilities.CollectionUtils.AddDistinct(model.Patterns, schema.Pattern);
			}
		}
	}
	internal class JsonSchemaModelBuilder
	{
		private JsonSchemaNodeCollection _nodes = new JsonSchemaNodeCollection();

		private Dictionary<JsonSchemaNode, JsonSchemaModel> _nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();

		private JsonSchemaNode _node;

		public JsonSchemaModel Build(JsonSchema schema)
		{
			_nodes = new JsonSchemaNodeCollection();
			_node = AddSchema(null, schema);
			_nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();
			return BuildNodeModel(_node);
		}

		public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema)
		{
			string id;
			if (existingNode != null)
			{
				if (existingNode.Schemas.Contains(schema))
				{
					return existingNode;
				}
				id = JsonSchemaNode.GetId(System.Linq.Enumerable.Union(existingNode.Schemas, new JsonSchema[1] { schema }));
			}
			else
			{
				id = JsonSchemaNode.GetId(new JsonSchema[1] { schema });
			}
			if (_nodes.Contains(id))
			{
				return _nodes[id];
			}
			JsonSchemaNode jsonSchemaNode = ((existingNode == null) ? new JsonSchemaNode(schema) : existingNode.Combine(schema));
			_nodes.Add(jsonSchemaNode);
			AddProperties(schema.Properties, jsonSchemaNode.Properties);
			AddProperties(schema.PatternProperties, jsonSchemaNode.PatternProperties);
			if (schema.Items != null)
			{
				for (int i = 0; i < schema.Items.Count; i++)
				{
					AddItem(jsonSchemaNode, i, schema.Items[i]);
				}
			}
			if (schema.AdditionalProperties != null)
			{
				AddAdditionalProperties(jsonSchemaNode, schema.AdditionalProperties);
			}
			if (schema.Extends != null)
			{
				jsonSchemaNode = AddSchema(jsonSchemaNode, schema.Extends);
			}
			return jsonSchemaNode;
		}

		public void AddProperties(IDictionary<string, JsonSchema> source, IDictionary<string, JsonSchemaNode> target)
		{
			if (source == null)
			{
				return;
			}
			foreach (KeyValuePair<string, JsonSchema> item in source)
			{
				AddProperty(target, item.Key, item.Value);
			}
		}

		public void AddProperty(IDictionary<string, JsonSchemaNode> target, string propertyName, JsonSchema schema)
		{
			target.TryGetValue(propertyName, out var value);
			target[propertyName] = AddSchema(value, schema);
		}

		public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema)
		{
			JsonSchemaNode existingNode = ((parentNode.Items.Count <= index) ? null : parentNode.Items[index]);
			JsonSchemaNode jsonSchemaNode = AddSchema(existingNode, schema);
			if (parentNode.Items.Count <= index)
			{
				parentNode.Items.Add(jsonSchemaNode);
			}
			else
			{
				parentNode.Items[index] = jsonSchemaNode;
			}
		}

		public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema)
		{
			parentNode.AdditionalProperties = AddSchema(parentNode.AdditionalProperties, schema);
		}

		private JsonSchemaModel BuildNodeModel(JsonSchemaNode node)
		{
			if (_nodeModels.TryGetValue(node, out var value))
			{
				return value;
			}
			value = JsonSchemaModel.Create(node.Schemas);
			_nodeModels[node] = value;
			foreach (KeyValuePair<string, JsonSchemaNode> property in node.Properties)
			{
				if (value.Properties == null)
				{
					value.Properties = new Dictionary<string, JsonSchemaModel>();
				}
				value.Properties[property.Key] = BuildNodeModel(property.Value);
			}
			foreach (KeyValuePair<string, JsonSchemaNode> patternProperty in node.PatternProperties)
			{
				if (value.PatternProperties == null)
				{
					value.PatternProperties = new Dictionary<string, JsonSchemaModel>();
				}
				value.PatternProperties[patternProperty.Key] = BuildNodeModel(patternProperty.Value);
			}
			for (int i = 0; i < node.Items.Count; i++)
			{
				if (value.Items == null)
				{
					value.Items = new List<JsonSchemaModel>();
				}
				value.Items.Add(BuildNodeModel(node.Items[i]));
			}
			if (node.AdditionalProperties != null)
			{
				value.AdditionalProperties = BuildNodeModel(node.AdditionalProperties);
			}
			return value;
		}
	}
	internal class JsonSchemaNode
	{
		public string Id { get; private set; }

		public ReadOnlyCollection<JsonSchema> Schemas { get; private set; }

		public Dictionary<string, JsonSchemaNode> Properties { get; private set; }

		public Dictionary<string, JsonSchemaNode> PatternProperties { get; private set; }

		public List<JsonSchemaNode> Items { get; private set; }

		public JsonSchemaNode AdditionalProperties { get; set; }

		public JsonSchemaNode(JsonSchema schema)
		{
			Schemas = new ReadOnlyCollection<JsonSchema>(new JsonSchema[1] { schema });
			Properties = new Dictionary<string, JsonSchemaNode>();
			PatternProperties = new Dictionary<string, JsonSchemaNode>();
			Items = new List<JsonSchemaNode>();
			Id = GetId(Schemas);
		}

		private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema)
		{
			Schemas = new ReadOnlyCollection<JsonSchema>(System.Linq.Enumerable.ToList(System.Linq.Enumerable.Union(source.Schemas, new JsonSchema[1] { schema })));
			Properties = new Dictionary<string, JsonSchemaNode>(source.Properties);
			PatternProperties = new Dictionary<string, JsonSchemaNode>(source.PatternProperties);
			Items = new List<JsonSchemaNode>(source.Items);
			AdditionalProperties = source.AdditionalProperties;
			Id = GetId(Schemas);
		}

		public JsonSchemaNode Combine(JsonSchema schema)
		{
			return new JsonSchemaNode(this, schema);
		}

		public static string GetId(IEnumerable<JsonSchema> schemata)
		{
			return string.Join("-", System.Linq.Enumerable.ToArray(System.Linq.Enumerable.OrderBy(System.Linq.Enumerable.Select(schemata, (JsonSchema s) => s.InternalId), (string id) => id, StringComparer.Ordinal)));
		}
	}
	internal class JsonSchemaNodeCollection : KeyedCollection<string, JsonSchemaNode>
	{
		protected override string GetKeyForItem(JsonSchemaNode item)
		{
			return item.Id;
		}
	}
	public class JsonSchemaResolver
	{
		public IList<JsonSchema> LoadedSchemas { get; protected set; }

		public JsonSchemaResolver()
		{
			LoadedSchemas = new List<JsonSchema>();
		}

		public virtual JsonSchema GetSchema(string id)
		{
			return System.Linq.Enumerable.SingleOrDefault(LoadedSchemas, (JsonSchema s) => s.Id == id);
		}
	}
	[Flags]
	public enum JsonSchemaType
	{
		None = 0,
		String = 1,
		Float = 2,
		Integer = 4,
		Boolean = 8,
		Object = 0x10,
		Array = 0x20,
		Null = 0x40,
		Any = 0x7F
	}
	internal class JsonSchemaWriter
	{
		private readonly JsonWriter _writer;

		private readonly JsonSchemaResolver _resolver;

		public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = writer;
			_resolver = resolver;
		}

		private void ReferenceOrWriteSchema(JsonSchema schema)
		{
			if (schema.Id != null && _resolver.GetSchema(schema.Id) != null)
			{
				_writer.WriteStartObject();
				_writer.WritePropertyName("$ref");
				_writer.WriteValue(schema.Id);
				_writer.WriteEndObject();
			}
			else
			{
				WriteSchema(schema);
			}
		}

		public void WriteSchema(JsonSchema schema)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(schema, "schema");
			if (!_resolver.LoadedSchemas.Contains(schema))
			{
				_resolver.LoadedSchemas.Add(schema);
			}
			_writer.WriteStartObject();
			WritePropertyIfNotNull(_writer, "id", schema.Id);
			WritePropertyIfNotNull(_writer, "title", schema.Title);
			WritePropertyIfNotNull(_writer, "description", schema.Description);
			WritePropertyIfNotNull(_writer, "required", schema.Required);
			WritePropertyIfNotNull(_writer, "readonly", schema.ReadOnly);
			WritePropertyIfNotNull(_writer, "hidden", schema.Hidden);
			WritePropertyIfNotNull(_writer, "transient", schema.Transient);
			if (schema.Type.HasValue)
			{
				WriteType("type", _writer, schema.Type.Value);
			}
			if (!schema.AllowAdditionalProperties)
			{
				_writer.WritePropertyName("additionalProperties");
				_writer.WriteValue(schema.AllowAdditionalProperties);
			}
			else if (schema.AdditionalProperties != null)
			{
				_writer.WritePropertyName("additionalProperties");
				ReferenceOrWriteSchema(schema.AdditionalProperties);
			}
			WriteSchemaDictionaryIfNotNull(_writer, "properties", schema.Properties);
			WriteSchemaDictionaryIfNotNull(_writer, "patternProperties", schema.PatternProperties);
			WriteItems(schema);
			WritePropertyIfNotNull(_writer, "minimum", schema.Minimum);
			WritePropertyIfNotNull(_writer, "maximum", schema.Maximum);
			WritePropertyIfNotNull(_writer, "exclusiveMinimum", schema.ExclusiveMinimum);
			WritePropertyIfNotNull(_writer, "exclusiveMaximum", schema.ExclusiveMaximum);
			WritePropertyIfNotNull(_writer, "minLength", schema.MinimumLength);
			WritePropertyIfNotNull(_writer, "maxLength", schema.MaximumLength);
			WritePropertyIfNotNull(_writer, "minItems", schema.MinimumItems);
			WritePropertyIfNotNull(_writer, "maxItems", schema.MaximumItems);
			WritePropertyIfNotNull(_writer, "divisibleBy", schema.DivisibleBy);
			WritePropertyIfNotNull(_writer, "format", schema.Format);
			WritePropertyIfNotNull(_writer, "pattern", schema.Pattern);
			if (schema.Enum != null)
			{
				_writer.WritePropertyName("enum");
				_writer.WriteStartArray();
				foreach (PlayFab.Json.Linq.JToken item in schema.Enum)
				{
					item.WriteTo(_writer);
				}
				_writer.WriteEndArray();
			}
			if (schema.Default != null)
			{
				_writer.WritePropertyName("default");
				schema.Default.WriteTo(_writer);
			}
			if (schema.Options != null)
			{
				_writer.WritePropertyName("options");
				_writer.WriteStartArray();
				foreach (KeyValuePair<PlayFab.Json.Linq.JToken, string> option in schema.Options)
				{
					_writer.WriteStartObject();
					_writer.WritePropertyName("value");
					option.Key.WriteTo(_writer);
					if (option.Value != null)
					{
						_writer.WritePropertyName("label");
						_writer.WriteValue(option.Value);
					}
					_writer.WriteEndObject();
				}
				_writer.WriteEndArray();
			}
			if (schema.Disallow.HasValue)
			{
				WriteType("disallow", _writer, schema.Disallow.Value);
			}
			if (schema.Extends != null)
			{
				_writer.WritePropertyName("extends");
				ReferenceOrWriteSchema(schema.Extends);
			}
			_writer.WriteEndObject();
		}

		private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary<string, JsonSchema> properties)
		{
			if (properties == null)
			{
				return;
			}
			writer.WritePropertyName(propertyName);
			writer.WriteStartObject();
			foreach (KeyValuePair<string, JsonSchema> property in properties)
			{
				writer.WritePropertyName(property.Key);
				ReferenceOrWriteSchema(property.Value);
			}
			writer.WriteEndObject();
		}

		private void WriteItems(JsonSchema schema)
		{
			if (PlayFab.Json.Utilities.CollectionUtils.IsNullOrEmpty(schema.Items))
			{
				return;
			}
			_writer.WritePropertyName("items");
			if (schema.Items.Count == 1)
			{
				ReferenceOrWriteSchema(schema.Items[0]);
				return;
			}
			_writer.WriteStartArray();
			foreach (JsonSchema item in schema.Items)
			{
				ReferenceOrWriteSchema(item);
			}
			_writer.WriteEndArray();
		}

		private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type)
		{
			IList<JsonSchemaType> list2;
			if (Enum.IsDefined(typeof(JsonSchemaType), type))
			{
				List<JsonSchemaType> list = new List<JsonSchemaType>();
				list.Add(type);
				list2 = list;
			}
			else
			{
				list2 = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(PlayFab.Json.Utilities.EnumUtils.GetFlagsValues(type), (JsonSchemaType v) => v != JsonSchemaType.None));
			}
			if (list2.Count == 0)
			{
				return;
			}
			writer.WritePropertyName(propertyName);
			if (list2.Count == 1)
			{
				writer.WriteValue(JsonSchemaBuilder.MapType(list2[0]));
				return;
			}
			writer.WriteStartArray();
			foreach (JsonSchemaType item in list2)
			{
				writer.WriteValue(JsonSchemaBuilder.MapType(item));
			}
			writer.WriteEndArray();
		}

		private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value)
		{
			if (value != null)
			{
				writer.WritePropertyName(propertyName);
				writer.WriteValue(value);
			}
		}
	}
	public static class SchemaExtensions
	{
		public static bool IsValid(this PlayFab.Json.Linq.JToken source, JsonSchema schema)
		{
			bool valid = true;
			source.Validate(schema, delegate
			{
				valid = false;
			});
			return valid;
		}

		public static void Validate(this PlayFab.Json.Linq.JToken source, JsonSchema schema)
		{
			source.Validate(schema, null);
		}

		public static void Validate(this PlayFab.Json.Linq.JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(schema, "schema");
			using JsonValidatingReader jsonValidatingReader = new JsonValidatingReader(source.CreateReader());
			jsonValidatingReader.Schema = schema;
			if (validationEventHandler != null)
			{
				jsonValidatingReader.ValidationEventHandler += validationEventHandler;
			}
			while (jsonValidatingReader.Read())
			{
			}
		}
	}
	public enum UndefinedSchemaIdHandling
	{
		None,
		UseTypeName,
		UseAssemblyQualifiedName
	}
	public class ValidationEventArgs : EventArgs
	{
		private readonly JsonSchemaException _ex;

		public JsonSchemaException Exception => _ex;

		public string Message => _ex.Message;

		internal ValidationEventArgs(JsonSchemaException ex)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(ex, "ex");
			_ex = ex;
		}
	}
	public delegate void ValidationEventHandler(object sender, ValidationEventArgs e);
}
namespace PlayFab.Json.Serialization
{
	internal static class CachedAttributeGetter<T> where T : Attribute
	{
		private static readonly PlayFab.Json.Utilities.ThreadSafeStore<ICustomAttributeProvider, T> TypeAttributeCache = new PlayFab.Json.Utilities.ThreadSafeStore<ICustomAttributeProvider, T>(JsonTypeReflector.GetAttribute<T>);

		public static T GetAttribute(ICustomAttributeProvider type)
		{
			return TypeAttributeCache.Get(type);
		}
	}
	public class CamelCasePropertyNamesContractResolver : DefaultContractResolver
	{
		public CamelCasePropertyNamesContractResolver()
			: base(shareCache: true)
		{
		}

		protected internal override string ResolvePropertyName(string propertyName)
		{
			return PlayFab.Json.Utilities.StringUtils.ToCamelCase(propertyName);
		}
	}
	internal struct ResolverContractKey : IEquatable<ResolverContractKey>
	{
		private readonly Type _resolverType;

		private readonly Type _contractType;

		public ResolverContractKey(Type resolverType, Type contractType)
		{
			_resolverType = resolverType;
			_contractType = contractType;
		}

		public override int GetHashCode()
		{
			return _resolverType.GetHashCode() ^ _contractType.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (!(obj is ResolverContractKey))
			{
				return false;
			}
			return Equals((ResolverContractKey)obj);
		}

		public bool Equals(ResolverContractKey other)
		{
			return _resolverType == other._resolverType && _contractType == other._contractType;
		}
	}
	public class DefaultContractResolver : IContractResolver
	{
		private static readonly IContractResolver _instance = new DefaultContractResolver(shareCache: true);

		internal static readonly IList<JsonConverter> BuiltInConverters = new List<JsonConverter>
		{
			new PlayFab.Json.Converters.KeyValuePairConverter()
		};

		private static Dictionary<ResolverContractKey, JsonContract> _sharedContractCache;

		private static readonly object _typeContractCacheLock = new object();

		private Dictionary<ResolverContractKey, JsonContract> _instanceContractCache;

		private readonly bool _sharedCache;

		internal static IContractResolver Instance => _instance;

		public bool DynamicCodeGeneration => JsonTypeReflector.DynamicCodeGeneration;

		public BindingFlags DefaultMembersSearchFlags { get; set; }

		public bool SerializeCompilerGeneratedMembers { get; set; }

		public DefaultContractResolver()
			: this(shareCache: false)
		{
		}

		public DefaultContractResolver(bool shareCache)
		{
			DefaultMembersSearchFlags = BindingFlags.Instance | BindingFlags.Public;
			_sharedCache = shareCache;
		}

		private Dictionary<ResolverContractKey, JsonContract> GetCache()
		{
			if (_sharedCache)
			{
				return _sharedContractCache;
			}
			return _instanceContractCache;
		}

		private void UpdateCache(Dictionary<ResolverContractKey, JsonContract> cache)
		{
			if (_sharedCache)
			{
				_sharedContractCache = cache;
			}
			else
			{
				_instanceContractCache = cache;
			}
		}

		public virtual JsonContract ResolveContract(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			ResolverContractKey key = new ResolverContractKey(GetType(), type);
			Dictionary<ResolverContractKey, JsonContract> cache = GetCache();
			if (cache == null || !cache.TryGetValue(key, out var value))
			{
				value = CreateContract(type);
				lock (_typeContractCacheLock)
				{
					cache = GetCache();
					Dictionary<ResolverContractKey, JsonContract> dictionary = ((cache == null) ? new Dictionary<ResolverContractKey, JsonContract>() : new Dictionary<ResolverContractKey, JsonContract>(cache));
					dictionary[key] = value;
					UpdateCache(dictionary);
				}
			}
			return value;
		}

		protected virtual List<MemberInfo> GetSerializableMembers(Type objectType)
		{
			List<MemberInfo> list = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(PlayFab.Json.Utilities.ReflectionUtils.GetFieldsAndProperties(objectType, DefaultMembersSearchFlags), (MemberInfo m) => !PlayFab.Json.Utilities.ReflectionUtils.IsIndexedProperty(m)));
			List<MemberInfo> list2 = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(PlayFab.Json.Utilities.ReflectionUtils.GetFieldsAndProperties(objectType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic), (MemberInfo m) => !PlayFab.Json.Utilities.ReflectionUtils.IsIndexedProperty(m)));
			List<MemberInfo> list3 = new List<MemberInfo>();
			foreach (MemberInfo item in list2)
			{
				if (SerializeCompilerGeneratedMembers || !item.IsDefined(typeof(CompilerGeneratedAttribute), inherit: true))
				{
					if (list.Contains(item))
					{
						list3.Add(item);
					}
					else if (JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(item) != null)
					{
						list3.Add(item);
					}
				}
			}
			if (PlayFab.Json.Utilities.ReflectionUtils.AssignableToTypeName(objectType, "System.Data.Objects.DataClasses.EntityObject", out var _))
			{
				list3 = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(list3, ShouldSerializeEntityMember));
			}
			return list3;
		}

		private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsGenericType && propertyInfo.PropertyType.GetGenericTypeDefinition().FullName == "System.Data.Objects.DataClasses.EntityReference`1")
			{
				return false;
			}
			return true;
		}

		protected virtual JsonObjectContract CreateObjectContract(Type objectType)
		{
			JsonObjectContract jsonObjectContract = new JsonObjectContract(objectType);
			InitializeContract(jsonObjectContract);
			jsonObjectContract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType);
			PlayFab.Json.Utilities.CollectionUtils.AddRange(jsonObjectContract.Properties, CreateProperties(jsonObjectContract.UnderlyingType, jsonObjectContract.MemberSerialization));
			if (System.Linq.Enumerable.Any(objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic), (ConstructorInfo c) => c.IsDefined(typeof(JsonConstructorAttribute), inherit: true)))
			{
				ConstructorInfo attributeConstructor = GetAttributeConstructor(objectType);
				if (attributeConstructor != null)
				{
					jsonObjectContract.OverrideConstructor = attributeConstructor;
					PlayFab.Json.Utilities.CollectionUtils.AddRange(jsonObjectContract.ConstructorParameters, CreateConstructorParameters(attributeConstructor, jsonObjectContract.Properties));
				}
			}
			else if (jsonObjectContract.DefaultCreator == null || jsonObjectContract.DefaultCreatorNonPublic)
			{
				ConstructorInfo parametrizedConstructor = GetParametrizedConstructor(objectType);
				if (parametrizedConstructor != null)
				{
					jsonObjectContract.ParametrizedConstructor = parametrizedConstructor;
					PlayFab.Json.Utilities.CollectionUtils.AddRange(jsonObjectContract.ConstructorParameters, CreateConstructorParameters(parametrizedConstructor, jsonObjectContract.Properties));
				}
			}
			return jsonObjectContract;
		}

		private ConstructorInfo GetAttributeConstructor(Type objectType)
		{
			IList<ConstructorInfo> list = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Where(objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic), (ConstructorInfo c) => c.IsDefined(typeof(JsonConstructorAttribute), inherit: true)));
			if (list.Count > 1)
			{
				throw new Exception("Multiple constructors with the JsonConstructorAttribute.");
			}
			if (list.Count == 1)
			{
				return list[0];
			}
			return null;
		}

		private ConstructorInfo GetParametrizedConstructor(Type objectType)
		{
			IList<ConstructorInfo> constructors = objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
			if (constructors.Count == 1)
			{
				return constructors[0];
			}
			return null;
		}

		protected virtual IList<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
		{
			ParameterInfo[] parameters = constructor.GetParameters();
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(constructor.DeclaringType);
			ParameterInfo[] array = parameters;
			foreach (ParameterInfo parameterInfo in array)
			{
				JsonProperty jsonProperty = memberProperties.GetClosestMatchProperty(parameterInfo.Name);
				if (jsonProperty != null && jsonProperty.PropertyType != parameterInfo.ParameterType)
				{
					jsonProperty = null;
				}
				JsonProperty jsonProperty2 = CreatePropertyFromConstructorParameter(jsonProperty, parameterInfo);
				if (jsonProperty2 != null)
				{
					jsonPropertyCollection.AddProperty(jsonProperty2);
				}
			}
			return jsonPropertyCollection;
		}

		protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = parameterInfo.ParameterType;
			SetPropertySettingsFromAttributes(jsonProperty, parameterInfo, parameterInfo.Name, parameterInfo.Member.DeclaringType, MemberSerialization.OptOut, out var _, out var _);
			jsonProperty.Readable = false;
			jsonProperty.Writable = true;
			if (matchingMemberProperty != null)
			{
				jsonProperty.PropertyName = ((!(jsonProperty.PropertyName != parameterInfo.Name)) ? matchingMemberProperty.PropertyName : jsonProperty.PropertyName);
				jsonProperty.Converter = jsonProperty.Converter ?? matchingMemberProperty.Converter;
				jsonProperty.MemberConverter = jsonProperty.MemberConverter ?? matchingMemberProperty.MemberConverter;
				jsonProperty.DefaultValue = jsonProperty.DefaultValue ?? matchingMemberProperty.DefaultValue;
				jsonProperty.Required = ((jsonProperty.Required == Required.Default) ? matchingMemberProperty.Required : jsonProperty.Required);
				jsonProperty.IsReference = jsonProperty.IsReference ?? matchingMemberProperty.IsReference;
				jsonProperty.NullValueHandling = jsonProperty.NullValueHandling ?? matchingMemberProperty.NullValueHandling;
				jsonProperty.DefaultValueHandling = jsonProperty.DefaultValueHandling ?? matchingMemberProperty.DefaultValueHandling;
				jsonProperty.ReferenceLoopHandling = jsonProperty.ReferenceLoopHandling ?? matchingMemberProperty.ReferenceLoopHandling;
				jsonProperty.ObjectCreationHandling = jsonProperty.ObjectCreationHandling ?? matchingMemberProperty.ObjectCreationHandling;
				jsonProperty.TypeNameHandling = jsonProperty.TypeNameHandling ?? matchingMemberProperty.TypeNameHandling;
			}
			return jsonProperty;
		}

		protected virtual JsonConverter ResolveContractConverter(Type objectType)
		{
			return JsonTypeReflector.GetJsonConverter(objectType, objectType);
		}

		private Func<object> GetDefaultCreator(Type createdType)
		{
			return JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(createdType);
		}

		private void InitializeContract(JsonContract contract)
		{
			JsonContainerAttribute jsonContainerAttribute = JsonTypeReflector.GetJsonContainerAttribute(contract.UnderlyingType);
			if (jsonContainerAttribute != null)
			{
				contract.IsReference = jsonContainerAttribute._isReference;
			}
			contract.Converter = ResolveContractConverter(contract.UnderlyingType);
			contract.InternalConverter = JsonSerializer.GetMatchingConverter(BuiltInConverters, contract.UnderlyingType);
			if (PlayFab.Json.Utilities.ReflectionUtils.HasDefaultConstructor(contract.CreatedType, nonPublic: true) || contract.CreatedType.IsValueType)
			{
				contract.DefaultCreator = GetDefaultCreator(contract.CreatedType);
				contract.DefaultCreatorNonPublic = !contract.CreatedType.IsValueType && PlayFab.Json.Utilities.ReflectionUtils.GetDefaultConstructor(contract.CreatedType) == null;
			}
			ResolveCallbackMethods(contract, contract.UnderlyingType);
		}

		private void ResolveCallbackMethods(JsonContract contract, Type t)
		{
			if (t.BaseType != null)
			{
				ResolveCallbackMethods(contract, t.BaseType);
			}
			GetCallbackMethodsForType(t, out var onSerializing, out var onSerialized, out var onDeserializing, out var onDeserialized, out var onError);
			if (onSerializing != null)
			{
				contract.OnSerializing = onSerializing;
			}
			if (onSerialized != null)
			{
				contract.OnSerialized = onSerialized;
			}
			if (onDeserializing != null)
			{
				contract.OnDeserializing = onDeserializing;
			}
			if (onDeserialized != null)
			{
				contract.OnDeserialized = onDeserialized;
			}
			if (onError != null)
			{
				contract.OnError = onError;
			}
		}

		private void GetCallbackMethodsForType(Type type, out MethodInfo onSerializing, out MethodInfo onSerialized, out MethodInfo onDeserializing, out MethodInfo onDeserialized, out MethodInfo onError)
		{
			onSerializing = null;
			onSerialized = null;
			onDeserializing = null;
			onDeserialized = null;
			onError = null;
			MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (MethodInfo methodInfo in methods)
			{
				if (!methodInfo.ContainsGenericParameters)
				{
					Type prevAttributeType = null;
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (IsValidCallback(methodInfo, parameters, typeof(OnSerializingAttribute), onSerializing, ref prevAttributeType))
					{
						onSerializing = methodInfo;
					}
					if (IsValidCallback(methodInfo, parameters, typeof(OnSerializedAttribute), onSerialized, ref prevAttributeType))
					{
						onSerialized = methodInfo;
					}
					if (IsValidCallback(methodInfo, parameters, typeof(OnDeserializingAttribute), onDeserializing, ref prevAttributeType))
					{
						onDeserializing = methodInfo;
					}
					if (IsValidCallback(methodInfo, parameters, typeof(OnDeserializedAttribute), onDeserialized, ref prevAttributeType))
					{
						onDeserialized = methodInfo;
					}
					if (IsValidCallback(methodInfo, parameters, typeof(OnErrorAttribute), onError, ref prevAttributeType))
					{
						onError = methodInfo;
					}
				}
			}
		}

		protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType)
		{
			JsonDictionaryContract jsonDictionaryContract = new JsonDictionaryContract(objectType);
			InitializeContract(jsonDictionaryContract);
			jsonDictionaryContract.PropertyNameResolver = ResolvePropertyName;
			return jsonDictionaryContract;
		}

		protected virtual JsonArrayContract CreateArrayContract(Type objectType)
		{
			JsonArrayContract jsonArrayContract = new JsonArrayContract(objectType);
			InitializeContract(jsonArrayContract);
			return jsonArrayContract;
		}

		protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
		{
			JsonPrimitiveContract jsonPrimitiveContract = new JsonPrimitiveContract(objectType);
			InitializeContract(jsonPrimitiveContract);
			return jsonPrimitiveContract;
		}

		protected virtual JsonLinqContract CreateLinqContract(Type objectType)
		{
			JsonLinqContract jsonLinqContract = new JsonLinqContract(objectType);
			InitializeContract(jsonLinqContract);
			return jsonLinqContract;
		}

		protected virtual JsonISerializableContract CreateISerializableContract(Type objectType)
		{
			JsonISerializableContract jsonISerializableContract = new JsonISerializableContract(objectType);
			InitializeContract(jsonISerializableContract);
			ConstructorInfo constructor = objectType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
			{
				typeof(SerializationInfo),
				typeof(StreamingContext)
			}, null);
			if (constructor != null)
			{
				PlayFab.Json.Utilities.MethodCall<object, object> methodCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(constructor);
				jsonISerializableContract.ISerializableCreator = (object[] args) => methodCall(null, args);
			}
			return jsonISerializableContract;
		}

		protected virtual JsonStringContract CreateStringContract(Type objectType)
		{
			JsonStringContract jsonStringContract = new JsonStringContract(objectType);
			InitializeContract(jsonStringContract);
			return jsonStringContract;
		}

		protected virtual JsonContract CreateContract(Type objectType)
		{
			Type type = PlayFab.Json.Utilities.ReflectionUtils.EnsureNotNullableType(objectType);
			if (JsonConvert.IsJsonPrimitiveType(type))
			{
				return CreatePrimitiveContract(type);
			}
			if (JsonTypeReflector.GetJsonObjectAttribute(type) != null)
			{
				return CreateObjectContract(type);
			}
			if (JsonTypeReflector.GetJsonArrayAttribute(type) != null)
			{
				return CreateArrayContract(type);
			}
			if (type == typeof(PlayFab.Json.Linq.JToken) || type.IsSubclassOf(typeof(PlayFab.Json.Linq.JToken)))
			{
				return CreateLinqContract(type);
			}
			if (PlayFab.Json.Utilities.CollectionUtils.IsDictionaryType(type))
			{
				return CreateDictionaryContract(type);
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				return CreateArrayContract(type);
			}
			if (CanConvertToString(type))
			{
				return CreateStringContract(type);
			}
			if (typeof(ISerializable).IsAssignableFrom(type))
			{
				return CreateISerializableContract(type);
			}
			return CreateObjectContract(type);
		}

		internal static bool CanConvertToString(Type type)
		{
			TypeConverter converter = PlayFab.Json.Utilities.ConvertUtils.GetConverter(type);
			if (converter != null && !(converter is ComponentConverter) && !(converter is ReferenceConverter) && converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
			{
				return true;
			}
			if (type == typeof(Type) || type.IsSubclassOf(typeof(Type)))
			{
				return true;
			}
			return false;
		}

		private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, ref Type prevAttributeType)
		{
			if (!method.IsDefined(attributeType, inherit: false))
			{
				return false;
			}
			if (currentCallback != null)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.", CultureInfo.InvariantCulture, method, currentCallback, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if (prevAttributeType != null)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.", CultureInfo.InvariantCulture, prevAttributeType, attributeType, GetClrTypeFullName(method.DeclaringType), method));
			}
			if (method.IsVirtual)
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.", CultureInfo.InvariantCulture, method, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if (method.ReturnType != typeof(void))
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Serialization Callback '{1}' in type '{0}' must return void.", CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method));
			}
			if (attributeType == typeof(OnErrorAttribute))
			{
				if (parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof(StreamingContext) || parameters[1].ParameterType != typeof(ErrorContext))
				{
					throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.", CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext), typeof(ErrorContext)));
				}
			}
			else if (parameters == null || parameters.Length != 1 || parameters[0].ParameterType != typeof(StreamingContext))
			{
				throw new Exception(PlayFab.Json.Utilities.StringUtils.FormatWith("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.", CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext)));
			}
			prevAttributeType = attributeType;
			return true;
		}

		internal static string GetClrTypeFullName(Type type)
		{
			if (type.IsGenericTypeDefinition || !type.ContainsGenericParameters)
			{
				return type.FullName;
			}
			return string.Format(CultureInfo.InvariantCulture, "{0}.{1}", type.Namespace, type.Name);
		}

		protected virtual IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
		{
			List<MemberInfo> serializableMembers = GetSerializableMembers(type);
			if (serializableMembers == null)
			{
				throw new JsonSerializationException("Null collection of seralizable members returned.");
			}
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(type);
			foreach (MemberInfo item in serializableMembers)
			{
				JsonProperty jsonProperty = CreateProperty(item, memberSerialization);
				if (jsonProperty != null)
				{
					jsonPropertyCollection.AddProperty(jsonProperty);
				}
			}
			return System.Linq.Enumerable.ToList(System.Linq.Enumerable.OrderBy(jsonPropertyCollection, delegate(JsonProperty p)
			{
				int? order = p.Order;
				return (!order.HasValue) ? (-1) : order.Value;
			}));
		}

		protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member)
		{
			return new ReflectionValueProvider(member);
		}

		protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = PlayFab.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(member);
			jsonProperty.ValueProvider = CreateMemberValueProvider(member);
			SetPropertySettingsFromAttributes(jsonProperty, member, member.Name, member.DeclaringType, memberSerialization, out var allowNonPublicAccess, out var hasExplicitAttribute);
			jsonProperty.Readable = PlayFab.Json.Utilities.ReflectionUtils.CanReadMemberValue(member, allowNonPublicAccess);
			jsonProperty.Writable = PlayFab.Json.Utilities.ReflectionUtils.CanSetMemberValue(member, allowNonPublicAccess, hasExplicitAttribute);
			jsonProperty.ShouldSerialize = CreateShouldSerializeTest(member);
			SetIsSpecifiedActions(jsonProperty, member, allowNonPublicAccess);
			return jsonProperty;
		}

		private void SetPropertySettingsFromAttributes(JsonProperty property, ICustomAttributeProvider attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, out bool allowNonPublicAccess, out bool hasExplicitAttribute)
		{
			hasExplicitAttribute = false;
			JsonPropertyAttribute attribute = JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(attributeProvider);
			if (attribute != null)
			{
				hasExplicitAttribute = true;
			}
			bool flag = JsonTypeReflector.GetAttribute<JsonIgnoreAttribute>(attributeProvider) != null;
			string propertyName = ((attribute == null || attribute.PropertyName == null) ? name : attribute.PropertyName);
			property.PropertyName = ResolvePropertyName(propertyName);
			property.UnderlyingName = name;
			if (attribute != null)
			{
				property.Required = attribute.Required;
				property.Order = attribute._order;
			}
			else
			{
				property.Required = Required.Default;
			}
			property.Ignored = flag || (memberSerialization == MemberSerialization.OptIn && attribute == null);
			property.Converter = JsonTypeReflector.GetJsonConverter(attributeProvider, property.PropertyType);
			property.MemberConverter = JsonTypeReflector.GetJsonConverter(attributeProvider, property.PropertyType);
			property.DefaultValue = JsonTypeReflector.GetAttribute<DefaultValueAttribute>(attributeProvider)?.Value;
			property.NullValueHandling = attribute?._nullValueHandling;
			property.DefaultValueHandling = attribute?._defaultValueHandling;
			property.ReferenceLoopHandling = attribute?._referenceLoopHandling;
			property.ObjectCreationHandling = attribute?._objectCreationHandling;
			property.TypeNameHandling = attribute?._typeNameHandling;
			property.IsReference = attribute?._isReference;
			allowNonPublicAccess = false;
			if ((DefaultMembersSearchFlags & BindingFlags.NonPublic) == BindingFlags.NonPublic)
			{
				allowNonPublicAccess = true;
			}
			if (attribute != null)
			{
				allowNonPublicAccess = true;
			}
		}

		private Predicate<object> CreateShouldSerializeTest(MemberInfo member)
		{
			MethodInfo method = member.DeclaringType.GetMethod("ShouldSerialize" + member.Name, new Type[0]);
			if (method == null || method.ReturnType != typeof(bool))
			{
				return null;
			}
			PlayFab.Json.Utilities.MethodCall<object, object> shouldSerializeCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object o) => (bool)shouldSerializeCall(o);
		}

		private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
		{
			MemberInfo memberInfo = member.DeclaringType.GetProperty(member.Name + "Specified");
			if (memberInfo == null)
			{
				memberInfo = member.DeclaringType.GetField(member.Name + "Specified");
			}
			if (memberInfo != null && PlayFab.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(memberInfo) == typeof(bool))
			{
				Func<object, object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(memberInfo);
				property.GetIsSpecified = (object o) => (bool)specifiedPropertyGet(o);
				if (PlayFab.Json.Utilities.ReflectionUtils.CanSetMemberValue(memberInfo, allowNonPublicAccess, canSetReadOnly: false))
				{
					property.SetIsSpecified = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(memberInfo);
				}
			}
		}

		protected internal virtual string ResolvePropertyName(string propertyName)
		{
			return propertyName;
		}
	}
	internal class DefaultReferenceResolver : IReferenceResolver
	{
		private int _referenceCount;

		private PlayFab.Json.Utilities.BidirectionalDictionary<string, object> GetMappings(object context)
		{
			JsonSerializerInternalBase jsonSerializerInternalBase;
			if (context is JsonSerializerInternalBase)
			{
				jsonSerializerInternalBase = (JsonSerializerInternalBase)context;
			}
			else
			{
				if (!(context is JsonSerializerProxy))
				{
					throw new Exception("The DefaultReferenceResolver can only be used internally.");
				}
				jsonSerializerInternalBase = ((JsonSerializerProxy)context).GetInternalSerializer();
			}
			return jsonSerializerInternalBase.DefaultReferenceMappings;
		}

		public object ResolveReference(object context, string reference)
		{
			GetMappings(context).TryGetByFirst(reference, out var second);
			return second;
		}

		public string GetReference(object context, object value)
		{
			PlayFab.Json.Utilities.BidirectionalDictionary<string, object> mappings = GetMappings(context);
			if (!mappings.TryGetBySecond(value, out var first))
			{
				_referenceCount++;
				first = _referenceCount.ToString(CultureInfo.InvariantCulture);
				mappings.Add(first, value);
			}
			return first;
		}

		public void AddReference(object context, string reference, object value)
		{
			GetMappings(context).Add(reference, value);
		}

		public bool IsReferenced(object context, object value)
		{
			string first;
			return GetMappings(context).TryGetBySecond(value, out first);
		}
	}
	public class DefaultSerializationBinder : SerializationBinder
	{
		internal struct TypeNameKey
		{
			internal readonly string AssemblyName;

			internal readonly string TypeName;

			public TypeNameKey(string assemblyName, string typeName)
			{
				AssemblyName = assemblyName;
				TypeName = typeName;
			}

			public override int GetHashCode()
			{
				return ((AssemblyName != null) ? AssemblyName.GetHashCode() : 0) ^ ((TypeName != null) ? TypeName.GetHashCode() : 0);
			}

			public override bool Equals(object obj)
			{
				if (!(obj is TypeNameKey))
				{
					return false;
				}
				return Equals((TypeNameKey)obj);
			}

			public bool Equals(TypeNameKey other)
			{
				return AssemblyName == other.AssemblyName && TypeName == other.TypeName;
			}
		}

		internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();

		private readonly PlayFab.Json.Utilities.ThreadSafeStore<TypeNameKey, Type> _typeCache = new PlayFab.Json.Utilities.ThreadSafeStore<TypeNameKey, Type>(GetTypeFromTypeNameKey);

		private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
		{
			string assemblyName = typeNameKey.AssemblyName;
			string typeName = typeNameKey.TypeName;
			if (assemblyName != null)
			{
				Assembly assembly = Assembly.Load(assemblyName);
				if (assembly == null)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not load assembly '{0}'.", CultureInfo.InvariantCulture, assemblyName));
				}
				Type type = assembly.GetType(typeName);
				if (type == null)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not find type '{0}' in assembly '{1}'.", CultureInfo.InvariantCulture, typeName, assembly.FullName));
				}
				return type;
			}
			return Type.GetType(typeName);
		}

		public override Type BindToType(string assemblyName, string typeName)
		{
			return _typeCache.Get(new TypeNameKey(assemblyName, typeName));
		}
	}
	public class ErrorContext
	{
		public Exception Error { get; private set; }

		public object OriginalObject { get; private set; }

		public object Member { get; private set; }

		public bool Handled { get; set; }

		internal ErrorContext(object originalObject, object member, Exception error)
		{
			OriginalObject = originalObject;
			Member = member;
			Error = error;
		}
	}
	public class ErrorEventArgs : EventArgs
	{
		public object CurrentObject { get; private set; }

		public ErrorContext ErrorContext { get; private set; }

		public ErrorEventArgs(object currentObject, ErrorContext errorContext)
		{
			CurrentObject = currentObject;
			ErrorContext = errorContext;
		}
	}
	public interface IContractResolver
	{
		JsonContract ResolveContract(Type type);
	}
	public interface IReferenceResolver
	{
		object ResolveReference(object context, string reference);

		string GetReference(object context, object value);

		bool IsReferenced(object context, object value);

		void AddReference(object context, string reference, object value);
	}
	public interface IValueProvider
	{
		void SetValue(object target, object value);

		object GetValue(object target);
	}
	public class JsonArrayContract : JsonContract
	{
		private readonly bool _isCollectionItemTypeNullableType;

		private readonly Type _genericCollectionDefinitionType;

		private Type _genericWrapperType;

		private PlayFab.Json.Utilities.MethodCall<object, object> _genericWrapperCreator;

		internal Type CollectionItemType { get; private set; }

		public bool IsMultidimensionalArray { get; private set; }

		public JsonArrayContract(Type underlyingType)
			: base(underlyingType)
		{
			if (PlayFab.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
			{
				CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
			}
			else if (underlyingType.IsGenericType && underlyingType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
			{
				_genericCollectionDefinitionType = typeof(IEnumerable<>);
				CollectionItemType = underlyingType.GetGenericArguments()[0];
			}
			else
			{
				CollectionItemType = PlayFab.Json.Utilities.ReflectionUtils.GetCollectionItemType(base.UnderlyingType);
			}
			if (CollectionItemType != null)
			{
				_isCollectionItemTypeNullableType = PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(CollectionItemType);
			}
			if (IsTypeGenericCollectionInterface(base.UnderlyingType))
			{
				base.CreatedType = PlayFab.Json.Utilities.ReflectionUtils.MakeGenericType(typeof(List<>), CollectionItemType);
			}
			else if (typeof(HashSet<>).IsAssignableFrom(base.UnderlyingType))
			{
				base.CreatedType = PlayFab.Json.Utilities.ReflectionUtils.MakeGenericType(typeof(HashSet<>), CollectionItemType);
			}
			IsMultidimensionalArray = base.UnderlyingType.IsArray && base.UnderlyingType.GetArrayRank() > 1;
		}

		internal PlayFab.Json.Utilities.IWrappedCollection CreateWrapper(object list)
		{
			if ((list is IList && (CollectionItemType == null || !_isCollectionItemTypeNullableType)) || base.UnderlyingType.IsArray)
			{
				return new PlayFab.Json.Utilities.CollectionWrapper<object>((IList)list);
			}
			if (_genericCollectionDefinitionType != null)
			{
				EnsureGenericWrapperCreator();
				return (PlayFab.Json.Utilities.IWrappedCollection)_genericWrapperCreator(null, list);
			}
			IList list2 = System.Linq.Enumerable.ToList(System.Linq.Enumerable.Cast<object>((IEnumerable)list));
			if (CollectionItemType != null)
			{
				Array array = Array.CreateInstance(CollectionItemType, list2.Count);
				for (int i = 0; i < list2.Count; i++)
				{
					array.SetValue(list2[i], i);
				}
				list2 = array;
			}
			return new PlayFab.Json.Utilities.CollectionWrapper<object>(list2);
		}

		private void EnsureGenericWrapperCreator()
		{
			if (_genericWrapperType == null)
			{
				_genericWrapperType = PlayFab.Json.Utilities.ReflectionUtils.MakeGenericType(typeof(PlayFab.Json.Utilities.CollectionWrapper<>), CollectionItemType);
				Type type = ((!PlayFab.Json.Utilities.ReflectionUtils.InheritsGenericDefinition(_genericCollectionDefinitionType, typeof(List<>)) && _genericCollectionDefinitionType.GetGenericTypeDefinition() != typeof(IEnumerable<>)) ? _genericCollectionDefinitionType : PlayFab.Json.Utilities.ReflectionUtils.MakeGenericType(typeof(ICollection<>), CollectionItemType));
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { type });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(constructor);
			}
		}

		private bool IsTypeGenericCollectionInterface(Type type)
		{
			if (!type.IsGenericType)
			{
				return false;
			}
			Type genericTypeDefinition = type.GetGenericTypeDefinition();
			return genericTypeDefinition == typeof(IList<>) || genericTypeDefinition == typeof(ICollection<>) || genericTypeDefinition == typeof(IEnumerable<>);
		}
	}
	public abstract class JsonContract
	{
		public Type UnderlyingType { get; private set; }

		public Type CreatedType { get; set; }

		public bool? IsReference { get; set; }

		public JsonConverter Converter { get; set; }

		internal JsonConverter InternalConverter { get; set; }

		public MethodInfo OnDeserialized { get; set; }

		public MethodInfo OnDeserializing { get; set; }

		public MethodInfo OnSerialized { get; set; }

		public MethodInfo OnSerializing { get; set; }

		public Func<object> DefaultCreator { get; set; }

		public bool DefaultCreatorNonPublic { get; set; }

		public MethodInfo OnError { get; set; }

		internal JsonContract(Type underlyingType)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(underlyingType, "underlyingType");
			UnderlyingType = underlyingType;
			CreatedType = underlyingType;
		}

		internal void InvokeOnSerializing(object o, StreamingContext context)
		{
			if (OnSerializing != null)
			{
				OnSerializing.Invoke(o, new object[1] { context });
			}
		}

		internal void InvokeOnSerialized(object o, StreamingContext context)
		{
			if (OnSerialized != null)
			{
				OnSerialized.Invoke(o, new object[1] { context });
			}
		}

		internal void InvokeOnDeserializing(object o, StreamingContext context)
		{
			if (OnDeserializing != null)
			{
				OnDeserializing.Invoke(o, new object[1] { context });
			}
		}

		internal void InvokeOnDeserialized(object o, StreamingContext context)
		{
			if (OnDeserialized != null)
			{
				OnDeserialized.Invoke(o, new object[1] { context });
			}
		}

		internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
		{
			if (OnError != null)
			{
				OnError.Invoke(o, new object[2] { context, errorContext });
			}
		}
	}
	public class JsonDictionaryContract : JsonContract
	{
		private readonly bool _isDictionaryValueTypeNullableType;

		private readonly Type _genericCollectionDefinitionType;

		private Type _genericWrapperType;

		private PlayFab.Json.Utilities.MethodCall<object, object> _genericWrapperCreator;

		public Func<string, string> PropertyNameResolver { get; set; }

		internal Type DictionaryKeyType { get; private set; }

		internal Type DictionaryValueType { get; private set; }

		public JsonDictionaryContract(Type underlyingType)
			: base(underlyingType)
		{
			Type keyType;
			Type valueType;
			if (PlayFab.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IDictionary<, >), out _genericCollectionDefinitionType))
			{
				keyType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				valueType = _genericCollectionDefinitionType.GetGenericArguments()[1];
			}
			else
			{
				PlayFab.Json.Utilities.ReflectionUtils.GetDictionaryKeyValueTypes(base.UnderlyingType, out keyType, out valueType);
			}
			DictionaryKeyType = keyType;
			DictionaryValueType = valueType;
			if (DictionaryValueType != null)
			{
				_isDictionaryValueTypeNullableType = PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(DictionaryValueType);
			}
			if (IsTypeGenericDictionaryInterface(base.UnderlyingType))
			{
				base.CreatedType = PlayFab.Json.Utilities.ReflectionUtils.MakeGenericType(typeof(Dictionary<, >), keyType, valueType);
			}
			else if (base.UnderlyingType == typeof(IDictionary))
			{
				base.CreatedType = typeof(Dictionary<object, object>);
			}
		}

		internal PlayFab.Json.Utilities.IWrappedDictionary CreateWrapper(object dictionary)
		{
			if (dictionary is IDictionary && (DictionaryValueType == null || !_isDictionaryValueTypeNullableType))
			{
				return new PlayFab.Json.Utilities.DictionaryWrapper<object, object>((IDictionary)dictionary);
			}
			if (_genericWrapperType == null)
			{
				_genericWrapperType = PlayFab.Json.Utilities.ReflectionUtils.MakeGenericType(typeof(PlayFab.Json.Utilities.DictionaryWrapper<, >), DictionaryKeyType, DictionaryValueType);
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { _genericCollectionDefinitionType });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(constructor);
			}
			return (PlayFab.Json.Utilities.IWrappedDictionary)_genericWrapperCreator(null, dictionary);
		}

		private bool IsTypeGenericDictionaryInterface(Type type)
		{
			if (!type.IsGenericType)
			{
				return false;
			}
			Type genericTypeDefinition = type.GetGenericTypeDefinition();
			return genericTypeDefinition == typeof(IDictionary<, >);
		}
	}
	internal class JsonFormatterConverter : IFormatterConverter
	{
		private readonly JsonSerializer _serializer;

		public JsonFormatterConverter(JsonSerializer serializer)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(serializer, "serializer");
			_serializer = serializer;
		}

		private T GetTokenValue<T>(object value)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
			PlayFab.Json.Linq.JValue jValue = (PlayFab.Json.Linq.JValue)value;
			return (T)System.Convert.ChangeType(jValue.Value, typeof(T), CultureInfo.InvariantCulture);
		}

		public object Convert(object value, Type type)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
			if (!(value is PlayFab.Json.Linq.JToken jToken))
			{
				throw new ArgumentException("Value is not a JToken.", "value");
			}
			return _serializer.Deserialize(jToken.CreateReader(), type);
		}

		public object Convert(object value, TypeCode typeCode)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
			if (value is PlayFab.Json.Linq.JValue)
			{
				value = ((PlayFab.Json.Linq.JValue)value).Value;
			}
			return System.Convert.ChangeType(value, typeCode, CultureInfo.InvariantCulture);
		}

		public bool ToBoolean(object value)
		{
			return GetTokenValue<bool>(value);
		}

		public byte ToByte(object value)
		{
			return GetTokenValue<byte>(value);
		}

		public char ToChar(object value)
		{
			return GetTokenValue<char>(value);
		}

		public DateTime ToDateTime(object value)
		{
			return GetTokenValue<DateTime>(value);
		}

		public decimal ToDecimal(object value)
		{
			return GetTokenValue<decimal>(value);
		}

		public double ToDouble(object value)
		{
			return GetTokenValue<double>(value);
		}

		public short ToInt16(object value)
		{
			return GetTokenValue<short>(value);
		}

		public int ToInt32(object value)
		{
			return GetTokenValue<int>(value);
		}

		public long ToInt64(object value)
		{
			return GetTokenValue<long>(value);
		}

		public sbyte ToSByte(object value)
		{
			return GetTokenValue<sbyte>(value);
		}

		public float ToSingle(object value)
		{
			return GetTokenValue<float>(value);
		}

		public string ToString(object value)
		{
			return GetTokenValue<string>(value);
		}

		public ushort ToUInt16(object value)
		{
			return GetTokenValue<ushort>(value);
		}

		public uint ToUInt32(object value)
		{
			return GetTokenValue<uint>(value);
		}

		public ulong ToUInt64(object value)
		{
			return GetTokenValue<ulong>(value);
		}
	}
	public class JsonISerializableContract : JsonContract
	{
		public ObjectConstructor<object> ISerializableCreator { get; set; }

		public JsonISerializableContract(Type underlyingType)
			: base(underlyingType)
		{
		}
	}
	public class JsonLinqContract : JsonContract
	{
		public JsonLinqContract(Type underlyingType)
			: base(underlyingType)
		{
		}
	}
	public class JsonObjectContract : JsonContract
	{
		public MemberSerialization MemberSerialization { get; set; }

		public JsonPropertyCollection Properties { get; private set; }

		public JsonPropertyCollection ConstructorParameters { get; private set; }

		public ConstructorInfo OverrideConstructor { get; set; }

		public ConstructorInfo ParametrizedConstructor { get; set; }

		public JsonObjectContract(Type underlyingType)
			: base(underlyingType)
		{
			Properties = new JsonPropertyCollection(base.UnderlyingType);
			ConstructorParameters = new JsonPropertyCollection(base.UnderlyingType);
		}
	}
	public class JsonPrimitiveContract : JsonContract
	{
		public JsonPrimitiveContract(Type underlyingType)
			: base(underlyingType)
		{
		}
	}
	public class JsonProperty
	{
		public string PropertyName { get; set; }

		public int? Order { get; set; }

		public string UnderlyingName { get; set; }

		public IValueProvider ValueProvider { get; set; }

		public Type PropertyType { get; set; }

		public JsonConverter Converter { get; set; }

		public JsonConverter MemberConverter { get; set; }

		public bool Ignored { get; set; }

		public bool Readable { get; set; }

		public bool Writable { get; set; }

		public object DefaultValue { get; set; }

		public Required Required { get; set; }

		public bool? IsReference { get; set; }

		public NullValueHandling? NullValueHandling { get; set; }

		public DefaultValueHandling? DefaultValueHandling { get; set; }

		public ReferenceLoopHandling? ReferenceLoopHandling { get; set; }

		public ObjectCreationHandling? ObjectCreationHandling { get; set; }

		public TypeNameHandling? TypeNameHandling { get; set; }

		public Predicate<object> ShouldSerialize { get; set; }

		public Predicate<object> GetIsSpecified { get; set; }

		public Action<object, object> SetIsSpecified { get; set; }

		public override string ToString()
		{
			return PropertyName;
		}
	}
	public class JsonPropertyCollection : KeyedCollection<string, JsonProperty>
	{
		private readonly Type _type;

		public JsonPropertyCollection(Type type)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(type, "type");
			_type = type;
		}

		protected override string GetKeyForItem(JsonProperty item)
		{
			return item.PropertyName;
		}

		public void AddProperty(JsonProperty property)
		{
			if (Contains(property.PropertyName))
			{
				if (property.Ignored)
				{
					return;
				}
				JsonProperty jsonProperty = base[property.PropertyName];
				if (!jsonProperty.Ignored)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.", CultureInfo.InvariantCulture, property.PropertyName, _type));
				}
				Remove(jsonProperty);
			}
			Add(property);
		}

		public JsonProperty GetClosestMatchProperty(string propertyName)
		{
			JsonProperty property = GetProperty(propertyName, StringComparison.Ordinal);
			if (property == null)
			{
				property = GetProperty(propertyName, StringComparison.OrdinalIgnoreCase);
			}
			return property;
		}

		public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
		{
			using (IEnumerator<JsonProperty> enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					JsonProperty current = enumerator.Current;
					if (string.Equals(propertyName, current.PropertyName, comparisonType))
					{
						return current;
					}
				}
			}
			return null;
		}
	}
	internal abstract class JsonSerializerInternalBase
	{
		private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
		{
			bool IEqualityComparer<object>.Equals(object x, object y)
			{
				return object.ReferenceEquals(x, y);
			}

			int IEqualityComparer<object>.GetHashCode(object obj)
			{
				return RuntimeHelpers.GetHashCode(obj);
			}
		}

		private ErrorContext _currentErrorContext;

		private PlayFab.Json.Utilities.BidirectionalDictionary<string, object> _mappings;

		internal JsonSerializer Serializer { get; private set; }

		internal PlayFab.Json.Utilities.BidirectionalDictionary<string, object> DefaultReferenceMappings
		{
			get
			{
				if (_mappings == null)
				{
					_mappings = new PlayFab.Json.Utilities.BidirectionalDictionary<string, object>(EqualityComparer<string>.Default, new ReferenceEqualsEqualityComparer());
				}
				return _mappings;
			}
		}

		protected JsonSerializerInternalBase(JsonSerializer serializer)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(serializer, "serializer");
			Serializer = serializer;
		}

		protected ErrorContext GetErrorContext(object currentObject, object member, Exception error)
		{
			if (_currentErrorContext == null)
			{
				_currentErrorContext = new ErrorContext(currentObject, member, error);
			}
			if (_currentErrorContext.Error != error)
			{
				throw new InvalidOperationException("Current error context error is different to requested error.");
			}
			return _currentErrorContext;
		}

		protected void ClearErrorContext()
		{
			if (_currentErrorContext == null)
			{
				throw new InvalidOperationException("Could not clear error context. Error context is already null.");
			}
			_currentErrorContext = null;
		}

		protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, Exception ex)
		{
			ErrorContext errorContext = GetErrorContext(currentObject, keyValue, ex);
			contract.InvokeOnError(currentObject, Serializer.Context, errorContext);
			if (!errorContext.Handled)
			{
				Serializer.OnError(new ErrorEventArgs(currentObject, errorContext));
			}
			return errorContext.Handled;
		}
	}
	internal class JsonSerializerInternalReader : JsonSerializerInternalBase
	{
		internal enum PropertyPresence
		{
			None,
			Null,
			Value
		}

		private JsonSerializerProxy _internalSerializer;

		private JsonFormatterConverter _formatterConverter;

		public JsonSerializerInternalReader(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Populate(JsonReader reader, object target)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(target, "target");
			Type type = target.GetType();
			JsonContract jsonContract = base.Serializer.ContractResolver.ResolveContract(type);
			if (reader.TokenType == JsonToken.None)
			{
				reader.Read();
			}
			if (reader.TokenType == JsonToken.StartArray)
			{
				if (jsonContract is JsonArrayContract)
				{
					PopulateList(PlayFab.Json.Utilities.CollectionUtils.CreateCollectionWrapper(target), reader, null, (JsonArrayContract)jsonContract);
					return;
				}
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot populate JSON array onto type '{0}'.", CultureInfo.InvariantCulture, type));
			}
			if (reader.TokenType == JsonToken.StartObject)
			{
				CheckedRead(reader);
				string id = null;
				if (reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$id", StringComparison.Ordinal))
				{
					CheckedRead(reader);
					id = ((reader.Value == null) ? null : reader.Value.ToString());
					CheckedRead(reader);
				}
				if (jsonContract is JsonDictionaryContract)
				{
					PopulateDictionary(PlayFab.Json.Utilities.CollectionUtils.CreateDictionaryWrapper(target), reader, (JsonDictionaryContract)jsonContract, id);
					return;
				}
				if (jsonContract is JsonObjectContract)
				{
					PopulateObject(target, reader, (JsonObjectContract)jsonContract, id);
					return;
				}
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot populate JSON object onto type '{0}'.", CultureInfo.InvariantCulture, type));
			}
			throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected initial token '{0}' when populating object. Expected JSON object or array.", CultureInfo.InvariantCulture, reader.TokenType));
		}

		private JsonContract GetContractSafe(Type type)
		{
			if (type == null)
			{
				return null;
			}
			return base.Serializer.ContractResolver.ResolveContract(type);
		}

		private JsonContract GetContractSafe(Type type, object value)
		{
			if (value == null)
			{
				return GetContractSafe(type);
			}
			return base.Serializer.ContractResolver.ResolveContract(value.GetType());
		}

		public object Deserialize(JsonReader reader, Type objectType)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			if (reader.TokenType == JsonToken.None && !ReadForType(reader, objectType, null))
			{
				return null;
			}
			return CreateValueNonProperty(reader, objectType, GetContractSafe(objectType));
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (_internalSerializer == null)
			{
				_internalSerializer = new JsonSerializerProxy(this);
			}
			return _internalSerializer;
		}

		private JsonFormatterConverter GetFormatterConverter()
		{
			if (_formatterConverter == null)
			{
				_formatterConverter = new JsonFormatterConverter(GetInternalSerializer());
			}
			return _formatterConverter;
		}

		private PlayFab.Json.Linq.JToken CreateJToken(JsonReader reader, JsonContract contract)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			if (contract != null && contract.UnderlyingType == typeof(PlayFab.Json.Linq.JRaw))
			{
				return PlayFab.Json.Linq.JRaw.Create(reader);
			}
			using PlayFab.Json.Linq.JTokenWriter jTokenWriter = new PlayFab.Json.Linq.JTokenWriter();
			jTokenWriter.WriteToken(reader);
			return jTokenWriter.Token;
		}

		private PlayFab.Json.Linq.JToken CreateJObject(JsonReader reader)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			using PlayFab.Json.Linq.JTokenWriter jTokenWriter = new PlayFab.Json.Linq.JTokenWriter();
			jTokenWriter.WriteStartObject();
			if (reader.TokenType == JsonToken.PropertyName)
			{
				jTokenWriter.WriteToken(reader, reader.Depth - 1);
			}
			else
			{
				jTokenWriter.WriteEndObject();
			}
			return jTokenWriter.Token;
		}

		private object CreateValueProperty(JsonReader reader, JsonProperty property, object target, bool gottenCurrentValue, object currentValue)
		{
			JsonContract contractSafe = GetContractSafe(property.PropertyType, currentValue);
			Type propertyType = property.PropertyType;
			JsonConverter converter = GetConverter(contractSafe, property.MemberConverter);
			if (converter != null && converter.CanRead)
			{
				if (!gottenCurrentValue && target != null && property.Readable)
				{
					currentValue = property.ValueProvider.GetValue(target);
				}
				return converter.ReadJson(reader, propertyType, currentValue, GetInternalSerializer());
			}
			return CreateValueInternal(reader, propertyType, contractSafe, property, currentValue);
		}

		private object CreateValueNonProperty(JsonReader reader, Type objectType, JsonContract contract)
		{
			JsonConverter converter = GetConverter(contract, null);
			if (converter != null && converter.CanRead)
			{
				return converter.ReadJson(reader, objectType, null, GetInternalSerializer());
			}
			return CreateValueInternal(reader, objectType, contract, null, null);
		}

		private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue)
		{
			if (contract is JsonLinqContract)
			{
				return CreateJToken(reader, contract);
			}
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.StartObject:
					return CreateObject(reader, objectType, contract, member, existingValue);
				case JsonToken.StartArray:
					return CreateList(reader, objectType, contract, member, existingValue, null);
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
					return EnsureType(reader.Value, CultureInfo.InvariantCulture, objectType);
				case JsonToken.String:
					if (string.IsNullOrEmpty((string)reader.Value) && objectType != null && PlayFab.Json.Utilities.ReflectionUtils.IsNullableType(objectType))
					{
						return null;
					}
					if (objectType == typeof(byte[]))
					{
						return Convert.FromBase64String((string)reader.Value);
					}
					return EnsureType(reader.Value, CultureInfo.InvariantCulture, objectType);
				case JsonToken.StartConstructor:
				case JsonToken.EndConstructor:
					return reader.Value.ToString();
				case JsonToken.Null:
				case JsonToken.Undefined:
					if (objectType == typeof(DBNull))
					{
						return DBNull.Value;
					}
					return EnsureType(reader.Value, CultureInfo.InvariantCulture, objectType);
				case JsonToken.Raw:
					return new PlayFab.Json.Linq.JRaw((string)reader.Value);
				default:
					throw new JsonSerializationException("Unexpected token while deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (reader.Read());
			throw new JsonSerializationException("Unexpected end when deserializing object.");
		}

		private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter)
		{
			JsonConverter result = null;
			if (memberConverter != null)
			{
				result = memberConverter;
			}
			else if (contract != null)
			{
				JsonConverter matchingConverter;
				if (contract.Converter != null)
				{
					result = contract.Converter;
				}
				else if ((matchingConverter = base.Serializer.GetMatchingConverter(contract.UnderlyingType)) != null)
				{
					result = matchingConverter;
				}
				else if (contract.InternalConverter != null)
				{
					result = contract.InternalConverter;
				}
			}
			return result;
		}

		private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue)
		{
			CheckedRead(reader);
			string text = null;
			if (reader.TokenType == JsonToken.PropertyName)
			{
				bool flag;
				do
				{
					string a = reader.Value.ToString();
					if (string.Equals(a, "$ref", StringComparison.Ordinal))
					{
						CheckedRead(reader);
						if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null)
						{
							throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("JSON reference {0} property must have a string or null value.", CultureInfo.InvariantCulture, "$ref"));
						}
						string text2 = ((reader.Value == null) ? null : reader.Value.ToString());
						CheckedRead(reader);
						if (text2 != null)
						{
							if (reader.TokenType == JsonToken.PropertyName)
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Additional content found in JSON reference object. A JSON reference object should only have a {0} property.", CultureInfo.InvariantCulture, "$ref"));
							}
							return base.Serializer.ReferenceResolver.ResolveReference(this, text2);
						}
						flag = true;
					}
					else if (string.Equals(a, "$type", StringComparison.Ordinal))
					{
						CheckedRead(reader);
						string text3 = reader.Value.ToString();
						CheckedRead(reader);
						TypeNameHandling? typeNameHandling = member?.TypeNameHandling;
						if (((!typeNameHandling.HasValue) ? base.Serializer.TypeNameHandling : typeNameHandling.Value) != 0)
						{
							PlayFab.Json.Utilities.ReflectionUtils.SplitFullyQualifiedTypeName(text3, out var typeName, out var assemblyName);
							Type type;
							try
							{
								type = base.Serializer.Binder.BindToType(assemblyName, typeName);
							}
							catch (Exception innerException)
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error resolving type specified in JSON '{0}'.", CultureInfo.InvariantCulture, text3), innerException);
							}
							if (type == null)
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Type specified in JSON '{0}' was not resolved.", CultureInfo.InvariantCulture, text3));
							}
							if (objectType != null && !objectType.IsAssignableFrom(type))
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Type specified in JSON '{0}' is not compatible with '{1}'.", CultureInfo.InvariantCulture, type.AssemblyQualifiedName, objectType.AssemblyQualifiedName));
							}
							objectType = type;
							contract = GetContractSafe(type);
						}
						flag = true;
					}
					else if (string.Equals(a, "$id", StringComparison.Ordinal))
					{
						CheckedRead(reader);
						text = ((reader.Value == null) ? null : reader.Value.ToString());
						CheckedRead(reader);
						flag = true;
					}
					else
					{
						if (string.Equals(a, "$values", StringComparison.Ordinal))
						{
							CheckedRead(reader);
							object result = CreateList(reader, objectType, contract, member, existingValue, text);
							CheckedRead(reader);
							return result;
						}
						flag = false;
					}
				}
				while (flag && reader.TokenType == JsonToken.PropertyName);
			}
			if (!HasDefinedType(objectType))
			{
				return CreateJObject(reader);
			}
			if (contract == null)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not resolve type '{0}' to a JsonContract.", CultureInfo.InvariantCulture, objectType));
			}
			if (contract is JsonDictionaryContract jsonDictionaryContract)
			{
				if (existingValue == null)
				{
					return CreateAndPopulateDictionary(reader, jsonDictionaryContract, text);
				}
				return PopulateDictionary(jsonDictionaryContract.CreateWrapper(existingValue), reader, jsonDictionaryContract, text);
			}
			if (contract is JsonObjectContract contract2)
			{
				if (existingValue == null)
				{
					return CreateAndPopulateObject(reader, contract2, text);
				}
				return PopulateObject(existingValue, reader, contract2, text);
			}
			if (contract is JsonPrimitiveContract contract3 && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$value", StringComparison.Ordinal))
			{
				CheckedRead(reader);
				object result2 = CreateValueInternal(reader, objectType, contract3, member, existingValue);
				CheckedRead(reader);
				return result2;
			}
			if (contract is JsonISerializableContract contract4)
			{
				return CreateISerializable(reader, contract4, text);
			}
			throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot deserialize JSON object into type '{0}'.", CultureInfo.InvariantCulture, objectType));
		}

		private JsonArrayContract EnsureArrayContract(Type objectType, JsonContract contract)
		{
			if (contract == null)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not resolve type '{0}' to a JsonContract.", CultureInfo.InvariantCulture, objectType));
			}
			if (!(contract is JsonArrayContract result))
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot deserialize JSON array into type '{0}'.", CultureInfo.InvariantCulture, objectType));
			}
			return result;
		}

		private void CheckedRead(JsonReader reader)
		{
			if (!reader.Read())
			{
				throw new JsonSerializationException("Unexpected end when deserializing object.");
			}
		}

		private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string reference)
		{
			if (HasDefinedType(objectType))
			{
				JsonArrayContract jsonArrayContract = EnsureArrayContract(objectType, contract);
				if (existingValue == null || objectType == typeof(BitArray))
				{
					return CreateAndPopulateList(reader, reference, jsonArrayContract);
				}
				return PopulateList(jsonArrayContract.CreateWrapper(existingValue), reader, reference, jsonArrayContract);
			}
			return CreateJToken(reader, contract);
		}

		private bool HasDefinedType(Type type)
		{
			return type != null && type != typeof(object) && !typeof(PlayFab.Json.Linq.JToken).IsAssignableFrom(type);
		}

		private object EnsureType(object value, CultureInfo culture, Type targetType)
		{
			if (targetType == null)
			{
				return value;
			}
			Type objectType = PlayFab.Json.Utilities.ReflectionUtils.GetObjectType(value);
			if (objectType != targetType)
			{
				try
				{
					return PlayFab.Json.Utilities.ConvertUtils.ConvertOrCast(value, culture, targetType);
				}
				catch (Exception innerException)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error converting value {0} to type '{1}'.", CultureInfo.InvariantCulture, FormatValueForPrint(value), targetType), innerException);
				}
			}
			return value;
		}

		private string FormatValueForPrint(object value)
		{
			if (value == null)
			{
				return "{null}";
			}
			if (value is string)
			{
				return string.Concat("\"", value, "\"");
			}
			return value.ToString();
		}

		private void SetPropertyValue(JsonProperty property, JsonReader reader, object target)
		{
			if (property.Ignored)
			{
				reader.Skip();
				return;
			}
			object obj = null;
			bool flag = false;
			bool gottenCurrentValue = false;
			ObjectCreationHandling valueOrDefault = property.ObjectCreationHandling.GetValueOrDefault(base.Serializer.ObjectCreationHandling);
			if ((valueOrDefault == ObjectCreationHandling.Auto || valueOrDefault == ObjectCreationHandling.Reuse) && (reader.TokenType == JsonToken.StartArray || reader.TokenType == JsonToken.StartObject) && property.Readable)
			{
				obj = property.ValueProvider.GetValue(target);
				gottenCurrentValue = true;
				flag = obj != null && !property.PropertyType.IsArray && !PlayFab.Json.Utilities.ReflectionUtils.InheritsGenericDefinition(property.PropertyType, typeof(ReadOnlyCollection<>)) && !property.PropertyType.IsValueType;
			}
			if (!property.Writable && !flag)
			{
				reader.Skip();
				return;
			}
			if (property.NullValueHandling.GetValueOrDefault(base.Serializer.NullValueHandling) == NullValueHandling.Ignore && reader.TokenType == JsonToken.Null)
			{
				reader.Skip();
				return;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(base.Serializer.DefaultValueHandling), DefaultValueHandling.Ignore) && JsonReader.IsPrimitiveToken(reader.TokenType) && PlayFab.Json.Utilities.MiscellaneousUtils.ValueEquals(reader.Value, property.DefaultValue))
			{
				reader.Skip();
				return;
			}
			object currentValue = ((!flag) ? null : obj);
			object obj2 = CreateValueProperty(reader, property, target, gottenCurrentValue, currentValue);
			if ((!flag || obj2 != obj) && ShouldSetPropertyValue(property, obj2))
			{
				property.ValueProvider.SetValue(target, obj2);
				if (property.SetIsSpecified != null)
				{
					property.SetIsSpecified(target, true);
				}
			}
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool ShouldSetPropertyValue(JsonProperty property, object value)
		{
			if (property.NullValueHandling.GetValueOrDefault(base.Serializer.NullValueHandling) == NullValueHandling.Ignore && value == null)
			{
				return false;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(base.Serializer.DefaultValueHandling), DefaultValueHandling.Ignore) && PlayFab.Json.Utilities.MiscellaneousUtils.ValueEquals(value, property.DefaultValue))
			{
				return false;
			}
			if (!property.Writable)
			{
				return false;
			}
			return true;
		}

		private object CreateAndPopulateDictionary(JsonReader reader, JsonDictionaryContract contract, string id)
		{
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || base.Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				object dictionary = contract.DefaultCreator();
				PlayFab.Json.Utilities.IWrappedDictionary wrappedDictionary = contract.CreateWrapper(dictionary);
				PopulateDictionary(wrappedDictionary, reader, contract, id);
				return wrappedDictionary.UnderlyingDictionary;
			}
			throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unable to find a default constructor to use for type {0}.", CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private object PopulateDictionary(PlayFab.Json.Utilities.IWrappedDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, string id)
		{
			if (id != null)
			{
				base.Serializer.ReferenceResolver.AddReference(this, id, dictionary.UnderlyingDictionary);
			}
			contract.InvokeOnDeserializing(dictionary.UnderlyingDictionary, base.Serializer.Context);
			int depth = reader.Depth;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					object obj = reader.Value;
					try
					{
						try
						{
							obj = EnsureType(obj, CultureInfo.InvariantCulture, contract.DictionaryKeyType);
						}
						catch (Exception innerException)
						{
							throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.", CultureInfo.InvariantCulture, reader.Value, contract.DictionaryKeyType), innerException);
						}
						if (!ReadForType(reader, contract.DictionaryValueType, null))
						{
							throw new JsonSerializationException("Unexpected end when deserializing object.");
						}
						dictionary[obj] = CreateValueNonProperty(reader, contract.DictionaryValueType, GetContractSafe(contract.DictionaryValueType));
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(dictionary, contract, obj, ex))
						{
							HandleError(reader, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					contract.InvokeOnDeserialized(dictionary.UnderlyingDictionary, base.Serializer.Context);
					return dictionary.UnderlyingDictionary;
				default:
					throw new JsonSerializationException("Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (reader.Read());
			throw new JsonSerializationException("Unexpected end when deserializing object.");
		}

		private object CreateAndPopulateList(JsonReader reader, string reference, JsonArrayContract contract)
		{
			return PlayFab.Json.Utilities.CollectionUtils.CreateAndPopulateList(contract.CreatedType, delegate(IList l, bool isTemporaryListReference)
			{
				if (reference != null && isTemporaryListReference)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot preserve reference to array or readonly list: {0}", CultureInfo.InvariantCulture, contract.UnderlyingType));
				}
				if (contract.OnSerializing != null && isTemporaryListReference)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot call OnSerializing on an array or readonly list: {0}", CultureInfo.InvariantCulture, contract.UnderlyingType));
				}
				if (contract.OnError != null && isTemporaryListReference)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot call OnError on an array or readonly list: {0}", CultureInfo.InvariantCulture, contract.UnderlyingType));
				}
				if (!contract.IsMultidimensionalArray)
				{
					PopulateList(contract.CreateWrapper(l), reader, reference, contract);
				}
				else
				{
					PopulateMultidimensionalArray(l, reader, reference, contract);
				}
			});
		}

		private bool ReadForTypeArrayHack(JsonReader reader, Type t)
		{
			try
			{
				return ReadForType(reader, t, null);
			}
			catch (JsonReaderException)
			{
				if (reader.TokenType == JsonToken.EndArray)
				{
					return true;
				}
				throw;
			}
		}

		private object PopulateList(PlayFab.Json.Utilities.IWrappedCollection wrappedList, JsonReader reader, string reference, JsonArrayContract contract)
		{
			object underlyingCollection = wrappedList.UnderlyingCollection;
			if (wrappedList.IsFixedSize)
			{
				reader.Skip();
				return wrappedList.UnderlyingCollection;
			}
			if (reference != null)
			{
				base.Serializer.ReferenceResolver.AddReference(this, reference, underlyingCollection);
			}
			contract.InvokeOnDeserializing(underlyingCollection, base.Serializer.Context);
			int depth = reader.Depth;
			while (ReadForTypeArrayHack(reader, contract.CollectionItemType))
			{
				switch (reader.TokenType)
				{
				case JsonToken.EndArray:
					contract.InvokeOnDeserialized(underlyingCollection, base.Serializer.Context);
					return wrappedList.UnderlyingCollection;
				case JsonToken.Comment:
					continue;
				}
				try
				{
					object value = CreateValueNonProperty(reader, contract.CollectionItemType, GetContractSafe(contract.CollectionItemType));
					wrappedList.Add(value);
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(underlyingCollection, contract, wrappedList.Count, ex))
					{
						HandleError(reader, depth);
						continue;
					}
					throw;
				}
			}
			throw new JsonSerializationException("Unexpected end when deserializing array.");
		}

		private object PopulateMultidimensionalArray(IList list, JsonReader reader, string reference, JsonArrayContract contract)
		{
			int arrayRank = contract.UnderlyingType.GetArrayRank();
			if (reference != null)
			{
				base.Serializer.ReferenceResolver.AddReference(this, reference, list);
			}
			contract.InvokeOnDeserializing(list, base.Serializer.Context);
			Stack<IList> stack = new Stack<IList>();
			stack.Push(list);
			IList list2 = list;
			bool flag = false;
			do
			{
				int depth = reader.Depth;
				if (stack.Count == arrayRank)
				{
					if (!ReadForTypeArrayHack(reader, contract.CollectionItemType))
					{
						break;
					}
					switch (reader.TokenType)
					{
					case JsonToken.EndArray:
						stack.Pop();
						list2 = stack.Peek();
						continue;
					case JsonToken.Comment:
						continue;
					}
					try
					{
						object value = CreateValueNonProperty(reader, contract.CollectionItemType, GetContractSafe(contract.CollectionItemType));
						list2.Add(value);
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(list, contract, list2.Count, ex))
						{
							HandleError(reader, depth);
							continue;
						}
						throw;
					}
					continue;
				}
				if (!reader.Read())
				{
					break;
				}
				switch (reader.TokenType)
				{
				case JsonToken.StartArray:
				{
					IList list3 = new List<object>();
					list2.Add(list3);
					stack.Push(list3);
					list2 = list3;
					break;
				}
				case JsonToken.EndArray:
					stack.Pop();
					if (stack.Count > 0)
					{
						list2 = stack.Peek();
					}
					else
					{
						flag = true;
					}
					break;
				default:
					throw new JsonSerializationException("Unexpected token when deserializing multidimensional array: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag);
			if (!flag)
			{
				throw new JsonSerializationException("Unexpected end when deserializing array." + reader.TokenType);
			}
			contract.InvokeOnDeserialized(list, base.Serializer.Context);
			return list;
		}

		private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, string id)
		{
			Type underlyingType = contract.UnderlyingType;
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, GetFormatterConverter());
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (!reader.Read())
					{
						throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected end when setting {0}'s value.", CultureInfo.InvariantCulture, text));
					}
					serializationInfo.AddValue(text, PlayFab.Json.Linq.JToken.ReadFrom(reader));
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw new JsonSerializationException("Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (contract.ISerializableCreator == null)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.", CultureInfo.InvariantCulture, underlyingType));
			}
			object obj = contract.ISerializableCreator(serializationInfo, base.Serializer.Context);
			if (id != null)
			{
				base.Serializer.ReferenceResolver.AddReference(this, id, obj);
			}
			contract.InvokeOnDeserializing(obj, base.Serializer.Context);
			contract.InvokeOnDeserialized(obj, base.Serializer.Context);
			return obj;
		}

		private object CreateAndPopulateObject(JsonReader reader, JsonObjectContract contract, string id)
		{
			object obj = null;
			if (contract.UnderlyingType.IsInterface || contract.UnderlyingType.IsAbstract)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantated.", CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			if (contract.OverrideConstructor != null)
			{
				if (contract.OverrideConstructor.GetParameters().Length > 0)
				{
					return CreateObjectFromNonDefaultConstructor(reader, contract, contract.OverrideConstructor, id);
				}
				obj = contract.OverrideConstructor.Invoke(null);
			}
			else if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || base.Serializer.ConstructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				obj = contract.DefaultCreator();
			}
			else if (contract.ParametrizedConstructor != null)
			{
				return CreateObjectFromNonDefaultConstructor(reader, contract, contract.ParametrizedConstructor, id);
			}
			if (obj == null)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unable to find a constructor to use for type {0}. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute.", CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			PopulateObject(obj, reader, contract, id);
			return obj;
		}

		private object CreateObjectFromNonDefaultConstructor(JsonReader reader, JsonObjectContract contract, ConstructorInfo constructorInfo, string id)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(constructorInfo, "constructorInfo");
			Type underlyingType = contract.UnderlyingType;
			IDictionary<JsonProperty, object> dictionary = ResolvePropertyAndConstructorValues(contract, reader, underlyingType);
			IDictionary<ParameterInfo, object> dictionary2 = System.Linq.Enumerable.ToDictionary(constructorInfo.GetParameters(), (ParameterInfo p) => p, (ParameterInfo p) => (object)null);
			IDictionary<JsonProperty, object> dictionary3 = new Dictionary<JsonProperty, object>();
			foreach (KeyValuePair<JsonProperty, object> item in dictionary)
			{
				ParameterInfo key = PlayFab.Json.Utilities.StringUtils.ForgivingCaseSensitiveFind(dictionary2, (KeyValuePair<ParameterInfo, object> kv) => kv.Key.Name, item.Key.UnderlyingName).Key;
				if (key != null)
				{
					dictionary2[key] = item.Value;
				}
				else
				{
					dictionary3.Add(item);
				}
			}
			object obj = constructorInfo.Invoke(System.Linq.Enumerable.ToArray(dictionary2.Values));
			if (id != null)
			{
				base.Serializer.ReferenceResolver.AddReference(this, id, obj);
			}
			contract.InvokeOnDeserializing(obj, base.Serializer.Context);
			foreach (KeyValuePair<JsonProperty, object> item2 in dictionary3)
			{
				JsonProperty key2 = item2.Key;
				object value = item2.Value;
				if (ShouldSetPropertyValue(item2.Key, item2.Value))
				{
					key2.ValueProvider.SetValue(obj, value);
				}
				else
				{
					if (key2.Writable || value == null)
					{
						continue;
					}
					JsonContract jsonContract = base.Serializer.ContractResolver.ResolveContract(key2.PropertyType);
					if (jsonContract is JsonArrayContract)
					{
						JsonArrayContract jsonArrayContract = jsonContract as JsonArrayContract;
						object value2 = key2.ValueProvider.GetValue(obj);
						if (value2 == null)
						{
							continue;
						}
						PlayFab.Json.Utilities.IWrappedCollection wrappedCollection = jsonArrayContract.CreateWrapper(value2);
						PlayFab.Json.Utilities.IWrappedCollection wrappedCollection2 = jsonArrayContract.CreateWrapper(value);
						foreach (object item3 in wrappedCollection2)
						{
							wrappedCollection.Add(item3);
						}
					}
					else
					{
						if (!(jsonContract is JsonDictionaryContract))
						{
							continue;
						}
						JsonDictionaryContract jsonDictionaryContract = jsonContract as JsonDictionaryContract;
						object value3 = key2.ValueProvider.GetValue(obj);
						if (value3 == null)
						{
							continue;
						}
						PlayFab.Json.Utilities.IWrappedDictionary wrappedDictionary = jsonDictionaryContract.CreateWrapper(value3);
						PlayFab.Json.Utilities.IWrappedDictionary wrappedDictionary2 = jsonDictionaryContract.CreateWrapper(value);
						foreach (DictionaryEntry item4 in wrappedDictionary2)
						{
							wrappedDictionary.Add(item4.Key, item4.Value);
						}
					}
				}
			}
			contract.InvokeOnDeserialized(obj, base.Serializer.Context);
			return obj;
		}

		private IDictionary<JsonProperty, object> ResolvePropertyAndConstructorValues(JsonObjectContract contract, JsonReader reader, Type objectType)
		{
			IDictionary<JsonProperty, object> dictionary = new Dictionary<JsonProperty, object>();
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					JsonProperty jsonProperty = contract.ConstructorParameters.GetClosestMatchProperty(text) ?? contract.Properties.GetClosestMatchProperty(text);
					if (jsonProperty != null)
					{
						if (!ReadForType(reader, jsonProperty.PropertyType, jsonProperty.Converter))
						{
							throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected end when setting {0}'s value.", CultureInfo.InvariantCulture, text));
						}
						if (!jsonProperty.Ignored)
						{
							dictionary[jsonProperty] = CreateValueProperty(reader, jsonProperty, null, gottenCurrentValue: true, null);
						}
						else
						{
							reader.Skip();
						}
						break;
					}
					if (!reader.Read())
					{
						throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected end when setting {0}'s value.", CultureInfo.InvariantCulture, text));
					}
					if (base.Serializer.MissingMemberHandling == MissingMemberHandling.Error)
					{
						throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not find member '{0}' on object of type '{1}'", CultureInfo.InvariantCulture, text, objectType.Name));
					}
					reader.Skip();
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw new JsonSerializationException("Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			return dictionary;
		}

		private bool ReadForType(JsonReader reader, Type t, JsonConverter propertyConverter)
		{
			if (GetConverter(GetContractSafe(t), propertyConverter) != null)
			{
				return reader.Read();
			}
			if (t == typeof(byte[]))
			{
				reader.ReadAsBytes();
				return true;
			}
			if (t == typeof(decimal) || t == typeof(decimal?))
			{
				reader.ReadAsDecimal();
				return true;
			}
			if (t == typeof(DateTimeOffset) || t == typeof(DateTimeOffset?))
			{
				reader.ReadAsDateTimeOffset();
				return true;
			}
			do
			{
				if (!reader.Read())
				{
					return false;
				}
			}
			while (reader.TokenType == JsonToken.Comment);
			return true;
		}

		private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, string id)
		{
			contract.InvokeOnDeserializing(newObject, base.Serializer.Context);
			Dictionary<JsonProperty, PropertyPresence> dictionary = System.Linq.Enumerable.ToDictionary(contract.Properties, (JsonProperty m) => m, (JsonProperty m) => PropertyPresence.None);
			if (id != null)
			{
				base.Serializer.ReferenceResolver.AddReference(this, id, newObject);
			}
			int depth = reader.Depth;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					try
					{
						JsonProperty closestMatchProperty = contract.Properties.GetClosestMatchProperty(text);
						if (closestMatchProperty == null)
						{
							if (base.Serializer.MissingMemberHandling == MissingMemberHandling.Error)
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Could not find member '{0}' on object of type '{1}'", CultureInfo.InvariantCulture, text, contract.UnderlyingType.Name));
							}
							reader.Skip();
						}
						else
						{
							if (!ReadForType(reader, closestMatchProperty.PropertyType, closestMatchProperty.Converter))
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected end when setting {0}'s value.", CultureInfo.InvariantCulture, text));
							}
							SetPropertyPresence(reader, closestMatchProperty, dictionary);
							SetPropertyValue(closestMatchProperty, reader, newObject);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(newObject, contract, text, ex))
						{
							HandleError(reader, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					foreach (KeyValuePair<JsonProperty, PropertyPresence> item in dictionary)
					{
						JsonProperty key = item.Key;
						switch (item.Value)
						{
						case PropertyPresence.None:
							if (key.Required == Required.AllowNull || key.Required == Required.Always)
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Required property '{0}' not found in JSON.", CultureInfo.InvariantCulture, key.PropertyName));
							}
							if (HasFlag(key.DefaultValueHandling.GetValueOrDefault(base.Serializer.DefaultValueHandling), DefaultValueHandling.Populate) && key.Writable)
							{
								key.ValueProvider.SetValue(newObject, EnsureType(key.DefaultValue, CultureInfo.InvariantCulture, key.PropertyType));
							}
							break;
						case PropertyPresence.Null:
							if (key.Required == Required.Always)
							{
								throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Required property '{0}' expects a value but got null.", CultureInfo.InvariantCulture, key.PropertyName));
							}
							break;
						}
					}
					contract.InvokeOnDeserialized(newObject, base.Serializer.Context);
					return newObject;
				default:
					throw new JsonSerializationException("Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (reader.Read());
			throw new JsonSerializationException("Unexpected end when deserializing object.");
		}

		private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary<JsonProperty, PropertyPresence> requiredProperties)
		{
			if (property != null)
			{
				requiredProperties[property] = ((reader.TokenType == JsonToken.Null || reader.TokenType == JsonToken.Undefined) ? PropertyPresence.Null : PropertyPresence.Value);
			}
		}

		private void HandleError(JsonReader reader, int initialDepth)
		{
			ClearErrorContext();
			reader.Skip();
			while (reader.Depth > initialDepth + 1)
			{
				reader.Read();
			}
		}
	}
	internal class JsonSerializerInternalWriter : JsonSerializerInternalBase
	{
		private JsonSerializerProxy _internalSerializer;

		private List<object> _serializeStack;

		private List<object> SerializeStack
		{
			get
			{
				if (_serializeStack == null)
				{
					_serializeStack = new List<object>();
				}
				return _serializeStack;
			}
		}

		public JsonSerializerInternalWriter(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Serialize(JsonWriter jsonWriter, object value)
		{
			if (jsonWriter == null)
			{
				throw new ArgumentNullException("jsonWriter");
			}
			SerializeValue(jsonWriter, value, GetContractSafe(value), null, null);
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (_internalSerializer == null)
			{
				_internalSerializer = new JsonSerializerProxy(this);
			}
			return _internalSerializer;
		}

		private JsonContract GetContractSafe(object value)
		{
			if (value == null)
			{
				return null;
			}
			return base.Serializer.ContractResolver.ResolveContract(value.GetType());
		}

		private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContract collectionValueContract)
		{
			if (contract.UnderlyingType == typeof(byte[]) && ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionValueContract))
			{
				writer.WriteStartObject();
				WriteTypeProperty(writer, contract.CreatedType);
				writer.WritePropertyName("$value");
				writer.WriteValue(value);
				writer.WriteEndObject();
			}
			else
			{
				writer.WriteValue(value);
			}
		}

		private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContract collectionValueContract)
		{
			JsonConverter jsonConverter = member?.Converter;
			if (value == null)
			{
				writer.WriteNull();
			}
			else if ((jsonConverter != null || (jsonConverter = valueContract.Converter) != null || (jsonConverter = base.Serializer.GetMatchingConverter(valueContract.UnderlyingType)) != null || (jsonConverter = valueContract.InternalConverter) != null) && jsonConverter.CanWrite)
			{
				SerializeConvertable(writer, jsonConverter, value, valueContract);
			}
			else if (valueContract is JsonPrimitiveContract)
			{
				SerializePrimitive(writer, value, (JsonPrimitiveContract)valueContract, member, collectionValueContract);
			}
			else if (valueContract is JsonStringContract)
			{
				SerializeString(writer, value, (JsonStringContract)valueContract);
			}
			else if (valueContract is JsonObjectContract)
			{
				SerializeObject(writer, value, (JsonObjectContract)valueContract, member, collectionValueContract);
			}
			else if (valueContract is JsonDictionaryContract)
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)valueContract;
				SerializeDictionary(writer, jsonDictionaryContract.CreateWrapper(value), jsonDictionaryContract, member, collectionValueContract);
			}
			else if (valueContract is JsonArrayContract)
			{
				JsonArrayContract jsonArrayContract = (JsonArrayContract)valueContract;
				if (!jsonArrayContract.IsMultidimensionalArray)
				{
					SerializeList(writer, jsonArrayContract.CreateWrapper(value), jsonArrayContract, member, collectionValueContract);
				}
				else
				{
					SerializeMultidimensionalArray(writer, (Array)value, jsonArrayContract, member, collectionValueContract);
				}
			}
			else if (valueContract is JsonLinqContract)
			{
				((PlayFab.Json.Linq.JToken)value).WriteTo(writer, (base.Serializer.Converters == null) ? null : System.Linq.Enumerable.ToArray(base.Serializer.Converters));
			}
			else if (valueContract is JsonISerializableContract)
			{
				SerializeISerializable(writer, (ISerializable)value, (JsonISerializableContract)valueContract);
			}
		}

		private bool ShouldWriteReference(object value, JsonProperty property, JsonContract contract)
		{
			if (value == null)
			{
				return false;
			}
			if (contract is JsonPrimitiveContract)
			{
				return false;
			}
			bool? flag = null;
			if (property != null)
			{
				flag = property.IsReference;
			}
			if (!flag.HasValue)
			{
				flag = contract.IsReference;
			}
			if (!flag.HasValue)
			{
				flag = ((!(contract is JsonArrayContract)) ? new bool?(HasFlag(base.Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Objects)) : new bool?(HasFlag(base.Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Arrays)));
			}
			if (!flag.Value)
			{
				return false;
			}
			return base.Serializer.ReferenceResolver.IsReferenced(this, value);
		}

		private void WriteMemberInfoProperty(JsonWriter writer, object memberValue, JsonProperty property, JsonContract contract)
		{
			string propertyName = property.PropertyName;
			object defaultValue = property.DefaultValue;
			if ((property.NullValueHandling.GetValueOrDefault(base.Serializer.NullValueHandling) == NullValueHandling.Ignore && memberValue == null) || (HasFlag(property.DefaultValueHandling.GetValueOrDefault(base.Serializer.DefaultValueHandling), DefaultValueHandling.Ignore) && PlayFab.Json.Utilities.MiscellaneousUtils.ValueEquals(memberValue, defaultValue)))
			{
				return;
			}
			if (ShouldWriteReference(memberValue, property, contract))
			{
				writer.WritePropertyName(propertyName);
				WriteReference(writer, memberValue);
			}
			else if (CheckForCircularReference(memberValue, property.ReferenceLoopHandling, contract))
			{
				if (memberValue == null && property.Required == Required.Always)
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Cannot write a null value for property '{0}'. Property requires a value.", CultureInfo.InvariantCulture, property.PropertyName));
				}
				writer.WritePropertyName(propertyName);
				SerializeValue(writer, memberValue, contract, property, null);
			}
		}

		private bool CheckForCircularReference(object value, ReferenceLoopHandling? referenceLoopHandling, JsonContract contract)
		{
			if (value == null || contract is JsonPrimitiveContract)
			{
				return true;
			}
			if (SerializeStack.IndexOf(value) != -1)
			{
				return ((value is Vector2 || value is Vector3 || value is Vector4 || value is UnityEngine.Color || value is Color32) ? ReferenceLoopHandling.Ignore : referenceLoopHandling.GetValueOrDefault(base.Serializer.ReferenceLoopHandling)) switch
				{
					ReferenceLoopHandling.Error => throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Self referencing loop detected for type '{0}'.", CultureInfo.InvariantCulture, value.GetType())), 
					ReferenceLoopHandling.Ignore => false, 
					ReferenceLoopHandling.Serialize => true, 
					_ => throw new InvalidOperationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Unexpected ReferenceLoopHandling value: '{0}'", CultureInfo.InvariantCulture, base.Serializer.ReferenceLoopHandling)), 
				};
			}
			return true;
		}

		private void WriteReference(JsonWriter writer, object value)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("$ref");
			writer.WriteValue(base.Serializer.ReferenceResolver.GetReference(this, value));
			writer.WriteEndObject();
		}

		internal static bool TryConvertToString(object value, Type type, out string s)
		{
			TypeConverter converter = PlayFab.Json.Utilities.ConvertUtils.GetConverter(type);
			if (converter != null && !(converter is ComponentConverter) && converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
			{
				s = converter.ConvertToInvariantString(value);
				return true;
			}
			if (value is Type)
			{
				s = ((Type)value).AssemblyQualifiedName;
				return true;
			}
			s = null;
			return false;
		}

		private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
		{
			contract.InvokeOnSerializing(value, base.Serializer.Context);
			TryConvertToString(value, contract.UnderlyingType, out var s);
			writer.WriteValue(s);
			contract.InvokeOnSerialized(value, base.Serializer.Context);
		}

		private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContract collectionValueContract)
		{
			contract.InvokeOnSerializing(value, base.Serializer.Context);
			SerializeStack.Add(value);
			writer.WriteStartObject();
			bool? isReference = contract.IsReference;
			if ((!isReference.HasValue) ? HasFlag(base.Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Objects) : isReference.Value)
			{
				writer.WritePropertyName("$id");
				writer.WriteValue(base.Serializer.ReferenceResolver.GetReference(this, value));
			}
			if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionValueContract))
			{
				WriteTypeProperty(writer, contract.UnderlyingType);
			}
			int top = writer.Top;
			foreach (JsonProperty property in contract.Properties)
			{
				try
				{
					if (!property.Ignored && property.Readable && ShouldSerialize(property, value) && IsSpecified(property, value))
					{
						object value2 = property.ValueProvider.GetValue(value);
						JsonContract contractSafe = GetContractSafe(value2);
						WriteMemberInfoProperty(writer, value2, property, contractSafe);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(value, contract, property.PropertyName, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			writer.WriteEndObject();
			SerializeStack.RemoveAt(SerializeStack.Count - 1);
			contract.InvokeOnSerialized(value, base.Serializer.Context);
		}

		private void WriteTypeProperty(JsonWriter writer, Type type)
		{
			writer.WritePropertyName("$type");
			writer.WriteValue(PlayFab.Json.Utilities.ReflectionUtils.GetTypeName(type, base.Serializer.TypeNameAssemblyFormat, base.Serializer.Binder));
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
		{
			return (value & flag) == flag;
		}

		private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract)
		{
			if (ShouldWriteReference(value, null, contract))
			{
				WriteReference(writer, value);
			}
			else if (CheckForCircularReference(value, null, contract))
			{
				SerializeStack.Add(value);
				converter.WriteJson(writer, value, GetInternalSerializer());
				SerializeStack.RemoveAt(SerializeStack.Count - 1);
			}
		}

		private void SerializeList(JsonWriter writer, PlayFab.Json.Utilities.IWrappedCollection values, JsonArrayContract contract, JsonProperty member, JsonContract collectionValueContract)
		{
			contract.InvokeOnSerializing(values.UnderlyingCollection, base.Serializer.Context);
			SerializeStack.Add(values.UnderlyingCollection);
			bool? isReference = contract.IsReference;
			bool flag = ((!isReference.HasValue) ? HasFlag(base.Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Arrays) : isReference.Value);
			bool flag2 = ShouldWriteType(TypeNameHandling.Arrays, contract, member, collectionValueContract);
			if (flag || flag2)
			{
				writer.WriteStartObject();
				if (flag)
				{
					writer.WritePropertyName("$id");
					writer.WriteValue(base.Serializer.ReferenceResolver.GetReference(this, values.UnderlyingCollection));
				}
				if (flag2)
				{
					WriteTypeProperty(writer, values.UnderlyingCollection.GetType());
				}
				writer.WritePropertyName("$values");
			}
			JsonContract collectionValueContract2 = base.Serializer.ContractResolver.ResolveContract(contract.CollectionItemType ?? typeof(object));
			writer.WriteStartArray();
			int top = writer.Top;
			int num = 0;
			foreach (object value in values)
			{
				try
				{
					JsonContract contractSafe = GetContractSafe(value);
					if (ShouldWriteReference(value, null, contractSafe))
					{
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(value, null, contract))
					{
						SerializeValue(writer, value, contractSafe, null, collectionValueContract2);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(values.UnderlyingCollection, contract, num, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
				finally
				{
					num++;
				}
			}
			writer.WriteEndArray();
			if (flag || flag2)
			{
				writer.WriteEndObject();
			}
			SerializeStack.RemoveAt(SerializeStack.Count - 1);
			contract.InvokeOnSerialized(values.UnderlyingCollection, base.Serializer.Context);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContract collectionContract)
		{
			contract.InvokeOnSerializing(values, base.Serializer.Context);
			_serializeStack.Add(values);
			bool flag = WriteStartArray(writer, values, contract, member, collectionContract);
			SerializeMultidimensionalArray(writer, values, contract, member, writer.Top, new int[0]);
			if (flag)
			{
				writer.WriteEndObject();
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			contract.InvokeOnSerialized(values, base.Serializer.Context);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, int[] indices)
		{
			int num = indices.Length;
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			writer.WriteStartArray();
			for (int j = 0; j < values.GetLength(num); j++)
			{
				array[num] = j;
				if (array.Length == values.Rank)
				{
					object value = values.GetValue(array);
					try
					{
						JsonContract contractSafe = GetContractSafe(value);
						if (ShouldWriteReference(value, member, contractSafe))
						{
							WriteReference(writer, value);
						}
						else if (CheckForCircularReference(value, null, contractSafe))
						{
							SerializeValue(writer, value, contractSafe, member, contract);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(values, contract, j, ex))
						{
							HandleError(writer, initialDepth + 1);
							continue;
						}
						throw;
					}
				}
				else
				{
					SerializeMultidimensionalArray(writer, values, contract, member, initialDepth + 1, array);
				}
			}
			writer.WriteEndArray();
		}

		private string GetReference(JsonWriter writer, object value)
		{
			try
			{
				return base.Serializer.ReferenceResolver.GetReference(this, value);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error writing object reference for '{0}'.", CultureInfo.InvariantCulture, value.GetType()), innerException);
			}
		}

		private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContract containerContract)
		{
			bool? isReference = contract.IsReference;
			bool flag = ((!isReference.HasValue) ? HasFlag(base.Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Arrays) : isReference.Value);
			bool flag2 = ShouldWriteType(TypeNameHandling.Arrays, contract, member, containerContract);
			bool flag3 = flag || flag2;
			if (flag3)
			{
				writer.WriteStartObject();
				if (flag)
				{
					writer.WritePropertyName("$id");
					writer.WriteValue(GetReference(writer, values));
				}
				if (flag2)
				{
					WriteTypeProperty(writer, values.GetType());
				}
				writer.WritePropertyName("$values");
			}
			return flag3;
		}

		[SecuritySafeCritical]
		private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract)
		{
			contract.InvokeOnSerializing(value, base.Serializer.Context);
			SerializeStack.Add(value);
			writer.WriteStartObject();
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new FormatterConverter());
			value.GetObjectData(serializationInfo, base.Serializer.Context);
			SerializationInfoEnumerator enumerator = serializationInfo.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				writer.WritePropertyName(current.Name);
				SerializeValue(writer, current.Value, GetContractSafe(current.Value), null, null);
			}
			writer.WriteEndObject();
			SerializeStack.RemoveAt(SerializeStack.Count - 1);
			contract.InvokeOnSerialized(value, base.Serializer.Context);
		}

		private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContract collectionValueContract)
		{
			TypeNameHandling? typeNameHandling = member?.TypeNameHandling;
			if (HasFlag((!typeNameHandling.HasValue) ? base.Serializer.TypeNameHandling : typeNameHandling.Value, typeNameHandlingFlag))
			{
				return true;
			}
			if (member != null)
			{
				TypeNameHandling? typeNameHandling2 = member.TypeNameHandling;
				if (((!typeNameHandling2.HasValue) ? base.Serializer.TypeNameHandling : typeNameHandling2.Value) == TypeNameHandling.Auto && contract.UnderlyingType != member.PropertyType)
				{
					JsonContract jsonContract = base.Serializer.ContractResolver.ResolveContract(member.PropertyType);
					if (contract.UnderlyingType != jsonContract.CreatedType)
					{
						return true;
					}
				}
			}
			else if (collectionValueContract != null && base.Serializer.TypeNameHandling == TypeNameHandling.Auto && contract.UnderlyingType != collectionValueContract.UnderlyingType)
			{
				return true;
			}
			return false;
		}

		private void SerializeDictionary(JsonWriter writer, PlayFab.Json.Utilities.IWrappedDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContract collectionValueContract)
		{
			contract.InvokeOnSerializing(values.UnderlyingDictionary, base.Serializer.Context);
			SerializeStack.Add(values.UnderlyingDictionary);
			writer.WriteStartObject();
			bool? isReference = contract.IsReference;
			if ((!isReference.HasValue) ? HasFlag(base.Serializer.PreserveReferencesHandling, PreserveReferencesHandling.Objects) : isReference.Value)
			{
				writer.WritePropertyName("$id");
				writer.WriteValue(base.Serializer.ReferenceResolver.GetReference(this, values.UnderlyingDictionary));
			}
			if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionValueContract))
			{
				WriteTypeProperty(writer, values.UnderlyingDictionary.GetType());
			}
			JsonContract collectionValueContract2 = base.Serializer.ContractResolver.ResolveContract(contract.DictionaryValueType ?? typeof(object));
			int top = writer.Top;
			foreach (DictionaryEntry value2 in values)
			{
				string propertyName = GetPropertyName(value2);
				propertyName = ((contract.PropertyNameResolver == null) ? propertyName : contract.PropertyNameResolver(propertyName));
				try
				{
					object value = value2.Value;
					JsonContract contractSafe = GetContractSafe(value);
					if (ShouldWriteReference(value, null, contractSafe))
					{
						writer.WritePropertyName(propertyName);
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(value, null, contract))
					{
						writer.WritePropertyName(propertyName);
						SerializeValue(writer, value, contractSafe, null, collectionValueContract2);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(values.UnderlyingDictionary, contract, propertyName, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			writer.WriteEndObject();
			SerializeStack.RemoveAt(SerializeStack.Count - 1);
			contract.InvokeOnSerialized(values.UnderlyingDictionary, base.Serializer.Context);
		}

		private string GetPropertyName(DictionaryEntry entry)
		{
			if (entry.Key is IConvertible)
			{
				return Convert.ToString(entry.Key, CultureInfo.InvariantCulture);
			}
			if (TryConvertToString(entry.Key, entry.Key.GetType(), out var s))
			{
				return s;
			}
			return entry.Key.ToString();
		}

		private void HandleError(JsonWriter writer, int initialDepth)
		{
			ClearErrorContext();
			while (writer.Top > initialDepth)
			{
				writer.WriteEnd();
			}
		}

		private bool ShouldSerialize(JsonProperty property, object target)
		{
			if (property.ShouldSerialize == null)
			{
				return true;
			}
			return property.ShouldSerialize(target);
		}

		private bool IsSpecified(JsonProperty property, object target)
		{
			if (property.GetIsSpecified == null)
			{
				return true;
			}
			return property.GetIsSpecified(target);
		}
	}
	internal class JsonSerializerProxy : JsonSerializer
	{
		private readonly JsonSerializerInternalReader _serializerReader;

		private readonly JsonSerializerInternalWriter _serializerWriter;

		private readonly JsonSerializer _serializer;

		public override IReferenceResolver ReferenceResolver
		{
			get
			{
				return _serializer.ReferenceResolver;
			}
			set
			{
				_serializer.ReferenceResolver = value;
			}
		}

		public override JsonConverterCollection Converters => _serializer.Converters;

		public override DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _serializer.DefaultValueHandling;
			}
			set
			{
				_serializer.DefaultValueHandling = value;
			}
		}

		public override IContractResolver ContractResolver
		{
			get
			{
				return _serializer.ContractResolver;
			}
			set
			{
				_serializer.ContractResolver = value;
			}
		}

		public override MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _serializer.MissingMemberHandling;
			}
			set
			{
				_serializer.MissingMemberHandling = value;
			}
		}

		public override NullValueHandling NullValueHandling
		{
			get
			{
				return _serializer.NullValueHandling;
			}
			set
			{
				_serializer.NullValueHandling = value;
			}
		}

		public override ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _serializer.ObjectCreationHandling;
			}
			set
			{
				_serializer.ObjectCreationHandling = value;
			}
		}

		public override ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _serializer.ReferenceLoopHandling;
			}
			set
			{
				_serializer.ReferenceLoopHandling = value;
			}
		}

		public override PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _serializer.PreserveReferencesHandling;
			}
			set
			{
				_serializer.PreserveReferencesHandling = value;
			}
		}

		public override TypeNameHandling TypeNameHandling
		{
			get
			{
				return _serializer.TypeNameHandling;
			}
			set
			{
				_serializer.TypeNameHandling = value;
			}
		}

		public override FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _serializer.TypeNameAssemblyFormat;
			}
			set
			{
				_serializer.TypeNameAssemblyFormat = value;
			}
		}

		public override ConstructorHandling ConstructorHandling
		{
			get
			{
				return _serializer.ConstructorHandling;
			}
			set
			{
				_serializer.ConstructorHandling = value;
			}
		}

		public override SerializationBinder Binder
		{
			get
			{
				return _serializer.Binder;
			}
			set
			{
				_serializer.Binder = value;
			}
		}

		public override StreamingContext Context
		{
			get
			{
				return _serializer.Context;
			}
			set
			{
				_serializer.Context = value;
			}
		}

		public override event EventHandler<ErrorEventArgs> Error
		{
			add
			{
				_serializer.Error += value;
			}
			remove
			{
				_serializer.Error -= value;
			}
		}

		public JsonSerializerProxy(JsonSerializerInternalReader serializerReader)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(serializerReader, "serializerReader");
			_serializerReader = serializerReader;
			_serializer = serializerReader.Serializer;
		}

		public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(serializerWriter, "serializerWriter");
			_serializerWriter = serializerWriter;
			_serializer = serializerWriter.Serializer;
		}

		internal JsonSerializerInternalBase GetInternalSerializer()
		{
			if (_serializerReader != null)
			{
				return _serializerReader;
			}
			return _serializerWriter;
		}

		internal override object DeserializeInternal(JsonReader reader, Type objectType)
		{
			if (_serializerReader != null)
			{
				return _serializerReader.Deserialize(reader, objectType);
			}
			return _serializer.Deserialize(reader, objectType);
		}

		internal override void PopulateInternal(JsonReader reader, object target)
		{
			if (_serializerReader != null)
			{
				_serializerReader.Populate(reader, target);
			}
			else
			{
				_serializer.Populate(reader, target);
			}
		}

		internal override void SerializeInternal(JsonWriter jsonWriter, object value)
		{
			if (_serializerWriter != null)
			{
				_serializerWriter.Serialize(jsonWriter, value);
			}
			else
			{
				_serializer.Serialize(jsonWriter, value);
			}
		}
	}
	public class JsonStringContract : JsonContract
	{
		public JsonStringContract(Type underlyingType)
			: base(underlyingType)
		{
		}
	}
	internal interface IMetadataTypeAttribute
	{
		Type MetadataClassType { get; }
	}
	internal static class JsonTypeReflector
	{
		public const string IdPropertyName = "$id";

		public const string RefPropertyName = "$ref";

		public const string TypePropertyName = "$type";

		public const string ValuePropertyName = "$value";

		public const string ArrayValuesPropertyName = "$values";

		public const string ShouldSerializePrefix = "ShouldSerialize";

		public const string SpecifiedPostfix = "Specified";

		private static readonly PlayFab.Json.Utilities.ThreadSafeStore<ICustomAttributeProvider, Type> JsonConverterTypeCache = new PlayFab.Json.Utilities.ThreadSafeStore<ICustomAttributeProvider, Type>(GetJsonConverterTypeFromAttribute);

		private static readonly PlayFab.Json.Utilities.ThreadSafeStore<Type, Type> AssociatedMetadataTypesCache = new PlayFab.Json.Utilities.ThreadSafeStore<Type, Type>(GetAssociateMetadataTypeFromAttribute);

		private const string MetadataTypeAttributeTypeName = "System.ComponentModel.DataAnnotations.MetadataTypeAttribute, System.ComponentModel.DataAnnotations, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

		private static Type _cachedMetadataTypeAttributeType;

		private static bool? _dynamicCodeGeneration;

		public static bool DynamicCodeGeneration
		{
			get
			{
				bool? dynamicCodeGeneration = _dynamicCodeGeneration;
				if (!dynamicCodeGeneration.HasValue)
				{
					_dynamicCodeGeneration = false;
				}
				return _dynamicCodeGeneration.Value;
			}
		}

		public static PlayFab.Json.Utilities.ReflectionDelegateFactory ReflectionDelegateFactory => PlayFab.Json.Utilities.LateBoundReflectionDelegateFactory.Instance;

		public static JsonContainerAttribute GetJsonContainerAttribute(Type type)
		{
			return CachedAttributeGetter<JsonContainerAttribute>.GetAttribute(type);
		}

		public static JsonObjectAttribute GetJsonObjectAttribute(Type type)
		{
			return GetJsonContainerAttribute(type) as JsonObjectAttribute;
		}

		public static JsonArrayAttribute GetJsonArrayAttribute(Type type)
		{
			return GetJsonContainerAttribute(type) as JsonArrayAttribute;
		}

		public static MemberSerialization GetObjectMemberSerialization(Type objectType)
		{
			return GetJsonObjectAttribute(objectType)?.MemberSerialization ?? MemberSerialization.OptOut;
		}

		private static Type GetJsonConverterType(ICustomAttributeProvider attributeProvider)
		{
			return JsonConverterTypeCache.Get(attributeProvider);
		}

		private static Type GetJsonConverterTypeFromAttribute(ICustomAttributeProvider attributeProvider)
		{
			return GetAttribute<JsonConverterAttribute>(attributeProvider)?.ConverterType;
		}

		public static JsonConverter GetJsonConverter(ICustomAttributeProvider attributeProvider, Type targetConvertedType)
		{
			Type jsonConverterType = GetJsonConverterType(attributeProvider);
			if (jsonConverterType != null)
			{
				JsonConverter jsonConverter = JsonConverterAttribute.CreateJsonConverterInstance(jsonConverterType);
				if (!jsonConverter.CanConvert(targetConvertedType))
				{
					throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("JsonConverter {0} on {1} is not compatible with member type {2}.", CultureInfo.InvariantCulture, jsonConverter.GetType().Name, attributeProvider, targetConvertedType.Name));
				}
				return jsonConverter;
			}
			return null;
		}

		public static TypeConverter GetTypeConverter(Type type)
		{
			return TypeDescriptor.GetConverter(type);
		}

		private static Type GetAssociatedMetadataType(Type type)
		{
			return AssociatedMetadataTypesCache.Get(type);
		}

		private static Type GetAssociateMetadataTypeFromAttribute(Type type)
		{
			Type metadataTypeAttributeType = GetMetadataTypeAttributeType();
			if (metadataTypeAttributeType == null)
			{
				return null;
			}
			object obj = System.Linq.Enumerable.SingleOrDefault(type.GetCustomAttributes(metadataTypeAttributeType, inherit: true));
			if (obj == null)
			{
				return null;
			}
			IMetadataTypeAttribute metadataTypeAttribute = new LateBoundMetadataTypeAttribute(obj);
			return metadataTypeAttribute.MetadataClassType;
		}

		private static Type GetMetadataTypeAttributeType()
		{
			if (_cachedMetadataTypeAttributeType == null)
			{
				Type type = Type.GetType("System.ComponentModel.DataAnnotations.MetadataTypeAttribute, System.ComponentModel.DataAnnotations, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35");
				if (type == null)
				{
					return null;
				}
				_cachedMetadataTypeAttributeType = type;
			}
			return _cachedMetadataTypeAttributeType;
		}

		private static T GetAttribute<T>(Type type) where T : Attribute
		{
			Type associatedMetadataType = GetAssociatedMetadataType(type);
			T attribute;
			if (associatedMetadataType != null)
			{
				attribute = PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<T>(associatedMetadataType, inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
			attribute = PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<T>(type, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type attributeProvider in interfaces)
			{
				attribute = PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<T>(attributeProvider, inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
			return (T)null;
		}

		private static T GetAttribute<T>(MemberInfo memberInfo) where T : Attribute
		{
			Type associatedMetadataType = GetAssociatedMetadataType(memberInfo.DeclaringType);
			T attribute;
			if (associatedMetadataType != null)
			{
				MemberInfo memberInfoFromType = PlayFab.Json.Utilities.ReflectionUtils.GetMemberInfoFromType(associatedMetadataType, memberInfo);
				if (memberInfoFromType != null)
				{
					attribute = PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<T>(memberInfoFromType, inherit: true);
					if (attribute != null)
					{
						return attribute;
					}
				}
			}
			attribute = PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<T>(memberInfo, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			Type[] interfaces = memberInfo.DeclaringType.GetInterfaces();
			foreach (Type targetType in interfaces)
			{
				MemberInfo memberInfoFromType2 = PlayFab.Json.Utilities.ReflectionUtils.GetMemberInfoFromType(targetType, memberInfo);
				if (memberInfoFromType2 != null)
				{
					attribute = PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<T>(memberInfoFromType2, inherit: true);
					if (attribute != null)
					{
						return attribute;
					}
				}
			}
			return (T)null;
		}

		public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider) where T : Attribute
		{
			if (attributeProvider is Type type)
			{
				return GetAttribute<T>(type);
			}
			if (attributeProvider is MemberInfo memberInfo)
			{
				return GetAttribute<T>(memberInfo);
			}
			return PlayFab.Json.Utilities.ReflectionUtils.GetAttribute<T>(attributeProvider, inherit: true);
		}
	}
	internal class LateBoundMetadataTypeAttribute : IMetadataTypeAttribute
	{
		private static PropertyInfo _metadataClassTypeProperty;

		private readonly object _attribute;

		public Type MetadataClassType
		{
			get
			{
				if (_metadataClassTypeProperty == null)
				{
					_metadataClassTypeProperty = _attribute.GetType().GetProperty("MetadataClassType");
				}
				return (Type)PlayFab.Json.Utilities.ReflectionUtils.GetMemberValue(_metadataClassTypeProperty, _attribute);
			}
		}

		public LateBoundMetadataTypeAttribute(object attribute)
		{
			_attribute = attribute;
		}
	}
	public delegate object ObjectConstructor<T>(params object[] args);
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	public sealed class OnErrorAttribute : Attribute
	{
	}
	public class ReflectionValueProvider : IValueProvider
	{
		private readonly MemberInfo _memberInfo;

		public ReflectionValueProvider(MemberInfo memberInfo)
		{
			PlayFab.Json.Utilities.ValidationUtils.ArgumentNotNull(memberInfo, "memberInfo");
			_memberInfo = memberInfo;
		}

		public void SetValue(object target, object value)
		{
			try
			{
				PlayFab.Json.Utilities.ReflectionUtils.SetMemberValue(_memberInfo, target, value);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error setting value to '{0}' on '{1}'.", CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}

		public object GetValue(object target)
		{
			try
			{
				return PlayFab.Json.Utilities.ReflectionUtils.GetMemberValue(_memberInfo, target);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException(PlayFab.Json.Utilities.StringUtils.FormatWith("Error getting value from '{0}' on '{1}'.", CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}
	}
}
namespace System.Runtime.Serialization
{
	[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
	public sealed class EnumMemberAttribute : Attribute
	{
		private string value;

		public string Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}
	}
}
namespace PlayFab.Json
{
	[Flags]
	public enum TypeNameHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		Auto = 4,
		All = 3
	}
}
namespace PlayFab.Json.Utilities
{
	internal class Base64Encoder
	{
		private const int Base64LineSize = 76;

		private const int LineSizeInBytes = 57;

		private readonly char[] _charsLine = new char[76];

		private readonly TextWriter _writer;

		private byte[] _leftOverBytes;

		private int _leftOverBytesCount;

		public Base64Encoder(TextWriter writer)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = writer;
		}

		public void Encode(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > buffer.Length - index)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (_leftOverBytesCount > 0)
			{
				int leftOverBytesCount = _leftOverBytesCount;
				while (leftOverBytesCount < 3 && count > 0)
				{
					_leftOverBytes[leftOverBytesCount++] = buffer[index++];
					count--;
				}
				if (count == 0 && leftOverBytesCount < 3)
				{
					_leftOverBytesCount = leftOverBytesCount;
					return;
				}
				int count2 = Convert.ToBase64CharArray(_leftOverBytes, 0, 3, _charsLine, 0);
				WriteChars(_charsLine, 0, count2);
			}
			_leftOverBytesCount = count % 3;
			if (_leftOverBytesCount > 0)
			{
				count -= _leftOverBytesCount;
				if (_leftOverBytes == null)
				{
					_leftOverBytes = new byte[3];
				}
				for (int i = 0; i < _leftOverBytesCount; i++)
				{
					_leftOverBytes[i] = buffer[index + count + i];
				}
			}
			int num = index + count;
			int num2 = 57;
			while (index < num)
			{
				if (index + num2 > num)
				{
					num2 = num - index;
				}
				int count3 = Convert.ToBase64CharArray(buffer, index, num2, _charsLine, 0);
				WriteChars(_charsLine, 0, count3);
				index += num2;
			}
		}

		public void Flush()
		{
			if (_leftOverBytesCount > 0)
			{
				int count = Convert.ToBase64CharArray(_leftOverBytes, 0, _leftOverBytesCount, _charsLine, 0);
				WriteChars(_charsLine, 0, count);
				_leftOverBytesCount = 0;
			}
		}

		private void WriteChars(char[] chars, int index, int count)
		{
			_writer.Write(chars, index, count);
		}
	}
	internal class BidirectionalDictionary<TFirst, TSecond>
	{
		private readonly IDictionary<TFirst, TSecond> _firstToSecond;

		private readonly IDictionary<TSecond, TFirst> _secondToFirst;

		public BidirectionalDictionary()
			: this((IEqualityComparer<TFirst>)EqualityComparer<TFirst>.Default, (IEqualityComparer<TSecond>)EqualityComparer<TSecond>.Default)
		{
		}

		public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer)
		{
			_firstToSecond = new Dictionary<TFirst, TSecond>(firstEqualityComparer);
			_secondToFirst = new Dictionary<TSecond, TFirst>(secondEqualityComparer);
		}

		public void Add(TFirst first, TSecond second)
		{
			if (_firstToSecond.ContainsKey(first) || _secondToFirst.ContainsKey(second))
			{
				throw new ArgumentException("Duplicate first or second");
			}
			_firstToSecond.Add(first, second);
			_secondToFirst.Add(second, first);
		}

		public bool TryGetByFirst(TFirst first, out TSecond second)
		{
			return _firstToSecond.TryGetValue(first, out second);
		}

		public bool TryGetBySecond(TSecond second, out TFirst first)
		{
			return _secondToFirst.TryGetValue(second, out first);
		}
	}
	internal static class CollectionUtils
	{
		public static IEnumerable<T> CastValid<T>(this IEnumerable enumerable)
		{
			ValidationUtils.ArgumentNotNull(enumerable, "enumerable");
			return System.Linq.Enumerable.Cast<T>(System.Linq.Enumerable.Where(System.Linq.Enumerable.Cast<object>(enumerable), (object o) => o is T));
		}

		public static List<T> CreateList<T>(params T[] values)
		{
			return new List<T>(values);
		}

		public static bool IsNullOrEmpty(ICollection collection)
		{
			if (collection != null)
			{
				return collection.Count == 0;
			}
			return true;
		}

		public static bool IsNullOrEmpty<T>(ICollection<T> collection)
		{
			if (collection != null)
			{
				return collection.Count == 0;
			}
			return true;
		}

		public static bool IsNullOrEmptyOrDefault<T>(IList<T> list)
		{
			if (IsNullOrEmpty(list))
			{
				return true;
			}
			return ReflectionUtils.ItemsUnitializedValue(list);
		}

		public static IList<T> Slice<T>(IList<T> list, int? start, int? end)
		{
			return Slice(list, start, end, null);
		}

		public static IList<T> Slice<T>(IList<T> list, int? start, int? end, int? step)
		{
			if (list == null)
			{
				throw new ArgumentNullException("list");
			}
			if (step.GetValueOrDefault() == 0 && step.HasValue)
			{
				throw new ArgumentException("Step cannot be zero.", "step");
			}
			List<T> list2 = new List<T>();
			if (list.Count == 0)
			{
				return list2;
			}
			int num = ((!step.HasValue) ? 1 : step.Value);
			int num2 = (start.HasValue ? start.Value : 0);
			int num3 = ((!end.HasValue) ? list.Count : end.Value);
			num2 = ((num2 >= 0) ? num2 : (list.Count + num2));
			num3 = ((num3 >= 0) ? num3 : (list.Count + num3));
			num2 = Math.Max(num2, 0);
			num3 = Math.Min(num3, list.Count - 1);
			for (int i = num2; i < num3; i += num)
			{
				list2.Add(list[i]);
			}
			return list2;
		}

		public static Dictionary<K, List<V>> GroupBy<K, V>(ICollection<V> source, Func<V, K> keySelector)
		{
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			Dictionary<K, List<V>> dictionary = new Dictionary<K, List<V>>();
			foreach (V item in source)
			{
				K key = keySelector(item);
				if (!dictionary.TryGetValue(key, out var value))
				{
					value = new List<V>();
					dictionary.Add(key, value);
				}
				value.Add(item);
			}
			return dictionary;
		}

		public static void AddRange<T>(this IList<T> initial, IEnumerable<T> collection)
		{
			if (initial == null)
			{
				throw new ArgumentNullException("initial");
			}
			if (collection == null)
			{
				return;
			}
			foreach (T item in collection)
			{
				initial.Add(item);
			}
		}

		public static void AddRange(this IList initial, IEnumerable collection)
		{
			ValidationUtils.ArgumentNotNull(initial, "initial");
			ListWrapper<object> initial2 = new ListWrapper<object>(initial);
			initial2.AddRange(System.Linq.Enumerable.Cast<object>(collection));
		}

		public static List<T> Distinct<T>(List<T> collection)
		{
			List<T> list = new List<T>();
			foreach (T item in collection)
			{
				if (!list.Contains(item))
				{
					list.Add(item);
				}
			}
			return list;
		}

		public static List<List<T>> Flatten<T>(params IList<T>[] lists)
		{
			List<List<T>> list = new List<List<T>>();
			Dictionary<int, T> currentSet = new Dictionary<int, T>();
			Recurse(new List<IList<T>>(lists), 0, currentSet, list);
			return list;
		}

		private static void Recurse<T>(IList<IList<T>> global, int current, Dictionary<int, T> currentSet, List<List<T>> flattenedResult)
		{
			IList<T> list = global[current];
			for (int i = 0; i < list.Count; i++)
			{
				currentSet[current] = list[i];
				if (current == global.Count - 1)
				{
					List<T> list2 = new List<T>();
					for (int j = 0; j < currentSet.Count; j++)
					{
						list2.Add(currentSet[j]);
					}
					flattenedResult.Add(list2);
				}
				else
				{
					Recurse(global, current + 1, currentSet, flattenedResult);
				}
			}
		}

		public static List<T> CreateList<T>(ICollection collection)
		{
			if (collection == null)
			{
				throw new ArgumentNullException("collection");
			}
			T[] array = new T[collection.Count];
			collection.CopyTo(array, 0);
			return new List<T>(array);
		}

		public static bool ListEquals<T>(IList<T> a, IList<T> b)
		{
			if (a == null || b == null)
			{
				return a == null && b == null;
			}
			if (a.Count != b.Count)
			{
				return false;
			}
			EqualityComparer<T> @default = EqualityComparer<T>.Default;
			for (int i = 0; i < a.Count; i++)
			{
				if (!@default.Equals(a[i], b[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static bool TryGetSingleItem<T>(IList<T> list, out T value)
		{
			return TryGetSingleItem(list, returnDefaultIfEmpty: false, out value);
		}

		public static bool TryGetSingleItem<T>(IList<T> list, bool returnDefaultIfEmpty, out T value)
		{
			return MiscellaneousUtils.TryAction(() => GetSingleItem(list, returnDefaultIfEmpty), out value);
		}

		public static T GetSingleItem<T>(IList<T> list)
		{
			return GetSingleItem(list, returnDefaultIfEmpty: false);
		}

		public static T GetSingleItem<T>(IList<T> list, bool returnDefaultIfEmpty)
		{
			if (list.Count == 1)
			{
				return list[0];
			}
			if (returnDefaultIfEmpty && list.Count == 0)
			{
				return default(T);
			}
			throw new Exception("Expected single {0} in list but got {1}.".FormatWith(CultureInfo.InvariantCulture, typeof(T), list.Count));
		}

		public static IList<T> Minus<T>(IList<T> list, IList<T> minus)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			List<T> list2 = new List<T>(list.Count);
			foreach (T item in list)
			{
				if (minus == null || !minus.Contains(item))
				{
					list2.Add(item);
				}
			}
			return list2;
		}

		public static IList CreateGenericList(Type listType)
		{
			ValidationUtils.ArgumentNotNull(listType, "listType");
			return (IList)ReflectionUtils.CreateGeneric(typeof(List<>), listType);
		}

		public static IDictionary CreateGenericDictionary(Type keyType, Type valueType)
		{
			ValidationUtils.ArgumentNotNull(keyType, "keyType");
			ValidationUtils.ArgumentNotNull(valueType, "valueType");
			return (IDictionary)ReflectionUtils.CreateGeneric(typeof(Dictionary<, >), keyType, valueType);
		}

		public static bool IsListType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsArray)
			{
				return true;
			}
			if (typeof(IList).IsAssignableFrom(type))
			{
				return true;
			}
			if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(IList<>)))
			{
				return true;
			}
			return false;
		}

		public static bool IsCollectionType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsArray)
			{
				return true;
			}
			if (typeof(ICollection).IsAssignableFrom(type))
			{
				return true;
			}
			if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(ICollection<>)))
			{
				return true;
			}
			return false;
		}

		public static bool IsDictionaryType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (typeof(IDictionary).IsAssignableFrom(type))
			{
				return true;
			}
			if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(IDictionary<, >)))
			{
				return true;
			}
			return false;
		}

		public static IWrappedCollection CreateCollectionWrapper(object list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			if (ReflectionUtils.ImplementsGenericDefinition(list.GetType(), typeof(ICollection<>), out var collectionDefinition))
			{
				Type collectionItemType = ReflectionUtils.GetCollectionItemType(collectionDefinition);
				Func<Type, IList<object>, object> instanceCreator = delegate(Type t, IList<object> a)
				{
					ConstructorInfo constructor = t.GetConstructor(new Type[1] { collectionDefinition });
					return constructor.Invoke(new object[1] { list });
				};
				return (IWrappedCollection)ReflectionUtils.CreateGeneric(typeof(CollectionWrapper<>), new Type[1] { collectionItemType }, instanceCreator, list);
			}
			if (list is IList)
			{
				return new CollectionWrapper<object>((IList)list);
			}
			throw new Exception("Can not create ListWrapper for type {0}.".FormatWith(CultureInfo.InvariantCulture, list.GetType()));
		}

		public static IWrappedList CreateListWrapper(object list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			if (ReflectionUtils.ImplementsGenericDefinition(list.GetType(), typeof(IList<>), out var listDefinition))
			{
				Type collectionItemType = ReflectionUtils.GetCollectionItemType(listDefinition);
				Func<Type, IList<object>, object> instanceCreator = delegate(Type t, IList<object> a)
				{
					ConstructorInfo constructor = t.GetConstructor(new Type[1] { listDefinition });
					return constructor.Invoke(new object[1] { list });
				};
				return (IWrappedList)ReflectionUtils.CreateGeneric(typeof(ListWrapper<>), new Type[1] { collectionItemType }, instanceCreator, list);
			}
			if (list is IList)
			{
				return new ListWrapper<object>((IList)list);
			}
			throw new Exception("Can not create ListWrapper for type {0}.".FormatWith(CultureInfo.InvariantCulture, list.GetType()));
		}

		public static IWrappedDictionary CreateDictionaryWrapper(object dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			if (ReflectionUtils.ImplementsGenericDefinition(dictionary.GetType(), typeof(IDictionary<, >), out var dictionaryDefinition))
			{
				Type dictionaryKeyType = ReflectionUtils.GetDictionaryKeyType(dictionaryDefinition);
				Type dictionaryValueType = ReflectionUtils.GetDictionaryValueType(dictionaryDefinition);
				Func<Type, IList<object>, object> instanceCreator = delegate(Type t, IList<object> a)
				{
					ConstructorInfo constructor = t.GetConstructor(new Type[1] { dictionaryDefinition });
					return constructor.Invoke(new object[1] { dictionary });
				};
				return (IWrappedDictionary)ReflectionUtils.CreateGeneric(typeof(DictionaryWrapper<, >), new Type[2] { dictionaryKeyType, dictionaryValueType }, instanceCreator, dictionary);
			}
			if (dictionary is IDictionary)
			{
				return new DictionaryWrapper<object, object>((IDictionary)dictionary);
			}
			throw new Exception("Can not create DictionaryWrapper for type {0}.".FormatWith(CultureInfo.InvariantCulture, dictionary.GetType()));
		}

		public static object CreateAndPopulateList(Type listType, Action<IList, bool> populateList)
		{
			ValidationUtils.ArgumentNotNull(listType, "listType");
			ValidationUtils.ArgumentNotNull(populateList, "populateList");
			bool flag = false;
			IList list;
			Type implementingType;
			if (listType.IsArray)
			{
				list = new List<object>();
				flag = true;
			}
			else if (ReflectionUtils.InheritsGenericDefinition(listType, typeof(ReadOnlyCollection<>), out implementingType))
			{
				Type type = implementingType.GetGenericArguments()[0];
				Type type2 = ReflectionUtils.MakeGenericType(typeof(IEnumerable<>), type);
				bool flag2 = false;
				ConstructorInfo[] constructors = listType.GetConstructors();
				foreach (ConstructorInfo constructorInfo in constructors)
				{
					IList<ParameterInfo> parameters = constructorInfo.GetParameters();
					if (parameters.Count == 1 && type2.IsAssignableFrom(parameters[0].ParameterType))
					{
						flag2 = true;
						break;
					}
				}
				if (!flag2)
				{
					throw new Exception("Read-only type {0} does not have a public constructor that takes a type that implements {1}.".FormatWith(CultureInfo.InvariantCulture, listType, type2));
				}
				list = CreateGenericList(type);
				flag = true;
			}
			else if (typeof(IList).IsAssignableFrom(listType))
			{
				list = (ReflectionUtils.IsInstantiatableType(listType) ? ((IList)Activator.CreateInstance(listType)) : ((listType != typeof(IList)) ? null : new List<object>()));
			}
			else if (ReflectionUtils.ImplementsGenericDefinition(listType, typeof(ICollection<>)))
			{
				list = ((!ReflectionUtils.IsInstantiatableType(listType)) ? null : CreateCollectionWrapper(Activator.CreateInstance(listType)));
			}
			else if (listType == typeof(BitArray))
			{
				list = new List<object>();
				flag = true;
			}
			else
			{
				list = null;
			}
			if (list == null)
			{
				throw new Exception("Cannot create and populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, listType));
			}
			populateList(list, flag);
			if (flag)
			{
				if (listType.IsArray)
				{
					list = ((listType.GetArrayRank() <= 1) ? ToArray(((List<object>)list).ToArray(), ReflectionUtils.GetCollectionItemType(listType)) : ToMultidimensionalArray(list, ReflectionUtils.GetCollectionItemType(listType), listType.GetArrayRank()));
				}
				else if (ReflectionUtils.InheritsGenericDefinition(listType, typeof(ReadOnlyCollection<>)))
				{
					list = (IList)ReflectionUtils.CreateInstance(listType, list);
				}
				else if (listType == typeof(BitArray))
				{
					BitArray bitArray = new BitArray(list.Count);
					for (int j = 0; j < list.Count; j++)
					{
						bitArray[j] = (bool)list[j];
					}
					return bitArray;
				}
			}
			else if (list is IWrappedCollection)
			{
				return ((IWrappedCollection)list).UnderlyingCollection;
			}
			return list;
		}

		public static Array ToArray(Array initial, Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			Array array = Array.CreateInstance(type, initial.Length);
			Array.Copy(initial, 0, array, 0, initial.Length);
			return array;
		}

		private static IList<int> GetDimensions(IList values)
		{
			IList<int> list = new List<int>();
			IList list2 = values;
			while (true)
			{
				list.Add(list2.Count);
				if (list2.Count == 0)
				{
					break;
				}
				object obj = list2[0];
				if (obj is IList)
				{
					list2 = (IList)obj;
					continue;
				}
				break;
			}
			return list;
		}

		public static Array ToMultidimensionalArray(IList values, Type type, int rank)
		{
			IList<int> dimensions = GetDimensions(values);
			while (dimensions.Count < rank)
			{
				dimensions.Add(0);
			}
			Array array = Array.CreateInstance(type, System.Linq.Enumerable.ToArray(dimensions));
			CopyFromJaggedToMultidimensionalArray(values, array, new int[0]);
			return array;
		}

		private static object JaggedArrayGetValue(IList values, int[] indices)
		{
			IList list = values;
			for (int i = 0; i < indices.Length; i++)
			{
				int index = indices[i];
				if (i == indices.Length - 1)
				{
					return list[index];
				}
				list = (IList)list[index];
			}
			return list;
		}

		private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, int[] indices)
		{
			int num = indices.Length;
			if (num == multidimensionalArray.Rank)
			{
				multidimensionalArray.SetValue(JaggedArrayGetValue(values, indices), indices);
				return;
			}
			int length = multidimensionalArray.GetLength(num);
			IList list = (IList)JaggedArrayGetValue(values, indices);
			int count = list.Count;
			if (count != length)
			{
				throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");
			}
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			for (int j = 0; j < multidimensionalArray.GetLength(num); j++)
			{
				array[num] = j;
				CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, array);
			}
		}

		public static bool AddDistinct<T>(this IList<T> list, T value)
		{
			return list.AddDistinct(value, EqualityComparer<T>.Default);
		}

		public static bool AddDistinct<T>(this IList<T> list, T value, IEqualityComparer<T> comparer)
		{
			if (list.ContainsValue(value, comparer))
			{
				return false;
			}
			list.Add(value);
			return true;
		}

		public static bool ContainsValue<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TSource>.Default;
			}
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, value))
				{
					return true;
				}
			}
			return false;
		}

		public static bool AddRangeDistinct<T>(this IList<T> list, IEnumerable<T> values)
		{
			return list.AddRangeDistinct(values, EqualityComparer<T>.Default);
		}

		public static bool AddRangeDistinct<T>(this IList<T> list, IEnumerable<T> values, IEqualityComparer<T> comparer)
		{
			bool result = true;
			foreach (T value in values)
			{
				if (!list.AddDistinct(value, comparer))
				{
					result = false;
				}
			}
			return result;
		}

		public static int IndexOf<T>(this IEnumerable<T> collection, Func<T, bool> predicate)
		{
			int num = 0;
			foreach (T item in collection)
			{
				if (predicate(item))
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		public static int IndexOf<TSource>(this IEnumerable<TSource> list, TSource value) where TSource : IEquatable<TSource>
		{
			return list.IndexOf(value, EqualityComparer<TSource>.Default);
		}

		public static int IndexOf<TSource>(this IEnumerable<TSource> list, TSource value, IEqualityComparer<TSource> comparer)
		{
			int num = 0;
			foreach (TSource item in list)
			{
				if (comparer.Equals(item, value))
				{
					return num;
				}
				num++;
			}
			return -1;
		}
	}
	internal interface IWrappedCollection : IList, IEnumerable, ICollection
	{
		object UnderlyingCollection { get; }
	}
	internal class CollectionWrapper<T> : ICollection<T>, IWrappedCollection, IEnumerable, IEnumerable<T>, IList, ICollection
	{
		private readonly IList _list;

		private readonly ICollection<T> _genericCollection;

		private object _syncRoot;

		bool IList.IsFixedSize
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsFixedSize;
			}
		}

		object IList.this[int index]
		{
			get
			{
				if (_genericCollection != null)
				{
					throw new Exception("Wrapped ICollection<T> does not support indexer.");
				}
				return _list[index];
			}
			set
			{
				if (_genericCollection != null)
				{
					throw new Exception("Wrapped ICollection<T> does not support indexer.");
				}
				VerifyValueType(value);
				_list[index] = (T)value;
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public virtual int Count
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.Count;
				}
				return _list.Count;
			}
		}

		public virtual bool IsReadOnly
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsReadOnly;
			}
		}

		public object UnderlyingCollection
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection;
				}
				return _list;
			}
		}

		public CollectionWrapper(IList list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			if (list is ICollection<T>)
			{
				_genericCollection = (ICollection<T>)list;
			}
			else
			{
				_list = list;
			}
		}

		public CollectionWrapper(ICollection<T> list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			_genericCollection = list;
		}

		public virtual void Add(T item)
		{
			if (_genericCollection != null)
			{
				_genericCollection.Add(item);
			}
			else
			{
				_list.Add(item);
			}
		}

		public virtual void Clear()
		{
			if (_genericCollection != null)
			{
				_genericCollection.Clear();
			}
			else
			{
				_list.Clear();
			}
		}

		public virtual bool Contains(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Contains(item);
			}
			return _list.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			if (_genericCollection != null)
			{
				_genericCollection.CopyTo(array, arrayIndex);
			}
			else
			{
				_list.CopyTo(array, arrayIndex);
			}
		}

		public virtual bool Remove(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Remove(item);
			}
			bool flag = _list.Contains(item);
			if (flag)
			{
				_list.Remove(item);
			}
			return flag;
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			if (_genericCollection != null)
			{
				return _genericCollection.GetEnumerator();
			}
			return System.Linq.Enumerable.Cast<T>(_list).GetEnumerator();
		}

		public bool IsGenericCollection()
		{
			return _genericCollection != null;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			if (_genericCollection != null)
			{
				return _genericCollection.GetEnumerator();
			}
			return _list.GetEnumerator();
		}

		int IList.Add(object value)
		{
			VerifyValueType(value);
			Add((T)value);
			return Count - 1;
		}

		bool IList.Contains(object value)
		{
			if (IsCompatibleObject(value))
			{
				return Contains((T)value);
			}
			return false;
		}

		int IList.IndexOf(object value)
		{
			if (_genericCollection != null)
			{
				throw new Exception("Wrapped ICollection<T> does not support IndexOf.");
			}
			if (IsCompatibleObject(value))
			{
				return _list.IndexOf((T)value);
			}
			return -1;
		}

		void IList.RemoveAt(int index)
		{
			if (_genericCollection != null)
			{
				throw new Exception("Wrapped ICollection<T> does not support RemoveAt.");
			}
			_list.RemoveAt(index);
		}

		void IList.Insert(int index, object value)
		{
			if (_genericCollection != null)
			{
				throw new Exception("Wrapped ICollection<T> does not support Insert.");
			}
			VerifyValueType(value);
			_list.Insert(index, (T)value);
		}

		void IList.Remove(object value)
		{
			if (IsCompatibleObject(value))
			{
				Remove((T)value);
			}
		}

		void ICollection.CopyTo(Array array, int arrayIndex)
		{
			CopyTo((T[])array, arrayIndex);
		}

		private static void VerifyValueType(object value)
		{
			if (!IsCompatibleObject(value))
			{
				throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith(CultureInfo.InvariantCulture, value, typeof(T)), "value");
			}
		}

		private static bool IsCompatibleObject(object value)
		{
			if (!(value is T) && (value != null || (typeof(T).IsValueType && !ReflectionUtils.IsNullableType(typeof(T)))))
			{
				return false;
			}
			return true;
		}
	}
	internal static class ConvertUtils
	{
		internal struct TypeConvertKey : IEquatable<TypeConvertKey>
		{
			private readonly Type _initialType;

			private readonly Type _targetType;

			public Type InitialType => _initialType;

			public Type TargetType => _targetType;

			public TypeConvertKey(Type initialType, Type targetType)
			{
				_initialType = initialType;
				_targetType = targetType;
			}

			public override int GetHashCode()
			{
				return _initialType.GetHashCode() ^ _targetType.GetHashCode();
			}

			public override bool Equals(object obj)
			{
				if (!(obj is TypeConvertKey))
				{
					return false;
				}
				return Equals((TypeConvertKey)obj);
			}

			public bool Equals(TypeConvertKey other)
			{
				return _initialType == other._initialType && _targetType == other._targetType;
			}
		}

		private static readonly ThreadSafeStore<TypeConvertKey, Func<object, object>> CastConverters = new ThreadSafeStore<TypeConvertKey, Func<object, object>>(CreateCastConverter);

		private static Func<object, object> CreateCastConverter(TypeConvertKey t)
		{
			MethodInfo method = t.TargetType.GetMethod("op_Implicit", new Type[1] { t.InitialType });
			if (method == null)
			{
				method = t.TargetType.GetMethod("op_Explicit", new Type[1] { t.InitialType });
			}
			if (method == null)
			{
				return null;
			}
			MethodCall<object, object> call = PlayFab.Json.Serialization.JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object o) => call(null, o);
		}

		public static bool CanConvertType(Type initialType, Type targetType, bool allowTypeNameToString)
		{
			ValidationUtils.ArgumentNotNull(initialType, "initialType");
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			if (ReflectionUtils.IsNullableType(targetType))
			{
				targetType = Nullable.GetUnderlyingType(targetType);
			}
			if (targetType == initialType)
			{
				return true;
			}
			if (typeof(IConvertible).IsAssignableFrom(initialType) && typeof(IConvertible).IsAssignableFrom(targetType))
			{
				return true;
			}
			if (initialType == typeof(DateTime) && targetType == typeof(DateTimeOffset))
			{
				return true;
			}
			if (initialType == typeof(Guid) && (targetType == typeof(Guid) || targetType == typeof(string)))
			{
				return true;
			}
			if (initialType == typeof(Type) && targetType == typeof(string))
			{
				return true;
			}
			TypeConverter converter = GetConverter(initialType);
			if (converter != null && !IsComponentConverter(converter) && converter.CanConvertTo(targetType) && (allowTypeNameToString || converter.GetType() != typeof(TypeConverter)))
			{
				return true;
			}
			TypeConverter converter2 = GetConverter(targetType);
			if (converter2 != null && !IsComponentConverter(converter2) && converter2.CanConvertFrom(initialType))
			{
				return true;
			}
			if (initialType == typeof(DBNull) && ReflectionUtils.IsNullable(targetType))
			{
				return true;
			}
			return false;
		}

		private static bool IsComponentConverter(TypeConverter converter)
		{
			return converter is ComponentConverter;
		}

		public static T Convert<T>(object initialValue)
		{
			return Convert<T>(initialValue, CultureInfo.CurrentCulture);
		}

		public static T Convert<T>(object initialValue, CultureInfo culture)
		{
			return (T)Convert(initialValue, culture, typeof(T));
		}

		public static object Convert(object initialValue, CultureInfo culture, Type targetType)
		{
			if (initialValue == null)
			{
				throw new ArgumentNullException("initialValue");
			}
			if (ReflectionUtils.IsNullableType(targetType))
			{
				targetType = Nullable.GetUnderlyingType(targetType);
			}
			Type type = initialValue.GetType();
			if (targetType == type)
			{
				return initialValue;
			}
			if (initialValue is string && typeof(Type).IsAssignableFrom(targetType))
			{
				return Type.GetType((string)initialValue, throwOnError: true);
			}
			if (targetType.IsInterface || targetType.IsGenericTypeDefinition || targetType.IsAbstract)
			{
				throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith(CultureInfo.InvariantCulture, targetType), "targetType");
			}
			if (initialValue is IConvertible && typeof(IConvertible).IsAssignableFrom(targetType))
			{
				if (targetType.IsEnum)
				{
					if (initialValue is string)
					{
						return Enum.Parse(targetType, initialValue.ToString(), ignoreCase: true);
					}
					if (IsInteger(initialValue))
					{
						return Enum.ToObject(targetType, initialValue);
					}
				}
				return System.Convert.ChangeType(initialValue, targetType, culture);
			}
			if (initialValue is DateTime && targetType == typeof(DateTimeOffset))
			{
				return new DateTimeOffset((DateTime)initialValue);
			}
			if (initialValue is string)
			{
				if (targetType == typeof(Guid))
				{
					return new Guid((string)initialValue);
				}
				if (targetType == typeof(Uri))
				{
					return new Uri((string)initialValue);
				}
				if (targetType == typeof(TimeSpan))
				{
					return TimeSpan.Parse((string)initialValue);
				}
			}
			TypeConverter converter = GetConverter(type);
			if (converter != null && converter.CanConvertTo(targetType))
			{
				return converter.ConvertTo(null, culture, initialValue, targetType);
			}
			TypeConverter converter2 = GetConverter(targetType);
			if (converter2 != null && converter2.CanConvertFrom(type))
			{
				return converter2.ConvertFrom(null, culture, initialValue);
			}
			if (initialValue == DBNull.Value)
			{
				if (ReflectionUtils.IsNullable(targetType))
				{
					return EnsureTypeAssignable(null, type, targetType);
				}
				throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith(CultureInfo.InvariantCulture, type, targetType));
			}
			throw new Exception("Can not convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, type, targetType));
		}

		public static bool TryConvert<T>(object initialValue, out T convertedValue)
		{
			return TryConvert<T>(initialValue, CultureInfo.CurrentCulture, out convertedValue);
		}

		public static bool TryConvert<T>(object initialValue, CultureInfo culture, out T convertedValue)
		{
			return MiscellaneousUtils.TryAction(delegate
			{
				TryConvert(initialValue, CultureInfo.CurrentCulture, typeof(T), out var convertedValue2);
				return (T)convertedValue2;
			}, out convertedValue);
		}

		public static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, out object convertedValue)
		{
			return MiscellaneousUtils.TryAction(() => Convert(initialValue, culture, targetType), out convertedValue);
		}

		public static T ConvertOrCast<T>(object initialValue)
		{
			return ConvertOrCast<T>(initialValue, CultureInfo.CurrentCulture);
		}

		public static T ConvertOrCast<T>(object initialValue, CultureInfo culture)
		{
			return (T)ConvertOrCast(initialValue, culture, typeof(T));
		}

		public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
		{
			if (targetType == typeof(object))
			{
				return initialValue;
			}
			if (initialValue == null && ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			if (TryConvert(initialValue, culture, targetType, out var convertedValue))
			{
				return convertedValue;
			}
			return EnsureTypeAssignable(initialValue, ReflectionUtils.GetObjectType(initialValue), targetType);
		}

		public static bool TryConvertOrCast<T>(object initialValue, out T convertedValue)
		{
			return TryConvertOrCast<T>(initialValue, CultureInfo.CurrentCulture, out convertedValue);
		}

		public static bool TryConvertOrCast<T>(object initialValue, CultureInfo culture, out T convertedValue)
		{
			return MiscellaneousUtils.TryAction(delegate
			{
				TryConvertOrCast(initialValue, CultureInfo.CurrentCulture, typeof(T), out var convertedValue2);
				return (T)convertedValue2;
			}, out convertedValue);
		}

		public static bool TryConvertOrCast(object initialValue, CultureInfo culture, Type targetType, out object convertedValue)
		{
			return MiscellaneousUtils.TryAction(() => ConvertOrCast(initialValue, culture, targetType), out convertedValue);
		}

		private static object EnsureTypeAssignable(object value, Type initialType, Type targetType)
		{
			Type type = value?.GetType();
			if (value != null)
			{
				if (targetType.IsAssignableFrom(type))
				{
					return value;
				}
				Func<object, object> func = CastConverters.Get(new TypeConvertKey(type, targetType));
				if (func != null)
				{
					return func(value);
				}
			}
			else if (ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			throw new Exception("Could not cast or convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, (initialType == null) ? "{null}" : initialType.ToString(), targetType));
		}

		internal static TypeConverter GetConverter(Type t)
		{
			return PlayFab.Json.Serialization.JsonTypeReflector.GetTypeConverter(t);
		}

		public static bool IsInteger(object value)
		{
			switch (System.Convert.GetTypeCode(value))
			{
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}
	}
	internal static class DateTimeUtils
	{
		public static string GetLocalOffset(this DateTime d)
		{
			TimeSpan utcOffset = TimeZoneInfo.Local.GetUtcOffset(d);
			return utcOffset.Hours.ToString("+00;-00", CultureInfo.InvariantCulture) + ":" + utcOffset.Minutes.ToString("00;00", CultureInfo.InvariantCulture);
		}
	}
	internal interface IWrappedDictionary : IDictionary, IEnumerable, ICollection
	{
		object UnderlyingDictionary { get; }
	}
	internal class DictionaryWrapper<TKey, TValue> : IDictionary<TKey, TValue>, IWrappedDictionary, IEnumerable, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IDictionary, ICollection
	{
		private struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IDictionaryEnumerator, IEnumerator
		{
			private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

			public DictionaryEntry Entry => (DictionaryEntry)Current;

			public object Key => Entry.Key;

			public object Value => Entry.Value;

			public object Current => new DictionaryEntry(_e.Current.Key, _e.Current.Value);

			public DictionaryEnumerator(IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
			{
				ValidationUtils.ArgumentNotNull(e, "e");
				_e = e;
			}

			public bool MoveNext()
			{
				return _e.MoveNext();
			}

			public void Reset()
			{
				_e.Reset();
			}
		}

		private readonly IDictionary _dictionary;

		private readonly IDictionary<TKey, TValue> _genericDictionary;

		private object _syncRoot;

		bool IDictionary.IsFixedSize
		{
			get
			{
				if (_genericDictionary != null)
				{
					return false;
				}
				return _dictionary.IsFixedSize;
			}
		}

		ICollection IDictionary.Keys
		{
			get
			{
				if (_genericDictionary != null)
				{
					return System.Linq.Enumerable.ToList(_genericDictionary.Keys);
				}
				return _dictionary.Keys;
			}
		}

		ICollection IDictionary.Values
		{
			get
			{
				if (_genericDictionary != null)
				{
					return System.Linq.Enumerable.ToList(_genericDictionary.Values);
				}
				return _dictionary.Values;
			}
		}

		object IDictionary.this[object key]
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary[(TKey)key];
				}
				return _dictionary[key];
			}
			set
			{
				if (_genericDictionary != null)
				{
					_genericDictionary[(TKey)key] = (TValue)value;
				}
				else
				{
					_dictionary[key] = value;
				}
			}
		}

		bool ICollection.IsSynchronized
		{
			get
			{
				if (_genericDictionary != null)
				{
					return false;
				}
				return _dictionary.IsSynchronized;
			}
		}

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public ICollection<TKey> Keys
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.Keys;
				}
				return System.Linq.Enumerable.ToList(System.Linq.Enumerable.Cast<TKey>(_dictionary.Keys));
			}
		}

		public ICollection<TValue> Values
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.Values;
				}
				return System.Linq.Enumerable.ToList(System.Linq.Enumerable.Cast<TValue>(_dictionary.Values));
			}
		}

		public TValue this[TKey key]
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary[key];
				}
				return (TValue)_dictionary[key];
			}
			set
			{
				if (_genericDictionary != null)
				{
					_genericDictionary[key] = value;
				}
				else
				{
					_dictionary[key] = value;
				}
			}
		}

		public int Count
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.Count;
				}
				return _dictionary.Count;
			}
		}

		public bool IsReadOnly
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.IsReadOnly;
				}
				return _dictionary.IsReadOnly;
			}
		}

		public object UnderlyingDictionary
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary;
				}
				return _dictionary;
			}
		}

		public DictionaryWrapper(IDictionary dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_dictionary = dictionary;
		}

		public DictionaryWrapper(IDictionary<TKey, TValue> dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_genericDictionary = dictionary;
		}

		public void Add(TKey key, TValue value)
		{
			if (_genericDictionary != null)
			{
				_genericDictionary.Add(key, value);
			}
			else
			{
				_dictionary.Add(key, value);
			}
		}

		public bool ContainsKey(TKey key)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.ContainsKey(key);
			}
			return _dictionary.Contains(key);
		}

		public bool Remove(TKey key)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.Remove(key);
			}
			if (_dictionary.Contains(key))
			{
				_dictionary.Remove(key);
				return true;
			}
			return false;
		}

		public bool TryGetValue(TKey key, out TValue value)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.TryGetValue(key, out value);
			}
			if (!_dictionary.Contains(key))
			{
				value = default(TValue);
				return false;
			}
			value = (TValue)_dictionary[key];
			return true;
		}

		public void Add(KeyValuePair<TKey, TValue> item)
		{
			if (_genericDictionary != null)
			{
				_genericDictionary.Add(item);
			}
			else
			{
				((IList)_dictionary).Add(item);
			}
		}

		public void Clear()
		{
			if (_genericDictionary != null)
			{
				_genericDictionary.Clear();
			}
			else
			{
				_dictionary.Clear();
			}
		}

		public bool Contains(KeyValuePair<TKey, TValue> item)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.Contains(item);
			}
			return ((IList)_dictionary).Contains(item);
		}

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			if (_genericDictionary != null)
			{
				_genericDictionary.CopyTo(array, arrayIndex);
				return;
			}
			foreach (DictionaryEntry item in _dictionary)
			{
				ref KeyValuePair<TKey, TValue> reference = ref array[arrayIndex++];
				reference = new KeyValuePair<TKey, TValue>((TKey)item.Key, (TValue)item.Value);
			}
		}

		public bool Remove(KeyValuePair<TKey, TValue> item)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.Remove(item);
			}
			if (_dictionary.Contains(item.Key))
			{
				object objA = _dictionary[item.Key];
				if (object.Equals(objA, item.Value))
				{
					_dictionary.Remove(item.Key);
					return true;
				}
				return false;
			}
			return true;
		}

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.GetEnumerator();
			}
			return System.Linq.Enumerable.Select(System.Linq.Enumerable.Cast<DictionaryEntry>(_dictionary), (DictionaryEntry de) => new KeyValuePair<TKey, TValue>((TKey)de.Key, (TValue)de.Value)).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		void IDictionary.Add(object key, object value)
		{
			if (_genericDictionary != null)
			{
				_genericDictionary.Add((TKey)key, (TValue)value);
			}
			else
			{
				_dictionary.Add(key, value);
			}
		}

		bool IDictionary.Contains(object key)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.ContainsKey((TKey)key);
			}
			return _dictionary.Contains(key);
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			if (_genericDictionary != null)
			{
				return new DictionaryEnumerator<TKey, TValue>(_genericDictionary.GetEnumerator());
			}
			return _dictionary.GetEnumerator();
		}

		public void Remove(object key)
		{
			if (_genericDictionary != null)
			{
				_genericDictionary.Remove((TKey)key);
			}
			else
			{
				_dictionary.Remove(key);
			}
		}

		void ICollection.CopyTo(Array array, int index)
		{
			if (_genericDictionary != null)
			{
				_genericDictionary.CopyTo((KeyValuePair<TKey, TValue>[])array, index);
			}
			else
			{
				_dictionary.CopyTo(array, index);
			}
		}
	}
	internal static class EnumUtils
	{
		public static T Parse<T>(string enumMemberName) where T : struct
		{
			return Parse<T>(enumMemberName, ignoreCase: false);
		}

		public static T Parse<T>(string enumMemberName, bool ignoreCase) where T : struct
		{
			ValidationUtils.ArgumentTypeIsEnum(typeof(T), "T");
			return (T)Enum.Parse(typeof(T), enumMemberName, ignoreCase);
		}

		public static bool TryParse<T>(string enumMemberName, bool ignoreCase, out T value) where T : struct
		{
			ValidationUtils.ArgumentTypeIsEnum(typeof(T), "T");
			return MiscellaneousUtils.TryAction(() => Parse<T>(enumMemberName, ignoreCase), out value);
		}

		public static IList<T> GetFlagsValues<T>(T value) where T : struct
		{
			Type typeFromHandle = typeof(T);
			if (!typeFromHandle.IsDefined(typeof(FlagsAttribute), inherit: false))
			{
				throw new Exception("Enum type {0} is not a set of flags.".FormatWith(CultureInfo.InvariantCulture, typeFromHandle));
			}
			Type underlyingType = Enum.GetUnderlyingType(value.GetType());
			ulong num = Convert.ToUInt64(value, CultureInfo.InvariantCulture);
			EnumValues<ulong> namesAndValues = GetNamesAndValues<T>();
			IList<T> list = new List<T>();
			foreach (EnumValue<ulong> item in namesAndValues)
			{
				if ((num & item.Value) == item.Value && item.Value != 0)
				{
					list.Add((T)Convert.ChangeType(item.Value, underlyingType, CultureInfo.CurrentCulture));
				}
			}
			if (list.Count == 0 && System.Linq.Enumerable.SingleOrDefault(namesAndValues, (EnumValue<ulong> v) => v.Value == 0) != null)
			{
				list.Add(default(T));
			}
			return list;
		}

		public static EnumValues<ulong> GetNamesAndValues<T>() where T : struct
		{
			return GetNamesAndValues<ulong>(typeof(T));
		}

		public static EnumValues<TUnderlyingType> GetNamesAndValues<TEnum, TUnderlyingType>() where TEnum : struct where TUnderlyingType : struct
		{
			return GetNamesAndValues<TUnderlyingType>(typeof(TEnum));
		}

		public static EnumValues<TUnderlyingType> GetNamesAndValues<TUnderlyingType>(Type enumType) where TUnderlyingType : struct
		{
			if (enumType == null)
			{
				throw new ArgumentNullException("enumType");
			}
			ValidationUtils.ArgumentTypeIsEnum(enumType, "enumType");
			IList<object> values = GetValues(enumType);
			IList<string> names = GetNames(enumType);
			EnumValues<TUnderlyingType> enumValues = new EnumValues<TUnderlyingType>();
			for (int i = 0; i < values.Count; i++)
			{
				try
				{
					enumValues.Add(new EnumValue<TUnderlyingType>(names[i], (TUnderlyingType)Convert.ChangeType(values[i], typeof(TUnderlyingType), CultureInfo.CurrentCulture)));
				}
				catch (OverflowException innerException)
				{
					throw new Exception(string.Format(CultureInfo.InvariantCulture, "Value from enum with the underlying type of {0} cannot be added to dictionary with a value type of {1}. Value was too large: {2}", Enum.GetUnderlyingType(enumType), typeof(TUnderlyingType), Convert.ToUInt64(values[i], CultureInfo.InvariantCulture)), innerException);
				}
			}
			return enumValues;
		}

		public static IList<T> GetValues<T>()
		{
			return System.Linq.Enumerable.ToList(System.Linq.Enumerable.Cast<T>(GetValues(typeof(T))));
		}

		public static IList<object> GetValues(Type enumType)
		{
			if (!enumType.IsEnum)
			{
				throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
			}
			List<object> list = new List<object>();
			IEnumerable<FieldInfo> enumerable = System.Linq.Enumerable.Where(enumType.GetFields(), (FieldInfo field) => field.IsLiteral);
			foreach (FieldInfo item in enumerable)
			{
				object value = item.GetValue(enumType);
				list.Add(value);
			}
			return list;
		}

		public static IList<string> GetNames<T>()
		{
			return GetNames(typeof(T));
		}

		public static IList<string> GetNames(Type enumType)
		{
			if (!enumType.IsEnum)
			{
				throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
			}
			List<string> list = new List<string>();
			IEnumerable<FieldInfo> enumerable = System.Linq.Enumerable.Where(enumType.GetFields(), (FieldInfo field) => field.IsLiteral);
			foreach (FieldInfo item in enumerable)
			{
				list.Add(item.Name);
			}
			return list;
		}

		public static TEnumType GetMaximumValue<TEnumType>(Type enumType) where TEnumType : IConvertible, IComparable<TEnumType>
		{
			if (enumType == null)
			{
				throw new ArgumentNullException("enumType");
			}
			Type underlyingType = Enum.GetUnderlyingType(enumType);
			if (!typeof(TEnumType).IsAssignableFrom(underlyingType))
			{
				throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "TEnumType is not assignable from the enum's underlying type of {0}.", underlyingType.Name));
			}
			ulong num = 0uL;
			IList<object> values = GetValues(enumType);
			if (enumType.IsDefined(typeof(FlagsAttribute), inherit: false))
			{
				foreach (TEnumType item in values)
				{
					num |= item.ToUInt64(CultureInfo.InvariantCulture);
				}
			}
			else
			{
				foreach (TEnumType item2 in values)
				{
					ulong num2 = item2.ToUInt64(CultureInfo.InvariantCulture);
					if (num.CompareTo(num2) == -1)
					{
						num = num2;
					}
				}
			}
			return (TEnumType)Convert.ChangeType(num, typeof(TEnumType), CultureInfo.InvariantCulture);
		}
	}
	internal class EnumValue<T> where T : struct
	{
		private string _name;

		private T _value;

		public string Name => _name;

		public T Value => _value;

		public EnumValue(string name, T value)
		{
			_name = name;
			_value = value;
		}
	}
	internal class EnumValues<T> : KeyedCollection<string, EnumValue<T>> where T : struct
	{
		protected override string GetKeyForItem(EnumValue<T> item)
		{
			return item.Name;
		}
	}
	internal static class JavaScriptUtils
	{
		public static void WriteEscapedJavaScriptString(TextWriter writer, string value, char delimiter, bool appendDelimiters)
		{
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
			if (value != null)
			{
				int num = 0;
				int num2 = 0;
				char[] array = null;
				for (int i = 0; i < value.Length; i++)
				{
					char c = value[i];
					string text = c switch
					{
						'\t' => "\\t", 
						'\n' => "\\n", 
						'\r' => "\\r", 
						'\f' => "\\f", 
						'\b' => "\\b", 
						_ => (c == '\u2028') ? "\\u2028" : ((c == '\u2029') ? "\\u2029" : ((c == '"') ? ((delimiter != '"') ? null : "\\\"") : ((c == '\'') ? ((delimiter != '\'') ? null : "\\'") : ((c == '\\') ? "\\\\" : ((c != '\u0085') ? ((c > '\u001f') ? null : StringUtils.ToCharAsUnicode(c)) : "\\u0085"))))), 
					};
					if (text != null)
					{
						if (array == null)
						{
							array = value.ToCharArray();
						}
						if (num2 > 0)
						{
							writer.Write(array, num, num2);
							num2 = 0;
						}
						writer.Write(text);
						num = i + 1;
					}
					else
					{
						num2++;
					}
				}
				if (num2 > 0)
				{
					if (num == 0)
					{
						writer.Write(value);
					}
					else
					{
						writer.Write(array, num, num2);
					}
				}
			}
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
		}

		public static string ToEscapedJavaScriptString(string value)
		{
			return ToEscapedJavaScriptString(value, '"', appendDelimiters: true);
		}

		public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters)
		{
			int? length = StringUtils.GetLength(value);
			using StringWriter stringWriter = StringUtils.CreateStringWriter((!length.HasValue) ? 16 : length.Value);
			WriteEscapedJavaScriptString(stringWriter, value, delimiter, appendDelimiters);
			return stringWriter.ToString();
		}
	}
	internal class LateBoundReflectionDelegateFactory : ReflectionDelegateFactory
	{
		private static readonly LateBoundReflectionDelegateFactory _instance = new LateBoundReflectionDelegateFactory();

		internal static ReflectionDelegateFactory Instance => _instance;

		public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
		{
			ValidationUtils.ArgumentNotNull(method, "method");
			ConstructorInfo c = method as ConstructorInfo;
			if (c != null)
			{
				return (T o, object[] a) => c.Invoke(a);
			}
			return (T o, object[] a) => method.Invoke(o, a);
		}

		public override Func<T> CreateDefaultConstructor<T>(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsValueType)
			{
				return () => (T)ReflectionUtils.CreateInstance(type);
			}
			ConstructorInfo constructorInfo = ReflectionUtils.GetDefaultConstructor(type, nonPublic: true);
			return () => (T)constructorInfo.Invoke(null);
		}

		public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return (T o) => propertyInfo.GetValue(o, null);
		}

		public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return (T o) => fieldInfo.GetValue(o);
		}

		public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return delegate(T o, object v)
			{
				fieldInfo.SetValue(o, v);
			};
		}

		public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return delegate(T o, object v)
			{
				propertyInfo.SetValue(o, v, null);
			};
		}
	}
	internal interface IWrappedList : IList, IEnumerable, ICollection
	{
		object UnderlyingList { get; }
	}
	internal class ListWrapper<T> : CollectionWrapper<T>, IList<T>, IWrappedList, IEnumerable, ICollection<T>, IEnumerable<T>, IList, ICollection
	{
		private readonly IList<T> _genericList;

		public T this[int index]
		{
			get
			{
				if (_genericList != null)
				{
					return _genericList[index];
				}
				return (T)((IList)this)[index];
			}
			set
			{
				if (_genericList != null)
				{
					_genericList[index] = value;
				}
				else
				{
					((IList)this)[index] = value;
				}
			}
		}

		public override int Count
		{
			get
			{
				if (_genericList != null)
				{
					return _genericList.Count;
				}
				return base.Count;
			}
		}

		public override bool IsReadOnly
		{
			get
			{
				if (_genericList != null)
				{
					return _genericList.IsReadOnly;
				}
				return base.IsReadOnly;
			}
		}

		public object UnderlyingList
		{
			get
			{
				if (_genericList != null)
				{
					return _genericList;
				}
				return base.UnderlyingCollection;
			}
		}

		public ListWrapper(IList list)
			: base(list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			if (list is IList<T>)
			{
				_genericList = (IList<T>)list;
			}
		}

		public ListWrapper(IList<T> list)
			: base((ICollection<T>)list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			_genericList = list;
		}

		public int IndexOf(T item)
		{
			if (_genericList != null)
			{
				return _genericList.IndexOf(item);
			}
			return ((IList)this).IndexOf((object)item);
		}

		public void Insert(int index, T item)
		{
			if (_genericList != null)
			{
				_genericList.Insert(index, item);
			}
			else
			{
				((IList)this).Insert(index, (object)item);
			}
		}

		public void RemoveAt(int index)
		{
			if (_genericList != null)
			{
				_genericList.RemoveAt(index);
			}
			else
			{
				((IList)this).RemoveAt(index);
			}
		}

		public override void Add(T item)
		{
			if (_genericList != null)
			{
				_genericList.Add(item);
			}
			else
			{
				base.Add(item);
			}
		}

		public override void Clear()
		{
			if (_genericList != null)
			{
				_genericList.Clear();
			}
			else
			{
				base.Clear();
			}
		}

		public override bool Contains(T item)
		{
			if (_genericList != null)
			{
				return _genericList.Contains(item);
			}
			return base.Contains(item);
		}

		public override void CopyTo(T[] array, int arrayIndex)
		{
			if (_genericList != null)
			{
				_genericList.CopyTo(array, arrayIndex);
			}
			else
			{
				base.CopyTo(array, arrayIndex);
			}
		}

		public override bool Remove(T item)
		{
			if (_genericList != null)
			{
				return _genericList.Remove(item);
			}
			bool flag = base.Contains(item);
			if (flag)
			{
				base.Remove(item);
			}
			return flag;
		}

		public override IEnumerator<T> GetEnumerator()
		{
			if (_genericList != null)
			{
				return _genericList.GetEnumerator();
			}
			return base.GetEnumerator();
		}
	}
	internal class MathUtils
	{
		public static int IntLength(int i)
		{
			if (i < 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			if (i == 0)
			{
				return 1;
			}
			return (int)Math.Floor(Math.Log10(i)) + 1;
		}

		public static int HexToInt(char h)
		{
			if (h >= '0' && h <= '9')
			{
				return h - 48;
			}
			if (h >= 'a' && h <= 'f')
			{
				return h - 97 + 10;
			}
			if (h >= 'A' && h <= 'F')
			{
				return h - 65 + 10;
			}
			return -1;
		}

		public static char IntToHex(int n)
		{
			if (n <= 9)
			{
				return (char)(n + 48);
			}
			return (char)(n - 10 + 97);
		}

		public static int GetDecimalPlaces(double value)
		{
			int num = 10;
			double num2 = Math.Pow(0.1, num);
			if (value == 0.0)
			{
				return 0;
			}
			int num3 = 0;
			while (value - Math.Floor(value) > num2 && num3 < num)
			{
				value *= 10.0;
				num3++;
			}
			return num3;
		}

		public static int? Min(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Min(val1.Value, val2.Value);
		}

		public static int? Max(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.Value, val2.Value);
		}

		public static double? Min(double? val1, double? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Min(val1.Value, val2.Value);
		}

		public static double? Max(double? val1, double? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.Value, val2.Value);
		}

		public static bool ApproxEquals(double d1, double d2)
		{
			return Math.Abs(d1 - d2) < Math.Abs(d1) * 1E-06;
		}
	}
	internal delegate TResult MethodCall<T, TResult>(T target, params object[] args);
	internal delegate T Creator<T>();
	internal static class MiscellaneousUtils
	{
		public static bool ValueEquals(object objA, object objB)
		{
			if (objA == null && objB == null)
			{
				return true;
			}
			if (objA != null && objB == null)
			{
				return false;
			}
			if (objA == null && objB != null)
			{
				return false;
			}
			if (objA.GetType() != objB.GetType())
			{
				if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))
				{
					return Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture));
				}
				if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal))
				{
					return MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture));
				}
				return false;
			}
			return objA.Equals(objB);
		}

		public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
		{
			string message2 = message + Environment.NewLine + "Actual value was {0}.".FormatWith(CultureInfo.InvariantCulture, actualValue);
			return new ArgumentOutOfRangeException(paramName, message2);
		}

		public static bool TryAction<T>(Creator<T> creator, out T output)
		{
			ValidationUtils.ArgumentNotNull(creator, "creator");
			try
			{
				output = creator();
				return true;
			}
			catch
			{
				output = default(T);
				return false;
			}
		}

		public static string ToString(object value)
		{
			if (value == null)
			{
				return "{null}";
			}
			return (!(value is string)) ? value.ToString() : ("\"" + value.ToString() + "\"");
		}

		public static byte[] HexToBytes(string hex)
		{
			string text = hex.Replace("-", string.Empty);
			byte[] array = new byte[text.Length / 2];
			int num = 4;
			int num2 = 0;
			string text2 = text;
			foreach (char c in text2)
			{
				int num3 = (c - 48) % 32;
				if (num3 > 9)
				{
					num3 -= 7;
				}
				array[num2] |= (byte)(num3 << num);
				num ^= 4;
				if (num != 0)
				{
					num2++;
				}
			}
			return array;
		}

		public static string BytesToHex(byte[] bytes)
		{
			return BytesToHex(bytes, removeDashes: false);
		}

		public static string BytesToHex(byte[] bytes, bool removeDashes)
		{
			string text = BitConverter.ToString(bytes);
			if (removeDashes)
			{
				text = text.Replace("-", string.Empty);
			}
			return text;
		}

		public static int ByteArrayCompare(byte[] a1, byte[] a2)
		{
			int num = a1.Length.CompareTo(a2.Length);
			if (num != 0)
			{
				return num;
			}
			for (int i = 0; i < a1.Length; i++)
			{
				int num2 = a1[i].CompareTo(a2[i]);
				if (num2 != 0)
				{
					return num2;
				}
			}
			return 0;
		}

		public static string GetPrefix(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out var prefix, out var _);
			return prefix;
		}

		public static string GetLocalName(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out var _, out var localName);
			return localName;
		}

		public static void GetQualifiedNameParts(string qualifiedName, out string prefix, out string localName)
		{
			int num = qualifiedName.IndexOf(':');
			if (num == -1 || num == 0 || qualifiedName.Length - 1 == num)
			{
				prefix = null;
				localName = qualifiedName;
			}
			else
			{
				prefix = qualifiedName.Substring(0, num);
				localName = qualifiedName.Substring(num + 1);
			}
		}
	}
	internal abstract class ReflectionDelegateFactory
	{
		public Func<T, object> CreateGet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				return CreateGet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateGet<T>(fieldInfo);
			}
			throw new Exception("Could not create getter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public Action<T, object> CreateSet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				return CreateSet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateSet<T>(fieldInfo);
			}
			throw new Exception("Could not create setter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public abstract MethodCall<T, object> CreateMethodCall<T>(MethodBase method);

		public abstract Func<T> CreateDefaultConstructor<T>(Type type);

		public abstract Func<T, object> CreateGet<T>(PropertyInfo propertyInfo);

		public abstract Func<T, object> CreateGet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object> CreateSet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object> CreateSet<T>(PropertyInfo propertyInfo);
	}
	public delegate object D1();
	internal static class ReflectionUtils
	{
		public static bool IsVirtual(this PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			MethodInfo getMethod = propertyInfo.GetGetMethod();
			if (getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			getMethod = propertyInfo.GetSetMethod();
			if (getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			return false;
		}

		public static Type GetObjectType(object v)
		{
			return v?.GetType();
		}

		public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat)
		{
			return GetTypeName(t, assemblyFormat, null);
		}

		public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder)
		{
			string assemblyQualifiedName = t.AssemblyQualifiedName;
			return assemblyFormat switch
			{
				FormatterAssemblyStyle.Simple => RemoveAssemblyDetails(assemblyQualifiedName), 
				FormatterAssemblyStyle.Full => t.AssemblyQualifiedName, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		private static string RemoveAssemblyDetails(string fullyQualifiedTypeName)
		{
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = false;
			bool flag2 = false;
			foreach (char c in fullyQualifiedTypeName)
			{
				switch (c)
				{
				case '[':
					flag = false;
					flag2 = false;
					stringBuilder.Append(c);
					break;
				case ']':
					flag = false;
					flag2 = false;
					stringBuilder.Append(c);
					break;
				case ',':
					if (!flag)
					{
						flag = true;
						stringBuilder.Append(c);
					}
					else
					{
						flag2 = true;
					}
					break;
				default:
					if (!flag2)
					{
						stringBuilder.Append(c);
					}
					break;
				}
			}
			return stringBuilder.ToString();
		}

		public static bool IsInstantiatableType(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsAbstract || t.IsInterface || t.IsArray || t.IsGenericTypeDefinition || t == typeof(void))
			{
				return false;
			}
			if (!HasDefaultConstructor(t))
			{
				return false;
			}
			return true;
		}

		public static bool HasDefaultConstructor(Type t)
		{
			return HasDefaultConstructor(t, nonPublic: false);
		}

		public static bool HasDefaultConstructor(Type t, bool nonPublic)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType)
			{
				return true;
			}
			return GetDefaultConstructor(t, nonPublic) != null;
		}

		public static ConstructorInfo GetDefaultConstructor(Type t)
		{
			return GetDefaultConstructor(t, nonPublic: false);
		}

		public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
		{
			BindingFlags bindingFlags = BindingFlags.Public;
			if (nonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			return t.GetConstructor(bindingFlags | BindingFlags.Instance, null, new Type[0], null);
		}

		public static bool IsNullable(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType)
			{
				return IsNullableType(t);
			}
			return true;
		}

		public static bool IsNullableType(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			return t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Nullable<>);
		}

		public static Type EnsureNotNullableType(Type t)
		{
			return (!IsNullableType(t)) ? t : Nullable.GetUnderlyingType(t);
		}

		public static bool IsUnitializedValue(object value)
		{
			if (value == null)
			{
				return true;
			}
			object obj = CreateUnitializedValue(value.GetType());
			return value.Equals(obj);
		}

		public static object CreateUnitializedValue(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsGenericTypeDefinition)
			{
				throw new ArgumentException("Type {0} is a generic type definition and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, type), "type");
			}
			if (type.IsClass || type.IsInterface || type == typeof(void))
			{
				return null;
			}
			if (type.IsValueType)
			{
				return Activator.CreateInstance(type);
			}
			throw new ArgumentException("Type {0} cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, type), "type");
		}

		public static bool IsPropertyIndexed(PropertyInfo property)
		{
			ValidationUtils.ArgumentNotNull(property, "property");
			return !CollectionUtils.IsNullOrEmpty((ICollection<ParameterInfo>)property.GetIndexParameters());
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
		{
			Type implementingType;
			return ImplementsGenericDefinition(type, genericInterfaceDefinition, out implementingType);
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, out Type implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericInterfaceDefinition, "genericInterfaceDefinition");
			if (!genericInterfaceDefinition.IsInterface || !genericInterfaceDefinition.IsGenericTypeDefinition)
			{
				throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith(CultureInfo.InvariantCulture, genericInterfaceDefinition));
			}
			if (type.IsInterface && type.IsGenericType)
			{
				Type genericTypeDefinition = type.GetGenericTypeDefinition();
				if (genericInterfaceDefinition == genericTypeDefinition)
				{
					implementingType = type;
					return true;
				}
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				if (type2.IsGenericType)
				{
					Type genericTypeDefinition2 = type2.GetGenericTypeDefinition();
					if (genericInterfaceDefinition == genericTypeDefinition2)
					{
						implementingType = type2;
						return true;
					}
				}
			}
			implementingType = null;
			return false;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName, out Type match)
		{
			for (Type type2 = type; type2 != null; type2 = type2.BaseType)
			{
				if (string.Equals(type2.FullName, fullTypeName, StringComparison.Ordinal))
				{
					match = type2;
					return true;
				}
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type3 in interfaces)
			{
				if (string.Equals(type3.Name, fullTypeName, StringComparison.Ordinal))
				{
					match = type;
					return true;
				}
			}
			match = null;
			return false;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName)
		{
			Type match;
			return type.AssignableToTypeName(fullTypeName, out match);
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
		{
			Type implementingType;
			return InheritsGenericDefinition(type, genericClassDefinition, out implementingType);
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, out Type implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericClassDefinition, "genericClassDefinition");
			if (!genericClassDefinition.IsClass || !genericClassDefinition.IsGenericTypeDefinition)
			{
				throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith(CultureInfo.InvariantCulture, genericClassDefinition));
			}
			return InheritsGenericDefinitionInternal(type, genericClassDefinition, out implementingType);
		}

		private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, out Type implementingType)
		{
			if (currentType.IsGenericType)
			{
				Type genericTypeDefinition = currentType.GetGenericTypeDefinition();
				if (genericClassDefinition == genericTypeDefinition)
				{
					implementingType = currentType;
					return true;
				}
			}
			if (currentType.BaseType == null)
			{
				implementingType = null;
				return false;
			}
			return InheritsGenericDefinitionInternal(currentType.BaseType, genericClassDefinition, out implementingType);
		}

		public static Type GetCollectionItemType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsArray)
			{
				return type.GetElementType();
			}
			if (ImplementsGenericDefinition(type, typeof(IEnumerable<>), out var implementingType))
			{
				if (implementingType.IsGenericTypeDefinition)
				{
					throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
				}
				return implementingType.GetGenericArguments()[0];
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				return null;
			}
			throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
		}

		public static void GetDictionaryKeyValueTypes(Type dictionaryType, out Type keyType, out Type valueType)
		{
			ValidationUtils.ArgumentNotNull(dictionaryType, "type");
			if (ImplementsGenericDefinition(dictionaryType, typeof(IDictionary<, >), out var implementingType))
			{
				if (implementingType.IsGenericTypeDefinition)
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				Type[] genericArguments = implementingType.GetGenericArguments();
				keyType = genericArguments[0];
				valueType = genericArguments[1];
			}
			else
			{
				if (!typeof(IDictionary).IsAssignableFrom(dictionaryType))
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				keyType = null;
				valueType = null;
			}
		}

		public static Type GetDictionaryValueType(Type dictionaryType)
		{
			GetDictionaryKeyValueTypes(dictionaryType, out var _, out var valueType);
			return valueType;
		}

		public static Type GetDictionaryKeyType(Type dictionaryType)
		{
			GetDictionaryKeyValueTypes(dictionaryType, out var keyType, out var _);
			return keyType;
		}

		public static bool ItemsUnitializedValue<T>(IList<T> list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			Type collectionItemType = GetCollectionItemType(list.GetType());
			if (collectionItemType.IsValueType)
			{
				object obj = CreateUnitializedValue(collectionItemType);
				for (int i = 0; i < list.Count; i++)
				{
					if (!list[i].Equals(obj))
					{
						return false;
					}
				}
			}
			else
			{
				if (!collectionItemType.IsClass)
				{
					throw new Exception("Type {0} is neither a ValueType or a Class.".FormatWith(CultureInfo.InvariantCulture, collectionItemType));
				}
				for (int j = 0; j < list.Count; j++)
				{
					object obj2 = list[j];
					if (obj2 != null)
					{
						return false;
					}
				}
			}
			return true;
		}

		public static Type GetMemberUnderlyingType(MemberInfo member)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			return member.MemberType switch
			{
				MemberTypes.Field => ((FieldInfo)member).FieldType, 
				MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
				MemberTypes.Event => ((EventInfo)member).EventHandlerType, 
				_ => throw new ArgumentException("MemberInfo must be of type FieldInfo, PropertyInfo or EventInfo", "member"), 
			};
		}

		public static bool IsIndexedProperty(MemberInfo member)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			if (member is PropertyInfo property)
			{
				return IsIndexedProperty(property);
			}
			return false;
		}

		public static bool IsIndexedProperty(PropertyInfo property)
		{
			ValidationUtils.ArgumentNotNull(property, "property");
			return property.GetIndexParameters().Length > 0;
		}

		public static object GetMemberValue(MemberInfo member, object target)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType)
			{
			case MemberTypes.Field:
				return ((FieldInfo)member).GetValue(target);
			case MemberTypes.Property:
				try
				{
					return ((PropertyInfo)member).GetValue(target, null);
				}
				catch (TargetParameterCountException innerException)
				{
					throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith(CultureInfo.InvariantCulture, member.Name), innerException);
				}
			default:
				throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static void SetMemberValue(MemberInfo member, object target, object value)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType)
			{
			case MemberTypes.Field:
				((FieldInfo)member).SetValue(target, value);
				break;
			case MemberTypes.Property:
				((PropertyInfo)member).SetValue(target, value, null);
				break;
			default:
				throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static bool CanReadMemberValue(MemberInfo member, bool nonPublic)
		{
			switch (member.MemberType)
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanRead)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return propertyInfo.GetGetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
		{
			switch (member.MemberType)
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (fieldInfo.IsInitOnly && !canSetReadOnly)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanWrite)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return propertyInfo.GetSetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static List<MemberInfo> GetFieldsAndProperties<T>(BindingFlags bindingAttr)
		{
			return GetFieldsAndProperties(typeof(T), bindingAttr);
		}

		public static List<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
		{
			List<MemberInfo> list = new List<MemberInfo>();
			list.AddRange(GetFields(type, bindingAttr));
			list.AddRange(GetProperties(type, bindingAttr));
			List<MemberInfo> list2 = new List<MemberInfo>(list.Count);
			var enumerable = System.Linq.Enumerable.Select(System.Linq.Enumerable.GroupBy(list, (MemberInfo m) => m.Name), (System.Linq.IGrouping<string, MemberInfo> g) => new
			{
				Count = System.Linq.Enumerable.Count(g),
				Members = System.Linq.Enumerable.Cast<MemberInfo>(g)
			});
			foreach (var item in enumerable)
			{
				if (item.Count == 1)
				{
					list2.Add(System.Linq.Enumerable.First(item.Members));
					continue;
				}
				IEnumerable<MemberInfo> collection = System.Linq.Enumerable.Where(item.Members, (MemberInfo m) => !IsOverridenGenericMember(m, bindingAttr) || m.Name == "Item");
				list2.AddRange(collection);
			}
			return list2;
		}

		private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
		{
			if (memberInfo.MemberType != MemberTypes.Field && memberInfo.MemberType != MemberTypes.Property)
			{
				throw new ArgumentException("Member must be a field or property.");
			}
			Type declaringType = memberInfo.DeclaringType;
			if (!declaringType.IsGenericType)
			{
				return false;
			}
			Type genericTypeDefinition = declaringType.GetGenericTypeDefinition();
			if (genericTypeDefinition == null)
			{
				return false;
			}
			MemberInfo[] member = genericTypeDefinition.GetMember(memberInfo.Name, bindingAttr);
			if (member.Length == 0)
			{
				return false;
			}
			Type memberUnderlyingType = GetMemberUnderlyingType(member[0]);
			if (!memberUnderlyingType.IsGenericParameter)
			{
				return false;
			}
			return true;
		}

		public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider) where T : Attribute
		{
			return GetAttribute<T>(attributeProvider, inherit: true);
		}

		public static T GetAttribute<T>(ICustomAttributeProvider attributeProvider, bool inherit) where T : Attribute
		{
			T[] attributes = GetAttributes<T>(attributeProvider, inherit);
			return CollectionUtils.GetSingleItem(attributes, returnDefaultIfEmpty: true);
		}

		public static T[] GetAttributes<T>(ICustomAttributeProvider attributeProvider, bool inherit) where T : Attribute
		{
			ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
			if (attributeProvider is Type)
			{
				return (T[])((Type)attributeProvider).GetCustomAttributes(typeof(T), inherit);
			}
			if (attributeProvider is Assembly)
			{
				return (T[])Attribute.GetCustomAttributes((Assembly)attributeProvider, typeof(T), inherit);
			}
			if (attributeProvider is MemberInfo)
			{
				return (T[])Attribute.GetCustomAttributes((MemberInfo)attributeProvider, typeof(T), inherit);
			}
			if (attributeProvider is Module)
			{
				return (T[])Attribute.GetCustomAttributes((Module)attributeProvider, typeof(T), inherit);
			}
			if (attributeProvider is ParameterInfo)
			{
				return (T[])Attribute.GetCustomAttributes((ParameterInfo)attributeProvider, typeof(T), inherit);
			}
			return (T[])attributeProvider.GetCustomAttributes(typeof(T), inherit);
		}

		public static string GetNameAndAssessmblyName(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			return t.FullName + ", " + t.Assembly.GetName().Name;
		}

		public static Type MakeGenericType(Type genericTypeDefinition, params Type[] innerTypes)
		{
			ValidationUtils.ArgumentNotNull(genericTypeDefinition, "genericTypeDefinition");
			ValidationUtils.ArgumentNotNullOrEmpty((ICollection<Type>)innerTypes, "innerTypes");
			ValidationUtils.ArgumentConditionTrue(genericTypeDefinition.IsGenericTypeDefinition, "genericTypeDefinition", "Type {0} is not a generic type definition.".FormatWith(CultureInfo.InvariantCulture, genericTypeDefinition));
			return genericTypeDefinition.MakeGenericType(innerTypes);
		}

		public static object CreateGeneric(Type genericTypeDefinition, Type innerType, params object[] args)
		{
			return CreateGeneric(genericTypeDefinition, new Type[1] { innerType }, args);
		}

		public static object CreateGeneric(Type genericTypeDefinition, IList<Type> innerTypes, params object[] args)
		{
			return CreateGeneric(genericTypeDefinition, innerTypes, (Type t, IList<object> a) => CreateInstance(t, System.Linq.Enumerable.ToArray(a)), args);
		}

		public static object CreateGeneric(Type genericTypeDefinition, IList<Type> innerTypes, Func<Type, IList<object>, object> instanceCreator, params object[] args)
		{
			ValidationUtils.ArgumentNotNull(genericTypeDefinition, "genericTypeDefinition");
			ValidationUtils.ArgumentNotNullOrEmpty(innerTypes, "innerTypes");
			ValidationUtils.ArgumentNotNull(instanceCreator, "createInstance");
			Type arg = MakeGenericType(genericTypeDefinition, System.Linq.Enumerable.ToArray(innerTypes));
			return instanceCreator(arg, args);
		}

		public static bool IsCompatibleValue(object value, Type type)
		{
			if (value == null)
			{
				return IsNullable(type);
			}
			if (type.IsAssignableFrom(value.GetType()))
			{
				return true;
			}
			return false;
		}

		public static object CreateInstance(Type type, params object[] args)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			return Activator.CreateInstance(type, args);
		}

		public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, out string typeName, out string assemblyName)
		{
			int? assemblyDelimiterIndex = GetAssemblyDelimiterIndex(fullyQualifiedTypeName);
			if (assemblyDelimiterIndex.HasValue)
			{
				typeName = fullyQualifiedTypeName.Substring(0, assemblyDelimiterIndex.Value).Trim();
				assemblyName = fullyQualifiedTypeName.Substring(assemblyDelimiterIndex.Value + 1, fullyQualifiedTypeName.Length - assemblyDelimiterIndex.Value - 1).Trim();
			}
			else
			{
				typeName = fullyQualifiedTypeName;
				assemblyName = null;
			}
		}

		private static int? GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
		{
			int num = 0;
			for (int i = 0; i < fullyQualifiedTypeName.Length; i++)
			{
				switch (fullyQualifiedTypeName[i])
				{
				case '[':
					num++;
					break;
				case ']':
					num--;
					break;
				case ',':
					if (num == 0)
					{
						return i;
					}
					break;
				}
			}
			return null;
		}

		public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			MemberTypes memberType = memberInfo.MemberType;
			if (memberType == MemberTypes.Property)
			{
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				Type[] types = System.Linq.Enumerable.ToArray(System.Linq.Enumerable.Select(propertyInfo.GetIndexParameters(), (ParameterInfo p) => p.ParameterType));
				return targetType.GetProperty(propertyInfo.Name, bindingAttr, null, propertyInfo.PropertyType, types, null);
			}
			return System.Linq.Enumerable.SingleOrDefault(targetType.GetMember(memberInfo.Name, memberInfo.MemberType, bindingAttr));
		}

		public static IEnumerable<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<MemberInfo> list = new List<MemberInfo>(targetType.GetFields(bindingAttr));
			GetChildPrivateFields(list, targetType, bindingAttr);
			return System.Linq.Enumerable.Cast<FieldInfo>(list);
		}

		private static void GetChildPrivateFields(IList<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
		{
			if ((bindingAttr & BindingFlags.NonPublic) == 0)
			{
				return;
			}
			BindingFlags bindingAttr2 = bindingAttr.RemoveFlag(BindingFlags.Public);
			while ((targetType = targetType.BaseType) != null)
			{
				IEnumerable<MemberInfo> collection = System.Linq.Enumerable.Cast<MemberInfo>(System.Linq.Enumerable.Where(targetType.GetFields(bindingAttr2), (FieldInfo f) => f.IsPrivate));
				initialFields.AddRange(collection);
			}
		}

		public static IEnumerable<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<PropertyInfo> list = new List<PropertyInfo>(targetType.GetProperties(bindingAttr));
			GetChildPrivateProperties(list, targetType, bindingAttr);
			for (int i = 0; i < list.Count; i++)
			{
				PropertyInfo propertyInfo = list[i];
				if (propertyInfo.DeclaringType != targetType)
				{
					PropertyInfo value = (PropertyInfo)GetMemberInfoFromType(propertyInfo.DeclaringType, propertyInfo);
					list[i] = value;
				}
			}
			return list;
		}

		public static BindingFlags RemoveFlag(this BindingFlags bindingAttr, BindingFlags flag)
		{
			return ((bindingAttr & flag) != flag) ? bindingAttr : (bindingAttr ^ flag);
		}

		private static void GetChildPrivateProperties(IList<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
		{
			if ((bindingAttr & BindingFlags.NonPublic) == 0)
			{
				return;
			}
			BindingFlags bindingAttr2 = bindingAttr.RemoveFlag(BindingFlags.Public);
			while ((targetType = targetType.BaseType) != null)
			{
				PropertyInfo[] properties = targetType.GetProperties(bindingAttr2);
				foreach (PropertyInfo propertyInfo in properties)
				{
					PropertyInfo nonPublicProperty = propertyInfo;
					int num = initialProperties.IndexOf((PropertyInfo p) => p.Name == nonPublicProperty.Name);
					if (num == -1)
					{
						initialProperties.Add(nonPublicProperty);
					}
					else
					{
						initialProperties[num] = nonPublicProperty;
					}
				}
			}
		}
	}
	internal class StringBuffer
	{
		private char[] _buffer;

		private int _position;

		private static readonly char[] _emptyBuffer = new char[0];

		public int Position
		{
			get
			{
				return _position;
			}
			set
			{
				_position = value;
			}
		}

		public StringBuffer()
		{
			_buffer = _emptyBuffer;
		}

		public StringBuffer(int initalSize)
		{
			_buffer = new char[initalSize];
		}

		public void Append(char value)
		{
			if (_position == _buffer.Length)
			{
				EnsureSize(1);
			}
			_buffer[_position++] = value;
		}

		public void Clear()
		{
			_buffer = _emptyBuffer;
			_position = 0;
		}

		private void EnsureSize(int appendLength)
		{
			char[] array = new char[(_position + appendLength) * 2];
			Array.Copy(_buffer, array, _position);
			_buffer = array;
		}

		public override string ToString()
		{
			return ToString(0, _position);
		}

		public string ToString(int start, int length)
		{
			return new string(_buffer, start, length);
		}

		public char[] GetInternalBuffer()
		{
			return _buffer;
		}
	}
	internal static class StringUtils
	{
		private delegate void ActionLine(TextWriter textWriter, string line);

		public const string CarriageReturnLineFeed = "\r\n";

		public const string Empty = "";

		public const char CarriageReturn = '\r';

		public const char LineFeed = '\n';

		public const char Tab = '\t';

		public static string FormatWith(this string format, IFormatProvider provider, params object[] args)
		{
			ValidationUtils.ArgumentNotNull(format, "format");
			return string.Format(provider, format, args);
		}

		public static bool ContainsWhiteSpace(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			for (int i = 0; i < s.Length; i++)
			{
				if (char.IsWhiteSpace(s[i]))
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsWhiteSpace(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (s.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < s.Length; i++)
			{
				if (!char.IsWhiteSpace(s[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static string EnsureEndsWith(string target, string value)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (target.Length >= value.Length)
			{
				if (string.Compare(target, target.Length - value.Length, value, 0, value.Length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return target;
				}
				string text = target.TrimEnd(null);
				if (string.Compare(text, text.Length - value.Length, value, 0, value.Length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return target;
				}
			}
			return target + value;
		}

		public static bool IsNullOrEmptyOrWhiteSpace(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return true;
			}
			if (IsWhiteSpace(s))
			{
				return true;
			}
			return false;
		}

		public static void IfNotNullOrEmpty(string value, Action<string> action)
		{
			IfNotNullOrEmpty(value, action, null);
		}

		private static void IfNotNullOrEmpty(string value, Action<string> trueAction, Action<string> falseAction)
		{
			if (!string.IsNullOrEmpty(value))
			{
				trueAction?.Invoke(value);
			}
			else
			{
				falseAction?.Invoke(value);
			}
		}

		public static string Indent(string s, int indentation)
		{
			return Indent(s, indentation, ' ');
		}

		public static string Indent(string s, int indentation, char indentChar)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (indentation <= 0)
			{
				throw new ArgumentException("Must be greater than zero.", "indentation");
			}
			StringReader textReader = new StringReader(s);
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			ActionTextReaderLine(textReader, stringWriter, delegate(TextWriter tw, string line)
			{
				tw.Write(new string(indentChar, indentation));
				tw.Write(line);
			});
			return stringWriter.ToString();
		}

		private static void ActionTextReaderLine(TextReader textReader, TextWriter textWriter, ActionLine lineAction)
		{
			bool flag = true;
			string line;
			while ((line = textReader.ReadLine()) != null)
			{
				if (!flag)
				{
					textWriter.WriteLine();
				}
				else
				{
					flag = false;
				}
				lineAction(textWriter, line);
			}
		}

		public static string NumberLines(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			StringReader textReader = new StringReader(s);
			StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			int lineNumber = 1;
			ActionTextReaderLine(textReader, stringWriter, delegate(TextWriter tw, string line)
			{
				tw.Write(lineNumber.ToString(CultureInfo.InvariantCulture).PadLeft(4));
				tw.Write(". ");
				tw.Write(line);
				lineNumber++;
			});
			return stringWriter.ToString();
		}

		public static string NullEmptyString(string s)
		{
			return (!string.IsNullOrEmpty(s)) ? s : null;
		}

		public static string ReplaceNewLines(string s, string replacement)
		{
			StringReader stringReader = new StringReader(s);
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			string value;
			while ((value = stringReader.ReadLine()) != null)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					stringBuilder.Append(replacement);
				}
				stringBuilder.Append(value);
			}
			return stringBuilder.ToString();
		}

		public static string Truncate(string s, int maximumLength)
		{
			return Truncate(s, maximumLength, "...");
		}

		public static string Truncate(string s, int maximumLength, string suffix)
		{
			if (suffix == null)
			{
				throw new ArgumentNullException("suffix");
			}
			if (maximumLength <= 0)
			{
				throw new ArgumentException("Maximum length must be greater than zero.", "maximumLength");
			}
			int num = maximumLength - suffix.Length;
			if (num <= 0)
			{
				throw new ArgumentException("Length of suffix string is greater or equal to maximumLength");
			}
			if (s != null && s.Length > maximumLength)
			{
				string text = s.Substring(0, num);
				text = text.Trim();
				return text + suffix;
			}
			return s;
		}

		public static StringWriter CreateStringWriter(int capacity)
		{
			StringBuilder sb = new StringBuilder(capacity);
			return new StringWriter(sb, CultureInfo.InvariantCulture);
		}

		public static int? GetLength(string value)
		{
			return value?.Length;
		}

		public static string ToCharAsUnicode(char c)
		{
			char c2 = MathUtils.IntToHex(((int)c >> 12) & 0xF);
			char c3 = MathUtils.IntToHex(((int)c >> 8) & 0xF);
			char c4 = MathUtils.IntToHex(((int)c >> 4) & 0xF);
			char c5 = MathUtils.IntToHex(c & 0xF);
			return new string(new char[6] { '\\', 'u', c2, c3, c4, c5 });
		}

		public static void WriteCharAsUnicode(TextWriter writer, char c)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			char value = MathUtils.IntToHex(((int)c >> 12) & 0xF);
			char value2 = MathUtils.IntToHex(((int)c >> 8) & 0xF);
			char value3 = MathUtils.IntToHex(((int)c >> 4) & 0xF);
			char value4 = MathUtils.IntToHex(c & 0xF);
			writer.Write('\\');
			writer.Write('u');
			writer.Write(value);
			writer.Write(value2);
			writer.Write(value3);
			writer.Write(value4);
		}

		public static TSource ForgivingCaseSensitiveFind<TSource>(this IEnumerable<TSource> source, Func<TSource, string> valueSelector, string testValue)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (valueSelector == null)
			{
				throw new ArgumentNullException("valueSelector");
			}
			TSource[] array = System.Linq.Enumerable.ToArray(System.Linq.Enumerable.Where(source, (TSource s) => string.Compare(valueSelector(s), testValue, StringComparison.OrdinalIgnoreCase) == 0));
			int num = array.Length;
			if (num <= 1)
			{
				return (num != 1) ? default(TSource) : array[0];
			}
			IEnumerable<TSource> source2 = System.Linq.Enumerable.Where(source, (TSource s) => string.Compare(valueSelector(s), testValue, StringComparison.Ordinal) == 0);
			return System.Linq.Enumerable.SingleOrDefault(source2);
		}

		public static string ToCamelCase(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return s;
			}
			if (!char.IsUpper(s[0]))
			{
				return s;
			}
			string text = char.ToLower(s[0], CultureInfo.InvariantCulture).ToString(CultureInfo.InvariantCulture);
			if (s.Length > 1)
			{
				text += s.Substring(1);
			}
			return text;
		}
	}
	internal class ThreadSafeStore<TKey, TValue>
	{
		private readonly object _lock = new object();

		private Dictionary<TKey, TValue> _store;

		private readonly Func<TKey, TValue> _creator;

		public ThreadSafeStore(Func<TKey, TValue> creator)
		{
			if (creator == null)
			{
				throw new ArgumentNullException("creator");
			}
			_creator = creator;
		}

		public TValue Get(TKey key)
		{
			if (_store == null)
			{
				return AddValue(key);
			}
			if (!_store.TryGetValue(key, out var value))
			{
				return AddValue(key);
			}
			return value;
		}

		private TValue AddValue(TKey key)
		{
			TValue val = _creator(key);
			lock (_lock)
			{
				if (_store == null)
				{
					_store = new Dictionary<TKey, TValue>();
					_store[key] = val;
				}
				else
				{
					if (_store.TryGetValue(key, out var value))
					{
						return value;
					}
					Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>(_store);
					dictionary[key] = val;
					_store = dictionary;
				}
				return val;
			}
		}
	}
	internal static class ValidationUtils
	{
		public const string EmailAddressRegex = "^([a-zA-Z0-9_'+*$%\\^&!\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9:]{2,4})+$";

		public const string CurrencyRegex = "(^\\$?(?!0,?\\d)\\d{1,3}(,?\\d{3})*(\\.\\d\\d)?)$";

		public const string DateRegex = "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00|[048])))$";

		public const string NumericRegex = "\\d*";

		public static void ArgumentNotNullOrEmpty(string value, string parameterName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(parameterName);
			}
			if (value.Length == 0)
			{
				throw new ArgumentException("'{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture, parameterName), parameterName);
			}
		}

		public static void ArgumentNotNullOrEmptyOrWhitespace(string value, string parameterName)
		{
			ArgumentNotNullOrEmpty(value, parameterName);
			if (StringUtils.IsWhiteSpace(value))
			{
				throw new ArgumentException("'{0}' cannot only be whitespace.".FormatWith(CultureInfo.InvariantCulture, parameterName), parameterName);
			}
		}

		public static void ArgumentTypeIsEnum(Type enumType, string parameterName)
		{
			ArgumentNotNull(enumType, "enumType");
			if (!enumType.IsEnum)
			{
				throw new ArgumentException("Type {0} is not an Enum.".FormatWith(CultureInfo.InvariantCulture, enumType), parameterName);
			}
		}

		public static void ArgumentNotNullOrEmpty<T>(ICollection<T> collection, string parameterName)
		{
			ArgumentNotNullOrEmpty(collection, parameterName, "Collection '{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture, parameterName));
		}

		public static void ArgumentNotNullOrEmpty<T>(ICollection<T> collection, string parameterName, string message)
		{
			if (collection == null)
			{
				throw new ArgumentNullException(parameterName);
			}
			if (collection.Count == 0)
			{
				throw new ArgumentException(message, parameterName);
			}
		}

		public static void ArgumentNotNullOrEmpty(ICollection collection, string parameterName)
		{
			ArgumentNotNullOrEmpty(collection, parameterName, "Collection '{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture, parameterName));
		}

		public static void ArgumentNotNullOrEmpty(ICollection collection, string parameterName, string message)
		{
			if (collection == null)
			{
				throw new ArgumentNullException(parameterName);
			}
			if (collection.Count == 0)
			{
				throw new ArgumentException(message, parameterName);
			}
		}

		public static void ArgumentNotNull(object value, string parameterName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(parameterName);
			}
		}

		public static void ArgumentNotNegative(int value, string parameterName)
		{
			if (value <= 0)
			{
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException(parameterName, value, "Argument cannot be negative.");
			}
		}

		public static void ArgumentNotNegative(int value, string parameterName, string message)
		{
			if (value <= 0)
			{
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException(parameterName, value, message);
			}
		}

		public static void ArgumentNotZero(int value, string parameterName)
		{
			if (value == 0)
			{
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException(parameterName, value, "Argument cannot be zero.");
			}
		}

		public static void ArgumentNotZero(int value, string parameterName, string message)
		{
			if (value == 0)
			{
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException(parameterName, value, message);
			}
		}

		public static void ArgumentIsPositive<T>(T value, string parameterName) where T : struct, IComparable<T>
		{
			if (value.CompareTo(default(T)) != 1)
			{
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException(parameterName, value, "Positive number required.");
			}
		}

		public static void ArgumentIsPositive(int value, string parameterName, string message)
		{
			if (value > 0)
			{
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException(parameterName, value, message);
			}
		}

		public static void ObjectNotDisposed(bool disposed, Type objectType)
		{
			if (disposed)
			{
				throw new ObjectDisposedException(objectType.Name);
			}
		}

		public static void ArgumentConditionTrue(bool condition, string parameterName, string message)
		{
			if (!condition)
			{
				throw new ArgumentException(message, parameterName);
			}
		}
	}
}
namespace Ionic.Crc
{
	[Guid("ebc25cf6-9120-4283-b972-0e5520d0000C")]
	[ComVisible(true)]
	[ClassInterface(ClassInterfaceType.AutoDispatch)]
	public class CRC32
	{
		private uint dwPolynomial;

		private long _TotalBytesRead;

		private bool reverseBits;

		private uint[] crc32Table;

		private const int BUFFER_SIZE = 8192;

		private uint _register = uint.MaxValue;

		public long TotalBytesRead => _TotalBytesRead;

		public int Crc32Result => (int)(~_register);

		public CRC32()
			: this(reverseBits: false)
		{
		}

		public CRC32(bool reverseBits)
			: this(-306674912, reverseBits)
		{
		}

		public CRC32(int polynomial, bool reverseBits)
		{
			this.reverseBits = reverseBits;
			dwPolynomial = (uint)polynomial;
			GenerateLookupTable();
		}

		public int GetCrc32(Stream input)
		{
			return GetCrc32AndCopy(input, null);
		}

		public int GetCrc32AndCopy(Stream input, Stream output)
		{
			if (input == null)
			{
				throw new Exception("The input stream must not be null.");
			}
			byte[] array = new byte[8192];
			int count = 8192;
			_TotalBytesRead = 0L;
			int num = input.Read(array, 0, count);
			output?.Write(array, 0, num);
			_TotalBytesRead += num;
			while (num > 0)
			{
				SlurpBlock(array, 0, num);
				num = input.Read(array, 0, count);
				output?.Write(array, 0, num);
				_TotalBytesRead += num;
			}
			return (int)(~_register);
		}

		public int ComputeCrc32(int W, byte B)
		{
			return _InternalComputeCrc32((uint)W, B);
		}

		internal int _InternalComputeCrc32(uint W, byte B)
		{
			return (int)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
		}

		public void SlurpBlock(byte[] block, int offset, int count)
		{
			if (block == null)
			{
				throw new Exception("The data buffer must not be null.");
			}
			for (int i = 0; i < count; i++)
			{
				int num = offset + i;
				byte b = block[num];
				if (reverseBits)
				{
					uint num2 = (_register >> 24) ^ b;
					_register = (_register << 8) ^ crc32Table[num2];
				}
				else
				{
					uint num3 = (_register & 0xFFu) ^ b;
					_register = (_register >> 8) ^ crc32Table[num3];
				}
			}
			_TotalBytesRead += count;
		}

		public void UpdateCRC(byte b)
		{
			if (reverseBits)
			{
				uint num = (_register >> 24) ^ b;
				_register = (_register << 8) ^ crc32Table[num];
			}
			else
			{
				uint num2 = (_register & 0xFFu) ^ b;
				_register = (_register >> 8) ^ crc32Table[num2];
			}
		}

		public void UpdateCRC(byte b, int n)
		{
			while (n-- > 0)
			{
				if (reverseBits)
				{
					uint num = (_register >> 24) ^ b;
					_register = (_register << 8) ^ crc32Table[(num < 0) ? (num + 256) : num];
				}
				else
				{
					uint num2 = (_register & 0xFFu) ^ b;
					_register = (_register >> 8) ^ crc32Table[(num2 < 0) ? (num2 + 256) : num2];
				}
			}
		}

		private static uint ReverseBits(uint data)
		{
			uint num = data;
			num = ((num & 0x55555555) << 1) | ((num >> 1) & 0x55555555u);
			num = ((num & 0x33333333) << 2) | ((num >> 2) & 0x33333333u);
			num = ((num & 0xF0F0F0F) << 4) | ((num >> 4) & 0xF0F0F0Fu);
			return (num << 24) | ((num & 0xFF00) << 8) | ((num >> 8) & 0xFF00u) | (num >> 24);
		}

		private static byte ReverseBits(byte data)
		{
			uint num = (uint)(data * 131586);
			uint num2 = 17055760u;
			uint num3 = num & num2;
			uint num4 = (num << 2) & (num2 << 1);
			return (byte)(16781313 * (num3 + num4) >> 24);
		}

		private void GenerateLookupTable()
		{
			crc32Table = new uint[256];
			byte b = 0;
			do
			{
				uint num = b;
				for (byte b2 = 8; b2 > 0; b2--)
				{
					num = (((num & 1) != 1) ? (num >> 1) : ((num >> 1) ^ dwPolynomial));
				}
				if (reverseBits)
				{
					crc32Table[ReverseBits(b)] = ReverseBits(num);
				}
				else
				{
					crc32Table[b] = num;
				}
				b++;
			}
			while (b != 0);
		}

		private uint gf2_matrix_times(uint[] matrix, uint vec)
		{
			uint num = 0u;
			int num2 = 0;
			while (vec != 0)
			{
				if ((vec & 1) == 1)
				{
					num ^= matrix[num2];
				}
				vec >>= 1;
				num2++;
			}
			return num;
		}

		private void gf2_matrix_square(uint[] square, uint[] mat)
		{
			for (int i = 0; i < 32; i++)
			{
				square[i] = gf2_matrix_times(mat, mat[i]);
			}
		}

		public void Combine(int crc, int length)
		{
			uint[] array = new uint[32];
			uint[] array2 = new uint[32];
			if (length == 0)
			{
				return;
			}
			uint num = ~_register;
			array2[0] = dwPolynomial;
			uint num2 = 1u;
			for (int i = 1; i < 32; i++)
			{
				array2[i] = num2;
				num2 <<= 1;
			}
			gf2_matrix_square(array, array2);
			gf2_matrix_square(array2, array);
			uint num3 = (uint)length;
			do
			{
				gf2_matrix_square(array, array2);
				if ((num3 & 1) == 1)
				{
					num = gf2_matrix_times(array, num);
				}
				num3 >>= 1;
				if (num3 == 0)
				{
					break;
				}
				gf2_matrix_square(array2, array);
				if ((num3 & 1) == 1)
				{
					num = gf2_matrix_times(array2, num);
				}
				num3 >>= 1;
			}
			while (num3 != 0);
			num ^= (uint)crc;
			_register = ~num;
		}

		public void Reset()
		{
			_register = uint.MaxValue;
		}
	}
	public class CrcCalculatorStream : Stream, IDisposable
	{
		private static readonly long UnsetLengthLimit = -99L;

		internal Stream _innerStream;

		private CRC32 _Crc32;

		private long _lengthLimit = -99L;

		private bool _leaveOpen;

		public long TotalBytesSlurped => _Crc32.TotalBytesRead;

		public int Crc => _Crc32.Crc32Result;

		public bool LeaveOpen
		{
			get
			{
				return _leaveOpen;
			}
			set
			{
				_leaveOpen = value;
			}
		}

		public override bool CanRead => _innerStream.CanRead;

		public override bool CanSeek => false;

		public override bool CanWrite => _innerStream.CanWrite;

		public override long Length
		{
			get
			{
				if (_lengthLimit == UnsetLengthLimit)
				{
					return _innerStream.Length;
				}
				return _lengthLimit;
			}
		}

		public override long Position
		{
			get
			{
				return _Crc32.TotalBytesRead;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public CrcCalculatorStream(Stream stream)
			: this(leaveOpen: true, UnsetLengthLimit, stream, null)
		{
		}

		public CrcCalculatorStream(Stream stream, bool leaveOpen)
			: this(leaveOpen, UnsetLengthLimit, stream, null)
		{
		}

		public CrcCalculatorStream(Stream stream, long length)
			: this(leaveOpen: true, length, stream, null)
		{
			if (length < 0)
			{
				throw new ArgumentException("length");
			}
		}

		public CrcCalculatorStream(Stream stream, long length, bool leaveOpen)
			: this(leaveOpen, length, stream, null)
		{
			if (length < 0)
			{
				throw new ArgumentException("length");
			}
		}

		public CrcCalculatorStream(Stream stream, long length, bool leaveOpen, CRC32 crc32)
			: this(leaveOpen, length, stream, crc32)
		{
			if (length < 0)
			{
				throw new ArgumentException("length");
			}
		}

		private CrcCalculatorStream(bool leaveOpen, long length, Stream stream, CRC32 crc32)
		{
			_innerStream = stream;
			_Crc32 = crc32 ?? new CRC32();
			_lengthLimit = length;
			_leaveOpen = leaveOpen;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			int count2 = count;
			if (_lengthLimit != UnsetLengthLimit)
			{
				if (_Crc32.TotalBytesRead >= _lengthLimit)
				{
					return 0;
				}
				long num = _lengthLimit - _Crc32.TotalBytesRead;
				if (num < count)
				{
					count2 = (int)num;
				}
			}
			int num2 = _innerStream.Read(buffer, offset, count2);
			if (num2 > 0)
			{
				_Crc32.SlurpBlock(buffer, offset, num2);
			}
			return num2;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (count > 0)
			{
				_Crc32.SlurpBlock(buffer, offset, count);
			}
			_innerStream.Write(buffer, offset, count);
		}

		public override void Flush()
		{
			_innerStream.Flush();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		void IDisposable.Dispose()
		{
			Close();
		}

		public override void Close()
		{
			base.Close();
			if (!_leaveOpen)
			{
				_innerStream.Close();
			}
		}
	}
}
namespace Ionic.Zlib
{
	internal enum BlockState
	{
		NeedMore,
		BlockDone,
		FinishStarted,
		FinishDone
	}
	internal enum DeflateFlavor
	{
		Store,
		Fast,
		Slow
	}
	internal sealed class DeflateManager
	{
		internal delegate BlockState CompressFunc(FlushType flush);

		internal class Config
		{
			internal int GoodLength;

			internal int MaxLazy;

			internal int NiceLength;

			internal int MaxChainLength;

			internal DeflateFlavor Flavor;

			private static readonly Config[] Table;

			private Config(int goodLength, int maxLazy, int niceLength, int maxChainLength, DeflateFlavor flavor)
			{
				GoodLength = goodLength;
				MaxLazy = maxLazy;
				NiceLength = niceLength;
				MaxChainLength = maxChainLength;
				Flavor = flavor;
			}

			static Config()
			{
				Table = new Config[10]
				{
					new Config(0, 0, 0, 0, DeflateFlavor.Store),
					new Config(4, 4, 8, 4, DeflateFlavor.Fast),
					new Config(4, 5, 16, 8, DeflateFlavor.Fast),
					new Config(4, 6, 32, 32, DeflateFlavor.Fast),
					new Config(4, 4, 16, 16, DeflateFlavor.Slow),
					new Config(8, 16, 32, 32, DeflateFlavor.Slow),
					new Config(8, 16, 128, 128, DeflateFlavor.Slow),
					new Config(8, 32, 128, 256, DeflateFlavor.Slow),
					new Config(32, 128, 258, 1024, DeflateFlavor.Slow),
					new Config(32, 258, 258, 4096, DeflateFlavor.Slow)
				};
			}

			public static Config Lookup(CompressionLevel level)
			{
				return Table[(int)level];
			}
		}

		private static readonly int MEM_LEVEL_MAX = 9;

		private static readonly int MEM_LEVEL_DEFAULT = 8;

		private CompressFunc DeflateFunction;

		private static readonly string[] _ErrorMessage = new string[10]
		{
			"need dictionary",
			"stream end",
			string.Empty,
			"file error",
			"stream error",
			"data error",
			"insufficient memory",
			"buffer error",
			"incompatible version",
			string.Empty
		};

		private static readonly int PRESET_DICT = 32;

		private static readonly int INIT_STATE = 42;

		private static readonly int BUSY_STATE = 113;

		private static readonly int FINISH_STATE = 666;

		private static readonly int Z_DEFLATED = 8;

		private static readonly int STORED_BLOCK = 0;

		private static readonly int STATIC_TREES = 1;

		private static readonly int DYN_TREES = 2;

		private static readonly int Z_BINARY = 0;

		private static readonly int Z_ASCII = 1;

		private static readonly int Z_UNKNOWN = 2;

		private static readonly int Buf_size = 16;

		private static readonly int MIN_MATCH = 3;

		private static readonly int MAX_MATCH = 258;

		private static readonly int MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

		private static readonly int HEAP_SIZE = 2 * InternalConstants.L_CODES + 1;

		private static readonly int END_BLOCK = 256;

		internal ZlibCodec _codec;

		internal int status;

		internal byte[] pending;

		internal int nextPending;

		internal int pendingCount;

		internal sbyte data_type;

		internal int last_flush;

		internal int w_size;

		internal int w_bits;

		internal int w_mask;

		internal byte[] window;

		internal int window_size;

		internal short[] prev;

		internal short[] head;

		internal int ins_h;

		internal int hash_size;

		internal int hash_bits;

		internal int hash_mask;

		internal int hash_shift;

		internal int block_start;

		private Config config;

		internal int match_length;

		internal int prev_match;

		internal int match_available;

		internal int strstart;

		internal int match_start;

		internal int lookahead;

		internal int prev_length;

		internal CompressionLevel compressionLevel;

		internal CompressionStrategy compressionStrategy;

		internal short[] dyn_ltree;

		internal short[] dyn_dtree;

		internal short[] bl_tree;

		internal ZTree treeLiterals = new ZTree();

		internal ZTree treeDistances = new ZTree();

		internal ZTree treeBitLengths = new ZTree();

		internal short[] bl_count = new short[InternalConstants.MAX_BITS + 1];

		internal int[] heap = new int[2 * InternalConstants.L_CODES + 1];

		internal int heap_len;

		internal int heap_max;

		internal sbyte[] depth = new sbyte[2 * InternalConstants.L_CODES + 1];

		internal int _lengthOffset;

		internal int lit_bufsize;

		internal int last_lit;

		internal int _distanceOffset;

		internal int opt_len;

		internal int static_len;

		internal int matches;

		internal int last_eob_len;

		internal short bi_buf;

		internal int bi_valid;

		private bool Rfc1950BytesEmitted;

		private bool _WantRfc1950HeaderBytes = true;

		internal bool WantRfc1950HeaderBytes
		{
			get
			{
				return _WantRfc1950HeaderBytes;
			}
			set
			{
				_WantRfc1950HeaderBytes = value;
			}
		}

		internal DeflateManager()
		{
			dyn_ltree = new short[HEAP_SIZE * 2];
			dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
			bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
		}

		private void _InitializeLazyMatch()
		{
			window_size = 2 * w_size;
			Array.Clear(head, 0, hash_size);
			config = Config.Lookup(compressionLevel);
			SetDeflater();
			strstart = 0;
			block_start = 0;
			lookahead = 0;
			match_length = (prev_length = MIN_MATCH - 1);
			match_available = 0;
			ins_h = 0;
		}

		private void _InitializeTreeData()
		{
			treeLiterals.dyn_tree = dyn_ltree;
			treeLiterals.staticTree = StaticTree.Literals;
			treeDistances.dyn_tree = dyn_dtree;
			treeDistances.staticTree = StaticTree.Distances;
			treeBitLengths.dyn_tree = bl_tree;
			treeBitLengths.staticTree = StaticTree.BitLengths;
			bi_buf = 0;
			bi_valid = 0;
			last_eob_len = 8;
			_InitializeBlocks();
		}

		internal void _InitializeBlocks()
		{
			for (int i = 0; i < InternalConstants.L_CODES; i++)
			{
				dyn_ltree[i * 2] = 0;
			}
			for (int j = 0; j < InternalConstants.D_CODES; j++)
			{
				dyn_dtree[j * 2] = 0;
			}
			for (int k = 0; k < InternalConstants.BL_CODES; k++)
			{
				bl_tree[k * 2] = 0;
			}
			dyn_ltree[END_BLOCK * 2] = 1;
			opt_len = (static_len = 0);
			last_lit = (matches = 0);
		}

		internal void pqdownheap(short[] tree, int k)
		{
			int num = heap[k];
			for (int num2 = k << 1; num2 <= heap_len; num2 <<= 1)
			{
				if (num2 < heap_len && _IsSmaller(tree, heap[num2 + 1], heap[num2], depth))
				{
					num2++;
				}
				if (_IsSmaller(tree, num, heap[num2], depth))
				{
					break;
				}
				heap[k] = heap[num2];
				k = num2;
			}
			heap[k] = num;
		}

		internal static bool _IsSmaller(short[] tree, int n, int m, sbyte[] depth)
		{
			short num = tree[n * 2];
			short num2 = tree[m * 2];
			return num < num2 || (num == num2 && depth[n] <= depth[m]);
		}

		internal void scan_tree(short[] tree, int max_code)
		{
			int num = -1;
			int num2 = tree[1];
			int num3 = 0;
			int num4 = 7;
			int num5 = 4;
			if (num2 == 0)
			{
				num4 = 138;
				num5 = 3;
			}
			tree[(max_code + 1) * 2 + 1] = short.MaxValue;
			for (int i = 0; i <= max_code; i++)
			{
				int num6 = num2;
				num2 = tree[(i + 1) * 2 + 1];
				if (++num3 < num4 && num6 == num2)
				{
					continue;
				}
				if (num3 < num5)
				{
					bl_tree[num6 * 2] = (short)(bl_tree[num6 * 2] + num3);
				}
				else if (num6 != 0)
				{
					if (num6 != num)
					{
						bl_tree[num6 * 2]++;
					}
					bl_tree[InternalConstants.REP_3_6 * 2]++;
				}
				else if (num3 <= 10)
				{
					bl_tree[InternalConstants.REPZ_3_10 * 2]++;
				}
				else
				{
					bl_tree[InternalConstants.REPZ_11_138 * 2]++;
				}
				num3 = 0;
				num = num6;
				if (num2 == 0)
				{
					num4 = 138;
					num5 = 3;
				}
				else if (num6 == num2)
				{
					num4 = 6;
					num5 = 3;
				}
				else
				{
					num4 = 7;
					num5 = 4;
				}
			}
		}

		internal int build_bl_tree()
		{
			scan_tree(dyn_ltree, treeLiterals.max_code);
			scan_tree(dyn_dtree, treeDistances.max_code);
			treeBitLengths.build_tree(this);
			int num = InternalConstants.BL_CODES - 1;
			while (num >= 3 && bl_tree[ZTree.bl_order[num] * 2 + 1] == 0)
			{
				num--;
			}
			opt_len += 3 * (num + 1) + 5 + 5 + 4;
			return num;
		}

		internal void send_all_trees(int lcodes, int dcodes, int blcodes)
		{
			send_bits(lcodes - 257, 5);
			send_bits(dcodes - 1, 5);
			send_bits(blcodes - 4, 4);
			for (int i = 0; i < blcodes; i++)
			{
				send_bits(bl_tree[ZTree.bl_order[i] * 2 + 1], 3);
			}
			send_tree(dyn_ltree, lcodes - 1);
			send_tree(dyn_dtree, dcodes - 1);
		}

		internal void send_tree(short[] tree, int max_code)
		{
			int num = -1;
			int num2 = tree[1];
			int num3 = 0;
			int num4 = 7;
			int num5 = 4;
			if (num2 == 0)
			{
				num4 = 138;
				num5 = 3;
			}
			for (int i = 0; i <= max_code; i++)
			{
				int num6 = num2;
				num2 = tree[(i + 1) * 2 + 1];
				if (++num3 < num4 && num6 == num2)
				{
					continue;
				}
				if (num3 < num5)
				{
					do
					{
						send_code(num6, bl_tree);
					}
					while (--num3 != 0);
				}
				else if (num6 != 0)
				{
					if (num6 != num)
					{
						send_code(num6, bl_tree);
						num3--;
					}
					send_code(InternalConstants.REP_3_6, bl_tree);
					send_bits(num3 - 3, 2);
				}
				else if (num3 <= 10)
				{
					send_code(InternalConstants.REPZ_3_10, bl_tree);
					send_bits(num3 - 3, 3);
				}
				else
				{
					send_code(InternalConstants.REPZ_11_138, bl_tree);
					send_bits(num3 - 11, 7);
				}
				num3 = 0;
				num = num6;
				if (num2 == 0)
				{
					num4 = 138;
					num5 = 3;
				}
				else if (num6 == num2)
				{
					num4 = 6;
					num5 = 3;
				}
				else
				{
					num4 = 7;
					num5 = 4;
				}
			}
		}

		private void put_bytes(byte[] p, int start, int len)
		{
			Array.Copy(p, start, pending, pendingCount, len);
			pendingCount += len;
		}

		internal void send_code(int c, short[] tree)
		{
			int num = c * 2;
			send_bits(tree[num] & 0xFFFF, tree[num + 1] & 0xFFFF);
		}

		internal void send_bits(int value, int length)
		{
			if (bi_valid > Buf_size - length)
			{
				bi_buf |= (short)((value << bi_valid) & 0xFFFF);
				pending[pendingCount++] = (byte)bi_buf;
				pending[pendingCount++] = (byte)(bi_buf >> 8);
				bi_buf = (short)(value >>> Buf_size - bi_valid);
				bi_valid += length - Buf_size;
			}
			else
			{
				bi_buf |= (short)((value << bi_valid) & 0xFFFF);
				bi_valid += length;
			}
		}

		internal void _tr_align()
		{
			send_bits(STATIC_TREES << 1, 3);
			send_code(END_BLOCK, StaticTree.lengthAndLiteralsTreeCodes);
			bi_flush();
			if (1 + last_eob_len + 10 - bi_valid < 9)
			{
				send_bits(STATIC_TREES << 1, 3);
				send_code(END_BLOCK, StaticTree.lengthAndLiteralsTreeCodes);
				bi_flush();
			}
			last_eob_len = 7;
		}

		internal bool _tr_tally(int dist, int lc)
		{
			pending[_distanceOffset + last_lit * 2] = (byte)((uint)dist >> 8);
			pending[_distanceOffset + last_lit * 2 + 1] = (byte)dist;
			pending[_lengthOffset + last_lit] = (byte)lc;
			last_lit++;
			if (dist == 0)
			{
				dyn_ltree[lc * 2]++;
			}
			else
			{
				matches++;
				dist--;
				dyn_ltree[(ZTree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;
				dyn_dtree[ZTree.DistanceCode(dist) * 2]++;
			}
			if ((last_lit & 0x1FFF) == 0 && compressionLevel > CompressionLevel.Level2)
			{
				int num = last_lit << 3;
				int num2 = strstart - block_start;
				for (int i = 0; i < InternalConstants.D_CODES; i++)
				{
					num = (int)(num + dyn_dtree[i * 2] * (5L + (long)ZTree.ExtraDistanceBits[i]));
				}
				num >>= 3;
				if (matches < last_lit / 2 && num < num2 / 2)
				{
					return true;
				}
			}
			return last_lit == lit_bufsize - 1 || last_lit == lit_bufsize;
		}

		internal void send_compressed_block(short[] ltree, short[] dtree)
		{
			int num = 0;
			if (last_lit != 0)
			{
				do
				{
					int num2 = _distanceOffset + num * 2;
					int num3 = ((pending[num2] << 8) & 0xFF00) | (pending[num2 + 1] & 0xFF);
					int num4 = pending[_lengthOffset + num] & 0xFF;
					num++;
					if (num3 == 0)
					{
						send_code(num4, ltree);
						continue;
					}
					int num5 = ZTree.LengthCode[num4];
					send_code(num5 + InternalConstants.LITERALS + 1, ltree);
					int num6 = ZTree.ExtraLengthBits[num5];
					if (num6 != 0)
					{
						num4 -= ZTree.LengthBase[num5];
						send_bits(num4, num6);
					}
					num3--;
					num5 = ZTree.DistanceCode(num3);
					send_code(num5, dtree);
					num6 = ZTree.ExtraDistanceBits[num5];
					if (num6 != 0)
					{
						num3 -= ZTree.DistanceBase[num5];
						send_bits(num3, num6);
					}
				}
				while (num < last_lit);
			}
			send_code(END_BLOCK, ltree);
			last_eob_len = ltree[END_BLOCK * 2 + 1];
		}

		internal void set_data_type()
		{
			int i = 0;
			int num = 0;
			int num2 = 0;
			for (; i < 7; i++)
			{
				num2 += dyn_ltree[i * 2];
			}
			for (; i < 128; i++)
			{
				num += dyn_ltree[i * 2];
			}
			for (; i < InternalConstants.LITERALS; i++)
			{
				num2 += dyn_ltree[i * 2];
			}
			data_type = (sbyte)((num2 <= num >> 2) ? Z_ASCII : Z_BINARY);
		}

		internal void bi_flush()
		{
			if (bi_valid == 16)
			{
				pending[pendingCount++] = (byte)bi_buf;
				pending[pendingCount++] = (byte)(bi_buf >> 8);
				bi_buf = 0;
				bi_valid = 0;
			}
			else if (bi_valid >= 8)
			{
				pending[pendingCount++] = (byte)bi_buf;
				bi_buf >>= 8;
				bi_valid -= 8;
			}
		}

		internal void bi_windup()
		{
			if (bi_valid > 8)
			{
				pending[pendingCount++] = (byte)bi_buf;
				pending[pendingCount++] = (byte)(bi_buf >> 8);
			}
			else if (bi_valid > 0)
			{
				pending[pendingCount++] = (byte)bi_buf;
			}
			bi_buf = 0;
			bi_valid = 0;
		}

		internal void copy_block(int buf, int len, bool header)
		{
			bi_windup();
			last_eob_len = 8;
			if (header)
			{
				pending[pendingCount++] = (byte)len;
				pending[pendingCount++] = (byte)(len >> 8);
				pending[pendingCount++] = (byte)(~len);
				pending[pendingCount++] = (byte)(~len >> 8);
			}
			put_bytes(window, buf, len);
		}

		internal void flush_block_only(bool eof)
		{
			_tr_flush_block((block_start < 0) ? (-1) : block_start, strstart - block_start, eof);
			block_start = strstart;
			_codec.flush_pending();
		}

		internal BlockState DeflateNone(FlushType flush)
		{
			int num = 65535;
			if (num > pending.Length - 5)
			{
				num = pending.Length - 5;
			}
			while (true)
			{
				if (lookahead <= 1)
				{
					_fillWindow();
					if (lookahead == 0 && flush == FlushType.None)
					{
						return BlockState.NeedMore;
					}
					if (lookahead == 0)
					{
						break;
					}
				}
				strstart += lookahead;
				lookahead = 0;
				int num2 = block_start + num;
				if (strstart == 0 || strstart >= num2)
				{
					lookahead = strstart - num2;
					strstart = num2;
					flush_block_only(eof: false);
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
				if (strstart - block_start >= w_size - MIN_LOOKAHEAD)
				{
					flush_block_only(eof: false);
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
			}
			flush_block_only(flush == FlushType.Finish);
			if (_codec.AvailableBytesOut == 0)
			{
				return (flush == FlushType.Finish) ? BlockState.FinishStarted : BlockState.NeedMore;
			}
			return (flush != FlushType.Finish) ? BlockState.BlockDone : BlockState.FinishDone;
		}

		internal void _tr_stored_block(int buf, int stored_len, bool eof)
		{
			send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3);
			copy_block(buf, stored_len, header: true);
		}

		internal void _tr_flush_block(int buf, int stored_len, bool eof)
		{
			int num = 0;
			int num2;
			int num3;
			if (compressionLevel > CompressionLevel.None)
			{
				if (data_type == Z_UNKNOWN)
				{
					set_data_type();
				}
				treeLiterals.build_tree(this);
				treeDistances.build_tree(this);
				num = build_bl_tree();
				num2 = opt_len + 3 + 7 >> 3;
				num3 = static_len + 3 + 7 >> 3;
				if (num3 <= num2)
				{
					num2 = num3;
				}
			}
			else
			{
				num2 = (num3 = stored_len + 5);
			}
			if (stored_len + 4 <= num2 && buf != -1)
			{
				_tr_stored_block(buf, stored_len, eof);
			}
			else if (num3 == num2)
			{
				send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
				send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes, StaticTree.distTreeCodes);
			}
			else
			{
				send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
				send_all_trees(treeLiterals.max_code + 1, treeDistances.max_code + 1, num + 1);
				send_compressed_block(dyn_ltree, dyn_dtree);
			}
			_InitializeBlocks();
			if (eof)
			{
				bi_windup();
			}
		}

		private void _fillWindow()
		{
			do
			{
				int num = window_size - lookahead - strstart;
				int num2;
				if (num == 0 && strstart == 0 && lookahead == 0)
				{
					num = w_size;
				}
				else if (num == -1)
				{
					num--;
				}
				else if (strstart >= w_size + w_size - MIN_LOOKAHEAD)
				{
					Array.Copy(window, w_size, window, 0, w_size);
					match_start -= w_size;
					strstart -= w_size;
					block_start -= w_size;
					num2 = hash_size;
					int num3 = num2;
					do
					{
						int num4 = head[--num3] & 0xFFFF;
						head[num3] = (short)((num4 >= w_size) ? (num4 - w_size) : 0);
					}
					while (--num2 != 0);
					num2 = w_size;
					num3 = num2;
					do
					{
						int num4 = prev[--num3] & 0xFFFF;
						prev[num3] = (short)((num4 >= w_size) ? (num4 - w_size) : 0);
					}
					while (--num2 != 0);
					num += w_size;
				}
				if (_codec.AvailableBytesIn == 0)
				{
					break;
				}
				num2 = _codec.read_buf(window, strstart + lookahead, num);
				lookahead += num2;
				if (lookahead >= MIN_MATCH)
				{
					ins_h = window[strstart] & 0xFF;
					ins_h = ((ins_h << hash_shift) ^ (window[strstart + 1] & 0xFF)) & hash_mask;
				}
			}
			while (lookahead < MIN_LOOKAHEAD && _codec.AvailableBytesIn != 0);
		}

		internal BlockState DeflateFast(FlushType flush)
		{
			int num = 0;
			while (true)
			{
				if (lookahead < MIN_LOOKAHEAD)
				{
					_fillWindow();
					if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)
					{
						return BlockState.NeedMore;
					}
					if (lookahead == 0)
					{
						break;
					}
				}
				if (lookahead >= MIN_MATCH)
				{
					ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
					num = head[ins_h] & 0xFFFF;
					prev[strstart & w_mask] = head[ins_h];
					head[ins_h] = (short)strstart;
				}
				if ((long)num != 0 && ((strstart - num) & 0xFFFF) <= w_size - MIN_LOOKAHEAD && compressionStrategy != CompressionStrategy.HuffmanOnly)
				{
					match_length = longest_match(num);
				}
				bool flag;
				if (match_length >= MIN_MATCH)
				{
					flag = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
					lookahead -= match_length;
					if (match_length <= config.MaxLazy && lookahead >= MIN_MATCH)
					{
						match_length--;
						do
						{
							strstart++;
							ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
							num = head[ins_h] & 0xFFFF;
							prev[strstart & w_mask] = head[ins_h];
							head[ins_h] = (short)strstart;
						}
						while (--match_length != 0);
						strstart++;
					}
					else
					{
						strstart += match_length;
						match_length = 0;
						ins_h = window[strstart] & 0xFF;
						ins_h = ((ins_h << hash_shift) ^ (window[strstart + 1] & 0xFF)) & hash_mask;
					}
				}
				else
				{
					flag = _tr_tally(0, window[strstart] & 0xFF);
					lookahead--;
					strstart++;
				}
				if (flag)
				{
					flush_block_only(eof: false);
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
			}
			flush_block_only(flush == FlushType.Finish);
			if (_codec.AvailableBytesOut == 0)
			{
				if (flush == FlushType.Finish)
				{
					return BlockState.FinishStarted;
				}
				return BlockState.NeedMore;
			}
			return (flush != FlushType.Finish) ? BlockState.BlockDone : BlockState.FinishDone;
		}

		internal BlockState DeflateSlow(FlushType flush)
		{
			int num = 0;
			while (true)
			{
				if (lookahead < MIN_LOOKAHEAD)
				{
					_fillWindow();
					if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)
					{
						return BlockState.NeedMore;
					}
					if (lookahead == 0)
					{
						break;
					}
				}
				if (lookahead >= MIN_MATCH)
				{
					ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
					num = head[ins_h] & 0xFFFF;
					prev[strstart & w_mask] = head[ins_h];
					head[ins_h] = (short)strstart;
				}
				prev_length = match_length;
				prev_match = match_start;
				match_length = MIN_MATCH - 1;
				if (num != 0 && prev_length < config.MaxLazy && ((strstart - num) & 0xFFFF) <= w_size - MIN_LOOKAHEAD)
				{
					if (compressionStrategy != CompressionStrategy.HuffmanOnly)
					{
						match_length = longest_match(num);
					}
					if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096)))
					{
						match_length = MIN_MATCH - 1;
					}
				}
				if (prev_length >= MIN_MATCH && match_length <= prev_length)
				{
					int num2 = strstart + lookahead - MIN_MATCH;
					bool flag = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
					lookahead -= prev_length - 1;
					prev_length -= 2;
					do
					{
						if (++strstart <= num2)
						{
							ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
							num = head[ins_h] & 0xFFFF;
							prev[strstart & w_mask] = head[ins_h];
							head[ins_h] = (short)strstart;
						}
					}
					while (--prev_length != 0);
					match_available = 0;
					match_length = MIN_MATCH - 1;
					strstart++;
					if (flag)
					{
						flush_block_only(eof: false);
						if (_codec.AvailableBytesOut == 0)
						{
							return BlockState.NeedMore;
						}
					}
				}
				else if (match_available != 0)
				{
					if (_tr_tally(0, window[strstart - 1] & 0xFF))
					{
						flush_block_only(eof: false);
					}
					strstart++;
					lookahead--;
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
				else
				{
					match_available = 1;
					strstart++;
					lookahead--;
				}
			}
			if (match_available != 0)
			{
				bool flag = _tr_tally(0, window[strstart - 1] & 0xFF);
				match_available = 0;
			}
			flush_block_only(flush == FlushType.Finish);
			if (_codec.AvailableBytesOut == 0)
			{
				if (flush == FlushType.Finish)
				{
					return BlockState.FinishStarted;
				}
				return BlockState.NeedMore;
			}
			return (flush != FlushType.Finish) ? BlockState.BlockDone : BlockState.FinishDone;
		}

		internal int longest_match(int cur_match)
		{
			int num = config.MaxChainLength;
			int num2 = strstart;
			int num3 = prev_length;
			int num4 = ((strstart > w_size - MIN_LOOKAHEAD) ? (strstart - (w_size - MIN_LOOKAHEAD)) : 0);
			int niceLength = config.NiceLength;
			int num5 = w_mask;
			int num6 = strstart + MAX_MATCH;
			byte b = window[num2 + num3 - 1];
			byte b2 = window[num2 + num3];
			if (prev_length >= config.GoodLength)
			{
				num >>= 2;
			}
			if (niceLength > lookahead)
			{
				niceLength = lookahead;
			}
			do
			{
				int num7 = cur_match;
				if (window[num7 + num3] != b2 || window[num7 + num3 - 1] != b || window[num7] != window[num2] || window[++num7] != window[num2 + 1])
				{
					continue;
				}
				num2 += 2;
				num7++;
				while (window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && num2 < num6)
				{
				}
				int num8 = MAX_MATCH - (num6 - num2);
				num2 = num6 - MAX_MATCH;
				if (num8 > num3)
				{
					match_start = cur_match;
					num3 = num8;
					if (num8 >= niceLength)
					{
						break;
					}
					b = window[num2 + num3 - 1];
					b2 = window[num2 + num3];
				}
			}
			while ((cur_match = prev[cur_match & num5] & 0xFFFF) > num4 && --num != 0);
			if (num3 <= lookahead)
			{
				return num3;
			}
			return lookahead;
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level)
		{
			return Initialize(codec, level, 15);
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits)
		{
			return Initialize(codec, level, bits, MEM_LEVEL_DEFAULT, CompressionStrategy.Default);
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits, CompressionStrategy compressionStrategy)
		{
			return Initialize(codec, level, bits, MEM_LEVEL_DEFAULT, compressionStrategy);
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy)
		{
			_codec = codec;
			_codec.Message = null;
			if (windowBits < 9 || windowBits > 15)
			{
				throw new ZlibException("windowBits must be in the range 9..15.");
			}
			if (memLevel < 1 || memLevel > MEM_LEVEL_MAX)
			{
				throw new ZlibException($"memLevel must be in the range 1.. {MEM_LEVEL_MAX}");
			}
			_codec.dstate = this;
			w_bits = windowBits;
			w_size = 1 << w_bits;
			w_mask = w_size - 1;
			hash_bits = memLevel + 7;
			hash_size = 1 << hash_bits;
			hash_mask = hash_size - 1;
			hash_shift = (hash_bits + MIN_MATCH - 1) / MIN_MATCH;
			window = new byte[w_size * 2];
			prev = new short[w_size];
			head = new short[hash_size];
			lit_bufsize = 1 << memLevel + 6;
			pending = new byte[lit_bufsize * 4];
			_distanceOffset = lit_bufsize;
			_lengthOffset = 3 * lit_bufsize;
			compressionLevel = level;
			compressionStrategy = strategy;
			Reset();
			return 0;
		}

		internal void Reset()
		{
			_codec.TotalBytesIn = (_codec.TotalBytesOut = 0L);
			_codec.Message = null;
			pendingCount = 0;
			nextPending = 0;
			Rfc1950BytesEmitted = false;
			status = ((!WantRfc1950HeaderBytes) ? BUSY_STATE : INIT_STATE);
			_codec._Adler32 = Adler.Adler32(0u, null, 0, 0);
			last_flush = 0;
			_InitializeTreeData();
			_InitializeLazyMatch();
		}

		internal int End()
		{
			if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE)
			{
				return -2;
			}
			pending = null;
			head = null;
			prev = null;
			window = null;
			return (status == BUSY_STATE) ? (-3) : 0;
		}

		private void SetDeflater()
		{
			switch (config.Flavor)
			{
			case DeflateFlavor.Store:
				DeflateFunction = DeflateNone;
				break;
			case DeflateFlavor.Fast:
				DeflateFunction = DeflateFast;
				break;
			case DeflateFlavor.Slow:
				DeflateFunction = DeflateSlow;
				break;
			}
		}

		internal int SetParams(CompressionLevel level, CompressionStrategy strategy)
		{
			int result = 0;
			if (compressionLevel != level)
			{
				Config config = Config.Lookup(level);
				if (config.Flavor != this.config.Flavor && _codec.TotalBytesIn != 0)
				{
					result = _codec.Deflate(FlushType.Partial);
				}
				compressionLevel = level;
				this.config = config;
				SetDeflater();
			}
			compressionStrategy = strategy;
			return result;
		}

		internal int SetDictionary(byte[] dictionary)
		{
			int num = dictionary.Length;
			int sourceIndex = 0;
			if (dictionary == null || status != INIT_STATE)
			{
				throw new ZlibException("Stream error.");
			}
			_codec._Adler32 = Adler.Adler32(_codec._Adler32, dictionary, 0, dictionary.Length);
			if (num < MIN_MATCH)
			{
				return 0;
			}
			if (num > w_size - MIN_LOOKAHEAD)
			{
				num = w_size - MIN_LOOKAHEAD;
				sourceIndex = dictionary.Length - num;
			}
			Array.Copy(dictionary, sourceIndex, window, 0, num);
			strstart = num;
			block_start = num;
			ins_h = window[0] & 0xFF;
			ins_h = ((ins_h << hash_shift) ^ (window[1] & 0xFF)) & hash_mask;
			for (int i = 0; i <= num - MIN_MATCH; i++)
			{
				ins_h = ((ins_h << hash_shift) ^ (window[i + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
				prev[i & w_mask] = head[ins_h];
				head[ins_h] = (short)i;
			}
			return 0;
		}

		internal int Deflate(FlushType flush)
		{
			if (_codec.OutputBuffer == null || (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) || (status == FINISH_STATE && flush != FlushType.Finish))
			{
				_codec.Message = _ErrorMessage[4];
				throw new ZlibException($"Something is fishy. [{_codec.Message}]");
			}
			if (_codec.AvailableBytesOut == 0)
			{
				_codec.Message = _ErrorMessage[7];
				throw new ZlibException("OutputBuffer is full (AvailableBytesOut == 0)");
			}
			int num = last_flush;
			last_flush = (int)flush;
			if (status == INIT_STATE)
			{
				int num2 = Z_DEFLATED + (w_bits - 8 << 4) << 8;
				int num3 = (int)((compressionLevel - 1) & (CompressionLevel)255) >> 1;
				if (num3 > 3)
				{
					num3 = 3;
				}
				num2 |= num3 << 6;
				if (strstart != 0)
				{
					num2 |= PRESET_DICT;
				}
				num2 += 31 - num2 % 31;
				status = BUSY_STATE;
				pending[pendingCount++] = (byte)(num2 >> 8);
				pending[pendingCount++] = (byte)num2;
				if (strstart != 0)
				{
					pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000u) >> 24);
					pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF0000) >> 16);
					pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF00) >> 8);
					pending[pendingCount++] = (byte)(_codec._Adler32 & 0xFFu);
				}
				_codec._Adler32 = Adler.Adler32(0u, null, 0, 0);
			}
			if (pendingCount != 0)
			{
				_codec.flush_pending();
				if (_codec.AvailableBytesOut == 0)
				{
					last_flush = -1;
					return 0;
				}
			}
			else if (_codec.AvailableBytesIn == 0 && (int)flush <= num && flush != FlushType.Finish)
			{
				return 0;
			}
			if (status == FINISH_STATE && _codec.AvailableBytesIn != 0)
			{
				_codec.Message = _ErrorMessage[7];
				throw new ZlibException("status == FINISH_STATE && _codec.AvailableBytesIn != 0");
			}
			if (_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != 0 && status != FINISH_STATE))
			{
				BlockState blockState = DeflateFunction(flush);
				if (blockState == BlockState.FinishStarted || blockState == BlockState.FinishDone)
				{
					status = FINISH_STATE;
				}
				switch (blockState)
				{
				case BlockState.NeedMore:
				case BlockState.FinishStarted:
					if (_codec.AvailableBytesOut == 0)
					{
						last_flush = -1;
					}
					return 0;
				case BlockState.BlockDone:
					if (flush == FlushType.Partial)
					{
						_tr_align();
					}
					else
					{
						_tr_stored_block(0, 0, eof: false);
						if (flush == FlushType.Full)
						{
							for (int i = 0; i < hash_size; i++)
							{
								head[i] = 0;
							}
						}
					}
					_codec.flush_pending();
					if (_codec.AvailableBytesOut == 0)
					{
						last_flush = -1;
						return 0;
					}
					break;
				}
			}
			if (flush != FlushType.Finish)
			{
				return 0;
			}
			if (!WantRfc1950HeaderBytes || Rfc1950BytesEmitted)
			{
				return 1;
			}
			pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000u) >> 24);
			pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF0000) >> 16);
			pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF00) >> 8);
			pending[pendingCount++] = (byte)(_codec._Adler32 & 0xFFu);
			_codec.flush_pending();
			Rfc1950BytesEmitted = true;
			return (pendingCount == 0) ? 1 : 0;
		}
	}
	public class DeflateStream : Stream
	{
		internal ZlibBaseStream _baseStream;

		internal Stream _innerStream;

		private bool _disposed;

		public virtual FlushType FlushMode
		{
			get
			{
				return _baseStream._flushMode;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				_baseStream._flushMode = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _baseStream._bufferSize;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				if (_baseStream._workingBuffer != null)
				{
					throw new ZlibException("The working buffer is already set.");
				}
				if (value < 1024)
				{
					throw new ZlibException($"Don't be silly. {value} bytes?? Use a bigger buffer, at least {1024}.");
				}
				_baseStream._bufferSize = value;
			}
		}

		public CompressionStrategy Strategy
		{
			get
			{
				return _baseStream.Strategy;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				_baseStream.Strategy = value;
			}
		}

		public virtual long TotalIn => _baseStream._z.TotalBytesIn;

		public virtual long TotalOut => _baseStream._z.TotalBytesOut;

		public override bool CanRead
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				return _baseStream._stream.CanRead;
			}
		}

		public override bool CanSeek => false;

		public override bool CanWrite
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				return _baseStream._stream.CanWrite;
			}
		}

		public override long Length
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override long Position
		{
			get
			{
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Writer)
				{
					return _baseStream._z.TotalBytesOut;
				}
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Reader)
				{
					return _baseStream._z.TotalBytesIn;
				}
				return 0L;
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		public DeflateStream(Stream stream, CompressionMode mode)
			: this(stream, mode, CompressionLevel.Default, leaveOpen: false)
		{
		}

		public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level)
			: this(stream, mode, level, leaveOpen: false)
		{
		}

		public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen)
			: this(stream, mode, CompressionLevel.Default, leaveOpen)
		{
		}

		public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen)
		{
			_innerStream = stream;
			_baseStream = new ZlibBaseStream(stream, mode, level, ZlibStreamFlavor.DEFLATE, leaveOpen);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!_disposed)
				{
					if (disposing && _baseStream != null)
					{
						_baseStream.Close();
					}
					_disposed = true;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("DeflateStream");
			}
			_baseStream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("DeflateStream");
			}
			return _baseStream.Read(buffer, offset, count);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotImplementedException();
		}

		public override void SetLength(long value)
		{
			throw new NotImplementedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("DeflateStream");
			}
			_baseStream.Write(buffer, offset, count);
		}

		public static byte[] CompressString(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new DeflateStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressString(s, compressor);
			return memoryStream.ToArray();
		}

		public static byte[] CompressBuffer(byte[] b)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new DeflateStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressBuffer(b, compressor);
			return memoryStream.ToArray();
		}

		public static string UncompressString(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new DeflateStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressString(compressed, decompressor);
		}

		public static byte[] UncompressBuffer(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new DeflateStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressBuffer(compressed, decompressor);
		}
	}
	public class GZipStream : Stream
	{
		public DateTime? LastModified;

		private int _headerByteCount;

		internal ZlibBaseStream _baseStream;

		private bool _disposed;

		private bool _firstReadDone;

		private string _FileName;

		private string _Comment;

		private int _Crc32;

		internal static readonly DateTime _unixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

		internal static readonly Encoding iso8859dash1 = Encoding.GetEncoding("iso-8859-1");

		public string Comment
		{
			get
			{
				return _Comment;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				_Comment = value;
			}
		}

		public string FileName
		{
			get
			{
				return _FileName;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				_FileName = value;
				if (_FileName != null)
				{
					if (_FileName.IndexOf("/") != -1)
					{
						_FileName = _FileName.Replace("/", "\\");
					}
					if (_FileName.EndsWith("\\"))
					{
						throw new Exception("Illegal filename");
					}
					if (_FileName.IndexOf("\\") != -1)
					{
						_FileName = Path.GetFileName(_FileName);
					}
				}
			}
		}

		public int Crc32 => _Crc32;

		public virtual FlushType FlushMode
		{
			get
			{
				return _baseStream._flushMode;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				_baseStream._flushMode = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _baseStream._bufferSize;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				if (_baseStream._workingBuffer != null)
				{
					throw new ZlibException("The working buffer is already set.");
				}
				if (value < 1024)
				{
					throw new ZlibException($"Don't be silly. {value} bytes?? Use a bigger buffer, at least {1024}.");
				}
				_baseStream._bufferSize = value;
			}
		}

		public virtual long TotalIn => _baseStream._z.TotalBytesIn;

		public virtual long TotalOut => _baseStream._z.TotalBytesOut;

		public override bool CanRead
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				return _baseStream._stream.CanRead;
			}
		}

		public override bool CanSeek => false;

		public override bool CanWrite
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				return _baseStream._stream.CanWrite;
			}
		}

		public override long Length
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override long Position
		{
			get
			{
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Writer)
				{
					return _baseStream._z.TotalBytesOut + _headerByteCount;
				}
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Reader)
				{
					return _baseStream._z.TotalBytesIn + _baseStream._gzipHeaderByteCount;
				}
				return 0L;
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		public GZipStream(Stream stream, CompressionMode mode)
			: this(stream, mode, CompressionLevel.Default, leaveOpen: false)
		{
		}

		public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level)
			: this(stream, mode, level, leaveOpen: false)
		{
		}

		public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen)
			: this(stream, mode, CompressionLevel.Default, leaveOpen)
		{
		}

		public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen)
		{
			_baseStream = new ZlibBaseStream(stream, mode, level, ZlibStreamFlavor.GZIP, leaveOpen);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!_disposed)
				{
					if (disposing && _baseStream != null)
					{
						_baseStream.Close();
						_Crc32 = _baseStream.Crc32;
					}
					_disposed = true;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("GZipStream");
			}
			_baseStream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("GZipStream");
			}
			int result = _baseStream.Read(buffer, offset, count);
			if (!_firstReadDone)
			{
				_firstReadDone = true;
				FileName = _baseStream._GzipFileName;
				Comment = _baseStream._GzipComment;
			}
			return result;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotImplementedException();
		}

		public override void SetLength(long value)
		{
			throw new NotImplementedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("GZipStream");
			}
			if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Undefined)
			{
				if (!_baseStream._wantCompress)
				{
					throw new InvalidOperationException();
				}
				_headerByteCount = EmitHeader();
			}
			_baseStream.Write(buffer, offset, count);
		}

		private int EmitHeader()
		{
			byte[] array = ((Comment != null) ? iso8859dash1.GetBytes(Comment) : null);
			byte[] array2 = ((FileName != null) ? iso8859dash1.GetBytes(FileName) : null);
			int num = ((Comment != null) ? (array.Length + 1) : 0);
			int num2 = ((FileName != null) ? (array2.Length + 1) : 0);
			int num3 = 10 + num + num2;
			byte[] array3 = new byte[num3];
			int num4 = 0;
			array3[num4++] = 31;
			array3[num4++] = 139;
			array3[num4++] = 8;
			byte b = 0;
			if (Comment != null)
			{
				b = (byte)(b ^ 0x10u);
			}
			if (FileName != null)
			{
				b = (byte)(b ^ 8u);
			}
			array3[num4++] = b;
			if (!LastModified.HasValue)
			{
				LastModified = DateTime.Now;
			}
			int value = (int)(LastModified.Value - _unixEpoch).TotalSeconds;
			Array.Copy(BitConverter.GetBytes(value), 0, array3, num4, 4);
			num4 += 4;
			array3[num4++] = 0;
			array3[num4++] = byte.MaxValue;
			if (num2 != 0)
			{
				Array.Copy(array2, 0, array3, num4, num2 - 1);
				num4 += num2 - 1;
				array3[num4++] = 0;
			}
			if (num != 0)
			{
				Array.Copy(array, 0, array3, num4, num - 1);
				num4 += num - 1;
				array3[num4++] = 0;
			}
			_baseStream._stream.Write(array3, 0, array3.Length);
			return array3.Length;
		}

		public static byte[] CompressString(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new GZipStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressString(s, compressor);
			return memoryStream.ToArray();
		}

		public static byte[] CompressBuffer(byte[] b)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new GZipStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressBuffer(b, compressor);
			return memoryStream.ToArray();
		}

		public static string UncompressString(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new GZipStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressString(compressed, decompressor);
		}

		public static byte[] UncompressBuffer(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new GZipStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressBuffer(compressed, decompressor);
		}
	}
	internal sealed class InfTree
	{
		private const int MANY = 1440;

		private const int Z_OK = 0;

		private const int Z_STREAM_END = 1;

		private const int Z_NEED_DICT = 2;

		private const int Z_ERRNO = -1;

		private const int Z_STREAM_ERROR = -2;

		private const int Z_DATA_ERROR = -3;

		private const int Z_MEM_ERROR = -4;

		private const int Z_BUF_ERROR = -5;

		private const int Z_VERSION_ERROR = -6;

		internal const int fixed_bl = 9;

		internal const int fixed_bd = 5;

		internal static readonly int[] fixed_tl = new int[1536]
		{
			96, 7, 256, 0, 8, 80, 0, 8, 16, 84,
			8, 115, 82, 7, 31, 0, 8, 112, 0, 8,
			48, 0, 9, 192, 80, 7, 10, 0, 8, 96,
			0, 8, 32, 0, 9, 160, 0, 8, 0, 0,
			8, 128, 0, 8, 64, 0, 9, 224, 80, 7,
			6, 0, 8, 88, 0, 8, 24, 0, 9, 144,
			83, 7, 59, 0, 8, 120, 0, 8, 56, 0,
			9, 208, 81, 7, 17, 0, 8, 104, 0, 8,
			40, 0, 9, 176, 0, 8, 8, 0, 8, 136,
			0, 8, 72, 0, 9, 240, 80, 7, 4, 0,
			8, 84, 0, 8, 20, 85, 8, 227, 83, 7,
			43, 0, 8, 116, 0, 8, 52, 0, 9, 200,
			81, 7, 13, 0, 8, 100, 0, 8, 36, 0,
			9, 168, 0, 8, 4, 0, 8, 132, 0, 8,
			68, 0, 9, 232, 80, 7, 8, 0, 8, 92,
			0, 8, 28, 0, 9, 152, 84, 7, 83, 0,
			8, 124, 0, 8, 60, 0, 9, 216, 82, 7,
			23, 0, 8, 108, 0, 8, 44, 0, 9, 184,
			0, 8, 12, 0, 8, 140, 0, 8, 76, 0,
			9, 248, 80, 7, 3, 0, 8, 82, 0, 8,
			18, 85, 8, 163, 83, 7, 35, 0, 8, 114,
			0, 8, 50, 0, 9, 196, 81, 7, 11, 0,
			8, 98, 0, 8, 34, 0, 9, 164, 0, 8,
			2, 0, 8, 130, 0, 8, 66, 0, 9, 228,
			80, 7, 7, 0, 8, 90, 0, 8, 26, 0,
			9, 148, 84, 7, 67, 0, 8, 122, 0, 8,
			58, 0, 9, 212, 82, 7, 19, 0, 8, 106,
			0, 8, 42, 0, 9, 180, 0, 8, 10, 0,
			8, 138, 0, 8, 74, 0, 9, 244, 80, 7,
			5, 0, 8, 86, 0, 8, 22, 192, 8, 0,
			83, 7, 51, 0, 8, 118, 0, 8, 54, 0,
			9, 204, 81, 7, 15, 0, 8, 102, 0, 8,
			38, 0, 9, 172, 0, 8, 6, 0, 8, 134,
			0, 8, 70, 0, 9, 236, 80, 7, 9, 0,
			8, 94, 0, 8, 30, 0, 9, 156, 84, 7,
			99, 0, 8, 126, 0, 8, 62, 0, 9, 220,
			82, 7, 27, 0, 8, 110, 0, 8, 46, 0,
			9, 188, 0, 8, 14, 0, 8, 142, 0, 8,
			78, 0, 9, 252, 96, 7, 256, 0, 8, 81,
			0, 8, 17, 85, 8, 131, 82, 7, 31, 0,
			8, 113, 0, 8, 49, 0, 9, 194, 80, 7,
			10, 0, 8, 97, 0, 8, 33, 0, 9, 162,
			0, 8, 1, 0, 8, 129, 0, 8, 65, 0,
			9, 226, 80, 7, 6, 0, 8, 89, 0, 8,
			25, 0, 9, 146, 83, 7, 59, 0, 8, 121,
			0, 8, 57, 0, 9, 210, 81, 7, 17, 0,
			8, 105, 0, 8, 41, 0, 9, 178, 0, 8,
			9, 0, 8, 137, 0, 8, 73, 0, 9, 242,
			80, 7, 4, 0, 8, 85, 0, 8, 21, 80,
			8, 258, 83, 7, 43, 0, 8, 117, 0, 8,
			53, 0, 9, 202, 81, 7, 13, 0, 8, 101,
			0, 8, 37, 0, 9, 170, 0, 8, 5, 0,
			8, 133, 0, 8, 69, 0, 9, 234, 80, 7,
			8, 0, 8, 93, 0, 8, 29, 0, 9, 154,
			84, 7, 83, 0, 8, 125, 0, 8, 61, 0,
			9, 218, 82, 7, 23, 0, 8, 109, 0, 8,
			45, 0, 9, 186, 0, 8, 13, 0, 8, 141,
			0, 8, 77, 0, 9, 250, 80, 7, 3, 0,
			8, 83, 0, 8, 19, 85, 8, 195, 83, 7,
			35, 0, 8, 115, 0, 8, 51, 0, 9, 198,
			81, 7, 11, 0, 8, 99, 0, 8, 35, 0,
			9, 166, 0, 8, 3, 0, 8, 131, 0, 8,
			67, 0, 9, 230, 80, 7, 7, 0, 8, 91,
			0, 8, 27, 0, 9, 150, 84, 7, 67, 0,
			8, 123, 0, 8, 59, 0, 9, 214, 82, 7,
			19, 0, 8, 107, 0, 8, 43, 0, 9, 182,
			0, 8, 11, 0, 8, 139, 0, 8, 75, 0,
			9, 246, 80, 7, 5, 0, 8, 87, 0, 8,
			23, 192, 8, 0, 83, 7, 51, 0, 8, 119,
			0, 8, 55, 0, 9, 206, 81, 7, 15, 0,
			8, 103, 0, 8, 39, 0, 9, 174, 0, 8,
			7, 0, 8, 135, 0, 8, 71, 0, 9, 238,
			80, 7, 9, 0, 8, 95, 0, 8, 31, 0,
			9, 158, 84, 7, 99, 0, 8, 127, 0, 8,
			63, 0, 9, 222, 82, 7, 27, 0, 8, 111,
			0, 8, 47, 0, 9, 190, 0, 8, 15, 0,
			8, 143, 0, 8, 79, 0, 9, 254, 96, 7,
			256, 0, 8, 80, 0, 8, 16, 84, 8, 115,
			82, 7, 31, 0, 8, 112, 0, 8, 48, 0,
			9, 193, 80, 7, 10, 0, 8, 96, 0, 8,
			32, 0, 9, 161, 0, 8, 0, 0, 8, 128,
			0, 8, 64, 0, 9, 225, 80, 7, 6, 0,
			8, 88, 0, 8, 24, 0, 9, 145, 83, 7,
			59, 0, 8, 120, 0, 8, 56, 0, 9, 209,
			81, 7, 17, 0, 8, 104, 0, 8, 40, 0,
			9, 177, 0, 8, 8, 0, 8, 136, 0, 8,
			72, 0, 9, 241, 80, 7, 4, 0, 8, 84,
			0, 8, 20, 85, 8, 227, 83, 7, 43, 0,
			8, 116, 0, 8, 52, 0, 9, 201, 81, 7,
			13, 0, 8, 100, 0, 8, 36, 0, 9, 169,
			0, 8, 4, 0, 8, 132, 0, 8, 68, 0,
			9, 233, 80, 7, 8, 0, 8, 92, 0, 8,
			28, 0, 9, 153, 84, 7, 83, 0, 8, 124,
			0, 8, 60, 0, 9, 217, 82, 7, 23, 0,
			8, 108, 0, 8, 44, 0, 9, 185, 0, 8,
			12, 0, 8, 140, 0, 8, 76, 0, 9, 249,
			80, 7, 3, 0, 8, 82, 0, 8, 18, 85,
			8, 163, 83, 7, 35, 0, 8, 114, 0, 8,
			50, 0, 9, 197, 81, 7, 11, 0, 8, 98,
			0, 8, 34, 0, 9, 165, 0, 8, 2, 0,
			8, 130, 0, 8, 66, 0, 9, 229, 80, 7,
			7, 0, 8, 90, 0, 8, 26, 0, 9, 149,
			84, 7, 67, 0, 8, 122, 0, 8, 58, 0,
			9, 213, 82, 7, 19, 0, 8, 106, 0, 8,
			42, 0, 9, 181, 0, 8, 10, 0, 8, 138,
			0, 8, 74, 0, 9, 245, 80, 7, 5, 0,
			8, 86, 0, 8, 22, 192, 8, 0, 83, 7,
			51, 0, 8, 118, 0, 8, 54, 0, 9, 205,
			81, 7, 15, 0, 8, 102, 0, 8, 38, 0,
			9, 173, 0, 8, 6, 0, 8, 134, 0, 8,
			70, 0, 9, 237, 80, 7, 9, 0, 8, 94,
			0, 8, 30, 0, 9, 157, 84, 7, 99, 0,
			8, 126, 0, 8, 62, 0, 9, 221, 82, 7,
			27, 0, 8, 110, 0, 8, 46, 0, 9, 189,
			0, 8, 14, 0, 8, 142, 0, 8, 78, 0,
			9, 253, 96, 7, 256, 0, 8, 81, 0, 8,
			17, 85, 8, 131, 82, 7, 31, 0, 8, 113,
			0, 8, 49, 0, 9, 195, 80, 7, 10, 0,
			8, 97, 0, 8, 33, 0, 9, 163, 0, 8,
			1, 0, 8, 129, 0, 8, 65, 0, 9, 227,
			80, 7, 6, 0, 8, 89, 0, 8, 25, 0,
			9, 147, 83, 7, 59, 0, 8, 121, 0, 8,
			57, 0, 9, 211, 81, 7, 17, 0, 8, 105,
			0, 8, 41, 0, 9, 179, 0, 8, 9, 0,
			8, 137, 0, 8, 73, 0, 9, 243, 80, 7,
			4, 0, 8, 85, 0, 8, 21, 80, 8, 258,
			83, 7, 43, 0, 8, 117, 0, 8, 53, 0,
			9, 203, 81, 7, 13, 0, 8, 101, 0, 8,
			37, 0, 9, 171, 0, 8, 5, 0, 8, 133,
			0, 8, 69, 0, 9, 235, 80, 7, 8, 0,
			8, 93, 0, 8, 29, 0, 9, 155, 84, 7,
			83, 0, 8, 125, 0, 8, 61, 0, 9, 219,
			82, 7, 23, 0, 8, 109, 0, 8, 45, 0,
			9, 187, 0, 8, 13, 0, 8, 141, 0, 8,
			77, 0, 9, 251, 80, 7, 3, 0, 8, 83,
			0, 8, 19, 85, 8, 195, 83, 7, 35, 0,
			8, 115, 0, 8, 51, 0, 9, 199, 81, 7,
			11, 0, 8, 99, 0, 8, 35, 0, 9, 167,
			0, 8, 3, 0, 8, 131, 0, 8, 67, 0,
			9, 231, 80, 7, 7, 0, 8, 91, 0, 8,
			27, 0, 9, 151, 84, 7, 67, 0, 8, 123,
			0, 8, 59, 0, 9, 215, 82, 7, 19, 0,
			8, 107, 0, 8, 43, 0, 9, 183, 0, 8,
			11, 0, 8, 139, 0, 8, 75, 0, 9, 247,
			80, 7, 5, 0, 8, 87, 0, 8, 23, 192,
			8, 0, 83, 7, 51, 0, 8, 119, 0, 8,
			55, 0, 9, 207, 81, 7, 15, 0, 8, 103,
			0, 8, 39, 0, 9, 175, 0, 8, 7, 0,
			8, 135, 0, 8, 71, 0, 9, 239, 80, 7,
			9, 0, 8, 95, 0, 8, 31, 0, 9, 159,
			84, 7, 99, 0, 8, 127, 0, 8, 63, 0,
			9, 223, 82, 7, 27, 0, 8, 111, 0, 8,
			47, 0, 9, 191, 0, 8, 15, 0, 8, 143,
			0, 8, 79, 0, 9, 255
		};

		internal static readonly int[] fixed_td = new int[96]
		{
			80, 5, 1, 87, 5, 257, 83, 5, 17, 91,
			5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5,
			65, 93, 5, 16385, 80, 5, 3, 88, 5, 513,
			84, 5, 33, 92, 5, 8193, 82, 5, 9, 90,
			5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5,
			2, 87, 5, 385, 83, 5, 25, 91, 5, 6145,
			81, 5, 7, 89, 5, 1537, 85, 5, 97, 93,
			5, 24577, 80, 5, 4, 88, 5, 769, 84, 5,
			49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073,
			86, 5, 193, 192, 5, 24577
		};

		internal static readonly int[] cplens = new int[31]
		{
			3, 4, 5, 6, 7, 8, 9, 10, 11, 13,
			15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
			67, 83, 99, 115, 131, 163, 195, 227, 258, 0,
			0
		};

		internal static readonly int[] cplext = new int[31]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
			1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
			4, 4, 4, 4, 5, 5, 5, 5, 0, 112,
			112
		};

		internal static readonly int[] cpdist = new int[30]
		{
			1, 2, 3, 4, 5, 7, 9, 13, 17, 25,
			33, 49, 65, 97, 129, 193, 257, 385, 513, 769,
			1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577
		};

		internal static readonly int[] cpdext = new int[30]
		{
			0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
			4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
			9, 9, 10, 10, 11, 11, 12, 12, 13, 13
		};

		internal const int BMAX = 15;

		internal int[] hn;

		internal int[] v;

		internal int[] c;

		internal int[] r;

		internal int[] u;

		internal int[] x;

		private int huft_build(int[] b, int bindex, int n, int s, int[] d, int[] e, int[] t, int[] m, int[] hp, int[] hn, int[] v)
		{
			int num = 0;
			int num2 = n;
			do
			{
				c[b[bindex + num]]++;
				num++;
				num2--;
			}
			while (num2 != 0);
			if (c[0] == n)
			{
				t[0] = -1;
				m[0] = 0;
				return 0;
			}
			int num3 = m[0];
			int i;
			for (i = 1; i <= 15 && c[i] == 0; i++)
			{
			}
			int j = i;
			if (num3 < i)
			{
				num3 = i;
			}
			num2 = 15;
			while (num2 != 0 && c[num2] == 0)
			{
				num2--;
			}
			int num4 = num2;
			if (num3 > num2)
			{
				num3 = num2;
			}
			m[0] = num3;
			int num5 = 1 << i;
			while (i < num2)
			{
				if ((num5 -= c[i]) < 0)
				{
					return -3;
				}
				i++;
				num5 <<= 1;
			}
			if ((num5 -= c[num2]) < 0)
			{
				return -3;
			}
			c[num2] += num5;
			i = (x[1] = 0);
			num = 1;
			int num6 = 2;
			while (--num2 != 0)
			{
				i = (x[num6] = i + c[num]);
				num6++;
				num++;
			}
			num2 = 0;
			num = 0;
			do
			{
				if ((i = b[bindex + num]) != 0)
				{
					v[x[i]++] = num2;
				}
				num++;
			}
			while (++num2 < n);
			n = x[num4];
			num2 = (x[0] = 0);
			num = 0;
			int num7 = -1;
			int num8 = -num3;
			u[0] = 0;
			int num9 = 0;
			int num10 = 0;
			for (; j <= num4; j++)
			{
				int num11 = c[j];
				while (num11-- != 0)
				{
					int num12;
					while (j > num8 + num3)
					{
						num7++;
						num8 += num3;
						num10 = num4 - num8;
						num10 = ((num10 <= num3) ? num10 : num3);
						if ((num12 = 1 << (i = j - num8)) > num11 + 1)
						{
							num12 -= num11 + 1;
							num6 = j;
							if (i < num10)
							{
								while (++i < num10 && (num12 <<= 1) > c[++num6])
								{
									num12 -= c[num6];
								}
							}
						}
						num10 = 1 << i;
						if (hn[0] + num10 > 1440)
						{
							return -3;
						}
						num9 = (u[num7] = hn[0]);
						hn[0] += num10;
						if (num7 != 0)
						{
							x[num7] = num2;
							r[0] = (sbyte)i;
							r[1] = (sbyte)num3;
							i = SharedUtils.URShift(num2, num8 - num3);
							r[2] = num9 - u[num7 - 1] - i;
							Array.Copy(r, 0, hp, (u[num7 - 1] + i) * 3, 3);
						}
						else
						{
							t[0] = num9;
						}
					}
					r[1] = (sbyte)(j - num8);
					if (num >= n)
					{
						r[0] = 192;
					}
					else if (v[num] < s)
					{
						r[0] = (sbyte)((v[num] >= 256) ? 96 : 0);
						r[2] = v[num++];
					}
					else
					{
						r[0] = (sbyte)(e[v[num] - s] + 16 + 64);
						r[2] = d[v[num++] - s];
					}
					num12 = 1 << j - num8;
					for (i = SharedUtils.URShift(num2, num8); i < num10; i += num12)
					{
						Array.Copy(r, 0, hp, (num9 + i) * 3, 3);
					}
					i = 1 << j - 1;
					while ((num2 & i) != 0)
					{
						num2 ^= i;
						i = SharedUtils.URShift(i, 1);
					}
					num2 ^= i;
					int num13 = (1 << num8) - 1;
					while ((num2 & num13) != x[num7])
					{
						num7--;
						num8 -= num3;
						num13 = (1 << num8) - 1;
					}
				}
			}
			return (num5 != 0 && num4 != 1) ? (-5) : 0;
		}

		internal int inflate_trees_bits(int[] c, int[] bb, int[] tb, int[] hp, ZlibCodec z)
		{
			initWorkArea(19);
			hn[0] = 0;
			int num = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);
			if (num == -3)
			{
				z.Message = "oversubscribed dynamic bit lengths tree";
			}
			else if (num == -5 || bb[0] == 0)
			{
				z.Message = "incomplete dynamic bit lengths tree";
				num = -3;
			}
			return num;
		}

		internal int inflate_trees_dynamic(int nl, int nd, int[] c, int[] bl, int[] bd, int[] tl, int[] td, int[] hp, ZlibCodec z)
		{
			initWorkArea(288);
			hn[0] = 0;
			int num = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
			if (num != 0 || bl[0] == 0)
			{
				switch (num)
				{
				case -3:
					z.Message = "oversubscribed literal/length tree";
					break;
				default:
					z.Message = "incomplete literal/length tree";
					num = -3;
					break;
				case -4:
					break;
				}
				return num;
			}
			initWorkArea(288);
			num = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
			if (num != 0 || (bd[0] == 0 && nl > 257))
			{
				switch (num)
				{
				case -3:
					z.Message = "oversubscribed distance tree";
					break;
				case -5:
					z.Message = "incomplete distance tree";
					num = -3;
					break;
				default:
					z.Message = "empty distance tree with lengths";
					num = -3;
					break;
				case -4:
					break;
				}
				return num;
			}
			return 0;
		}

		internal static int inflate_trees_fixed(int[] bl, int[] bd, int[][] tl, int[][] td, ZlibCodec z)
		{
			bl[0] = 9;
			bd[0] = 5;
			tl[0] = fixed_tl;
			td[0] = fixed_td;
			return 0;
		}

		private void initWorkArea(int vsize)
		{
			if (hn == null)
			{
				hn = new int[1];
				v = new int[vsize];
				c = new int[16];
				r = new int[3];
				u = new int[15];
				x = new int[16];
				return;
			}
			if (v.Length < vsize)
			{
				v = new int[vsize];
			}
			Array.Clear(v, 0, vsize);
			Array.Clear(c, 0, 16);
			r[0] = 0;
			r[1] = 0;
			r[2] = 0;
			Array.Clear(u, 0, 15);
			Array.Clear(x, 0, 16);
		}
	}
	internal sealed class InflateBlocks
	{
		private enum InflateBlockMode
		{
			TYPE,
			LENS,
			STORED,
			TABLE,
			BTREE,
			DTREE,
			CODES,
			DRY,
			DONE,
			BAD
		}

		private const int MANY = 1440;

		internal static readonly int[] border = new int[19]
		{
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5,
			11, 4, 12, 3, 13, 2, 14, 1, 15
		};

		private InflateBlockMode mode;

		internal int left;

		internal int table;

		internal int index;

		internal int[] blens;

		internal int[] bb = new int[1];

		internal int[] tb = new int[1];

		internal InflateCodes codes = new InflateCodes();

		internal int last;

		internal ZlibCodec _codec;

		internal int bitk;

		internal int bitb;

		internal int[] hufts;

		internal byte[] window;

		internal int end;

		internal int readAt;

		internal int writeAt;

		internal object checkfn;

		internal uint check;

		internal InfTree inftree = new InfTree();

		internal InflateBlocks(ZlibCodec codec, object checkfn, int w)
		{
			_codec = codec;
			hufts = new int[4320];
			window = new byte[w];
			end = w;
			this.checkfn = checkfn;
			mode = InflateBlockMode.TYPE;
			Reset();
		}

		internal uint Reset()
		{
			uint result = check;
			mode = InflateBlockMode.TYPE;
			bitk = 0;
			bitb = 0;
			readAt = (writeAt = 0);
			if (checkfn != null)
			{
				_codec._Adler32 = (check = Adler.Adler32(0u, null, 0, 0));
			}
			return result;
		}

		internal int Process(int r)
		{
			int num = _codec.NextIn;
			int num2 = _codec.AvailableBytesIn;
			int num3 = bitb;
			int i = bitk;
			int num4 = writeAt;
			int num5 = ((num4 >= readAt) ? (end - num4) : (readAt - num4 - 1));
			while (true)
			{
				switch (mode)
				{
				case InflateBlockMode.TYPE:
				{
					for (; i < 3; i += 8)
					{
						if (num2 != 0)
						{
							r = 0;
							num2--;
							num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
							continue;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					int num6 = num3 & 7;
					last = num6 & 1;
					switch ((uint)(num6 >>> 1))
					{
					case 0u:
						num3 >>= 3;
						i -= 3;
						num6 = i & 7;
						num3 >>= num6;
						i -= num6;
						mode = InflateBlockMode.LENS;
						break;
					case 1u:
					{
						int[] array = new int[1];
						int[] array2 = new int[1];
						int[][] array3 = new int[1][];
						int[][] array4 = new int[1][];
						InfTree.inflate_trees_fixed(array, array2, array3, array4, _codec);
						codes.Init(array[0], array2[0], array3[0], 0, array4[0], 0);
						num3 >>= 3;
						i -= 3;
						mode = InflateBlockMode.CODES;
						break;
					}
					case 2u:
						num3 >>= 3;
						i -= 3;
						mode = InflateBlockMode.TABLE;
						break;
					case 3u:
						num3 >>= 3;
						i -= 3;
						mode = InflateBlockMode.BAD;
						_codec.Message = "invalid block type";
						r = -3;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					break;
				}
				case InflateBlockMode.LENS:
					for (; i < 32; i += 8)
					{
						if (num2 != 0)
						{
							r = 0;
							num2--;
							num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
							continue;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					if (((~num3 >> 16) & 0xFFFF) != (num3 & 0xFFFF))
					{
						mode = InflateBlockMode.BAD;
						_codec.Message = "invalid stored block lengths";
						r = -3;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					left = num3 & 0xFFFF;
					num3 = (i = 0);
					mode = ((left != 0) ? InflateBlockMode.STORED : ((last != 0) ? InflateBlockMode.DRY : InflateBlockMode.TYPE));
					break;
				case InflateBlockMode.STORED:
				{
					if (num2 == 0)
					{
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					if (num5 == 0)
					{
						if (num4 == end && readAt != 0)
						{
							num4 = 0;
							num5 = ((num4 >= readAt) ? (end - num4) : (readAt - num4 - 1));
						}
						if (num5 == 0)
						{
							writeAt = num4;
							r = Flush(r);
							num4 = writeAt;
							num5 = ((num4 >= readAt) ? (end - num4) : (readAt - num4 - 1));
							if (num4 == end && readAt != 0)
							{
								num4 = 0;
								num5 = ((num4 >= readAt) ? (end - num4) : (readAt - num4 - 1));
							}
							if (num5 == 0)
							{
								bitb = num3;
								bitk = i;
								_codec.AvailableBytesIn = num2;
								_codec.TotalBytesIn += num - _codec.NextIn;
								_codec.NextIn = num;
								writeAt = num4;
								return Flush(r);
							}
						}
					}
					r = 0;
					int num6 = left;
					if (num6 > num2)
					{
						num6 = num2;
					}
					if (num6 > num5)
					{
						num6 = num5;
					}
					Array.Copy(_codec.InputBuffer, num, window, num4, num6);
					num += num6;
					num2 -= num6;
					num4 += num6;
					num5 -= num6;
					if ((left -= num6) == 0)
					{
						mode = ((last != 0) ? InflateBlockMode.DRY : InflateBlockMode.TYPE);
					}
					break;
				}
				case InflateBlockMode.TABLE:
				{
					for (; i < 14; i += 8)
					{
						if (num2 != 0)
						{
							r = 0;
							num2--;
							num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
							continue;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					int num6 = (table = num3 & 0x3FFF);
					if ((num6 & 0x1F) > 29 || ((num6 >> 5) & 0x1F) > 29)
					{
						mode = InflateBlockMode.BAD;
						_codec.Message = "too many length or distance symbols";
						r = -3;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					num6 = 258 + (num6 & 0x1F) + ((num6 >> 5) & 0x1F);
					if (blens == null || blens.Length < num6)
					{
						blens = new int[num6];
					}
					else
					{
						Array.Clear(blens, 0, num6);
					}
					num3 >>= 14;
					i -= 14;
					index = 0;
					mode = InflateBlockMode.BTREE;
					goto case InflateBlockMode.BTREE;
				}
				case InflateBlockMode.BTREE:
				{
					while (index < 4 + (table >> 10))
					{
						for (; i < 3; i += 8)
						{
							if (num2 != 0)
							{
								r = 0;
								num2--;
								num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
								continue;
							}
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						blens[border[index++]] = num3 & 7;
						num3 >>= 3;
						i -= 3;
					}
					while (index < 19)
					{
						blens[border[index++]] = 0;
					}
					bb[0] = 7;
					int num6 = inftree.inflate_trees_bits(blens, bb, tb, hufts, _codec);
					if (num6 != 0)
					{
						r = num6;
						if (r == -3)
						{
							blens = null;
							mode = InflateBlockMode.BAD;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					index = 0;
					mode = InflateBlockMode.DTREE;
					goto case InflateBlockMode.DTREE;
				}
				case InflateBlockMode.DTREE:
				{
					int num6;
					while (true)
					{
						num6 = table;
						if (index >= 258 + (num6 & 0x1F) + ((num6 >> 5) & 0x1F))
						{
							break;
						}
						for (num6 = bb[0]; i < num6; i += 8)
						{
							if (num2 != 0)
							{
								r = 0;
								num2--;
								num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
								continue;
							}
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						num6 = hufts[(tb[0] + (num3 & InternalInflateConstants.InflateMask[num6])) * 3 + 1];
						int num7 = hufts[(tb[0] + (num3 & InternalInflateConstants.InflateMask[num6])) * 3 + 2];
						if (num7 < 16)
						{
							num3 >>= num6;
							i -= num6;
							blens[index++] = num7;
							continue;
						}
						int num8 = ((num7 != 18) ? (num7 - 14) : 7);
						int num9 = ((num7 != 18) ? 3 : 11);
						for (; i < num6 + num8; i += 8)
						{
							if (num2 != 0)
							{
								r = 0;
								num2--;
								num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
								continue;
							}
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						num3 >>= num6;
						i -= num6;
						num9 += num3 & InternalInflateConstants.InflateMask[num8];
						num3 >>= num8;
						i -= num8;
						num8 = index;
						num6 = table;
						if (num8 + num9 > 258 + (num6 & 0x1F) + ((num6 >> 5) & 0x1F) || (num7 == 16 && num8 < 1))
						{
							blens = null;
							mode = InflateBlockMode.BAD;
							_codec.Message = "invalid bit length repeat";
							r = -3;
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						num7 = ((num7 == 16) ? blens[num8 - 1] : 0);
						do
						{
							blens[num8++] = num7;
						}
						while (--num9 != 0);
						index = num8;
					}
					tb[0] = -1;
					int[] array5 = new int[1] { 9 };
					int[] array6 = new int[1] { 6 };
					int[] array7 = new int[1];
					int[] array8 = new int[1];
					num6 = table;
					num6 = inftree.inflate_trees_dynamic(257 + (num6 & 0x1F), 1 + ((num6 >> 5) & 0x1F), blens, array5, array6, array7, array8, hufts, _codec);
					if (num6 != 0)
					{
						if (num6 == -3)
						{
							blens = null;
							mode = InflateBlockMode.BAD;
						}
						r = num6;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					codes.Init(array5[0], array6[0], hufts, array7[0], hufts, array8[0]);
					mode = InflateBlockMode.CODES;
					goto case InflateBlockMode.CODES;
				}
				case InflateBlockMode.CODES:
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					r = codes.Process(this, r);
					if (r != 1)
					{
						return Flush(r);
					}
					r = 0;
					num = _codec.NextIn;
					num2 = _codec.AvailableBytesIn;
					num3 = bitb;
					i = bitk;
					num4 = writeAt;
					num5 = ((num4 >= readAt) ? (end - num4) : (readAt - num4 - 1));
					if (last == 0)
					{
						mode = InflateBlockMode.TYPE;
						break;
					}
					mode = InflateBlockMode.DRY;
					goto case InflateBlockMode.DRY;
				case InflateBlockMode.DRY:
					writeAt = num4;
					r = Flush(r);
					num4 = writeAt;
					num5 = ((num4 >= readAt) ? (end - num4) : (readAt - num4 - 1));
					if (readAt != writeAt)
					{
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					mode = InflateBlockMode.DONE;
					goto case InflateBlockMode.DONE;
				case InflateBlockMode.DONE:
					r = 1;
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					return Flush(r);
				case InflateBlockMode.BAD:
					r = -3;
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					return Flush(r);
				default:
					r = -2;
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					return Flush(r);
				}
			}
		}

		internal void Free()
		{
			Reset();
			window = null;
			hufts = null;
		}

		internal void SetDictionary(byte[] d, int start, int n)
		{
			Array.Copy(d, start, window, 0, n);
			readAt = (writeAt = n);
		}

		internal int SyncPoint()
		{
			return (mode == InflateBlockMode.LENS) ? 1 : 0;
		}

		internal int Flush(int r)
		{
			for (int i = 0; i < 2; i++)
			{
				int num = ((i != 0) ? (writeAt - readAt) : (((readAt > writeAt) ? end : writeAt) - readAt));
				if (num == 0)
				{
					if (r == -5)
					{
						r = 0;
					}
					return r;
				}
				if (num > _codec.AvailableBytesOut)
				{
					num = _codec.AvailableBytesOut;
				}
				if (num != 0 && r == -5)
				{
					r = 0;
				}
				_codec.AvailableBytesOut -= num;
				_codec.TotalBytesOut += num;
				if (checkfn != null)
				{
					_codec._Adler32 = (check = Adler.Adler32(check, window, readAt, num));
				}
				Array.Copy(window, readAt, _codec.OutputBuffer, _codec.NextOut, num);
				_codec.NextOut += num;
				readAt += num;
				if (readAt == end && i == 0)
				{
					readAt = 0;
					if (writeAt == end)
					{
						writeAt = 0;
					}
				}
				else
				{
					i++;
				}
			}
			return r;
		}
	}
	internal static class InternalInflateConstants
	{
		internal static readonly int[] InflateMask = new int[17]
		{
			0, 1, 3, 7, 15, 31, 63, 127, 255, 511,
			1023, 2047, 4095, 8191, 16383, 32767, 65535
		};
	}
	internal sealed class InflateCodes
	{
		private const int START = 0;

		private const int LEN = 1;

		private const int LENEXT = 2;

		private const int DIST = 3;

		private const int DISTEXT = 4;

		private const int COPY = 5;

		private const int LIT = 6;

		private const int WASH = 7;

		private const int END = 8;

		private const int BADCODE = 9;

		internal int mode;

		internal int len;

		internal int[] tree;

		internal int tree_index;

		internal int need;

		internal int lit;

		internal int bitsToGet;

		internal int dist;

		internal byte lbits;

		internal byte dbits;

		internal int[] ltree;

		internal int ltree_index;

		internal int[] dtree;

		internal int dtree_index;

		internal InflateCodes()
		{
		}

		internal void Init(int bl, int bd, int[] tl, int tl_index, int[] td, int td_index)
		{
			mode = 0;
			lbits = (byte)bl;
			dbits = (byte)bd;
			ltree = tl;
			ltree_index = tl_index;
			dtree = td;
			dtree_index = td_index;
			tree = null;
		}

		internal int Process(InflateBlocks blocks, int r)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			ZlibCodec codec = blocks._codec;
			num3 = codec.NextIn;
			int num4 = codec.AvailableBytesIn;
			num = blocks.bitb;
			num2 = blocks.bitk;
			int num5 = blocks.writeAt;
			int num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
			while (true)
			{
				switch (mode)
				{
				case 0:
					if (num6 >= 258 && num4 >= 10)
					{
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						r = InflateFast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, blocks, codec);
						num3 = codec.NextIn;
						num4 = codec.AvailableBytesIn;
						num = blocks.bitb;
						num2 = blocks.bitk;
						num5 = blocks.writeAt;
						num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
						if (r != 0)
						{
							mode = ((r != 1) ? 9 : 7);
							break;
						}
					}
					need = lbits;
					tree = ltree;
					tree_index = ltree_index;
					mode = 1;
					goto case 1;
				case 1:
				{
					int num7;
					for (num7 = need; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					int num8 = (tree_index + (num & InternalInflateConstants.InflateMask[num7])) * 3;
					num >>= tree[num8 + 1];
					num2 -= tree[num8 + 1];
					int num9 = tree[num8];
					if (num9 == 0)
					{
						lit = tree[num8 + 2];
						mode = 6;
						break;
					}
					if (((uint)num9 & 0x10u) != 0)
					{
						bitsToGet = num9 & 0xF;
						len = tree[num8 + 2];
						mode = 2;
						break;
					}
					if ((num9 & 0x40) == 0)
					{
						need = num9;
						tree_index = num8 / 3 + tree[num8 + 2];
						break;
					}
					if (((uint)num9 & 0x20u) != 0)
					{
						mode = 7;
						break;
					}
					mode = 9;
					codec.Message = "invalid literal/length code";
					r = -3;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				}
				case 2:
				{
					int num7;
					for (num7 = bitsToGet; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					len += num & InternalInflateConstants.InflateMask[num7];
					num >>= num7;
					num2 -= num7;
					need = dbits;
					tree = dtree;
					tree_index = dtree_index;
					mode = 3;
					goto case 3;
				}
				case 3:
				{
					int num7;
					for (num7 = need; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					int num8 = (tree_index + (num & InternalInflateConstants.InflateMask[num7])) * 3;
					num >>= tree[num8 + 1];
					num2 -= tree[num8 + 1];
					int num9 = tree[num8];
					if (((uint)num9 & 0x10u) != 0)
					{
						bitsToGet = num9 & 0xF;
						dist = tree[num8 + 2];
						mode = 4;
						break;
					}
					if ((num9 & 0x40) == 0)
					{
						need = num9;
						tree_index = num8 / 3 + tree[num8 + 2];
						break;
					}
					mode = 9;
					codec.Message = "invalid distance code";
					r = -3;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				}
				case 4:
				{
					int num7;
					for (num7 = bitsToGet; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					dist += num & InternalInflateConstants.InflateMask[num7];
					num >>= num7;
					num2 -= num7;
					mode = 5;
					goto case 5;
				}
				case 5:
				{
					int i;
					for (i = num5 - dist; i < 0; i += blocks.end)
					{
					}
					while (len != 0)
					{
						if (num6 == 0)
						{
							if (num5 == blocks.end && blocks.readAt != 0)
							{
								num5 = 0;
								num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
							}
							if (num6 == 0)
							{
								blocks.writeAt = num5;
								r = blocks.Flush(r);
								num5 = blocks.writeAt;
								num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
								if (num5 == blocks.end && blocks.readAt != 0)
								{
									num5 = 0;
									num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
								}
								if (num6 == 0)
								{
									blocks.bitb = num;
									blocks.bitk = num2;
									codec.AvailableBytesIn = num4;
									codec.TotalBytesIn += num3 - codec.NextIn;
									codec.NextIn = num3;
									blocks.writeAt = num5;
									return blocks.Flush(r);
								}
							}
						}
						blocks.window[num5++] = blocks.window[i++];
						num6--;
						if (i == blocks.end)
						{
							i = 0;
						}
						len--;
					}
					mode = 0;
					break;
				}
				case 6:
					if (num6 == 0)
					{
						if (num5 == blocks.end && blocks.readAt != 0)
						{
							num5 = 0;
							num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
						}
						if (num6 == 0)
						{
							blocks.writeAt = num5;
							r = blocks.Flush(r);
							num5 = blocks.writeAt;
							num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
							if (num5 == blocks.end && blocks.readAt != 0)
							{
								num5 = 0;
								num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
							}
							if (num6 == 0)
							{
								blocks.bitb = num;
								blocks.bitk = num2;
								codec.AvailableBytesIn = num4;
								codec.TotalBytesIn += num3 - codec.NextIn;
								codec.NextIn = num3;
								blocks.writeAt = num5;
								return blocks.Flush(r);
							}
						}
					}
					r = 0;
					blocks.window[num5++] = (byte)lit;
					num6--;
					mode = 0;
					break;
				case 7:
					if (num2 > 7)
					{
						num2 -= 8;
						num4++;
						num3--;
					}
					blocks.writeAt = num5;
					r = blocks.Flush(r);
					num5 = blocks.writeAt;
					num6 = ((num5 >= blocks.readAt) ? (blocks.end - num5) : (blocks.readAt - num5 - 1));
					if (blocks.readAt != blocks.writeAt)
					{
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					mode = 8;
					goto case 8;
				case 8:
					r = 1;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				case 9:
					r = -3;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				default:
					r = -2;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				}
			}
		}

		internal int InflateFast(int bl, int bd, int[] tl, int tl_index, int[] td, int td_index, InflateBlocks s, ZlibCodec z)
		{
			int nextIn = z.NextIn;
			int num = z.AvailableBytesIn;
			int num2 = s.bitb;
			int num3 = s.bitk;
			int num4 = s.writeAt;
			int num5 = ((num4 >= s.readAt) ? (s.end - num4) : (s.readAt - num4 - 1));
			int num6 = InternalInflateConstants.InflateMask[bl];
			int num7 = InternalInflateConstants.InflateMask[bd];
			int num12;
			while (true)
			{
				if (num3 < 20)
				{
					num--;
					num2 |= (z.InputBuffer[nextIn++] & 0xFF) << num3;
					num3 += 8;
					continue;
				}
				int num8 = num2 & num6;
				int[] array = tl;
				int num9 = tl_index;
				int num10 = (num9 + num8) * 3;
				int num11;
				if ((num11 = array[num10]) == 0)
				{
					num2 >>= array[num10 + 1];
					num3 -= array[num10 + 1];
					s.window[num4++] = (byte)array[num10 + 2];
					num5--;
				}
				else
				{
					while (true)
					{
						num2 >>= array[num10 + 1];
						num3 -= array[num10 + 1];
						if (((uint)num11 & 0x10u) != 0)
						{
							num11 &= 0xF;
							num12 = array[num10 + 2] + (num2 & InternalInflateConstants.InflateMask[num11]);
							num2 >>= num11;
							for (num3 -= num11; num3 < 15; num3 += 8)
							{
								num--;
								num2 |= (z.InputBuffer[nextIn++] & 0xFF) << num3;
							}
							num8 = num2 & num7;
							array = td;
							num9 = td_index;
							num10 = (num9 + num8) * 3;
							num11 = array[num10];
							while (true)
							{
								num2 >>= array[num10 + 1];
								num3 -= array[num10 + 1];
								if (((uint)num11 & 0x10u) != 0)
								{
									break;
								}
								if ((num11 & 0x40) == 0)
								{
									num8 += array[num10 + 2];
									num8 += num2 & InternalInflateConstants.InflateMask[num11];
									num10 = (num9 + num8) * 3;
									num11 = array[num10];
									continue;
								}
								z.Message = "invalid distance code";
								num12 = z.AvailableBytesIn - num;
								num12 = ((num3 >> 3 >= num12) ? num12 : (num3 >> 3));
								num += num12;
								nextIn -= num12;
								num3 -= num12 << 3;
								s.bitb = num2;
								s.bitk = num3;
								z.AvailableBytesIn = num;
								z.TotalBytesIn += nextIn - z.NextIn;
								z.NextIn = nextIn;
								s.writeAt = num4;
								return -3;
							}
							for (num11 &= 0xF; num3 < num11; num3 += 8)
							{
								num--;
								num2 |= (z.InputBuffer[nextIn++] & 0xFF) << num3;
							}
							int num13 = array[num10 + 2] + (num2 & InternalInflateConstants.InflateMask[num11]);
							num2 >>= num11;
							num3 -= num11;
							num5 -= num12;
							int num14;
							if (num4 >= num13)
							{
								num14 = num4 - num13;
								if (num4 - num14 > 0 && 2 > num4 - num14)
								{
									s.window[num4++] = s.window[num14++];
									s.window[num4++] = s.window[num14++];
									num12 -= 2;
								}
								else
								{
									Array.Copy(s.window, num14, s.window, num4, 2);
									num4 += 2;
									num14 += 2;
									num12 -= 2;
								}
							}
							else
							{
								num14 = num4 - num13;
								do
								{
									num14 += s.end;
								}
								while (num14 < 0);
								num11 = s.end - num14;
								if (num12 > num11)
								{
									num12 -= num11;
									if (num4 - num14 > 0 && num11 > num4 - num14)
									{
										do
										{
											s.window[num4++] = s.window[num14++];
										}
										while (--num11 != 0);
									}
									else
									{
										Array.Copy(s.window, num14, s.window, num4, num11);
										num4 += num11;
										num14 += num11;
										num11 = 0;
									}
									num14 = 0;
								}
							}
							if (num4 - num14 > 0 && num12 > num4 - num14)
							{
								do
								{
									s.window[num4++] = s.window[num14++];
								}
								while (--num12 != 0);
								break;
							}
							Array.Copy(s.window, num14, s.window, num4, num12);
							num4 += num12;
							num14 += num12;
							num12 = 0;
							break;
						}
						if ((num11 & 0x40) == 0)
						{
							num8 += array[num10 + 2];
							num8 += num2 & InternalInflateConstants.InflateMask[num11];
							num10 = (num9 + num8) * 3;
							if ((num11 = array[num10]) == 0)
							{
								num2 >>= array[num10 + 1];
								num3 -= array[num10 + 1];
								s.window[num4++] = (byte)array[num10 + 2];
								num5--;
								break;
							}
							continue;
						}
						if (((uint)num11 & 0x20u) != 0)
						{
							num12 = z.AvailableBytesIn - num;
							num12 = ((num3 >> 3 >= num12) ? num12 : (num3 >> 3));
							num += num12;
							nextIn -= num12;
							num3 -= num12 << 3;
							s.bitb = num2;
							s.bitk = num3;
							z.AvailableBytesIn = num;
							z.TotalBytesIn += nextIn - z.NextIn;
							z.NextIn = nextIn;
							s.writeAt = num4;
							return 1;
						}
						z.Message = "invalid literal/length code";
						num12 = z.AvailableBytesIn - num;
						num12 = ((num3 >> 3 >= num12) ? num12 : (num3 >> 3));
						num += num12;
						nextIn -= num12;
						num3 -= num12 << 3;
						s.bitb = num2;
						s.bitk = num3;
						z.AvailableBytesIn = num;
						z.TotalBytesIn += nextIn - z.NextIn;
						z.NextIn = nextIn;
						s.writeAt = num4;
						return -3;
					}
				}
				if (num5 < 258 || num < 10)
				{
					break;
				}
			}
			num12 = z.AvailableBytesIn - num;
			num12 = ((num3 >> 3 >= num12) ? num12 : (num3 >> 3));
			num += num12;
			nextIn -= num12;
			num3 -= num12 << 3;
			s.bitb = num2;
			s.bitk = num3;
			z.AvailableBytesIn = num;
			z.TotalBytesIn += nextIn - z.NextIn;
			z.NextIn = nextIn;
			s.writeAt = num4;
			return 0;
		}
	}
	internal sealed class InflateManager
	{
		private enum InflateManagerMode
		{
			METHOD,
			FLAG,
			DICT4,
			DICT3,
			DICT2,
			DICT1,
			DICT0,
			BLOCKS,
			CHECK4,
			CHECK3,
			CHECK2,
			CHECK1,
			DONE,
			BAD
		}

		private const int PRESET_DICT = 32;

		private const int Z_DEFLATED = 8;

		private InflateManagerMode mode;

		internal ZlibCodec _codec;

		internal int method;

		internal uint computedCheck;

		internal uint expectedCheck;

		internal int marker;

		private bool _handleRfc1950HeaderBytes = true;

		internal int wbits;

		internal InflateBlocks blocks;

		private static readonly byte[] mark = new byte[4] { 0, 0, 255, 255 };

		internal bool HandleRfc1950HeaderBytes
		{
			get
			{
				return _handleRfc1950HeaderBytes;
			}
			set
			{
				_handleRfc1950HeaderBytes = value;
			}
		}

		public InflateManager()
		{
		}

		public InflateManager(bool expectRfc1950HeaderBytes)
		{
			_handleRfc1950HeaderBytes = expectRfc1950HeaderBytes;
		}

		internal int Reset()
		{
			_codec.TotalBytesIn = (_codec.TotalBytesOut = 0L);
			_codec.Message = null;
			mode = ((!HandleRfc1950HeaderBytes) ? InflateManagerMode.BLOCKS : InflateManagerMode.METHOD);
			blocks.Reset();
			return 0;
		}

		internal int End()
		{
			if (blocks != null)
			{
				blocks.Free();
			}
			blocks = null;
			return 0;
		}

		internal int Initialize(ZlibCodec codec, int w)
		{
			_codec = codec;
			_codec.Message = null;
			blocks = null;
			if (w < 8 || w > 15)
			{
				End();
				throw new ZlibException("Bad window size.");
			}
			wbits = w;
			blocks = new InflateBlocks(codec, (!HandleRfc1950HeaderBytes) ? null : this, 1 << w);
			Reset();
			return 0;
		}

		internal int Inflate(FlushType flush)
		{
			if (_codec.InputBuffer == null)
			{
				throw new ZlibException("InputBuffer is null. ");
			}
			int num = 0;
			int num2 = -5;
			while (true)
			{
				switch (mode)
				{
				case InflateManagerMode.METHOD:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xF) != 8)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = $"unknown compression method (0x{method:X2})";
						marker = 5;
					}
					else if ((method >> 4) + 8 > wbits)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = $"invalid window size ({(method >> 4) + 8})";
						marker = 5;
					}
					else
					{
						mode = InflateManagerMode.FLAG;
					}
					break;
				case InflateManagerMode.FLAG:
				{
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					int num3 = _codec.InputBuffer[_codec.NextIn++] & 0xFF;
					if (((method << 8) + num3) % 31 != 0)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = "incorrect header check";
						marker = 5;
					}
					else
					{
						mode = ((((uint)num3 & 0x20u) != 0) ? InflateManagerMode.DICT4 : InflateManagerMode.BLOCKS);
					}
					break;
				}
				case InflateManagerMode.DICT4:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xFF000000u);
					mode = InflateManagerMode.DICT3;
					break;
				case InflateManagerMode.DICT3:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0xFF0000);
					mode = InflateManagerMode.DICT2;
					break;
				case InflateManagerMode.DICT2:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0xFF00);
					mode = InflateManagerMode.DICT1;
					break;
				case InflateManagerMode.DICT1:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0xFF);
					_codec._Adler32 = expectedCheck;
					mode = InflateManagerMode.DICT0;
					return 2;
				case InflateManagerMode.DICT0:
					mode = InflateManagerMode.BAD;
					_codec.Message = "need dictionary";
					marker = 0;
					return -2;
				case InflateManagerMode.BLOCKS:
					num2 = blocks.Process(num2);
					switch (num2)
					{
					case -3:
						mode = InflateManagerMode.BAD;
						marker = 0;
						goto end_IL_0028;
					case 0:
						num2 = num;
						break;
					}
					if (num2 != 1)
					{
						return num2;
					}
					num2 = num;
					computedCheck = blocks.Reset();
					if (!HandleRfc1950HeaderBytes)
					{
						mode = InflateManagerMode.DONE;
						return 1;
					}
					mode = InflateManagerMode.CHECK4;
					break;
				case InflateManagerMode.CHECK4:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xFF000000u);
					mode = InflateManagerMode.CHECK3;
					break;
				case InflateManagerMode.CHECK3:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0xFF0000);
					mode = InflateManagerMode.CHECK2;
					break;
				case InflateManagerMode.CHECK2:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0xFF00);
					mode = InflateManagerMode.CHECK1;
					break;
				case InflateManagerMode.CHECK1:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0xFF);
					if (computedCheck != expectedCheck)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = "incorrect data check";
						marker = 5;
						break;
					}
					mode = InflateManagerMode.DONE;
					return 1;
				case InflateManagerMode.DONE:
					return 1;
				case InflateManagerMode.BAD:
					throw new ZlibException($"Bad state ({_codec.Message})");
				default:
					{
						throw new ZlibException("Stream error.");
					}
					end_IL_0028:
					break;
				}
			}
		}

		internal int SetDictionary(byte[] dictionary)
		{
			int start = 0;
			int num = dictionary.Length;
			if (mode != InflateManagerMode.DICT0)
			{
				throw new ZlibException("Stream error.");
			}
			if (Adler.Adler32(1u, dictionary, 0, dictionary.Length) != _codec._Adler32)
			{
				return -3;
			}
			_codec._Adler32 = Adler.Adler32(0u, null, 0, 0);
			if (num >= 1 << wbits)
			{
				num = (1 << wbits) - 1;
				start = dictionary.Length - num;
			}
			blocks.SetDictionary(dictionary, start, num);
			mode = InflateManagerMode.BLOCKS;
			return 0;
		}

		internal int Sync()
		{
			if (mode != InflateManagerMode.BAD)
			{
				mode = InflateManagerMode.BAD;
				marker = 0;
			}
			int num;
			if ((num = _codec.AvailableBytesIn) == 0)
			{
				return -5;
			}
			int num2 = _codec.NextIn;
			int num3 = marker;
			while (num != 0 && num3 < 4)
			{
				num3 = ((_codec.InputBuffer[num2] != mark[num3]) ? ((_codec.InputBuffer[num2] == 0) ? (4 - num3) : 0) : (num3 + 1));
				num2++;
				num--;
			}
			_codec.TotalBytesIn += num2 - _codec.NextIn;
			_codec.NextIn = num2;
			_codec.AvailableBytesIn = num;
			marker = num3;
			if (num3 != 4)
			{
				return -3;
			}
			long totalBytesIn = _codec.TotalBytesIn;
			long totalBytesOut = _codec.TotalBytesOut;
			Reset();
			_codec.TotalBytesIn = totalBytesIn;
			_codec.TotalBytesOut = totalBytesOut;
			mode = InflateManagerMode.BLOCKS;
			return 0;
		}

		internal int SyncPoint(ZlibCodec z)
		{
			return blocks.SyncPoint();
		}
	}
	internal class WorkItem
	{
		public byte[] buffer;

		public byte[] compressed;

		public int crc;

		public int index;

		public int ordinal;

		public int inputBytesAvailable;

		public int compressedBytesAvailable;

		public ZlibCodec compressor;

		public WorkItem(int size, CompressionLevel compressLevel, CompressionStrategy strategy, int ix)
		{
			buffer = new byte[size];
			int num = size + (size / 32768 + 1) * 5 * 2;
			compressed = new byte[num];
			compressor = new ZlibCodec();
			compressor.InitializeDeflate(compressLevel, wantRfc1950Header: false);
			compressor.OutputBuffer = compressed;
			compressor.InputBuffer = buffer;
			index = ix;
		}
	}
	public class ParallelDeflateOutputStream : Stream
	{
		[Flags]
		private enum TraceBits : uint
		{
			None = 0u,
			NotUsed1 = 1u,
			EmitLock = 2u,
			EmitEnter = 4u,
			EmitBegin = 8u,
			EmitDone = 0x10u,
			EmitSkip = 0x20u,
			EmitAll = 0x3Au,
			Flush = 0x40u,
			Lifecycle = 0x80u,
			Session = 0x100u,
			Synch = 0x200u,
			Instance = 0x400u,
			Compress = 0x800u,
			Write = 0x1000u,
			WriteEnter = 0x2000u,
			WriteTake = 0x4000u,
			All = uint.MaxValue
		}

		private static readonly int IO_BUFFER_SIZE_DEFAULT = 65536;

		private static readonly int BufferPairsPerCore = 4;

		private List<WorkItem> _pool;

		private bool _leaveOpen;

		private bool emitting;

		private Stream _outStream;

		private int _maxBufferPairs;

		private int _bufferSize = IO_BUFFER_SIZE_DEFAULT;

		private AutoResetEvent _newlyCompressedBlob;

		private object _outputLock = new object();

		private bool _isClosed;

		private bool _firstWriteDone;

		private int _currentlyFilling;

		private int _lastFilled;

		private int _lastWritten;

		private int _latestCompressed;

		private int _Crc32;

		private CRC32 _runningCrc;

		private object _latestLock = new object();

		private Queue<int> _toWrite;

		private Queue<int> _toFill;

		private long _totalBytesProcessed;

		private CompressionLevel _compressLevel;

		private volatile Exception _pendingException;

		private bool _handlingException;

		private object _eLock = new object();

		private TraceBits _DesiredTrace = TraceBits.EmitAll | TraceBits.EmitEnter | TraceBits.Session | TraceBits.Compress | TraceBits.WriteEnter | TraceBits.WriteTake;

		public CompressionStrategy Strategy { get; private set; }

		public int MaxBufferPairs
		{
			get
			{
				return _maxBufferPairs;
			}
			set
			{
				if (value < 4)
				{
					throw new ArgumentException("MaxBufferPairs", "Value must be 4 or greater.");
				}
				_maxBufferPairs = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _bufferSize;
			}
			set
			{
				if (value < 1024)
				{
					throw new ArgumentOutOfRangeException("BufferSize", "BufferSize must be greater than 1024 bytes");
				}
				_bufferSize = value;
			}
		}

		public int Crc32 => _Crc32;

		public long BytesProcessed => _totalBytesProcessed;

		public override bool CanSeek => false;

		public override bool CanRead => false;

		public override bool CanWrite => _outStream.CanWrite;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				return _outStream.Position;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public ParallelDeflateOutputStream(Stream stream)
			: this(stream, CompressionLevel.Default, CompressionStrategy.Default, leaveOpen: false)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, CompressionLevel level)
			: this(stream, level, CompressionStrategy.Default, leaveOpen: false)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, bool leaveOpen)
			: this(stream, CompressionLevel.Default, CompressionStrategy.Default, leaveOpen)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, bool leaveOpen)
			: this(stream, CompressionLevel.Default, CompressionStrategy.Default, leaveOpen)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, CompressionStrategy strategy, bool leaveOpen)
		{
			_outStream = stream;
			_compressLevel = level;
			Strategy = strategy;
			_leaveOpen = leaveOpen;
			MaxBufferPairs = 16;
		}

		private void _InitializePoolOfWorkItems()
		{
			_toWrite = new Queue<int>();
			_toFill = new Queue<int>();
			_pool = new List<WorkItem>();
			int val = BufferPairsPerCore * Environment.ProcessorCount;
			val = Math.Min(val, _maxBufferPairs);
			for (int i = 0; i < val; i++)
			{
				_pool.Add(new WorkItem(_bufferSize, _compressLevel, Strategy, i));
				_toFill.Enqueue(i);
			}
			_newlyCompressedBlob = new AutoResetEvent(initialState: false);
			_runningCrc = new CRC32();
			_currentlyFilling = -1;
			_lastFilled = -1;
			_lastWritten = -1;
			_latestCompressed = -1;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			bool mustWait = false;
			if (_isClosed)
			{
				throw new InvalidOperationException();
			}
			if (_pendingException != null)
			{
				_handlingException = true;
				Exception pendingException = _pendingException;
				_pendingException = null;
				throw pendingException;
			}
			if (count == 0)
			{
				return;
			}
			if (!_firstWriteDone)
			{
				_InitializePoolOfWorkItems();
				_firstWriteDone = true;
			}
			do
			{
				EmitPendingBuffers(doAll: false, mustWait);
				mustWait = false;
				int num = -1;
				if (_currentlyFilling >= 0)
				{
					num = _currentlyFilling;
				}
				else
				{
					if (_toFill.Count == 0)
					{
						mustWait = true;
						continue;
					}
					num = _toFill.Dequeue();
					_lastFilled++;
				}
				WorkItem workItem = _pool[num];
				int num2 = ((workItem.buffer.Length - workItem.inputBytesAvailable <= count) ? (workItem.buffer.Length - workItem.inputBytesAvailable) : count);
				workItem.ordinal = _lastFilled;
				Buffer.BlockCopy(buffer, offset, workItem.buffer, workItem.inputBytesAvailable, num2);
				count -= num2;
				offset += num2;
				workItem.inputBytesAvailable += num2;
				if (workItem.inputBytesAvailable == workItem.buffer.Length)
				{
					if (!ThreadPool.QueueUserWorkItem(_DeflateOne, workItem))
					{
						throw new Exception("Cannot enqueue workitem");
					}
					_currentlyFilling = -1;
				}
				else
				{
					_currentlyFilling = num;
				}
				if (count <= 0)
				{
				}
			}
			while (count > 0);
		}

		private void _FlushFinish()
		{
			byte[] array = new byte[128];
			ZlibCodec zlibCodec = new ZlibCodec();
			int num = zlibCodec.InitializeDeflate(_compressLevel, wantRfc1950Header: false);
			zlibCodec.InputBuffer = null;
			zlibCodec.NextIn = 0;
			zlibCodec.AvailableBytesIn = 0;
			zlibCodec.OutputBuffer = array;
			zlibCodec.NextOut = 0;
			zlibCodec.AvailableBytesOut = array.Length;
			num = zlibCodec.Deflate(FlushType.Finish);
			if (num != 1 && num != 0)
			{
				throw new Exception("deflating: " + zlibCodec.Message);
			}
			if (array.Length - zlibCodec.AvailableBytesOut > 0)
			{
				_outStream.Write(array, 0, array.Length - zlibCodec.AvailableBytesOut);
			}
			zlibCodec.EndDeflate();
			_Crc32 = _runningCrc.Crc32Result;
		}

		private void _Flush(bool lastInput)
		{
			if (_isClosed)
			{
				throw new InvalidOperationException();
			}
			if (!emitting)
			{
				if (_currentlyFilling >= 0)
				{
					WorkItem wi = _pool[_currentlyFilling];
					_DeflateOne(wi);
					_currentlyFilling = -1;
				}
				if (lastInput)
				{
					EmitPendingBuffers(doAll: true, mustWait: false);
					_FlushFinish();
				}
				else
				{
					EmitPendingBuffers(doAll: false, mustWait: false);
				}
			}
		}

		public override void Flush()
		{
			if (_pendingException != null)
			{
				_handlingException = true;
				Exception pendingException = _pendingException;
				_pendingException = null;
				throw pendingException;
			}
			if (!_handlingException)
			{
				_Flush(lastInput: false);
			}
		}

		public override void Close()
		{
			if (_pendingException != null)
			{
				_handlingException = true;
				Exception pendingException = _pendingException;
				_pendingException = null;
				throw pendingException;
			}
			if (!_handlingException && !_isClosed)
			{
				_Flush(lastInput: true);
				if (!_leaveOpen)
				{
					_outStream.Close();
				}
				_isClosed = true;
			}
		}

		public new void Dispose()
		{
			Close();
			_pool = null;
			Dispose(disposing: true);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		public void Reset(Stream stream)
		{
			if (!_firstWriteDone)
			{
				return;
			}
			_toWrite.Clear();
			_toFill.Clear();
			foreach (WorkItem item in _pool)
			{
				_toFill.Enqueue(item.index);
				item.ordinal = -1;
			}
			_firstWriteDone = false;
			_totalBytesProcessed = 0L;
			_runningCrc = new CRC32();
			_isClosed = false;
			_currentlyFilling = -1;
			_lastFilled = -1;
			_lastWritten = -1;
			_latestCompressed = -1;
			_outStream = stream;
		}

		private void EmitPendingBuffers(bool doAll, bool mustWait)
		{
			if (emitting)
			{
				return;
			}
			emitting = true;
			if (doAll || mustWait)
			{
				_newlyCompressedBlob.WaitOne();
			}
			do
			{
				int num = -1;
				int num2 = (doAll ? 200 : (mustWait ? (-1) : 0));
				int num3 = -1;
				do
				{
					if (Monitor.TryEnter(_toWrite, num2))
					{
						num3 = -1;
						try
						{
							if (_toWrite.Count > 0)
							{
								num3 = _toWrite.Dequeue();
							}
						}
						finally
						{
							Monitor.Exit(_toWrite);
						}
						if (num3 < 0)
						{
							continue;
						}
						WorkItem workItem = _pool[num3];
						if (workItem.ordinal != _lastWritten + 1)
						{
							lock (_toWrite)
							{
								_toWrite.Enqueue(num3);
							}
							if (num == num3)
							{
								_newlyCompressedBlob.WaitOne();
								num = -1;
							}
							else if (num == -1)
							{
								num = num3;
							}
							continue;
						}
						num = -1;
						_outStream.Write(workItem.compressed, 0, workItem.compressedBytesAvailable);
						_runningCrc.Combine(workItem.crc, workItem.inputBytesAvailable);
						_totalBytesProcessed += workItem.inputBytesAvailable;
						workItem.inputBytesAvailable = 0;
						_lastWritten = workItem.ordinal;
						_toFill.Enqueue(workItem.index);
						if (num2 == -1)
						{
							num2 = 0;
						}
					}
					else
					{
						num3 = -1;
					}
				}
				while (num3 >= 0);
			}
			while (doAll && _lastWritten != _latestCompressed);
			emitting = false;
		}

		private void _DeflateOne(object wi)
		{
			WorkItem workItem = (WorkItem)wi;
			try
			{
				CRC32 cRC = new CRC32();
				cRC.SlurpBlock(workItem.buffer, 0, workItem.inputBytesAvailable);
				DeflateOneSegment(workItem);
				workItem.crc = cRC.Crc32Result;
				lock (_latestLock)
				{
					if (workItem.ordinal > _latestCompressed)
					{
						_latestCompressed = workItem.ordinal;
					}
				}
				lock (_toWrite)
				{
					_toWrite.Enqueue(workItem.index);
				}
				_newlyCompressedBlob.Set();
			}
			catch (Exception pendingException)
			{
				lock (_eLock)
				{
					if (_pendingException != null)
					{
						_pendingException = pendingException;
					}
				}
			}
		}

		private bool DeflateOneSegment(WorkItem workitem)
		{
			ZlibCodec compressor = workitem.compressor;
			int num = 0;
			compressor.ResetDeflate();
			compressor.NextIn = 0;
			compressor.AvailableBytesIn = workitem.inputBytesAvailable;
			compressor.NextOut = 0;
			compressor.AvailableBytesOut = workitem.compressed.Length;
			do
			{
				compressor.Deflate(FlushType.None);
			}
			while (compressor.AvailableBytesIn > 0 || compressor.AvailableBytesOut == 0);
			num = compressor.Deflate(FlushType.Sync);
			workitem.compressedBytesAvailable = (int)compressor.TotalBytesOut;
			return true;
		}

		[Conditional("Trace")]
		private void TraceOutput(TraceBits bits, string format, params object[] varParams)
		{
			if ((bits & _DesiredTrace) != 0)
			{
				lock (_outputLock)
				{
					int hashCode = Thread.CurrentThread.GetHashCode();
					Console.Write("{0:000} PDOS ", hashCode);
					Console.WriteLine(format, varParams);
				}
			}
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class ZTree
	{
		private static readonly int HEAP_SIZE = 2 * InternalConstants.L_CODES + 1;

		internal static readonly int[] ExtraLengthBits = new int[29]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
			1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
			4, 4, 4, 4, 5, 5, 5, 5, 0
		};

		internal static readonly int[] ExtraDistanceBits = new int[30]
		{
			0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
			4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
			9, 9, 10, 10, 11, 11, 12, 12, 13, 13
		};

		internal static readonly int[] extra_blbits = new int[19]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 2, 3, 7
		};

		internal static readonly sbyte[] bl_order = new sbyte[19]
		{
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5,
			11, 4, 12, 3, 13, 2, 14, 1, 15
		};

		internal const int Buf_size = 16;

		private static readonly sbyte[] _dist_code = new sbyte[512]
		{
			0, 1, 2, 3, 4, 4, 5, 5, 6, 6,
			6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
			8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
			9, 9, 10, 10, 10, 10, 10, 10, 10, 10,
			10, 10, 10, 10, 10, 10, 10, 10, 11, 11,
			11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
			11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
			13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
			13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
			13, 13, 13, 13, 13, 13, 13, 13, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 0, 0, 16, 17,
			18, 18, 19, 19, 20, 20, 20, 20, 21, 21,
			21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
			23, 23, 23, 23, 23, 23, 23, 23, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29
		};

		internal static readonly sbyte[] LengthCode = new sbyte[256]
		{
			0, 1, 2, 3, 4, 5, 6, 7, 8, 8,
			9, 9, 10, 10, 11, 11, 12, 12, 12, 12,
			13, 13, 13, 13, 14, 14, 14, 14, 15, 15,
			15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
			17, 17, 17, 17, 17, 17, 17, 17, 18, 18,
			18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
			19, 19, 19, 19, 20, 20, 20, 20, 20, 20,
			20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
			21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
			21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
			22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
			22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
			23, 23, 23, 23, 23, 23, 23, 23, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 28
		};

		internal static readonly int[] LengthBase = new int[29]
		{
			0, 1, 2, 3, 4, 5, 6, 7, 8, 10,
			12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
			64, 80, 96, 112, 128, 160, 192, 224, 0
		};

		internal static readonly int[] DistanceBase = new int[30]
		{
			0, 1, 2, 3, 4, 6, 8, 12, 16, 24,
			32, 48, 64, 96, 128, 192, 256, 384, 512, 768,
			1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576
		};

		internal short[] dyn_tree;

		internal int max_code;

		internal StaticTree staticTree;

		internal static int DistanceCode(int dist)
		{
			return (dist >= 256) ? _dist_code[256 + SharedUtils.URShift(dist, 7)] : _dist_code[dist];
		}

		internal void gen_bitlen(DeflateManager s)
		{
			short[] array = dyn_tree;
			short[] treeCodes = staticTree.treeCodes;
			int[] extraBits = staticTree.extraBits;
			int extraBase = staticTree.extraBase;
			int maxLength = staticTree.maxLength;
			int num = 0;
			for (int i = 0; i <= InternalConstants.MAX_BITS; i++)
			{
				s.bl_count[i] = 0;
			}
			array[s.heap[s.heap_max] * 2 + 1] = 0;
			int j;
			for (j = s.heap_max + 1; j < HEAP_SIZE; j++)
			{
				int num2 = s.heap[j];
				int i = array[array[num2 * 2 + 1] * 2 + 1] + 1;
				if (i > maxLength)
				{
					i = maxLength;
					num++;
				}
				array[num2 * 2 + 1] = (short)i;
				if (num2 <= max_code)
				{
					s.bl_count[i]++;
					int num3 = 0;
					if (num2 >= extraBase)
					{
						num3 = extraBits[num2 - extraBase];
					}
					short num4 = array[num2 * 2];
					s.opt_len += num4 * (i + num3);
					if (treeCodes != null)
					{
						s.static_len += num4 * (treeCodes[num2 * 2 + 1] + num3);
					}
				}
			}
			if (num == 0)
			{
				return;
			}
			do
			{
				int i = maxLength - 1;
				while (s.bl_count[i] == 0)
				{
					i--;
				}
				s.bl_count[i]--;
				s.bl_count[i + 1] = (short)(s.bl_count[i + 1] + 2);
				s.bl_count[maxLength]--;
				num -= 2;
			}
			while (num > 0);
			for (int i = maxLength; i != 0; i--)
			{
				int num2 = s.bl_count[i];
				while (num2 != 0)
				{
					int num5 = s.heap[--j];
					if (num5 <= max_code)
					{
						if (array[num5 * 2 + 1] != i)
						{
							s.opt_len = (int)(s.opt_len + ((long)i - (long)array[num5 * 2 + 1]) * array[num5 * 2]);
							array[num5 * 2 + 1] = (short)i;
						}
						num2--;
					}
				}
			}
		}

		internal void build_tree(DeflateManager s)
		{
			short[] array = dyn_tree;
			short[] treeCodes = staticTree.treeCodes;
			int elems = staticTree.elems;
			int num = -1;
			s.heap_len = 0;
			s.heap_max = HEAP_SIZE;
			for (int i = 0; i < elems; i++)
			{
				if (array[i * 2] != 0)
				{
					num = (s.heap[++s.heap_len] = i);
					s.depth[i] = 0;
				}
				else
				{
					array[i * 2 + 1] = 0;
				}
			}
			int num2;
			while (s.heap_len < 2)
			{
				num2 = (s.heap[++s.heap_len] = ((num < 2) ? (++num) : 0));
				array[num2 * 2] = 1;
				s.depth[num2] = 0;
				s.opt_len--;
				if (treeCodes != null)
				{
					s.static_len -= treeCodes[num2 * 2 + 1];
				}
			}
			max_code = num;
			for (int i = s.heap_len / 2; i >= 1; i--)
			{
				s.pqdownheap(array, i);
			}
			num2 = elems;
			do
			{
				int i = s.heap[1];
				s.heap[1] = s.heap[s.heap_len--];
				s.pqdownheap(array, 1);
				int num3 = s.heap[1];
				s.heap[--s.heap_max] = i;
				s.heap[--s.heap_max] = num3;
				array[num2 * 2] = (short)(array[i * 2] + array[num3 * 2]);
				s.depth[num2] = (sbyte)(Math.Max((byte)s.depth[i], (byte)s.depth[num3]) + 1);
				array[i * 2 + 1] = (array[num3 * 2 + 1] = (short)num2);
				s.heap[1] = num2++;
				s.pqdownheap(array, 1);
			}
			while (s.heap_len >= 2);
			s.heap[--s.heap_max] = s.heap[1];
			gen_bitlen(s);
			gen_codes(array, num, s.bl_count);
		}

		internal static void gen_codes(short[] tree, int max_code, short[] bl_count)
		{
			short[] array = new short[InternalConstants.MAX_BITS + 1];
			short num = 0;
			for (int i = 1; i <= InternalConstants.MAX_BITS; i++)
			{
				num = (array[i] = (short)(num + bl_count[i - 1] << 1));
			}
			for (int j = 0; j <= max_code; j++)
			{
				int num2 = tree[j * 2 + 1];
				if (num2 != 0)
				{
					tree[j * 2] = (short)bi_reverse(array[num2]++, num2);
				}
			}
		}

		internal static int bi_reverse(int code, int len)
		{
			int num = 0;
			do
			{
				num |= code & 1;
				code >>= 1;
				num <<= 1;
			}
			while (--len > 0);
			return num >> 1;
		}
	}
	public enum FlushType
	{
		None,
		Partial,
		Sync,
		Full,
		Finish
	}
	public enum CompressionLevel
	{
		None = 0,
		Level0 = 0,
		BestSpeed = 1,
		Level1 = 1,
		Level2 = 2,
		Level3 = 3,
		Level4 = 4,
		Level5 = 5,
		Default = 6,
		Level6 = 6,
		Level7 = 7,
		Level8 = 8,
		BestCompression = 9,
		Level9 = 9
	}
	public enum CompressionStrategy
	{
		Default,
		Filtered,
		HuffmanOnly
	}
	public enum CompressionMode
	{
		Compress,
		Decompress
	}
	[Guid("ebc25cf6-9120-4283-b972-0e5520d0000E")]
	public class ZlibException : Exception
	{
		public ZlibException()
		{
		}

		public ZlibException(string s)
			: base(s)
		{
		}
	}
	internal class SharedUtils
	{
		public static int URShift(int number, int bits)
		{
			return number >>> bits;
		}

		public static int ReadInput(TextReader sourceTextReader, byte[] target, int start, int count)
		{
			if (target.Length == 0)
			{
				return 0;
			}
			char[] array = new char[target.Length];
			int num = sourceTextReader.Read(array, start, count);
			if (num == 0)
			{
				return -1;
			}
			for (int i = start; i < start + num; i++)
			{
				target[i] = (byte)array[i];
			}
			return num;
		}

		internal static byte[] ToByteArray(string sourceString)
		{
			return Encoding.UTF8.GetBytes(sourceString);
		}

		internal static char[] ToCharArray(byte[] byteArray)
		{
			return Encoding.UTF8.GetChars(byteArray);
		}
	}
	internal static class InternalConstants
	{
		internal static readonly int MAX_BITS = 15;

		internal static readonly int BL_CODES = 19;

		internal static readonly int D_CODES = 30;

		internal static readonly int LITERALS = 256;

		internal static readonly int LENGTH_CODES = 29;

		internal static readonly int L_CODES = LITERALS + 1 + LENGTH_CODES;

		internal static readonly int MAX_BL_BITS = 7;

		internal static readonly int REP_3_6 = 16;

		internal static readonly int REPZ_3_10 = 17;

		internal static readonly int REPZ_11_138 = 18;
	}
	internal sealed class StaticTree
	{
		internal static readonly short[] lengthAndLiteralsTreeCodes;

		internal static readonly short[] distTreeCodes;

		internal static readonly StaticTree Literals;

		internal static readonly StaticTree Distances;

		internal static readonly StaticTree BitLengths;

		internal short[] treeCodes;

		internal int[] extraBits;

		internal int extraBase;

		internal int elems;

		internal int maxLength;

		private StaticTree(short[] treeCodes, int[] extraBits, int extraBase, int elems, int maxLength)
		{
			this.treeCodes = treeCodes;
			this.extraBits = extraBits;
			this.extraBase = extraBase;
			this.elems = elems;
			this.maxLength = maxLength;
		}

		static StaticTree()
		{
			lengthAndLiteralsTreeCodes = new short[576]
			{
				12, 8, 140, 8, 76, 8, 204, 8, 44, 8,
				172, 8, 108, 8, 236, 8, 28, 8, 156, 8,
				92, 8, 220, 8, 60, 8, 188, 8, 124, 8,
				252, 8, 2, 8, 130, 8, 66, 8, 194, 8,
				34, 8, 162, 8, 98, 8, 226, 8, 18, 8,
				146, 8, 82, 8, 210, 8, 50, 8, 178, 8,
				114, 8, 242, 8, 10, 8, 138, 8, 74, 8,
				202, 8, 42, 8, 170, 8, 106, 8, 234, 8,
				26, 8, 154, 8, 90, 8, 218, 8, 58, 8,
				186, 8, 122, 8, 250, 8, 6, 8, 134, 8,
				70, 8, 198, 8, 38, 8, 166, 8, 102, 8,
				230, 8, 22, 8, 150, 8, 86, 8, 214, 8,
				54, 8, 182, 8, 118, 8, 246, 8, 14, 8,
				142, 8, 78, 8, 206, 8, 46, 8, 174, 8,
				110, 8, 238, 8, 30, 8, 158, 8, 94, 8,
				222, 8, 62, 8, 190, 8, 126, 8, 254, 8,
				1, 8, 129, 8, 65, 8, 193, 8, 33, 8,
				161, 8, 97, 8, 225, 8, 17, 8, 145, 8,
				81, 8, 209, 8, 49, 8, 177, 8, 113, 8,
				241, 8, 9, 8, 137, 8, 73, 8, 201, 8,
				41, 8, 169, 8, 105, 8, 233, 8, 25, 8,
				153, 8, 89, 8, 217, 8, 57, 8, 185, 8,
				121, 8, 249, 8, 5, 8, 133, 8, 69, 8,
				197, 8, 37, 8, 165, 8, 101, 8, 229, 8,
				21, 8, 149, 8, 85, 8, 213, 8, 53, 8,
				181, 8, 117, 8, 245, 8, 13, 8, 141, 8,
				77, 8, 205, 8, 45, 8, 173, 8, 109, 8,
				237, 8, 29, 8, 157, 8, 93, 8, 221, 8,
				61, 8, 189, 8, 125, 8, 253, 8, 19, 9,
				275, 9, 147, 9, 403, 9, 83, 9, 339, 9,
				211, 9, 467, 9, 51, 9, 307, 9, 179, 9,
				435, 9, 115, 9, 371, 9, 243, 9, 499, 9,
				11, 9, 267, 9, 139, 9, 395, 9, 75, 9,
				331, 9, 203, 9, 459, 9, 43, 9, 299, 9,
				171, 9, 427, 9, 107, 9, 363, 9, 235, 9,
				491, 9, 27, 9, 283, 9, 155, 9, 411, 9,
				91, 9, 347, 9, 219, 9, 475, 9, 59, 9,
				315, 9, 187, 9, 443, 9, 123, 9, 379, 9,
				251, 9, 507, 9, 7, 9, 263, 9, 135, 9,
				391, 9, 71, 9, 327, 9, 199, 9, 455, 9,
				39, 9, 295, 9, 167, 9, 423, 9, 103, 9,
				359, 9, 231, 9, 487, 9, 23, 9, 279, 9,
				151, 9, 407, 9, 87, 9, 343, 9, 215, 9,
				471, 9, 55, 9, 311, 9, 183, 9, 439, 9,
				119, 9, 375, 9, 247, 9, 503, 9, 15, 9,
				271, 9, 143, 9, 399, 9, 79, 9, 335, 9,
				207, 9, 463, 9, 47, 9, 303, 9, 175, 9,
				431, 9, 111, 9, 367, 9, 239, 9, 495, 9,
				31, 9, 287, 9, 159, 9, 415, 9, 95, 9,
				351, 9, 223, 9, 479, 9, 63, 9, 319, 9,
				191, 9, 447, 9, 127, 9, 383, 9, 255, 9,
				511, 9, 0, 7, 64, 7, 32, 7, 96, 7,
				16, 7, 80, 7, 48, 7, 112, 7, 8, 7,
				72, 7, 40, 7, 104, 7, 24, 7, 88, 7,
				56, 7, 120, 7, 4, 7, 68, 7, 36, 7,
				100, 7, 20, 7, 84, 7, 52, 7, 116, 7,
				3, 8, 131, 8, 67, 8, 195, 8, 35, 8,
				163, 8, 99, 8, 227, 8
			};
			distTreeCodes = new short[60]
			{
				0, 5, 16, 5, 8, 5, 24, 5, 4, 5,
				20, 5, 12, 5, 28, 5, 2, 5, 18, 5,
				10, 5, 26, 5, 6, 5, 22, 5, 14, 5,
				30, 5, 1, 5, 17, 5, 9, 5, 25, 5,
				5, 5, 21, 5, 13, 5, 29, 5, 3, 5,
				19, 5, 11, 5, 27, 5, 7, 5, 23, 5
			};
			Literals = new StaticTree(lengthAndLiteralsTreeCodes, ZTree.ExtraLengthBits, InternalConstants.LITERALS + 1, InternalConstants.L_CODES, InternalConstants.MAX_BITS);
			Distances = new StaticTree(distTreeCodes, ZTree.ExtraDistanceBits, 0, InternalConstants.D_CODES, InternalConstants.MAX_BITS);
			BitLengths = new StaticTree(null, ZTree.extra_blbits, 0, InternalConstants.BL_CODES, InternalConstants.MAX_BL_BITS);
		}
	}
	public sealed class Adler
	{
		private static readonly uint BASE = 65521u;

		private static readonly int NMAX = 5552;

		public static uint Adler32(uint adler, byte[] buf, int index, int len)
		{
			if (buf == null)
			{
				return 1u;
			}
			uint num = adler & 0xFFFFu;
			uint num2 = (adler >> 16) & 0xFFFFu;
			while (len > 0)
			{
				int num3 = ((len >= NMAX) ? NMAX : len);
				len -= num3;
				while (num3 >= 16)
				{
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num3 -= 16;
				}
				if (num3 != 0)
				{
					do
					{
						num += buf[index++];
						num2 += num;
					}
					while (--num3 != 0);
				}
				num %= BASE;
				num2 %= BASE;
			}
			return (num2 << 16) | num;
		}
	}
	internal enum ZlibStreamFlavor
	{
		ZLIB = 1950,
		DEFLATE,
		GZIP
	}
	internal class ZlibBaseStream : Stream
	{
		internal enum StreamMode
		{
			Writer,
			Reader,
			Undefined
		}

		protected internal ZlibCodec _z;

		protected internal StreamMode _streamMode = StreamMode.Undefined;

		protected internal FlushType _flushMode;

		protected internal ZlibStreamFlavor _flavor;

		protected internal CompressionMode _compressionMode;

		protected internal CompressionLevel _level;

		protected internal bool _leaveOpen;

		protected internal byte[] _workingBuffer;

		protected internal int _bufferSize = 16384;

		protected internal byte[] _buf1 = new byte[1];

		protected internal Stream _stream;

		protected internal CompressionStrategy Strategy;

		private CRC32 crc;

		protected internal string _GzipFileName;

		protected internal string _GzipComment;

		protected internal DateTime _GzipMtime;

		protected internal int _gzipHeaderByteCount;

		private bool nomoreinput;

		internal int Crc32
		{
			get
			{
				if (crc == null)
				{
					return 0;
				}
				return crc.Crc32Result;
			}
		}

		protected internal bool _wantCompress => _compressionMode == CompressionMode.Compress;

		private ZlibCodec z
		{
			get
			{
				if (_z == null)
				{
					bool flag = _flavor == ZlibStreamFlavor.ZLIB;
					_z = new ZlibCodec();
					if (_compressionMode == CompressionMode.Decompress)
					{
						_z.InitializeInflate(flag);
					}
					else
					{
						_z.Strategy = Strategy;
						_z.InitializeDeflate(_level, flag);
					}
				}
				return _z;
			}
		}

		private byte[] workingBuffer
		{
			get
			{
				if (_workingBuffer == null)
				{
					_workingBuffer = new byte[_bufferSize];
				}
				return _workingBuffer;
			}
		}

		public override bool CanRead => _stream.CanRead;

		public override bool CanSeek => _stream.CanSeek;

		public override bool CanWrite => _stream.CanWrite;

		public override long Length => _stream.Length;

		public override long Position
		{
			get
			{
				throw new NotImplementedException();
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		public ZlibBaseStream(Stream stream, CompressionMode compressionMode, CompressionLevel level, ZlibStreamFlavor flavor, bool leaveOpen)
		{
			_flushMode = FlushType.None;
			_stream = stream;
			_leaveOpen = leaveOpen;
			_compressionMode = compressionMode;
			_flavor = flavor;
			_level = level;
			if (flavor == ZlibStreamFlavor.GZIP)
			{
				crc = new CRC32();
			}
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (crc != null)
			{
				crc.SlurpBlock(buffer, offset, count);
			}
			if (_streamMode == StreamMode.Undefined)
			{
				_streamMode = StreamMode.Writer;
			}
			else if (_streamMode != 0)
			{
				throw new ZlibException("Cannot Write after Reading.");
			}
			if (count == 0)
			{
				return;
			}
			z.InputBuffer = buffer;
			_z.NextIn = offset;
			_z.AvailableBytesIn = count;
			bool flag = false;
			do
			{
				_z.OutputBuffer = workingBuffer;
				_z.NextOut = 0;
				_z.AvailableBytesOut = _workingBuffer.Length;
				int num = ((!_wantCompress) ? _z.Inflate(_flushMode) : _z.Deflate(_flushMode));
				if (num != 0 && num != 1)
				{
					throw new ZlibException(((!_wantCompress) ? "in" : "de") + "flating: " + _z.Message);
				}
				_stream.Write(_workingBuffer, 0, _workingBuffer.Length - _z.AvailableBytesOut);
				flag = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;
				if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)
				{
					flag = _z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0;
				}
			}
			while (!flag);
		}

		private void finish()
		{
			if (_z == null)
			{
				return;
			}
			if (_streamMode == StreamMode.Writer)
			{
				bool flag = false;
				do
				{
					_z.OutputBuffer = workingBuffer;
					_z.NextOut = 0;
					_z.AvailableBytesOut = _workingBuffer.Length;
					int num = ((!_wantCompress) ? _z.Inflate(FlushType.Finish) : _z.Deflate(FlushType.Finish));
					if (num != 1 && num != 0)
					{
						string text = ((!_wantCompress) ? "in" : "de") + "flating";
						if (_z.Message == null)
						{
							throw new ZlibException($"{text}: (rc = {num})");
						}
						throw new ZlibException(text + ": " + _z.Message);
					}
					if (_workingBuffer.Length - _z.AvailableBytesOut > 0)
					{
						_stream.Write(_workingBuffer, 0, _workingBuffer.Length - _z.AvailableBytesOut);
					}
					flag = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;
					if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)
					{
						flag = _z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0;
					}
				}
				while (!flag);
				Flush();
				if (_flavor == ZlibStreamFlavor.GZIP)
				{
					if (!_wantCompress)
					{
						throw new ZlibException("Writing with decompression is not supported.");
					}
					int crc32Result = crc.Crc32Result;
					_stream.Write(BitConverter.GetBytes(crc32Result), 0, 4);
					int value = (int)(crc.TotalBytesRead & 0xFFFFFFFFu);
					_stream.Write(BitConverter.GetBytes(value), 0, 4);
				}
			}
			else
			{
				if (_streamMode != StreamMode.Reader || _flavor != ZlibStreamFlavor.GZIP)
				{
					return;
				}
				if (_wantCompress)
				{
					throw new ZlibException("Reading with compression is not supported.");
				}
				if (_z.TotalBytesOut == 0)
				{
					return;
				}
				byte[] array = new byte[8];
				if (_z.AvailableBytesIn < 8)
				{
					Array.Copy(_z.InputBuffer, _z.NextIn, array, 0, _z.AvailableBytesIn);
					int num2 = 8 - _z.AvailableBytesIn;
					int num3 = _stream.Read(array, _z.AvailableBytesIn, num2);
					if (num2 != num3)
					{
						throw new ZlibException($"Missing or incomplete GZIP trailer. Expected 8 bytes, got {_z.AvailableBytesIn + num3}.");
					}
				}
				else
				{
					Array.Copy(_z.InputBuffer, _z.NextIn, array, 0, array.Length);
				}
				int num4 = BitConverter.ToInt32(array, 0);
				int crc32Result2 = crc.Crc32Result;
				int num5 = BitConverter.ToInt32(array, 4);
				int num6 = (int)(_z.TotalBytesOut & 0xFFFFFFFFu);
				if (crc32Result2 != num4)
				{
					throw new ZlibException($"Bad CRC32 in GZIP trailer. (actual({crc32Result2:X8})!=expected({num4:X8}))");
				}
				if (num6 != num5)
				{
					throw new ZlibException($"Bad size in GZIP trailer. (actual({num6})!=expected({num5}))");
				}
			}
		}

		private void end()
		{
			if (z != null)
			{
				if (_wantCompress)
				{
					_z.EndDeflate();
				}
				else
				{
					_z.EndInflate();
				}
				_z = null;
			}
		}

		public override void Close()
		{
			if (_stream == null)
			{
				return;
			}
			try
			{
				finish();
			}
			finally
			{
				end();
				if (!_leaveOpen)
				{
					_stream.Close();
				}
				_stream = null;
			}
		}

		public override void Flush()
		{
			_stream.Flush();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotImplementedException();
		}

		public override void SetLength(long value)
		{
			_stream.SetLength(value);
		}

		private string ReadZeroTerminatedString()
		{
			List<byte> list = new List<byte>();
			bool flag = false;
			do
			{
				int num = _stream.Read(_buf1, 0, 1);
				if (num != 1)
				{
					throw new ZlibException("Unexpected EOF reading GZIP header.");
				}
				if (_buf1[0] == 0)
				{
					flag = true;
				}
				else
				{
					list.Add(_buf1[0]);
				}
			}
			while (!flag);
			byte[] array = list.ToArray();
			return GZipStream.iso8859dash1.GetString(array, 0, array.Length);
		}

		private int _ReadAndValidateGzipHeader()
		{
			int num = 0;
			byte[] array = new byte[10];
			int num2 = _stream.Read(array, 0, array.Length);
			switch (num2)
			{
			case 0:
				return 0;
			default:
				throw new ZlibException("Not a valid GZIP stream.");
			case 10:
			{
				if (array[0] != 31 || array[1] != 139 || array[2] != 8)
				{
					throw new ZlibException("Bad GZIP header.");
				}
				int num3 = BitConverter.ToInt32(array, 4);
				_GzipMtime = GZipStream._unixEpoch.AddSeconds(num3);
				num += num2;
				if ((array[3] & 4) == 4)
				{
					num2 = _stream.Read(array, 0, 2);
					num += num2;
					short num4 = (short)(array[0] + array[1] * 256);
					byte[] array2 = new byte[num4];
					num2 = _stream.Read(array2, 0, array2.Length);
					if (num2 != num4)
					{
						throw new ZlibException("Unexpected end-of-file reading GZIP header.");
					}
					num += num2;
				}
				if ((array[3] & 8) == 8)
				{
					_GzipFileName = ReadZeroTerminatedString();
				}
				if ((array[3] & 0x10) == 16)
				{
					_GzipComment = ReadZeroTerminatedString();
				}
				if ((array[3] & 2) == 2)
				{
					Read(_buf1, 0, 1);
				}
				return num;
			}
			}
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_streamMode == StreamMode.Undefined)
			{
				if (!_stream.CanRead)
				{
					throw new ZlibException("The stream is not readable.");
				}
				_streamMode = StreamMode.Reader;
				z.AvailableBytesIn = 0;
				if (_flavor == ZlibStreamFlavor.GZIP)
				{
					_gzipHeaderByteCount = _ReadAndValidateGzipHeader();
					if (_gzipHeaderByteCount == 0)
					{
						return 0;
					}
				}
			}
			if (_streamMode != StreamMode.Reader)
			{
				throw new ZlibException("Cannot Read after Writing.");
			}
			if (count == 0)
			{
				return 0;
			}
			if (nomoreinput && _wantCompress)
			{
				return 0;
			}
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (offset < buffer.GetLowerBound(0))
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (offset + count > buffer.GetLength(0))
			{
				throw new ArgumentOutOfRangeException("count");
			}
			int num = 0;
			_z.OutputBuffer = buffer;
			_z.NextOut = offset;
			_z.AvailableBytesOut = count;
			_z.InputBuffer = workingBuffer;
			do
			{
				if (_z.AvailableBytesIn == 0 && !nomoreinput)
				{
					_z.NextIn = 0;
					_z.AvailableBytesIn = _stream.Read(_workingBuffer, 0, _workingBuffer.Length);
					if (_z.AvailableBytesIn == 0)
					{
						nomoreinput = true;
					}
				}
				num = ((!_wantCompress) ? _z.Inflate(_flushMode) : _z.Deflate(_flushMode));
				if (nomoreinput && num == -5)
				{
					return 0;
				}
				if (num != 0 && num != 1)
				{
					throw new ZlibException(string.Format("{0}flating:  rc={1}  msg={2}", (!_wantCompress) ? "in" : "de", num, _z.Message));
				}
			}
			while (((!nomoreinput && num != 1) || _z.AvailableBytesOut != count) && _z.AvailableBytesOut > 0 && !nomoreinput && num == 0);
			if (_z.AvailableBytesOut > 0)
			{
				if (num != 0 || _z.AvailableBytesIn == 0)
				{
				}
				if (nomoreinput && _wantCompress)
				{
					num = _z.Deflate(FlushType.Finish);
					if (num != 0 && num != 1)
					{
						throw new ZlibException($"Deflating:  rc={num}  msg={_z.Message}");
					}
				}
			}
			num = count - _z.AvailableBytesOut;
			if (crc != null)
			{
				crc.SlurpBlock(buffer, offset, num);
			}
			return num;
		}

		public static void CompressString(string s, Stream compressor)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(s);
			using (compressor)
			{
				compressor.Write(bytes, 0, bytes.Length);
			}
		}

		public static void CompressBuffer(byte[] b, Stream compressor)
		{
			using (compressor)
			{
				compressor.Write(b, 0, b.Length);
			}
		}

		public static string UncompressString(byte[] compressed, Stream decompressor)
		{
			byte[] array = new byte[1024];
			Encoding uTF = Encoding.UTF8;
			using MemoryStream memoryStream = new MemoryStream();
			using (decompressor)
			{
				int count;
				while ((count = decompressor.Read(array, 0, array.Length)) != 0)
				{
					memoryStream.Write(array, 0, count);
				}
			}
			memoryStream.Seek(0L, SeekOrigin.Begin);
			StreamReader streamReader = new StreamReader(memoryStream, uTF);
			return streamReader.ReadToEnd();
		}

		public static byte[] UncompressBuffer(byte[] compressed, Stream decompressor)
		{
			byte[] array = new byte[1024];
			using MemoryStream memoryStream = new MemoryStream();
			using (decompressor)
			{
				int count;
				while ((count = decompressor.Read(array, 0, array.Length)) != 0)
				{
					memoryStream.Write(array, 0, count);
				}
			}
			return memoryStream.ToArray();
		}
	}
	[Guid("ebc25cf6-9120-4283-b972-0e5520d0000D")]
	[ComVisible(true)]
	[ClassInterface(ClassInterfaceType.AutoDispatch)]
	public sealed class ZlibCodec
	{
		public byte[] InputBuffer;

		public int NextIn;

		public int AvailableBytesIn;

		public long TotalBytesIn;

		public byte[] OutputBuffer;

		public int NextOut;

		public int AvailableBytesOut;

		public long TotalBytesOut;

		public string Message;

		internal DeflateManager dstate;

		internal InflateManager istate;

		internal uint _Adler32;

		public CompressionLevel CompressLevel = CompressionLevel.Default;

		public int WindowBits = 15;

		public CompressionStrategy Strategy;

		public int Adler32 => (int)_Adler32;

		public ZlibCodec()
		{
		}

		public ZlibCodec(CompressionMode mode)
		{
			switch (mode)
			{
			case CompressionMode.Compress:
				if (InitializeDeflate() != 0)
				{
					throw new ZlibException("Cannot initialize for deflate.");
				}
				break;
			case CompressionMode.Decompress:
				if (InitializeInflate() != 0)
				{
					throw new ZlibException("Cannot initialize for inflate.");
				}
				break;
			default:
				throw new ZlibException("Invalid ZlibStreamFlavor.");
			}
		}

		public int InitializeInflate()
		{
			return InitializeInflate(WindowBits);
		}

		public int InitializeInflate(bool expectRfc1950Header)
		{
			return InitializeInflate(WindowBits, expectRfc1950Header);
		}

		public int InitializeInflate(int windowBits)
		{
			WindowBits = windowBits;
			return InitializeInflate(windowBits, expectRfc1950Header: true);
		}

		public int InitializeInflate(int windowBits, bool expectRfc1950Header)
		{
			WindowBits = windowBits;
			if (dstate != null)
			{
				throw new ZlibException("You may not call InitializeInflate() after calling InitializeDeflate().");
			}
			istate = new InflateManager(expectRfc1950Header);
			return istate.Initialize(this, windowBits);
		}

		public int Inflate(FlushType flush)
		{
			if (istate == null)
			{
				throw new ZlibException("No Inflate State!");
			}
			return istate.Inflate(flush);
		}

		public int EndInflate()
		{
			if (istate == null)
			{
				throw new ZlibException("No Inflate State!");
			}
			int result = istate.End();
			istate = null;
			return result;
		}

		public int SyncInflate()
		{
			if (istate == null)
			{
				throw new ZlibException("No Inflate State!");
			}
			return istate.Sync();
		}

		public int InitializeDeflate()
		{
			return _InternalInitializeDeflate(wantRfc1950Header: true);
		}

		public int InitializeDeflate(CompressionLevel level)
		{
			CompressLevel = level;
			return _InternalInitializeDeflate(wantRfc1950Header: true);
		}

		public int InitializeDeflate(CompressionLevel level, bool wantRfc1950Header)
		{
			CompressLevel = level;
			return _InternalInitializeDeflate(wantRfc1950Header);
		}

		public int InitializeDeflate(CompressionLevel level, int bits)
		{
			CompressLevel = level;
			WindowBits = bits;
			return _InternalInitializeDeflate(wantRfc1950Header: true);
		}

		public int InitializeDeflate(CompressionLevel level, int bits, bool wantRfc1950Header)
		{
			CompressLevel = level;
			WindowBits = bits;
			return _InternalInitializeDeflate(wantRfc1950Header);
		}

		private int _InternalInitializeDeflate(bool wantRfc1950Header)
		{
			if (istate != null)
			{
				throw new ZlibException("You may not call InitializeDeflate() after calling InitializeInflate().");
			}
			dstate = new DeflateManager();
			dstate.WantRfc1950HeaderBytes = wantRfc1950Header;
			return dstate.Initialize(this, CompressLevel, WindowBits, Strategy);
		}

		public int Deflate(FlushType flush)
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			return dstate.Deflate(flush);
		}

		public int EndDeflate()
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			dstate = null;
			return 0;
		}

		public void ResetDeflate()
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			dstate.Reset();
		}

		public int SetDeflateParams(CompressionLevel level, CompressionStrategy strategy)
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			return dstate.SetParams(level, strategy);
		}

		public int SetDictionary(byte[] dictionary)
		{
			if (istate != null)
			{
				return istate.SetDictionary(dictionary);
			}
			if (dstate != null)
			{
				return dstate.SetDictionary(dictionary);
			}
			throw new ZlibException("No Inflate or Deflate state!");
		}

		internal void flush_pending()
		{
			int num = dstate.pendingCount;
			if (num > AvailableBytesOut)
			{
				num = AvailableBytesOut;
			}
			if (num != 0)
			{
				if (dstate.pending.Length <= dstate.nextPending || OutputBuffer.Length <= NextOut || dstate.pending.Length < dstate.nextPending + num || OutputBuffer.Length < NextOut + num)
				{
					throw new ZlibException($"Invalid State. (pending.Length={dstate.pending.Length}, pendingCount={dstate.pendingCount})");
				}
				Array.Copy(dstate.pending, dstate.nextPending, OutputBuffer, NextOut, num);
				NextOut += num;
				dstate.nextPending += num;
				TotalBytesOut += num;
				AvailableBytesOut -= num;
				dstate.pendingCount -= num;
				if (dstate.pendingCount == 0)
				{
					dstate.nextPending = 0;
				}
			}
		}

		internal int read_buf(byte[] buf, int start, int size)
		{
			int num = AvailableBytesIn;
			if (num > size)
			{
				num = size;
			}
			if (num == 0)
			{
				return 0;
			}
			AvailableBytesIn -= num;
			if (dstate.WantRfc1950HeaderBytes)
			{
				_Adler32 = Adler.Adler32(_Adler32, InputBuffer, NextIn, num);
			}
			Array.Copy(InputBuffer, NextIn, buf, start, num);
			NextIn += num;
			TotalBytesIn += num;
			return num;
		}
	}
	public static class ZlibConstants
	{
		public const int WindowBitsMax = 15;

		public const int WindowBitsDefault = 15;

		public const int Z_OK = 0;

		public const int Z_STREAM_END = 1;

		public const int Z_NEED_DICT = 2;

		public const int Z_STREAM_ERROR = -2;

		public const int Z_DATA_ERROR = -3;

		public const int Z_BUF_ERROR = -5;

		public const int WorkingBufferSizeDefault = 16384;

		public const int WorkingBufferSizeMin = 1024;
	}
	public class ZlibStream : Stream
	{
		internal ZlibBaseStream _baseStream;

		private bool _disposed;

		public virtual FlushType FlushMode
		{
			get
			{
				return _baseStream._flushMode;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				_baseStream._flushMode = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _baseStream._bufferSize;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				if (_baseStream._workingBuffer != null)
				{
					throw new ZlibException("The working buffer is already set.");
				}
				if (value < 1024)
				{
					throw new ZlibException($"Don't be silly. {value} bytes?? Use a bigger buffer, at least {1024}.");
				}
				_baseStream._bufferSize = value;
			}
		}

		public virtual long TotalIn => _baseStream._z.TotalBytesIn;

		public virtual long TotalOut => _baseStream._z.TotalBytesOut;

		public override bool CanRead
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				return _baseStream._stream.CanRead;
			}
		}

		public override bool CanSeek => false;

		public override bool CanWrite
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				return _baseStream._stream.CanWrite;
			}
		}

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Writer)
				{
					return _baseStream._z.TotalBytesOut;
				}
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Reader)
				{
					return _baseStream._z.TotalBytesIn;
				}
				return 0L;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public ZlibStream(Stream stream, CompressionMode mode)
			: this(stream, mode, CompressionLevel.Default, leaveOpen: false)
		{
		}

		public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level)
			: this(stream, mode, level, leaveOpen: false)
		{
		}

		public ZlibStream(Stream stream, CompressionMode mode, bool leaveOpen)
			: this(stream, mode, CompressionLevel.Default, leaveOpen)
		{
		}

		public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen)
		{
			_baseStream = new ZlibBaseStream(stream, mode, level, ZlibStreamFlavor.ZLIB, leaveOpen);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!_disposed)
				{
					if (disposing && _baseStream != null)
					{
						_baseStream.Close();
					}
					_disposed = true;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("ZlibStream");
			}
			_baseStream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("ZlibStream");
			}
			return _baseStream.Read(buffer, offset, count);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("ZlibStream");
			}
			_baseStream.Write(buffer, offset, count);
		}

		public static byte[] CompressString(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new ZlibStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressString(s, compressor);
			return memoryStream.ToArray();
		}

		public static byte[] CompressBuffer(byte[] b)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new ZlibStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressBuffer(b, compressor);
			return memoryStream.ToArray();
		}

		public static string UncompressString(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new ZlibStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressString(compressed, decompressor);
		}

		public static byte[] UncompressBuffer(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new ZlibStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressBuffer(compressed, decompressor);
		}
	}
}
namespace Newtonsoft.Json
{
	public enum ConstructorHandling
	{
		Default,
		AllowNonPublicDefaultConstructor
	}
}
namespace Newtonsoft.Json.Converters
{
	public abstract class CustomCreationConverter<T> : JsonConverter
	{
		public override bool CanWrite => false;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			throw new NotSupportedException("CustomCreationConverter should only be used while deserializing.");
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			T val = Create(objectType);
			if (val == null)
			{
				throw new JsonSerializationException("No object created.");
			}
			serializer.Populate(reader, val);
			return val;
		}

		public abstract T Create(Type objectType);

		public override bool CanConvert(Type objectType)
		{
			return typeof(T).IsAssignableFrom(objectType);
		}
	}
	public abstract class DateTimeConverterBase : JsonConverter
	{
		public override bool CanConvert(Type objectType)
		{
			if (objectType == typeof(DateTime) || objectType == typeof(DateTime?))
			{
				return true;
			}
			return false;
		}
	}
	public class IsoDateTimeConverter : DateTimeConverterBase
	{
		private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

		private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;

		private string _dateTimeFormat;

		private CultureInfo _culture;

		public DateTimeStyles DateTimeStyles
		{
			get
			{
				return _dateTimeStyles;
			}
			set
			{
				_dateTimeStyles = value;
			}
		}

		public string DateTimeFormat
		{
			get
			{
				return _dateTimeFormat ?? string.Empty;
			}
			set
			{
				_dateTimeFormat = Newtonsoft.Json.Utilities.StringUtils.NullEmptyString(value);
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.CurrentCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value is DateTime dateTime)
			{
				if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
				{
					dateTime = dateTime.ToUniversalTime();
				}
				string value2 = dateTime.ToString(_dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", Culture);
				writer.WriteValue(value2);
				return;
			}
			throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset, got {0}.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.ReflectionUtils.GetObjectType(value)));
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			bool flag = Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(objectType);
			if (reader.TokenType == JsonToken.Null)
			{
				if (!Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType == JsonToken.Date)
			{
				return reader.Value;
			}
			if (reader.TokenType != JsonToken.String)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected String, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			string text = reader.Value.ToString();
			if (string.IsNullOrEmpty(text) && flag)
			{
				return null;
			}
			if (!string.IsNullOrEmpty(_dateTimeFormat))
			{
				return DateTime.ParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles);
			}
			return DateTime.Parse(text, Culture, _dateTimeStyles);
		}
	}
	public class JavaScriptDateTimeConverter : DateTimeConverterBase
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value is DateTime dateTime)
			{
				DateTime dateTime2 = dateTime.ToUniversalTime();
				long value2 = Newtonsoft.Json.Utilities.DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime2);
				writer.WriteStartConstructor("Date");
				writer.WriteValue(value2);
				writer.WriteEndConstructor();
				return;
			}
			throw new JsonSerializationException("Expected date object value.");
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!Newtonsoft.Json.Utilities.ReflectionUtils.IsNullable(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType != JsonToken.StartConstructor || !string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
			{
				throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing date. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
			}
			reader.Read();
			if (reader.TokenType != JsonToken.Integer)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected Integer, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			long javaScriptTicks = (long)reader.Value;
			DateTime dateTime = Newtonsoft.Json.Utilities.DateTimeUtils.ConvertJavaScriptTicksToDateTime(javaScriptTicks);
			reader.Read();
			if (reader.TokenType != JsonToken.EndConstructor)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected EndConstructor, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			return dateTime;
		}
	}
	public class KeyValuePairConverter : JsonConverter
	{
		private const string KeyName = "Key";

		private const string ValueName = "Value";

		private static readonly Newtonsoft.Json.Utilities.ThreadSafeStore<Type, ReflectionObject> ReflectionObjectPerType = new Newtonsoft.Json.Utilities.ThreadSafeStore<Type, ReflectionObject>(InitializeReflectionObject, new TypeKeyMaker());

		private static ReflectionObject InitializeReflectionObject(Type t)
		{
			IList<Type> genericArguments = t.GetGenericArguments();
			Type type = genericArguments[0];
			Type type2 = genericArguments[1];
			return ReflectionObject.Create(t, t.GetConstructor(new Type[2] { type, type2 }), "Key", "Value");
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			ReflectionObject reflectionObject = ReflectionObjectPerType.Get(value.GetType());
			Newtonsoft.Json.Serialization.DefaultContractResolver defaultContractResolver = serializer.ContractResolver as Newtonsoft.Json.Serialization.DefaultContractResolver;
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver == null) ? "Key" : defaultContractResolver.GetResolvedPropertyName("Key"));
			serializer.Serialize(writer, reflectionObject.GetValue(value, "Key"), reflectionObject.GetType("Key"));
			writer.WritePropertyName((defaultContractResolver == null) ? "Value" : defaultContractResolver.GetResolvedPropertyName("Value"));
			serializer.Serialize(writer, reflectionObject.GetValue(value, "Value"), reflectionObject.GetType("Value"));
			writer.WriteEndObject();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			bool flag = Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(objectType);
			Type key = ((!flag) ? objectType : Nullable.GetUnderlyingType(objectType));
			ReflectionObject reflectionObject = ReflectionObjectPerType.Get(key);
			if (reader.TokenType == JsonToken.Null)
			{
				if (!flag)
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to KeyValuePair.");
				}
				return null;
			}
			object obj = null;
			object obj2 = null;
			ReadAndAssert(reader);
			while (reader.TokenType == JsonToken.PropertyName)
			{
				string a = reader.Value.ToString();
				if (string.Equals(a, "Key", StringComparison.OrdinalIgnoreCase))
				{
					ReadAndAssert(reader);
					obj = serializer.Deserialize(reader, reflectionObject.GetType("Key"));
				}
				else if (string.Equals(a, "Value", StringComparison.OrdinalIgnoreCase))
				{
					ReadAndAssert(reader);
					obj2 = serializer.Deserialize(reader, reflectionObject.GetType("Value"));
				}
				else
				{
					reader.Skip();
				}
				ReadAndAssert(reader);
			}
			return reflectionObject.Creator(obj, obj2);
		}

		public override bool CanConvert(Type objectType)
		{
			Type type = ((!Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(objectType)) ? objectType : Nullable.GetUnderlyingType(objectType));
			if (type.IsValueType() && type.IsGenericType())
			{
				return type.GetGenericTypeDefinition() == typeof(KeyValuePair<, >);
			}
			return false;
		}

		private static void ReadAndAssert(JsonReader reader)
		{
			if (!reader.Read())
			{
				throw JsonSerializationException.Create(reader, "Unexpected end when reading KeyValuePair.");
			}
		}
	}
	public class RegexConverter : JsonConverter
	{
		private const string PatternName = "Pattern";

		private const string OptionsName = "Options";

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			Regex regex = (Regex)value;
			WriteJson(writer, regex, serializer);
		}

		private bool HasFlag(RegexOptions options, RegexOptions flag)
		{
			return (options & flag) == flag;
		}

		private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer)
		{
			Newtonsoft.Json.Serialization.DefaultContractResolver defaultContractResolver = serializer.ContractResolver as Newtonsoft.Json.Serialization.DefaultContractResolver;
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver == null) ? "Pattern" : defaultContractResolver.GetResolvedPropertyName("Pattern"));
			writer.WriteValue(regex.ToString());
			writer.WritePropertyName((defaultContractResolver == null) ? "Options" : defaultContractResolver.GetResolvedPropertyName("Options"));
			serializer.Serialize(writer, regex.Options);
			writer.WriteEndObject();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.StartObject)
			{
				return ReadRegexObject(reader, serializer);
			}
			if (reader.TokenType == JsonToken.String)
			{
				return ReadRegexString(reader);
			}
			throw JsonSerializationException.Create(reader, "Unexpected token when reading Regex.");
		}

		private object ReadRegexString(JsonReader reader)
		{
			string text = (string)reader.Value;
			int num = text.LastIndexOf('/');
			string pattern = text.Substring(1, num - 1);
			string text2 = text.Substring(num + 1);
			RegexOptions regexOptions = RegexOptions.None;
			string text3 = text2;
			for (int i = 0; i < text3.Length; i++)
			{
				switch (text3[i])
				{
				case 'i':
					regexOptions |= RegexOptions.IgnoreCase;
					break;
				case 'm':
					regexOptions |= RegexOptions.Multiline;
					break;
				case 's':
					regexOptions |= RegexOptions.Singleline;
					break;
				case 'x':
					regexOptions |= RegexOptions.ExplicitCapture;
					break;
				}
			}
			return new Regex(pattern, regexOptions);
		}

		private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer)
		{
			string text = null;
			RegexOptions? regexOptions = null;
			while (reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string a = reader.Value.ToString();
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
					}
					if (string.Equals(a, "Pattern", StringComparison.OrdinalIgnoreCase))
					{
						text = (string)reader.Value;
					}
					else if (string.Equals(a, "Options", StringComparison.OrdinalIgnoreCase))
					{
						regexOptions = serializer.Deserialize<RegexOptions>(reader);
					}
					else
					{
						reader.Skip();
					}
					break;
				}
				case JsonToken.EndObject:
					if (text == null)
					{
						throw JsonSerializationException.Create(reader, "Error deserializing Regex. No pattern found.");
					}
					return new Regex(text, regexOptions.HasValue ? regexOptions.Value : RegexOptions.None);
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
		}

		public override bool CanConvert(Type objectType)
		{
			return objectType == typeof(Regex);
		}
	}
	public class StringEnumConverter : JsonConverter
	{
		public bool CamelCaseText { get; set; }

		public bool AllowIntegerValues { get; set; }

		public StringEnumConverter()
		{
			AllowIntegerValues = true;
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Enum @enum = (Enum)value;
			string text = @enum.ToString("G");
			if (char.IsNumber(text[0]) || text[0] == '-')
			{
				writer.WriteValue(value);
				return;
			}
			Type type = @enum.GetType();
			string value2 = Newtonsoft.Json.Utilities.EnumUtils.ToEnumName(type, text, CamelCaseText);
			writer.WriteValue(value2);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			bool flag = Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(objectType);
			Type type = ((!flag) ? objectType : Nullable.GetUnderlyingType(objectType));
			if (reader.TokenType == JsonToken.Null)
			{
				if (!Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			try
			{
				if (reader.TokenType == JsonToken.String)
				{
					string enumText = reader.Value.ToString();
					return Newtonsoft.Json.Utilities.EnumUtils.ParseEnumName(enumText, flag, type);
				}
				if (reader.TokenType == JsonToken.Integer)
				{
					if (!AllowIntegerValues)
					{
						throw JsonSerializationException.Create(reader, "Integer value {0} is not allowed.".FormatWith(CultureInfo.InvariantCulture, reader.Value));
					}
					return Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(reader.Value, CultureInfo.InvariantCulture, type);
				}
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.FormatValueForPrint(reader.Value), objectType), ex);
			}
			throw JsonSerializationException.Create(reader, "Unexpected token {0} when parsing enum.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}

		public override bool CanConvert(Type objectType)
		{
			Type type = ((!Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(objectType)) ? objectType : Nullable.GetUnderlyingType(objectType));
			return type.IsEnum();
		}
	}
	public class VersionConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			if (value is Version)
			{
				writer.WriteValue(value.ToString());
				return;
			}
			throw new JsonSerializationException("Expected Version object value");
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			if (reader.TokenType == JsonToken.String)
			{
				try
				{
					return new Version((string)reader.Value);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error parsing version string: {0}".FormatWith(CultureInfo.InvariantCulture, reader.Value), ex);
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing version. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
		}

		public override bool CanConvert(Type objectType)
		{
			return objectType == typeof(Version);
		}
	}
}
namespace Newtonsoft.Json
{
	public enum DateFormatHandling
	{
		IsoDateFormat,
		MicrosoftDateFormat
	}
	public enum DateParseHandling
	{
		None,
		DateTime
	}
	public enum DateTimeZoneHandling
	{
		Local,
		Utc,
		Unspecified,
		RoundtripKind
	}
	[Flags]
	public enum DefaultValueHandling
	{
		Include = 0,
		Ignore = 1,
		Populate = 2,
		IgnoreAndPopulate = 3
	}
	public enum FloatFormatHandling
	{
		String,
		Symbol,
		DefaultValue
	}
	public enum FloatParseHandling
	{
		Double,
		Decimal
	}
	public enum Formatting
	{
		None,
		Indented
	}
	public interface IJsonLineInfo
	{
		int LineNumber { get; }

		int LinePosition { get; }

		bool HasLineInfo();
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonArrayAttribute : JsonContainerAttribute
	{
		private bool _allowNullItems;

		public bool AllowNullItems
		{
			get
			{
				return _allowNullItems;
			}
			set
			{
				_allowNullItems = value;
			}
		}

		public JsonArrayAttribute()
		{
		}

		public JsonArrayAttribute(bool allowNullItems)
		{
			_allowNullItems = allowNullItems;
		}

		public JsonArrayAttribute(string id)
			: base(id)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
	public sealed class JsonConstructorAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	public abstract class JsonContainerAttribute : Attribute
	{
		internal bool? _isReference;

		internal bool? _itemIsReference;

		internal ReferenceLoopHandling? _itemReferenceLoopHandling;

		internal TypeNameHandling? _itemTypeNameHandling;

		public string Id { get; set; }

		public string Title { get; set; }

		public string Description { get; set; }

		public Type ItemConverterType { get; set; }

		public object[] ItemConverterParameters { get; set; }

		public bool IsReference
		{
			get
			{
				bool? isReference = _isReference;
				return isReference.HasValue && isReference.Value;
			}
			set
			{
				_isReference = value;
			}
		}

		public bool ItemIsReference
		{
			get
			{
				bool? itemIsReference = _itemIsReference;
				return itemIsReference.HasValue && itemIsReference.Value;
			}
			set
			{
				_itemIsReference = value;
			}
		}

		public ReferenceLoopHandling ItemReferenceLoopHandling
		{
			get
			{
				ReferenceLoopHandling? itemReferenceLoopHandling = _itemReferenceLoopHandling;
				return itemReferenceLoopHandling.HasValue ? itemReferenceLoopHandling.Value : ReferenceLoopHandling.Error;
			}
			set
			{
				_itemReferenceLoopHandling = value;
			}
		}

		public TypeNameHandling ItemTypeNameHandling
		{
			get
			{
				TypeNameHandling? itemTypeNameHandling = _itemTypeNameHandling;
				return itemTypeNameHandling.HasValue ? itemTypeNameHandling.Value : TypeNameHandling.None;
			}
			set
			{
				_itemTypeNameHandling = value;
			}
		}

		protected JsonContainerAttribute()
		{
		}

		protected JsonContainerAttribute(string id)
		{
			Id = id;
		}
	}
	public static class JsonConvert
	{
		public static readonly string True = "true";

		public static readonly string False = "false";

		public static readonly string Null = "null";

		public static readonly string Undefined = "undefined";

		public static readonly string PositiveInfinity = "Infinity";

		public static readonly string NegativeInfinity = "-Infinity";

		public static readonly string NaN = "NaN";

		public static Func<JsonSerializerSettings> DefaultSettings { get; set; }

		public static string ToString(DateTime value)
		{
			return ToString(value, DateFormatHandling.IsoDateFormat, DateTimeZoneHandling.RoundtripKind);
		}

		public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling)
		{
			DateTime value2 = Newtonsoft.Json.Utilities.DateTimeUtils.EnsureDateTime(value, timeZoneHandling);
			using StringWriter stringWriter = Newtonsoft.Json.Utilities.StringUtils.CreateStringWriter(64);
			stringWriter.Write('"');
			Newtonsoft.Json.Utilities.DateTimeUtils.WriteDateTimeString(stringWriter, value2, format, null, CultureInfo.InvariantCulture);
			stringWriter.Write('"');
			return stringWriter.ToString();
		}

		public static string ToString(bool value)
		{
			return (!value) ? False : True;
		}

		public static string ToString(char value)
		{
			return ToString(char.ToString(value));
		}

		public static string ToString(Enum value)
		{
			return value.ToString("D");
		}

		public static string ToString(int value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(short value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(ushort value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(uint value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(long value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(ulong value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(float value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
		}

		private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			if (floatFormatHandling == FloatFormatHandling.Symbol || (!double.IsInfinity(value) && !double.IsNaN(value)))
			{
				return text;
			}
			if (floatFormatHandling == FloatFormatHandling.DefaultValue)
			{
				return nullable ? Null : "0.0";
			}
			return quoteChar + text + quoteChar;
		}

		public static string ToString(double value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
		}

		private static string EnsureDecimalPlace(double value, string text)
		{
			if (double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		private static string EnsureDecimalPlace(string text)
		{
			if (text.IndexOf('.') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		public static string ToString(byte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(sbyte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(decimal value)
		{
			return EnsureDecimalPlace(value.ToString(null, CultureInfo.InvariantCulture));
		}

		public static string ToString(Guid value)
		{
			return ToString(value, '"');
		}

		internal static string ToString(Guid value, char quoteChar)
		{
			string text = value.ToString("D", CultureInfo.InvariantCulture);
			string text2 = quoteChar.ToString(CultureInfo.InvariantCulture);
			return text2 + text + text2;
		}

		public static string ToString(TimeSpan value)
		{
			return ToString(value, '"');
		}

		internal static string ToString(TimeSpan value, char quoteChar)
		{
			return ToString(value.ToString(), quoteChar);
		}

		public static string ToString(Uri value)
		{
			if (value == null)
			{
				return Null;
			}
			return ToString(value, '"');
		}

		internal static string ToString(Uri value, char quoteChar)
		{
			return ToString(value.OriginalString, quoteChar);
		}

		public static string ToString(string value)
		{
			return ToString(value, '"');
		}

		public static string ToString(string value, char delimiter)
		{
			return ToString(value, delimiter, StringEscapeHandling.Default);
		}

		public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling)
		{
			if (delimiter != '"' && delimiter != '\'')
			{
				throw new ArgumentException("Delimiter must be a single or double quote.", "delimiter");
			}
			return Newtonsoft.Json.Utilities.JavaScriptUtils.ToEscapedJavaScriptString(value, delimiter, appendDelimiters: true, stringEscapeHandling);
		}

		public static string ToString(object value)
		{
			if (value == null)
			{
				return Null;
			}
			return Newtonsoft.Json.Utilities.ConvertUtils.GetTypeCode(value.GetType()) switch
			{
				PrimitiveTypeCode.String => ToString((string)value), 
				PrimitiveTypeCode.Char => ToString((char)value), 
				PrimitiveTypeCode.Boolean => ToString((bool)value), 
				PrimitiveTypeCode.SByte => ToString((sbyte)value), 
				PrimitiveTypeCode.Int16 => ToString((short)value), 
				PrimitiveTypeCode.UInt16 => ToString((ushort)value), 
				PrimitiveTypeCode.Int32 => ToString((int)value), 
				PrimitiveTypeCode.Byte => ToString((byte)value), 
				PrimitiveTypeCode.UInt32 => ToString((uint)value), 
				PrimitiveTypeCode.Int64 => ToString((long)value), 
				PrimitiveTypeCode.UInt64 => ToString((ulong)value), 
				PrimitiveTypeCode.Single => ToString((float)value), 
				PrimitiveTypeCode.Double => ToString((double)value), 
				PrimitiveTypeCode.DateTime => ToString((DateTime)value), 
				PrimitiveTypeCode.Decimal => ToString((decimal)value), 
				PrimitiveTypeCode.Guid => ToString((Guid)value), 
				PrimitiveTypeCode.Uri => ToString((Uri)value), 
				PrimitiveTypeCode.TimeSpan => ToString((TimeSpan)value), 
				_ => throw new ArgumentException("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType())), 
			};
		}

		public static string SerializeObject(object value)
		{
			return SerializeObject(value, (Type)null, (JsonSerializerSettings)null);
		}

		public static string SerializeObject(object value, Formatting formatting)
		{
			return SerializeObject(value, formatting, (JsonSerializerSettings)null);
		}

		public static string SerializeObject(object value, params JsonConverter[] converters)
		{
			object obj;
			if (converters != null && converters.Length > 0)
			{
				JsonSerializerSettings jsonSerializerSettings = new JsonSerializerSettings();
				jsonSerializerSettings.Converters = converters;
				obj = jsonSerializerSettings;
			}
			else
			{
				obj = null;
			}
			JsonSerializerSettings settings = (JsonSerializerSettings)obj;
			return SerializeObject(value, null, settings);
		}

		public static string SerializeObject(object value, Formatting formatting, params JsonConverter[] converters)
		{
			object obj;
			if (converters != null && converters.Length > 0)
			{
				JsonSerializerSettings jsonSerializerSettings = new JsonSerializerSettings();
				jsonSerializerSettings.Converters = converters;
				obj = jsonSerializerSettings;
			}
			else
			{
				obj = null;
			}
			JsonSerializerSettings settings = (JsonSerializerSettings)obj;
			return SerializeObject(value, null, formatting, settings);
		}

		public static string SerializeObject(object value, JsonSerializerSettings settings)
		{
			return SerializeObject(value, null, settings);
		}

		public static string SerializeObject(object value, Type type, JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			return SerializeObjectInternal(value, type, jsonSerializer);
		}

		public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings)
		{
			return SerializeObject(value, null, formatting, settings);
		}

		public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			jsonSerializer.Formatting = formatting;
			return SerializeObjectInternal(value, type, jsonSerializer);
		}

		private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer)
		{
			StringBuilder sb = new StringBuilder(256);
			StringWriter stringWriter = new StringWriter(sb, CultureInfo.InvariantCulture);
			using (JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter))
			{
				jsonTextWriter.Formatting = jsonSerializer.Formatting;
				jsonSerializer.Serialize(jsonTextWriter, value, type);
			}
			return stringWriter.ToString();
		}

		public static object DeserializeObject(string value)
		{
			return DeserializeObject(value, (Type)null, (JsonSerializerSettings)null);
		}

		public static object DeserializeObject(string value, JsonSerializerSettings settings)
		{
			return DeserializeObject(value, null, settings);
		}

		public static object DeserializeObject(string value, Type type)
		{
			return DeserializeObject(value, type, (JsonSerializerSettings)null);
		}

		public static T DeserializeObject<T>(string value)
		{
			return JsonConvert.DeserializeObject<T>(value, (JsonSerializerSettings)null);
		}

		public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject)
		{
			return DeserializeObject<T>(value);
		}

		public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject, JsonSerializerSettings settings)
		{
			return DeserializeObject<T>(value, settings);
		}

		public static T DeserializeObject<T>(string value, params JsonConverter[] converters)
		{
			return (T)DeserializeObject(value, typeof(T), converters);
		}

		public static T DeserializeObject<T>(string value, JsonSerializerSettings settings)
		{
			return (T)DeserializeObject(value, typeof(T), settings);
		}

		public static object DeserializeObject(string value, Type type, params JsonConverter[] converters)
		{
			object obj;
			if (converters != null && converters.Length > 0)
			{
				JsonSerializerSettings jsonSerializerSettings = new JsonSerializerSettings();
				jsonSerializerSettings.Converters = converters;
				obj = jsonSerializerSettings;
			}
			else
			{
				obj = null;
			}
			JsonSerializerSettings settings = (JsonSerializerSettings)obj;
			return DeserializeObject(value, type, settings);
		}

		public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			if (!jsonSerializer.IsCheckAdditionalContentSet())
			{
				jsonSerializer.CheckAdditionalContent = true;
			}
			using JsonTextReader reader = new JsonTextReader(new StringReader(value));
			return jsonSerializer.Deserialize(reader, type);
		}

		public static void PopulateObject(string value, object target)
		{
			PopulateObject(value, target, null);
		}

		public static void PopulateObject(string value, object target, JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			using JsonReader jsonReader = new JsonTextReader(new StringReader(value));
			jsonSerializer.Populate(jsonReader, target);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
			}
		}
	}
	public abstract class JsonConverter
	{
		public virtual bool CanRead => true;

		public virtual bool CanWrite => true;

		public abstract void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);

		public abstract object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);

		public abstract bool CanConvert(Type objectType);
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter, AllowMultiple = false)]
	public sealed class JsonConverterAttribute : Attribute
	{
		private readonly Type _converterType;

		public Type ConverterType => _converterType;

		public object[] ConverterParameters { get; private set; }

		public JsonConverterAttribute(Type converterType)
		{
			if (converterType == null)
			{
				throw new ArgumentNullException("converterType");
			}
			_converterType = converterType;
		}

		public JsonConverterAttribute(Type converterType, params object[] converterParameters)
			: this(converterType)
		{
			ConverterParameters = converterParameters;
		}
	}
	public class JsonConverterCollection : Collection<JsonConverter>
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonDictionaryAttribute : JsonContainerAttribute
	{
		public JsonDictionaryAttribute()
		{
		}

		public JsonDictionaryAttribute(string id)
			: base(id)
		{
		}
	}
	[Serializable]
	public class JsonException : Exception
	{
		public JsonException()
		{
		}

		public JsonException(string message)
			: base(message)
		{
		}

		public JsonException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			return new JsonException(message);
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public class JsonExtensionDataAttribute : Attribute
	{
		public bool WriteData { get; set; }

		public bool ReadData { get; set; }

		public JsonExtensionDataAttribute()
		{
			WriteData = true;
			ReadData = true;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonIgnoreAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonObjectAttribute : JsonContainerAttribute
	{
		private MemberSerialization _memberSerialization;

		internal Required? _itemRequired;

		public MemberSerialization MemberSerialization
		{
			get
			{
				return _memberSerialization;
			}
			set
			{
				_memberSerialization = value;
			}
		}

		public Required ItemRequired
		{
			get
			{
				Required? itemRequired = _itemRequired;
				return itemRequired.HasValue ? itemRequired.Value : Required.Default;
			}
			set
			{
				_itemRequired = value;
			}
		}

		public JsonObjectAttribute()
		{
		}

		public JsonObjectAttribute(MemberSerialization memberSerialization)
		{
			MemberSerialization = memberSerialization;
		}

		public JsonObjectAttribute(string id)
			: base(id)
		{
		}
	}
	internal enum JsonContainerType
	{
		None,
		Object,
		Array,
		Constructor
	}
	internal struct JsonPosition
	{
		private static readonly char[] SpecialCharacters = new char[6] { '.', ' ', '[', ']', '(', ')' };

		internal JsonContainerType Type;

		internal int Position;

		internal string PropertyName;

		internal bool HasIndex;

		public JsonPosition(JsonContainerType type)
		{
			Type = type;
			HasIndex = TypeHasIndex(type);
			Position = -1;
			PropertyName = null;
		}

		internal void WriteTo(StringBuilder sb)
		{
			switch (Type)
			{
			case JsonContainerType.Object:
			{
				if (sb.Length > 0)
				{
					sb.Append('.');
				}
				string propertyName = PropertyName;
				if (propertyName.IndexOfAny(SpecialCharacters) != -1)
				{
					sb.Append("['");
					sb.Append(propertyName);
					sb.Append("']");
				}
				else
				{
					sb.Append(propertyName);
				}
				break;
			}
			case JsonContainerType.Array:
			case JsonContainerType.Constructor:
				sb.Append('[');
				sb.Append(Position);
				sb.Append(']');
				break;
			}
		}

		internal static bool TypeHasIndex(JsonContainerType type)
		{
			return type == JsonContainerType.Array || type == JsonContainerType.Constructor;
		}

		internal static string BuildPath(IEnumerable<JsonPosition> positions)
		{
			StringBuilder stringBuilder = new StringBuilder();
			foreach (JsonPosition position in positions)
			{
				position.WriteTo(stringBuilder);
			}
			return stringBuilder.ToString();
		}

		internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message)
		{
			if (!message.EndsWith(Environment.NewLine, StringComparison.Ordinal))
			{
				message = message.Trim();
				if (!message.EndsWith('.'))
				{
					message += ".";
				}
				message += " ";
			}
			message += "Path '{0}'".FormatWith(CultureInfo.InvariantCulture, path);
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				message += ", line {0}, position {1}".FormatWith(CultureInfo.InvariantCulture, lineInfo.LineNumber, lineInfo.LinePosition);
			}
			message += ".";
			return message;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
	public sealed class JsonPropertyAttribute : Attribute
	{
		internal NullValueHandling? _nullValueHandling;

		internal DefaultValueHandling? _defaultValueHandling;

		internal ReferenceLoopHandling? _referenceLoopHandling;

		internal ObjectCreationHandling? _objectCreationHandling;

		internal TypeNameHandling? _typeNameHandling;

		internal bool? _isReference;

		internal int? _order;

		internal Required? _required;

		internal bool? _itemIsReference;

		internal ReferenceLoopHandling? _itemReferenceLoopHandling;

		internal TypeNameHandling? _itemTypeNameHandling;

		public Type ItemConverterType { get; set; }

		public object[] ItemConverterParameters { get; set; }

		public NullValueHandling NullValueHandling
		{
			get
			{
				NullValueHandling? nullValueHandling = _nullValueHandling;
				return nullValueHandling.HasValue ? nullValueHandling.Value : NullValueHandling.Include;
			}
			set
			{
				_nullValueHandling = value;
			}
		}

		public DefaultValueHandling DefaultValueHandling
		{
			get
			{
				DefaultValueHandling? defaultValueHandling = _defaultValueHandling;
				return defaultValueHandling.HasValue ? defaultValueHandling.Value : DefaultValueHandling.Include;
			}
			set
			{
				_defaultValueHandling = value;
			}
		}

		public ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				ReferenceLoopHandling? referenceLoopHandling = _referenceLoopHandling;
				return referenceLoopHandling.HasValue ? referenceLoopHandling.Value : ReferenceLoopHandling.Error;
			}
			set
			{
				_referenceLoopHandling = value;
			}
		}

		public ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				ObjectCreationHandling? objectCreationHandling = _objectCreationHandling;
				return objectCreationHandling.HasValue ? objectCreationHandling.Value : ObjectCreationHandling.Auto;
			}
			set
			{
				_objectCreationHandling = value;
			}
		}

		public TypeNameHandling TypeNameHandling
		{
			get
			{
				TypeNameHandling? typeNameHandling = _typeNameHandling;
				return typeNameHandling.HasValue ? typeNameHandling.Value : TypeNameHandling.None;
			}
			set
			{
				_typeNameHandling = value;
			}
		}

		public bool IsReference
		{
			get
			{
				bool? isReference = _isReference;
				return isReference.HasValue && isReference.Value;
			}
			set
			{
				_isReference = value;
			}
		}

		public int Order
		{
			get
			{
				int? order = _order;
				return order.HasValue ? order.Value : 0;
			}
			set
			{
				_order = value;
			}
		}

		public Required Required
		{
			get
			{
				Required? required = _required;
				return required.HasValue ? required.Value : Required.Default;
			}
			set
			{
				_required = value;
			}
		}

		public string PropertyName { get; set; }

		public ReferenceLoopHandling ItemReferenceLoopHandling
		{
			get
			{
				ReferenceLoopHandling? itemReferenceLoopHandling = _itemReferenceLoopHandling;
				return itemReferenceLoopHandling.HasValue ? itemReferenceLoopHandling.Value : ReferenceLoopHandling.Error;
			}
			set
			{
				_itemReferenceLoopHandling = value;
			}
		}

		public TypeNameHandling ItemTypeNameHandling
		{
			get
			{
				TypeNameHandling? itemTypeNameHandling = _itemTypeNameHandling;
				return itemTypeNameHandling.HasValue ? itemTypeNameHandling.Value : TypeNameHandling.None;
			}
			set
			{
				_itemTypeNameHandling = value;
			}
		}

		public bool ItemIsReference
		{
			get
			{
				bool? itemIsReference = _itemIsReference;
				return itemIsReference.HasValue && itemIsReference.Value;
			}
			set
			{
				_itemIsReference = value;
			}
		}

		public JsonPropertyAttribute()
		{
		}

		public JsonPropertyAttribute(string propertyName)
		{
			PropertyName = propertyName;
		}
	}
	public abstract class JsonReader : IDisposable
	{
		protected internal enum State
		{
			Start,
			Complete,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			Closed,
			PostValue,
			ConstructorStart,
			Constructor,
			Error,
			Finished
		}

		private JsonToken _tokenType;

		private object _value;

		internal char _quoteChar;

		internal State _currentState;

		internal ReadType _readType;

		private JsonPosition _currentPosition;

		private CultureInfo _culture;

		private DateTimeZoneHandling _dateTimeZoneHandling;

		private int? _maxDepth;

		private bool _hasExceededMaxDepth;

		internal DateParseHandling _dateParseHandling;

		internal FloatParseHandling _floatParseHandling;

		private string _dateFormatString;

		private readonly List<JsonPosition> _stack;

		protected State CurrentState => _currentState;

		public bool CloseInput { get; set; }

		public bool SupportMultipleContent { get; set; }

		public virtual char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			protected internal set
			{
				_quoteChar = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public DateParseHandling DateParseHandling
		{
			get
			{
				return _dateParseHandling;
			}
			set
			{
				_dateParseHandling = value;
			}
		}

		public FloatParseHandling FloatParseHandling
		{
			get
			{
				return _floatParseHandling;
			}
			set
			{
				_floatParseHandling = value;
			}
		}

		public string DateFormatString
		{
			get
			{
				return _dateFormatString;
			}
			set
			{
				_dateFormatString = value;
			}
		}

		public int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value.HasValue && value.GetValueOrDefault() <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
			}
		}

		public virtual JsonToken TokenType => _tokenType;

		public virtual object Value => _value;

		public virtual Type ValueType => (_value == null) ? null : _value.GetType();

		public virtual int Depth
		{
			get
			{
				int count = _stack.Count;
				if (JsonTokenUtils.IsStartToken(TokenType) || _currentPosition.Type == JsonContainerType.None)
				{
					return count;
				}
				return count + 1;
			}
		}

		public virtual string Path
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None)
				{
					return string.Empty;
				}
				IEnumerable<JsonPosition> positions = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Concat(_stack, new JsonPosition[1] { _currentPosition }) : _stack);
				return JsonPosition.BuildPath(positions);
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.InvariantCulture;
			}
			set
			{
				_culture = value;
			}
		}

		protected JsonReader()
		{
			_currentState = State.Start;
			_stack = new List<JsonPosition>(4);
			_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
			_dateParseHandling = DateParseHandling.DateTime;
			_floatParseHandling = FloatParseHandling.Double;
			CloseInput = true;
		}

		internal JsonPosition GetPosition(int depth)
		{
			if (depth < _stack.Count)
			{
				return _stack[depth];
			}
			return _currentPosition;
		}

		private void Push(JsonContainerType value)
		{
			UpdateScopeWithFinishedValue();
			if (_currentPosition.Type == JsonContainerType.None)
			{
				_currentPosition = new JsonPosition(value);
				return;
			}
			_stack.Add(_currentPosition);
			_currentPosition = new JsonPosition(value);
			int? maxDepth = _maxDepth;
			if (maxDepth.HasValue)
			{
				int? maxDepth2 = _maxDepth;
				if (maxDepth2.HasValue && Depth + 1 > maxDepth2.GetValueOrDefault() && !_hasExceededMaxDepth)
				{
					_hasExceededMaxDepth = true;
					throw JsonReaderException.Create(this, "The reader's MaxDepth of {0} has been exceeded.".FormatWith(CultureInfo.InvariantCulture, _maxDepth));
				}
			}
		}

		private JsonContainerType Pop()
		{
			JsonPosition currentPosition;
			if (_stack.Count > 0)
			{
				currentPosition = _currentPosition;
				_currentPosition = _stack[_stack.Count - 1];
				_stack.RemoveAt(_stack.Count - 1);
			}
			else
			{
				currentPosition = _currentPosition;
				_currentPosition = default(JsonPosition);
			}
			int? maxDepth = _maxDepth;
			if (maxDepth.HasValue)
			{
				int? maxDepth2 = _maxDepth;
				if (maxDepth2.HasValue && Depth <= maxDepth2.GetValueOrDefault())
				{
					_hasExceededMaxDepth = false;
				}
			}
			return currentPosition.Type;
		}

		private JsonContainerType Peek()
		{
			return _currentPosition.Type;
		}

		public abstract bool Read();

		public abstract int? ReadAsInt32();

		public abstract string ReadAsString();

		public abstract byte[] ReadAsBytes();

		public abstract decimal? ReadAsDecimal();

		public abstract DateTime? ReadAsDateTime();

		internal virtual bool ReadInternal()
		{
			throw new NotImplementedException();
		}

		internal byte[] ReadAsBytesInternal()
		{
			_readType = ReadType.ReadAsBytes;
			JsonToken tokenType;
			do
			{
				if (!ReadInternal())
				{
					SetToken(JsonToken.None);
					return null;
				}
				tokenType = TokenType;
			}
			while (tokenType == JsonToken.Comment);
			if (IsWrappedInTypeObject())
			{
				byte[] array = ReadAsBytes();
				ReadInternal();
				SetToken(JsonToken.Bytes, array, updateIndex: false);
				return array;
			}
			switch (tokenType)
			{
			case JsonToken.String:
			{
				string text = (string)Value;
				Guid g;
				byte[] array3 = ((text.Length == 0) ? new byte[0] : ((!Newtonsoft.Json.Utilities.ConvertUtils.TryConvertGuid(text, out g)) ? Convert.FromBase64String(text) : g.ToByteArray()));
				SetToken(JsonToken.Bytes, array3, updateIndex: false);
				return array3;
			}
			case JsonToken.Null:
				return null;
			case JsonToken.Bytes:
				if (ValueType == typeof(Guid))
				{
					byte[] array4 = ((Guid)Value).ToByteArray();
					SetToken(JsonToken.Bytes, array4, updateIndex: false);
					return array4;
				}
				return (byte[])Value;
			case JsonToken.StartArray:
			{
				List<byte> list = new List<byte>();
				while (ReadInternal())
				{
					tokenType = TokenType;
					switch (tokenType)
					{
					case JsonToken.Integer:
						list.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));
						break;
					case JsonToken.EndArray:
					{
						byte[] array2 = list.ToArray();
						SetToken(JsonToken.Bytes, array2, updateIndex: false);
						return array2;
					}
					default:
						throw JsonReaderException.Create(this, "Unexpected token when reading bytes: {0}.".FormatWith(CultureInfo.InvariantCulture, tokenType));
					case JsonToken.Comment:
						break;
					}
				}
				throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");
			}
			case JsonToken.EndArray:
				return null;
			default:
				throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, tokenType));
			}
		}

		internal decimal? ReadAsDecimalInternal()
		{
			_readType = ReadType.ReadAsDecimal;
			while (ReadInternal())
			{
				JsonToken tokenType = TokenType;
				switch (tokenType)
				{
				case JsonToken.Comment:
					break;
				case JsonToken.Integer:
				case JsonToken.Float:
					if (!(Value is decimal))
					{
						SetToken(JsonToken.Float, Convert.ToDecimal(Value, CultureInfo.InvariantCulture), updateIndex: false);
					}
					return (decimal)Value;
				case JsonToken.Null:
					return null;
				case JsonToken.String:
				{
					string text = (string)Value;
					if (string.IsNullOrEmpty(text))
					{
						SetToken(JsonToken.Null);
						return null;
					}
					if (decimal.TryParse(text, NumberStyles.Number, Culture, out var result))
					{
						SetToken(JsonToken.Float, result, updateIndex: false);
						return result;
					}
					throw JsonReaderException.Create(this, "Could not convert string to decimal: {0}.".FormatWith(CultureInfo.InvariantCulture, Value));
				}
				case JsonToken.EndArray:
					return null;
				default:
					throw JsonReaderException.Create(this, "Error reading decimal. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, tokenType));
				}
			}
			SetToken(JsonToken.None);
			return null;
		}

		internal int? ReadAsInt32Internal()
		{
			_readType = ReadType.ReadAsInt32;
			while (ReadInternal())
			{
				switch (TokenType)
				{
				case JsonToken.Comment:
					break;
				case JsonToken.Integer:
				case JsonToken.Float:
					if (!(Value is int))
					{
						SetToken(JsonToken.Integer, Convert.ToInt32(Value, CultureInfo.InvariantCulture), updateIndex: false);
					}
					return (int)Value;
				case JsonToken.Null:
					return null;
				case JsonToken.String:
				{
					string text = (string)Value;
					if (string.IsNullOrEmpty(text))
					{
						SetToken(JsonToken.Null);
						return null;
					}
					if (int.TryParse(text, NumberStyles.Integer, Culture, out var result))
					{
						SetToken(JsonToken.Integer, result, updateIndex: false);
						return result;
					}
					throw JsonReaderException.Create(this, "Could not convert string to integer: {0}.".FormatWith(CultureInfo.InvariantCulture, Value));
				}
				case JsonToken.EndArray:
					return null;
				default:
					throw JsonReaderException.Create(this, "Error reading integer. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
				}
			}
			SetToken(JsonToken.None);
			return null;
		}

		internal string ReadAsStringInternal()
		{
			_readType = ReadType.ReadAsString;
			while (ReadInternal())
			{
				JsonToken tokenType = TokenType;
				switch (tokenType)
				{
				case JsonToken.Comment:
					continue;
				case JsonToken.String:
					return (string)Value;
				case JsonToken.Null:
					return null;
				}
				if (JsonTokenUtils.IsPrimitiveToken(tokenType) && Value != null)
				{
					string text = ((!(Value is IFormattable)) ? Value.ToString() : ((IFormattable)Value).ToString(null, Culture));
					SetToken(JsonToken.String, text, updateIndex: false);
					return text;
				}
				if (tokenType == JsonToken.EndArray)
				{
					return null;
				}
				throw JsonReaderException.Create(this, "Error reading string. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, tokenType));
			}
			SetToken(JsonToken.None);
			return null;
		}

		internal DateTime? ReadAsDateTimeInternal()
		{
			_readType = ReadType.ReadAsDateTime;
			do
			{
				if (!ReadInternal())
				{
					SetToken(JsonToken.None);
					return null;
				}
			}
			while (TokenType == JsonToken.Comment);
			if (TokenType == JsonToken.Date)
			{
				return (DateTime)Value;
			}
			if (TokenType == JsonToken.Null)
			{
				return null;
			}
			if (TokenType == JsonToken.String)
			{
				string text = (string)Value;
				if (string.IsNullOrEmpty(text))
				{
					SetToken(JsonToken.Null);
					return null;
				}
				DateTime value;
				if (Newtonsoft.Json.Utilities.DateTimeUtils.TryParseDateTime(text, DateParseHandling.DateTime, DateTimeZoneHandling, _dateFormatString, Culture, out var dt))
				{
					value = (DateTime)dt;
					value = Newtonsoft.Json.Utilities.DateTimeUtils.EnsureDateTime(value, DateTimeZoneHandling);
					SetToken(JsonToken.Date, value, updateIndex: false);
					return value;
				}
				if (DateTime.TryParse(text, Culture, DateTimeStyles.RoundtripKind, out value))
				{
					value = Newtonsoft.Json.Utilities.DateTimeUtils.EnsureDateTime(value, DateTimeZoneHandling);
					SetToken(JsonToken.Date, value, updateIndex: false);
					return value;
				}
				throw JsonReaderException.Create(this, "Could not convert string to DateTime: {0}.".FormatWith(CultureInfo.InvariantCulture, Value));
			}
			if (TokenType == JsonToken.EndArray)
			{
				return null;
			}
			throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
		}

		private bool IsWrappedInTypeObject()
		{
			_readType = ReadType.Read;
			if (TokenType == JsonToken.StartObject)
			{
				if (!ReadInternal())
				{
					throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");
				}
				if (Value.ToString() == "$type")
				{
					ReadInternal();
					if (Value != null && Value.ToString().StartsWith("System.Byte[]", StringComparison.Ordinal))
					{
						ReadInternal();
						if (Value.ToString() == "$value")
						{
							return true;
						}
					}
				}
				throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));
			}
			return false;
		}

		public void Skip()
		{
			if (TokenType == JsonToken.PropertyName)
			{
				Read();
			}
			if (JsonTokenUtils.IsStartToken(TokenType))
			{
				int depth = Depth;
				while (Read() && depth < Depth)
				{
				}
			}
		}

		protected void SetToken(JsonToken newToken)
		{
			SetToken(newToken, null, updateIndex: true);
		}

		protected void SetToken(JsonToken newToken, object value)
		{
			SetToken(newToken, value, updateIndex: true);
		}

		internal void SetToken(JsonToken newToken, object value, bool updateIndex)
		{
			_tokenType = newToken;
			_value = value;
			switch (newToken)
			{
			case JsonToken.StartObject:
				_currentState = State.ObjectStart;
				Push(JsonContainerType.Object);
				break;
			case JsonToken.StartArray:
				_currentState = State.ArrayStart;
				Push(JsonContainerType.Array);
				break;
			case JsonToken.StartConstructor:
				_currentState = State.ConstructorStart;
				Push(JsonContainerType.Constructor);
				break;
			case JsonToken.EndObject:
				ValidateEnd(JsonToken.EndObject);
				break;
			case JsonToken.EndArray:
				ValidateEnd(JsonToken.EndArray);
				break;
			case JsonToken.EndConstructor:
				ValidateEnd(JsonToken.EndConstructor);
				break;
			case JsonToken.PropertyName:
				_currentState = State.Property;
				_currentPosition.PropertyName = (string)value;
				break;
			case JsonToken.Raw:
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				SetPostValueState(updateIndex);
				break;
			case JsonToken.Comment:
				break;
			}
		}

		internal void SetPostValueState(bool updateIndex)
		{
			if (Peek() != 0)
			{
				_currentState = State.PostValue;
			}
			else
			{
				SetFinished();
			}
			if (updateIndex)
			{
				UpdateScopeWithFinishedValue();
			}
		}

		private void UpdateScopeWithFinishedValue()
		{
			if (_currentPosition.HasIndex)
			{
				_currentPosition.Position++;
			}
		}

		private void ValidateEnd(JsonToken endToken)
		{
			JsonContainerType jsonContainerType = Pop();
			if (GetTypeForCloseToken(endToken) != jsonContainerType)
			{
				throw JsonReaderException.Create(this, "JsonToken {0} is not valid for closing JsonType {1}.".FormatWith(CultureInfo.InvariantCulture, endToken, jsonContainerType));
			}
			if (Peek() != 0)
			{
				_currentState = State.PostValue;
			}
			else
			{
				SetFinished();
			}
		}

		protected void SetStateBasedOnCurrent()
		{
			JsonContainerType jsonContainerType = Peek();
			switch (jsonContainerType)
			{
			case JsonContainerType.Object:
				_currentState = State.Object;
				break;
			case JsonContainerType.Array:
				_currentState = State.Array;
				break;
			case JsonContainerType.Constructor:
				_currentState = State.Constructor;
				break;
			case JsonContainerType.None:
				SetFinished();
				break;
			default:
				throw JsonReaderException.Create(this, "While setting the reader state back to current object an unexpected JsonType was encountered: {0}".FormatWith(CultureInfo.InvariantCulture, jsonContainerType));
			}
		}

		private void SetFinished()
		{
			if (SupportMultipleContent)
			{
				_currentState = State.Start;
			}
			else
			{
				_currentState = State.Finished;
			}
		}

		private JsonContainerType GetTypeForCloseToken(JsonToken token)
		{
			return token switch
			{
				JsonToken.EndObject => JsonContainerType.Object, 
				JsonToken.EndArray => JsonContainerType.Array, 
				JsonToken.EndConstructor => JsonContainerType.Constructor, 
				_ => throw JsonReaderException.Create(this, "Not a valid close JsonToken: {0}".FormatWith(CultureInfo.InvariantCulture, token)), 
			};
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_currentState != State.Closed && disposing)
			{
				Close();
			}
		}

		public virtual void Close()
		{
			_currentState = State.Closed;
			_tokenType = JsonToken.None;
			_value = null;
		}
	}
	[Serializable]
	public class JsonReaderException : JsonException
	{
		public int LineNumber { get; private set; }

		public int LinePosition { get; private set; }

		public string Path { get; private set; }

		public JsonReaderException()
		{
		}

		public JsonReaderException(string message)
			: base(message)
		{
		}

		public JsonReaderException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition)
			: base(message, innerException)
		{
			Path = path;
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}

		internal static JsonReaderException Create(JsonReader reader, string message)
		{
			return Create(reader, message, null);
		}

		internal static JsonReaderException Create(JsonReader reader, string message, Exception ex)
		{
			return Create(reader as IJsonLineInfo, reader.Path, message, ex);
		}

		internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			int lineNumber;
			int linePosition;
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				lineNumber = lineInfo.LineNumber;
				linePosition = lineInfo.LinePosition;
			}
			else
			{
				lineNumber = 0;
				linePosition = 0;
			}
			return new JsonReaderException(message, ex, path, lineNumber, linePosition);
		}
	}
	[Serializable]
	public class JsonSerializationException : JsonException
	{
		public JsonSerializationException()
		{
		}

		public JsonSerializationException(string message)
			: base(message)
		{
		}

		public JsonSerializationException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonSerializationException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal static JsonSerializationException Create(JsonReader reader, string message)
		{
			return Create(reader, message, null);
		}

		internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex)
		{
			return Create(reader as IJsonLineInfo, reader.Path, message, ex);
		}

		internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			return new JsonSerializationException(message, ex);
		}
	}
	public class JsonSerializer
	{
		internal TypeNameHandling _typeNameHandling;

		internal FormatterAssemblyStyle _typeNameAssemblyFormat;

		internal PreserveReferencesHandling _preserveReferencesHandling;

		internal ReferenceLoopHandling _referenceLoopHandling;

		internal MissingMemberHandling _missingMemberHandling;

		internal ObjectCreationHandling _objectCreationHandling;

		internal NullValueHandling _nullValueHandling;

		internal DefaultValueHandling _defaultValueHandling;

		internal ConstructorHandling _constructorHandling;

		internal MetadataPropertyHandling _metadataPropertyHandling;

		internal JsonConverterCollection _converters;

		internal Newtonsoft.Json.Serialization.IContractResolver _contractResolver;

		internal ITraceWriter _traceWriter;

		internal SerializationBinder _binder;

		internal StreamingContext _context;

		private Newtonsoft.Json.Serialization.IReferenceResolver _referenceResolver;

		private Formatting? _formatting;

		private DateFormatHandling? _dateFormatHandling;

		private DateTimeZoneHandling? _dateTimeZoneHandling;

		private DateParseHandling? _dateParseHandling;

		private FloatFormatHandling? _floatFormatHandling;

		private FloatParseHandling? _floatParseHandling;

		private StringEscapeHandling? _stringEscapeHandling;

		private CultureInfo _culture;

		private int? _maxDepth;

		private bool _maxDepthSet;

		private bool? _checkAdditionalContent;

		private string _dateFormatString;

		private bool _dateFormatStringSet;

		public virtual Newtonsoft.Json.Serialization.IReferenceResolver ReferenceResolver
		{
			get
			{
				return GetReferenceResolver();
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Reference resolver cannot be null.");
				}
				_referenceResolver = value;
			}
		}

		public virtual SerializationBinder Binder
		{
			get
			{
				return _binder;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Serialization binder cannot be null.");
				}
				_binder = value;
			}
		}

		public virtual ITraceWriter TraceWriter
		{
			get
			{
				return _traceWriter;
			}
			set
			{
				_traceWriter = value;
			}
		}

		public virtual TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling;
			}
			set
			{
				if (value < TypeNameHandling.None || value > TypeNameHandling.Auto)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameHandling = value;
			}
		}

		public virtual FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _typeNameAssemblyFormat;
			}
			set
			{
				if (value < FormatterAssemblyStyle.Simple || value > FormatterAssemblyStyle.Full)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameAssemblyFormat = value;
			}
		}

		public virtual PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _preserveReferencesHandling;
			}
			set
			{
				if (value < PreserveReferencesHandling.None || value > PreserveReferencesHandling.All)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_preserveReferencesHandling = value;
			}
		}

		public virtual ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling;
			}
			set
			{
				if (value < ReferenceLoopHandling.Error || value > ReferenceLoopHandling.Serialize)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_referenceLoopHandling = value;
			}
		}

		public virtual MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _missingMemberHandling;
			}
			set
			{
				if (value < MissingMemberHandling.Ignore || value > MissingMemberHandling.Error)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_missingMemberHandling = value;
			}
		}

		public virtual NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling;
			}
			set
			{
				if (value < NullValueHandling.Include || value > NullValueHandling.Ignore)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_nullValueHandling = value;
			}
		}

		public virtual DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling;
			}
			set
			{
				if (value < DefaultValueHandling.Include || value > DefaultValueHandling.IgnoreAndPopulate)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_defaultValueHandling = value;
			}
		}

		public virtual ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling;
			}
			set
			{
				if (value < ObjectCreationHandling.Auto || value > ObjectCreationHandling.Replace)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_objectCreationHandling = value;
			}
		}

		public virtual ConstructorHandling ConstructorHandling
		{
			get
			{
				return _constructorHandling;
			}
			set
			{
				if (value < ConstructorHandling.Default || value > ConstructorHandling.AllowNonPublicDefaultConstructor)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_constructorHandling = value;
			}
		}

		public virtual MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _metadataPropertyHandling;
			}
			set
			{
				if (value < MetadataPropertyHandling.Default || value > MetadataPropertyHandling.Ignore)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_metadataPropertyHandling = value;
			}
		}

		public virtual JsonConverterCollection Converters
		{
			get
			{
				if (_converters == null)
				{
					_converters = new JsonConverterCollection();
				}
				return _converters;
			}
		}

		public virtual Newtonsoft.Json.Serialization.IContractResolver ContractResolver
		{
			get
			{
				return _contractResolver;
			}
			set
			{
				_contractResolver = value ?? Newtonsoft.Json.Serialization.DefaultContractResolver.Instance;
			}
		}

		public virtual StreamingContext Context
		{
			get
			{
				return _context;
			}
			set
			{
				_context = value;
			}
		}

		public virtual Formatting Formatting
		{
			get
			{
				Formatting? formatting = _formatting;
				return formatting.HasValue ? formatting.Value : Formatting.None;
			}
			set
			{
				_formatting = value;
			}
		}

		public virtual DateFormatHandling DateFormatHandling
		{
			get
			{
				DateFormatHandling? dateFormatHandling = _dateFormatHandling;
				return dateFormatHandling.HasValue ? dateFormatHandling.Value : DateFormatHandling.IsoDateFormat;
			}
			set
			{
				_dateFormatHandling = value;
			}
		}

		public virtual DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				DateTimeZoneHandling? dateTimeZoneHandling = _dateTimeZoneHandling;
				return (!dateTimeZoneHandling.HasValue) ? DateTimeZoneHandling.RoundtripKind : dateTimeZoneHandling.Value;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public virtual DateParseHandling DateParseHandling
		{
			get
			{
				DateParseHandling? dateParseHandling = _dateParseHandling;
				return (!dateParseHandling.HasValue) ? DateParseHandling.DateTime : dateParseHandling.Value;
			}
			set
			{
				_dateParseHandling = value;
			}
		}

		public virtual FloatParseHandling FloatParseHandling
		{
			get
			{
				FloatParseHandling? floatParseHandling = _floatParseHandling;
				return floatParseHandling.HasValue ? floatParseHandling.Value : FloatParseHandling.Double;
			}
			set
			{
				_floatParseHandling = value;
			}
		}

		public virtual FloatFormatHandling FloatFormatHandling
		{
			get
			{
				FloatFormatHandling? floatFormatHandling = _floatFormatHandling;
				return floatFormatHandling.HasValue ? floatFormatHandling.Value : FloatFormatHandling.String;
			}
			set
			{
				_floatFormatHandling = value;
			}
		}

		public virtual StringEscapeHandling StringEscapeHandling
		{
			get
			{
				StringEscapeHandling? stringEscapeHandling = _stringEscapeHandling;
				return stringEscapeHandling.HasValue ? stringEscapeHandling.Value : StringEscapeHandling.Default;
			}
			set
			{
				_stringEscapeHandling = value;
			}
		}

		public virtual string DateFormatString
		{
			get
			{
				return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
			}
			set
			{
				_dateFormatString = value;
				_dateFormatStringSet = true;
			}
		}

		public virtual CultureInfo Culture
		{
			get
			{
				return _culture ?? JsonSerializerSettings.DefaultCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public virtual int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value.HasValue && value.GetValueOrDefault() <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
				_maxDepthSet = true;
			}
		}

		public virtual bool CheckAdditionalContent
		{
			get
			{
				bool? checkAdditionalContent = _checkAdditionalContent;
				return checkAdditionalContent.HasValue && checkAdditionalContent.Value;
			}
			set
			{
				_checkAdditionalContent = value;
			}
		}

		public virtual event EventHandler<Newtonsoft.Json.Serialization.ErrorEventArgs> Error;

		public JsonSerializer()
		{
			_referenceLoopHandling = ReferenceLoopHandling.Error;
			_missingMemberHandling = MissingMemberHandling.Ignore;
			_nullValueHandling = NullValueHandling.Include;
			_defaultValueHandling = DefaultValueHandling.Include;
			_objectCreationHandling = ObjectCreationHandling.Auto;
			_preserveReferencesHandling = PreserveReferencesHandling.None;
			_constructorHandling = ConstructorHandling.Default;
			_typeNameHandling = TypeNameHandling.None;
			_metadataPropertyHandling = MetadataPropertyHandling.Default;
			_context = JsonSerializerSettings.DefaultContext;
			_binder = Newtonsoft.Json.Serialization.DefaultSerializationBinder.Instance;
			_culture = JsonSerializerSettings.DefaultCulture;
			_contractResolver = Newtonsoft.Json.Serialization.DefaultContractResolver.Instance;
		}

		internal bool IsCheckAdditionalContentSet()
		{
			bool? checkAdditionalContent = _checkAdditionalContent;
			return checkAdditionalContent.HasValue;
		}

		public static JsonSerializer Create()
		{
			return new JsonSerializer();
		}

		public static JsonSerializer Create(JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = Create();
			if (settings != null)
			{
				ApplySerializerSettings(jsonSerializer, settings);
			}
			return jsonSerializer;
		}

		public static JsonSerializer CreateDefault()
		{
			JsonSerializerSettings settings = JsonConvert.DefaultSettings?.Invoke();
			return Create(settings);
		}

		public static JsonSerializer CreateDefault(JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = CreateDefault();
			if (settings != null)
			{
				ApplySerializerSettings(jsonSerializer, settings);
			}
			return jsonSerializer;
		}

		private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings)
		{
			if (!Newtonsoft.Json.Utilities.CollectionUtils.IsNullOrEmpty(settings.Converters))
			{
				for (int i = 0; i < settings.Converters.Count; i++)
				{
					serializer.Converters.Insert(i, settings.Converters[i]);
				}
			}
			TypeNameHandling? typeNameHandling = settings._typeNameHandling;
			if (typeNameHandling.HasValue)
			{
				serializer.TypeNameHandling = settings.TypeNameHandling;
			}
			MetadataPropertyHandling? metadataPropertyHandling = settings._metadataPropertyHandling;
			if (metadataPropertyHandling.HasValue)
			{
				serializer.MetadataPropertyHandling = settings.MetadataPropertyHandling;
			}
			FormatterAssemblyStyle? typeNameAssemblyFormat = settings._typeNameAssemblyFormat;
			if (typeNameAssemblyFormat.HasValue)
			{
				serializer.TypeNameAssemblyFormat = settings.TypeNameAssemblyFormat;
			}
			PreserveReferencesHandling? preserveReferencesHandling = settings._preserveReferencesHandling;
			if (preserveReferencesHandling.HasValue)
			{
				serializer.PreserveReferencesHandling = settings.PreserveReferencesHandling;
			}
			ReferenceLoopHandling? referenceLoopHandling = settings._referenceLoopHandling;
			if (referenceLoopHandling.HasValue)
			{
				serializer.ReferenceLoopHandling = settings.ReferenceLoopHandling;
			}
			MissingMemberHandling? missingMemberHandling = settings._missingMemberHandling;
			if (missingMemberHandling.HasValue)
			{
				serializer.MissingMemberHandling = settings.MissingMemberHandling;
			}
			ObjectCreationHandling? objectCreationHandling = settings._objectCreationHandling;
			if (objectCreationHandling.HasValue)
			{
				serializer.ObjectCreationHandling = settings.ObjectCreationHandling;
			}
			NullValueHandling? nullValueHandling = settings._nullValueHandling;
			if (nullValueHandling.HasValue)
			{
				serializer.NullValueHandling = settings.NullValueHandling;
			}
			DefaultValueHandling? defaultValueHandling = settings._defaultValueHandling;
			if (defaultValueHandling.HasValue)
			{
				serializer.DefaultValueHandling = settings.DefaultValueHandling;
			}
			ConstructorHandling? constructorHandling = settings._constructorHandling;
			if (constructorHandling.HasValue)
			{
				serializer.ConstructorHandling = settings.ConstructorHandling;
			}
			StreamingContext? context = settings._context;
			if (context.HasValue)
			{
				serializer.Context = settings.Context;
			}
			bool? checkAdditionalContent = settings._checkAdditionalContent;
			if (checkAdditionalContent.HasValue)
			{
				serializer._checkAdditionalContent = settings._checkAdditionalContent;
			}
			if (settings.Error != null)
			{
				serializer.Error += settings.Error;
			}
			if (settings.ContractResolver != null)
			{
				serializer.ContractResolver = settings.ContractResolver;
			}
			if (settings.ReferenceResolver != null)
			{
				serializer.ReferenceResolver = settings.ReferenceResolver;
			}
			if (settings.TraceWriter != null)
			{
				serializer.TraceWriter = settings.TraceWriter;
			}
			if (settings.Binder != null)
			{
				serializer.Binder = settings.Binder;
			}
			Formatting? formatting = settings._formatting;
			if (formatting.HasValue)
			{
				serializer._formatting = settings._formatting;
			}
			DateFormatHandling? dateFormatHandling = settings._dateFormatHandling;
			if (dateFormatHandling.HasValue)
			{
				serializer._dateFormatHandling = settings._dateFormatHandling;
			}
			DateTimeZoneHandling? dateTimeZoneHandling = settings._dateTimeZoneHandling;
			if (dateTimeZoneHandling.HasValue)
			{
				serializer._dateTimeZoneHandling = settings._dateTimeZoneHandling;
			}
			DateParseHandling? dateParseHandling = settings._dateParseHandling;
			if (dateParseHandling.HasValue)
			{
				serializer._dateParseHandling = settings._dateParseHandling;
			}
			if (settings._dateFormatStringSet)
			{
				serializer._dateFormatString = settings._dateFormatString;
				serializer._dateFormatStringSet = settings._dateFormatStringSet;
			}
			FloatFormatHandling? floatFormatHandling = settings._floatFormatHandling;
			if (floatFormatHandling.HasValue)
			{
				serializer._floatFormatHandling = settings._floatFormatHandling;
			}
			FloatParseHandling? floatParseHandling = settings._floatParseHandling;
			if (floatParseHandling.HasValue)
			{
				serializer._floatParseHandling = settings._floatParseHandling;
			}
			StringEscapeHandling? stringEscapeHandling = settings._stringEscapeHandling;
			if (stringEscapeHandling.HasValue)
			{
				serializer._stringEscapeHandling = settings._stringEscapeHandling;
			}
			if (settings._culture != null)
			{
				serializer._culture = settings._culture;
			}
			if (settings._maxDepthSet)
			{
				serializer._maxDepth = settings._maxDepth;
				serializer._maxDepthSet = settings._maxDepthSet;
			}
		}

		public void Populate(TextReader reader, object target)
		{
			Populate(new JsonTextReader(reader), target);
		}

		public void Populate(JsonReader reader, object target)
		{
			PopulateInternal(reader, target);
		}

		internal virtual void PopulateInternal(JsonReader reader, object target)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(target, "target");
			SetupReader(reader, out var previousCulture, out var previousDateTimeZoneHandling, out var previousDateParseHandling, out var previousFloatParseHandling, out var previousMaxDepth, out var previousDateFormatString);
			TraceJsonReader traceJsonReader = ((TraceWriter == null || TraceWriter.LevelFilter < TraceLevel.Verbose) ? null : new TraceJsonReader(reader));
			Newtonsoft.Json.Serialization.JsonSerializerInternalReader jsonSerializerInternalReader = new Newtonsoft.Json.Serialization.JsonSerializerInternalReader(this);
			jsonSerializerInternalReader.Populate(traceJsonReader ?? reader, target);
			if (traceJsonReader != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, "Deserialized JSON: " + Environment.NewLine + traceJsonReader.GetJson(), null);
			}
			ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
		}

		public object Deserialize(JsonReader reader)
		{
			return Deserialize(reader, null);
		}

		public object Deserialize(TextReader reader, Type objectType)
		{
			return Deserialize(new JsonTextReader(reader), objectType);
		}

		public T Deserialize<T>(JsonReader reader)
		{
			return (T)Deserialize(reader, typeof(T));
		}

		public object Deserialize(JsonReader reader, Type objectType)
		{
			return DeserializeInternal(reader, objectType);
		}

		internal virtual object DeserializeInternal(JsonReader reader, Type objectType)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			SetupReader(reader, out var previousCulture, out var previousDateTimeZoneHandling, out var previousDateParseHandling, out var previousFloatParseHandling, out var previousMaxDepth, out var previousDateFormatString);
			TraceJsonReader traceJsonReader = ((TraceWriter == null || TraceWriter.LevelFilter < TraceLevel.Verbose) ? null : new TraceJsonReader(reader));
			Newtonsoft.Json.Serialization.JsonSerializerInternalReader jsonSerializerInternalReader = new Newtonsoft.Json.Serialization.JsonSerializerInternalReader(this);
			object result = jsonSerializerInternalReader.Deserialize(traceJsonReader ?? reader, objectType, CheckAdditionalContent);
			if (traceJsonReader != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, "Deserialized JSON: " + Environment.NewLine + traceJsonReader.GetJson(), null);
			}
			ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
			return result;
		}

		private void SetupReader(JsonReader reader, out CultureInfo previousCulture, out DateTimeZoneHandling? previousDateTimeZoneHandling, out DateParseHandling? previousDateParseHandling, out FloatParseHandling? previousFloatParseHandling, out int? previousMaxDepth, out string previousDateFormatString)
		{
			if (_culture != null && !_culture.Equals(reader.Culture))
			{
				previousCulture = reader.Culture;
				reader.Culture = _culture;
			}
			else
			{
				previousCulture = null;
			}
			DateTimeZoneHandling? dateTimeZoneHandling = _dateTimeZoneHandling;
			if (dateTimeZoneHandling.HasValue && reader.DateTimeZoneHandling != _dateTimeZoneHandling)
			{
				previousDateTimeZoneHandling = reader.DateTimeZoneHandling;
				reader.DateTimeZoneHandling = _dateTimeZoneHandling.Value;
			}
			else
			{
				previousDateTimeZoneHandling = null;
			}
			DateParseHandling? dateParseHandling = _dateParseHandling;
			if (dateParseHandling.HasValue && reader.DateParseHandling != _dateParseHandling)
			{
				previousDateParseHandling = reader.DateParseHandling;
				reader.DateParseHandling = _dateParseHandling.Value;
			}
			else
			{
				previousDateParseHandling = null;
			}
			FloatParseHandling? floatParseHandling = _floatParseHandling;
			if (floatParseHandling.HasValue && reader.FloatParseHandling != _floatParseHandling)
			{
				previousFloatParseHandling = reader.FloatParseHandling;
				reader.FloatParseHandling = _floatParseHandling.Value;
			}
			else
			{
				previousFloatParseHandling = null;
			}
			if (_maxDepthSet)
			{
				int? maxDepth = reader.MaxDepth;
				int valueOrDefault = maxDepth.GetValueOrDefault();
				int? maxDepth2 = _maxDepth;
				if (valueOrDefault != maxDepth2.GetValueOrDefault() || (maxDepth.HasValue ^ maxDepth2.HasValue))
				{
					previousMaxDepth = reader.MaxDepth;
					reader.MaxDepth = _maxDepth;
					goto IL_020a;
				}
			}
			previousMaxDepth = null;
			goto IL_020a;
			IL_020a:
			if (_dateFormatStringSet && reader.DateFormatString != _dateFormatString)
			{
				previousDateFormatString = reader.DateFormatString;
				reader.DateFormatString = _dateFormatString;
			}
			else
			{
				previousDateFormatString = null;
			}
			if (reader is JsonTextReader jsonTextReader && _contractResolver is Newtonsoft.Json.Serialization.DefaultContractResolver defaultContractResolver)
			{
				jsonTextReader.NameTable = defaultContractResolver.GetState().NameTable;
			}
		}

		private void ResetReader(JsonReader reader, CultureInfo previousCulture, DateTimeZoneHandling? previousDateTimeZoneHandling, DateParseHandling? previousDateParseHandling, FloatParseHandling? previousFloatParseHandling, int? previousMaxDepth, string previousDateFormatString)
		{
			if (previousCulture != null)
			{
				reader.Culture = previousCulture;
			}
			if (previousDateTimeZoneHandling.HasValue)
			{
				reader.DateTimeZoneHandling = previousDateTimeZoneHandling.Value;
			}
			if (previousDateParseHandling.HasValue)
			{
				reader.DateParseHandling = previousDateParseHandling.Value;
			}
			if (previousFloatParseHandling.HasValue)
			{
				reader.FloatParseHandling = previousFloatParseHandling.Value;
			}
			if (_maxDepthSet)
			{
				reader.MaxDepth = previousMaxDepth;
			}
			if (_dateFormatStringSet)
			{
				reader.DateFormatString = previousDateFormatString;
			}
			if (reader is JsonTextReader jsonTextReader)
			{
				jsonTextReader.NameTable = null;
			}
		}

		public void Serialize(TextWriter textWriter, object value)
		{
			Serialize(new JsonTextWriter(textWriter), value);
		}

		public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
		{
			SerializeInternal(jsonWriter, value, objectType);
		}

		public void Serialize(TextWriter textWriter, object value, Type objectType)
		{
			Serialize(new JsonTextWriter(textWriter), value, objectType);
		}

		public void Serialize(JsonWriter jsonWriter, object value)
		{
			SerializeInternal(jsonWriter, value, null);
		}

		internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(jsonWriter, "jsonWriter");
			Formatting? formatting = null;
			Formatting? formatting2 = _formatting;
			if (formatting2.HasValue && jsonWriter.Formatting != _formatting)
			{
				formatting = jsonWriter.Formatting;
				jsonWriter.Formatting = _formatting.Value;
			}
			DateFormatHandling? dateFormatHandling = null;
			DateFormatHandling? dateFormatHandling2 = _dateFormatHandling;
			if (dateFormatHandling2.HasValue && jsonWriter.DateFormatHandling != _dateFormatHandling)
			{
				dateFormatHandling = jsonWriter.DateFormatHandling;
				jsonWriter.DateFormatHandling = _dateFormatHandling.Value;
			}
			DateTimeZoneHandling? dateTimeZoneHandling = null;
			DateTimeZoneHandling? dateTimeZoneHandling2 = _dateTimeZoneHandling;
			if (dateTimeZoneHandling2.HasValue && jsonWriter.DateTimeZoneHandling != _dateTimeZoneHandling)
			{
				dateTimeZoneHandling = jsonWriter.DateTimeZoneHandling;
				jsonWriter.DateTimeZoneHandling = _dateTimeZoneHandling.Value;
			}
			FloatFormatHandling? floatFormatHandling = null;
			FloatFormatHandling? floatFormatHandling2 = _floatFormatHandling;
			if (floatFormatHandling2.HasValue && jsonWriter.FloatFormatHandling != _floatFormatHandling)
			{
				floatFormatHandling = jsonWriter.FloatFormatHandling;
				jsonWriter.FloatFormatHandling = _floatFormatHandling.Value;
			}
			StringEscapeHandling? stringEscapeHandling = null;
			StringEscapeHandling? stringEscapeHandling2 = _stringEscapeHandling;
			if (stringEscapeHandling2.HasValue && jsonWriter.StringEscapeHandling != _stringEscapeHandling)
			{
				stringEscapeHandling = jsonWriter.StringEscapeHandling;
				jsonWriter.StringEscapeHandling = _stringEscapeHandling.Value;
			}
			CultureInfo cultureInfo = null;
			if (_culture != null && !_culture.Equals(jsonWriter.Culture))
			{
				cultureInfo = jsonWriter.Culture;
				jsonWriter.Culture = _culture;
			}
			string dateFormatString = null;
			if (_dateFormatStringSet && jsonWriter.DateFormatString != _dateFormatString)
			{
				dateFormatString = jsonWriter.DateFormatString;
				jsonWriter.DateFormatString = _dateFormatString;
			}
			TraceJsonWriter traceJsonWriter = ((TraceWriter == null || TraceWriter.LevelFilter < TraceLevel.Verbose) ? null : new TraceJsonWriter(jsonWriter));
			Newtonsoft.Json.Serialization.JsonSerializerInternalWriter jsonSerializerInternalWriter = new Newtonsoft.Json.Serialization.JsonSerializerInternalWriter(this);
			jsonSerializerInternalWriter.Serialize(traceJsonWriter ?? jsonWriter, value, objectType);
			if (traceJsonWriter != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, "Serialized JSON: " + Environment.NewLine + traceJsonWriter.GetJson(), null);
			}
			if (formatting.HasValue)
			{
				jsonWriter.Formatting = formatting.Value;
			}
			if (dateFormatHandling.HasValue)
			{
				jsonWriter.DateFormatHandling = dateFormatHandling.Value;
			}
			if (dateTimeZoneHandling.HasValue)
			{
				jsonWriter.DateTimeZoneHandling = dateTimeZoneHandling.Value;
			}
			if (floatFormatHandling.HasValue)
			{
				jsonWriter.FloatFormatHandling = floatFormatHandling.Value;
			}
			if (stringEscapeHandling.HasValue)
			{
				jsonWriter.StringEscapeHandling = stringEscapeHandling.Value;
			}
			if (_dateFormatStringSet)
			{
				jsonWriter.DateFormatString = dateFormatString;
			}
			if (cultureInfo != null)
			{
				jsonWriter.Culture = cultureInfo;
			}
		}

		internal Newtonsoft.Json.Serialization.IReferenceResolver GetReferenceResolver()
		{
			if (_referenceResolver == null)
			{
				_referenceResolver = new Newtonsoft.Json.Serialization.DefaultReferenceResolver();
			}
			return _referenceResolver;
		}

		internal JsonConverter GetMatchingConverter(Type type)
		{
			return GetMatchingConverter(_converters, type);
		}

		internal static JsonConverter GetMatchingConverter(IList<JsonConverter> converters, Type objectType)
		{
			if (converters != null)
			{
				for (int i = 0; i < converters.Count; i++)
				{
					JsonConverter jsonConverter = converters[i];
					if (jsonConverter.CanConvert(objectType))
					{
						return jsonConverter;
					}
				}
			}
			return null;
		}

		internal void OnError(Newtonsoft.Json.Serialization.ErrorEventArgs e)
		{
			this.Error?.Invoke(this, e);
		}
	}
	public class JsonSerializerSettings
	{
		internal const ReferenceLoopHandling DefaultReferenceLoopHandling = ReferenceLoopHandling.Error;

		internal const MissingMemberHandling DefaultMissingMemberHandling = MissingMemberHandling.Ignore;

		internal const NullValueHandling DefaultNullValueHandling = NullValueHandling.Include;

		internal const DefaultValueHandling DefaultDefaultValueHandling = DefaultValueHandling.Include;

		internal const ObjectCreationHandling DefaultObjectCreationHandling = ObjectCreationHandling.Auto;

		internal const PreserveReferencesHandling DefaultPreserveReferencesHandling = PreserveReferencesHandling.None;

		internal const ConstructorHandling DefaultConstructorHandling = ConstructorHandling.Default;

		internal const TypeNameHandling DefaultTypeNameHandling = TypeNameHandling.None;

		internal const MetadataPropertyHandling DefaultMetadataPropertyHandling = MetadataPropertyHandling.Default;

		internal const FormatterAssemblyStyle DefaultTypeNameAssemblyFormat = FormatterAssemblyStyle.Simple;

		internal static readonly StreamingContext DefaultContext;

		internal const Formatting DefaultFormatting = Formatting.None;

		internal const DateFormatHandling DefaultDateFormatHandling = DateFormatHandling.IsoDateFormat;

		internal const DateTimeZoneHandling DefaultDateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;

		internal const DateParseHandling DefaultDateParseHandling = DateParseHandling.DateTime;

		internal const FloatParseHandling DefaultFloatParseHandling = FloatParseHandling.Double;

		internal const FloatFormatHandling DefaultFloatFormatHandling = FloatFormatHandling.String;

		internal const StringEscapeHandling DefaultStringEscapeHandling = StringEscapeHandling.Default;

		internal const FormatterAssemblyStyle DefaultFormatterAssemblyStyle = FormatterAssemblyStyle.Simple;

		internal static readonly CultureInfo DefaultCulture;

		internal const bool DefaultCheckAdditionalContent = false;

		internal const string DefaultDateFormatString = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

		internal Formatting? _formatting;

		internal DateFormatHandling? _dateFormatHandling;

		internal DateTimeZoneHandling? _dateTimeZoneHandling;

		internal DateParseHandling? _dateParseHandling;

		internal FloatFormatHandling? _floatFormatHandling;

		internal FloatParseHandling? _floatParseHandling;

		internal StringEscapeHandling? _stringEscapeHandling;

		internal CultureInfo _culture;

		internal bool? _checkAdditionalContent;

		internal int? _maxDepth;

		internal bool _maxDepthSet;

		internal string _dateFormatString;

		internal bool _dateFormatStringSet;

		internal FormatterAssemblyStyle? _typeNameAssemblyFormat;

		internal DefaultValueHandling? _defaultValueHandling;

		internal PreserveReferencesHandling? _preserveReferencesHandling;

		internal NullValueHandling? _nullValueHandling;

		internal ObjectCreationHandling? _objectCreationHandling;

		internal MissingMemberHandling? _missingMemberHandling;

		internal ReferenceLoopHandling? _referenceLoopHandling;

		internal StreamingContext? _context;

		internal ConstructorHandling? _constructorHandling;

		internal TypeNameHandling? _typeNameHandling;

		internal MetadataPropertyHandling? _metadataPropertyHandling;

		public ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				ReferenceLoopHandling? referenceLoopHandling = _referenceLoopHandling;
				return referenceLoopHandling.HasValue ? referenceLoopHandling.Value : ReferenceLoopHandling.Error;
			}
			set
			{
				_referenceLoopHandling = value;
			}
		}

		public MissingMemberHandling MissingMemberHandling
		{
			get
			{
				MissingMemberHandling? missingMemberHandling = _missingMemberHandling;
				return missingMemberHandling.HasValue ? missingMemberHandling.Value : MissingMemberHandling.Ignore;
			}
			set
			{
				_missingMemberHandling = value;
			}
		}

		public ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				ObjectCreationHandling? objectCreationHandling = _objectCreationHandling;
				return objectCreationHandling.HasValue ? objectCreationHandling.Value : ObjectCreationHandling.Auto;
			}
			set
			{
				_objectCreationHandling = value;
			}
		}

		public NullValueHandling NullValueHandling
		{
			get
			{
				NullValueHandling? nullValueHandling = _nullValueHandling;
				return nullValueHandling.HasValue ? nullValueHandling.Value : NullValueHandling.Include;
			}
			set
			{
				_nullValueHandling = value;
			}
		}

		public DefaultValueHandling DefaultValueHandling
		{
			get
			{
				DefaultValueHandling? defaultValueHandling = _defaultValueHandling;
				return defaultValueHandling.HasValue ? defaultValueHandling.Value : DefaultValueHandling.Include;
			}
			set
			{
				_defaultValueHandling = value;
			}
		}

		public IList<JsonConverter> Converters { get; set; }

		public PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				PreserveReferencesHandling? preserveReferencesHandling = _preserveReferencesHandling;
				return preserveReferencesHandling.HasValue ? preserveReferencesHandling.Value : PreserveReferencesHandling.None;
			}
			set
			{
				_preserveReferencesHandling = value;
			}
		}

		public TypeNameHandling TypeNameHandling
		{
			get
			{
				TypeNameHandling? typeNameHandling = _typeNameHandling;
				return typeNameHandling.HasValue ? typeNameHandling.Value : TypeNameHandling.None;
			}
			set
			{
				_typeNameHandling = value;
			}
		}

		public MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				MetadataPropertyHandling? metadataPropertyHandling = _metadataPropertyHandling;
				return metadataPropertyHandling.HasValue ? metadataPropertyHandling.Value : MetadataPropertyHandling.Default;
			}
			set
			{
				_metadataPropertyHandling = value;
			}
		}

		public FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				FormatterAssemblyStyle? typeNameAssemblyFormat = _typeNameAssemblyFormat;
				return typeNameAssemblyFormat.HasValue ? typeNameAssemblyFormat.Value : FormatterAssemblyStyle.Simple;
			}
			set
			{
				_typeNameAssemblyFormat = value;
			}
		}

		public ConstructorHandling ConstructorHandling
		{
			get
			{
				ConstructorHandling? constructorHandling = _constructorHandling;
				return constructorHandling.HasValue ? constructorHandling.Value : ConstructorHandling.Default;
			}
			set
			{
				_constructorHandling = value;
			}
		}

		public Newtonsoft.Json.Serialization.IContractResolver ContractResolver { get; set; }

		public Newtonsoft.Json.Serialization.IReferenceResolver ReferenceResolver { get; set; }

		public ITraceWriter TraceWriter { get; set; }

		public SerializationBinder Binder { get; set; }

		public EventHandler<Newtonsoft.Json.Serialization.ErrorEventArgs> Error { get; set; }

		public StreamingContext Context
		{
			get
			{
				StreamingContext? context = _context;
				return (!context.HasValue) ? DefaultContext : context.Value;
			}
			set
			{
				_context = value;
			}
		}

		public string DateFormatString
		{
			get
			{
				return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
			}
			set
			{
				_dateFormatString = value;
				_dateFormatStringSet = true;
			}
		}

		public int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value.HasValue && value.GetValueOrDefault() <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
				_maxDepthSet = true;
			}
		}

		public Formatting Formatting
		{
			get
			{
				Formatting? formatting = _formatting;
				return formatting.HasValue ? formatting.Value : Formatting.None;
			}
			set
			{
				_formatting = value;
			}
		}

		public DateFormatHandling DateFormatHandling
		{
			get
			{
				DateFormatHandling? dateFormatHandling = _dateFormatHandling;
				return dateFormatHandling.HasValue ? dateFormatHandling.Value : DateFormatHandling.IsoDateFormat;
			}
			set
			{
				_dateFormatHandling = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				DateTimeZoneHandling? dateTimeZoneHandling = _dateTimeZoneHandling;
				return (!dateTimeZoneHandling.HasValue) ? DateTimeZoneHandling.RoundtripKind : dateTimeZoneHandling.Value;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public DateParseHandling DateParseHandling
		{
			get
			{
				DateParseHandling? dateParseHandling = _dateParseHandling;
				return (!dateParseHandling.HasValue) ? DateParseHandling.DateTime : dateParseHandling.Value;
			}
			set
			{
				_dateParseHandling = value;
			}
		}

		public FloatFormatHandling FloatFormatHandling
		{
			get
			{
				FloatFormatHandling? floatFormatHandling = _floatFormatHandling;
				return floatFormatHandling.HasValue ? floatFormatHandling.Value : FloatFormatHandling.String;
			}
			set
			{
				_floatFormatHandling = value;
			}
		}

		public FloatParseHandling FloatParseHandling
		{
			get
			{
				FloatParseHandling? floatParseHandling = _floatParseHandling;
				return floatParseHandling.HasValue ? floatParseHandling.Value : FloatParseHandling.Double;
			}
			set
			{
				_floatParseHandling = value;
			}
		}

		public StringEscapeHandling StringEscapeHandling
		{
			get
			{
				StringEscapeHandling? stringEscapeHandling = _stringEscapeHandling;
				return stringEscapeHandling.HasValue ? stringEscapeHandling.Value : StringEscapeHandling.Default;
			}
			set
			{
				_stringEscapeHandling = value;
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? DefaultCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public bool CheckAdditionalContent
		{
			get
			{
				bool? checkAdditionalContent = _checkAdditionalContent;
				return checkAdditionalContent.HasValue && checkAdditionalContent.Value;
			}
			set
			{
				_checkAdditionalContent = value;
			}
		}

		static JsonSerializerSettings()
		{
			DefaultContext = default(StreamingContext);
			DefaultCulture = CultureInfo.InvariantCulture;
		}

		public JsonSerializerSettings()
		{
			Converters = new List<JsonConverter>();
		}
	}
	internal enum ReadType
	{
		Read,
		ReadAsInt32,
		ReadAsBytes,
		ReadAsString,
		ReadAsDecimal,
		ReadAsDateTime
	}
	public class JsonTextReader : JsonReader, IJsonLineInfo
	{
		private const char UnicodeReplacementChar = '\ufffd';

		private const int MaximumJavascriptIntegerCharacterLength = 380;

		private readonly TextReader _reader;

		private char[] _chars;

		private int _charsUsed;

		private int _charPos;

		private int _lineStartPos;

		private int _lineNumber;

		private bool _isEndOfFile;

		private Newtonsoft.Json.Utilities.StringBuffer _buffer;

		private StringReference _stringReference;

		internal PropertyNameTable NameTable;

		public int LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start && LinePosition == 0)
				{
					return 0;
				}
				return _lineNumber;
			}
		}

		public int LinePosition => _charPos - _lineStartPos;

		public JsonTextReader(TextReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			_reader = reader;
			_lineNumber = 1;
			_chars = new char[1025];
		}

		private Newtonsoft.Json.Utilities.StringBuffer GetBuffer()
		{
			if (_buffer == null)
			{
				_buffer = new Newtonsoft.Json.Utilities.StringBuffer(1025);
			}
			else
			{
				_buffer.Position = 0;
			}
			return _buffer;
		}

		private void OnNewLine(int pos)
		{
			_lineNumber++;
			_lineStartPos = pos - 1;
		}

		private void ParseString(char quote)
		{
			_charPos++;
			ShiftBufferIfNeeded();
			ReadStringIntoBuffer(quote);
			SetPostValueState(updateIndex: true);
			if (_readType == ReadType.ReadAsBytes)
			{
				byte[] value = ((_stringReference.Length != 0) ? Convert.FromBase64CharArray(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length) : new byte[0]);
				SetToken(JsonToken.Bytes, value, updateIndex: false);
				return;
			}
			if (_readType == ReadType.ReadAsString)
			{
				string value2 = _stringReference.ToString();
				SetToken(JsonToken.String, value2, updateIndex: false);
				_quoteChar = quote;
				return;
			}
			string text = _stringReference.ToString();
			if (_dateParseHandling != 0)
			{
				DateParseHandling dateParseHandling = ((_readType == ReadType.ReadAsDateTime) ? DateParseHandling.DateTime : _dateParseHandling);
				if (Newtonsoft.Json.Utilities.DateTimeUtils.TryParseDateTime(text, dateParseHandling, base.DateTimeZoneHandling, base.DateFormatString, base.Culture, out var dt))
				{
					SetToken(JsonToken.Date, dt, updateIndex: false);
					return;
				}
			}
			SetToken(JsonToken.String, text, updateIndex: false);
			_quoteChar = quote;
		}

		private static void BlockCopyChars(char[] src, int srcOffset, char[] dst, int dstOffset, int count)
		{
			Buffer.BlockCopy(src, srcOffset * 2, dst, dstOffset * 2, count * 2);
		}

		private void ShiftBufferIfNeeded()
		{
			int num = _chars.Length;
			if ((double)(num - _charPos) <= (double)num * 0.1)
			{
				int num2 = _charsUsed - _charPos;
				if (num2 > 0)
				{
					BlockCopyChars(_chars, _charPos, _chars, 0, num2);
				}
				_lineStartPos -= _charPos;
				_charPos = 0;
				_charsUsed = num2;
				_chars[_charsUsed] = '\0';
			}
		}

		private int ReadData(bool append)
		{
			return ReadData(append, 0);
		}

		private int ReadData(bool append, int charsRequired)
		{
			if (_isEndOfFile)
			{
				return 0;
			}
			if (_charsUsed + charsRequired >= _chars.Length - 1)
			{
				if (append)
				{
					int num = Math.Max(_chars.Length * 2, _charsUsed + charsRequired + 1);
					char[] array = new char[num];
					BlockCopyChars(_chars, 0, array, 0, _chars.Length);
					_chars = array;
				}
				else
				{
					int num2 = _charsUsed - _charPos;
					if (num2 + charsRequired + 1 >= _chars.Length)
					{
						char[] array2 = new char[num2 + charsRequired + 1];
						if (num2 > 0)
						{
							BlockCopyChars(_chars, _charPos, array2, 0, num2);
						}
						_chars = array2;
					}
					else if (num2 > 0)
					{
						BlockCopyChars(_chars, _charPos, _chars, 0, num2);
					}
					_lineStartPos -= _charPos;
					_charPos = 0;
					_charsUsed = num2;
				}
			}
			int count = _chars.Length - _charsUsed - 1;
			int num3 = _reader.Read(_chars, _charsUsed, count);
			_charsUsed += num3;
			if (num3 == 0)
			{
				_isEndOfFile = true;
			}
			_chars[_charsUsed] = '\0';
			return num3;
		}

		private bool EnsureChars(int relativePosition, bool append)
		{
			if (_charPos + relativePosition >= _charsUsed)
			{
				return ReadChars(relativePosition, append);
			}
			return true;
		}

		private bool ReadChars(int relativePosition, bool append)
		{
			if (_isEndOfFile)
			{
				return false;
			}
			int num = _charPos + relativePosition - _charsUsed + 1;
			int num2 = 0;
			do
			{
				int num3 = ReadData(append, num - num2);
				if (num3 == 0)
				{
					break;
				}
				num2 += num3;
			}
			while (num2 < num);
			if (num2 < num)
			{
				return false;
			}
			return true;
		}

		[DebuggerStepThrough]
		public override bool Read()
		{
			_readType = ReadType.Read;
			if (!ReadInternal())
			{
				SetToken(JsonToken.None);
				return false;
			}
			return true;
		}

		public override byte[] ReadAsBytes()
		{
			return ReadAsBytesInternal();
		}

		public override decimal? ReadAsDecimal()
		{
			return ReadAsDecimalInternal();
		}

		public override int? ReadAsInt32()
		{
			return ReadAsInt32Internal();
		}

		public override string ReadAsString()
		{
			return ReadAsStringInternal();
		}

		public override DateTime? ReadAsDateTime()
		{
			return ReadAsDateTimeInternal();
		}

		internal override bool ReadInternal()
		{
			do
			{
				switch (_currentState)
				{
				case State.Start:
				case State.Property:
				case State.ArrayStart:
				case State.Array:
				case State.ConstructorStart:
				case State.Constructor:
					return ParseValue();
				case State.ObjectStart:
				case State.Object:
					return ParseObject();
				case State.PostValue:
					break;
				case State.Finished:
					if (EnsureChars(0, append: false))
					{
						EatWhitespace(oneOrMore: false);
						if (_isEndOfFile)
						{
							return false;
						}
						if (_chars[_charPos] == '/')
						{
							ParseComment();
							return true;
						}
						throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
					}
					return false;
				default:
					throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
				}
			}
			while (!ParsePostValue());
			return true;
		}

		private void ReadStringIntoBuffer(char quote)
		{
			int num = _charPos;
			int charPos = _charPos;
			int num2 = _charPos;
			Newtonsoft.Json.Utilities.StringBuffer stringBuffer = null;
			while (true)
			{
				switch (_chars[num++])
				{
				case '\0':
					if (_charsUsed == num - 1)
					{
						num--;
						if (ReadData(append: true) == 0)
						{
							_charPos = num;
							throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
						}
					}
					break;
				case '\\':
				{
					_charPos = num;
					if (!EnsureChars(0, append: true))
					{
						_charPos = num;
						throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
					}
					int writeToPosition = num - 1;
					char c = _chars[num];
					char c2;
					switch (c)
					{
					case 'b':
						num++;
						c2 = '\b';
						break;
					case 't':
						num++;
						c2 = '\t';
						break;
					case 'n':
						num++;
						c2 = '\n';
						break;
					case 'f':
						num++;
						c2 = '\f';
						break;
					case 'r':
						num++;
						c2 = '\r';
						break;
					case '\\':
						num++;
						c2 = '\\';
						break;
					case '"':
					case '\'':
					case '/':
						c2 = c;
						num++;
						break;
					case 'u':
						num++;
						_charPos = num;
						c2 = ParseUnicode();
						if (Newtonsoft.Json.Utilities.StringUtils.IsLowSurrogate(c2))
						{
							c2 = '\ufffd';
						}
						else if (Newtonsoft.Json.Utilities.StringUtils.IsHighSurrogate(c2))
						{
							bool flag;
							do
							{
								flag = false;
								if (EnsureChars(2, append: true) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')
								{
									char writeChar = c2;
									_charPos += 2;
									c2 = ParseUnicode();
									if (!Newtonsoft.Json.Utilities.StringUtils.IsLowSurrogate(c2))
									{
										if (Newtonsoft.Json.Utilities.StringUtils.IsHighSurrogate(c2))
										{
											writeChar = '\ufffd';
											flag = true;
										}
										else
										{
											writeChar = '\ufffd';
										}
									}
									if (stringBuffer == null)
									{
										stringBuffer = GetBuffer();
									}
									WriteCharToBuffer(stringBuffer, writeChar, num2, writeToPosition);
									num2 = _charPos;
								}
								else
								{
									c2 = '\ufffd';
								}
							}
							while (flag);
						}
						num = _charPos;
						break;
					default:
						num++;
						_charPos = num;
						throw JsonReaderException.Create(this, "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture, "\\" + c));
					}
					if (stringBuffer == null)
					{
						stringBuffer = GetBuffer();
					}
					WriteCharToBuffer(stringBuffer, c2, num2, writeToPosition);
					num2 = num;
					break;
				}
				case '\r':
					_charPos = num - 1;
					ProcessCarriageReturn(append: true);
					num = _charPos;
					break;
				case '\n':
					_charPos = num - 1;
					ProcessLineFeed();
					num = _charPos;
					break;
				case '"':
				case '\'':
					if (_chars[num - 1] != quote)
					{
						break;
					}
					num--;
					if (charPos == num2)
					{
						_stringReference = new StringReference(_chars, charPos, num - charPos);
					}
					else
					{
						if (stringBuffer == null)
						{
							stringBuffer = GetBuffer();
						}
						if (num > num2)
						{
							stringBuffer.Append(_chars, num2, num - num2);
						}
						_stringReference = new StringReference(stringBuffer.GetInternalBuffer(), 0, stringBuffer.Position);
					}
					num++;
					_charPos = num;
					return;
				}
			}
		}

		private void WriteCharToBuffer(Newtonsoft.Json.Utilities.StringBuffer buffer, char writeChar, int lastWritePosition, int writeToPosition)
		{
			if (writeToPosition > lastWritePosition)
			{
				buffer.Append(_chars, lastWritePosition, writeToPosition - lastWritePosition);
			}
			buffer.Append(writeChar);
		}

		private char ParseUnicode()
		{
			if (EnsureChars(4, append: true))
			{
				string s = new string(_chars, _charPos, 4);
				char c = Convert.ToChar(int.Parse(s, NumberStyles.HexNumber, NumberFormatInfo.InvariantInfo));
				char result = c;
				_charPos += 4;
				return result;
			}
			throw JsonReaderException.Create(this, "Unexpected end while parsing unicode character.");
		}

		private void ReadNumberIntoBuffer()
		{
			int num = _charPos;
			while (true)
			{
				switch (_chars[num])
				{
				case '\0':
					_charPos = num;
					if (_charsUsed != num || ReadData(append: true) == 0)
					{
						return;
					}
					continue;
				case '+':
				case '-':
				case '.':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'X':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'x':
					num++;
					continue;
				}
				_charPos = num;
				char c = _chars[_charPos];
				if (char.IsWhiteSpace(c) || c == ',' || c == '}' || c == ']' || c == ')' || c == '/')
				{
					return;
				}
				throw JsonReaderException.Create(this, "Unexpected character encountered while parsing number: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
			}
		}

		private void ClearRecentString()
		{
			if (_buffer != null)
			{
				_buffer.Position = 0;
			}
			_stringReference = default(StringReference);
		}

		private bool ParsePostValue()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							_currentState = State.Finished;
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '}':
					_charPos++;
					SetToken(JsonToken.EndObject);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '/':
					ParseComment();
					return true;
				case ',':
					_charPos++;
					SetStateBasedOnCurrent();
					return false;
				case '\t':
				case ' ':
					_charPos++;
					break;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					throw JsonReaderException.Create(this, "After parsing a value an unexpected character was encountered: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
				}
			}
		}

		private bool ParseObject()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '}':
					SetToken(JsonToken.EndObject);
					_charPos++;
					return true;
				case '/':
					ParseComment();
					return true;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					return ParseProperty();
				}
			}
		}

		private bool ParseProperty()
		{
			char c = _chars[_charPos];
			char c2;
			if (c == '"' || c == '\'')
			{
				_charPos++;
				c2 = c;
				ShiftBufferIfNeeded();
				ReadStringIntoBuffer(c2);
			}
			else
			{
				if (!ValidIdentifierChar(c))
				{
					throw JsonReaderException.Create(this, "Invalid property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				c2 = '\0';
				ShiftBufferIfNeeded();
				ParseUnquotedProperty();
			}
			string text;
			if (NameTable != null)
			{
				text = NameTable.Get(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length);
				if (text == null)
				{
					text = _stringReference.ToString();
				}
			}
			else
			{
				text = _stringReference.ToString();
			}
			EatWhitespace(oneOrMore: false);
			if (_chars[_charPos] != ':')
			{
				throw JsonReaderException.Create(this, "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			_charPos++;
			SetToken(JsonToken.PropertyName, text);
			_quoteChar = c2;
			ClearRecentString();
			return true;
		}

		private bool ValidIdentifierChar(char value)
		{
			return char.IsLetterOrDigit(value) || value == '_' || value == '$';
		}

		private void ParseUnquotedProperty()
		{
			int charPos = _charPos;
			char c;
			while (true)
			{
				if (_chars[_charPos] == '\0')
				{
					if (_charsUsed != _charPos)
					{
						_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
						return;
					}
					if (ReadData(append: true) == 0)
					{
						throw JsonReaderException.Create(this, "Unexpected end while parsing unquoted property name.");
					}
				}
				else
				{
					c = _chars[_charPos];
					if (!ValidIdentifierChar(c))
					{
						break;
					}
					_charPos++;
				}
			}
			if (char.IsWhiteSpace(c) || c == ':')
			{
				_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
				return;
			}
			throw JsonReaderException.Create(this, "Invalid JavaScript property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
		}

		private bool ParseValue()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '"':
				case '\'':
					ParseString(c);
					return true;
				case 't':
					ParseTrue();
					return true;
				case 'f':
					ParseFalse();
					return true;
				case 'n':
					if (EnsureChars(1, append: true))
					{
						switch (_chars[_charPos + 1])
						{
						case 'u':
							ParseNull();
							break;
						case 'e':
							ParseConstructor();
							break;
						default:
							throw JsonReaderException.Create(this, "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
						}
						return true;
					}
					throw JsonReaderException.Create(this, "Unexpected end.");
				case 'N':
					ParseNumberNaN();
					return true;
				case 'I':
					ParseNumberPositiveInfinity();
					return true;
				case '-':
					if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
					{
						ParseNumberNegativeInfinity();
					}
					else
					{
						ParseNumber();
					}
					return true;
				case '/':
					ParseComment();
					return true;
				case 'u':
					ParseUndefined();
					return true;
				case '{':
					_charPos++;
					SetToken(JsonToken.StartObject);
					return true;
				case '[':
					_charPos++;
					SetToken(JsonToken.StartArray);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ',':
					SetToken(JsonToken.Undefined);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					if (char.IsNumber(c) || c == '-' || c == '.')
					{
						ParseNumber();
						return true;
					}
					throw JsonReaderException.Create(this, "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
				}
			}
		}

		private void ProcessLineFeed()
		{
			_charPos++;
			OnNewLine(_charPos);
		}

		private void ProcessCarriageReturn(bool append)
		{
			_charPos++;
			if (EnsureChars(1, append) && _chars[_charPos] == '\n')
			{
				_charPos++;
			}
			OnNewLine(_charPos);
		}

		private bool EatWhitespace(bool oneOrMore)
		{
			bool flag = false;
			bool flag2 = false;
			while (!flag)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							flag = true;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				default:
					if (!char.IsWhiteSpace(c))
					{
						flag = true;
						break;
					}
					goto case ' ';
				case ' ':
					flag2 = true;
					_charPos++;
					break;
				}
			}
			return !oneOrMore || flag2;
		}

		private void ParseConstructor()
		{
			if (MatchValueWithTrailingSeparator("new"))
			{
				EatWhitespace(oneOrMore: false);
				int charPos = _charPos;
				int charPos2;
				while (true)
				{
					char c = _chars[_charPos];
					if (c == '\0')
					{
						if (_charsUsed == _charPos)
						{
							if (ReadData(append: true) == 0)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing constructor.");
							}
							continue;
						}
						charPos2 = _charPos;
						_charPos++;
						break;
					}
					if (char.IsLetterOrDigit(c))
					{
						_charPos++;
						continue;
					}
					switch (c)
					{
					case '\r':
						charPos2 = _charPos;
						ProcessCarriageReturn(append: true);
						break;
					case '\n':
						charPos2 = _charPos;
						ProcessLineFeed();
						break;
					default:
						if (char.IsWhiteSpace(c))
						{
							charPos2 = _charPos;
							_charPos++;
							break;
						}
						if (c == '(')
						{
							charPos2 = _charPos;
							break;
						}
						throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
					}
					break;
				}
				_stringReference = new StringReference(_chars, charPos, charPos2 - charPos);
				string value = _stringReference.ToString();
				EatWhitespace(oneOrMore: false);
				if (_chars[_charPos] != '(')
				{
					throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				_charPos++;
				ClearRecentString();
				SetToken(JsonToken.StartConstructor, value);
				return;
			}
			throw JsonReaderException.Create(this, "Unexpected content while parsing JSON.");
		}

		private void ParseNumber()
		{
			ShiftBufferIfNeeded();
			char c = _chars[_charPos];
			int charPos = _charPos;
			ReadNumberIntoBuffer();
			SetPostValueState(updateIndex: true);
			_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
			bool flag = char.IsDigit(c) && _stringReference.Length == 1;
			bool flag2 = c == '0' && _stringReference.Length > 1 && _stringReference.Chars[_stringReference.StartIndex + 1] != '.' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'e' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'E';
			object value;
			JsonToken newToken;
			if (_readType == ReadType.ReadAsInt32)
			{
				if (flag)
				{
					value = c - 48;
				}
				else if (flag2)
				{
					string text = _stringReference.ToString();
					try
					{
						int num = ((!text.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) ? Convert.ToInt32(text, 8) : Convert.ToInt32(text, 16));
						value = num;
					}
					catch (Exception ex)
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, text), ex);
					}
				}
				else
				{
					int value2;
					switch (Newtonsoft.Json.Utilities.ConvertUtils.Int32TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value2))
					{
					case ParseResult.Success:
						break;
					case ParseResult.Overflow:
						throw JsonReaderException.Create(this, "JSON integer {0} is too large or small for an Int32.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					default:
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = value2;
				}
				newToken = JsonToken.Integer;
			}
			else if (_readType == ReadType.ReadAsDecimal)
			{
				if (flag)
				{
					value = (decimal)c - 48m;
				}
				else if (flag2)
				{
					string text2 = _stringReference.ToString();
					try
					{
						long value3 = ((!text2.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) ? Convert.ToInt64(text2, 8) : Convert.ToInt64(text2, 16));
						value = Convert.ToDecimal(value3);
					}
					catch (Exception ex2)
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, text2), ex2);
					}
				}
				else
				{
					string s = _stringReference.ToString();
					if (!decimal.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out var result))
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = result;
				}
				newToken = JsonToken.Float;
			}
			else if (flag)
			{
				value = (long)(int)c - 48L;
				newToken = JsonToken.Integer;
			}
			else if (flag2)
			{
				string text3 = _stringReference.ToString();
				try
				{
					value = ((!text3.StartsWith("0x", StringComparison.OrdinalIgnoreCase)) ? Convert.ToInt64(text3, 8) : Convert.ToInt64(text3, 16));
				}
				catch (Exception ex3)
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text3), ex3);
				}
				newToken = JsonToken.Integer;
			}
			else
			{
				long value4;
				switch (Newtonsoft.Json.Utilities.ConvertUtils.Int64TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value4))
				{
				case ParseResult.Success:
					value = value4;
					newToken = JsonToken.Integer;
					break;
				case ParseResult.Overflow:
					throw JsonReaderException.Create(this, "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				default:
				{
					string text4 = _stringReference.ToString();
					if (_floatParseHandling == FloatParseHandling.Decimal)
					{
						if (!decimal.TryParse(text4, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out var result2))
						{
							throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, text4));
						}
						value = result2;
					}
					else
					{
						if (!double.TryParse(text4, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var result3))
						{
							throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text4));
						}
						value = result3;
					}
					newToken = JsonToken.Float;
					break;
				}
				}
			}
			ClearRecentString();
			SetToken(newToken, value, updateIndex: false);
		}

		private void ParseComment()
		{
			_charPos++;
			if (!EnsureChars(1, append: false))
			{
				throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
			}
			bool flag;
			if (_chars[_charPos] == '*')
			{
				flag = false;
			}
			else
			{
				if (_chars[_charPos] != '/')
				{
					throw JsonReaderException.Create(this, "Error parsing comment. Expected: *, got {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				flag = true;
			}
			_charPos++;
			int charPos = _charPos;
			bool flag2 = false;
			while (!flag2)
			{
				switch (_chars[_charPos])
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: true) == 0)
						{
							if (!flag)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
							}
							_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
							flag2 = true;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '*':
					_charPos++;
					if (!flag && EnsureChars(0, append: true) && _chars[_charPos] == '/')
					{
						_stringReference = new StringReference(_chars, charPos, _charPos - charPos - 1);
						_charPos++;
						flag2 = true;
					}
					break;
				case '\r':
					if (flag)
					{
						_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
						flag2 = true;
					}
					ProcessCarriageReturn(append: true);
					break;
				case '\n':
					if (flag)
					{
						_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
						flag2 = true;
					}
					ProcessLineFeed();
					break;
				default:
					_charPos++;
					break;
				}
			}
			SetToken(JsonToken.Comment, _stringReference.ToString());
			ClearRecentString();
		}

		private bool MatchValue(string value)
		{
			if (!EnsureChars(value.Length - 1, append: true))
			{
				return false;
			}
			for (int i = 0; i < value.Length; i++)
			{
				if (_chars[_charPos + i] != value[i])
				{
					return false;
				}
			}
			_charPos += value.Length;
			return true;
		}

		private bool MatchValueWithTrailingSeparator(string value)
		{
			if (!MatchValue(value))
			{
				return false;
			}
			if (!EnsureChars(0, append: false))
			{
				return true;
			}
			return IsSeparator(_chars[_charPos]) || _chars[_charPos] == '\0';
		}

		private bool IsSeparator(char c)
		{
			switch (c)
			{
			case ',':
			case ']':
			case '}':
				return true;
			case '/':
			{
				if (!EnsureChars(1, append: false))
				{
					return false;
				}
				char c2 = _chars[_charPos + 1];
				return c2 == '*' || c2 == '/';
			}
			case ')':
				if (base.CurrentState == State.Constructor || base.CurrentState == State.ConstructorStart)
				{
					return true;
				}
				break;
			case '\t':
			case '\n':
			case '\r':
			case ' ':
				return true;
			default:
				if (char.IsWhiteSpace(c))
				{
					return true;
				}
				break;
			}
			return false;
		}

		private void ParseTrue()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.True))
			{
				SetToken(JsonToken.Boolean, true);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing boolean value.");
		}

		private void ParseNull()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.Null))
			{
				SetToken(JsonToken.Null);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing null value.");
		}

		private void ParseUndefined()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.Undefined))
			{
				SetToken(JsonToken.Undefined);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing undefined value.");
		}

		private void ParseFalse()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.False))
			{
				SetToken(JsonToken.Boolean, false);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing boolean value.");
		}

		private void ParseNumberNegativeInfinity()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.NegativeInfinity))
			{
				if (_floatParseHandling == FloatParseHandling.Decimal)
				{
					throw new JsonReaderException("Cannot read -Infinity as a decimal.");
				}
				SetToken(JsonToken.Float, double.NegativeInfinity);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing negative infinity value.");
		}

		private void ParseNumberPositiveInfinity()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.PositiveInfinity))
			{
				if (_floatParseHandling == FloatParseHandling.Decimal)
				{
					throw new JsonReaderException("Cannot read Infinity as a decimal.");
				}
				SetToken(JsonToken.Float, double.PositiveInfinity);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing positive infinity value.");
		}

		private void ParseNumberNaN()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.NaN))
			{
				if (_floatParseHandling == FloatParseHandling.Decimal)
				{
					throw new JsonReaderException("Cannot read NaN as a decimal.");
				}
				SetToken(JsonToken.Float, double.NaN);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing NaN value.");
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseInput && _reader != null)
			{
				_reader.Close();
			}
			if (_buffer != null)
			{
				_buffer.Clear();
			}
		}

		public bool HasLineInfo()
		{
			return true;
		}
	}
	public class JsonTextWriter : JsonWriter
	{
		private readonly TextWriter _writer;

		private Newtonsoft.Json.Utilities.Base64Encoder _base64Encoder;

		private char _indentChar;

		private int _indentation;

		private char _quoteChar;

		private bool _quoteName;

		private bool[] _charEscapeFlags;

		private char[] _writeBuffer;

		private char[] _indentChars;

		private Newtonsoft.Json.Utilities.Base64Encoder Base64Encoder
		{
			get
			{
				if (_base64Encoder == null)
				{
					_base64Encoder = new Newtonsoft.Json.Utilities.Base64Encoder(_writer);
				}
				return _base64Encoder;
			}
		}

		public int Indentation
		{
			get
			{
				return _indentation;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("Indentation value must be greater than 0.");
				}
				_indentation = value;
			}
		}

		public char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			set
			{
				if (value != '"' && value != '\'')
				{
					throw new ArgumentException("Invalid JavaScript string quote character. Valid quote characters are ' and \".");
				}
				_quoteChar = value;
				UpdateCharEscapeFlags();
			}
		}

		public char IndentChar
		{
			get
			{
				return _indentChar;
			}
			set
			{
				if (value != _indentChar)
				{
					_indentChar = value;
					_indentChars = null;
				}
			}
		}

		public bool QuoteName
		{
			get
			{
				return _quoteName;
			}
			set
			{
				_quoteName = value;
			}
		}

		public JsonTextWriter(TextWriter textWriter)
		{
			if (textWriter == null)
			{
				throw new ArgumentNullException("textWriter");
			}
			_writer = textWriter;
			_quoteChar = '"';
			_quoteName = true;
			_indentChar = ' ';
			_indentation = 2;
			UpdateCharEscapeFlags();
		}

		public override void Flush()
		{
			_writer.Flush();
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseOutput && _writer != null)
			{
				_writer.Close();
			}
		}

		public override void WriteStartObject()
		{
			InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
			_writer.Write('{');
		}

		public override void WriteStartArray()
		{
			InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
			_writer.Write('[');
		}

		public override void WriteStartConstructor(string name)
		{
			InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
			_writer.Write("new ");
			_writer.Write(name);
			_writer.Write('(');
		}

		protected override void WriteEnd(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.EndObject:
				_writer.Write('}');
				break;
			case JsonToken.EndArray:
				_writer.Write(']');
				break;
			case JsonToken.EndConstructor:
				_writer.Write(')');
				break;
			default:
				throw JsonWriterException.Create(this, "Invalid JsonToken: " + token, null);
			}
		}

		public override void WritePropertyName(string name)
		{
			InternalWritePropertyName(name);
			WriteEscapedString(name, _quoteName);
			_writer.Write(':');
		}

		public override void WritePropertyName(string name, bool escape)
		{
			InternalWritePropertyName(name);
			if (escape)
			{
				WriteEscapedString(name, _quoteName);
			}
			else
			{
				if (_quoteName)
				{
					_writer.Write(_quoteChar);
				}
				_writer.Write(name);
				if (_quoteName)
				{
					_writer.Write(_quoteChar);
				}
			}
			_writer.Write(':');
		}

		internal override void OnStringEscapeHandlingChanged()
		{
			UpdateCharEscapeFlags();
		}

		private void UpdateCharEscapeFlags()
		{
			_charEscapeFlags = Newtonsoft.Json.Utilities.JavaScriptUtils.GetCharEscapeFlags(base.StringEscapeHandling, _quoteChar);
		}

		protected override void WriteIndent()
		{
			_writer.WriteLine();
			int num = base.Top * _indentation;
			if (num > 0)
			{
				if (_indentChars == null)
				{
					_indentChars = new string(_indentChar, 10).ToCharArray();
				}
				while (num > 0)
				{
					int num2 = Math.Min(num, 10);
					_writer.Write(_indentChars, 0, num2);
					num -= num2;
				}
			}
		}

		protected override void WriteValueDelimiter()
		{
			_writer.Write(',');
		}

		protected override void WriteIndentSpace()
		{
			_writer.Write(' ');
		}

		private void WriteValueInternal(string value, JsonToken token)
		{
			_writer.Write(value);
		}

		public override void WriteNull()
		{
			InternalWriteValue(JsonToken.Null);
			WriteValueInternal(JsonConvert.Null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			InternalWriteValue(JsonToken.Undefined);
			WriteValueInternal(JsonConvert.Undefined, JsonToken.Undefined);
		}

		public override void WriteRaw(string json)
		{
			InternalWriteRaw();
			_writer.Write(json);
		}

		public override void WriteValue(string value)
		{
			InternalWriteValue(JsonToken.String);
			if (value == null)
			{
				WriteValueInternal(JsonConvert.Null, JsonToken.Null);
			}
			else
			{
				WriteEscapedString(value, quote: true);
			}
		}

		private void WriteEscapedString(string value, bool quote)
		{
			EnsureWriteBuffer();
			Newtonsoft.Json.Utilities.JavaScriptUtils.WriteEscapedJavaScriptString(_writer, value, _quoteChar, quote, _charEscapeFlags, base.StringEscapeHandling, ref _writeBuffer);
		}

		public override void WriteValue(int value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(uint value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(long value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(ulong value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(float value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
		}

		public override void WriteValue(float? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value.Value, base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
		}

		public override void WriteValue(double? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value.Value, base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			InternalWriteValue(JsonToken.Boolean);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(ushort value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue((int)value);
		}

		public override void WriteValue(char value)
		{
			InternalWriteValue(JsonToken.String);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.String);
		}

		public override void WriteValue(byte value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue((int)value);
		}

		public override void WriteValue(sbyte value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(decimal value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			InternalWriteValue(JsonToken.Date);
			value = Newtonsoft.Json.Utilities.DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			if (string.IsNullOrEmpty(base.DateFormatString))
			{
				EnsureWriteBuffer();
				int start = 0;
				_writeBuffer[start++] = _quoteChar;
				start = Newtonsoft.Json.Utilities.DateTimeUtils.WriteDateTimeString(_writeBuffer, start, value, null, value.Kind, base.DateFormatHandling);
				_writeBuffer[start++] = _quoteChar;
				_writer.Write(_writeBuffer, 0, start);
			}
			else
			{
				_writer.Write(_quoteChar);
				_writer.Write(value.ToString(base.DateFormatString, base.Culture));
				_writer.Write(_quoteChar);
			}
		}

		public override void WriteValue(byte[] value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Bytes);
			_writer.Write(_quoteChar);
			Base64Encoder.Encode(value, 0, value.Length);
			Base64Encoder.Flush();
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(Guid value)
		{
			InternalWriteValue(JsonToken.String);
			string text = null;
			text = value.ToString("D", CultureInfo.InvariantCulture);
			_writer.Write(_quoteChar);
			_writer.Write(text);
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(TimeSpan value)
		{
			InternalWriteValue(JsonToken.String);
			string value2 = value.ToString();
			_writer.Write(_quoteChar);
			_writer.Write(value2);
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(Uri value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.String);
			WriteEscapedString(value.OriginalString, quote: true);
		}

		public override void WriteComment(string text)
		{
			InternalWriteComment();
			_writer.Write("/*");
			_writer.Write(text);
			_writer.Write("*/");
		}

		public override void WriteWhitespace(string ws)
		{
			InternalWriteWhitespace(ws);
			_writer.Write(ws);
		}

		private void EnsureWriteBuffer()
		{
			if (_writeBuffer == null)
			{
				_writeBuffer = new char[35];
			}
		}

		private void WriteIntegerValue(long value)
		{
			if (value >= 0 && value <= 9)
			{
				_writer.Write((char)(48 + value));
				return;
			}
			ulong uvalue = (ulong)((value >= 0) ? value : (-value));
			if (value < 0)
			{
				_writer.Write('-');
			}
			WriteIntegerValue(uvalue);
		}

		private void WriteIntegerValue(ulong uvalue)
		{
			if (uvalue <= 9)
			{
				_writer.Write((char)(48 + uvalue));
				return;
			}
			EnsureWriteBuffer();
			int num = Newtonsoft.Json.Utilities.MathUtils.IntLength(uvalue);
			int num2 = 0;
			do
			{
				_writeBuffer[num - ++num2] = (char)(48 + uvalue % 10);
				uvalue /= 10;
			}
			while (uvalue != 0);
			_writer.Write(_writeBuffer, 0, num2);
		}
	}
	public enum JsonToken
	{
		None,
		StartObject,
		StartArray,
		StartConstructor,
		PropertyName,
		Comment,
		Raw,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		EndObject,
		EndArray,
		EndConstructor,
		Date,
		Bytes
	}
	public abstract class JsonWriter : IDisposable
	{
		internal enum State
		{
			Start,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			ConstructorStart,
			Constructor,
			Closed,
			Error
		}

		private static readonly State[][] StateArray;

		internal static readonly State[][] StateArrayTempate;

		private readonly List<JsonPosition> _stack;

		private JsonPosition _currentPosition;

		private State _currentState;

		private Formatting _formatting;

		private DateFormatHandling _dateFormatHandling;

		private DateTimeZoneHandling _dateTimeZoneHandling;

		private StringEscapeHandling _stringEscapeHandling;

		private FloatFormatHandling _floatFormatHandling;

		private string _dateFormatString;

		private CultureInfo _culture;

		public bool CloseOutput { get; set; }

		protected internal int Top
		{
			get
			{
				int num = _stack.Count;
				if (Peek() != 0)
				{
					num++;
				}
				return num;
			}
		}

		public WriteState WriteState
		{
			get
			{
				switch (_currentState)
				{
				case State.Error:
					return WriteState.Error;
				case State.Closed:
					return WriteState.Closed;
				case State.ObjectStart:
				case State.Object:
					return WriteState.Object;
				case State.ArrayStart:
				case State.Array:
					return WriteState.Array;
				case State.ConstructorStart:
				case State.Constructor:
					return WriteState.Constructor;
				case State.Property:
					return WriteState.Property;
				case State.Start:
					return WriteState.Start;
				default:
					throw JsonWriterException.Create(this, "Invalid state: " + _currentState, null);
				}
			}
		}

		internal string ContainerPath
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None)
				{
					return string.Empty;
				}
				return JsonPosition.BuildPath(_stack);
			}
		}

		public string Path
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None)
				{
					return string.Empty;
				}
				IEnumerable<JsonPosition> positions = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Concat(_stack, new JsonPosition[1] { _currentPosition }) : _stack);
				return JsonPosition.BuildPath(positions);
			}
		}

		public Formatting Formatting
		{
			get
			{
				return _formatting;
			}
			set
			{
				_formatting = value;
			}
		}

		public DateFormatHandling DateFormatHandling
		{
			get
			{
				return _dateFormatHandling;
			}
			set
			{
				_dateFormatHandling = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _stringEscapeHandling;
			}
			set
			{
				_stringEscapeHandling = value;
				OnStringEscapeHandlingChanged();
			}
		}

		public FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _floatFormatHandling;
			}
			set
			{
				_floatFormatHandling = value;
			}
		}

		public string DateFormatString
		{
			get
			{
				return _dateFormatString;
			}
			set
			{
				_dateFormatString = value;
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.InvariantCulture;
			}
			set
			{
				_culture = value;
			}
		}

		static JsonWriter()
		{
			StateArrayTempate = new State[8][]
			{
				new State[10]
				{
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ObjectStart,
					State.ObjectStart,
					State.Error,
					State.Error,
					State.ObjectStart,
					State.ObjectStart,
					State.ObjectStart,
					State.ObjectStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ArrayStart,
					State.ArrayStart,
					State.Error,
					State.Error,
					State.ArrayStart,
					State.ArrayStart,
					State.ArrayStart,
					State.ArrayStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ConstructorStart,
					State.ConstructorStart,
					State.Error,
					State.Error,
					State.ConstructorStart,
					State.ConstructorStart,
					State.ConstructorStart,
					State.ConstructorStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Property,
					State.Error,
					State.Property,
					State.Property,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Property,
					State.ObjectStart,
					State.Object,
					State.ArrayStart,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Property,
					State.ObjectStart,
					State.Object,
					State.ArrayStart,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Object,
					State.Error,
					State.Error,
					State.Array,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				}
			};
			StateArray = BuildStateArray();
		}

		protected JsonWriter()
		{
			_stack = new List<JsonPosition>(4);
			_currentState = State.Start;
			_formatting = Formatting.None;
			_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
			CloseOutput = true;
		}

		internal static State[][] BuildStateArray()
		{
			List<State[]> list = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(StateArrayTempate);
			State[] item = StateArrayTempate[0];
			State[] item2 = StateArrayTempate[7];
			foreach (JsonToken value in Newtonsoft.Json.Utilities.EnumUtils.GetValues(typeof(JsonToken)))
			{
				if (list.Count <= (int)value)
				{
					switch (value)
					{
					case JsonToken.Integer:
					case JsonToken.Float:
					case JsonToken.String:
					case JsonToken.Boolean:
					case JsonToken.Null:
					case JsonToken.Undefined:
					case JsonToken.Date:
					case JsonToken.Bytes:
						list.Add(item2);
						break;
					default:
						list.Add(item);
						break;
					}
				}
			}
			return list.ToArray();
		}

		internal virtual void OnStringEscapeHandlingChanged()
		{
		}

		internal void UpdateScopeWithFinishedValue()
		{
			if (_currentPosition.HasIndex)
			{
				_currentPosition.Position++;
			}
		}

		private void Push(JsonContainerType value)
		{
			if (_currentPosition.Type != 0)
			{
				_stack.Add(_currentPosition);
			}
			_currentPosition = new JsonPosition(value);
		}

		private JsonContainerType Pop()
		{
			JsonPosition currentPosition = _currentPosition;
			if (_stack.Count > 0)
			{
				_currentPosition = _stack[_stack.Count - 1];
				_stack.RemoveAt(_stack.Count - 1);
			}
			else
			{
				_currentPosition = default(JsonPosition);
			}
			return currentPosition.Type;
		}

		private JsonContainerType Peek()
		{
			return _currentPosition.Type;
		}

		public abstract void Flush();

		public virtual void Close()
		{
			AutoCompleteAll();
		}

		public virtual void WriteStartObject()
		{
			InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
		}

		public virtual void WriteEndObject()
		{
			InternalWriteEnd(JsonContainerType.Object);
		}

		public virtual void WriteStartArray()
		{
			InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
		}

		public virtual void WriteEndArray()
		{
			InternalWriteEnd(JsonContainerType.Array);
		}

		public virtual void WriteStartConstructor(string name)
		{
			InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
		}

		public virtual void WriteEndConstructor()
		{
			InternalWriteEnd(JsonContainerType.Constructor);
		}

		public virtual void WritePropertyName(string name)
		{
			InternalWritePropertyName(name);
		}

		public virtual void WritePropertyName(string name, bool escape)
		{
			WritePropertyName(name);
		}

		public virtual void WriteEnd()
		{
			WriteEnd(Peek());
		}

		public void WriteToken(JsonReader reader)
		{
			WriteToken(reader, writeChildren: true, writeDateConstructorAsDate: true);
		}

		public void WriteToken(JsonReader reader, bool writeChildren)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			WriteToken(reader, writeChildren, writeDateConstructorAsDate: true);
		}

		public void WriteToken(JsonToken token, object value)
		{
			WriteTokenInternal(token, value);
		}

		public void WriteToken(JsonToken token)
		{
			WriteTokenInternal(token, null);
		}

		internal void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate)
		{
			int initialDepth = ((reader.TokenType == JsonToken.None) ? (-1) : (JsonTokenUtils.IsStartToken(reader.TokenType) ? reader.Depth : (reader.Depth + 1)));
			WriteToken(reader, initialDepth, writeChildren, writeDateConstructorAsDate);
		}

		internal void WriteToken(JsonReader reader, int initialDepth, bool writeChildren, bool writeDateConstructorAsDate)
		{
			do
			{
				if (writeDateConstructorAsDate && reader.TokenType == JsonToken.StartConstructor && string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
				{
					WriteConstructorDate(reader);
				}
				else
				{
					WriteTokenInternal(reader.TokenType, reader.Value);
				}
			}
			while (initialDepth - 1 < reader.Depth - (JsonTokenUtils.IsEndToken(reader.TokenType) ? 1 : 0) && writeChildren && reader.Read());
		}

		private void WriteTokenInternal(JsonToken tokenType, object value)
		{
			switch (tokenType)
			{
			case JsonToken.None:
				break;
			case JsonToken.StartObject:
				WriteStartObject();
				break;
			case JsonToken.StartArray:
				WriteStartArray();
				break;
			case JsonToken.StartConstructor:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				WriteStartConstructor(value.ToString());
				break;
			case JsonToken.PropertyName:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				WritePropertyName(value.ToString());
				break;
			case JsonToken.Comment:
				WriteComment(value?.ToString());
				break;
			case JsonToken.Integer:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(Convert.ToInt64(value, CultureInfo.InvariantCulture));
				break;
			case JsonToken.Float:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				if (value is decimal)
				{
					WriteValue((decimal)value);
				}
				else if (value is double)
				{
					WriteValue((double)value);
				}
				else if (value is float)
				{
					WriteValue((float)value);
				}
				else
				{
					WriteValue(Convert.ToDouble(value, CultureInfo.InvariantCulture));
				}
				break;
			case JsonToken.String:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(value.ToString());
				break;
			case JsonToken.Boolean:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(Convert.ToBoolean(value, CultureInfo.InvariantCulture));
				break;
			case JsonToken.Null:
				WriteNull();
				break;
			case JsonToken.Undefined:
				WriteUndefined();
				break;
			case JsonToken.EndObject:
				WriteEndObject();
				break;
			case JsonToken.EndArray:
				WriteEndArray();
				break;
			case JsonToken.EndConstructor:
				WriteEndConstructor();
				break;
			case JsonToken.Date:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(Convert.ToDateTime(value, CultureInfo.InvariantCulture));
				break;
			case JsonToken.Raw:
				WriteRawValue(value?.ToString());
				break;
			case JsonToken.Bytes:
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
				if (value is Guid)
				{
					WriteValue((Guid)value);
				}
				else
				{
					WriteValue((byte[])value);
				}
				break;
			default:
				throw Newtonsoft.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", tokenType, "Unexpected token type.");
			}
		}

		private void WriteConstructorDate(JsonReader reader)
		{
			if (!reader.Read())
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
			}
			if (reader.TokenType != JsonToken.Integer)
			{
				throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected Integer, got " + reader.TokenType, null);
			}
			long javaScriptTicks = (long)reader.Value;
			DateTime value = Newtonsoft.Json.Utilities.DateTimeUtils.ConvertJavaScriptTicksToDateTime(javaScriptTicks);
			if (!reader.Read())
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
			}
			if (reader.TokenType != JsonToken.EndConstructor)
			{
				throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected EndConstructor, got " + reader.TokenType, null);
			}
			WriteValue(value);
		}

		private void WriteEnd(JsonContainerType type)
		{
			switch (type)
			{
			case JsonContainerType.Object:
				WriteEndObject();
				break;
			case JsonContainerType.Array:
				WriteEndArray();
				break;
			case JsonContainerType.Constructor:
				WriteEndConstructor();
				break;
			default:
				throw JsonWriterException.Create(this, "Unexpected type when writing end: " + type, null);
			}
		}

		private void AutoCompleteAll()
		{
			while (Top > 0)
			{
				WriteEnd();
			}
		}

		private JsonToken GetCloseTokenForType(JsonContainerType type)
		{
			return type switch
			{
				JsonContainerType.Object => JsonToken.EndObject, 
				JsonContainerType.Array => JsonToken.EndArray, 
				JsonContainerType.Constructor => JsonToken.EndConstructor, 
				_ => throw JsonWriterException.Create(this, "No close token for type: " + type, null), 
			};
		}

		private void AutoCompleteClose(JsonContainerType type)
		{
			int num = 0;
			if (_currentPosition.Type == type)
			{
				num = 1;
			}
			else
			{
				int num2 = Top - 2;
				for (int num3 = num2; num3 >= 0; num3--)
				{
					int index = num2 - num3;
					if (_stack[index].Type == type)
					{
						num = num3 + 2;
						break;
					}
				}
			}
			if (num == 0)
			{
				throw JsonWriterException.Create(this, "No token to close.", null);
			}
			for (int i = 0; i < num; i++)
			{
				JsonToken closeTokenForType = GetCloseTokenForType(Pop());
				if (_currentState == State.Property)
				{
					WriteNull();
				}
				if (_formatting == Formatting.Indented && _currentState != State.ObjectStart && _currentState != State.ArrayStart)
				{
					WriteIndent();
				}
				WriteEnd(closeTokenForType);
				JsonContainerType jsonContainerType = Peek();
				switch (jsonContainerType)
				{
				case JsonContainerType.Object:
					_currentState = State.Object;
					break;
				case JsonContainerType.Array:
					_currentState = State.Array;
					break;
				case JsonContainerType.Constructor:
					_currentState = State.Array;
					break;
				case JsonContainerType.None:
					_currentState = State.Start;
					break;
				default:
					throw JsonWriterException.Create(this, "Unknown JsonType: " + jsonContainerType, null);
				}
			}
		}

		protected virtual void WriteEnd(JsonToken token)
		{
		}

		protected virtual void WriteIndent()
		{
		}

		protected virtual void WriteValueDelimiter()
		{
		}

		protected virtual void WriteIndentSpace()
		{
		}

		internal void AutoComplete(JsonToken tokenBeingWritten)
		{
			State state = StateArray[(int)tokenBeingWritten][(int)_currentState];
			if (state == State.Error)
			{
				throw JsonWriterException.Create(this, "Token {0} in state {1} would result in an invalid JSON object.".FormatWith(CultureInfo.InvariantCulture, tokenBeingWritten.ToString(), _currentState.ToString()), null);
			}
			if ((_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment)
			{
				WriteValueDelimiter();
			}
			if (_formatting == Formatting.Indented)
			{
				if (_currentState == State.Property)
				{
					WriteIndentSpace();
				}
				if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.Constructor || _currentState == State.ConstructorStart || (tokenBeingWritten == JsonToken.PropertyName && _currentState != 0))
				{
					WriteIndent();
				}
			}
			_currentState = state;
		}

		public virtual void WriteNull()
		{
			InternalWriteValue(JsonToken.Null);
		}

		public virtual void WriteUndefined()
		{
			InternalWriteValue(JsonToken.Undefined);
		}

		public virtual void WriteRaw(string json)
		{
			InternalWriteRaw();
		}

		public virtual void WriteRawValue(string json)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(JsonToken.Undefined);
			WriteRaw(json);
		}

		public virtual void WriteValue(string value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(int value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(uint value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(long value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(ulong value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(float value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(double value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(bool value)
		{
			InternalWriteValue(JsonToken.Boolean);
		}

		public virtual void WriteValue(short value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(ushort value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(char value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(byte value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(sbyte value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(decimal value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(DateTime value)
		{
			InternalWriteValue(JsonToken.Date);
		}

		public virtual void WriteValue(Guid value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(TimeSpan value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(int? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(uint? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(long? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(ulong? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(float? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(double? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(bool? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(short? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(ushort? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(char? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(byte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(sbyte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(decimal? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(DateTime? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(Guid? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(TimeSpan? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.Value);
			}
		}

		public virtual void WriteValue(byte[] value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				InternalWriteValue(JsonToken.Bytes);
			}
		}

		public virtual void WriteValue(Uri value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				InternalWriteValue(JsonToken.String);
			}
		}

		public virtual void WriteValue(object value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				WriteValue(this, Newtonsoft.Json.Utilities.ConvertUtils.GetTypeCode(value.GetType()), value);
			}
		}

		public virtual void WriteComment(string text)
		{
			InternalWriteComment();
		}

		public virtual void WriteWhitespace(string ws)
		{
			InternalWriteWhitespace(ws);
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (_currentState != State.Closed)
			{
				Close();
			}
		}

		internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value)
		{
			switch (typeCode)
			{
			case PrimitiveTypeCode.Char:
				writer.WriteValue((char)value);
				return;
			case PrimitiveTypeCode.CharNullable:
				writer.WriteValue((char?)value);
				return;
			case PrimitiveTypeCode.Boolean:
				writer.WriteValue((bool)value);
				return;
			case PrimitiveTypeCode.BooleanNullable:
				writer.WriteValue((bool?)value);
				return;
			case PrimitiveTypeCode.SByte:
				writer.WriteValue((sbyte)value);
				return;
			case PrimitiveTypeCode.SByteNullable:
				writer.WriteValue((sbyte?)value);
				return;
			case PrimitiveTypeCode.Int16:
				writer.WriteValue((short)value);
				return;
			case PrimitiveTypeCode.Int16Nullable:
				writer.WriteValue((short?)value);
				return;
			case PrimitiveTypeCode.UInt16:
				writer.WriteValue((ushort)value);
				return;
			case PrimitiveTypeCode.UInt16Nullable:
				writer.WriteValue((ushort?)value);
				return;
			case PrimitiveTypeCode.Int32:
				writer.WriteValue((int)value);
				return;
			case PrimitiveTypeCode.Int32Nullable:
				writer.WriteValue((int?)value);
				return;
			case PrimitiveTypeCode.Byte:
				writer.WriteValue((byte)value);
				return;
			case PrimitiveTypeCode.ByteNullable:
				writer.WriteValue((byte?)value);
				return;
			case PrimitiveTypeCode.UInt32:
				writer.WriteValue((uint)value);
				return;
			case PrimitiveTypeCode.UInt32Nullable:
				writer.WriteValue((uint?)value);
				return;
			case PrimitiveTypeCode.Int64:
				writer.WriteValue((long)value);
				return;
			case PrimitiveTypeCode.Int64Nullable:
				writer.WriteValue((long?)value);
				return;
			case PrimitiveTypeCode.UInt64:
				writer.WriteValue((ulong)value);
				return;
			case PrimitiveTypeCode.UInt64Nullable:
				writer.WriteValue((ulong?)value);
				return;
			case PrimitiveTypeCode.Single:
				writer.WriteValue((float)value);
				return;
			case PrimitiveTypeCode.SingleNullable:
				writer.WriteValue((float?)value);
				return;
			case PrimitiveTypeCode.Double:
				writer.WriteValue((double)value);
				return;
			case PrimitiveTypeCode.DoubleNullable:
				writer.WriteValue((double?)value);
				return;
			case PrimitiveTypeCode.DateTime:
				writer.WriteValue((DateTime)value);
				return;
			case PrimitiveTypeCode.DateTimeNullable:
				writer.WriteValue((DateTime?)value);
				return;
			case PrimitiveTypeCode.Decimal:
				writer.WriteValue((decimal)value);
				return;
			case PrimitiveTypeCode.DecimalNullable:
				writer.WriteValue((decimal?)value);
				return;
			case PrimitiveTypeCode.Guid:
				writer.WriteValue((Guid)value);
				return;
			case PrimitiveTypeCode.GuidNullable:
				writer.WriteValue((Guid?)value);
				return;
			case PrimitiveTypeCode.TimeSpan:
				writer.WriteValue((TimeSpan)value);
				return;
			case PrimitiveTypeCode.TimeSpanNullable:
				writer.WriteValue((TimeSpan?)value);
				return;
			case PrimitiveTypeCode.Uri:
				writer.WriteValue((Uri)value);
				return;
			case PrimitiveTypeCode.String:
				writer.WriteValue((string)value);
				return;
			case PrimitiveTypeCode.Bytes:
				writer.WriteValue((byte[])value);
				return;
			}
			if (value is IConvertible)
			{
				IConvertible convertible = (IConvertible)value;
				TypeInformation typeInformation = Newtonsoft.Json.Utilities.ConvertUtils.GetTypeInformation(convertible);
				PrimitiveTypeCode typeCode2 = ((typeInformation.TypeCode != PrimitiveTypeCode.Object) ? typeInformation.TypeCode : PrimitiveTypeCode.String);
				Type conversionType = ((typeInformation.TypeCode != PrimitiveTypeCode.Object) ? typeInformation.Type : typeof(string));
				object value2 = convertible.ToType(conversionType, CultureInfo.InvariantCulture);
				WriteValue(writer, typeCode2, value2);
				return;
			}
			throw CreateUnsupportedTypeException(writer, value);
		}

		private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value)
		{
			return JsonWriterException.Create(writer, "Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), null);
		}

		protected void SetWriteState(JsonToken token, object value)
		{
			switch (token)
			{
			case JsonToken.StartObject:
				InternalWriteStart(token, JsonContainerType.Object);
				break;
			case JsonToken.StartArray:
				InternalWriteStart(token, JsonContainerType.Array);
				break;
			case JsonToken.StartConstructor:
				InternalWriteStart(token, JsonContainerType.Constructor);
				break;
			case JsonToken.PropertyName:
				if (!(value is string))
				{
					throw new ArgumentException("A name is required when setting property name state.", "value");
				}
				InternalWritePropertyName((string)value);
				break;
			case JsonToken.Comment:
				InternalWriteComment();
				break;
			case JsonToken.Raw:
				InternalWriteRaw();
				break;
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				InternalWriteValue(token);
				break;
			case JsonToken.EndObject:
				InternalWriteEnd(JsonContainerType.Object);
				break;
			case JsonToken.EndArray:
				InternalWriteEnd(JsonContainerType.Array);
				break;
			case JsonToken.EndConstructor:
				InternalWriteEnd(JsonContainerType.Constructor);
				break;
			default:
				throw new ArgumentOutOfRangeException("token");
			}
		}

		internal void InternalWriteEnd(JsonContainerType container)
		{
			AutoCompleteClose(container);
		}

		internal void InternalWritePropertyName(string name)
		{
			_currentPosition.PropertyName = name;
			AutoComplete(JsonToken.PropertyName);
		}

		internal void InternalWriteRaw()
		{
		}

		internal void InternalWriteStart(JsonToken token, JsonContainerType container)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(token);
			Push(container);
		}

		internal void InternalWriteValue(JsonToken token)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(token);
		}

		internal void InternalWriteWhitespace(string ws)
		{
			if (ws != null && !Newtonsoft.Json.Utilities.StringUtils.IsWhiteSpace(ws))
			{
				throw JsonWriterException.Create(this, "Only white space characters should be used.", null);
			}
		}

		internal void InternalWriteComment()
		{
			AutoComplete(JsonToken.Comment);
		}
	}
	[Serializable]
	public class JsonWriterException : JsonException
	{
		public string Path { get; private set; }

		public JsonWriterException()
		{
		}

		public JsonWriterException(string message)
			: base(message)
		{
		}

		public JsonWriterException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonWriterException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal JsonWriterException(string message, Exception innerException, string path)
			: base(message, innerException)
		{
			Path = path;
		}

		internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex)
		{
			return Create(writer.ContainerPath, message, ex);
		}

		internal static JsonWriterException Create(string path, string message, Exception ex)
		{
			message = JsonPosition.FormatMessage(null, path, message);
			return new JsonWriterException(message, ex, path);
		}
	}
}
namespace Newtonsoft.Json.Linq
{
	public static class Extensions
	{
		public static IJEnumerable<JToken> Ancestors<T>(this IEnumerable<T> source) where T : JToken
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SelectMany(source, (T j) => j.Ancestors()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> AncestorsAndSelf<T>(this IEnumerable<T> source) where T : JToken
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SelectMany(source, (T j) => j.AncestorsAndSelf()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Descendants<T>(this IEnumerable<T> source) where T : JContainer
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SelectMany(source, (T j) => j.Descendants()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> DescendantsAndSelf<T>(this IEnumerable<T> source) where T : JContainer
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SelectMany(source, (T j) => j.DescendantsAndSelf()).AsJEnumerable();
		}

		public static IJEnumerable<JProperty> Properties(this IEnumerable<JObject> source)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SelectMany(source, (JObject d) => d.Properties()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source, object key)
		{
			return source.Values<JToken, JToken>(key).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source)
		{
			return source.Values(null);
		}

		public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source, object key)
		{
			return source.Values<JToken, U>(key);
		}

		public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source)
		{
			return source.Values<JToken, U>(null);
		}

		public static U Value<U>(this IEnumerable<JToken> value)
		{
			return value.Value<JToken, U>();
		}

		public static U Value<T, U>(this IEnumerable<T> value) where T : JToken
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "source");
			if (!(value is JToken token))
			{
				throw new ArgumentException("Source value must be a JToken.");
			}
			return token.Convert<JToken, U>();
		}

		internal static IEnumerable<U> Values<T, U>(this IEnumerable<T> source, object key) where T : JToken
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			foreach (T token in source)
			{
				if (key == null)
				{
					if (token is JValue)
					{
						yield return ((JValue)(object)token).Convert<JValue, U>();
						continue;
					}
					foreach (JToken t in token.Children())
					{
						yield return t.Convert<JToken, U>();
					}
				}
				else
				{
					JToken value = token[key];
					if (value != null)
					{
						yield return value.Convert<JToken, U>();
					}
				}
			}
		}

		public static IJEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
		{
			return source.Children<T, JToken>().AsJEnumerable();
		}

		public static IEnumerable<U> Children<T, U>(this IEnumerable<T> source) where T : JToken
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SelectMany(source, (T c) => c.Children()).Convert<JToken, U>();
		}

		internal static IEnumerable<U> Convert<T, U>(this IEnumerable<T> source) where T : JToken
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(source, "source");
			foreach (T token in source)
			{
				yield return token.Convert<JToken, U>();
			}
		}

		internal static U Convert<T, U>(this T token) where T : JToken
		{
			if (token == null)
			{
				return default(U);
			}
			if (token is U && typeof(U) != typeof(IComparable) && typeof(U) != typeof(IFormattable))
			{
				return (U)(object)token;
			}
			if (!(token is JValue jValue))
			{
				throw new InvalidCastException("Cannot cast {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, token.GetType(), typeof(T)));
			}
			if (jValue.Value is U)
			{
				return (U)jValue.Value;
			}
			Type type = typeof(U);
			if (Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(type))
			{
				if (jValue.Value == null)
				{
					return default(U);
				}
				type = Nullable.GetUnderlyingType(type);
			}
			return (U)System.Convert.ChangeType(jValue.Value, type, CultureInfo.InvariantCulture);
		}

		public static IJEnumerable<JToken> AsJEnumerable(this IEnumerable<JToken> source)
		{
			return source.AsJEnumerable<JToken>();
		}

		public static IJEnumerable<T> AsJEnumerable<T>(this IEnumerable<T> source) where T : JToken
		{
			if (source == null)
			{
				return null;
			}
			if (source is IJEnumerable<T>)
			{
				return (IJEnumerable<T>)source;
			}
			return new JEnumerable<T>(source);
		}
	}
	public interface IJEnumerable<T> : IEnumerable<T>, IEnumerable where T : JToken
	{
		IJEnumerable<JToken> this[object key] { get; }
	}
	public class JArray : JContainer, IList<JToken>, IEnumerable, ICollection<JToken>, IEnumerable<JToken>
	{
		private readonly List<JToken> _values = new List<JToken>();

		protected override IList<JToken> ChildrenTokens => _values;

		public override JTokenType Type => JTokenType.Array;

		public override JToken this[object key]
		{
			get
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException("Accessed JArray values with invalid key value: {0}. Array position index expected.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				return GetItem((int)key);
			}
			set
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException("Set JArray values with invalid key value: {0}. Array position index expected.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				SetItem((int)key, value);
			}
		}

		public JToken this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		public bool IsReadOnly => false;

		public JArray()
		{
		}

		public JArray(JArray other)
			: base(other)
		{
		}

		public JArray(params object[] content)
			: this((object)content)
		{
		}

		public JArray(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			return node is JArray container && ContentsEqual(container);
		}

		internal override JToken CloneToken()
		{
			return new JArray(this);
		}

		public new static JArray Load(JsonReader reader)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader.");
			}
			while (reader.TokenType == JsonToken.Comment)
			{
				reader.Read();
			}
			if (reader.TokenType != JsonToken.StartArray)
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JArray jArray = new JArray();
			jArray.SetLineInfo(reader as IJsonLineInfo);
			jArray.ReadTokenFrom(reader);
			return jArray;
		}

		public new static JArray Parse(string json)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JArray result = Load(jsonReader);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
			}
			return result;
		}

		public new static JArray FromObject(object o)
		{
			return FromObject(o, JsonSerializer.CreateDefault());
		}

		public new static JArray FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken.Type != JTokenType.Array)
			{
				throw new ArgumentException("Object serialized to {0}. JArray instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JArray)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartArray();
			for (int i = 0; i < _values.Count; i++)
			{
				_values[i].WriteTo(writer, converters);
			}
			writer.WriteEndArray();
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			IEnumerable enumerable = ((!IsMultiContent(content) && !(content is JArray)) ? null : ((IEnumerable)content));
			if (enumerable != null)
			{
				JContainer.MergeEnumerableContent(this, enumerable, settings);
			}
		}

		public int IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		public void Insert(int index, JToken item)
		{
			InsertItem(index, item, skipParentCheck: false);
		}

		public void RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		public IEnumerator<JToken> GetEnumerator()
		{
			return Children().GetEnumerator();
		}

		public void Add(JToken item)
		{
			Add((object)item);
		}

		public void Clear()
		{
			ClearItems();
		}

		public bool Contains(JToken item)
		{
			return ContainsItem(item);
		}

		public void CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		public bool Remove(JToken item)
		{
			return RemoveItem(item);
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}
	}
	public class JConstructor : JContainer
	{
		private string _name;

		private readonly List<JToken> _values = new List<JToken>();

		protected override IList<JToken> ChildrenTokens => _values;

		public string Name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public override JTokenType Type => JTokenType.Constructor;

		public override JToken this[object key]
		{
			get
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException("Accessed JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				return GetItem((int)key);
			}
			set
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is int))
				{
					throw new ArgumentException("Set JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				SetItem((int)key, value);
			}
		}

		public JConstructor()
		{
		}

		public JConstructor(JConstructor other)
			: base(other)
		{
			_name = other.Name;
		}

		public JConstructor(string name, params object[] content)
			: this(name, (object)content)
		{
		}

		public JConstructor(string name, object content)
			: this(name)
		{
			Add(content);
		}

		public JConstructor(string name)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNullOrEmpty(name, "name");
			_name = name;
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			if (content is JConstructor jConstructor)
			{
				if (jConstructor.Name != null)
				{
					Name = jConstructor.Name;
				}
				JContainer.MergeEnumerableContent(this, jConstructor, settings);
			}
		}

		internal override bool DeepEquals(JToken node)
		{
			return node is JConstructor jConstructor && _name == jConstructor.Name && ContentsEqual(jConstructor);
		}

		internal override JToken CloneToken()
		{
			return new JConstructor(this);
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartConstructor(_name);
			foreach (JToken item in Children())
			{
				item.WriteTo(writer, converters);
			}
			writer.WriteEndConstructor();
		}

		internal override int GetDeepHashCode()
		{
			return _name.GetHashCode() ^ ContentsHashCode();
		}

		public new static JConstructor Load(JsonReader reader)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader.");
			}
			while (reader.TokenType == JsonToken.Comment)
			{
				reader.Read();
			}
			if (reader.TokenType != JsonToken.StartConstructor)
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JConstructor jConstructor = new JConstructor((string)reader.Value);
			jConstructor.SetLineInfo(reader as IJsonLineInfo);
			jConstructor.ReadTokenFrom(reader);
			return jConstructor;
		}
	}
	public abstract class JContainer : JToken, IList<JToken>, ITypedList, IBindingList, IList, IEnumerable, ICollection<JToken>, IEnumerable<JToken>, ICollection
	{
		private class JTokenReferenceEqualityComparer : IEqualityComparer<JToken>
		{
			public static readonly JTokenReferenceEqualityComparer Instance = new JTokenReferenceEqualityComparer();

			public bool Equals(JToken x, JToken y)
			{
				return object.ReferenceEquals(x, y);
			}

			public int GetHashCode(JToken obj)
			{
				return obj?.GetHashCode() ?? 0;
			}
		}

		internal ListChangedEventHandler _listChanged;

		private object _syncRoot;

		private bool _busy;

		JToken IList<JToken>.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		bool ICollection<JToken>.IsReadOnly => false;

		bool IList.IsFixedSize => false;

		bool IList.IsReadOnly => false;

		object IList.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, EnsureValue(value));
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		bool IBindingList.AllowEdit => true;

		bool IBindingList.AllowNew => true;

		bool IBindingList.AllowRemove => true;

		bool IBindingList.IsSorted => false;

		ListSortDirection IBindingList.SortDirection => ListSortDirection.Ascending;

		PropertyDescriptor IBindingList.SortProperty => null;

		bool IBindingList.SupportsChangeNotification => true;

		bool IBindingList.SupportsSearching => false;

		bool IBindingList.SupportsSorting => false;

		protected abstract IList<JToken> ChildrenTokens { get; }

		public override bool HasValues => ChildrenTokens.Count > 0;

		public override JToken First => Newtonsoft.Json.Utilities.LinqBridge.Enumerable.FirstOrDefault(ChildrenTokens);

		public override JToken Last => Newtonsoft.Json.Utilities.LinqBridge.Enumerable.LastOrDefault(ChildrenTokens);

		public int Count => ChildrenTokens.Count;

		public event ListChangedEventHandler ListChanged
		{
			add
			{
				_listChanged = (ListChangedEventHandler)Delegate.Combine(_listChanged, value);
			}
			remove
			{
				_listChanged = (ListChangedEventHandler)Delegate.Remove(_listChanged, value);
			}
		}

		internal JContainer()
		{
		}

		internal JContainer(JContainer other)
			: this()
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(other, "c");
			int num = 0;
			foreach (JToken item in (IEnumerable<JToken>)other)
			{
				AddInternal(num, item, skipParentCheck: false);
				num++;
			}
		}

		internal void CheckReentrancy()
		{
			if (_busy)
			{
				throw new InvalidOperationException("Cannot change {0} during a collection change event.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		internal virtual IList<JToken> CreateChildrenCollection()
		{
			return new List<JToken>();
		}

		protected virtual void OnListChanged(ListChangedEventArgs e)
		{
			ListChangedEventHandler listChanged = _listChanged;
			if (listChanged != null)
			{
				_busy = true;
				try
				{
					listChanged(this, e);
				}
				finally
				{
					_busy = false;
				}
			}
		}

		internal bool ContentsEqual(JContainer container)
		{
			if (container == this)
			{
				return true;
			}
			IList<JToken> childrenTokens = ChildrenTokens;
			IList<JToken> childrenTokens2 = container.ChildrenTokens;
			if (childrenTokens.Count != childrenTokens2.Count)
			{
				return false;
			}
			for (int i = 0; i < childrenTokens.Count; i++)
			{
				if (!childrenTokens[i].DeepEquals(childrenTokens2[i]))
				{
					return false;
				}
			}
			return true;
		}

		public override JEnumerable<JToken> Children()
		{
			return new JEnumerable<JToken>(ChildrenTokens);
		}

		public override IEnumerable<T> Values<T>()
		{
			return ChildrenTokens.Convert<JToken, T>();
		}

		public IEnumerable<JToken> Descendants()
		{
			return GetDescendants(self: false);
		}

		public IEnumerable<JToken> DescendantsAndSelf()
		{
			return GetDescendants(self: true);
		}

		internal IEnumerable<JToken> GetDescendants(bool self)
		{
			if (self)
			{
				yield return this;
			}
			foreach (JToken o in ChildrenTokens)
			{
				yield return o;
				if (!(o is JContainer c))
				{
					continue;
				}
				foreach (JToken item in c.Descendants())
				{
					yield return item;
				}
			}
		}

		internal bool IsMultiContent(object content)
		{
			return content is IEnumerable && !(content is string) && !(content is JToken) && !(content is byte[]);
		}

		internal JToken EnsureParentToken(JToken item, bool skipParentCheck)
		{
			if (item == null)
			{
				return JValue.CreateNull();
			}
			if (skipParentCheck)
			{
				return item;
			}
			if (item.Parent != null || item == this || (item.HasValues && base.Root == item))
			{
				item = item.CloneToken();
			}
			return item;
		}

		internal int IndexOfItem(JToken item)
		{
			return Newtonsoft.Json.Utilities.CollectionUtils.IndexOf(ChildrenTokens, item, JTokenReferenceEqualityComparer.Instance);
		}

		internal virtual void InsertItem(int index, JToken item, bool skipParentCheck)
		{
			if (index > ChildrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index must be within the bounds of the List.");
			}
			CheckReentrancy();
			item = EnsureParentToken(item, skipParentCheck);
			JToken jToken = ((index != 0) ? ChildrenTokens[index - 1] : null);
			JToken jToken2 = ((index != ChildrenTokens.Count) ? ChildrenTokens[index] : null);
			ValidateToken(item, null);
			item.Parent = this;
			item.Previous = jToken;
			if (jToken != null)
			{
				jToken.Next = item;
			}
			item.Next = jToken2;
			if (jToken2 != null)
			{
				jToken2.Previous = item;
			}
			ChildrenTokens.Insert(index, item);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));
			}
		}

		internal virtual void RemoveItemAt(int index)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= ChildrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			CheckReentrancy();
			JToken jToken = ChildrenTokens[index];
			JToken jToken2 = ((index != 0) ? ChildrenTokens[index - 1] : null);
			JToken jToken3 = ((index != ChildrenTokens.Count - 1) ? ChildrenTokens[index + 1] : null);
			if (jToken2 != null)
			{
				jToken2.Next = jToken3;
			}
			if (jToken3 != null)
			{
				jToken3.Previous = jToken2;
			}
			jToken.Parent = null;
			jToken.Previous = null;
			jToken.Next = null;
			ChildrenTokens.RemoveAt(index);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
			}
		}

		internal virtual bool RemoveItem(JToken item)
		{
			int num = IndexOfItem(item);
			if (num >= 0)
			{
				RemoveItemAt(num);
				return true;
			}
			return false;
		}

		internal virtual JToken GetItem(int index)
		{
			return ChildrenTokens[index];
		}

		internal virtual void SetItem(int index, JToken item)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= ChildrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			JToken jToken = ChildrenTokens[index];
			if (!IsTokenUnchanged(jToken, item))
			{
				CheckReentrancy();
				item = EnsureParentToken(item, skipParentCheck: false);
				ValidateToken(item, jToken);
				JToken jToken2 = ((index != 0) ? ChildrenTokens[index - 1] : null);
				JToken jToken3 = ((index != ChildrenTokens.Count - 1) ? ChildrenTokens[index + 1] : null);
				item.Parent = this;
				item.Previous = jToken2;
				if (jToken2 != null)
				{
					jToken2.Next = item;
				}
				item.Next = jToken3;
				if (jToken3 != null)
				{
					jToken3.Previous = item;
				}
				ChildrenTokens[index] = item;
				jToken.Parent = null;
				jToken.Previous = null;
				jToken.Next = null;
				if (_listChanged != null)
				{
					OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
				}
			}
		}

		internal virtual void ClearItems()
		{
			CheckReentrancy();
			foreach (JToken childrenToken in ChildrenTokens)
			{
				childrenToken.Parent = null;
				childrenToken.Previous = null;
				childrenToken.Next = null;
			}
			ChildrenTokens.Clear();
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
			}
		}

		internal virtual void ReplaceItem(JToken existing, JToken replacement)
		{
			if (existing != null && existing.Parent == this)
			{
				int index = IndexOfItem(existing);
				SetItem(index, replacement);
			}
		}

		internal virtual bool ContainsItem(JToken item)
		{
			return IndexOfItem(item) != -1;
		}

		internal virtual void CopyItemsTo(Array array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length && arrayIndex != 0)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				array.SetValue(childrenToken, arrayIndex + num);
				num++;
			}
		}

		internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue)
		{
			if (currentValue is JValue jValue)
			{
				if (jValue.Type == JTokenType.Null && newValue == null)
				{
					return true;
				}
				return jValue.Equals(newValue);
			}
			return false;
		}

		internal virtual void ValidateToken(JToken o, JToken existing)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type == JTokenType.Property)
			{
				throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
		}

		public virtual void Add(object content)
		{
			AddInternal(ChildrenTokens.Count, content, skipParentCheck: false);
		}

		internal void AddAndSkipParentCheck(JToken token)
		{
			AddInternal(ChildrenTokens.Count, token, skipParentCheck: true);
		}

		public void AddFirst(object content)
		{
			AddInternal(0, content, skipParentCheck: false);
		}

		internal void AddInternal(int index, object content, bool skipParentCheck)
		{
			if (IsMultiContent(content))
			{
				IEnumerable enumerable = (IEnumerable)content;
				int num = index;
				{
					foreach (object item2 in enumerable)
					{
						AddInternal(num, item2, skipParentCheck);
						num++;
					}
					return;
				}
			}
			JToken item = CreateFromContent(content);
			InsertItem(index, item, skipParentCheck);
		}

		internal static JToken CreateFromContent(object content)
		{
			if (content is JToken)
			{
				return (JToken)content;
			}
			return new JValue(content);
		}

		public JsonWriter CreateWriter()
		{
			return new JTokenWriter(this);
		}

		public void ReplaceAll(object content)
		{
			ClearItems();
			Add(content);
		}

		public void RemoveAll()
		{
			ClearItems();
		}

		internal abstract void MergeItem(object content, JsonMergeSettings settings);

		public void Merge(object content)
		{
			MergeItem(content, new JsonMergeSettings());
		}

		public void Merge(object content, JsonMergeSettings settings)
		{
			MergeItem(content, settings);
		}

		internal void ReadTokenFrom(JsonReader reader)
		{
			int depth = reader.Depth;
			if (!reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading {0} from JsonReader.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
			ReadContentFrom(reader);
			int depth2 = reader.Depth;
			if (depth2 > depth)
			{
				throw JsonReaderException.Create(reader, "Unexpected end of content while loading {0}.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
		}

		internal void ReadContentFrom(JsonReader r)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(r, "r");
			IJsonLineInfo lineInfo = r as IJsonLineInfo;
			JContainer jContainer = this;
			do
			{
				if (jContainer is JProperty && ((JProperty)jContainer).Value != null)
				{
					if (jContainer == this)
					{
						break;
					}
					jContainer = jContainer.Parent;
				}
				switch (r.TokenType)
				{
				case JsonToken.StartArray:
				{
					JArray jArray = new JArray();
					jArray.SetLineInfo(lineInfo);
					jContainer.Add(jArray);
					jContainer = jArray;
					break;
				}
				case JsonToken.EndArray:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartObject:
				{
					JObject jObject2 = new JObject();
					jObject2.SetLineInfo(lineInfo);
					jContainer.Add(jObject2);
					jContainer = jObject2;
					break;
				}
				case JsonToken.EndObject:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartConstructor:
				{
					JConstructor jConstructor = new JConstructor(r.Value.ToString());
					jConstructor.SetLineInfo(lineInfo);
					jContainer.Add(jConstructor);
					jContainer = jConstructor;
					break;
				}
				case JsonToken.EndConstructor:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
				{
					JValue jValue = new JValue(r.Value);
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Comment:
				{
					JValue jValue = JValue.CreateComment(r.Value.ToString());
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Null:
				{
					JValue jValue = JValue.CreateNull();
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Undefined:
				{
					JValue jValue = JValue.CreateUndefined();
					jValue.SetLineInfo(lineInfo);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.PropertyName:
				{
					string name = r.Value.ToString();
					JProperty jProperty = new JProperty(name);
					jProperty.SetLineInfo(lineInfo);
					JObject jObject = (JObject)jContainer;
					JProperty jProperty2 = jObject.Property(name);
					if (jProperty2 == null)
					{
						jContainer.Add(jProperty);
					}
					else
					{
						jProperty2.Replace(jProperty);
					}
					jContainer = jProperty;
					break;
				}
				default:
					throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith(CultureInfo.InvariantCulture, r.TokenType));
				case JsonToken.None:
					break;
				}
			}
			while (r.Read());
		}

		internal int ContentsHashCode()
		{
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				num ^= childrenToken.GetDeepHashCode();
			}
			return num;
		}

		string ITypedList.GetListName(PropertyDescriptor[] listAccessors)
		{
			return string.Empty;
		}

		PropertyDescriptorCollection ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
		{
			if (First is ICustomTypeDescriptor customTypeDescriptor)
			{
				return customTypeDescriptor.GetProperties();
			}
			return null;
		}

		int IList<JToken>.IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		void IList<JToken>.Insert(int index, JToken item)
		{
			InsertItem(index, item, skipParentCheck: false);
		}

		void IList<JToken>.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection<JToken>.Add(JToken item)
		{
			Add(item);
		}

		void ICollection<JToken>.Clear()
		{
			ClearItems();
		}

		bool ICollection<JToken>.Contains(JToken item)
		{
			return ContainsItem(item);
		}

		void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		bool ICollection<JToken>.Remove(JToken item)
		{
			return RemoveItem(item);
		}

		private JToken EnsureValue(object value)
		{
			if (value == null)
			{
				return null;
			}
			if (value is JToken)
			{
				return (JToken)value;
			}
			throw new ArgumentException("Argument is not a JToken.");
		}

		int IList.Add(object value)
		{
			Add(EnsureValue(value));
			return Count - 1;
		}

		void IList.Clear()
		{
			ClearItems();
		}

		bool IList.Contains(object value)
		{
			return ContainsItem(EnsureValue(value));
		}

		int IList.IndexOf(object value)
		{
			return IndexOfItem(EnsureValue(value));
		}

		void IList.Insert(int index, object value)
		{
			InsertItem(index, EnsureValue(value), skipParentCheck: false);
		}

		void IList.Remove(object value)
		{
			RemoveItem(EnsureValue(value));
		}

		void IList.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			CopyItemsTo(array, index);
		}

		void IBindingList.AddIndex(PropertyDescriptor property)
		{
		}

		object IBindingList.AddNew()
		{
			return null;
		}

		void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
		{
			throw new NotSupportedException();
		}

		int IBindingList.Find(PropertyDescriptor property, object key)
		{
			throw new NotSupportedException();
		}

		void IBindingList.RemoveIndex(PropertyDescriptor property)
		{
		}

		void IBindingList.RemoveSort()
		{
			throw new NotSupportedException();
		}

		internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings)
		{
			switch (settings.MergeArrayHandling)
			{
			case MergeArrayHandling.Concat:
			{
				foreach (JToken item in content)
				{
					target.Add(item);
				}
				break;
			}
			case MergeArrayHandling.Union:
			{
				IDictionary<JToken, bool> dictionary = new Dictionary<JToken, bool>(JToken.EqualityComparer);
				foreach (JToken item2 in (IEnumerable<JToken>)target)
				{
					dictionary[item2] = true;
				}
				{
					foreach (JToken item3 in content)
					{
						if (!dictionary.ContainsKey(item3))
						{
							dictionary[item3] = true;
							target.Add(item3);
						}
					}
					break;
				}
			}
			case MergeArrayHandling.Replace:
				target.ClearItems();
				{
					foreach (JToken item4 in content)
					{
						target.Add(item4);
					}
					break;
				}
			case MergeArrayHandling.Merge:
			{
				int num = 0;
				{
					foreach (object item5 in content)
					{
						if (num < target.Count)
						{
							JToken jToken = target[num];
							if (jToken is JContainer jContainer)
							{
								jContainer.Merge(item5, settings);
							}
							else if (item5 != null)
							{
								JToken jToken2 = CreateFromContent(item5);
								if (jToken2.Type != JTokenType.Null)
								{
									target[num] = jToken2;
								}
							}
						}
						else
						{
							target.Add(item5);
						}
						num++;
					}
					break;
				}
			}
			default:
				throw new ArgumentOutOfRangeException("settings", "Unexpected merge array handling when merging JSON.");
			}
		}
	}
	public struct JEnumerable<T> : IJEnumerable<T>, IEquatable<JEnumerable<T>>, IEnumerable<T>, IEnumerable where T : JToken
	{
		public static readonly JEnumerable<T> Empty = new JEnumerable<T>(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Empty<T>());

		private readonly IEnumerable<T> _enumerable;

		public IJEnumerable<JToken> this[object key]
		{
			get
			{
				if (_enumerable == null)
				{
					return JEnumerable<JToken>.Empty;
				}
				return new JEnumerable<JToken>(_enumerable.Values<T, JToken>(key));
			}
		}

		public JEnumerable(IEnumerable<T> enumerable)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(enumerable, "enumerable");
			_enumerable = enumerable;
		}

		public IEnumerator<T> GetEnumerator()
		{
			if (_enumerable == null)
			{
				return Empty.GetEnumerator();
			}
			return _enumerable.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public bool Equals(JEnumerable<T> other)
		{
			return object.Equals(_enumerable, other._enumerable);
		}

		public override bool Equals(object obj)
		{
			if (obj is JEnumerable<T>)
			{
				return Equals((JEnumerable<T>)obj);
			}
			return false;
		}

		public override int GetHashCode()
		{
			if (_enumerable == null)
			{
				return 0;
			}
			return _enumerable.GetHashCode();
		}
	}
	public class JObject : JContainer, IDictionary<string, JToken>, INotifyPropertyChanged, ICustomTypeDescriptor, IEnumerable, ICollection<KeyValuePair<string, JToken>>, IEnumerable<KeyValuePair<string, JToken>>
	{
		private readonly JPropertyKeyedCollection _properties = new JPropertyKeyedCollection();

		ICollection<string> IDictionary<string, JToken>.Keys => _properties.Keys;

		ICollection<JToken> IDictionary<string, JToken>.Values
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		bool ICollection<KeyValuePair<string, JToken>>.IsReadOnly => false;

		protected override IList<JToken> ChildrenTokens => _properties;

		public override JTokenType Type => JTokenType.Object;

		public override JToken this[object key]
		{
			get
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is string propertyName))
				{
					throw new ArgumentException("Accessed JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				return this[propertyName];
			}
			set
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(key, "o");
				if (!(key is string propertyName))
				{
					throw new ArgumentException("Set JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.ToString(key)));
				}
				this[propertyName] = value;
			}
		}

		public JToken this[string propertyName]
		{
			get
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(propertyName, "propertyName");
				return Property(propertyName)?.Value;
			}
			set
			{
				JProperty jProperty = Property(propertyName);
				if (jProperty != null)
				{
					jProperty.Value = value;
					return;
				}
				Add(new JProperty(propertyName, value));
				OnPropertyChanged(propertyName);
			}
		}

		public event PropertyChangedEventHandler PropertyChanged;

		public JObject()
		{
		}

		public JObject(JObject other)
			: base(other)
		{
		}

		public JObject(params object[] content)
			: this((object)content)
		{
		}

		public JObject(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			if (!(node is JObject jObject))
			{
				return false;
			}
			return _properties.Compare(jObject._properties);
		}

		internal override void InsertItem(int index, JToken item, bool skipParentCheck)
		{
			if (item == null || item.Type != JTokenType.Comment)
			{
				base.InsertItem(index, item, skipParentCheck);
			}
		}

		internal override void ValidateToken(JToken o, JToken existing)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type != JTokenType.Property)
			{
				throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
			JProperty jProperty = (JProperty)o;
			if (existing != null)
			{
				JProperty jProperty2 = (JProperty)existing;
				if (jProperty.Name == jProperty2.Name)
				{
					return;
				}
			}
			if (_properties.TryGetValue(jProperty.Name, out existing))
			{
				throw new ArgumentException("Can not add property {0} to {1}. Property with the same name already exists on object.".FormatWith(CultureInfo.InvariantCulture, jProperty.Name, GetType()));
			}
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			if (!(content is JObject jObject))
			{
				return;
			}
			foreach (KeyValuePair<string, JToken> item in jObject)
			{
				JProperty jProperty = Property(item.Key);
				if (jProperty == null)
				{
					Add(item.Key, item.Value);
				}
				else
				{
					if (item.Value == null)
					{
						continue;
					}
					if (!(jProperty.Value is JContainer jContainer))
					{
						if (item.Value.Type != JTokenType.Null)
						{
							jProperty.Value = item.Value;
						}
					}
					else if (jContainer.Type != item.Value.Type)
					{
						jProperty.Value = item.Value;
					}
					else
					{
						jContainer.Merge(item.Value, settings);
					}
				}
			}
		}

		internal void InternalPropertyChanged(JProperty childProperty)
		{
			OnPropertyChanged(childProperty.Name);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, IndexOfItem(childProperty)));
			}
		}

		internal void InternalPropertyChanging(JProperty childProperty)
		{
		}

		internal override JToken CloneToken()
		{
			return new JObject(this);
		}

		public IEnumerable<JProperty> Properties()
		{
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<JProperty>(_properties);
		}

		public JProperty Property(string name)
		{
			if (name == null)
			{
				return null;
			}
			_properties.TryGetValue(name, out var value);
			return (JProperty)value;
		}

		public JEnumerable<JToken> PropertyValues()
		{
			return new JEnumerable<JToken>(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Select(Properties(), (JProperty p) => p.Value));
		}

		public new static JObject Load(JsonReader reader)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader.");
			}
			while (reader.TokenType == JsonToken.Comment)
			{
				reader.Read();
			}
			if (reader.TokenType != JsonToken.StartObject)
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JObject jObject = new JObject();
			jObject.SetLineInfo(reader as IJsonLineInfo);
			jObject.ReadTokenFrom(reader);
			return jObject;
		}

		public new static JObject Parse(string json)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JObject result = Load(jsonReader);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
			}
			return result;
		}

		public new static JObject FromObject(object o)
		{
			return FromObject(o, JsonSerializer.CreateDefault());
		}

		public new static JObject FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken != null && jToken.Type != JTokenType.Object)
			{
				throw new ArgumentException("Object serialized to {0}. JObject instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JObject)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartObject();
			for (int i = 0; i < _properties.Count; i++)
			{
				_properties[i].WriteTo(writer, converters);
			}
			writer.WriteEndObject();
		}

		public JToken GetValue(string propertyName)
		{
			return GetValue(propertyName, StringComparison.Ordinal);
		}

		public JToken GetValue(string propertyName, StringComparison comparison)
		{
			if (propertyName == null)
			{
				return null;
			}
			JProperty jProperty = Property(propertyName);
			if (jProperty != null)
			{
				return jProperty.Value;
			}
			if (comparison != StringComparison.Ordinal)
			{
				foreach (JProperty property in _properties)
				{
					if (string.Equals(property.Name, propertyName, comparison))
					{
						return property.Value;
					}
				}
			}
			return null;
		}

		public bool TryGetValue(string propertyName, StringComparison comparison, out JToken value)
		{
			value = GetValue(propertyName, comparison);
			return value != null;
		}

		public void Add(string propertyName, JToken value)
		{
			Add(new JProperty(propertyName, value));
		}

		bool IDictionary<string, JToken>.ContainsKey(string key)
		{
			return _properties.Contains(key);
		}

		public bool Remove(string propertyName)
		{
			JProperty jProperty = Property(propertyName);
			if (jProperty == null)
			{
				return false;
			}
			jProperty.Remove();
			return true;
		}

		public bool TryGetValue(string propertyName, out JToken value)
		{
			JProperty jProperty = Property(propertyName);
			if (jProperty == null)
			{
				value = null;
				return false;
			}
			value = jProperty.Value;
			return true;
		}

		void ICollection<KeyValuePair<string, JToken>>.Add(KeyValuePair<string, JToken> item)
		{
			Add(new JProperty(item.Key, item.Value));
		}

		void ICollection<KeyValuePair<string, JToken>>.Clear()
		{
			RemoveAll();
		}

		bool ICollection<KeyValuePair<string, JToken>>.Contains(KeyValuePair<string, JToken> item)
		{
			JProperty jProperty = Property(item.Key);
			if (jProperty == null)
			{
				return false;
			}
			return jProperty.Value == item.Value;
		}

		void ICollection<KeyValuePair<string, JToken>>.CopyTo(KeyValuePair<string, JToken>[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length && arrayIndex != 0)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (base.Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JProperty property in _properties)
			{
				ref KeyValuePair<string, JToken> reference = ref array[arrayIndex + num];
				reference = new KeyValuePair<string, JToken>(property.Name, property.Value);
				num++;
			}
		}

		bool ICollection<KeyValuePair<string, JToken>>.Remove(KeyValuePair<string, JToken> item)
		{
			if (!((ICollection<KeyValuePair<string, JToken>>)this).Contains(item))
			{
				return false;
			}
			((IDictionary<string, JToken>)this).Remove(item.Key);
			return true;
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}

		public IEnumerator<KeyValuePair<string, JToken>> GetEnumerator()
		{
			foreach (JProperty property in _properties)
			{
				yield return new KeyValuePair<string, JToken>(property.Name, property.Value);
			}
		}

		protected virtual void OnPropertyChanged(string propertyName)
		{
			if (this.PropertyChanged != null)
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
		{
			return ((ICustomTypeDescriptor)this).GetProperties((Attribute[])null);
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
		{
			PropertyDescriptorCollection propertyDescriptorCollection = new PropertyDescriptorCollection(null);
			using IEnumerator<KeyValuePair<string, JToken>> enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				propertyDescriptorCollection.Add(new JPropertyDescriptor(enumerator.Current.Key));
			}
			return propertyDescriptorCollection;
		}

		AttributeCollection ICustomTypeDescriptor.GetAttributes()
		{
			return AttributeCollection.Empty;
		}

		string ICustomTypeDescriptor.GetClassName()
		{
			return null;
		}

		string ICustomTypeDescriptor.GetComponentName()
		{
			return null;
		}

		TypeConverter ICustomTypeDescriptor.GetConverter()
		{
			return new TypeConverter();
		}

		EventDescriptor ICustomTypeDescriptor.GetDefaultEvent()
		{
			return null;
		}

		PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty()
		{
			return null;
		}

		object ICustomTypeDescriptor.GetEditor(Type editorBaseType)
		{
			return null;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
		{
			return EventDescriptorCollection.Empty;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents()
		{
			return EventDescriptorCollection.Empty;
		}

		object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
		{
			return null;
		}
	}
	public class JProperty : JContainer
	{
		private class JPropertyList : IList<JToken>, IEnumerable, ICollection<JToken>, IEnumerable<JToken>
		{
			internal JToken _token;

			public int Count => (_token != null) ? 1 : 0;

			public bool IsReadOnly => false;

			public JToken this[int index]
			{
				get
				{
					return (index != 0) ? null : _token;
				}
				set
				{
					if (index == 0)
					{
						_token = value;
					}
				}
			}

			public IEnumerator<JToken> GetEnumerator()
			{
				if (_token != null)
				{
					yield return _token;
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			public void Add(JToken item)
			{
				_token = item;
			}

			public void Clear()
			{
				_token = null;
			}

			public bool Contains(JToken item)
			{
				return _token == item;
			}

			public void CopyTo(JToken[] array, int arrayIndex)
			{
				if (_token != null)
				{
					array[arrayIndex] = _token;
				}
			}

			public bool Remove(JToken item)
			{
				if (_token == item)
				{
					_token = null;
					return true;
				}
				return false;
			}

			public int IndexOf(JToken item)
			{
				return (_token != item) ? (-1) : 0;
			}

			public void Insert(int index, JToken item)
			{
				if (index == 0)
				{
					_token = item;
				}
			}

			public void RemoveAt(int index)
			{
				if (index == 0)
				{
					_token = null;
				}
			}
		}

		private readonly JPropertyList _content = new JPropertyList();

		private readonly string _name;

		protected override IList<JToken> ChildrenTokens => _content;

		public string Name
		{
			[DebuggerStepThrough]
			get
			{
				return _name;
			}
		}

		public JToken Value
		{
			[DebuggerStepThrough]
			get
			{
				return _content._token;
			}
			set
			{
				CheckReentrancy();
				JToken item = value ?? JValue.CreateNull();
				if (_content._token == null)
				{
					InsertItem(0, item, skipParentCheck: false);
				}
				else
				{
					SetItem(0, item);
				}
			}
		}

		public override JTokenType Type
		{
			[DebuggerStepThrough]
			get
			{
				return JTokenType.Property;
			}
		}

		public JProperty(JProperty other)
			: base(other)
		{
			_name = other.Name;
		}

		internal JProperty(string name)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
		}

		public JProperty(string name, params object[] content)
			: this(name, (object)content)
		{
		}

		public JProperty(string name, object content)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
			Value = ((!IsMultiContent(content)) ? JContainer.CreateFromContent(content) : new JArray(content));
		}

		internal override JToken GetItem(int index)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			return Value;
		}

		internal override void SetItem(int index, JToken item)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			if (!JContainer.IsTokenUnchanged(Value, item))
			{
				if (base.Parent != null)
				{
					((JObject)base.Parent).InternalPropertyChanging(this);
				}
				base.SetItem(0, item);
				if (base.Parent != null)
				{
					((JObject)base.Parent).InternalPropertyChanged(this);
				}
			}
		}

		internal override bool RemoveItem(JToken item)
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override void RemoveItemAt(int index)
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override void InsertItem(int index, JToken item, bool skipParentCheck)
		{
			if (item == null || item.Type != JTokenType.Comment)
			{
				if (Value != null)
				{
					throw new JsonException("{0} cannot have multiple values.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
				}
				base.InsertItem(0, item, skipParentCheck: false);
			}
		}

		internal override bool ContainsItem(JToken item)
		{
			return Value == item;
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			if (content is JProperty { Value: not null } jProperty && jProperty.Value.Type != JTokenType.Null)
			{
				Value = jProperty.Value;
			}
		}

		internal override void ClearItems()
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override bool DeepEquals(JToken node)
		{
			return node is JProperty jProperty && _name == jProperty.Name && ContentsEqual(jProperty);
		}

		internal override JToken CloneToken()
		{
			return new JProperty(this);
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WritePropertyName(_name);
			JToken value = Value;
			if (value != null)
			{
				value.WriteTo(writer, converters);
			}
			else
			{
				writer.WriteNull();
			}
		}

		internal override int GetDeepHashCode()
		{
			return _name.GetHashCode() ^ ((Value != null) ? Value.GetDeepHashCode() : 0);
		}

		public new static JProperty Load(JsonReader reader)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader.");
			}
			while (reader.TokenType == JsonToken.Comment)
			{
				reader.Read();
			}
			if (reader.TokenType != JsonToken.PropertyName)
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JProperty jProperty = new JProperty((string)reader.Value);
			jProperty.SetLineInfo(reader as IJsonLineInfo);
			jProperty.ReadTokenFrom(reader);
			return jProperty;
		}
	}
	public class JPropertyDescriptor : PropertyDescriptor
	{
		public override Type ComponentType => typeof(JObject);

		public override bool IsReadOnly => false;

		public override Type PropertyType => typeof(object);

		protected override int NameHashCode => base.NameHashCode;

		public JPropertyDescriptor(string name)
			: base(name, null)
		{
		}

		private static JObject CastInstance(object instance)
		{
			return (JObject)instance;
		}

		public override bool CanResetValue(object component)
		{
			return false;
		}

		public override object GetValue(object component)
		{
			return CastInstance(component)[Name];
		}

		public override void ResetValue(object component)
		{
		}

		public override void SetValue(object component, object value)
		{
			JToken value2 = ((!(value is JToken)) ? new JValue(value) : ((JToken)value));
			CastInstance(component)[Name] = value2;
		}

		public override bool ShouldSerializeValue(object component)
		{
			return false;
		}
	}
	internal class JPropertyKeyedCollection : Collection<JToken>
	{
		private static readonly IEqualityComparer<string> Comparer = StringComparer.Ordinal;

		private Dictionary<string, JToken> _dictionary;

		public JToken this[string key]
		{
			get
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (_dictionary != null)
				{
					return _dictionary[key];
				}
				throw new KeyNotFoundException();
			}
		}

		public ICollection<string> Keys
		{
			get
			{
				EnsureDictionary();
				return _dictionary.Keys;
			}
		}

		public ICollection<JToken> Values
		{
			get
			{
				EnsureDictionary();
				return _dictionary.Values;
			}
		}

		private void AddKey(string key, JToken item)
		{
			EnsureDictionary();
			_dictionary[key] = item;
		}

		protected void ChangeItemKey(JToken item, string newKey)
		{
			if (!ContainsItem(item))
			{
				throw new ArgumentException("The specified item does not exist in this KeyedCollection.");
			}
			string keyForItem = GetKeyForItem(item);
			if (!Comparer.Equals(keyForItem, newKey))
			{
				if (newKey != null)
				{
					AddKey(newKey, item);
				}
				if (keyForItem != null)
				{
					RemoveKey(keyForItem);
				}
			}
		}

		protected override void ClearItems()
		{
			base.ClearItems();
			if (_dictionary != null)
			{
				_dictionary.Clear();
			}
		}

		public bool Contains(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (_dictionary != null)
			{
				return _dictionary.ContainsKey(key);
			}
			return false;
		}

		private bool ContainsItem(JToken item)
		{
			if (_dictionary == null)
			{
				return false;
			}
			string keyForItem = GetKeyForItem(item);
			JToken value;
			return _dictionary.TryGetValue(keyForItem, out value);
		}

		private void EnsureDictionary()
		{
			if (_dictionary == null)
			{
				_dictionary = new Dictionary<string, JToken>(Comparer);
			}
		}

		private string GetKeyForItem(JToken item)
		{
			return ((JProperty)item).Name;
		}

		protected override void InsertItem(int index, JToken item)
		{
			AddKey(GetKeyForItem(item), item);
			base.InsertItem(index, item);
		}

		public bool Remove(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (_dictionary != null)
			{
				return _dictionary.ContainsKey(key) && Remove(_dictionary[key]);
			}
			return false;
		}

		protected override void RemoveItem(int index)
		{
			string keyForItem = GetKeyForItem(base.Items[index]);
			RemoveKey(keyForItem);
			base.RemoveItem(index);
		}

		private void RemoveKey(string key)
		{
			if (_dictionary != null)
			{
				_dictionary.Remove(key);
			}
		}

		protected override void SetItem(int index, JToken item)
		{
			string keyForItem = GetKeyForItem(item);
			string keyForItem2 = GetKeyForItem(base.Items[index]);
			if (Comparer.Equals(keyForItem2, keyForItem))
			{
				if (_dictionary != null)
				{
					_dictionary[keyForItem] = item;
				}
			}
			else
			{
				AddKey(keyForItem, item);
				if (keyForItem2 != null)
				{
					RemoveKey(keyForItem2);
				}
			}
			base.SetItem(index, item);
		}

		public bool TryGetValue(string key, out JToken value)
		{
			if (_dictionary == null)
			{
				value = null;
				return false;
			}
			return _dictionary.TryGetValue(key, out value);
		}

		public bool Compare(JPropertyKeyedCollection other)
		{
			if (this == other)
			{
				return true;
			}
			Dictionary<string, JToken> dictionary = _dictionary;
			Dictionary<string, JToken> dictionary2 = other._dictionary;
			if (dictionary == null && dictionary2 == null)
			{
				return true;
			}
			if (dictionary == null)
			{
				return dictionary2.Count == 0;
			}
			if (dictionary2 == null)
			{
				return dictionary.Count == 0;
			}
			if (dictionary.Count != dictionary2.Count)
			{
				return false;
			}
			foreach (KeyValuePair<string, JToken> item in dictionary)
			{
				if (!dictionary2.TryGetValue(item.Key, out var value))
				{
					return false;
				}
				JProperty jProperty = (JProperty)item.Value;
				JProperty jProperty2 = (JProperty)value;
				if (jProperty.Value == null)
				{
					return jProperty2.Value == null;
				}
				if (!jProperty.Value.DeepEquals(jProperty2.Value))
				{
					return false;
				}
			}
			return true;
		}
	}
	public class JRaw : JValue
	{
		public JRaw(JRaw other)
			: base(other)
		{
		}

		public JRaw(object rawJson)
			: base(rawJson, JTokenType.Raw)
		{
		}

		public static JRaw Create(JsonReader reader)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			using JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.WriteToken(reader);
			return new JRaw(stringWriter.ToString());
		}

		internal override JToken CloneToken()
		{
			return new JRaw(this);
		}
	}
	public abstract class JToken : IJEnumerable<JToken>, IJsonLineInfo, ICloneable, IEnumerable<JToken>, IEnumerable
	{
		private class LineInfoAnnotation
		{
			internal readonly int LineNumber;

			internal readonly int LinePosition;

			public LineInfoAnnotation(int lineNumber, int linePosition)
			{
				LineNumber = lineNumber;
				LinePosition = linePosition;
			}
		}

		private static JTokenEqualityComparer _equalityComparer;

		private JContainer _parent;

		private JToken _previous;

		private JToken _next;

		private object _annotations;

		private static readonly JTokenType[] BooleanTypes = new JTokenType[6]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean
		};

		private static readonly JTokenType[] NumberTypes = new JTokenType[6]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean
		};

		private static readonly JTokenType[] StringTypes = new JTokenType[11]
		{
			JTokenType.Date,
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean,
			JTokenType.Bytes,
			JTokenType.Guid,
			JTokenType.TimeSpan,
			JTokenType.Uri
		};

		private static readonly JTokenType[] GuidTypes = new JTokenType[5]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Guid,
			JTokenType.Bytes
		};

		private static readonly JTokenType[] TimeSpanTypes = new JTokenType[4]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.TimeSpan
		};

		private static readonly JTokenType[] UriTypes = new JTokenType[4]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Uri
		};

		private static readonly JTokenType[] CharTypes = new JTokenType[5]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw
		};

		private static readonly JTokenType[] DateTimeTypes = new JTokenType[4]
		{
			JTokenType.Date,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw
		};

		private static readonly JTokenType[] BytesTypes = new JTokenType[5]
		{
			JTokenType.Bytes,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Integer
		};

		IJEnumerable<JToken> IJEnumerable<JToken>.this[object key] => this[key];

		int IJsonLineInfo.LineNumber => Annotation<LineInfoAnnotation>()?.LineNumber ?? 0;

		int IJsonLineInfo.LinePosition => Annotation<LineInfoAnnotation>()?.LinePosition ?? 0;

		public static JTokenEqualityComparer EqualityComparer
		{
			get
			{
				if (_equalityComparer == null)
				{
					_equalityComparer = new JTokenEqualityComparer();
				}
				return _equalityComparer;
			}
		}

		public JContainer Parent
		{
			[DebuggerStepThrough]
			get
			{
				return _parent;
			}
			internal set
			{
				_parent = value;
			}
		}

		public JToken Root
		{
			get
			{
				JContainer parent = Parent;
				if (parent == null)
				{
					return this;
				}
				while (parent.Parent != null)
				{
					parent = parent.Parent;
				}
				return parent;
			}
		}

		public abstract JTokenType Type { get; }

		public abstract bool HasValues { get; }

		public JToken Next
		{
			get
			{
				return _next;
			}
			internal set
			{
				_next = value;
			}
		}

		public JToken Previous
		{
			get
			{
				return _previous;
			}
			internal set
			{
				_previous = value;
			}
		}

		public string Path
		{
			get
			{
				if (Parent == null)
				{
					return string.Empty;
				}
				IList<JToken> list = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Reverse(AncestorsAndSelf()));
				IList<JsonPosition> list2 = new List<JsonPosition>();
				for (int i = 0; i < list.Count; i++)
				{
					JToken jToken = list[i];
					JToken jToken2 = null;
					if (i + 1 < list.Count)
					{
						jToken2 = list[i + 1];
					}
					else if (list[i].Type == JTokenType.Property)
					{
						jToken2 = list[i];
					}
					if (jToken2 != null)
					{
						switch (jToken.Type)
						{
						case JTokenType.Property:
						{
							JProperty jProperty = (JProperty)jToken;
							list2.Add(new JsonPosition(JsonContainerType.Object)
							{
								PropertyName = jProperty.Name
							});
							break;
						}
						case JTokenType.Array:
						case JTokenType.Constructor:
						{
							int position = ((IList<JToken>)jToken).IndexOf(jToken2);
							list2.Add(new JsonPosition(JsonContainerType.Array)
							{
								Position = position
							});
							break;
						}
						}
					}
				}
				return JsonPosition.BuildPath(list2);
			}
		}

		public virtual JToken this[object key]
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
			set
			{
				throw new InvalidOperationException("Cannot set child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken First
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken Last
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		internal JToken()
		{
		}

		internal abstract JToken CloneToken();

		internal abstract bool DeepEquals(JToken node);

		public static bool DeepEquals(JToken t1, JToken t2)
		{
			return t1 == t2 || (t1 != null && t2 != null && t1.DeepEquals(t2));
		}

		public void AddAfterSelf(object content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int num = _parent.IndexOfItem(this);
			_parent.AddInternal(num + 1, content, skipParentCheck: false);
		}

		public void AddBeforeSelf(object content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int index = _parent.IndexOfItem(this);
			_parent.AddInternal(index, content, skipParentCheck: false);
		}

		public IEnumerable<JToken> Ancestors()
		{
			return GetAncestors(self: false);
		}

		public IEnumerable<JToken> AncestorsAndSelf()
		{
			return GetAncestors(self: true);
		}

		internal IEnumerable<JToken> GetAncestors(bool self)
		{
			for (JToken current = ((!self) ? Parent : this); current != null; current = current.Parent)
			{
				yield return current;
			}
		}

		public IEnumerable<JToken> AfterSelf()
		{
			if (Parent != null)
			{
				for (JToken o = Next; o != null; o = o.Next)
				{
					yield return o;
				}
			}
		}

		public IEnumerable<JToken> BeforeSelf()
		{
			for (JToken o = Parent.First; o != this; o = o.Next)
			{
				yield return o;
			}
		}

		public virtual JEnumerable<JToken> Children()
		{
			return JEnumerable<JToken>.Empty;
		}

		public JEnumerable<T> Children<T>() where T : JToken
		{
			return new JEnumerable<T>(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.OfType<T>(Children()));
		}

		public virtual IEnumerable<T> Values<T>()
		{
			throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}

		public void Remove()
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.RemoveItem(this);
		}

		public void Replace(JToken value)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.ReplaceItem(this, value);
		}

		public abstract void WriteTo(JsonWriter writer, params JsonConverter[] converters);

		public override string ToString()
		{
			return ToString(Formatting.Indented);
		}

		public string ToString(Formatting formatting, params JsonConverter[] converters)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.Formatting = formatting;
			WriteTo(jsonTextWriter, converters);
			return stringWriter.ToString();
		}

		private static JValue EnsureValue(JToken value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value is JProperty)
			{
				value = ((JProperty)value).Value;
			}
			return value as JValue;
		}

		private static string GetType(JToken token)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(token, "token");
			if (token is JProperty)
			{
				token = ((JProperty)token).Value;
			}
			return token.Type.ToString();
		}

		private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
		{
			return Array.IndexOf(validTypes, o.Type) != -1 || (nullable && (o.Type == JTokenType.Null || o.Type == JTokenType.Undefined));
		}

		public static explicit operator bool(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator bool?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new bool?(Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator long(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTime?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new DateTime?(Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator decimal?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new decimal?(Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator double?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new double?(Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator char?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new char?(Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator int(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator short(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator ushort(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator char(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator sbyte(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator int?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new int?(Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator short?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new short?(Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator ushort?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new ushort?(Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator byte?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new byte?(Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator sbyte?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new sbyte?(Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator DateTime(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator long?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new long?(Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator float?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new float?(Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator decimal(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator uint?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new uint?(Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator ulong?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (jValue.Value == null) ? null : new ulong?(Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator double(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator float(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator string(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, StringTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to String.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (jValue.Value is byte[])
			{
				return Convert.ToBase64String((byte[])jValue.Value);
			}
			return Convert.ToString(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator uint(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator ulong(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte[](JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BytesTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is string)
			{
				return Convert.FromBase64String(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
			}
			if (jValue.Value is byte[])
			{
				return (byte[])jValue.Value;
			}
			throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}

		public static explicit operator Guid(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is byte[])
			{
				return new Guid((byte[])jValue.Value);
			}
			return (!(jValue.Value is Guid)) ? new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture)) : ((Guid)jValue.Value);
		}

		public static explicit operator Guid?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (jValue.Value is byte[])
			{
				return new Guid((byte[])jValue.Value);
			}
			return (!(jValue.Value is Guid)) ? new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture)) : ((Guid)jValue.Value);
		}

		public static explicit operator TimeSpan(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return (!(jValue.Value is TimeSpan)) ? Newtonsoft.Json.Utilities.ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture)) : ((TimeSpan)jValue.Value);
		}

		public static explicit operator TimeSpan?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return (!(jValue.Value is TimeSpan)) ? Newtonsoft.Json.Utilities.ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture)) : ((TimeSpan)jValue.Value);
		}

		public static explicit operator Uri(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, UriTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Uri.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return (!(jValue.Value is Uri)) ? new Uri(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture)) : ((Uri)jValue.Value);
		}

		public static implicit operator JToken(bool value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte value)
		{
			return new JValue((int)value);
		}

		public static implicit operator JToken(byte? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(sbyte value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(sbyte? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(bool? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(short value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ushort value)
		{
			return new JValue((int)value);
		}

		public static implicit operator JToken(int value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(int? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(short? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ushort? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(uint? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ulong? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(string value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(uint value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(ulong value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte[] value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Uri value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(TimeSpan value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(TimeSpan? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Guid value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Guid? value)
		{
			return new JValue(value);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<JToken>)this).GetEnumerator();
		}

		IEnumerator<JToken> IEnumerable<JToken>.GetEnumerator()
		{
			return Children().GetEnumerator();
		}

		internal abstract int GetDeepHashCode();

		public JsonReader CreateReader()
		{
			return new JTokenReader(this, Path);
		}

		internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(o, "o");
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenWriter jTokenWriter = new JTokenWriter();
			jsonSerializer.Serialize(jTokenWriter, o);
			return jTokenWriter.Token;
		}

		public static JToken FromObject(object o)
		{
			return FromObjectInternal(o, JsonSerializer.CreateDefault());
		}

		public static JToken FromObject(object o, JsonSerializer jsonSerializer)
		{
			return FromObjectInternal(o, jsonSerializer);
		}

		public T ToObject<T>()
		{
			return (T)ToObject(typeof(T));
		}

		public object ToObject(Type objectType)
		{
			if (JsonConvert.DefaultSettings == null)
			{
				bool isEnum;
				PrimitiveTypeCode typeCode = Newtonsoft.Json.Utilities.ConvertUtils.GetTypeCode(objectType, out isEnum);
				if (isEnum && Type == JTokenType.String)
				{
					Type type = ((!objectType.IsEnum()) ? Nullable.GetUnderlyingType(objectType) : objectType);
					try
					{
						return Enum.Parse(type, (string)this, ignoreCase: true);
					}
					catch (Exception innerException)
					{
						throw new ArgumentException("Could not convert '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, (string)this, type.Name), innerException);
					}
				}
				switch (typeCode)
				{
				case PrimitiveTypeCode.BooleanNullable:
					return (bool?)this;
				case PrimitiveTypeCode.Boolean:
					return (bool)this;
				case PrimitiveTypeCode.CharNullable:
					return (char?)this;
				case PrimitiveTypeCode.Char:
					return (char)this;
				case PrimitiveTypeCode.SByte:
					return (sbyte?)this;
				case PrimitiveTypeCode.SByteNullable:
					return (sbyte)this;
				case PrimitiveTypeCode.ByteNullable:
					return (byte?)this;
				case PrimitiveTypeCode.Byte:
					return (byte)this;
				case PrimitiveTypeCode.Int16Nullable:
					return (short?)this;
				case PrimitiveTypeCode.Int16:
					return (short)this;
				case PrimitiveTypeCode.UInt16Nullable:
					return (ushort?)this;
				case PrimitiveTypeCode.UInt16:
					return (ushort)this;
				case PrimitiveTypeCode.Int32Nullable:
					return (int?)this;
				case PrimitiveTypeCode.Int32:
					return (int)this;
				case PrimitiveTypeCode.UInt32Nullable:
					return (uint?)this;
				case PrimitiveTypeCode.UInt32:
					return (uint)this;
				case PrimitiveTypeCode.Int64Nullable:
					return (long?)this;
				case PrimitiveTypeCode.Int64:
					return (long)this;
				case PrimitiveTypeCode.UInt64Nullable:
					return (ulong?)this;
				case PrimitiveTypeCode.UInt64:
					return (ulong)this;
				case PrimitiveTypeCode.SingleNullable:
					return (float?)this;
				case PrimitiveTypeCode.Single:
					return (float)this;
				case PrimitiveTypeCode.DoubleNullable:
					return (double?)this;
				case PrimitiveTypeCode.Double:
					return (double)this;
				case PrimitiveTypeCode.DecimalNullable:
					return (decimal?)this;
				case PrimitiveTypeCode.Decimal:
					return (decimal)this;
				case PrimitiveTypeCode.DateTimeNullable:
					return (DateTime?)this;
				case PrimitiveTypeCode.DateTime:
					return (DateTime)this;
				case PrimitiveTypeCode.String:
					return (string)this;
				case PrimitiveTypeCode.GuidNullable:
					return (Guid?)this;
				case PrimitiveTypeCode.Guid:
					return (Guid)this;
				case PrimitiveTypeCode.Uri:
					return (Uri)this;
				case PrimitiveTypeCode.TimeSpanNullable:
					return (TimeSpan?)this;
				case PrimitiveTypeCode.TimeSpan:
					return (TimeSpan)this;
				}
			}
			return ToObject(objectType, JsonSerializer.CreateDefault());
		}

		public T ToObject<T>(JsonSerializer jsonSerializer)
		{
			return (T)ToObject(typeof(T), jsonSerializer);
		}

		public object ToObject(Type objectType, JsonSerializer jsonSerializer)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenReader reader = new JTokenReader(this);
			return jsonSerializer.Deserialize(reader, objectType);
		}

		public static JToken ReadFrom(JsonReader reader)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader.");
			}
			IJsonLineInfo lineInfo = reader as IJsonLineInfo;
			switch (reader.TokenType)
			{
			case JsonToken.StartObject:
				return JObject.Load(reader);
			case JsonToken.StartArray:
				return JArray.Load(reader);
			case JsonToken.StartConstructor:
				return JConstructor.Load(reader);
			case JsonToken.PropertyName:
				return JProperty.Load(reader);
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
			{
				JValue jValue = new JValue(reader.Value);
				jValue.SetLineInfo(lineInfo);
				return jValue;
			}
			case JsonToken.Comment:
			{
				JValue jValue = JValue.CreateComment(reader.Value.ToString());
				jValue.SetLineInfo(lineInfo);
				return jValue;
			}
			case JsonToken.Null:
			{
				JValue jValue = JValue.CreateNull();
				jValue.SetLineInfo(lineInfo);
				return jValue;
			}
			case JsonToken.Undefined:
			{
				JValue jValue = JValue.CreateUndefined();
				jValue.SetLineInfo(lineInfo);
				return jValue;
			}
			default:
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
		}

		public static JToken Parse(string json)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JToken result = Load(jsonReader);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
			}
			return result;
		}

		public static JToken Load(JsonReader reader)
		{
			return ReadFrom(reader);
		}

		internal void SetLineInfo(IJsonLineInfo lineInfo)
		{
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
			}
		}

		internal void SetLineInfo(int lineNumber, int linePosition)
		{
			AddAnnotation(new LineInfoAnnotation(lineNumber, linePosition));
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			return Annotation<LineInfoAnnotation>() != null;
		}

		public JToken SelectToken(string path)
		{
			return SelectToken(path, errorWhenNoMatch: false);
		}

		public JToken SelectToken(string path, bool errorWhenNoMatch)
		{
			Newtonsoft.Json.Linq.JsonPath.JPath jPath = new Newtonsoft.Json.Linq.JsonPath.JPath(path);
			JToken jToken = null;
			foreach (JToken item in jPath.Evaluate(this, errorWhenNoMatch))
			{
				if (jToken != null)
				{
					throw new JsonException("Path returned multiple tokens.");
				}
				jToken = item;
			}
			return jToken;
		}

		public IEnumerable<JToken> SelectTokens(string path)
		{
			return SelectTokens(path, errorWhenNoMatch: false);
		}

		public IEnumerable<JToken> SelectTokens(string path, bool errorWhenNoMatch)
		{
			Newtonsoft.Json.Linq.JsonPath.JPath jPath = new Newtonsoft.Json.Linq.JsonPath.JPath(path);
			return jPath.Evaluate(this, errorWhenNoMatch);
		}

		object ICloneable.Clone()
		{
			return DeepClone();
		}

		public JToken DeepClone()
		{
			return CloneToken();
		}

		public void AddAnnotation(object annotation)
		{
			if (annotation == null)
			{
				throw new ArgumentNullException("annotation");
			}
			if (_annotations == null)
			{
				_annotations = ((!(annotation is object[])) ? annotation : new object[1] { annotation });
				return;
			}
			object[] array = _annotations as object[];
			if (array == null)
			{
				_annotations = new object[2] { _annotations, annotation };
				return;
			}
			int i;
			for (i = 0; i < array.Length && array[i] != null; i++)
			{
			}
			if (i == array.Length)
			{
				Array.Resize(ref array, i * 2);
				_annotations = array;
			}
			array[i] = annotation;
		}

		public T Annotation<T>() where T : class
		{
			if (_annotations != null)
			{
				if (!(_annotations is object[] array))
				{
					return _annotations as T;
				}
				foreach (object obj in array)
				{
					if (obj == null)
					{
						break;
					}
					if (obj is T result)
					{
						return result;
					}
				}
			}
			return (T)null;
		}

		public object Annotation(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations != null)
			{
				if (!(_annotations is object[] array))
				{
					if (type.IsInstanceOfType(_annotations))
					{
						return _annotations;
					}
				}
				else
				{
					foreach (object obj in array)
					{
						if (obj == null)
						{
							break;
						}
						if (type.IsInstanceOfType(obj))
						{
							return obj;
						}
					}
				}
			}
			return null;
		}

		public IEnumerable<T> Annotations<T>() where T : class
		{
			if (_annotations == null)
			{
				yield break;
			}
			if (_annotations is object[] annotations)
			{
				foreach (object o in annotations)
				{
					if (o == null)
					{
						break;
					}
					if (o is T casted)
					{
						yield return casted;
					}
				}
			}
			else if (_annotations is T annotation)
			{
				yield return annotation;
			}
		}

		public IEnumerable<object> Annotations(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations == null)
			{
				yield break;
			}
			if (_annotations is object[] annotations)
			{
				foreach (object o in annotations)
				{
					if (o == null)
					{
						break;
					}
					if (type.IsInstanceOfType(o))
					{
						yield return o;
					}
				}
			}
			else if (type.IsInstanceOfType(_annotations))
			{
				yield return _annotations;
			}
		}

		public void RemoveAnnotations<T>() where T : class
		{
			if (_annotations == null)
			{
				return;
			}
			if (!(_annotations is object[] array))
			{
				if (_annotations is T)
				{
					_annotations = null;
				}
				return;
			}
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				object obj = array[i];
				if (obj == null)
				{
					break;
				}
				if (!(obj is T))
				{
					array[num++] = obj;
				}
			}
			if (num != 0)
			{
				while (num < i)
				{
					array[num++] = null;
				}
			}
			else
			{
				_annotations = null;
			}
		}

		public void RemoveAnnotations(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations == null)
			{
				return;
			}
			if (!(_annotations is object[] array))
			{
				if (type.IsInstanceOfType(_annotations))
				{
					_annotations = null;
				}
				return;
			}
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				object obj = array[i];
				if (obj == null)
				{
					break;
				}
				if (!type.IsInstanceOfType(obj))
				{
					array[num++] = obj;
				}
			}
			if (num != 0)
			{
				while (num < i)
				{
					array[num++] = null;
				}
			}
			else
			{
				_annotations = null;
			}
		}
	}
	public class JTokenEqualityComparer : IEqualityComparer<JToken>
	{
		public bool Equals(JToken x, JToken y)
		{
			return JToken.DeepEquals(x, y);
		}

		public int GetHashCode(JToken obj)
		{
			return obj?.GetDeepHashCode() ?? 0;
		}
	}
	public class JTokenReader : JsonReader, IJsonLineInfo
	{
		private readonly string _initialPath;

		private readonly JToken _root;

		private JToken _parent;

		private JToken _current;

		int IJsonLineInfo.LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)_current)?.LineNumber ?? 0;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)_current)?.LinePosition ?? 0;
			}
		}

		public JToken CurrentToken => _current;

		public override string Path
		{
			get
			{
				string text = base.Path;
				if (!string.IsNullOrEmpty(_initialPath))
				{
					if (string.IsNullOrEmpty(text))
					{
						return _initialPath;
					}
					text = ((!_initialPath.EndsWith(']') && !text.StartsWith('[')) ? (_initialPath + "." + text) : (_initialPath + text));
				}
				return text;
			}
		}

		public JTokenReader(JToken token)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(token, "token");
			_root = token;
		}

		internal JTokenReader(JToken token, string initialPath)
			: this(token)
		{
			_initialPath = initialPath;
		}

		public override byte[] ReadAsBytes()
		{
			return ReadAsBytesInternal();
		}

		public override decimal? ReadAsDecimal()
		{
			return ReadAsDecimalInternal();
		}

		public override int? ReadAsInt32()
		{
			return ReadAsInt32Internal();
		}

		public override string ReadAsString()
		{
			return ReadAsStringInternal();
		}

		public override DateTime? ReadAsDateTime()
		{
			return ReadAsDateTimeInternal();
		}

		internal override bool ReadInternal()
		{
			if (base.CurrentState != 0)
			{
				if (_current == null)
				{
					return false;
				}
				if (_current is JContainer jContainer && _parent != jContainer)
				{
					return ReadInto(jContainer);
				}
				return ReadOver(_current);
			}
			_current = _root;
			SetToken(_current);
			return true;
		}

		public override bool Read()
		{
			_readType = ReadType.Read;
			return ReadInternal();
		}

		private bool ReadOver(JToken t)
		{
			if (t == _root)
			{
				return ReadToEnd();
			}
			JToken next = t.Next;
			if (next == null || next == t || t == t.Parent.Last)
			{
				if (t.Parent == null)
				{
					return ReadToEnd();
				}
				return SetEnd(t.Parent);
			}
			_current = next;
			SetToken(_current);
			return true;
		}

		private bool ReadToEnd()
		{
			_current = null;
			SetToken(JsonToken.None);
			return false;
		}

		private JsonToken? GetEndToken(JContainer c)
		{
			return c.Type switch
			{
				JTokenType.Object => JsonToken.EndObject, 
				JTokenType.Array => JsonToken.EndArray, 
				JTokenType.Constructor => JsonToken.EndConstructor, 
				JTokenType.Property => null, 
				_ => throw Newtonsoft.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", c.Type, "Unexpected JContainer type."), 
			};
		}

		private bool ReadInto(JContainer c)
		{
			JToken first = c.First;
			if (first == null)
			{
				return SetEnd(c);
			}
			SetToken(first);
			_current = first;
			_parent = c;
			return true;
		}

		private bool SetEnd(JContainer c)
		{
			JsonToken? endToken = GetEndToken(c);
			if (endToken.HasValue)
			{
				SetToken(endToken.Value);
				_current = c;
				_parent = c;
				return true;
			}
			return ReadOver(c);
		}

		private void SetToken(JToken token)
		{
			switch (token.Type)
			{
			case JTokenType.Object:
				SetToken(JsonToken.StartObject);
				break;
			case JTokenType.Array:
				SetToken(JsonToken.StartArray);
				break;
			case JTokenType.Constructor:
				SetToken(JsonToken.StartConstructor, ((JConstructor)token).Name);
				break;
			case JTokenType.Property:
				SetToken(JsonToken.PropertyName, ((JProperty)token).Name);
				break;
			case JTokenType.Comment:
				SetToken(JsonToken.Comment, ((JValue)token).Value);
				break;
			case JTokenType.Integer:
				SetToken(JsonToken.Integer, ((JValue)token).Value);
				break;
			case JTokenType.Float:
				SetToken(JsonToken.Float, ((JValue)token).Value);
				break;
			case JTokenType.String:
				SetToken(JsonToken.String, ((JValue)token).Value);
				break;
			case JTokenType.Boolean:
				SetToken(JsonToken.Boolean, ((JValue)token).Value);
				break;
			case JTokenType.Null:
				SetToken(JsonToken.Null, ((JValue)token).Value);
				break;
			case JTokenType.Undefined:
				SetToken(JsonToken.Undefined, ((JValue)token).Value);
				break;
			case JTokenType.Date:
				SetToken(JsonToken.Date, ((JValue)token).Value);
				break;
			case JTokenType.Raw:
				SetToken(JsonToken.Raw, ((JValue)token).Value);
				break;
			case JTokenType.Bytes:
				SetToken(JsonToken.Bytes, ((JValue)token).Value);
				break;
			case JTokenType.Guid:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			case JTokenType.Uri:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			case JTokenType.TimeSpan:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			default:
				throw Newtonsoft.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", token.Type, "Unexpected JTokenType.");
			}
		}

		private string SafeToString(object value)
		{
			return value?.ToString();
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			if (base.CurrentState == State.Start)
			{
				return false;
			}
			return ((IJsonLineInfo)_current)?.HasLineInfo() ?? false;
		}
	}
	public enum JTokenType
	{
		None,
		Object,
		Array,
		Constructor,
		Property,
		Comment,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		Date,
		Raw,
		Bytes,
		Guid,
		Uri,
		TimeSpan
	}
	public class JTokenWriter : JsonWriter
	{
		private JContainer _token;

		private JContainer _parent;

		private JValue _value;

		private JToken _current;

		public JToken CurrentToken => _current;

		public JToken Token
		{
			get
			{
				if (_token != null)
				{
					return _token;
				}
				return _value;
			}
		}

		public JTokenWriter(JContainer container)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(container, "container");
			_token = container;
			_parent = container;
		}

		public JTokenWriter()
		{
		}

		public override void Flush()
		{
		}

		public override void Close()
		{
			base.Close();
		}

		public override void WriteStartObject()
		{
			base.WriteStartObject();
			AddParent(new JObject());
		}

		private void AddParent(JContainer container)
		{
			if (_parent == null)
			{
				_token = container;
			}
			else
			{
				_parent.AddAndSkipParentCheck(container);
			}
			_parent = container;
			_current = container;
		}

		private void RemoveParent()
		{
			_current = _parent;
			_parent = _parent.Parent;
			if (_parent != null && _parent.Type == JTokenType.Property)
			{
				_parent = _parent.Parent;
			}
		}

		public override void WriteStartArray()
		{
			base.WriteStartArray();
			AddParent(new JArray());
		}

		public override void WriteStartConstructor(string name)
		{
			base.WriteStartConstructor(name);
			AddParent(new JConstructor(name));
		}

		protected override void WriteEnd(JsonToken token)
		{
			RemoveParent();
		}

		public override void WritePropertyName(string name)
		{
			AddParent(new JProperty(name));
			base.WritePropertyName(name);
		}

		private void AddValue(object value, JsonToken token)
		{
			AddValue(new JValue(value), token);
		}

		internal void AddValue(JValue value, JsonToken token)
		{
			if (_parent != null)
			{
				_parent.Add(value);
				_current = _parent.Last;
				if (_parent.Type == JTokenType.Property)
				{
					_parent = _parent.Parent;
				}
			}
			else
			{
				_value = value ?? JValue.CreateNull();
				_current = _value;
			}
		}

		public override void WriteValue(object value)
		{
			base.WriteValue(value);
		}

		public override void WriteNull()
		{
			base.WriteNull();
			AddValue(null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			base.WriteUndefined();
			AddValue(null, JsonToken.Undefined);
		}

		public override void WriteRaw(string json)
		{
			base.WriteRaw(json);
			AddValue(new JRaw(json), JsonToken.Raw);
		}

		public override void WriteComment(string text)
		{
			base.WriteComment(text);
			AddValue(JValue.CreateComment(text), JsonToken.Comment);
		}

		public override void WriteValue(string value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(int value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(uint value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(long value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(ulong value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(float value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(ushort value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(char value)
		{
			base.WriteValue(value);
			string text = null;
			text = value.ToString(CultureInfo.InvariantCulture);
			AddValue(text, JsonToken.String);
		}

		public override void WriteValue(byte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(sbyte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(decimal value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			base.WriteValue(value);
			value = Newtonsoft.Json.Utilities.DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			AddValue(value, JsonToken.Date);
		}

		public override void WriteValue(byte[] value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Bytes);
		}

		public override void WriteValue(TimeSpan value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Guid value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Uri value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}
	}
	public class JValue : JToken, IEquatable<JValue>, IFormattable, IComparable, IComparable<JValue>, IConvertible
	{
		private JTokenType _valueType;

		private object _value;

		public override bool HasValues => false;

		public override JTokenType Type => _valueType;

		public object Value
		{
			get
			{
				return _value;
			}
			set
			{
				Type type = ((_value == null) ? null : _value.GetType());
				Type type2 = value?.GetType();
				if (type != type2)
				{
					_valueType = GetValueType(_valueType, value);
				}
				_value = value;
			}
		}

		internal JValue(object value, JTokenType type)
		{
			_value = value;
			_valueType = type;
		}

		public JValue(JValue other)
			: this(other.Value, other.Type)
		{
		}

		public JValue(long value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(decimal value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(char value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(ulong value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(double value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(float value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(DateTime value)
			: this(value, JTokenType.Date)
		{
		}

		public JValue(bool value)
			: this(value, JTokenType.Boolean)
		{
		}

		public JValue(string value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(Guid value)
			: this(value, JTokenType.Guid)
		{
		}

		public JValue(Uri value)
			: this(value, (!(value != null)) ? JTokenType.Null : JTokenType.Uri)
		{
		}

		public JValue(TimeSpan value)
			: this(value, JTokenType.TimeSpan)
		{
		}

		public JValue(object value)
			: this(value, GetValueType(null, value))
		{
		}

		internal override bool DeepEquals(JToken node)
		{
			if (!(node is JValue jValue))
			{
				return false;
			}
			if (jValue == this)
			{
				return true;
			}
			return ValuesEquals(this, jValue);
		}

		internal static int Compare(JTokenType valueType, object objA, object objB)
		{
			if (objA == null && objB == null)
			{
				return 0;
			}
			if (objA != null && objB == null)
			{
				return 1;
			}
			if (objA == null && objB != null)
			{
				return -1;
			}
			switch (valueType)
			{
			case JTokenType.Integer:
				if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
				{
					return Convert.ToDecimal(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, CultureInfo.InvariantCulture));
				}
				if (objA is float || objB is float || objA is double || objB is double)
				{
					return CompareFloat(objA, objB);
				}
				return Convert.ToInt64(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB, CultureInfo.InvariantCulture));
			case JTokenType.Float:
				return CompareFloat(objA, objB);
			case JTokenType.Comment:
			case JTokenType.String:
			case JTokenType.Raw:
			{
				string strA = Convert.ToString(objA, CultureInfo.InvariantCulture);
				string strB = Convert.ToString(objB, CultureInfo.InvariantCulture);
				return string.CompareOrdinal(strA, strB);
			}
			case JTokenType.Boolean:
			{
				bool flag = Convert.ToBoolean(objA, CultureInfo.InvariantCulture);
				bool value3 = Convert.ToBoolean(objB, CultureInfo.InvariantCulture);
				return flag.CompareTo(value3);
			}
			case JTokenType.Date:
			{
				DateTime dateTime = (DateTime)objA;
				DateTime value2 = Convert.ToDateTime(objB, CultureInfo.InvariantCulture);
				return dateTime.CompareTo(value2);
			}
			case JTokenType.Bytes:
			{
				if (!(objB is byte[]))
				{
					throw new ArgumentException("Object must be of type byte[].");
				}
				byte[] array = objA as byte[];
				byte[] array2 = objB as byte[];
				if (array == null)
				{
					return -1;
				}
				if (array2 == null)
				{
					return 1;
				}
				return Newtonsoft.Json.Utilities.MiscellaneousUtils.ByteArrayCompare(array, array2);
			}
			case JTokenType.Guid:
			{
				if (!(objB is Guid))
				{
					throw new ArgumentException("Object must be of type Guid.");
				}
				Guid guid = (Guid)objA;
				Guid value4 = (Guid)objB;
				return guid.CompareTo(value4);
			}
			case JTokenType.Uri:
			{
				if (!(objB is Uri))
				{
					throw new ArgumentException("Object must be of type Uri.");
				}
				Uri uri = (Uri)objA;
				Uri uri2 = (Uri)objB;
				return Comparer<string>.Default.Compare(uri.ToString(), uri2.ToString());
			}
			case JTokenType.TimeSpan:
			{
				if (!(objB is TimeSpan))
				{
					throw new ArgumentException("Object must be of type TimeSpan.");
				}
				TimeSpan timeSpan = (TimeSpan)objA;
				TimeSpan value = (TimeSpan)objB;
				return timeSpan.CompareTo(value);
			}
			default:
				throw Newtonsoft.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("valueType", valueType, "Unexpected value type: {0}".FormatWith(CultureInfo.InvariantCulture, valueType));
			}
		}

		private static int CompareFloat(object objA, object objB)
		{
			double d = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
			double num = Convert.ToDouble(objB, CultureInfo.InvariantCulture);
			if (Newtonsoft.Json.Utilities.MathUtils.ApproxEquals(d, num))
			{
				return 0;
			}
			return d.CompareTo(num);
		}

		internal override JToken CloneToken()
		{
			return new JValue(this);
		}

		public static JValue CreateComment(string value)
		{
			return new JValue(value, JTokenType.Comment);
		}

		public static JValue CreateString(string value)
		{
			return new JValue(value, JTokenType.String);
		}

		public static JValue CreateNull()
		{
			return new JValue(null, JTokenType.Null);
		}

		public static JValue CreateUndefined()
		{
			return new JValue(null, JTokenType.Undefined);
		}

		private static JTokenType GetValueType(JTokenType? current, object value)
		{
			if (value == null)
			{
				return JTokenType.Null;
			}
			if (value is string)
			{
				return GetStringValueType(current);
			}
			if (value is long || value is int || value is short || value is sbyte || value is ulong || value is uint || value is ushort || value is byte)
			{
				return JTokenType.Integer;
			}
			if (value is Enum)
			{
				return JTokenType.Integer;
			}
			if (value is double || value is float || value is decimal)
			{
				return JTokenType.Float;
			}
			if (value is DateTime)
			{
				return JTokenType.Date;
			}
			if (value is byte[])
			{
				return JTokenType.Bytes;
			}
			if (value is bool)
			{
				return JTokenType.Boolean;
			}
			if (value is Guid)
			{
				return JTokenType.Guid;
			}
			if (value is Uri)
			{
				return JTokenType.Uri;
			}
			if (value is TimeSpan)
			{
				return JTokenType.TimeSpan;
			}
			throw new ArgumentException("Could not determine JSON object type for type {0}.".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
		}

		private static JTokenType GetStringValueType(JTokenType? current)
		{
			if (!current.HasValue)
			{
				return JTokenType.String;
			}
			switch (current.Value)
			{
			case JTokenType.Comment:
			case JTokenType.String:
			case JTokenType.Raw:
				return current.Value;
			default:
				return JTokenType.String;
			}
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			if (converters != null && converters.Length > 0 && _value != null)
			{
				JsonConverter matchingConverter = JsonSerializer.GetMatchingConverter(converters, _value.GetType());
				if (matchingConverter != null && matchingConverter.CanWrite)
				{
					matchingConverter.WriteJson(writer, _value, JsonSerializer.CreateDefault());
					return;
				}
			}
			switch (_valueType)
			{
			case JTokenType.Comment:
				writer.WriteComment((_value == null) ? null : _value.ToString());
				break;
			case JTokenType.Raw:
				writer.WriteRawValue((_value == null) ? null : _value.ToString());
				break;
			case JTokenType.Null:
				writer.WriteNull();
				break;
			case JTokenType.Undefined:
				writer.WriteUndefined();
				break;
			case JTokenType.Integer:
				writer.WriteValue(Convert.ToInt64(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.Float:
				if (_value is decimal)
				{
					writer.WriteValue((decimal)_value);
				}
				else if (_value is double)
				{
					writer.WriteValue((double)_value);
				}
				else if (_value is float)
				{
					writer.WriteValue((float)_value);
				}
				else
				{
					writer.WriteValue(Convert.ToDouble(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.String:
				writer.WriteValue((_value == null) ? null : _value.ToString());
				break;
			case JTokenType.Boolean:
				writer.WriteValue(Convert.ToBoolean(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.Date:
				writer.WriteValue(Convert.ToDateTime(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.Bytes:
				writer.WriteValue((byte[])_value);
				break;
			case JTokenType.Guid:
			case JTokenType.Uri:
			case JTokenType.TimeSpan:
				writer.WriteValue((_value == null) ? null : _value.ToString());
				break;
			default:
				throw Newtonsoft.Json.Utilities.MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", _valueType, "Unexpected token type.");
			}
		}

		internal override int GetDeepHashCode()
		{
			int num = ((_value != null) ? _value.GetHashCode() : 0);
			int valueType = (int)_valueType;
			return valueType.GetHashCode() ^ num;
		}

		private static bool ValuesEquals(JValue v1, JValue v2)
		{
			return v1 == v2 || (v1._valueType == v2._valueType && Compare(v1._valueType, v1._value, v2._value) == 0);
		}

		public bool Equals(JValue other)
		{
			if (other == null)
			{
				return false;
			}
			return ValuesEquals(this, other);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is JValue other)
			{
				return Equals(other);
			}
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			if (_value == null)
			{
				return 0;
			}
			return _value.GetHashCode();
		}

		public override string ToString()
		{
			if (_value == null)
			{
				return string.Empty;
			}
			return _value.ToString();
		}

		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		public string ToString(IFormatProvider formatProvider)
		{
			return ToString(null, formatProvider);
		}

		public string ToString(string format, IFormatProvider formatProvider)
		{
			if (_value == null)
			{
				return string.Empty;
			}
			if (_value is IFormattable formattable)
			{
				return formattable.ToString(format, formatProvider);
			}
			return _value.ToString();
		}

		int IComparable.CompareTo(object obj)
		{
			if (obj == null)
			{
				return 1;
			}
			object objB = ((!(obj is JValue)) ? obj : ((JValue)obj).Value);
			return Compare(_valueType, _value, objB);
		}

		public int CompareTo(JValue obj)
		{
			if (obj == null)
			{
				return 1;
			}
			return Compare(_valueType, _value, obj._value);
		}

		TypeCode IConvertible.GetTypeCode()
		{
			if (_value == null)
			{
				return TypeCode.Empty;
			}
			return System.Type.GetTypeCode(_value.GetType());
		}

		bool IConvertible.ToBoolean(IFormatProvider provider)
		{
			return (bool)(JToken)this;
		}

		char IConvertible.ToChar(IFormatProvider provider)
		{
			return (char)(JToken)this;
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider)
		{
			return (sbyte)(JToken)this;
		}

		byte IConvertible.ToByte(IFormatProvider provider)
		{
			return (byte)(JToken)this;
		}

		short IConvertible.ToInt16(IFormatProvider provider)
		{
			return (short)(JToken)this;
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider)
		{
			return (ushort)(JToken)this;
		}

		int IConvertible.ToInt32(IFormatProvider provider)
		{
			return (int)(JToken)this;
		}

		uint IConvertible.ToUInt32(IFormatProvider provider)
		{
			return (uint)(JToken)this;
		}

		long IConvertible.ToInt64(IFormatProvider provider)
		{
			return (long)(JToken)this;
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider)
		{
			return (ulong)(JToken)this;
		}

		float IConvertible.ToSingle(IFormatProvider provider)
		{
			return (float)(JToken)this;
		}

		double IConvertible.ToDouble(IFormatProvider provider)
		{
			return (double)(JToken)this;
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider)
		{
			return (decimal)(JToken)this;
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider)
		{
			return (DateTime)(JToken)this;
		}

		object IConvertible.ToType(Type conversionType, IFormatProvider provider)
		{
			return ToObject(conversionType);
		}
	}
	public class JsonMergeSettings
	{
		private MergeArrayHandling _mergeArrayHandling;

		public MergeArrayHandling MergeArrayHandling
		{
			get
			{
				return _mergeArrayHandling;
			}
			set
			{
				if (value < MergeArrayHandling.Concat || value > MergeArrayHandling.Merge)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_mergeArrayHandling = value;
			}
		}
	}
}
namespace Newtonsoft.Json.Linq.JsonPath
{
	internal class ArrayIndexFilter : PathFilter
	{
		public int? Index { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				if (Index.HasValue)
				{
					JToken v = PathFilter.GetTokenIndex(t, errorWhenNoMatch, Index.Value);
					if (v != null)
					{
						yield return v;
					}
				}
				else if (t is JArray || t is JConstructor)
				{
					foreach (JToken item in (IEnumerable<JToken>)t)
					{
						yield return item;
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Index * not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, t.GetType().Name));
				}
			}
		}
	}
	internal class ArrayMultipleIndexFilter : PathFilter
	{
		public List<int> Indexes { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				foreach (int i in Indexes)
				{
					JToken v = PathFilter.GetTokenIndex(t, errorWhenNoMatch, i);
					if (v != null)
					{
						yield return v;
					}
				}
			}
		}
	}
	internal class ArraySliceFilter : PathFilter
	{
		public int? Start { get; set; }

		public int? End { get; set; }

		public int? Step { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			int? step = Step;
			if (step.GetValueOrDefault() == 0 && step.HasValue)
			{
				throw new JsonException("Step cannot be zero.");
			}
			foreach (JToken t in current)
			{
				if (t is JArray a)
				{
					int? step2 = Step;
					int stepCount = ((!step2.HasValue) ? 1 : step2.Value);
					int? start = Start;
					int startIndex = (start.HasValue ? start.Value : ((stepCount <= 0) ? (a.Count - 1) : 0));
					int? end = End;
					int stopIndex = (end.HasValue ? end.Value : ((stepCount <= 0) ? (-1) : a.Count));
					int? start2 = Start;
					if (start2.HasValue && start2.GetValueOrDefault() < 0)
					{
						startIndex = a.Count + startIndex;
					}
					int? end2 = End;
					if (end2.HasValue && end2.GetValueOrDefault() < 0)
					{
						stopIndex = a.Count + stopIndex;
					}
					startIndex = Math.Max(startIndex, (stepCount <= 0) ? int.MinValue : 0);
					startIndex = Math.Min(startIndex, (stepCount <= 0) ? (a.Count - 1) : a.Count);
					stopIndex = Math.Max(stopIndex, -1);
					stopIndex = Math.Min(stopIndex, a.Count);
					bool positiveStep = stepCount > 0;
					if (IsValid(startIndex, stopIndex, positiveStep))
					{
						for (int i = startIndex; IsValid(i, stopIndex, positiveStep); i += stepCount)
						{
							yield return a[i];
						}
					}
					else if (errorWhenNoMatch)
					{
						throw new JsonException("Array slice of {0} to {1} returned no results.".FormatWith(CultureInfo.InvariantCulture, (!Start.HasValue) ? "*" : Start.Value.ToString(CultureInfo.InvariantCulture), (!End.HasValue) ? "*" : End.Value.ToString(CultureInfo.InvariantCulture)));
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Array slice is not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, t.GetType().Name));
				}
			}
		}

		private bool IsValid(int index, int stopIndex, bool positiveStep)
		{
			if (positiveStep)
			{
				return index < stopIndex;
			}
			return index > stopIndex;
		}
	}
	internal class FieldFilter : PathFilter
	{
		public string Name { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				if (t is JObject o)
				{
					if (Name != null)
					{
						JToken v = o[Name];
						if (v != null)
						{
							yield return v;
						}
						else if (errorWhenNoMatch)
						{
							throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, Name));
						}
						continue;
					}
					foreach (KeyValuePair<string, JToken> item in o)
					{
						yield return item.Value;
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Property '{0}' not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, Name ?? "*", t.GetType().Name));
				}
			}
		}
	}
	internal class FieldMultipleFilter : PathFilter
	{
		public List<string> Names { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				if (t is JObject o)
				{
					foreach (string name in Names)
					{
						JToken v = o[name];
						if (v != null)
						{
							yield return v;
						}
						if (errorWhenNoMatch)
						{
							throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, name));
						}
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Properties {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, string.Join(", ", Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Select(Names, (string n) => "'" + n + "'"))), t.GetType().Name));
				}
			}
		}
	}
	internal class JPath
	{
		private readonly string _expression;

		private int _currentIndex;

		public List<PathFilter> Filters { get; private set; }

		public JPath(string expression)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(expression, "expression");
			_expression = expression;
			Filters = new List<PathFilter>();
			ParseMain();
		}

		private void ParseMain()
		{
			int currentIndex = _currentIndex;
			EatWhitespace();
			if (_expression.Length == _currentIndex)
			{
				return;
			}
			if (_expression[_currentIndex] == '$')
			{
				if (_expression.Length == 1)
				{
					return;
				}
				char c = _expression[_currentIndex + 1];
				if (c == '.' || c == '[')
				{
					_currentIndex++;
					currentIndex = _currentIndex;
				}
			}
			if (!ParsePath(Filters, currentIndex, query: false))
			{
				int currentIndex2 = _currentIndex;
				EatWhitespace();
				if (_currentIndex < _expression.Length)
				{
					throw new JsonException("Unexpected character while parsing path: " + _expression[currentIndex2]);
				}
			}
		}

		private bool ParsePath(List<PathFilter> filters, int currentPartStartIndex, bool query)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			while (_currentIndex < _expression.Length && !flag4)
			{
				char c = _expression[_currentIndex];
				switch (c)
				{
				case '(':
				case '[':
					if (_currentIndex > currentPartStartIndex)
					{
						string name = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
						object obj2;
						if (flag)
						{
							ScanFilter scanFilter = new ScanFilter();
							scanFilter.Name = name;
							obj2 = scanFilter;
						}
						else
						{
							FieldFilter fieldFilter = new FieldFilter();
							fieldFilter.Name = name;
							obj2 = fieldFilter;
						}
						PathFilter item2 = (PathFilter)obj2;
						filters.Add(item2);
						flag = false;
					}
					filters.Add(ParseIndexer(c));
					_currentIndex++;
					currentPartStartIndex = _currentIndex;
					flag2 = true;
					flag3 = false;
					break;
				case ')':
				case ']':
					flag4 = true;
					break;
				case ' ':
					if (_currentIndex < _expression.Length)
					{
						flag4 = true;
					}
					break;
				case '.':
					if (_currentIndex > currentPartStartIndex)
					{
						string text = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
						if (text == "*")
						{
							text = null;
						}
						object obj;
						if (flag)
						{
							ScanFilter scanFilter = new ScanFilter();
							scanFilter.Name = text;
							obj = scanFilter;
						}
						else
						{
							FieldFilter fieldFilter = new FieldFilter();
							fieldFilter.Name = text;
							obj = fieldFilter;
						}
						PathFilter item = (PathFilter)obj;
						filters.Add(item);
						flag = false;
					}
					if (_currentIndex + 1 < _expression.Length && _expression[_currentIndex + 1] == '.')
					{
						flag = true;
						_currentIndex++;
					}
					_currentIndex++;
					currentPartStartIndex = _currentIndex;
					flag2 = false;
					flag3 = true;
					break;
				default:
					if (query && (c == '=' || c == '<' || c == '!' || c == '>' || c == '|' || c == '&'))
					{
						flag4 = true;
						break;
					}
					if (flag2)
					{
						throw new JsonException("Unexpected character following indexer: " + c);
					}
					_currentIndex++;
					break;
				}
			}
			bool flag5 = _currentIndex == _expression.Length;
			if (_currentIndex > currentPartStartIndex)
			{
				string text2 = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex).TrimEnd();
				if (text2 == "*")
				{
					text2 = null;
				}
				object obj3;
				if (flag)
				{
					ScanFilter scanFilter = new ScanFilter();
					scanFilter.Name = text2;
					obj3 = scanFilter;
				}
				else
				{
					FieldFilter fieldFilter = new FieldFilter();
					fieldFilter.Name = text2;
					obj3 = fieldFilter;
				}
				PathFilter item3 = (PathFilter)obj3;
				filters.Add(item3);
			}
			else if (flag3 && (flag5 || query))
			{
				throw new JsonException("Unexpected end while parsing path.");
			}
			return flag5;
		}

		private PathFilter ParseIndexer(char indexerOpenChar)
		{
			_currentIndex++;
			char indexerCloseChar = ((indexerOpenChar != '[') ? ')' : ']');
			EnsureLength("Path ended with open indexer.");
			EatWhitespace();
			if (_expression[_currentIndex] == '\'')
			{
				return ParseQuotedField(indexerCloseChar);
			}
			if (_expression[_currentIndex] == '?')
			{
				return ParseQuery(indexerCloseChar);
			}
			return ParseArrayIndexer(indexerCloseChar);
		}

		private PathFilter ParseArrayIndexer(char indexerCloseChar)
		{
			int currentIndex = _currentIndex;
			int? num = null;
			List<int> list = null;
			int num2 = 0;
			int? start = null;
			int? end = null;
			int? step = null;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				if (c == ' ')
				{
					num = _currentIndex;
					EatWhitespace();
					continue;
				}
				if (c == indexerCloseChar)
				{
					int num3 = ((!num.HasValue) ? _currentIndex : num.Value) - currentIndex;
					if (list != null)
					{
						if (num3 == 0)
						{
							throw new JsonException("Array index expected.");
						}
						string value = _expression.Substring(currentIndex, num3);
						int item = Convert.ToInt32(value, CultureInfo.InvariantCulture);
						list.Add(item);
						ArrayMultipleIndexFilter arrayMultipleIndexFilter = new ArrayMultipleIndexFilter();
						arrayMultipleIndexFilter.Indexes = list;
						return arrayMultipleIndexFilter;
					}
					if (num2 > 0)
					{
						if (num3 > 0)
						{
							string value2 = _expression.Substring(currentIndex, num3);
							int value3 = Convert.ToInt32(value2, CultureInfo.InvariantCulture);
							if (num2 == 1)
							{
								end = value3;
							}
							else
							{
								step = value3;
							}
						}
						ArraySliceFilter arraySliceFilter = new ArraySliceFilter();
						arraySliceFilter.Start = start;
						arraySliceFilter.End = end;
						arraySliceFilter.Step = step;
						return arraySliceFilter;
					}
					if (num3 == 0)
					{
						throw new JsonException("Array index expected.");
					}
					string value4 = _expression.Substring(currentIndex, num3);
					int value5 = Convert.ToInt32(value4, CultureInfo.InvariantCulture);
					ArrayIndexFilter arrayIndexFilter = new ArrayIndexFilter();
					arrayIndexFilter.Index = value5;
					return arrayIndexFilter;
				}
				switch (c)
				{
				case ',':
				{
					int num5 = ((!num.HasValue) ? _currentIndex : num.Value) - currentIndex;
					if (num5 == 0)
					{
						throw new JsonException("Array index expected.");
					}
					if (list == null)
					{
						list = new List<int>();
					}
					string value8 = _expression.Substring(currentIndex, num5);
					list.Add(Convert.ToInt32(value8, CultureInfo.InvariantCulture));
					_currentIndex++;
					EatWhitespace();
					currentIndex = _currentIndex;
					num = null;
					break;
				}
				case '*':
					_currentIndex++;
					EnsureLength("Path ended with open indexer.");
					EatWhitespace();
					if (_expression[_currentIndex] != indexerCloseChar)
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					return new ArrayIndexFilter();
				case ':':
				{
					int num4 = ((!num.HasValue) ? _currentIndex : num.Value) - currentIndex;
					if (num4 > 0)
					{
						string value6 = _expression.Substring(currentIndex, num4);
						int value7 = Convert.ToInt32(value6, CultureInfo.InvariantCulture);
						switch (num2)
						{
						case 0:
							start = value7;
							break;
						case 1:
							end = value7;
							break;
						default:
							step = value7;
							break;
						}
					}
					num2++;
					_currentIndex++;
					EatWhitespace();
					currentIndex = _currentIndex;
					num = null;
					break;
				}
				default:
					if (!char.IsDigit(c) && c != '-')
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					if (num.HasValue)
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					_currentIndex++;
					break;
				}
			}
			throw new JsonException("Path ended with open indexer.");
		}

		private void EatWhitespace()
		{
			while (_currentIndex < _expression.Length && _expression[_currentIndex] == ' ')
			{
				_currentIndex++;
			}
		}

		private PathFilter ParseQuery(char indexerCloseChar)
		{
			_currentIndex++;
			EnsureLength("Path ended with open indexer.");
			if (_expression[_currentIndex] != '(')
			{
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			_currentIndex++;
			QueryExpression expression = ParseExpression();
			_currentIndex++;
			EnsureLength("Path ended with open indexer.");
			EatWhitespace();
			if (_expression[_currentIndex] != indexerCloseChar)
			{
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			QueryFilter queryFilter = new QueryFilter();
			queryFilter.Expression = expression;
			return queryFilter;
		}

		private QueryExpression ParseExpression()
		{
			QueryExpression queryExpression = null;
			CompositeExpression compositeExpression = null;
			while (_currentIndex < _expression.Length)
			{
				EatWhitespace();
				if (_expression[_currentIndex] != '@')
				{
					throw new JsonException("Unexpected character while parsing path query: " + _expression[_currentIndex]);
				}
				_currentIndex++;
				List<PathFilter> list = new List<PathFilter>();
				if (ParsePath(list, _currentIndex, query: true))
				{
					throw new JsonException("Path ended with open query.");
				}
				EatWhitespace();
				EnsureLength("Path ended with open query.");
				object value = null;
				QueryOperator queryOperator;
				if (_expression[_currentIndex] == ')' || _expression[_currentIndex] == '|' || _expression[_currentIndex] == '&')
				{
					queryOperator = QueryOperator.Exists;
				}
				else
				{
					queryOperator = ParseOperator();
					EatWhitespace();
					EnsureLength("Path ended with open query.");
					value = ParseValue();
					EatWhitespace();
					EnsureLength("Path ended with open query.");
				}
				BooleanQueryExpression booleanQueryExpression = new BooleanQueryExpression();
				booleanQueryExpression.Path = list;
				booleanQueryExpression.Operator = queryOperator;
				booleanQueryExpression.Value = ((queryOperator == QueryOperator.Exists) ? null : new JValue(value));
				BooleanQueryExpression booleanQueryExpression2 = booleanQueryExpression;
				if (_expression[_currentIndex] == ')')
				{
					if (compositeExpression != null)
					{
						compositeExpression.Expressions.Add(booleanQueryExpression2);
						return queryExpression;
					}
					return booleanQueryExpression2;
				}
				if (_expression[_currentIndex] == '&' && Match("&&"))
				{
					if (compositeExpression == null || compositeExpression.Operator != QueryOperator.And)
					{
						CompositeExpression compositeExpression2 = new CompositeExpression();
						compositeExpression2.Operator = QueryOperator.And;
						CompositeExpression compositeExpression3 = compositeExpression2;
						compositeExpression?.Expressions.Add(compositeExpression3);
						compositeExpression = compositeExpression3;
						if (queryExpression == null)
						{
							queryExpression = compositeExpression;
						}
					}
					compositeExpression.Expressions.Add(booleanQueryExpression2);
				}
				if (_expression[_currentIndex] != '|' || !Match("||"))
				{
					continue;
				}
				if (compositeExpression == null || compositeExpression.Operator != QueryOperator.Or)
				{
					CompositeExpression compositeExpression2 = new CompositeExpression();
					compositeExpression2.Operator = QueryOperator.Or;
					CompositeExpression compositeExpression4 = compositeExpression2;
					compositeExpression?.Expressions.Add(compositeExpression4);
					compositeExpression = compositeExpression4;
					if (queryExpression == null)
					{
						queryExpression = compositeExpression;
					}
				}
				compositeExpression.Expressions.Add(booleanQueryExpression2);
			}
			throw new JsonException("Path ended with open query.");
		}

		private object ParseValue()
		{
			char c = _expression[_currentIndex];
			if (c == '\'')
			{
				return ReadQuotedString();
			}
			if (char.IsDigit(c) || c == '-')
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(c);
				_currentIndex++;
				while (_currentIndex < _expression.Length)
				{
					c = _expression[_currentIndex];
					if (c == ' ' || c == ')')
					{
						string text = stringBuilder.ToString();
						if (text.IndexOfAny(new char[3] { '.', 'E', 'e' }) != -1)
						{
							if (double.TryParse(text, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var result))
							{
								return result;
							}
							throw new JsonException("Could not read query value.");
						}
						if (long.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result2))
						{
							return result2;
						}
						throw new JsonException("Could not read query value.");
					}
					stringBuilder.Append(c);
					_currentIndex++;
				}
			}
			else
			{
				switch (c)
				{
				case 't':
					if (Match("true"))
					{
						return true;
					}
					break;
				case 'f':
					if (Match("false"))
					{
						return false;
					}
					break;
				case 'n':
					if (Match("null"))
					{
						return null;
					}
					break;
				}
			}
			throw new JsonException("Could not read query value.");
		}

		private string ReadQuotedString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			_currentIndex++;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				if (c == '\\' && _currentIndex + 1 < _expression.Length)
				{
					_currentIndex++;
					if (_expression[_currentIndex] == '\'')
					{
						stringBuilder.Append('\'');
					}
					else
					{
						if (_expression[_currentIndex] != '\\')
						{
							throw new JsonException("Unknown escape chracter: \\" + _expression[_currentIndex]);
						}
						stringBuilder.Append('\\');
					}
					_currentIndex++;
				}
				else
				{
					if (c == '\'')
					{
						_currentIndex++;
						return stringBuilder.ToString();
					}
					_currentIndex++;
					stringBuilder.Append(c);
				}
			}
			throw new JsonException("Path ended with an open string.");
		}

		private bool Match(string s)
		{
			int num = _currentIndex;
			foreach (char c in s)
			{
				if (num < _expression.Length && _expression[num] == c)
				{
					num++;
					continue;
				}
				return false;
			}
			_currentIndex = num;
			return true;
		}

		private QueryOperator ParseOperator()
		{
			if (_currentIndex + 1 >= _expression.Length)
			{
				throw new JsonException("Path ended with open query.");
			}
			if (Match("=="))
			{
				return QueryOperator.Equals;
			}
			if (Match("!=") || Match("<>"))
			{
				return QueryOperator.NotEquals;
			}
			if (Match("<="))
			{
				return QueryOperator.LessThanOrEquals;
			}
			if (Match("<"))
			{
				return QueryOperator.LessThan;
			}
			if (Match(">="))
			{
				return QueryOperator.GreaterThanOrEquals;
			}
			if (Match(">"))
			{
				return QueryOperator.GreaterThan;
			}
			throw new JsonException("Could not read query operator.");
		}

		private PathFilter ParseQuotedField(char indexerCloseChar)
		{
			List<string> list = null;
			while (_currentIndex < _expression.Length)
			{
				string text = ReadQuotedString();
				EatWhitespace();
				EnsureLength("Path ended with open indexer.");
				if (_expression[_currentIndex] == indexerCloseChar)
				{
					if (list != null)
					{
						list.Add(text);
						FieldMultipleFilter fieldMultipleFilter = new FieldMultipleFilter();
						fieldMultipleFilter.Names = list;
						return fieldMultipleFilter;
					}
					FieldFilter fieldFilter = new FieldFilter();
					fieldFilter.Name = text;
					return fieldFilter;
				}
				if (_expression[_currentIndex] == ',')
				{
					_currentIndex++;
					EatWhitespace();
					if (list == null)
					{
						list = new List<string>();
					}
					list.Add(text);
					continue;
				}
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			throw new JsonException("Path ended with open indexer.");
		}

		private void EnsureLength(string message)
		{
			if (_currentIndex >= _expression.Length)
			{
				throw new JsonException(message);
			}
		}

		internal IEnumerable<JToken> Evaluate(JToken t, bool errorWhenNoMatch)
		{
			return Evaluate(Filters, t, errorWhenNoMatch);
		}

		internal static IEnumerable<JToken> Evaluate(List<PathFilter> filters, JToken t, bool errorWhenNoMatch)
		{
			IEnumerable<JToken> enumerable = new JToken[1] { t };
			foreach (PathFilter filter in filters)
			{
				enumerable = filter.ExecuteFilter(enumerable, errorWhenNoMatch);
			}
			return enumerable;
		}
	}
	internal abstract class PathFilter
	{
		public abstract IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch);

		protected static JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index)
		{
			JArray jArray = t as JArray;
			JConstructor jConstructor = t as JConstructor;
			if (jArray != null)
			{
				if (jArray.Count <= index)
				{
					if (errorWhenNoMatch)
					{
						throw new JsonException("Index {0} outside the bounds of JArray.".FormatWith(CultureInfo.InvariantCulture, index));
					}
					return null;
				}
				return jArray[index];
			}
			if (jConstructor != null)
			{
				if (jConstructor.Count <= index)
				{
					if (errorWhenNoMatch)
					{
						throw new JsonException("Index {0} outside the bounds of JConstructor.".FormatWith(CultureInfo.InvariantCulture, index));
					}
					return null;
				}
				return jConstructor[index];
			}
			if (errorWhenNoMatch)
			{
				throw new JsonException("Index {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, index, t.GetType().Name));
			}
			return null;
		}
	}
	internal enum QueryOperator
	{
		None,
		Equals,
		NotEquals,
		Exists,
		LessThan,
		LessThanOrEquals,
		GreaterThan,
		GreaterThanOrEquals,
		And,
		Or
	}
	internal abstract class QueryExpression
	{
		public QueryOperator Operator { get; set; }

		public abstract bool IsMatch(JToken t);
	}
	internal class CompositeExpression : QueryExpression
	{
		public List<QueryExpression> Expressions { get; set; }

		public CompositeExpression()
		{
			Expressions = new List<QueryExpression>();
		}

		public override bool IsMatch(JToken t)
		{
			switch (base.Operator)
			{
			case QueryOperator.And:
				foreach (QueryExpression expression in Expressions)
				{
					if (!expression.IsMatch(t))
					{
						return false;
					}
				}
				return true;
			case QueryOperator.Or:
				foreach (QueryExpression expression2 in Expressions)
				{
					if (expression2.IsMatch(t))
					{
						return true;
					}
				}
				return false;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}
	internal class BooleanQueryExpression : QueryExpression
	{
		public List<PathFilter> Path { get; set; }

		public JValue Value { get; set; }

		public override bool IsMatch(JToken t)
		{
			IEnumerable<JToken> enumerable = JPath.Evaluate(Path, t, errorWhenNoMatch: false);
			foreach (JToken item in enumerable)
			{
				JValue jValue = item as JValue;
				switch (base.Operator)
				{
				case QueryOperator.Equals:
					if (jValue != null && jValue.Equals(Value))
					{
						return true;
					}
					break;
				case QueryOperator.NotEquals:
					if (jValue != null && !jValue.Equals(Value))
					{
						return true;
					}
					break;
				case QueryOperator.GreaterThan:
					if (jValue != null && jValue.CompareTo(Value) > 0)
					{
						return true;
					}
					break;
				case QueryOperator.GreaterThanOrEquals:
					if (jValue != null && jValue.CompareTo(Value) >= 0)
					{
						return true;
					}
					break;
				case QueryOperator.LessThan:
					if (jValue != null && jValue.CompareTo(Value) < 0)
					{
						return true;
					}
					break;
				case QueryOperator.LessThanOrEquals:
					if (jValue != null && jValue.CompareTo(Value) <= 0)
					{
						return true;
					}
					break;
				case QueryOperator.Exists:
					return true;
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
			return false;
		}
	}
	internal class QueryFilter : PathFilter
	{
		public QueryExpression Expression { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				foreach (JToken v in (IEnumerable<JToken>)t)
				{
					if (Expression.IsMatch(v))
					{
						yield return v;
					}
				}
			}
		}
	}
	internal class ScanFilter : PathFilter
	{
		public string Name { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken root in current)
			{
				if (Name == null)
				{
					yield return root;
				}
				JToken value = root;
				JToken container = root;
				while (true)
				{
					if (container != null && container.HasValues)
					{
						value = container.First;
					}
					else
					{
						while (value != null && value != root && value == value.Parent.Last)
						{
							value = value.Parent;
						}
						if (value == null || value == root)
						{
							break;
						}
						value = value.Next;
					}
					if (value is JProperty e)
					{
						if (e.Name == Name)
						{
							yield return e.Value;
						}
					}
					else if (Name == null)
					{
						yield return value;
					}
					container = value as JContainer;
				}
			}
		}
	}
}
namespace Newtonsoft.Json.Linq
{
	public enum MergeArrayHandling
	{
		Concat,
		Union,
		Replace,
		Merge
	}
}
namespace Newtonsoft.Json
{
	public enum MemberSerialization
	{
		OptOut,
		OptIn,
		Fields
	}
	public enum MetadataPropertyHandling
	{
		Default,
		ReadAhead,
		Ignore
	}
	public enum MissingMemberHandling
	{
		Ignore,
		Error
	}
	public enum NullValueHandling
	{
		Include,
		Ignore
	}
	public enum ObjectCreationHandling
	{
		Auto,
		Reuse,
		Replace
	}
	[Flags]
	public enum PreserveReferencesHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		All = 3
	}
	public enum ReferenceLoopHandling
	{
		Error,
		Ignore,
		Serialize
	}
	public enum Required
	{
		Default,
		AllowNull,
		Always
	}
}
namespace Newtonsoft.Json.Serialization
{
	internal static class CachedAttributeGetter<T> where T : Attribute
	{
		public static T GetAttribute(object type)
		{
			return JsonTypeReflector.GetAttribute<T>(type);
		}
	}
	public class CamelCasePropertyNamesContractResolver : DefaultContractResolver
	{
		public CamelCasePropertyNamesContractResolver()
			: base(shareCache: true)
		{
		}

		protected internal override string ResolvePropertyName(string propertyName)
		{
			return Newtonsoft.Json.Utilities.StringUtils.ToCamelCase(propertyName);
		}
	}
	internal struct ResolverContractKey : IEquatable<ResolverContractKey>
	{
		private readonly Type _resolverType;

		private readonly Type _contractType;

		public ResolverContractKey(Type resolverType, Type contractType)
		{
			_resolverType = resolverType;
			_contractType = contractType;
		}

		public override int GetHashCode()
		{
			return _resolverType.GetHashCode() ^ _contractType.GetHashCode();
		}

		public string GetStringKey()
		{
			return TypeKeyMaker.MakeKey(_resolverType) + "/" + TypeKeyMaker.MakeKey(_contractType);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is ResolverContractKey))
			{
				return false;
			}
			return Equals((ResolverContractKey)obj);
		}

		public bool Equals(ResolverContractKey other)
		{
			return _resolverType == other._resolverType && _contractType == other._contractType;
		}
	}
	internal class DefaultContractResolverState
	{
		public Dictionary<string, JsonContract> ContractCache;

		public PropertyNameTable NameTable = new PropertyNameTable();
	}
	public class DefaultContractResolver : IContractResolver
	{
		internal struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IEnumerable<KeyValuePair<object, object>>, IEnumerator<KeyValuePair<object, object>>, IEnumerable, IEnumerator, IDisposable
		{
			private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

			object IEnumerator.Current => Current;

			public KeyValuePair<object, object> Current => new KeyValuePair<object, object>(_e.Current.Key, _e.Current.Value);

			public DictionaryEnumerator(IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
			{
				Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(e, "e");
				_e = e.GetEnumerator();
			}

			public bool MoveNext()
			{
				return _e.MoveNext();
			}

			public void Reset()
			{
				_e.Reset();
			}

			public void Dispose()
			{
				_e.Dispose();
			}

			public IEnumerator<KeyValuePair<object, object>> GetEnumerator()
			{
				return this;
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return this;
			}
		}

		private static readonly IContractResolver _instance = new DefaultContractResolver(shareCache: true);

		private static readonly JsonConverter[] BuiltInConverters = new JsonConverter[2]
		{
			new Newtonsoft.Json.Converters.KeyValuePairConverter(),
			new RegexConverter()
		};

		private static readonly DefaultContractResolverState _sharedState = new DefaultContractResolverState();

		private readonly DefaultContractResolverState _instanceState = new DefaultContractResolverState();

		private readonly bool _sharedCache;

		internal static IContractResolver Instance => _instance;

		[Obsolete("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
		public BindingFlags DefaultMembersSearchFlags { get; set; }

		public bool SerializeCompilerGeneratedMembers { get; set; }

		public bool IgnoreSerializableInterface { get; set; }

		public bool IgnoreSerializableAttribute { get; set; }

		public DefaultContractResolver()
			: this(shareCache: false)
		{
		}

		public DefaultContractResolver(bool shareCache)
		{
			DefaultMembersSearchFlags = BindingFlags.Instance | BindingFlags.Public;
			IgnoreSerializableAttribute = true;
			_sharedCache = shareCache;
		}

		internal DefaultContractResolverState GetState()
		{
			if (_sharedCache)
			{
				return _sharedState;
			}
			return _instanceState;
		}

		public virtual JsonContract ResolveContract(Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			DefaultContractResolverState state = GetState();
			ResolverContractKey resolverContractKey = new ResolverContractKey(GetType(), type);
			Dictionary<string, JsonContract> contractCache = state.ContractCache;
			string stringKey = resolverContractKey.GetStringKey();
			if (contractCache == null || !contractCache.TryGetValue(stringKey, out var value))
			{
				value = CreateContract(type);
				contractCache = state.ContractCache;
				Dictionary<string, JsonContract> dictionary = ((contractCache == null) ? new Dictionary<string, JsonContract>() : new Dictionary<string, JsonContract>(contractCache));
				dictionary[stringKey] = value;
				state.ContractCache = dictionary;
			}
			return value;
		}

		protected virtual List<MemberInfo> GetSerializableMembers(Type objectType)
		{
			bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
			MemberSerialization objectMemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType, ignoreSerializableAttribute);
			List<MemberInfo> list = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(Newtonsoft.Json.Utilities.ReflectionUtils.GetFieldsAndProperties(objectType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic), (MemberInfo m) => !Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(m)));
			List<MemberInfo> list2 = new List<MemberInfo>();
			if (objectMemberSerialization != MemberSerialization.Fields)
			{
				List<MemberInfo> list3 = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(Newtonsoft.Json.Utilities.ReflectionUtils.GetFieldsAndProperties(objectType, DefaultMembersSearchFlags), (MemberInfo m) => !Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(m)));
				foreach (MemberInfo item in list)
				{
					if (SerializeCompilerGeneratedMembers || !item.IsDefined(typeof(CompilerGeneratedAttribute), inherit: true))
					{
						if (list3.Contains(item))
						{
							list2.Add(item);
						}
						else if (JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(item) != null)
						{
							list2.Add(item);
						}
						else if (objectMemberSerialization == MemberSerialization.Fields && item.MemberType() == MemberTypes.Field)
						{
							list2.Add(item);
						}
					}
				}
			}
			else
			{
				foreach (MemberInfo item2 in list)
				{
					if (item2 is FieldInfo { IsStatic: false })
					{
						list2.Add(item2);
					}
				}
			}
			return list2;
		}

		protected virtual JsonObjectContract CreateObjectContract(Type objectType)
		{
			JsonObjectContract jsonObjectContract = new JsonObjectContract(objectType);
			InitializeContract(jsonObjectContract);
			bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
			jsonObjectContract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(jsonObjectContract.NonNullableUnderlyingType, ignoreSerializableAttribute);
			Newtonsoft.Json.Utilities.CollectionUtils.AddRange(jsonObjectContract.Properties, CreateProperties(jsonObjectContract.NonNullableUnderlyingType, jsonObjectContract.MemberSerialization));
			JsonObjectAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonObjectAttribute>(jsonObjectContract.NonNullableUnderlyingType);
			if (cachedAttribute != null)
			{
				jsonObjectContract.ItemRequired = cachedAttribute._itemRequired;
			}
			if (jsonObjectContract.IsInstantiable)
			{
				ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonObjectContract.NonNullableUnderlyingType);
				if (attributeConstructor != null)
				{
					jsonObjectContract.OverrideConstructor = attributeConstructor;
					Newtonsoft.Json.Utilities.CollectionUtils.AddRange(jsonObjectContract.CreatorParameters, CreateConstructorParameters(attributeConstructor, jsonObjectContract.Properties));
				}
				else if (jsonObjectContract.MemberSerialization == MemberSerialization.Fields)
				{
					if (JsonTypeReflector.FullyTrusted)
					{
						jsonObjectContract.DefaultCreator = jsonObjectContract.GetUninitializedObject;
					}
				}
				else if (jsonObjectContract.DefaultCreator == null || jsonObjectContract.DefaultCreatorNonPublic)
				{
					ConstructorInfo parametrizedConstructor = GetParametrizedConstructor(jsonObjectContract.NonNullableUnderlyingType);
					if (parametrizedConstructor != null)
					{
						jsonObjectContract.ParametrizedConstructor = parametrizedConstructor;
						Newtonsoft.Json.Utilities.CollectionUtils.AddRange(jsonObjectContract.CreatorParameters, CreateConstructorParameters(parametrizedConstructor, jsonObjectContract.Properties));
					}
				}
			}
			MemberInfo extensionDataMemberForType = GetExtensionDataMemberForType(jsonObjectContract.NonNullableUnderlyingType);
			if (extensionDataMemberForType != null)
			{
				SetExtensionDataDelegates(jsonObjectContract, extensionDataMemberForType);
			}
			return jsonObjectContract;
		}

		private MemberInfo GetExtensionDataMemberForType(Type type)
		{
			IEnumerable<MemberInfo> source = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SelectMany(GetClassHierarchyForType(type), delegate(Type baseType)
			{
				IList<MemberInfo> list = new List<MemberInfo>();
				Newtonsoft.Json.Utilities.CollectionUtils.AddRange(list, baseType.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
				Newtonsoft.Json.Utilities.CollectionUtils.AddRange(list, baseType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
				return list;
			});
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.LastOrDefault(source, delegate(MemberInfo m)
			{
				MemberTypes memberTypes = m.MemberType();
				if (memberTypes != MemberTypes.Property && memberTypes != MemberTypes.Field)
				{
					return false;
				}
				if (!m.IsDefined(typeof(JsonExtensionDataAttribute), inherit: false))
				{
					return false;
				}
				Type memberUnderlyingType = Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(m);
				if (Newtonsoft.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >), out var implementingType))
				{
					Type type2 = implementingType.GetGenericArguments()[0];
					Type type3 = implementingType.GetGenericArguments()[1];
					if (type2.IsAssignableFrom(typeof(string)) && type3.IsAssignableFrom(typeof(Newtonsoft.Json.Linq.JToken)))
					{
						return true;
					}
				}
				throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' type must implement IDictionary<string, JToken>.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(m.DeclaringType), m.Name));
			});
		}

		private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member)
		{
			JsonExtensionDataAttribute attribute = Newtonsoft.Json.Utilities.ReflectionUtils.GetAttribute<JsonExtensionDataAttribute>(member);
			if (attribute == null)
			{
				return;
			}
			Type memberUnderlyingType = Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(member);
			Newtonsoft.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >), out var implementingType);
			Type type = implementingType.GetGenericArguments()[0];
			Type type2 = implementingType.GetGenericArguments()[1];
			bool isJTokenValueType = typeof(Newtonsoft.Json.Linq.JToken).IsAssignableFrom(type2);
			Type type3 = ((!Newtonsoft.Json.Utilities.ReflectionUtils.IsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >))) ? memberUnderlyingType : typeof(Dictionary<, >).MakeGenericType(type, type2));
			MethodInfo method = memberUnderlyingType.GetMethod("Add", new Type[2] { type, type2 });
			Func<object, object> getExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(member);
			Action<object, object> setExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(member);
			Func<object> createExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type3);
			Newtonsoft.Json.Utilities.MethodCall<object, object> setExtensionDataDictionaryValue = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			ExtensionDataSetter extensionDataSetter = delegate(object o, string key, object value)
			{
				object obj2 = getExtensionDataDictionary(o);
				if (obj2 == null)
				{
					obj2 = createExtensionDataDictionary();
					setExtensionDataDictionary(o, obj2);
				}
				if (isJTokenValueType && !(value is Newtonsoft.Json.Linq.JToken))
				{
					value = ((value == null) ? Newtonsoft.Json.Linq.JValue.CreateNull() : Newtonsoft.Json.Linq.JToken.FromObject(value));
				}
				setExtensionDataDictionaryValue(obj2, key, value);
			};
			Type type4 = typeof(DictionaryEnumerator<, >).MakeGenericType(type, type2);
			ConstructorInfo method2 = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.First(type4.GetConstructors());
			ObjectConstructor<object> createEnumerableWrapper = JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(method2);
			ExtensionDataGetter extensionDataGetter = delegate(object o)
			{
				object obj = getExtensionDataDictionary(o);
				return (obj == null) ? null : ((IEnumerable<KeyValuePair<object, object>>)createEnumerableWrapper(obj));
			};
			if (attribute.ReadData)
			{
				contract.ExtensionDataSetter = extensionDataSetter;
			}
			if (attribute.WriteData)
			{
				contract.ExtensionDataGetter = extensionDataGetter;
			}
		}

		private ConstructorInfo GetAttributeConstructor(Type objectType)
		{
			IList<ConstructorInfo> list = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic), (ConstructorInfo c) => c.IsDefined(typeof(JsonConstructorAttribute), inherit: true)));
			if (list.Count > 1)
			{
				throw new JsonException("Multiple constructors with the JsonConstructorAttribute.");
			}
			if (list.Count == 1)
			{
				return list[0];
			}
			if (objectType == typeof(Version))
			{
				return objectType.GetConstructor(new Type[4]
				{
					typeof(int),
					typeof(int),
					typeof(int),
					typeof(int)
				});
			}
			return null;
		}

		private ConstructorInfo GetParametrizedConstructor(Type objectType)
		{
			IList<ConstructorInfo> list = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public));
			if (list.Count == 1)
			{
				return list[0];
			}
			return null;
		}

		protected virtual IList<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
		{
			ParameterInfo[] parameters = constructor.GetParameters();
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(constructor.DeclaringType);
			ParameterInfo[] array = parameters;
			foreach (ParameterInfo parameterInfo in array)
			{
				JsonProperty jsonProperty = ((parameterInfo.Name == null) ? null : memberProperties.GetClosestMatchProperty(parameterInfo.Name));
				if (jsonProperty != null && jsonProperty.PropertyType != parameterInfo.ParameterType)
				{
					jsonProperty = null;
				}
				if (jsonProperty != null || parameterInfo.Name != null)
				{
					JsonProperty jsonProperty2 = CreatePropertyFromConstructorParameter(jsonProperty, parameterInfo);
					if (jsonProperty2 != null)
					{
						jsonPropertyCollection.AddProperty(jsonProperty2);
					}
				}
			}
			return jsonPropertyCollection;
		}

		protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = parameterInfo.ParameterType;
			jsonProperty.AttributeProvider = new ReflectionAttributeProvider(parameterInfo);
			SetPropertySettingsFromAttributes(jsonProperty, parameterInfo, parameterInfo.Name, parameterInfo.Member.DeclaringType, MemberSerialization.OptOut, out var _);
			jsonProperty.Readable = false;
			jsonProperty.Writable = true;
			if (matchingMemberProperty != null)
			{
				jsonProperty.PropertyName = ((!(jsonProperty.PropertyName != parameterInfo.Name)) ? matchingMemberProperty.PropertyName : jsonProperty.PropertyName);
				jsonProperty.Converter = jsonProperty.Converter ?? matchingMemberProperty.Converter;
				jsonProperty.MemberConverter = jsonProperty.MemberConverter ?? matchingMemberProperty.MemberConverter;
				if (!jsonProperty._hasExplicitDefaultValue && matchingMemberProperty._hasExplicitDefaultValue)
				{
					jsonProperty.DefaultValue = matchingMemberProperty.DefaultValue;
				}
				jsonProperty._required = jsonProperty._required ?? matchingMemberProperty._required;
				jsonProperty.IsReference = jsonProperty.IsReference ?? matchingMemberProperty.IsReference;
				jsonProperty.NullValueHandling = jsonProperty.NullValueHandling ?? matchingMemberProperty.NullValueHandling;
				jsonProperty.DefaultValueHandling = jsonProperty.DefaultValueHandling ?? matchingMemberProperty.DefaultValueHandling;
				jsonProperty.ReferenceLoopHandling = jsonProperty.ReferenceLoopHandling ?? matchingMemberProperty.ReferenceLoopHandling;
				jsonProperty.ObjectCreationHandling = jsonProperty.ObjectCreationHandling ?? matchingMemberProperty.ObjectCreationHandling;
				jsonProperty.TypeNameHandling = jsonProperty.TypeNameHandling ?? matchingMemberProperty.TypeNameHandling;
			}
			return jsonProperty;
		}

		protected virtual JsonConverter ResolveContractConverter(Type objectType)
		{
			return JsonTypeReflector.GetJsonConverter(objectType);
		}

		private Func<object> GetDefaultCreator(Type createdType)
		{
			return JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(createdType);
		}

		private void InitializeContract(JsonContract contract)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(contract.NonNullableUnderlyingType);
			if (cachedAttribute != null)
			{
				contract.IsReference = cachedAttribute._isReference;
			}
			contract.Converter = ResolveContractConverter(contract.NonNullableUnderlyingType);
			contract.InternalConverter = JsonSerializer.GetMatchingConverter(BuiltInConverters, contract.NonNullableUnderlyingType);
			if (contract.IsInstantiable && (Newtonsoft.Json.Utilities.ReflectionUtils.HasDefaultConstructor(contract.CreatedType, nonPublic: true) || contract.CreatedType.IsValueType()))
			{
				contract.DefaultCreator = GetDefaultCreator(contract.CreatedType);
				contract.DefaultCreatorNonPublic = !contract.CreatedType.IsValueType() && Newtonsoft.Json.Utilities.ReflectionUtils.GetDefaultConstructor(contract.CreatedType) == null;
			}
			ResolveCallbackMethods(contract, contract.NonNullableUnderlyingType);
		}

		private void ResolveCallbackMethods(JsonContract contract, Type t)
		{
			GetCallbackMethodsForType(t, out var onSerializing, out var onSerialized, out var onDeserializing, out var onDeserialized, out var onError);
			if (onSerializing != null)
			{
				Newtonsoft.Json.Utilities.CollectionUtils.AddRange(contract.OnSerializingCallbacks, onSerializing);
			}
			if (onSerialized != null)
			{
				Newtonsoft.Json.Utilities.CollectionUtils.AddRange(contract.OnSerializedCallbacks, onSerialized);
			}
			if (onDeserializing != null)
			{
				Newtonsoft.Json.Utilities.CollectionUtils.AddRange(contract.OnDeserializingCallbacks, onDeserializing);
			}
			if (onDeserialized != null)
			{
				Newtonsoft.Json.Utilities.CollectionUtils.AddRange(contract.OnDeserializedCallbacks, onDeserialized);
			}
			if (onError != null)
			{
				Newtonsoft.Json.Utilities.CollectionUtils.AddRange(contract.OnErrorCallbacks, onError);
			}
		}

		private void GetCallbackMethodsForType(Type type, out List<SerializationCallback> onSerializing, out List<SerializationCallback> onSerialized, out List<SerializationCallback> onDeserializing, out List<SerializationCallback> onDeserialized, out List<SerializationErrorCallback> onError)
		{
			onSerializing = null;
			onSerialized = null;
			onDeserializing = null;
			onDeserialized = null;
			onError = null;
			foreach (Type item in GetClassHierarchyForType(type))
			{
				MethodInfo currentCallback = null;
				MethodInfo currentCallback2 = null;
				MethodInfo currentCallback3 = null;
				MethodInfo currentCallback4 = null;
				MethodInfo currentCallback5 = null;
				MethodInfo[] methods = item.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (MethodInfo methodInfo in methods)
				{
					if (!methodInfo.ContainsGenericParameters)
					{
						Type prevAttributeType = null;
						ParameterInfo[] parameters = methodInfo.GetParameters();
						if (IsValidCallback(methodInfo, parameters, typeof(OnSerializingAttribute), currentCallback, ref prevAttributeType))
						{
							onSerializing = onSerializing ?? new List<SerializationCallback>();
							onSerializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnSerializedAttribute), currentCallback2, ref prevAttributeType))
						{
							onSerialized = onSerialized ?? new List<SerializationCallback>();
							onSerialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback2 = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnDeserializingAttribute), currentCallback3, ref prevAttributeType))
						{
							onDeserializing = onDeserializing ?? new List<SerializationCallback>();
							onDeserializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback3 = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnDeserializedAttribute), currentCallback4, ref prevAttributeType))
						{
							onDeserialized = onDeserialized ?? new List<SerializationCallback>();
							onDeserialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback4 = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnErrorAttribute), currentCallback5, ref prevAttributeType))
						{
							onError = onError ?? new List<SerializationErrorCallback>();
							onError.Add(JsonContract.CreateSerializationErrorCallback(methodInfo));
							currentCallback5 = methodInfo;
						}
					}
				}
			}
		}

		private List<Type> GetClassHierarchyForType(Type type)
		{
			List<Type> list = new List<Type>();
			Type type2 = type;
			while (type2 != null && type2 != typeof(object))
			{
				list.Add(type2);
				type2 = type2.BaseType();
			}
			list.Reverse();
			return list;
		}

		protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType)
		{
			JsonDictionaryContract jsonDictionaryContract = new JsonDictionaryContract(objectType);
			InitializeContract(jsonDictionaryContract);
			jsonDictionaryContract.PropertyNameResolver = ResolvePropertyName;
			return jsonDictionaryContract;
		}

		protected virtual JsonArrayContract CreateArrayContract(Type objectType)
		{
			JsonArrayContract jsonArrayContract = new JsonArrayContract(objectType);
			InitializeContract(jsonArrayContract);
			return jsonArrayContract;
		}

		protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
		{
			JsonPrimitiveContract jsonPrimitiveContract = new JsonPrimitiveContract(objectType);
			InitializeContract(jsonPrimitiveContract);
			return jsonPrimitiveContract;
		}

		protected virtual JsonLinqContract CreateLinqContract(Type objectType)
		{
			JsonLinqContract jsonLinqContract = new JsonLinqContract(objectType);
			InitializeContract(jsonLinqContract);
			return jsonLinqContract;
		}

		protected virtual JsonISerializableContract CreateISerializableContract(Type objectType)
		{
			JsonISerializableContract jsonISerializableContract = new JsonISerializableContract(objectType);
			InitializeContract(jsonISerializableContract);
			ConstructorInfo constructor = jsonISerializableContract.NonNullableUnderlyingType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
			{
				typeof(SerializationInfo),
				typeof(StreamingContext)
			}, null);
			if (constructor != null)
			{
				ObjectConstructor<object> iSerializableCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(constructor);
				jsonISerializableContract.ISerializableCreator = iSerializableCreator;
			}
			return jsonISerializableContract;
		}

		protected virtual JsonStringContract CreateStringContract(Type objectType)
		{
			JsonStringContract jsonStringContract = new JsonStringContract(objectType);
			InitializeContract(jsonStringContract);
			return jsonStringContract;
		}

		protected virtual JsonContract CreateContract(Type objectType)
		{
			if (IsJsonPrimitiveType(objectType))
			{
				return CreatePrimitiveContract(objectType);
			}
			Type type = Newtonsoft.Json.Utilities.ReflectionUtils.EnsureNotNullableType(objectType);
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(type);
			if (cachedAttribute is JsonObjectAttribute)
			{
				return CreateObjectContract(objectType);
			}
			if (cachedAttribute is JsonArrayAttribute)
			{
				return CreateArrayContract(objectType);
			}
			if (cachedAttribute is JsonDictionaryAttribute)
			{
				return CreateDictionaryContract(objectType);
			}
			if (type == typeof(Newtonsoft.Json.Linq.JToken) || type.IsSubclassOf(typeof(Newtonsoft.Json.Linq.JToken)))
			{
				return CreateLinqContract(objectType);
			}
			if (Newtonsoft.Json.Utilities.CollectionUtils.IsDictionaryType(type))
			{
				return CreateDictionaryContract(objectType);
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				return CreateArrayContract(objectType);
			}
			if (CanConvertToString(type))
			{
				return CreateStringContract(objectType);
			}
			if (!IgnoreSerializableInterface && typeof(ISerializable).IsAssignableFrom(type))
			{
				return CreateISerializableContract(objectType);
			}
			if (IsIConvertible(type))
			{
				return CreatePrimitiveContract(type);
			}
			return CreateObjectContract(objectType);
		}

		internal static bool IsJsonPrimitiveType(Type t)
		{
			PrimitiveTypeCode typeCode = Newtonsoft.Json.Utilities.ConvertUtils.GetTypeCode(t);
			return typeCode != 0 && typeCode != PrimitiveTypeCode.Object;
		}

		internal static bool IsIConvertible(Type t)
		{
			if (typeof(IConvertible).IsAssignableFrom(t) || (Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(t) && typeof(IConvertible).IsAssignableFrom(Nullable.GetUnderlyingType(t))))
			{
				return !typeof(Newtonsoft.Json.Linq.JToken).IsAssignableFrom(t);
			}
			return false;
		}

		internal static bool CanConvertToString(Type type)
		{
			TypeConverter converter = Newtonsoft.Json.Utilities.ConvertUtils.GetConverter(type);
			if (converter != null && !(converter is ComponentConverter) && !(converter is ReferenceConverter) && converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
			{
				return true;
			}
			if (type == typeof(Type) || type.IsSubclassOf(typeof(Type)))
			{
				return true;
			}
			return false;
		}

		private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, ref Type prevAttributeType)
		{
			if (!method.IsDefined(attributeType, inherit: false))
			{
				return false;
			}
			if (currentCallback != null)
			{
				throw new JsonException("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.".FormatWith(CultureInfo.InvariantCulture, method, currentCallback, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if (prevAttributeType != null)
			{
				throw new JsonException("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.".FormatWith(CultureInfo.InvariantCulture, prevAttributeType, attributeType, GetClrTypeFullName(method.DeclaringType), method));
			}
			if (method.IsVirtual)
			{
				throw new JsonException("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.".FormatWith(CultureInfo.InvariantCulture, method, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if (method.ReturnType != typeof(void))
			{
				throw new JsonException("Serialization Callback '{1}' in type '{0}' must return void.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method));
			}
			if (attributeType == typeof(OnErrorAttribute))
			{
				if (parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof(StreamingContext) || parameters[1].ParameterType != typeof(ErrorContext))
				{
					throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext), typeof(ErrorContext)));
				}
			}
			else if (parameters == null || parameters.Length != 1 || parameters[0].ParameterType != typeof(StreamingContext))
			{
				throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext)));
			}
			prevAttributeType = attributeType;
			return true;
		}

		internal static string GetClrTypeFullName(Type type)
		{
			if (type.IsGenericTypeDefinition() || !type.ContainsGenericParameters())
			{
				return type.FullName;
			}
			return string.Format(CultureInfo.InvariantCulture, "{0}.{1}", type.Namespace, type.Name);
		}

		protected virtual IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
		{
			List<MemberInfo> serializableMembers = GetSerializableMembers(type);
			if (serializableMembers == null)
			{
				throw new JsonSerializationException("Null collection of seralizable members returned.");
			}
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(type);
			foreach (MemberInfo item in serializableMembers)
			{
				JsonProperty jsonProperty = CreateProperty(item, memberSerialization);
				if (jsonProperty != null)
				{
					DefaultContractResolverState state = GetState();
					lock (state.NameTable)
					{
						jsonProperty.PropertyName = state.NameTable.Add(jsonProperty.PropertyName);
					}
					jsonPropertyCollection.AddProperty(jsonProperty);
				}
			}
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.OrderBy(jsonPropertyCollection, delegate(JsonProperty p)
			{
				int? order = p.Order;
				return (!order.HasValue) ? (-1) : order.Value;
			}));
		}

		protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member)
		{
			return new ReflectionValueProvider(member);
		}

		protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(member);
			jsonProperty.DeclaringType = member.DeclaringType;
			jsonProperty.ValueProvider = CreateMemberValueProvider(member);
			jsonProperty.AttributeProvider = new ReflectionAttributeProvider(member);
			SetPropertySettingsFromAttributes(jsonProperty, member, member.Name, member.DeclaringType, memberSerialization, out var allowNonPublicAccess);
			if (memberSerialization != MemberSerialization.Fields)
			{
				jsonProperty.Readable = Newtonsoft.Json.Utilities.ReflectionUtils.CanReadMemberValue(member, allowNonPublicAccess);
				jsonProperty.Writable = Newtonsoft.Json.Utilities.ReflectionUtils.CanSetMemberValue(member, allowNonPublicAccess, jsonProperty.HasMemberAttribute);
			}
			else
			{
				jsonProperty.Readable = true;
				jsonProperty.Writable = true;
			}
			jsonProperty.ShouldSerialize = CreateShouldSerializeTest(member);
			SetIsSpecifiedActions(jsonProperty, member, allowNonPublicAccess);
			return jsonProperty;
		}

		private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, out bool allowNonPublicAccess)
		{
			JsonPropertyAttribute attribute = JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(attributeProvider);
			if (attribute != null)
			{
				property.HasMemberAttribute = true;
			}
			string propertyName = ((attribute == null || attribute.PropertyName == null) ? name : attribute.PropertyName);
			property.PropertyName = ResolvePropertyName(propertyName);
			property.UnderlyingName = name;
			bool flag = false;
			if (attribute != null)
			{
				property._required = attribute._required;
				property.Order = attribute._order;
				property.DefaultValueHandling = attribute._defaultValueHandling;
				flag = true;
			}
			bool flag2 = JsonTypeReflector.GetAttribute<JsonIgnoreAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<JsonExtensionDataAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<NonSerializedAttribute>(attributeProvider) != null;
			if (memberSerialization != MemberSerialization.OptIn)
			{
				bool flag3 = false;
				property.Ignored = flag2 || flag3;
			}
			else
			{
				property.Ignored = flag2 || !flag;
			}
			property.Converter = JsonTypeReflector.GetJsonConverter(attributeProvider);
			property.MemberConverter = JsonTypeReflector.GetJsonConverter(attributeProvider);
			DefaultValueAttribute attribute2 = JsonTypeReflector.GetAttribute<DefaultValueAttribute>(attributeProvider);
			if (attribute2 != null)
			{
				property.DefaultValue = attribute2.Value;
			}
			property.NullValueHandling = attribute?._nullValueHandling;
			property.ReferenceLoopHandling = attribute?._referenceLoopHandling;
			property.ObjectCreationHandling = attribute?._objectCreationHandling;
			property.TypeNameHandling = attribute?._typeNameHandling;
			property.IsReference = attribute?._isReference;
			property.ItemIsReference = attribute?._itemIsReference;
			property.ItemConverter = ((attribute == null || attribute.ItemConverterType == null) ? null : JsonTypeReflector.CreateJsonConverterInstance(attribute.ItemConverterType, attribute.ItemConverterParameters));
			property.ItemReferenceLoopHandling = attribute?._itemReferenceLoopHandling;
			property.ItemTypeNameHandling = attribute?._itemTypeNameHandling;
			allowNonPublicAccess = false;
			if ((DefaultMembersSearchFlags & BindingFlags.NonPublic) == BindingFlags.NonPublic)
			{
				allowNonPublicAccess = true;
			}
			if (attribute != null)
			{
				allowNonPublicAccess = true;
			}
			if (memberSerialization == MemberSerialization.Fields)
			{
				allowNonPublicAccess = true;
			}
		}

		private Predicate<object> CreateShouldSerializeTest(MemberInfo member)
		{
			MethodInfo method = member.DeclaringType.GetMethod("ShouldSerialize" + member.Name, Newtonsoft.Json.Utilities.ReflectionUtils.EmptyTypes);
			if (method == null || method.ReturnType != typeof(bool))
			{
				return null;
			}
			Newtonsoft.Json.Utilities.MethodCall<object, object> shouldSerializeCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object o) => (bool)shouldSerializeCall(o);
		}

		private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
		{
			MemberInfo memberInfo = member.DeclaringType.GetProperty(member.Name + "Specified");
			if (memberInfo == null)
			{
				memberInfo = member.DeclaringType.GetField(member.Name + "Specified");
			}
			if (memberInfo != null && Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(memberInfo) == typeof(bool))
			{
				Func<object, object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(memberInfo);
				property.GetIsSpecified = (object o) => (bool)specifiedPropertyGet(o);
				if (Newtonsoft.Json.Utilities.ReflectionUtils.CanSetMemberValue(memberInfo, allowNonPublicAccess, canSetReadOnly: false))
				{
					property.SetIsSpecified = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(memberInfo);
				}
			}
		}

		protected internal virtual string ResolvePropertyName(string propertyName)
		{
			return propertyName;
		}

		public string GetResolvedPropertyName(string propertyName)
		{
			return ResolvePropertyName(propertyName);
		}
	}
	internal class DefaultReferenceResolver : IReferenceResolver
	{
		private int _referenceCount;

		private Newtonsoft.Json.Utilities.BidirectionalDictionary<string, object> GetMappings(object context)
		{
			JsonSerializerInternalBase jsonSerializerInternalBase;
			if (context is JsonSerializerInternalBase)
			{
				jsonSerializerInternalBase = (JsonSerializerInternalBase)context;
			}
			else
			{
				if (!(context is JsonSerializerProxy))
				{
					throw new JsonException("The DefaultReferenceResolver can only be used internally.");
				}
				jsonSerializerInternalBase = ((JsonSerializerProxy)context).GetInternalSerializer();
			}
			return jsonSerializerInternalBase.DefaultReferenceMappings;
		}

		public object ResolveReference(object context, string reference)
		{
			GetMappings(context).TryGetByFirst(reference, out var second);
			return second;
		}

		public string GetReference(object context, object value)
		{
			Newtonsoft.Json.Utilities.BidirectionalDictionary<string, object> mappings = GetMappings(context);
			if (!mappings.TryGetBySecond(value, out var first))
			{
				_referenceCount++;
				first = _referenceCount.ToString(CultureInfo.InvariantCulture);
				mappings.Set(first, value);
			}
			return first;
		}

		public void AddReference(object context, string reference, object value)
		{
			GetMappings(context).Set(reference, value);
		}

		public bool IsReferenced(object context, object value)
		{
			string first;
			return GetMappings(context).TryGetBySecond(value, out first);
		}
	}
	public class DefaultSerializationBinder : SerializationBinder
	{
		internal struct TypeNameKey : IEquatable<TypeNameKey>
		{
			internal readonly string AssemblyName;

			internal readonly string TypeName;

			public TypeNameKey(string assemblyName, string typeName)
			{
				AssemblyName = assemblyName;
				TypeName = typeName;
			}

			public override int GetHashCode()
			{
				return ((AssemblyName != null) ? AssemblyName.GetHashCode() : 0) ^ ((TypeName != null) ? TypeName.GetHashCode() : 0);
			}

			public override bool Equals(object obj)
			{
				if (!(obj is TypeNameKey))
				{
					return false;
				}
				return Equals((TypeNameKey)obj);
			}

			public bool Equals(TypeNameKey other)
			{
				return AssemblyName == other.AssemblyName && TypeName == other.TypeName;
			}
		}

		internal class TypeNameKeyStringKey : StringKeyMaker<TypeNameKey>
		{
			public string MakeStringKey(TypeNameKey typeNameKey)
			{
				return typeNameKey.AssemblyName + ":" + typeNameKey.TypeName;
			}
		}

		internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();

		private readonly Newtonsoft.Json.Utilities.ThreadSafeStore<TypeNameKey, Type> _typeCache = new Newtonsoft.Json.Utilities.ThreadSafeStore<TypeNameKey, Type>(GetTypeFromTypeNameKey, new TypeNameKeyStringKey());

		private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
		{
			string assemblyName = typeNameKey.AssemblyName;
			string typeName = typeNameKey.TypeName;
			if (assemblyName != null)
			{
				Assembly assembly = Assembly.LoadWithPartialName(assemblyName);
				if (assembly == null)
				{
					Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
					Assembly[] array = assemblies;
					foreach (Assembly assembly2 in array)
					{
						if (assembly2.FullName == assemblyName)
						{
							assembly = assembly2;
							break;
						}
					}
				}
				if (assembly == null)
				{
					throw new JsonSerializationException("Could not load assembly '{0}'.".FormatWith(CultureInfo.InvariantCulture, assemblyName));
				}
				Type type = assembly.GetType(typeName);
				if (type == null)
				{
					throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeName, assembly.FullName));
				}
				return type;
			}
			return Type.GetType(typeName);
		}

		public override Type BindToType(string assemblyName, string typeName)
		{
			return _typeCache.Get(new TypeNameKey(assemblyName, typeName));
		}
	}
	public class DiagnosticsTraceWriter : ITraceWriter
	{
		public TraceLevel LevelFilter { get; set; }

		private TraceEventType GetTraceEventType(TraceLevel level)
		{
			return level switch
			{
				TraceLevel.Error => TraceEventType.Error, 
				TraceLevel.Warning => TraceEventType.Warning, 
				TraceLevel.Info => TraceEventType.Information, 
				TraceLevel.Verbose => TraceEventType.Verbose, 
				_ => throw new ArgumentOutOfRangeException("level"), 
			};
		}

		public void Trace(TraceLevel level, string message, Exception ex)
		{
			if (level == TraceLevel.Off)
			{
				return;
			}
			TraceEventCache eventCache = new TraceEventCache();
			TraceEventType traceEventType = GetTraceEventType(level);
			foreach (TraceListener listener in System.Diagnostics.Trace.Listeners)
			{
				if (!listener.IsThreadSafe)
				{
					lock (listener)
					{
						listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
					}
				}
				else
				{
					listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
				}
				if (System.Diagnostics.Trace.AutoFlush)
				{
					listener.Flush();
				}
			}
		}
	}
	public class ErrorContext
	{
		internal bool Traced { get; set; }

		public Exception Error { get; private set; }

		public object OriginalObject { get; private set; }

		public object Member { get; private set; }

		public string Path { get; private set; }

		public bool Handled { get; set; }

		internal ErrorContext(object originalObject, object member, string path, Exception error)
		{
			OriginalObject = originalObject;
			Member = member;
			Error = error;
			Path = path;
		}
	}
	public class ErrorEventArgs : EventArgs
	{
		public object CurrentObject { get; private set; }

		public ErrorContext ErrorContext { get; private set; }

		public ErrorEventArgs(object currentObject, ErrorContext errorContext)
		{
			CurrentObject = currentObject;
			ErrorContext = errorContext;
		}
	}
	public interface IAttributeProvider
	{
		IList<Attribute> GetAttributes(bool inherit);

		IList<Attribute> GetAttributes(Type attributeType, bool inherit);
	}
	public interface IContractResolver
	{
		JsonContract ResolveContract(Type type);
	}
	public interface IReferenceResolver
	{
		object ResolveReference(object context, string reference);

		string GetReference(object context, object value);

		bool IsReferenced(object context, object value);

		void AddReference(object context, string reference, object value);
	}
	public interface ITraceWriter
	{
		TraceLevel LevelFilter { get; }

		void Trace(TraceLevel level, string message, Exception ex);
	}
	public interface IValueProvider
	{
		void SetValue(object target, object value);

		object GetValue(object target);
	}
	public class JsonArrayContract : JsonContainerContract
	{
		private readonly Type _genericCollectionDefinitionType;

		private Type _genericWrapperType;

		private ObjectConstructor<object> _genericWrapperCreator;

		private Func<object> _genericTemporaryCollectionCreator;

		private readonly ConstructorInfo _parametrizedConstructor;

		private ObjectConstructor<object> _parametrizedCreator;

		public Type CollectionItemType { get; private set; }

		public bool IsMultidimensionalArray { get; private set; }

		internal bool IsArray { get; private set; }

		internal bool ShouldCreateWrapper { get; private set; }

		internal bool CanDeserialize { get; private set; }

		internal ObjectConstructor<object> ParametrizedCreator
		{
			get
			{
				if (_parametrizedCreator == null)
				{
					_parametrizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(_parametrizedConstructor);
				}
				return _parametrizedCreator;
			}
		}

		internal bool HasParametrizedCreator => _parametrizedCreator != null || _parametrizedConstructor != null;

		public JsonArrayContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Array;
			IsArray = base.CreatedType.IsArray;
			bool canDeserialize;
			Type implementingType;
			if (IsArray)
			{
				CollectionItemType = Newtonsoft.Json.Utilities.ReflectionUtils.GetCollectionItemType(base.UnderlyingType);
				IsReadOnlyOrFixedSize = true;
				_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
				canDeserialize = true;
				IsMultidimensionalArray = IsArray && base.UnderlyingType.GetArrayRank() > 1;
			}
			else if (typeof(IList).IsAssignableFrom(underlyingType))
			{
				if (Newtonsoft.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
				{
					CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				}
				else
				{
					CollectionItemType = Newtonsoft.Json.Utilities.ReflectionUtils.GetCollectionItemType(underlyingType);
				}
				if (underlyingType == typeof(IList))
				{
					base.CreatedType = typeof(List<object>);
				}
				if (CollectionItemType != null)
				{
					_parametrizedConstructor = Newtonsoft.Json.Utilities.CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
				}
				IsReadOnlyOrFixedSize = Newtonsoft.Json.Utilities.ReflectionUtils.InheritsGenericDefinition(underlyingType, typeof(ReadOnlyCollection<>));
				canDeserialize = true;
			}
			else if (Newtonsoft.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
			{
				CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				if (Newtonsoft.Json.Utilities.ReflectionUtils.IsGenericDefinition(underlyingType, typeof(ICollection<>)) || Newtonsoft.Json.Utilities.ReflectionUtils.IsGenericDefinition(underlyingType, typeof(IList<>)))
				{
					base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
				}
				_parametrizedConstructor = Newtonsoft.Json.Utilities.CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
				canDeserialize = true;
				ShouldCreateWrapper = true;
			}
			else if (Newtonsoft.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IEnumerable<>), out implementingType))
			{
				CollectionItemType = implementingType.GetGenericArguments()[0];
				if (Newtonsoft.Json.Utilities.ReflectionUtils.IsGenericDefinition(base.UnderlyingType, typeof(IEnumerable<>)))
				{
					base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
				}
				_parametrizedConstructor = Newtonsoft.Json.Utilities.CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
				if (underlyingType.IsGenericType() && underlyingType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
				{
					_genericCollectionDefinitionType = implementingType;
					IsReadOnlyOrFixedSize = false;
					ShouldCreateWrapper = false;
					canDeserialize = true;
				}
				else
				{
					_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
					IsReadOnlyOrFixedSize = true;
					ShouldCreateWrapper = true;
					canDeserialize = HasParametrizedCreator;
				}
			}
			else
			{
				canDeserialize = false;
				ShouldCreateWrapper = true;
			}
			CanDeserialize = canDeserialize;
			if (CollectionItemType != null && Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(CollectionItemType) && (Newtonsoft.Json.Utilities.ReflectionUtils.InheritsGenericDefinition(base.CreatedType, typeof(List<>), out implementingType) || (IsArray && !IsMultidimensionalArray)))
			{
				ShouldCreateWrapper = true;
			}
		}

		internal Newtonsoft.Json.Utilities.IWrappedCollection CreateWrapper(object list)
		{
			if (_genericWrapperCreator == null)
			{
				_genericWrapperType = typeof(Newtonsoft.Json.Utilities.CollectionWrapper<>).MakeGenericType(CollectionItemType);
				Type type = ((!Newtonsoft.Json.Utilities.ReflectionUtils.InheritsGenericDefinition(_genericCollectionDefinitionType, typeof(List<>)) && _genericCollectionDefinitionType.GetGenericTypeDefinition() != typeof(IEnumerable<>)) ? _genericCollectionDefinitionType : typeof(ICollection<>).MakeGenericType(CollectionItemType));
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { type });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(constructor);
			}
			return (Newtonsoft.Json.Utilities.IWrappedCollection)_genericWrapperCreator(list);
		}

		internal IList CreateTemporaryCollection()
		{
			if (_genericTemporaryCollectionCreator == null)
			{
				Type type = ((!IsMultidimensionalArray) ? CollectionItemType : typeof(object));
				Type type2 = typeof(List<>).MakeGenericType(type);
				_genericTemporaryCollectionCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type2);
			}
			return (IList)_genericTemporaryCollectionCreator();
		}
	}
	public class JsonContainerContract : JsonContract
	{
		private JsonContract _itemContract;

		private JsonContract _finalItemContract;

		internal JsonContract ItemContract
		{
			get
			{
				return _itemContract;
			}
			set
			{
				_itemContract = value;
				if (_itemContract != null)
				{
					_finalItemContract = ((!_itemContract.UnderlyingType.IsSealed()) ? null : _itemContract);
				}
				else
				{
					_finalItemContract = null;
				}
			}
		}

		internal JsonContract FinalItemContract => _finalItemContract;

		public JsonConverter ItemConverter { get; set; }

		public bool? ItemIsReference { get; set; }

		public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

		public TypeNameHandling? ItemTypeNameHandling { get; set; }

		internal JsonContainerContract(Type underlyingType)
			: base(underlyingType)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(underlyingType);
			if (cachedAttribute != null)
			{
				if (cachedAttribute.ItemConverterType != null)
				{
					ItemConverter = JsonTypeReflector.CreateJsonConverterInstance(cachedAttribute.ItemConverterType, cachedAttribute.ItemConverterParameters);
				}
				ItemIsReference = cachedAttribute._itemIsReference;
				ItemReferenceLoopHandling = cachedAttribute._itemReferenceLoopHandling;
				ItemTypeNameHandling = cachedAttribute._itemTypeNameHandling;
			}
		}
	}
	internal enum JsonContractType
	{
		None,
		Object,
		Array,
		Primitive,
		String,
		Dictionary,
		Dynamic,
		Serializable,
		Linq
	}
	public delegate void SerializationCallback(object o, StreamingContext context);
	public delegate void SerializationErrorCallback(object o, StreamingContext context, ErrorContext errorContext);
	public delegate void ExtensionDataSetter(object o, string key, object value);
	public delegate IEnumerable<KeyValuePair<object, object>> ExtensionDataGetter(object o);
	public abstract class JsonContract
	{
		internal bool IsNullable;

		internal bool IsConvertable;

		internal bool IsEnum;

		internal Type NonNullableUnderlyingType;

		internal ReadType InternalReadType;

		internal JsonContractType ContractType;

		internal bool IsReadOnlyOrFixedSize;

		internal bool IsSealed;

		internal bool IsInstantiable;

		private List<SerializationCallback> _onDeserializedCallbacks;

		private IList<SerializationCallback> _onDeserializingCallbacks;

		private IList<SerializationCallback> _onSerializedCallbacks;

		private IList<SerializationCallback> _onSerializingCallbacks;

		private IList<SerializationErrorCallback> _onErrorCallbacks;

		private Type _createdType;

		public Type UnderlyingType { get; private set; }

		public Type CreatedType
		{
			get
			{
				return _createdType;
			}
			set
			{
				_createdType = value;
				IsSealed = _createdType.IsSealed();
				IsInstantiable = !_createdType.IsInterface() && !_createdType.IsAbstract();
			}
		}

		public bool? IsReference { get; set; }

		public JsonConverter Converter { get; set; }

		internal JsonConverter InternalConverter { get; set; }

		public IList<SerializationCallback> OnDeserializedCallbacks
		{
			get
			{
				if (_onDeserializedCallbacks == null)
				{
					_onDeserializedCallbacks = new List<SerializationCallback>();
				}
				return _onDeserializedCallbacks;
			}
		}

		public IList<SerializationCallback> OnDeserializingCallbacks
		{
			get
			{
				if (_onDeserializingCallbacks == null)
				{
					_onDeserializingCallbacks = new List<SerializationCallback>();
				}
				return _onDeserializingCallbacks;
			}
		}

		public IList<SerializationCallback> OnSerializedCallbacks
		{
			get
			{
				if (_onSerializedCallbacks == null)
				{
					_onSerializedCallbacks = new List<SerializationCallback>();
				}
				return _onSerializedCallbacks;
			}
		}

		public IList<SerializationCallback> OnSerializingCallbacks
		{
			get
			{
				if (_onSerializingCallbacks == null)
				{
					_onSerializingCallbacks = new List<SerializationCallback>();
				}
				return _onSerializingCallbacks;
			}
		}

		public IList<SerializationErrorCallback> OnErrorCallbacks
		{
			get
			{
				if (_onErrorCallbacks == null)
				{
					_onErrorCallbacks = new List<SerializationErrorCallback>();
				}
				return _onErrorCallbacks;
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.")]
		public MethodInfo OnDeserialized
		{
			get
			{
				return (OnDeserializedCallbacks.Count <= 0) ? null : OnDeserializedCallbacks[0].Method();
			}
			set
			{
				OnDeserializedCallbacks.Clear();
				OnDeserializedCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.")]
		public MethodInfo OnDeserializing
		{
			get
			{
				return (OnDeserializingCallbacks.Count <= 0) ? null : OnDeserializingCallbacks[0].Method();
			}
			set
			{
				OnDeserializingCallbacks.Clear();
				OnDeserializingCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnSerializedCallbacks collection.")]
		public MethodInfo OnSerialized
		{
			get
			{
				return (OnSerializedCallbacks.Count <= 0) ? null : OnSerializedCallbacks[0].Method();
			}
			set
			{
				OnSerializedCallbacks.Clear();
				OnSerializedCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnSerializingCallbacks collection.")]
		public MethodInfo OnSerializing
		{
			get
			{
				return (OnSerializingCallbacks.Count <= 0) ? null : OnSerializingCallbacks[0].Method();
			}
			set
			{
				OnSerializingCallbacks.Clear();
				OnSerializingCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnErrorCallbacks collection.")]
		public MethodInfo OnError
		{
			get
			{
				return (OnErrorCallbacks.Count <= 0) ? null : OnErrorCallbacks[0].Method();
			}
			set
			{
				OnErrorCallbacks.Clear();
				OnErrorCallbacks.Add(CreateSerializationErrorCallback(value));
			}
		}

		public Func<object> DefaultCreator { get; set; }

		public bool DefaultCreatorNonPublic { get; set; }

		internal JsonContract(Type underlyingType)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(underlyingType, "underlyingType");
			UnderlyingType = underlyingType;
			IsNullable = Newtonsoft.Json.Utilities.ReflectionUtils.IsNullable(underlyingType);
			NonNullableUnderlyingType = ((!IsNullable || !Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(underlyingType)) ? underlyingType : Nullable.GetUnderlyingType(underlyingType));
			CreatedType = NonNullableUnderlyingType;
			IsConvertable = Newtonsoft.Json.Utilities.ConvertUtils.IsConvertible(NonNullableUnderlyingType);
			IsEnum = NonNullableUnderlyingType.IsEnum();
			if (NonNullableUnderlyingType == typeof(byte[]))
			{
				InternalReadType = ReadType.ReadAsBytes;
			}
			else if (NonNullableUnderlyingType == typeof(int))
			{
				InternalReadType = ReadType.ReadAsInt32;
			}
			else if (NonNullableUnderlyingType == typeof(decimal))
			{
				InternalReadType = ReadType.ReadAsDecimal;
			}
			else if (NonNullableUnderlyingType == typeof(string))
			{
				InternalReadType = ReadType.ReadAsString;
			}
			else if (NonNullableUnderlyingType == typeof(DateTime))
			{
				InternalReadType = ReadType.ReadAsDateTime;
			}
			else
			{
				InternalReadType = ReadType.Read;
			}
		}

		internal void InvokeOnSerializing(object o, StreamingContext context)
		{
			if (_onSerializingCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onSerializingCallback in _onSerializingCallbacks)
			{
				onSerializingCallback(o, context);
			}
		}

		internal void InvokeOnSerialized(object o, StreamingContext context)
		{
			if (_onSerializedCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onSerializedCallback in _onSerializedCallbacks)
			{
				onSerializedCallback(o, context);
			}
		}

		internal void InvokeOnDeserializing(object o, StreamingContext context)
		{
			if (_onDeserializingCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onDeserializingCallback in _onDeserializingCallbacks)
			{
				onDeserializingCallback(o, context);
			}
		}

		internal void InvokeOnDeserialized(object o, StreamingContext context)
		{
			if (_onDeserializedCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onDeserializedCallback in _onDeserializedCallbacks)
			{
				onDeserializedCallback(o, context);
			}
		}

		internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
		{
			if (_onErrorCallbacks == null)
			{
				return;
			}
			foreach (SerializationErrorCallback onErrorCallback in _onErrorCallbacks)
			{
				onErrorCallback(o, context, errorContext);
			}
		}

		internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)
		{
			return delegate(object o, StreamingContext context)
			{
				callbackMethodInfo.Invoke(o, new object[1] { context });
			};
		}

		internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo)
		{
			return delegate(object o, StreamingContext context, ErrorContext econtext)
			{
				callbackMethodInfo.Invoke(o, new object[2] { context, econtext });
			};
		}
	}
	public class JsonDictionaryContract : JsonContainerContract
	{
		private readonly Type _genericCollectionDefinitionType;

		private Type _genericWrapperType;

		private ObjectConstructor<object> _genericWrapperCreator;

		private Func<object> _genericTemporaryDictionaryCreator;

		private readonly ConstructorInfo _parametrizedConstructor;

		private ObjectConstructor<object> _parametrizedCreator;

		public Func<string, string> PropertyNameResolver { get; set; }

		public Type DictionaryKeyType { get; private set; }

		public Type DictionaryValueType { get; private set; }

		internal JsonContract KeyContract { get; set; }

		internal bool ShouldCreateWrapper { get; private set; }

		internal ObjectConstructor<object> ParametrizedCreator
		{
			get
			{
				if (_parametrizedCreator == null)
				{
					_parametrizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(_parametrizedConstructor);
				}
				return _parametrizedCreator;
			}
		}

		internal bool HasParametrizedCreator => _parametrizedCreator != null || _parametrizedConstructor != null;

		public JsonDictionaryContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Dictionary;
			Type keyType;
			Type valueType;
			if (Newtonsoft.Json.Utilities.ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IDictionary<, >), out _genericCollectionDefinitionType))
			{
				keyType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				valueType = _genericCollectionDefinitionType.GetGenericArguments()[1];
				if (Newtonsoft.Json.Utilities.ReflectionUtils.IsGenericDefinition(base.UnderlyingType, typeof(IDictionary<, >)))
				{
					base.CreatedType = typeof(Dictionary<, >).MakeGenericType(keyType, valueType);
				}
			}
			else
			{
				Newtonsoft.Json.Utilities.ReflectionUtils.GetDictionaryKeyValueTypes(base.UnderlyingType, out keyType, out valueType);
				if (base.UnderlyingType == typeof(IDictionary))
				{
					base.CreatedType = typeof(Dictionary<object, object>);
				}
			}
			if (keyType != null && valueType != null)
			{
				_parametrizedConstructor = Newtonsoft.Json.Utilities.CollectionUtils.ResolveEnumerableCollectionConstructor(base.CreatedType, typeof(KeyValuePair<, >).MakeGenericType(keyType, valueType));
			}
			ShouldCreateWrapper = !typeof(IDictionary).IsAssignableFrom(base.CreatedType);
			DictionaryKeyType = keyType;
			DictionaryValueType = valueType;
			if (DictionaryValueType != null && Newtonsoft.Json.Utilities.ReflectionUtils.IsNullableType(DictionaryValueType) && Newtonsoft.Json.Utilities.ReflectionUtils.InheritsGenericDefinition(base.CreatedType, typeof(Dictionary<, >), out var _))
			{
				ShouldCreateWrapper = true;
			}
		}

		internal Newtonsoft.Json.Utilities.IWrappedDictionary CreateWrapper(object dictionary)
		{
			if (_genericWrapperCreator == null)
			{
				_genericWrapperType = typeof(Newtonsoft.Json.Utilities.DictionaryWrapper<, >).MakeGenericType(DictionaryKeyType, DictionaryValueType);
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { _genericCollectionDefinitionType });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(constructor);
			}
			return (Newtonsoft.Json.Utilities.IWrappedDictionary)_genericWrapperCreator(dictionary);
		}

		internal IDictionary CreateTemporaryDictionary()
		{
			if (_genericTemporaryDictionaryCreator == null)
			{
				Type type = typeof(Dictionary<, >).MakeGenericType(DictionaryKeyType, DictionaryValueType);
				_genericTemporaryDictionaryCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type);
			}
			return (IDictionary)_genericTemporaryDictionaryCreator();
		}
	}
	internal class JsonFormatterConverter : IFormatterConverter
	{
		private readonly JsonSerializerInternalReader _reader;

		private readonly JsonISerializableContract _contract;

		private readonly JsonProperty _member;

		public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "serializer");
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(contract, "contract");
			_reader = reader;
			_contract = contract;
			_member = member;
		}

		private T GetTokenValue<T>(object value)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
			Newtonsoft.Json.Linq.JValue jValue = (Newtonsoft.Json.Linq.JValue)value;
			return (T)System.Convert.ChangeType(jValue.Value, typeof(T), CultureInfo.InvariantCulture);
		}

		public object Convert(object value, Type type)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
			if (!(value is Newtonsoft.Json.Linq.JToken token))
			{
				throw new ArgumentException("Value is not a JToken.", "value");
			}
			return _reader.CreateISerializableItem(token, type, _contract, _member);
		}

		public object Convert(object value, TypeCode typeCode)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(value, "value");
			if (value is Newtonsoft.Json.Linq.JValue)
			{
				value = ((Newtonsoft.Json.Linq.JValue)value).Value;
			}
			return System.Convert.ChangeType(value, typeCode, CultureInfo.InvariantCulture);
		}

		public bool ToBoolean(object value)
		{
			return GetTokenValue<bool>(value);
		}

		public byte ToByte(object value)
		{
			return GetTokenValue<byte>(value);
		}

		public char ToChar(object value)
		{
			return GetTokenValue<char>(value);
		}

		public DateTime ToDateTime(object value)
		{
			return GetTokenValue<DateTime>(value);
		}

		public decimal ToDecimal(object value)
		{
			return GetTokenValue<decimal>(value);
		}

		public double ToDouble(object value)
		{
			return GetTokenValue<double>(value);
		}

		public short ToInt16(object value)
		{
			return GetTokenValue<short>(value);
		}

		public int ToInt32(object value)
		{
			return GetTokenValue<int>(value);
		}

		public long ToInt64(object value)
		{
			return GetTokenValue<long>(value);
		}

		public sbyte ToSByte(object value)
		{
			return GetTokenValue<sbyte>(value);
		}

		public float ToSingle(object value)
		{
			return GetTokenValue<float>(value);
		}

		public string ToString(object value)
		{
			return GetTokenValue<string>(value);
		}

		public ushort ToUInt16(object value)
		{
			return GetTokenValue<ushort>(value);
		}

		public uint ToUInt32(object value)
		{
			return GetTokenValue<uint>(value);
		}

		public ulong ToUInt64(object value)
		{
			return GetTokenValue<ulong>(value);
		}
	}
	public class JsonISerializableContract : JsonContainerContract
	{
		public ObjectConstructor<object> ISerializableCreator { get; set; }

		public JsonISerializableContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Serializable;
		}
	}
	public class JsonLinqContract : JsonContract
	{
		public JsonLinqContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Linq;
		}
	}
	public class JsonObjectContract : JsonContainerContract
	{
		private bool? _hasRequiredOrDefaultValueProperties;

		private ConstructorInfo _parametrizedConstructor;

		private ConstructorInfo _overrideConstructor;

		private ObjectConstructor<object> _overrideCreator;

		private ObjectConstructor<object> _parametrizedCreator;

		public MemberSerialization MemberSerialization { get; set; }

		public Required? ItemRequired { get; set; }

		public JsonPropertyCollection Properties { get; private set; }

		[Obsolete("ConstructorParameters is obsolete. Use CreatorParameters instead.")]
		public JsonPropertyCollection ConstructorParameters => CreatorParameters;

		public JsonPropertyCollection CreatorParameters { get; private set; }

		[Obsolete("OverrideConstructor is obsolete. Use OverrideCreator instead.")]
		public ConstructorInfo OverrideConstructor
		{
			get
			{
				return _overrideConstructor;
			}
			set
			{
				_overrideConstructor = value;
				_overrideCreator = ((value == null) ? null : JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(value));
			}
		}

		[Obsolete("ParametrizedConstructor is obsolete. Use OverrideCreator instead.")]
		public ConstructorInfo ParametrizedConstructor
		{
			get
			{
				return _parametrizedConstructor;
			}
			set
			{
				_parametrizedConstructor = value;
				_parametrizedCreator = ((value == null) ? null : JsonTypeReflector.ReflectionDelegateFactory.CreateParametrizedConstructor(value));
			}
		}

		public ObjectConstructor<object> OverrideCreator
		{
			get
			{
				return _overrideCreator;
			}
			set
			{
				_overrideCreator = value;
				_overrideConstructor = null;
			}
		}

		internal ObjectConstructor<object> ParametrizedCreator => _parametrizedCreator;

		public ExtensionDataSetter ExtensionDataSetter { get; set; }

		public ExtensionDataGetter ExtensionDataGetter { get; set; }

		internal bool HasRequiredOrDefaultValueProperties
		{
			get
			{
				bool? hasRequiredOrDefaultValueProperties = _hasRequiredOrDefaultValueProperties;
				if (!hasRequiredOrDefaultValueProperties.HasValue)
				{
					_hasRequiredOrDefaultValueProperties = false;
					if (ItemRequired.GetValueOrDefault(Required.Default) != 0)
					{
						_hasRequiredOrDefaultValueProperties = true;
					}
					else
					{
						foreach (JsonProperty property in Properties)
						{
							if (property.Required == Required.Default)
							{
								DefaultValueHandling? defaultValueHandling = property.DefaultValueHandling & DefaultValueHandling.Populate;
								if (defaultValueHandling.GetValueOrDefault() != DefaultValueHandling.Populate || !defaultValueHandling.HasValue || !property.Writable)
								{
									continue;
								}
							}
							_hasRequiredOrDefaultValueProperties = true;
							break;
						}
					}
				}
				return _hasRequiredOrDefaultValueProperties.Value;
			}
		}

		public JsonObjectContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Object;
			Properties = new JsonPropertyCollection(base.UnderlyingType);
			CreatorParameters = new JsonPropertyCollection(base.UnderlyingType);
		}

		internal object GetUninitializedObject()
		{
			if (!JsonTypeReflector.FullyTrusted)
			{
				throw new JsonException("Insufficient permissions. Creating an uninitialized '{0}' type requires full trust.".FormatWith(CultureInfo.InvariantCulture, NonNullableUnderlyingType));
			}
			return FormatterServices.GetUninitializedObject(NonNullableUnderlyingType);
		}
	}
	public class JsonPrimitiveContract : JsonContract
	{
		internal PrimitiveTypeCode TypeCode { get; set; }

		public JsonPrimitiveContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Primitive;
			TypeCode = Newtonsoft.Json.Utilities.ConvertUtils.GetTypeCode(underlyingType);
			IsReadOnlyOrFixedSize = true;
		}
	}
	public class JsonProperty
	{
		internal Required? _required;

		internal bool _hasExplicitDefaultValue;

		private object _defaultValue;

		private bool _hasGeneratedDefaultValue;

		private string _propertyName;

		internal bool _skipPropertyNameEscape;

		private Type _propertyType;

		internal JsonContract PropertyContract { get; set; }

		public string PropertyName
		{
			get
			{
				return _propertyName;
			}
			set
			{
				_propertyName = value;
				_skipPropertyNameEscape = !Newtonsoft.Json.Utilities.JavaScriptUtils.ShouldEscapeJavaScriptString(_propertyName, Newtonsoft.Json.Utilities.JavaScriptUtils.HtmlCharEscapeFlags);
			}
		}

		public Type DeclaringType { get; set; }

		public int? Order { get; set; }

		public string UnderlyingName { get; set; }

		public IValueProvider ValueProvider { get; set; }

		public IAttributeProvider AttributeProvider { get; set; }

		public Type PropertyType
		{
			get
			{
				return _propertyType;
			}
			set
			{
				if (_propertyType != value)
				{
					_propertyType = value;
					_hasGeneratedDefaultValue = false;
				}
			}
		}

		public JsonConverter Converter { get; set; }

		public JsonConverter MemberConverter { get; set; }

		public bool Ignored { get; set; }

		public bool Readable { get; set; }

		public bool Writable { get; set; }

		public bool HasMemberAttribute { get; set; }

		public object DefaultValue
		{
			get
			{
				if (!_hasExplicitDefaultValue)
				{
					return null;
				}
				return _defaultValue;
			}
			set
			{
				_hasExplicitDefaultValue = true;
				_defaultValue = value;
			}
		}

		public Required Required
		{
			get
			{
				Required? required = _required;
				return required.HasValue ? required.Value : Required.Default;
			}
			set
			{
				_required = value;
			}
		}

		public bool? IsReference { get; set; }

		public NullValueHandling? NullValueHandling { get; set; }

		public DefaultValueHandling? DefaultValueHandling { get; set; }

		public ReferenceLoopHandling? ReferenceLoopHandling { get; set; }

		public ObjectCreationHandling? ObjectCreationHandling { get; set; }

		public TypeNameHandling? TypeNameHandling { get; set; }

		public Predicate<object> ShouldSerialize { get; set; }

		public Predicate<object> GetIsSpecified { get; set; }

		public Action<object, object> SetIsSpecified { get; set; }

		public JsonConverter ItemConverter { get; set; }

		public bool? ItemIsReference { get; set; }

		public TypeNameHandling? ItemTypeNameHandling { get; set; }

		public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

		internal object GetResolvedDefaultValue()
		{
			if (_propertyType == null)
			{
				return null;
			}
			if (!_hasExplicitDefaultValue && !_hasGeneratedDefaultValue)
			{
				_defaultValue = Newtonsoft.Json.Utilities.ReflectionUtils.GetDefaultValue(PropertyType);
				_hasGeneratedDefaultValue = true;
			}
			return _defaultValue;
		}

		public override string ToString()
		{
			return PropertyName;
		}

		internal void WritePropertyName(JsonWriter writer)
		{
			if (_skipPropertyNameEscape)
			{
				writer.WritePropertyName(PropertyName, escape: false);
			}
			else
			{
				writer.WritePropertyName(PropertyName);
			}
		}
	}
	public class JsonPropertyCollection : KeyedCollection<string, JsonProperty>
	{
		private readonly Type _type;

		public JsonPropertyCollection(Type type)
			: base((IEqualityComparer<string>)StringComparer.Ordinal)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(type, "type");
			_type = type;
		}

		protected override string GetKeyForItem(JsonProperty item)
		{
			return item.PropertyName;
		}

		public void AddProperty(JsonProperty property)
		{
			if (Contains(property.PropertyName))
			{
				if (property.Ignored)
				{
					return;
				}
				JsonProperty jsonProperty = base[property.PropertyName];
				bool flag = true;
				if (jsonProperty.Ignored)
				{
					Remove(jsonProperty);
					flag = false;
				}
				else if (property.DeclaringType != null && jsonProperty.DeclaringType != null)
				{
					if (property.DeclaringType.IsSubclassOf(jsonProperty.DeclaringType))
					{
						Remove(jsonProperty);
						flag = false;
					}
					if (jsonProperty.DeclaringType.IsSubclassOf(property.DeclaringType))
					{
						return;
					}
				}
				if (flag)
				{
					throw new JsonSerializationException("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, _type));
				}
			}
			Add(property);
		}

		public JsonProperty GetClosestMatchProperty(string propertyName)
		{
			JsonProperty property = GetProperty(propertyName, StringComparison.Ordinal);
			if (property == null)
			{
				property = GetProperty(propertyName, StringComparison.OrdinalIgnoreCase);
			}
			return property;
		}

		private bool TryGetValue(string key, out JsonProperty item)
		{
			if (base.Dictionary == null)
			{
				item = null;
				return false;
			}
			return base.Dictionary.TryGetValue(key, out item);
		}

		public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
		{
			if (comparisonType == StringComparison.Ordinal)
			{
				if (TryGetValue(propertyName, out var item))
				{
					return item;
				}
				return null;
			}
			using (IEnumerator<JsonProperty> enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					JsonProperty current = enumerator.Current;
					if (string.Equals(propertyName, current.PropertyName, comparisonType))
					{
						return current;
					}
				}
			}
			return null;
		}
	}
	internal abstract class JsonSerializerInternalBase
	{
		private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
		{
			bool IEqualityComparer<object>.Equals(object x, object y)
			{
				return object.ReferenceEquals(x, y);
			}

			int IEqualityComparer<object>.GetHashCode(object obj)
			{
				return RuntimeHelpers.GetHashCode(obj);
			}
		}

		private ErrorContext _currentErrorContext;

		private Newtonsoft.Json.Utilities.BidirectionalDictionary<string, object> _mappings;

		private bool _serializing;

		internal readonly JsonSerializer Serializer;

		internal readonly ITraceWriter TraceWriter;

		internal Newtonsoft.Json.Utilities.BidirectionalDictionary<string, object> DefaultReferenceMappings
		{
			get
			{
				if (_mappings == null)
				{
					_mappings = new Newtonsoft.Json.Utilities.BidirectionalDictionary<string, object>(EqualityComparer<string>.Default, new ReferenceEqualsEqualityComparer(), "A different value already has the Id '{0}'.", "A different Id has already been assigned for value '{0}'.");
				}
				return _mappings;
			}
		}

		protected JsonSerializerInternalBase(JsonSerializer serializer)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(serializer, "serializer");
			Serializer = serializer;
			TraceWriter = serializer.TraceWriter;
			_serializing = GetType() == typeof(JsonSerializerInternalWriter);
		}

		private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error)
		{
			if (_currentErrorContext == null)
			{
				_currentErrorContext = new ErrorContext(currentObject, member, path, error);
			}
			if (_currentErrorContext.Error != error)
			{
				throw new InvalidOperationException("Current error context error is different to requested error.");
			}
			return _currentErrorContext;
		}

		protected void ClearErrorContext()
		{
			if (_currentErrorContext == null)
			{
				throw new InvalidOperationException("Could not clear error context. Error context is already null.");
			}
			_currentErrorContext = null;
		}

		protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex)
		{
			ErrorContext errorContext = GetErrorContext(currentObject, keyValue, path, ex);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Error && !errorContext.Traced)
			{
				errorContext.Traced = true;
				string text = ((!_serializing) ? "Error deserializing" : "Error serializing");
				if (contract != null)
				{
					text = text + " " + contract.UnderlyingType;
				}
				text = text + ". " + ex.Message;
				if (!(ex is JsonException))
				{
					text = JsonPosition.FormatMessage(lineInfo, path, text);
				}
				TraceWriter.Trace(TraceLevel.Error, text, ex);
			}
			if (contract != null && currentObject != null)
			{
				contract.InvokeOnError(currentObject, Serializer.Context, errorContext);
			}
			if (!errorContext.Handled)
			{
				Serializer.OnError(new ErrorEventArgs(currentObject, errorContext));
			}
			return errorContext.Handled;
		}
	}
	internal class JsonSerializerInternalReader : JsonSerializerInternalBase
	{
		internal enum PropertyPresence
		{
			None,
			Null,
			Value
		}

		private JsonSerializerProxy _internalSerializer;

		public JsonSerializerInternalReader(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Populate(JsonReader reader, object target)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(target, "target");
			Type type = target.GetType();
			JsonContract jsonContract = Serializer._contractResolver.ResolveContract(type);
			if (reader.TokenType == JsonToken.None)
			{
				reader.Read();
			}
			if (reader.TokenType == JsonToken.StartArray)
			{
				if (jsonContract.ContractType == JsonContractType.Array)
				{
					JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
					PopulateList((!jsonArrayContract.ShouldCreateWrapper) ? ((IList)target) : jsonArrayContract.CreateWrapper(target), reader, jsonArrayContract, null, null);
					return;
				}
				throw JsonSerializationException.Create(reader, "Cannot populate JSON array onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
			}
			if (reader.TokenType == JsonToken.StartObject)
			{
				CheckedRead(reader);
				string id = null;
				if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$id", StringComparison.Ordinal))
				{
					CheckedRead(reader);
					id = ((reader.Value == null) ? null : reader.Value.ToString());
					CheckedRead(reader);
				}
				if (jsonContract.ContractType == JsonContractType.Dictionary)
				{
					JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
					PopulateDictionary((!jsonDictionaryContract.ShouldCreateWrapper) ? ((IDictionary)target) : jsonDictionaryContract.CreateWrapper(target), reader, jsonDictionaryContract, null, id);
					return;
				}
				if (jsonContract.ContractType == JsonContractType.Object)
				{
					PopulateObject(target, reader, (JsonObjectContract)jsonContract, null, id);
					return;
				}
				throw JsonSerializationException.Create(reader, "Cannot populate JSON object onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
			}
			throw JsonSerializationException.Create(reader, "Unexpected initial token '{0}' when populating object. Expected JSON object or array.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}

		private JsonContract GetContractSafe(Type type)
		{
			if (type == null)
			{
				return null;
			}
			return Serializer._contractResolver.ResolveContract(type);
		}

		public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			JsonContract contractSafe = GetContractSafe(objectType);
			try
			{
				JsonConverter converter = GetConverter(contractSafe, null, null, null);
				if (reader.TokenType == JsonToken.None && !ReadForType(reader, contractSafe, converter != null))
				{
					if (contractSafe != null && !contractSafe.IsNullable)
					{
						throw JsonSerializationException.Create(reader, "No JSON content found and type '{0}' is not nullable.".FormatWith(CultureInfo.InvariantCulture, contractSafe.UnderlyingType));
					}
					return null;
				}
				object result = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, objectType, contractSafe, null, null, null, null) : DeserializeConvertable(converter, reader, objectType, null));
				if (checkAdditionalContent && reader.Read() && reader.TokenType != JsonToken.Comment)
				{
					throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
				}
				return result;
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(null, contractSafe, null, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: false, 0);
					return null;
				}
				ClearErrorContext();
				throw;
			}
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (_internalSerializer == null)
			{
				_internalSerializer = new JsonSerializerProxy(this);
			}
			return _internalSerializer;
		}

		private Newtonsoft.Json.Linq.JToken CreateJToken(JsonReader reader, JsonContract contract)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			if (contract != null)
			{
				if (contract.UnderlyingType == typeof(Newtonsoft.Json.Linq.JRaw))
				{
					return Newtonsoft.Json.Linq.JRaw.Create(reader);
				}
				if (reader.TokenType == JsonToken.Null && contract.UnderlyingType != typeof(Newtonsoft.Json.Linq.JValue) && contract.UnderlyingType != typeof(Newtonsoft.Json.Linq.JToken))
				{
					return null;
				}
			}
			using Newtonsoft.Json.Linq.JTokenWriter jTokenWriter = new Newtonsoft.Json.Linq.JTokenWriter();
			jTokenWriter.WriteToken(reader);
			return jTokenWriter.Token;
		}

		private Newtonsoft.Json.Linq.JToken CreateJObject(JsonReader reader)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(reader, "reader");
			using Newtonsoft.Json.Linq.JTokenWriter jTokenWriter = new Newtonsoft.Json.Linq.JTokenWriter();
			jTokenWriter.WriteStartObject();
			do
			{
				if (reader.TokenType == JsonToken.PropertyName)
				{
					string text = (string)reader.Value;
					while (reader.Read() && reader.TokenType == JsonToken.Comment)
					{
					}
					if (!CheckPropertyName(reader, text))
					{
						jTokenWriter.WritePropertyName(text);
						jTokenWriter.WriteToken(reader, writeChildren: true, writeDateConstructorAsDate: true);
					}
				}
				else if (reader.TokenType != JsonToken.Comment)
				{
					jTokenWriter.WriteEndObject();
					return jTokenWriter.Token;
				}
			}
			while (reader.Read());
			throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
		}

		private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
		{
			if (contract != null && contract.ContractType == JsonContractType.Linq)
			{
				return CreateJToken(reader, contract);
			}
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.StartObject:
					return CreateObject(reader, objectType, contract, member, containerContract, containerMember, existingValue);
				case JsonToken.StartArray:
					return CreateList(reader, objectType, contract, member, existingValue, null);
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
					return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
				case JsonToken.String:
				{
					string text = (string)reader.Value;
					if (string.IsNullOrEmpty(text) && objectType != null && objectType != typeof(string) && objectType != typeof(object) && contract != null && contract.IsNullable)
					{
						return null;
					}
					if (objectType == typeof(byte[]))
					{
						return Convert.FromBase64String(text);
					}
					return EnsureType(reader, text, CultureInfo.InvariantCulture, contract, objectType);
				}
				case JsonToken.StartConstructor:
				{
					string value = reader.Value.ToString();
					return EnsureType(reader, value, CultureInfo.InvariantCulture, contract, objectType);
				}
				case JsonToken.Null:
				case JsonToken.Undefined:
					return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
				case JsonToken.Raw:
					return new Newtonsoft.Json.Linq.JRaw((string)reader.Value);
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token while deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (reader.Read());
			throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
		}

		internal string GetExpectedDescription(JsonContract contract)
		{
			switch (contract.ContractType)
			{
			case JsonContractType.Object:
			case JsonContractType.Dictionary:
			case JsonContractType.Serializable:
				return "JSON object (e.g. {\"name\":\"value\"})";
			case JsonContractType.Array:
				return "JSON array (e.g. [1,2,3])";
			case JsonContractType.Primitive:
				return "JSON primitive value (e.g. string, number, boolean, null)";
			case JsonContractType.String:
				return "JSON string value";
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			JsonConverter result = null;
			if (memberConverter != null)
			{
				result = memberConverter;
			}
			else if (containerProperty != null && containerProperty.ItemConverter != null)
			{
				result = containerProperty.ItemConverter;
			}
			else if (containerContract != null && containerContract.ItemConverter != null)
			{
				result = containerContract.ItemConverter;
			}
			else if (contract != null)
			{
				JsonConverter matchingConverter;
				if (contract.Converter != null)
				{
					result = contract.Converter;
				}
				else if ((matchingConverter = Serializer.GetMatchingConverter(contract.UnderlyingType)) != null)
				{
					result = matchingConverter;
				}
				else if (contract.InternalConverter != null)
				{
					result = contract.InternalConverter;
				}
			}
			return result;
		}

		private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
		{
			Type objectType2 = objectType;
			string id;
			if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.Ignore)
			{
				CheckedRead(reader);
				id = null;
			}
			else if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
			{
				Newtonsoft.Json.Linq.JTokenReader jTokenReader = reader as Newtonsoft.Json.Linq.JTokenReader;
				if (jTokenReader == null)
				{
					Newtonsoft.Json.Linq.JToken jToken = Newtonsoft.Json.Linq.JToken.ReadFrom(reader);
					jTokenReader = (Newtonsoft.Json.Linq.JTokenReader)jToken.CreateReader();
					jTokenReader.Culture = reader.Culture;
					jTokenReader.DateFormatString = reader.DateFormatString;
					jTokenReader.DateParseHandling = reader.DateParseHandling;
					jTokenReader.DateTimeZoneHandling = reader.DateTimeZoneHandling;
					jTokenReader.FloatParseHandling = reader.FloatParseHandling;
					jTokenReader.SupportMultipleContent = reader.SupportMultipleContent;
					CheckedRead(jTokenReader);
					reader = jTokenReader;
				}
				if (ReadMetadataPropertiesToken(jTokenReader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out var newValue, out id))
				{
					return newValue;
				}
			}
			else
			{
				CheckedRead(reader);
				if (ReadMetadataProperties(reader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out var newValue2, out id))
				{
					return newValue2;
				}
			}
			if (HasNoDefinedType(contract))
			{
				return CreateJObject(reader);
			}
			switch (contract.ContractType)
			{
			case JsonContractType.Object:
			{
				bool createdFromNonDefaultCreator2 = false;
				JsonObjectContract jsonObjectContract = (JsonObjectContract)contract;
				object obj = ((existingValue == null || (objectType2 != objectType && !objectType2.IsAssignableFrom(existingValue.GetType()))) ? CreateNewObject(reader, jsonObjectContract, member, containerMember, id, out createdFromNonDefaultCreator2) : existingValue);
				if (createdFromNonDefaultCreator2)
				{
					return obj;
				}
				return PopulateObject(obj, reader, jsonObjectContract, member, id);
			}
			case JsonContractType.Primitive:
			{
				JsonPrimitiveContract contract3 = (JsonPrimitiveContract)contract;
				if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$value", StringComparison.Ordinal))
				{
					CheckedRead(reader);
					if (reader.TokenType == JsonToken.StartObject)
					{
						throw JsonSerializationException.Create(reader, "Unexpected token when deserializing primitive value: " + reader.TokenType);
					}
					object result = CreateValueInternal(reader, objectType2, contract3, member, null, null, existingValue);
					CheckedRead(reader);
					return result;
				}
				break;
			}
			case JsonContractType.Dictionary:
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)contract;
				if (existingValue == null)
				{
					bool createdFromNonDefaultCreator;
					IDictionary dictionary = CreateNewDictionary(reader, jsonDictionaryContract, out createdFromNonDefaultCreator);
					if (createdFromNonDefaultCreator)
					{
						if (id != null)
						{
							throw JsonSerializationException.Create(reader, "Cannot preserve reference to readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (contract.OnSerializingCallbacks.Count > 0)
						{
							throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (contract.OnErrorCallbacks.Count > 0)
						{
							throw JsonSerializationException.Create(reader, "Cannot call OnError on readonly list, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (!jsonDictionaryContract.HasParametrizedCreator)
						{
							throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size dictionary: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
					}
					PopulateDictionary(dictionary, reader, jsonDictionaryContract, member, id);
					if (createdFromNonDefaultCreator)
					{
						return jsonDictionaryContract.ParametrizedCreator(dictionary);
					}
					if (dictionary is Newtonsoft.Json.Utilities.IWrappedDictionary)
					{
						return ((Newtonsoft.Json.Utilities.IWrappedDictionary)dictionary).UnderlyingDictionary;
					}
					return dictionary;
				}
				return PopulateDictionary((!jsonDictionaryContract.ShouldCreateWrapper) ? ((IDictionary)existingValue) : jsonDictionaryContract.CreateWrapper(existingValue), reader, jsonDictionaryContract, member, id);
			}
			case JsonContractType.Serializable:
			{
				JsonISerializableContract contract2 = (JsonISerializableContract)contract;
				return CreateISerializable(reader, contract2, member, id);
			}
			}
			string format = "Cannot deserialize the current JSON object (e.g. {{\"name\":\"value\"}}) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer, not a collection type like an array or List<T>) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object." + Environment.NewLine;
			format = format.FormatWith(CultureInfo.InvariantCulture, objectType2, GetExpectedDescription(contract));
			throw JsonSerializationException.Create(reader, format);
		}

		private bool ReadMetadataPropertiesToken(Newtonsoft.Json.Linq.JTokenReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, out object newValue, out string id)
		{
			id = null;
			newValue = null;
			if (reader.TokenType == JsonToken.StartObject)
			{
				Newtonsoft.Json.Linq.JObject jObject = (Newtonsoft.Json.Linq.JObject)reader.CurrentToken;
				Newtonsoft.Json.Linq.JToken jToken = jObject["$ref"];
				if (jToken != null)
				{
					if (jToken.Type != Newtonsoft.Json.Linq.JTokenType.String && jToken.Type != Newtonsoft.Json.Linq.JTokenType.Null)
					{
						throw JsonSerializationException.Create(jToken, jToken.Path, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
					}
					Newtonsoft.Json.Linq.JToken parent = jToken.Parent;
					Newtonsoft.Json.Linq.JToken jToken2 = null;
					if (parent.Next != null)
					{
						jToken2 = parent.Next;
					}
					else if (parent.Previous != null)
					{
						jToken2 = parent.Previous;
					}
					string text = (string)jToken;
					if (text != null)
					{
						if (jToken2 != null)
						{
							throw JsonSerializationException.Create(jToken2, jToken2.Path, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
						}
						newValue = Serializer.GetReferenceResolver().ResolveReference(this, text);
						if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
						{
							TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text, newValue.GetType())), null);
						}
						reader.Skip();
						return true;
					}
				}
				Newtonsoft.Json.Linq.JToken jToken3 = jObject["$type"];
				if (jToken3 != null)
				{
					string qualifiedTypeName = (string)jToken3;
					JsonReader reader2 = jToken3.CreateReader();
					CheckedRead(reader2);
					ResolveTypeName(reader2, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
					Newtonsoft.Json.Linq.JToken jToken4 = jObject["$value"];
					if (jToken4 != null)
					{
						while (true)
						{
							CheckedRead(reader);
							if (reader.TokenType == JsonToken.PropertyName && (string)reader.Value == "$value")
							{
								break;
							}
							CheckedRead(reader);
							reader.Skip();
						}
						return false;
					}
				}
				Newtonsoft.Json.Linq.JToken jToken5 = jObject["$id"];
				if (jToken5 != null)
				{
					id = (string)jToken5;
				}
				Newtonsoft.Json.Linq.JToken jToken6 = jObject["$values"];
				if (jToken6 != null)
				{
					JsonReader reader3 = jToken6.CreateReader();
					CheckedRead(reader3);
					newValue = CreateList(reader3, objectType, contract, member, existingValue, id);
					reader.Skip();
					return true;
				}
			}
			CheckedRead(reader);
			return false;
		}

		private bool ReadMetadataProperties(JsonReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, out object newValue, out string id)
		{
			id = null;
			newValue = null;
			if (reader.TokenType == JsonToken.PropertyName)
			{
				string text = reader.Value.ToString();
				if (text.Length > 0 && text[0] == '$')
				{
					bool flag;
					do
					{
						text = reader.Value.ToString();
						if (string.Equals(text, "$ref", StringComparison.Ordinal))
						{
							CheckedRead(reader);
							if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null)
							{
								throw JsonSerializationException.Create(reader, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
							}
							string text2 = ((reader.Value == null) ? null : reader.Value.ToString());
							CheckedRead(reader);
							if (text2 != null)
							{
								if (reader.TokenType == JsonToken.PropertyName)
								{
									throw JsonSerializationException.Create(reader, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
								}
								newValue = Serializer.GetReferenceResolver().ResolveReference(this, text2);
								if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
								{
									TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text2, newValue.GetType())), null);
								}
								return true;
							}
							flag = true;
						}
						else if (string.Equals(text, "$type", StringComparison.Ordinal))
						{
							CheckedRead(reader);
							string qualifiedTypeName = reader.Value.ToString();
							ResolveTypeName(reader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
							CheckedRead(reader);
							flag = true;
						}
						else if (string.Equals(text, "$id", StringComparison.Ordinal))
						{
							CheckedRead(reader);
							id = ((reader.Value == null) ? null : reader.Value.ToString());
							CheckedRead(reader);
							flag = true;
						}
						else
						{
							if (string.Equals(text, "$values", StringComparison.Ordinal))
							{
								CheckedRead(reader);
								object obj = CreateList(reader, objectType, contract, member, existingValue, id);
								CheckedRead(reader);
								newValue = obj;
								return true;
							}
							flag = false;
						}
					}
					while (flag && reader.TokenType == JsonToken.PropertyName);
				}
			}
			return false;
		}

		private void ResolveTypeName(JsonReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName)
		{
			TypeNameHandling? typeNameHandling = member?.TypeNameHandling;
			int num;
			if (typeNameHandling.HasValue)
			{
				num = (int)typeNameHandling.Value;
			}
			else
			{
				TypeNameHandling? typeNameHandling2 = containerContract?.ItemTypeNameHandling;
				if (typeNameHandling2.HasValue)
				{
					num = (int)typeNameHandling2.Value;
				}
				else
				{
					TypeNameHandling? typeNameHandling3 = containerMember?.ItemTypeNameHandling;
					num = (int)((!typeNameHandling3.HasValue) ? Serializer._typeNameHandling : typeNameHandling3.Value);
				}
			}
			if (num != 0)
			{
				Newtonsoft.Json.Utilities.ReflectionUtils.SplitFullyQualifiedTypeName(qualifiedTypeName, out var typeName, out var assemblyName);
				Type type;
				try
				{
					type = Serializer._binder.BindToType(assemblyName, typeName);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error resolving type specified in JSON '{0}'.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName), ex);
				}
				if (type == null)
				{
					throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' was not resolved.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName));
				}
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved type '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName, type)), null);
				}
				if (objectType != null && !objectType.IsAssignableFrom(type))
				{
					throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' is not compatible with '{1}'.".FormatWith(CultureInfo.InvariantCulture, type.AssemblyQualifiedName, objectType.AssemblyQualifiedName));
				}
				objectType = type;
				contract = GetContractSafe(type);
			}
		}

		private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract)
		{
			if (contract == null)
			{
				throw JsonSerializationException.Create(reader, "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture, objectType));
			}
			if (!(contract is JsonArrayContract result))
			{
				string format = "Cannot deserialize the current JSON array (e.g. [1,2,3]) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, objectType, GetExpectedDescription(contract));
				throw JsonSerializationException.Create(reader, format);
			}
			return result;
		}

		private void CheckedRead(JsonReader reader)
		{
			if (!reader.Read())
			{
				throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
			}
		}

		private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id)
		{
			if (HasNoDefinedType(contract))
			{
				return CreateJToken(reader, contract);
			}
			JsonArrayContract jsonArrayContract = EnsureArrayContract(reader, objectType, contract);
			if (existingValue == null)
			{
				bool createdFromNonDefaultCreator;
				IList list = CreateNewList(reader, jsonArrayContract, out createdFromNonDefaultCreator);
				if (createdFromNonDefaultCreator)
				{
					if (id != null)
					{
						throw JsonSerializationException.Create(reader, "Cannot preserve reference to array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnSerializingCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnErrorCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnError on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (!jsonArrayContract.HasParametrizedCreator && !jsonArrayContract.IsArray)
					{
						throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size list: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
				}
				if (!jsonArrayContract.IsMultidimensionalArray)
				{
					PopulateList(list, reader, jsonArrayContract, member, id);
				}
				else
				{
					PopulateMultidimensionalArray(list, reader, jsonArrayContract, member, id);
				}
				if (createdFromNonDefaultCreator)
				{
					if (jsonArrayContract.IsMultidimensionalArray)
					{
						list = Newtonsoft.Json.Utilities.CollectionUtils.ToMultidimensionalArray(list, jsonArrayContract.CollectionItemType, contract.CreatedType.GetArrayRank());
					}
					else
					{
						if (!jsonArrayContract.IsArray)
						{
							return jsonArrayContract.ParametrizedCreator(list);
						}
						Array array = Array.CreateInstance(jsonArrayContract.CollectionItemType, list.Count);
						list.CopyTo(array, 0);
						list = array;
					}
				}
				else if (list is Newtonsoft.Json.Utilities.IWrappedCollection)
				{
					return ((Newtonsoft.Json.Utilities.IWrappedCollection)list).UnderlyingCollection;
				}
				return list;
			}
			if (!jsonArrayContract.CanDeserialize)
			{
				throw JsonSerializationException.Create(reader, "Cannot populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
			}
			return PopulateList((!jsonArrayContract.ShouldCreateWrapper) ? ((IList)existingValue) : jsonArrayContract.CreateWrapper(existingValue), reader, jsonArrayContract, member, id);
		}

		private bool HasNoDefinedType(JsonContract contract)
		{
			return contract == null || contract.UnderlyingType == typeof(object) || contract.ContractType == JsonContractType.Linq;
		}

		private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType)
		{
			if (targetType == null)
			{
				return value;
			}
			Type objectType = Newtonsoft.Json.Utilities.ReflectionUtils.GetObjectType(value);
			if (objectType != targetType)
			{
				if (value == null && contract.IsNullable)
				{
					return null;
				}
				try
				{
					if (contract.IsConvertable)
					{
						JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
						if (contract.IsEnum)
						{
							if (value is string)
							{
								return Enum.Parse(contract.NonNullableUnderlyingType, value.ToString(), ignoreCase: true);
							}
							if (Newtonsoft.Json.Utilities.ConvertUtils.IsInteger(jsonPrimitiveContract.TypeCode))
							{
								return Enum.ToObject(contract.NonNullableUnderlyingType, value);
							}
						}
						return Convert.ChangeType(value, contract.NonNullableUnderlyingType, culture);
					}
					return Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(value, culture, contract.NonNullableUnderlyingType);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, Newtonsoft.Json.Utilities.MiscellaneousUtils.FormatValueForPrint(value), targetType), ex);
				}
			}
			return value;
		}

		private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target)
		{
			if (CalculatePropertyDetails(property, ref propertyConverter, containerContract, containerProperty, reader, target, out var useExistingValue, out var currentValue, out var propertyContract, out var gottenCurrentValue))
			{
				return false;
			}
			object obj;
			if (propertyConverter != null && propertyConverter.CanRead)
			{
				if (!gottenCurrentValue && target != null && property.Readable)
				{
					currentValue = property.ValueProvider.GetValue(target);
				}
				obj = DeserializeConvertable(propertyConverter, reader, property.PropertyType, currentValue);
			}
			else
			{
				obj = CreateValueInternal(reader, property.PropertyType, propertyContract, property, containerContract, containerProperty, (!useExistingValue) ? null : currentValue);
			}
			if ((!useExistingValue || obj != currentValue) && ShouldSetPropertyValue(property, obj))
			{
				property.ValueProvider.SetValue(target, obj);
				if (property.SetIsSpecified != null)
				{
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "IsSpecified for property '{0}' on {1} set to true.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType)), null);
					}
					property.SetIsSpecified(target, true);
				}
				return true;
			}
			return useExistingValue;
		}

		private bool CalculatePropertyDetails(JsonProperty property, ref JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, out bool useExistingValue, out object currentValue, out JsonContract propertyContract, out bool gottenCurrentValue)
		{
			currentValue = null;
			useExistingValue = false;
			propertyContract = null;
			gottenCurrentValue = false;
			if (property.Ignored)
			{
				return true;
			}
			JsonToken tokenType = reader.TokenType;
			if (property.PropertyContract == null)
			{
				property.PropertyContract = GetContractSafe(property.PropertyType);
			}
			ObjectCreationHandling valueOrDefault = property.ObjectCreationHandling.GetValueOrDefault(Serializer._objectCreationHandling);
			if (valueOrDefault != ObjectCreationHandling.Replace && (tokenType == JsonToken.StartArray || tokenType == JsonToken.StartObject) && property.Readable)
			{
				currentValue = property.ValueProvider.GetValue(target);
				gottenCurrentValue = true;
				if (currentValue != null)
				{
					propertyContract = GetContractSafe(currentValue.GetType());
					useExistingValue = !propertyContract.IsReadOnlyOrFixedSize && !propertyContract.UnderlyingType.IsValueType();
				}
			}
			if (!property.Writable && !useExistingValue)
			{
				return true;
			}
			if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && tokenType == JsonToken.Null)
			{
				return true;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && JsonTokenUtils.IsPrimitiveToken(tokenType) && Newtonsoft.Json.Utilities.MiscellaneousUtils.ValueEquals(reader.Value, property.GetResolvedDefaultValue()))
			{
				return true;
			}
			if (currentValue == null)
			{
				propertyContract = property.PropertyContract;
			}
			else
			{
				propertyContract = GetContractSafe(currentValue.GetType());
				if (propertyContract != property.PropertyContract)
				{
					propertyConverter = GetConverter(propertyContract, property.MemberConverter, containerContract, containerProperty);
				}
			}
			return false;
		}

		private void AddReference(JsonReader reader, string id, object value)
		{
			try
			{
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Read object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, id, value.GetType())), null);
				}
				Serializer.GetReferenceResolver().AddReference(this, id, value);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error reading object reference '{0}'.".FormatWith(CultureInfo.InvariantCulture, id), ex);
			}
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool ShouldSetPropertyValue(JsonProperty property, object value)
		{
			if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && value == null)
			{
				return false;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && Newtonsoft.Json.Utilities.MiscellaneousUtils.ValueEquals(value, property.GetResolvedDefaultValue()))
			{
				return false;
			}
			if (!property.Writable)
			{
				return false;
			}
			return true;
		}

		private IList CreateNewList(JsonReader reader, JsonArrayContract contract, out bool createdFromNonDefaultCreator)
		{
			if (!contract.CanDeserialize)
			{
				throw JsonSerializationException.Create(reader, "Cannot create and populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
			}
			if (contract.IsReadOnlyOrFixedSize)
			{
				createdFromNonDefaultCreator = true;
				IList list = contract.CreateTemporaryCollection();
				if (contract.ShouldCreateWrapper)
				{
					list = contract.CreateWrapper(list);
				}
				return list;
			}
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				object obj = contract.DefaultCreator();
				if (contract.ShouldCreateWrapper)
				{
					obj = contract.CreateWrapper(obj);
				}
				createdFromNonDefaultCreator = false;
				return (IList)obj;
			}
			if (contract.HasParametrizedCreator)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryCollection();
			}
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, out bool createdFromNonDefaultCreator)
		{
			if (contract.IsReadOnlyOrFixedSize)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryDictionary();
			}
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				object obj = contract.DefaultCreator();
				if (contract.ShouldCreateWrapper)
				{
					obj = contract.CreateWrapper(obj);
				}
				createdFromNonDefaultCreator = false;
				return (IDictionary)obj;
			}
			if (contract.HasParametrizedCreator)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryDictionary();
			}
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnDeserializing(value, Serializer._context);
		}

		private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnDeserialized(value, Serializer._context);
		}

		private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id)
		{
			object obj = ((!(dictionary is Newtonsoft.Json.Utilities.IWrappedDictionary wrappedDictionary)) ? dictionary : wrappedDictionary.UnderlyingDictionary);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			int depth = reader.Depth;
			if (contract.KeyContract == null)
			{
				contract.KeyContract = GetContractSafe(contract.DictionaryKeyType);
			}
			if (contract.ItemContract == null)
			{
				contract.ItemContract = GetContractSafe(contract.DictionaryValueType);
			}
			JsonConverter jsonConverter = contract.ItemConverter ?? GetConverter(contract.ItemContract, null, contract, containerProperty);
			PrimitiveTypeCode primitiveTypeCode = ((contract.KeyContract is JsonPrimitiveContract) ? ((JsonPrimitiveContract)contract.KeyContract).TypeCode : PrimitiveTypeCode.Empty);
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					object obj2 = reader.Value;
					if (CheckPropertyName(reader, obj2.ToString()))
					{
						break;
					}
					try
					{
						try
						{
							DateParseHandling dateParseHandling = ((primitiveTypeCode == PrimitiveTypeCode.DateTime || primitiveTypeCode == PrimitiveTypeCode.DateTimeNullable) ? DateParseHandling.DateTime : DateParseHandling.None);
							obj2 = ((dateParseHandling == DateParseHandling.None || !Newtonsoft.Json.Utilities.DateTimeUtils.TryParseDateTime(obj2.ToString(), dateParseHandling, reader.DateTimeZoneHandling, reader.DateFormatString, reader.Culture, out var dt)) ? EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType) : dt);
						}
						catch (Exception ex)
						{
							throw JsonSerializationException.Create(reader, "Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.".FormatWith(CultureInfo.InvariantCulture, reader.Value, contract.DictionaryKeyType), ex);
						}
						if (!ReadForType(reader, contract.ItemContract, jsonConverter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
						}
						object value = ((jsonConverter == null || !jsonConverter.CanRead) ? CreateValueInternal(reader, contract.DictionaryValueType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(jsonConverter, reader, contract.DictionaryValueType, null));
						dictionary[obj2] = value;
					}
					catch (Exception ex2)
					{
						if (IsErrorHandled(obj, contract, obj2, reader as IJsonLineInfo, reader.Path, ex2))
						{
							HandleError(reader, readPastError: true, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing object.");
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
		{
			int arrayRank = contract.UnderlyingType.GetArrayRank();
			if (id != null)
			{
				AddReference(reader, id, list);
			}
			OnDeserializing(reader, contract, list);
			JsonContract contractSafe = GetContractSafe(contract.CollectionItemType);
			JsonConverter converter = GetConverter(contractSafe, null, contract, containerProperty);
			int? num = null;
			Stack<IList> stack = new Stack<IList>();
			stack.Push(list);
			IList list2 = list;
			bool flag = false;
			do
			{
				int depth = reader.Depth;
				if (stack.Count == arrayRank)
				{
					try
					{
						if (ReadForType(reader, contractSafe, converter != null))
						{
							switch (reader.TokenType)
							{
							case JsonToken.EndArray:
								stack.Pop();
								list2 = stack.Peek();
								num = null;
								break;
							default:
							{
								object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contractSafe, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
								list2.Add(value);
								break;
							}
							case JsonToken.Comment:
								break;
							}
							continue;
						}
					}
					catch (Exception ex)
					{
						JsonPosition position = reader.GetPosition(depth);
						if (IsErrorHandled(list, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
						{
							HandleError(reader, readPastError: true, depth);
							if (num.HasValue && num.GetValueOrDefault() == position.Position && num.HasValue)
							{
								throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
							}
							num = position.Position;
							continue;
						}
						throw;
					}
					break;
				}
				if (!reader.Read())
				{
					break;
				}
				switch (reader.TokenType)
				{
				case JsonToken.StartArray:
				{
					IList list3 = new List<object>();
					list2.Add(list3);
					stack.Push(list3);
					list2 = list3;
					break;
				}
				case JsonToken.EndArray:
					stack.Pop();
					if (stack.Count > 0)
					{
						list2 = stack.Peek();
					}
					else
					{
						flag = true;
					}
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing multidimensional array: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag);
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, list, "Unexpected end when deserializing array.");
			}
			OnDeserialized(reader, contract, list);
			return list;
		}

		private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message)
		{
			try
			{
				throw JsonSerializationException.Create(reader, message);
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(currentObject, contract, null, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: false, 0);
					return;
				}
				throw;
			}
		}

		private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
		{
			object obj = ((!(list is Newtonsoft.Json.Utilities.IWrappedCollection wrappedCollection)) ? list : wrappedCollection.UnderlyingCollection);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			if (list.IsFixedSize)
			{
				reader.Skip();
				return obj;
			}
			OnDeserializing(reader, contract, obj);
			int depth = reader.Depth;
			if (contract.ItemContract == null)
			{
				contract.ItemContract = GetContractSafe(contract.CollectionItemType);
			}
			JsonConverter converter = GetConverter(contract.ItemContract, null, contract, containerProperty);
			int? num = null;
			bool flag = false;
			do
			{
				try
				{
					if (ReadForType(reader, contract.ItemContract, converter != null))
					{
						switch (reader.TokenType)
						{
						case JsonToken.EndArray:
							flag = true;
							break;
						default:
						{
							object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
							list.Add(value);
							break;
						}
						case JsonToken.Comment:
							break;
						}
						continue;
					}
				}
				catch (Exception ex)
				{
					JsonPosition position = reader.GetPosition(depth);
					if (IsErrorHandled(obj, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
					{
						HandleError(reader, readPastError: true, depth);
						if (num.HasValue && num.GetValueOrDefault() == position.Position && num.HasValue)
						{
							throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
						}
						num = position.Position;
						continue;
					}
					throw;
				}
				break;
			}
			while (!flag);
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing array.");
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id)
		{
			Type underlyingType = contract.UnderlyingType;
			if (!JsonTypeReflector.FullyTrusted)
			{
				string format = "Type '{0}' implements ISerializable but cannot be deserialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, underlyingType);
				throw JsonSerializationException.Create(reader, format);
			}
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using ISerializable constructor.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new JsonFormatterConverter(this, contract, member));
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
					}
					serializationInfo.AddValue(text, Newtonsoft.Json.Linq.JToken.ReadFrom(reader));
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, serializationInfo, "Unexpected end when deserializing object.");
			}
			if (contract.ISerializableCreator == null)
			{
				throw JsonSerializationException.Create(reader, "ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.".FormatWith(CultureInfo.InvariantCulture, underlyingType));
			}
			object obj = contract.ISerializableCreator(serializationInfo, Serializer._context);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		internal object CreateISerializableItem(Newtonsoft.Json.Linq.JToken token, Type type, JsonISerializableContract contract, JsonProperty member)
		{
			JsonContract contractSafe = GetContractSafe(type);
			JsonConverter converter = GetConverter(contractSafe, null, contract, member);
			JsonReader reader = token.CreateReader();
			CheckedRead(reader);
			if (converter != null && converter.CanRead)
			{
				return DeserializeConvertable(converter, reader, type, null);
			}
			return CreateValueInternal(reader, type, contractSafe, null, contract, member, null);
		}

		private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor<object> creator, string id)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(creator, "creator");
			Dictionary<JsonProperty, PropertyPresence> dictionary = ((!contract.HasRequiredOrDefaultValueProperties && !HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate)) ? null : Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToDictionary(contract.Properties, (JsonProperty m) => m, (JsonProperty m) => PropertyPresence.None));
			Type underlyingType = contract.UnderlyingType;
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				string arg = string.Join(", ", Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Select(contract.CreatorParameters, (JsonProperty p) => p.PropertyName)));
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using creator with parameters: {1}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType, arg)), null);
			}
			IDictionary<string, object> extensionData;
			IDictionary<JsonProperty, object> dictionary2 = ResolvePropertyAndCreatorValues(contract, containerProperty, reader, underlyingType, out extensionData);
			object[] array = new object[contract.CreatorParameters.Count];
			IDictionary<JsonProperty, object> dictionary3 = new Dictionary<JsonProperty, object>();
			foreach (KeyValuePair<JsonProperty, object> item in dictionary2)
			{
				JsonProperty property = item.Key;
				JsonProperty jsonProperty = ((!contract.CreatorParameters.Contains(property)) ? Newtonsoft.Json.Utilities.StringUtils.ForgivingCaseSensitiveFind(contract.CreatorParameters, (JsonProperty p) => p.PropertyName, property.UnderlyingName) : property);
				if (jsonProperty != null)
				{
					int num = contract.CreatorParameters.IndexOf(jsonProperty);
					array[num] = item.Value;
				}
				else
				{
					dictionary3.Add(item);
				}
				if (dictionary != null)
				{
					JsonProperty jsonProperty2 = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.FirstOrDefault(dictionary.Keys, (JsonProperty p) => p.PropertyName == property.PropertyName);
					if (jsonProperty2 != null)
					{
						dictionary[jsonProperty2] = ((item.Value == null) ? PropertyPresence.Null : PropertyPresence.Value);
					}
				}
			}
			object obj = creator(array);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			foreach (KeyValuePair<JsonProperty, object> item2 in dictionary3)
			{
				JsonProperty key = item2.Key;
				object value = item2.Value;
				if (ShouldSetPropertyValue(key, value))
				{
					key.ValueProvider.SetValue(obj, value);
				}
				else
				{
					if (key.Writable || value == null)
					{
						continue;
					}
					JsonContract jsonContract = Serializer._contractResolver.ResolveContract(key.PropertyType);
					if (jsonContract.ContractType == JsonContractType.Array)
					{
						JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
						object value2 = key.ValueProvider.GetValue(obj);
						if (value2 == null)
						{
							continue;
						}
						Newtonsoft.Json.Utilities.IWrappedCollection wrappedCollection = jsonArrayContract.CreateWrapper(value2);
						Newtonsoft.Json.Utilities.IWrappedCollection wrappedCollection2 = jsonArrayContract.CreateWrapper(value);
						foreach (object item3 in wrappedCollection2)
						{
							wrappedCollection.Add(item3);
						}
					}
					else
					{
						if (jsonContract.ContractType != JsonContractType.Dictionary)
						{
							continue;
						}
						JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
						object value3 = key.ValueProvider.GetValue(obj);
						if (value3 == null)
						{
							continue;
						}
						IDictionary dictionary4 = ((!jsonDictionaryContract.ShouldCreateWrapper) ? ((IDictionary)value3) : jsonDictionaryContract.CreateWrapper(value3));
						IDictionary dictionary5 = ((!jsonDictionaryContract.ShouldCreateWrapper) ? ((IDictionary)value) : jsonDictionaryContract.CreateWrapper(value));
						foreach (DictionaryEntry item4 in dictionary5)
						{
							dictionary4.Add(item4.Key, item4.Value);
						}
					}
				}
			}
			if (extensionData != null)
			{
				foreach (KeyValuePair<string, object> item5 in extensionData)
				{
					contract.ExtensionDataSetter(obj, item5.Key, item5.Value);
				}
			}
			EndObject(obj, reader, contract, reader.Depth, dictionary);
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
			}
			object result = converter.ReadJson(reader, objectType, existingValue, GetInternalSerializer());
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
			}
			return result;
		}

		private IDictionary<JsonProperty, object> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType, out IDictionary<string, object> extensionData)
		{
			extensionData = ((contract.ExtensionDataSetter == null) ? null : new Dictionary<string, object>());
			IDictionary<JsonProperty, object> dictionary = new Dictionary<JsonProperty, object>();
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					JsonProperty jsonProperty = contract.CreatorParameters.GetClosestMatchProperty(text) ?? contract.Properties.GetClosestMatchProperty(text);
					if (jsonProperty != null)
					{
						if (jsonProperty.PropertyContract == null)
						{
							jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
						}
						JsonConverter converter = GetConverter(jsonProperty.PropertyContract, jsonProperty.MemberConverter, contract, containerProperty);
						if (!ReadForType(reader, jsonProperty.PropertyContract, converter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
						}
						if (!jsonProperty.Ignored)
						{
							if (jsonProperty.PropertyContract == null)
							{
								jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
							}
							object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, jsonProperty.PropertyType, jsonProperty.PropertyContract, jsonProperty, contract, containerProperty, null) : DeserializeConvertable(converter, reader, jsonProperty.PropertyType, null));
							dictionary[jsonProperty] = value;
							break;
						}
					}
					else
					{
						if (!reader.Read())
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
						}
						if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
						{
							TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}.".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
						}
						if (Serializer._missingMemberHandling == MissingMemberHandling.Error)
						{
							throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, objectType.Name));
						}
					}
					if (extensionData != null)
					{
						object value2 = CreateValueInternal(reader, null, null, null, contract, containerProperty, null);
						extensionData[text] = value2;
					}
					else
					{
						reader.Skip();
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			return dictionary;
		}

		private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter)
		{
			if (hasConverter)
			{
				return reader.Read();
			}
			switch (contract?.InternalReadType ?? ReadType.Read)
			{
			case ReadType.Read:
				do
				{
					if (!reader.Read())
					{
						return false;
					}
				}
				while (reader.TokenType == JsonToken.Comment);
				return true;
			case ReadType.ReadAsInt32:
				reader.ReadAsInt32();
				break;
			case ReadType.ReadAsDecimal:
				reader.ReadAsDecimal();
				break;
			case ReadType.ReadAsBytes:
				reader.ReadAsBytes();
				break;
			case ReadType.ReadAsString:
				reader.ReadAsString();
				break;
			case ReadType.ReadAsDateTime:
				reader.ReadAsDateTime();
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
			return reader.TokenType != JsonToken.None;
		}

		public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, out bool createdFromNonDefaultCreator)
		{
			object obj = null;
			if (objectContract.OverrideCreator != null)
			{
				if (objectContract.CreatorParameters.Count > 0)
				{
					createdFromNonDefaultCreator = true;
					return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.OverrideCreator, id);
				}
				obj = objectContract.OverrideCreator();
			}
			else if (objectContract.DefaultCreator != null && (!objectContract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParametrizedCreator == null))
			{
				obj = objectContract.DefaultCreator();
			}
			else if (objectContract.ParametrizedCreator != null)
			{
				createdFromNonDefaultCreator = true;
				return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.ParametrizedCreator, id);
			}
			if (obj == null)
			{
				if (!objectContract.IsInstantiable)
				{
					throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
				}
				throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
			}
			createdFromNonDefaultCreator = false;
			return obj;
		}

		private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id)
		{
			OnDeserializing(reader, contract, newObject);
			Dictionary<JsonProperty, PropertyPresence> dictionary = ((!contract.HasRequiredOrDefaultValueProperties && !HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate)) ? null : Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToDictionary(contract.Properties, (JsonProperty m) => m, (JsonProperty m) => PropertyPresence.None));
			if (id != null)
			{
				AddReference(reader, id, newObject);
			}
			int depth = reader.Depth;
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (CheckPropertyName(reader, text))
					{
						break;
					}
					try
					{
						JsonProperty closestMatchProperty = contract.Properties.GetClosestMatchProperty(text);
						if (closestMatchProperty == null)
						{
							if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
							{
								TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
							}
							if (Serializer._missingMemberHandling == MissingMemberHandling.Error)
							{
								throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType.Name));
							}
							if (reader.Read())
							{
								SetExtensionData(contract, member, reader, text, newObject);
							}
							break;
						}
						if (closestMatchProperty.PropertyContract == null)
						{
							closestMatchProperty.PropertyContract = GetContractSafe(closestMatchProperty.PropertyType);
						}
						JsonConverter converter = GetConverter(closestMatchProperty.PropertyContract, closestMatchProperty.MemberConverter, contract, member);
						if (!ReadForType(reader, closestMatchProperty.PropertyContract, converter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
						}
						SetPropertyPresence(reader, closestMatchProperty, dictionary);
						if (!SetPropertyValue(closestMatchProperty, converter, contract, member, reader, newObject))
						{
							SetExtensionData(contract, member, reader, text, newObject);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(newObject, contract, text, reader as IJsonLineInfo, reader.Path, ex))
						{
							HandleError(reader, readPastError: true, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, newObject, "Unexpected end when deserializing object.");
			}
			EndObject(newObject, reader, contract, depth, dictionary);
			OnDeserialized(reader, contract, newObject);
			return newObject;
		}

		private bool CheckPropertyName(JsonReader reader, string memberName)
		{
			if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
			{
				switch (memberName)
				{
				case "$id":
				case "$ref":
				case "$type":
				case "$values":
					reader.Skip();
					return true;
				}
			}
			return false;
		}

		private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o)
		{
			if (contract.ExtensionDataSetter != null)
			{
				try
				{
					object value = CreateValueInternal(reader, null, null, null, contract, member, null);
					contract.ExtensionDataSetter(o, memberName, value);
					return;
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error setting value in extension data for type '{0}'.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType), ex);
				}
			}
			reader.Skip();
		}

		private void EndObject(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, Dictionary<JsonProperty, PropertyPresence> propertiesPresence)
		{
			if (propertiesPresence == null)
			{
				return;
			}
			foreach (KeyValuePair<JsonProperty, PropertyPresence> item in propertiesPresence)
			{
				JsonProperty key = item.Key;
				PropertyPresence value = item.Value;
				if (value != 0 && value != PropertyPresence.Null)
				{
					continue;
				}
				try
				{
					Required? required = key._required;
					int num;
					if (required.HasValue)
					{
						num = (int)required.Value;
					}
					else
					{
						Required? itemRequired = contract.ItemRequired;
						num = (int)(itemRequired.HasValue ? itemRequired.Value : Required.Default);
					}
					Required required2 = (Required)num;
					switch (value)
					{
					case PropertyPresence.None:
						if (required2 == Required.AllowNull || required2 == Required.Always)
						{
							throw JsonSerializationException.Create(reader, "Required property '{0}' not found in JSON.".FormatWith(CultureInfo.InvariantCulture, key.PropertyName));
						}
						if (key.PropertyContract == null)
						{
							key.PropertyContract = GetContractSafe(key.PropertyType);
						}
						if (HasFlag(key.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && key.Writable && !key.Ignored)
						{
							key.ValueProvider.SetValue(newObject, EnsureType(reader, key.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, key.PropertyContract, key.PropertyType));
						}
						break;
					case PropertyPresence.Null:
						if (required2 == Required.Always)
						{
							throw JsonSerializationException.Create(reader, "Required property '{0}' expects a value but got null.".FormatWith(CultureInfo.InvariantCulture, key.PropertyName));
						}
						break;
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(newObject, contract, key.PropertyName, reader as IJsonLineInfo, reader.Path, ex))
					{
						HandleError(reader, readPastError: true, initialDepth);
						continue;
					}
					throw;
				}
			}
		}

		private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary<JsonProperty, PropertyPresence> requiredProperties)
		{
			if (property != null && requiredProperties != null)
			{
				requiredProperties[property] = ((reader.TokenType == JsonToken.Null || reader.TokenType == JsonToken.Undefined) ? PropertyPresence.Null : PropertyPresence.Value);
			}
		}

		private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
		{
			ClearErrorContext();
			if (readPastError)
			{
				reader.Skip();
				while (reader.Depth > initialDepth + 1 && reader.Read())
				{
				}
			}
		}
	}
	internal class JsonSerializerInternalWriter : JsonSerializerInternalBase
	{
		private JsonContract _rootContract;

		private int _rootLevel;

		private readonly List<object> _serializeStack = new List<object>();

		private JsonSerializerProxy _internalSerializer;

		public JsonSerializerInternalWriter(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
		{
			if (jsonWriter == null)
			{
				throw new ArgumentNullException("jsonWriter");
			}
			_rootContract = ((objectType == null) ? null : Serializer._contractResolver.ResolveContract(objectType));
			_rootLevel = _serializeStack.Count + 1;
			JsonContract contractSafe = GetContractSafe(value);
			try
			{
				SerializeValue(jsonWriter, value, contractSafe, null, null, null);
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(null, contractSafe, null, null, jsonWriter.Path, ex))
				{
					HandleError(jsonWriter, 0);
					return;
				}
				ClearErrorContext();
				throw;
			}
			finally
			{
				_rootContract = null;
			}
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (_internalSerializer == null)
			{
				_internalSerializer = new JsonSerializerProxy(this);
			}
			return _internalSerializer;
		}

		private JsonContract GetContractSafe(object value)
		{
			if (value == null)
			{
				return null;
			}
			return Serializer._contractResolver.ResolveContract(value.GetType());
		}

		private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			if (contract.TypeCode == PrimitiveTypeCode.Bytes && ShouldWriteType(TypeNameHandling.Objects, contract, member, containerContract, containerProperty))
			{
				writer.WriteStartObject();
				WriteTypeProperty(writer, contract.CreatedType);
				writer.WritePropertyName("$value", escape: false);
				JsonWriter.WriteValue(writer, contract.TypeCode, value);
				writer.WriteEndObject();
			}
			else
			{
				JsonWriter.WriteValue(writer, contract.TypeCode, value);
			}
		}

		private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			JsonConverter jsonConverter = member?.Converter ?? containerProperty?.ItemConverter ?? containerContract?.ItemConverter ?? valueContract.Converter ?? Serializer.GetMatchingConverter(valueContract.UnderlyingType) ?? valueContract.InternalConverter;
			if (jsonConverter != null && jsonConverter.CanWrite)
			{
				SerializeConvertable(writer, jsonConverter, value, valueContract, containerContract, containerProperty);
				return;
			}
			switch (valueContract.ContractType)
			{
			case JsonContractType.Object:
				SerializeObject(writer, value, (JsonObjectContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.Array:
			{
				JsonArrayContract jsonArrayContract = (JsonArrayContract)valueContract;
				if (!jsonArrayContract.IsMultidimensionalArray)
				{
					SerializeList(writer, (IEnumerable)value, jsonArrayContract, member, containerContract, containerProperty);
				}
				else
				{
					SerializeMultidimensionalArray(writer, (Array)value, jsonArrayContract, member, containerContract, containerProperty);
				}
				break;
			}
			case JsonContractType.Primitive:
				SerializePrimitive(writer, value, (JsonPrimitiveContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.String:
				SerializeString(writer, value, (JsonStringContract)valueContract);
				break;
			case JsonContractType.Dictionary:
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)valueContract;
				SerializeDictionary(writer, (!(value is IDictionary)) ? jsonDictionaryContract.CreateWrapper(value) : ((IDictionary)value), jsonDictionaryContract, member, containerContract, containerProperty);
				break;
			}
			case JsonContractType.Serializable:
				SerializeISerializable(writer, (ISerializable)value, (JsonISerializableContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.Linq:
				((Newtonsoft.Json.Linq.JToken)value).WriteTo(writer, Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Serializer.Converters));
				break;
			case JsonContractType.Dynamic:
				break;
			}
		}

		private bool? ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			bool? result = null;
			if (property != null)
			{
				result = property.IsReference;
			}
			if (!result.HasValue && containerProperty != null)
			{
				result = containerProperty.ItemIsReference;
			}
			if (!result.HasValue && collectionContract != null)
			{
				result = collectionContract.ItemIsReference;
			}
			if (!result.HasValue)
			{
				result = contract.IsReference;
			}
			return result;
		}

		private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			if (value == null)
			{
				return false;
			}
			if (valueContract.ContractType == JsonContractType.Primitive || valueContract.ContractType == JsonContractType.String)
			{
				return false;
			}
			bool? flag = ResolveIsReference(valueContract, property, collectionContract, containerProperty);
			if (!flag.HasValue)
			{
				flag = ((valueContract.ContractType != JsonContractType.Array) ? new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) : new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays)));
			}
			if (!flag.Value)
			{
				return false;
			}
			return Serializer.GetReferenceResolver().IsReferenced(this, value);
		}

		private bool ShouldWriteProperty(object memberValue, JsonProperty property)
		{
			if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && memberValue == null)
			{
				return false;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && Newtonsoft.Json.Utilities.MiscellaneousUtils.ValueEquals(memberValue, property.GetResolvedDefaultValue()))
			{
				return false;
			}
			return true;
		}

		private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			if (value == null || contract.ContractType == JsonContractType.Primitive || contract.ContractType == JsonContractType.String)
			{
				return true;
			}
			ReferenceLoopHandling? referenceLoopHandling = null;
			if (property != null)
			{
				referenceLoopHandling = property.ReferenceLoopHandling;
			}
			if (!referenceLoopHandling.HasValue && containerProperty != null)
			{
				referenceLoopHandling = containerProperty.ItemReferenceLoopHandling;
			}
			if (!referenceLoopHandling.HasValue && containerContract != null)
			{
				referenceLoopHandling = containerContract.ItemReferenceLoopHandling;
			}
			if (_serializeStack.IndexOf(value) != -1)
			{
				string text = "Self referencing loop detected";
				if (property != null)
				{
					text += " for property '{0}'".FormatWith(CultureInfo.InvariantCulture, property.PropertyName);
				}
				text += " with type '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType());
				switch (referenceLoopHandling.GetValueOrDefault(Serializer._referenceLoopHandling))
				{
				case ReferenceLoopHandling.Error:
					throw JsonSerializationException.Create(null, writer.ContainerPath, text, null);
				case ReferenceLoopHandling.Ignore:
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Skipping serializing self referenced value."), null);
					}
					return false;
				case ReferenceLoopHandling.Serialize:
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Serializing self referenced value."), null);
					}
					return true;
				}
			}
			return true;
		}

		private void WriteReference(JsonWriter writer, object value)
		{
			string reference = GetReference(writer, value);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference to Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, value.GetType())), null);
			}
			writer.WriteStartObject();
			writer.WritePropertyName("$ref", escape: false);
			writer.WriteValue(reference);
			writer.WriteEndObject();
		}

		private string GetReference(JsonWriter writer, object value)
		{
			try
			{
				return Serializer.GetReferenceResolver().GetReference(this, value);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(null, writer.ContainerPath, "Error writing object reference for '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), ex);
			}
		}

		internal static bool TryConvertToString(object value, Type type, out string s)
		{
			TypeConverter converter = Newtonsoft.Json.Utilities.ConvertUtils.GetConverter(type);
			if (converter != null && !(converter is ComponentConverter) && converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
			{
				s = converter.ConvertToInvariantString(value);
				return true;
			}
			if (value is Type)
			{
				s = ((Type)value).AssemblyQualifiedName;
				return true;
			}
			s = null;
			return false;
		}

		private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
		{
			OnSerializing(writer, contract, value);
			TryConvertToString(value, contract.UnderlyingType, out var s);
			writer.WriteValue(s);
			OnSerialized(writer, contract, value);
		}

		private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnSerializing(value, Serializer._context);
		}

		private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnSerialized(value, Serializer._context);
		}

		private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			OnSerializing(writer, contract, value);
			_serializeStack.Add(value);
			WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
			int top = writer.Top;
			for (int i = 0; i < contract.Properties.Count; i++)
			{
				JsonProperty jsonProperty = contract.Properties[i];
				try
				{
					if (CalculatePropertyValues(writer, value, contract, member, jsonProperty, out var memberContract, out var memberValue))
					{
						jsonProperty.WritePropertyName(writer);
						SerializeValue(writer, memberValue, memberContract, jsonProperty, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(value, contract, jsonProperty.PropertyName, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			if (contract.ExtensionDataGetter != null)
			{
				IEnumerable<KeyValuePair<object, object>> enumerable = contract.ExtensionDataGetter(value);
				if (enumerable != null)
				{
					foreach (KeyValuePair<object, object> item in enumerable)
					{
						JsonContract contractSafe = GetContractSafe(item.Key);
						JsonContract contractSafe2 = GetContractSafe(item.Value);
						bool escape;
						string propertyName = GetPropertyName(writer, item.Key, contractSafe, out escape);
						if (ShouldWriteReference(item.Value, null, contractSafe2, contract, member))
						{
							writer.WritePropertyName(propertyName);
							WriteReference(writer, item.Value);
						}
						else if (CheckForCircularReference(writer, item.Value, null, contractSafe2, contract, member))
						{
							writer.WritePropertyName(propertyName);
							SerializeValue(writer, item.Value, contractSafe2, null, contract, member);
						}
					}
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, value);
		}

		private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, out JsonContract memberContract, out object memberValue)
		{
			if (!property.Ignored && property.Readable && ShouldSerialize(writer, property, value) && IsSpecified(writer, property, value))
			{
				if (property.PropertyContract == null)
				{
					property.PropertyContract = Serializer._contractResolver.ResolveContract(property.PropertyType);
				}
				memberValue = property.ValueProvider.GetValue(value);
				memberContract = ((!property.PropertyContract.IsSealed) ? GetContractSafe(memberValue) : property.PropertyContract);
				if (ShouldWriteProperty(memberValue, property))
				{
					if (ShouldWriteReference(memberValue, property, memberContract, contract, member))
					{
						property.WritePropertyName(writer);
						WriteReference(writer, memberValue);
						return false;
					}
					if (!CheckForCircularReference(writer, memberValue, property, memberContract, contract, member))
					{
						return false;
					}
					if (memberValue == null)
					{
						JsonObjectContract jsonObjectContract = contract as JsonObjectContract;
						Required? required = property._required;
						int num;
						if (required.HasValue)
						{
							num = (int)required.Value;
						}
						else
						{
							Required? required2 = jsonObjectContract?.ItemRequired;
							num = (int)(required2.HasValue ? required2.Value : Required.Default);
						}
						Required required3 = (Required)num;
						if (required3 == Required.Always)
						{
							throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
						}
					}
					return true;
				}
			}
			memberContract = null;
			memberValue = null;
			return false;
		}

		private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			writer.WriteStartObject();
			bool? flag = ResolveIsReference(contract, member, collectionContract, containerProperty);
			if ((!flag.HasValue) ? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects) : flag.Value)
			{
				WriteReferenceIdProperty(writer, contract.UnderlyingType, value);
			}
			if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionContract, containerProperty))
			{
				WriteTypeProperty(writer, contract.UnderlyingType);
			}
		}

		private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
		{
			string reference = GetReference(writer, value);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, type)), null);
			}
			writer.WritePropertyName("$id", escape: false);
			writer.WriteValue(reference);
		}

		private void WriteTypeProperty(JsonWriter writer, Type type)
		{
			string typeName = Newtonsoft.Json.Utilities.ReflectionUtils.GetTypeName(type, Serializer._typeNameAssemblyFormat, Serializer._binder);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing type name '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, typeName, type)), null);
			}
			writer.WritePropertyName("$type", escape: false);
			writer.WriteValue(typeName);
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
		{
			return (value & flag) == flag;
		}

		private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			if (ShouldWriteReference(value, null, contract, collectionContract, containerProperty))
			{
				WriteReference(writer, value);
			}
			else if (CheckForCircularReference(writer, value, null, contract, collectionContract, containerProperty))
			{
				_serializeStack.Add(value);
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
				{
					TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
				}
				converter.WriteJson(writer, value, GetInternalSerializer());
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
				{
					TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
				}
				_serializeStack.RemoveAt(_serializeStack.Count - 1);
			}
		}

		private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			object obj = ((!(values is Newtonsoft.Json.Utilities.IWrappedCollection wrappedCollection)) ? values : wrappedCollection.UnderlyingCollection);
			OnSerializing(writer, contract, obj);
			_serializeStack.Add(obj);
			bool flag = WriteStartArray(writer, obj, contract, member, collectionContract, containerProperty);
			writer.WriteStartArray();
			int top = writer.Top;
			int num = 0;
			foreach (object value in values)
			{
				try
				{
					JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
					if (ShouldWriteReference(value, null, jsonContract, contract, member))
					{
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
					{
						SerializeValue(writer, value, jsonContract, null, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(obj, contract, num, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
				finally
				{
					num++;
				}
			}
			writer.WriteEndArray();
			if (flag)
			{
				writer.WriteEndObject();
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, obj);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			OnSerializing(writer, contract, values);
			_serializeStack.Add(values);
			bool flag = WriteStartArray(writer, values, contract, member, collectionContract, containerProperty);
			SerializeMultidimensionalArray(writer, values, contract, member, writer.Top, new int[0]);
			if (flag)
			{
				writer.WriteEndObject();
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, values);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, int[] indices)
		{
			int num = indices.Length;
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			writer.WriteStartArray();
			for (int j = 0; j < values.GetLength(num); j++)
			{
				array[num] = j;
				if (array.Length == values.Rank)
				{
					object value = values.GetValue(array);
					try
					{
						JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
						if (ShouldWriteReference(value, null, jsonContract, contract, member))
						{
							WriteReference(writer, value);
						}
						else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
						{
							SerializeValue(writer, value, jsonContract, null, contract, member);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(values, contract, j, null, writer.ContainerPath, ex))
						{
							HandleError(writer, initialDepth + 1);
							continue;
						}
						throw;
					}
				}
				else
				{
					SerializeMultidimensionalArray(writer, values, contract, member, initialDepth + 1, array);
				}
			}
			writer.WriteEndArray();
		}

		private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			bool? flag = ResolveIsReference(contract, member, containerContract, containerProperty);
			bool flag2 = ((!flag.HasValue) ? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays) : flag.Value);
			bool flag3 = ShouldWriteType(TypeNameHandling.Arrays, contract, member, containerContract, containerProperty);
			bool flag4 = flag2 || flag3;
			if (flag4)
			{
				writer.WriteStartObject();
				if (flag2)
				{
					WriteReferenceIdProperty(writer, contract.UnderlyingType, values);
				}
				if (flag3)
				{
					WriteTypeProperty(writer, values.GetType());
				}
				writer.WritePropertyName("$values", escape: false);
			}
			if (contract.ItemContract == null)
			{
				contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.CollectionItemType ?? typeof(object));
			}
			return flag4;
		}

		private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			if (!JsonTypeReflector.FullyTrusted)
			{
				string format = "Type '{0}' implements ISerializable but cannot be serialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, value.GetType());
				throw JsonSerializationException.Create(null, writer.ContainerPath, format, null);
			}
			OnSerializing(writer, contract, value);
			_serializeStack.Add(value);
			WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new FormatterConverter());
			value.GetObjectData(serializationInfo, Serializer._context);
			SerializationInfoEnumerator enumerator = serializationInfo.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				JsonContract contractSafe = GetContractSafe(current.Value);
				if (ShouldWriteReference(current.Value, null, contractSafe, contract, member))
				{
					writer.WritePropertyName(current.Name);
					WriteReference(writer, current.Value);
				}
				else if (CheckForCircularReference(writer, current.Value, null, contractSafe, contract, member))
				{
					writer.WritePropertyName(current.Name);
					SerializeValue(writer, current.Value, contractSafe, null, contract, member);
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, value);
		}

		private bool ShouldWriteDynamicProperty(object memberValue)
		{
			if (Serializer._nullValueHandling == NullValueHandling.Ignore && memberValue == null)
			{
				return false;
			}
			if (HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Ignore) && (memberValue == null || Newtonsoft.Json.Utilities.MiscellaneousUtils.ValueEquals(memberValue, Newtonsoft.Json.Utilities.ReflectionUtils.GetDefaultValue(memberValue.GetType()))))
			{
				return false;
			}
			return true;
		}

		private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			TypeNameHandling? typeNameHandling = member?.TypeNameHandling;
			int num;
			if (typeNameHandling.HasValue)
			{
				num = (int)typeNameHandling.Value;
			}
			else
			{
				TypeNameHandling? typeNameHandling2 = containerProperty?.ItemTypeNameHandling;
				if (typeNameHandling2.HasValue)
				{
					num = (int)typeNameHandling2.Value;
				}
				else
				{
					TypeNameHandling? typeNameHandling3 = containerContract?.ItemTypeNameHandling;
					num = (int)((!typeNameHandling3.HasValue) ? Serializer._typeNameHandling : typeNameHandling3.Value);
				}
			}
			TypeNameHandling value = (TypeNameHandling)num;
			if (HasFlag(value, typeNameHandlingFlag))
			{
				return true;
			}
			if (HasFlag(value, TypeNameHandling.Auto))
			{
				if (member != null)
				{
					if (contract.UnderlyingType != member.PropertyContract.CreatedType)
					{
						return true;
					}
				}
				else if (containerContract != null)
				{
					if (containerContract.ItemContract == null || contract.UnderlyingType != containerContract.ItemContract.CreatedType)
					{
						return true;
					}
				}
				else if (_rootContract != null && _serializeStack.Count == _rootLevel && contract.UnderlyingType != _rootContract.CreatedType)
				{
					return true;
				}
			}
			return false;
		}

		private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			object obj = ((!(values is Newtonsoft.Json.Utilities.IWrappedDictionary wrappedDictionary)) ? values : wrappedDictionary.UnderlyingDictionary);
			OnSerializing(writer, contract, obj);
			_serializeStack.Add(obj);
			WriteObjectStart(writer, obj, contract, member, collectionContract, containerProperty);
			if (contract.ItemContract == null)
			{
				contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.DictionaryValueType ?? typeof(object));
			}
			if (contract.KeyContract == null)
			{
				contract.KeyContract = Serializer._contractResolver.ResolveContract(contract.DictionaryKeyType ?? typeof(object));
			}
			int top = writer.Top;
			foreach (DictionaryEntry value2 in values)
			{
				string propertyName = GetPropertyName(writer, value2.Key, contract.KeyContract, out var escape);
				propertyName = ((contract.PropertyNameResolver == null) ? propertyName : contract.PropertyNameResolver(propertyName));
				try
				{
					object value = value2.Value;
					JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
					if (ShouldWriteReference(value, null, jsonContract, contract, member))
					{
						writer.WritePropertyName(propertyName, escape);
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
					{
						writer.WritePropertyName(propertyName, escape);
						SerializeValue(writer, value, jsonContract, null, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(obj, contract, propertyName, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, obj);
		}

		private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, out bool escape)
		{
			if (contract.ContractType == JsonContractType.Primitive)
			{
				JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
				if (jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTime || jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTimeNullable)
				{
					escape = false;
					StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
					Newtonsoft.Json.Utilities.DateTimeUtils.WriteDateTimeString(stringWriter, (DateTime)name, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
					return stringWriter.ToString();
				}
				escape = true;
				return Convert.ToString(name, CultureInfo.InvariantCulture);
			}
			if (TryConvertToString(name, name.GetType(), out var s))
			{
				escape = true;
				return s;
			}
			escape = true;
			return name.ToString();
		}

		private void HandleError(JsonWriter writer, int initialDepth)
		{
			ClearErrorContext();
			if (writer.WriteState == WriteState.Property)
			{
				writer.WriteNull();
			}
			while (writer.Top > initialDepth)
			{
				writer.WriteEnd();
			}
		}

		private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
		{
			if (property.ShouldSerialize == null)
			{
				return true;
			}
			bool flag = property.ShouldSerialize(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "ShouldSerialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}

		private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
		{
			if (property.GetIsSpecified == null)
			{
				return true;
			}
			bool flag = property.GetIsSpecified(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "IsSpecified result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}
	}
	internal class JsonSerializerProxy : JsonSerializer
	{
		private readonly JsonSerializerInternalReader _serializerReader;

		private readonly JsonSerializerInternalWriter _serializerWriter;

		private readonly JsonSerializer _serializer;

		public override IReferenceResolver ReferenceResolver
		{
			get
			{
				return _serializer.ReferenceResolver;
			}
			set
			{
				_serializer.ReferenceResolver = value;
			}
		}

		public override ITraceWriter TraceWriter
		{
			get
			{
				return _serializer.TraceWriter;
			}
			set
			{
				_serializer.TraceWriter = value;
			}
		}

		public override JsonConverterCollection Converters => _serializer.Converters;

		public override DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _serializer.DefaultValueHandling;
			}
			set
			{
				_serializer.DefaultValueHandling = value;
			}
		}

		public override IContractResolver ContractResolver
		{
			get
			{
				return _serializer.ContractResolver;
			}
			set
			{
				_serializer.ContractResolver = value;
			}
		}

		public override MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _serializer.MissingMemberHandling;
			}
			set
			{
				_serializer.MissingMemberHandling = value;
			}
		}

		public override NullValueHandling NullValueHandling
		{
			get
			{
				return _serializer.NullValueHandling;
			}
			set
			{
				_serializer.NullValueHandling = value;
			}
		}

		public override ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _serializer.ObjectCreationHandling;
			}
			set
			{
				_serializer.ObjectCreationHandling = value;
			}
		}

		public override ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _serializer.ReferenceLoopHandling;
			}
			set
			{
				_serializer.ReferenceLoopHandling = value;
			}
		}

		public override PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _serializer.PreserveReferencesHandling;
			}
			set
			{
				_serializer.PreserveReferencesHandling = value;
			}
		}

		public override TypeNameHandling TypeNameHandling
		{
			get
			{
				return _serializer.TypeNameHandling;
			}
			set
			{
				_serializer.TypeNameHandling = value;
			}
		}

		public override MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _serializer.MetadataPropertyHandling;
			}
			set
			{
				_serializer.MetadataPropertyHandling = value;
			}
		}

		public override FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _serializer.TypeNameAssemblyFormat;
			}
			set
			{
				_serializer.TypeNameAssemblyFormat = value;
			}
		}

		public override ConstructorHandling ConstructorHandling
		{
			get
			{
				return _serializer.ConstructorHandling;
			}
			set
			{
				_serializer.ConstructorHandling = value;
			}
		}

		public override SerializationBinder Binder
		{
			get
			{
				return _serializer.Binder;
			}
			set
			{
				_serializer.Binder = value;
			}
		}

		public override StreamingContext Context
		{
			get
			{
				return _serializer.Context;
			}
			set
			{
				_serializer.Context = value;
			}
		}

		public override Formatting Formatting
		{
			get
			{
				return _serializer.Formatting;
			}
			set
			{
				_serializer.Formatting = value;
			}
		}

		public override DateFormatHandling DateFormatHandling
		{
			get
			{
				return _serializer.DateFormatHandling;
			}
			set
			{
				_serializer.DateFormatHandling = value;
			}
		}

		public override DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _serializer.DateTimeZoneHandling;
			}
			set
			{
				_serializer.DateTimeZoneHandling = value;
			}
		}

		public override DateParseHandling DateParseHandling
		{
			get
			{
				return _serializer.DateParseHandling;
			}
			set
			{
				_serializer.DateParseHandling = value;
			}
		}

		public override FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _serializer.FloatFormatHandling;
			}
			set
			{
				_serializer.FloatFormatHandling = value;
			}
		}

		public override FloatParseHandling FloatParseHandling
		{
			get
			{
				return _serializer.FloatParseHandling;
			}
			set
			{
				_serializer.FloatParseHandling = value;
			}
		}

		public override StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _serializer.StringEscapeHandling;
			}
			set
			{
				_serializer.StringEscapeHandling = value;
			}
		}

		public override string DateFormatString
		{
			get
			{
				return _serializer.DateFormatString;
			}
			set
			{
				_serializer.DateFormatString = value;
			}
		}

		public override CultureInfo Culture
		{
			get
			{
				return _serializer.Culture;
			}
			set
			{
				_serializer.Culture = value;
			}
		}

		public override int? MaxDepth
		{
			get
			{
				return _serializer.MaxDepth;
			}
			set
			{
				_serializer.MaxDepth = value;
			}
		}

		public override bool CheckAdditionalContent
		{
			get
			{
				return _serializer.CheckAdditionalContent;
			}
			set
			{
				_serializer.CheckAdditionalContent = value;
			}
		}

		public override event EventHandler<ErrorEventArgs> Error
		{
			add
			{
				_serializer.Error += value;
			}
			remove
			{
				_serializer.Error -= value;
			}
		}

		public JsonSerializerProxy(JsonSerializerInternalReader serializerReader)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(serializerReader, "serializerReader");
			_serializerReader = serializerReader;
			_serializer = serializerReader.Serializer;
		}

		public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(serializerWriter, "serializerWriter");
			_serializerWriter = serializerWriter;
			_serializer = serializerWriter.Serializer;
		}

		internal JsonSerializerInternalBase GetInternalSerializer()
		{
			if (_serializerReader != null)
			{
				return _serializerReader;
			}
			return _serializerWriter;
		}

		internal override object DeserializeInternal(JsonReader reader, Type objectType)
		{
			if (_serializerReader != null)
			{
				return _serializerReader.Deserialize(reader, objectType, checkAdditionalContent: false);
			}
			return _serializer.Deserialize(reader, objectType);
		}

		internal override void PopulateInternal(JsonReader reader, object target)
		{
			if (_serializerReader != null)
			{
				_serializerReader.Populate(reader, target);
			}
			else
			{
				_serializer.Populate(reader, target);
			}
		}

		internal override void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType)
		{
			if (_serializerWriter != null)
			{
				_serializerWriter.Serialize(jsonWriter, value, rootType);
			}
			else
			{
				_serializer.Serialize(jsonWriter, value);
			}
		}
	}
	public class JsonStringContract : JsonPrimitiveContract
	{
		public JsonStringContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.String;
		}
	}
	internal static class JsonTypeReflector
	{
		private static bool? _fullyTrusted;

		public const string IdPropertyName = "$id";

		public const string RefPropertyName = "$ref";

		public const string TypePropertyName = "$type";

		public const string ValuePropertyName = "$value";

		public const string ArrayValuesPropertyName = "$values";

		public const string ShouldSerializePrefix = "ShouldSerialize";

		public const string SpecifiedPostfix = "Specified";

		private static readonly Newtonsoft.Json.Utilities.ThreadSafeStore<Type, Func<object[], JsonConverter>> JsonConverterCreatorCache = new Newtonsoft.Json.Utilities.ThreadSafeStore<Type, Func<object[], JsonConverter>>(GetJsonConverterCreator, new TypeKeyMaker());

		public static bool FullyTrusted
		{
			get
			{
				bool? fullyTrusted = _fullyTrusted;
				if (!fullyTrusted.HasValue)
				{
					try
					{
						new SecurityPermission(PermissionState.Unrestricted).Demand();
						_fullyTrusted = true;
					}
					catch (Exception)
					{
						_fullyTrusted = false;
					}
				}
				return _fullyTrusted.Value;
			}
		}

		public static Newtonsoft.Json.Utilities.ReflectionDelegateFactory ReflectionDelegateFactory => Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory.Instance;

		public static T GetCachedAttribute<T>(object attributeProvider) where T : Attribute
		{
			return CachedAttributeGetter<T>.GetAttribute(attributeProvider);
		}

		public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute)
		{
			JsonObjectAttribute cachedAttribute = GetCachedAttribute<JsonObjectAttribute>(objectType);
			if (cachedAttribute != null)
			{
				return cachedAttribute.MemberSerialization;
			}
			if (!ignoreSerializableAttribute)
			{
				SerializableAttribute cachedAttribute2 = GetCachedAttribute<SerializableAttribute>(objectType);
				if (cachedAttribute2 != null)
				{
					return MemberSerialization.Fields;
				}
			}
			return MemberSerialization.OptOut;
		}

		public static JsonConverter GetJsonConverter(object attributeProvider)
		{
			JsonConverterAttribute cachedAttribute = GetCachedAttribute<JsonConverterAttribute>(attributeProvider);
			if (cachedAttribute != null)
			{
				Func<object[], JsonConverter> func = JsonConverterCreatorCache.Get(cachedAttribute.ConverterType);
				if (func != null)
				{
					return func(cachedAttribute.ConverterParameters);
				}
			}
			return null;
		}

		public static JsonConverter CreateJsonConverterInstance(Type converterType, object[] converterArgs)
		{
			Func<object[], JsonConverter> func = JsonConverterCreatorCache.Get(converterType);
			return func(converterArgs);
		}

		private static Func<object[], JsonConverter> GetJsonConverterCreator(Type converterType)
		{
			Func<object> defaultConstructor = ((!Newtonsoft.Json.Utilities.ReflectionUtils.HasDefaultConstructor(converterType, nonPublic: false)) ? null : ReflectionDelegateFactory.CreateDefaultConstructor<object>(converterType));
			return delegate(object[] parameters)
			{
				try
				{
					if (parameters != null)
					{
						ObjectConstructor<object> objectConstructor = null;
						Type[] types = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Select(parameters, (object param) => param.GetType()));
						ConstructorInfo constructor = converterType.GetConstructor(types);
						if (constructor == null)
						{
							throw new JsonException("No matching parameterized constructor found for '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType));
						}
						objectConstructor = ReflectionDelegateFactory.CreateParametrizedConstructor(constructor);
						return (JsonConverter)objectConstructor(parameters);
					}
					if (defaultConstructor == null)
					{
						throw new JsonException("No parameterless constructor defined for '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType));
					}
					return (JsonConverter)defaultConstructor();
				}
				catch (Exception innerException)
				{
					throw new JsonException("Error creating '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType), innerException);
				}
			};
		}

		public static TypeConverter GetTypeConverter(Type type)
		{
			return TypeDescriptor.GetConverter(type);
		}

		private static T GetAttribute<T>(Type type) where T : Attribute
		{
			T attribute = Newtonsoft.Json.Utilities.ReflectionUtils.GetAttribute<T>(type, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type attributeProvider in interfaces)
			{
				attribute = Newtonsoft.Json.Utilities.ReflectionUtils.GetAttribute<T>(attributeProvider, inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
			return (T)null;
		}

		private static T GetAttribute<T>(MemberInfo memberInfo) where T : Attribute
		{
			T attribute = Newtonsoft.Json.Utilities.ReflectionUtils.GetAttribute<T>(memberInfo, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			if (memberInfo.DeclaringType != null)
			{
				Type[] interfaces = memberInfo.DeclaringType.GetInterfaces();
				foreach (Type targetType in interfaces)
				{
					MemberInfo memberInfoFromType = Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberInfoFromType(targetType, memberInfo);
					if (memberInfoFromType != null)
					{
						attribute = Newtonsoft.Json.Utilities.ReflectionUtils.GetAttribute<T>(memberInfoFromType, inherit: true);
						if (attribute != null)
						{
							return attribute;
						}
					}
				}
			}
			return (T)null;
		}

		public static T GetAttribute<T>(object provider) where T : Attribute
		{
			if (provider is Type type)
			{
				return GetAttribute<T>(type);
			}
			if (provider is MemberInfo memberInfo)
			{
				return GetAttribute<T>(memberInfo);
			}
			return Newtonsoft.Json.Utilities.ReflectionUtils.GetAttribute<T>(provider, inherit: true);
		}
	}
	public class MemoryTraceWriter : ITraceWriter
	{
		private readonly Queue<string> _traceMessages;

		public TraceLevel LevelFilter { get; set; }

		public MemoryTraceWriter()
		{
			LevelFilter = TraceLevel.Verbose;
			_traceMessages = new Queue<string>();
		}

		public void Trace(TraceLevel level, string message, Exception ex)
		{
			string item = DateTime.Now.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff", CultureInfo.InvariantCulture) + " " + level.ToString("g") + " " + message;
			if (_traceMessages.Count >= 1000)
			{
				_traceMessages.Dequeue();
			}
			_traceMessages.Enqueue(item);
		}

		public IEnumerable<string> GetTraceMessages()
		{
			return _traceMessages;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			foreach (string traceMessage in _traceMessages)
			{
				if (stringBuilder.Length > 0)
				{
					stringBuilder.AppendLine();
				}
				stringBuilder.Append(traceMessage);
			}
			return stringBuilder.ToString();
		}
	}
	public delegate object ObjectConstructor<T>(params object[] args);
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	public sealed class OnErrorAttribute : Attribute
	{
	}
	public class ReflectionAttributeProvider : IAttributeProvider
	{
		private readonly object _attributeProvider;

		public ReflectionAttributeProvider(object attributeProvider)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
			_attributeProvider = attributeProvider;
		}

		public IList<Attribute> GetAttributes(bool inherit)
		{
			return Newtonsoft.Json.Utilities.ReflectionUtils.GetAttributes(_attributeProvider, null, inherit);
		}

		public IList<Attribute> GetAttributes(Type attributeType, bool inherit)
		{
			return Newtonsoft.Json.Utilities.ReflectionUtils.GetAttributes(_attributeProvider, attributeType, inherit);
		}
	}
	public class ReflectionValueProvider : IValueProvider
	{
		private readonly MemberInfo _memberInfo;

		public ReflectionValueProvider(MemberInfo memberInfo)
		{
			Newtonsoft.Json.Utilities.ValidationUtils.ArgumentNotNull(memberInfo, "memberInfo");
			_memberInfo = memberInfo;
		}

		public void SetValue(object target, object value)
		{
			try
			{
				Newtonsoft.Json.Utilities.ReflectionUtils.SetMemberValue(_memberInfo, target, value);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}

		public object GetValue(object target)
		{
			try
			{
				return Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberValue(_memberInfo, target);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}
	}
	internal class TraceJsonReader : JsonReader, IJsonLineInfo
	{
		private readonly JsonReader _innerReader;

		private readonly JsonTextWriter _textWriter;

		private readonly StringWriter _sw;

		int IJsonLineInfo.LineNumber => (_innerReader is IJsonLineInfo jsonLineInfo) ? jsonLineInfo.LineNumber : 0;

		int IJsonLineInfo.LinePosition => (_innerReader is IJsonLineInfo jsonLineInfo) ? jsonLineInfo.LinePosition : 0;

		public override int Depth => _innerReader.Depth;

		public override string Path => _innerReader.Path;

		public override char QuoteChar
		{
			get
			{
				return _innerReader.QuoteChar;
			}
			protected internal set
			{
				_innerReader.QuoteChar = value;
			}
		}

		public override JsonToken TokenType => _innerReader.TokenType;

		public override object Value => _innerReader.Value;

		public override Type ValueType => _innerReader.ValueType;

		public TraceJsonReader(JsonReader innerReader)
		{
			_innerReader = innerReader;
			_sw = new StringWriter(CultureInfo.InvariantCulture);
			_textWriter = new JsonTextWriter(_sw);
			_textWriter.Formatting = Formatting.Indented;
		}

		public string GetJson()
		{
			return _sw.ToString();
		}

		public override bool Read()
		{
			bool result = _innerReader.Read();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false);
			return result;
		}

		public override int? ReadAsInt32()
		{
			int? result = _innerReader.ReadAsInt32();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false);
			return result;
		}

		public override string ReadAsString()
		{
			string result = _innerReader.ReadAsString();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false);
			return result;
		}

		public override byte[] ReadAsBytes()
		{
			byte[] result = _innerReader.ReadAsBytes();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false);
			return result;
		}

		public override decimal? ReadAsDecimal()
		{
			decimal? result = _innerReader.ReadAsDecimal();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false);
			return result;
		}

		public override DateTime? ReadAsDateTime()
		{
			DateTime? result = _innerReader.ReadAsDateTime();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false);
			return result;
		}

		public override void Close()
		{
			_innerReader.Close();
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			return _innerReader is IJsonLineInfo jsonLineInfo && jsonLineInfo.HasLineInfo();
		}
	}
	internal class TraceJsonWriter : JsonWriter
	{
		private readonly JsonWriter _innerWriter;

		private readonly JsonTextWriter _textWriter;

		private readonly StringWriter _sw;

		public TraceJsonWriter(JsonWriter innerWriter)
		{
			_innerWriter = innerWriter;
			_sw = new StringWriter(CultureInfo.InvariantCulture);
			_textWriter = new JsonTextWriter(_sw);
			_textWriter.Formatting = Formatting.Indented;
			_textWriter.Culture = innerWriter.Culture;
			_textWriter.DateFormatHandling = innerWriter.DateFormatHandling;
			_textWriter.DateFormatString = innerWriter.DateFormatString;
			_textWriter.DateTimeZoneHandling = innerWriter.DateTimeZoneHandling;
			_textWriter.FloatFormatHandling = innerWriter.FloatFormatHandling;
		}

		public string GetJson()
		{
			return _sw.ToString();
		}

		public override void WriteValue(decimal value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(bool value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(byte value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(byte? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(char value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(byte[] value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(DateTime value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(double value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteUndefined()
		{
			_textWriter.WriteUndefined();
			_innerWriter.WriteUndefined();
			base.WriteUndefined();
		}

		public override void WriteNull()
		{
			_textWriter.WriteNull();
			_innerWriter.WriteNull();
			base.WriteUndefined();
		}

		public override void WriteValue(float value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(Guid value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(int value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(long value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(object value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(sbyte value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(short value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(string value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(TimeSpan value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(uint value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(ulong value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(Uri value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(ushort value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteWhitespace(string ws)
		{
			_textWriter.WriteWhitespace(ws);
			_innerWriter.WriteWhitespace(ws);
			base.WriteWhitespace(ws);
		}

		public override void WriteComment(string text)
		{
			_textWriter.WriteComment(text);
			_innerWriter.WriteComment(text);
			base.WriteComment(text);
		}

		public override void WriteStartArray()
		{
			_textWriter.WriteStartArray();
			_innerWriter.WriteStartArray();
			base.WriteStartArray();
		}

		public override void WriteEndArray()
		{
			_textWriter.WriteEndArray();
			_innerWriter.WriteEndArray();
			base.WriteEndArray();
		}

		public override void WriteStartConstructor(string name)
		{
			_textWriter.WriteStartConstructor(name);
			_innerWriter.WriteStartConstructor(name);
			base.WriteStartConstructor(name);
		}

		public override void WriteEndConstructor()
		{
			_textWriter.WriteEndConstructor();
			_innerWriter.WriteEndConstructor();
			base.WriteEndConstructor();
		}

		public override void WritePropertyName(string name)
		{
			_textWriter.WritePropertyName(name);
			_innerWriter.WritePropertyName(name);
			base.WritePropertyName(name);
		}

		public override void WritePropertyName(string name, bool escape)
		{
			_textWriter.WritePropertyName(name, escape);
			_innerWriter.WritePropertyName(name, escape);
			base.WritePropertyName(name);
		}

		public override void WriteStartObject()
		{
			_textWriter.WriteStartObject();
			_innerWriter.WriteStartObject();
			base.WriteStartObject();
		}

		public override void WriteEndObject()
		{
			_textWriter.WriteEndObject();
			_innerWriter.WriteEndObject();
			base.WriteEndObject();
		}

		public override void WriteRaw(string json)
		{
			_textWriter.WriteRaw(json);
			_innerWriter.WriteRaw(json);
			base.WriteRaw(json);
		}

		public override void WriteRawValue(string json)
		{
			_textWriter.WriteRawValue(json);
			_innerWriter.WriteRawValue(json);
			base.WriteRawValue(json);
		}

		public override void Close()
		{
			_textWriter.Close();
			_innerWriter.Close();
			base.Close();
		}

		public override void Flush()
		{
			_textWriter.Flush();
			_innerWriter.Flush();
		}
	}
}
namespace Newtonsoft.Json
{
	public enum StringEscapeHandling
	{
		Default,
		EscapeNonAscii,
		EscapeHtml
	}
	[Flags]
	public enum TypeNameHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		All = 3,
		Auto = 4
	}
}
namespace Newtonsoft.Json.Utilities
{
	public interface StringKeyMaker<T>
	{
		string MakeStringKey(T obj);
	}
	public class TypeKeyMaker : StringKeyMaker<Type>
	{
		public static string MakeKey(Type t)
		{
			return (t == null) ? "null" : (t.Assembly.FullName + ":" + t.FullName);
		}

		public string MakeStringKey(Type t)
		{
			return (t == null) ? "null" : (t.Assembly.FullName + ":" + t.FullName);
		}
	}
	internal class Base64Encoder
	{
		private const int Base64LineSize = 76;

		private const int LineSizeInBytes = 57;

		private readonly char[] _charsLine = new char[76];

		private readonly TextWriter _writer;

		private byte[] _leftOverBytes;

		private int _leftOverBytesCount;

		public Base64Encoder(TextWriter writer)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = writer;
		}

		public void Encode(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > buffer.Length - index)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (_leftOverBytesCount > 0)
			{
				int leftOverBytesCount = _leftOverBytesCount;
				while (leftOverBytesCount < 3 && count > 0)
				{
					_leftOverBytes[leftOverBytesCount++] = buffer[index++];
					count--;
				}
				if (count == 0 && leftOverBytesCount < 3)
				{
					_leftOverBytesCount = leftOverBytesCount;
					return;
				}
				int count2 = Convert.ToBase64CharArray(_leftOverBytes, 0, 3, _charsLine, 0);
				WriteChars(_charsLine, 0, count2);
			}
			_leftOverBytesCount = count % 3;
			if (_leftOverBytesCount > 0)
			{
				count -= _leftOverBytesCount;
				if (_leftOverBytes == null)
				{
					_leftOverBytes = new byte[3];
				}
				for (int i = 0; i < _leftOverBytesCount; i++)
				{
					_leftOverBytes[i] = buffer[index + count + i];
				}
			}
			int num = index + count;
			int num2 = 57;
			while (index < num)
			{
				if (index + num2 > num)
				{
					num2 = num - index;
				}
				int count3 = Convert.ToBase64CharArray(buffer, index, num2, _charsLine, 0);
				WriteChars(_charsLine, 0, count3);
				index += num2;
			}
		}

		public void Flush()
		{
			if (_leftOverBytesCount > 0)
			{
				int count = Convert.ToBase64CharArray(_leftOverBytes, 0, _leftOverBytesCount, _charsLine, 0);
				WriteChars(_charsLine, 0, count);
				_leftOverBytesCount = 0;
			}
		}

		private void WriteChars(char[] chars, int index, int count)
		{
			_writer.Write(chars, index, count);
		}
	}
	internal class BidirectionalDictionary<TFirst, TSecond>
	{
		private readonly IDictionary<TFirst, TSecond> _firstToSecond;

		private readonly IDictionary<TSecond, TFirst> _secondToFirst;

		private readonly string _duplicateFirstErrorMessage;

		private readonly string _duplicateSecondErrorMessage;

		public BidirectionalDictionary()
			: this((IEqualityComparer<TFirst>)EqualityComparer<TFirst>.Default, (IEqualityComparer<TSecond>)EqualityComparer<TSecond>.Default)
		{
		}

		public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer)
			: this(firstEqualityComparer, secondEqualityComparer, "Duplicate item already exists for '{0}'.", "Duplicate item already exists for '{0}'.")
		{
		}

		public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
		{
			_firstToSecond = new Dictionary<TFirst, TSecond>(firstEqualityComparer);
			_secondToFirst = new Dictionary<TSecond, TFirst>(secondEqualityComparer);
			_duplicateFirstErrorMessage = duplicateFirstErrorMessage;
			_duplicateSecondErrorMessage = duplicateSecondErrorMessage;
		}

		public void Set(TFirst first, TSecond second)
		{
			if (_firstToSecond.TryGetValue(first, out var value) && !value.Equals(second))
			{
				throw new ArgumentException(_duplicateFirstErrorMessage.FormatWith(CultureInfo.InvariantCulture, first));
			}
			if (_secondToFirst.TryGetValue(second, out var value2) && !value2.Equals(first))
			{
				throw new ArgumentException(_duplicateSecondErrorMessage.FormatWith(CultureInfo.InvariantCulture, second));
			}
			_firstToSecond.Add(first, second);
			_secondToFirst.Add(second, first);
		}

		public bool TryGetByFirst(TFirst first, out TSecond second)
		{
			return _firstToSecond.TryGetValue(first, out second);
		}

		public bool TryGetBySecond(TSecond second, out TFirst first)
		{
			return _secondToFirst.TryGetValue(second, out first);
		}
	}
	internal static class CollectionUtils
	{
		public static bool IsNullOrEmpty<T>(ICollection<T> collection)
		{
			if (collection != null)
			{
				return collection.Count == 0;
			}
			return true;
		}

		public static void AddRange<T>(this IList<T> initial, IEnumerable<T> collection)
		{
			if (initial == null)
			{
				throw new ArgumentNullException("initial");
			}
			if (collection == null)
			{
				return;
			}
			foreach (T item in collection)
			{
				initial.Add(item);
			}
		}

		public static void AddRange<T>(this IList<T> initial, IEnumerable collection)
		{
			ValidationUtils.ArgumentNotNull(initial, "initial");
			initial.AddRange(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<T>(collection));
		}

		public static bool IsDictionaryType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (typeof(IDictionary).IsAssignableFrom(type))
			{
				return true;
			}
			if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(IDictionary<, >)))
			{
				return true;
			}
			return false;
		}

		public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType)
		{
			Type type = typeof(IEnumerable<>).MakeGenericType(collectionItemType);
			ConstructorInfo constructorInfo = null;
			ConstructorInfo[] constructors = collectionType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
			foreach (ConstructorInfo constructorInfo2 in constructors)
			{
				IList<ParameterInfo> parameters = constructorInfo2.GetParameters();
				if (parameters.Count == 1)
				{
					if (type == parameters[0].ParameterType)
					{
						constructorInfo = constructorInfo2;
						break;
					}
					if (constructorInfo == null && type.IsAssignableFrom(parameters[0].ParameterType))
					{
						constructorInfo = constructorInfo2;
					}
				}
			}
			return constructorInfo;
		}

		public static bool AddDistinct<T>(this IList<T> list, T value)
		{
			return list.AddDistinct(value, EqualityComparer<T>.Default);
		}

		public static bool AddDistinct<T>(this IList<T> list, T value, IEqualityComparer<T> comparer)
		{
			if (list.ContainsValue(value, comparer))
			{
				return false;
			}
			list.Add(value);
			return true;
		}

		public static bool ContainsValue<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TSource>.Default;
			}
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, value))
				{
					return true;
				}
			}
			return false;
		}

		public static bool AddRangeDistinct<T>(this IList<T> list, IEnumerable<T> values, IEqualityComparer<T> comparer)
		{
			bool result = true;
			foreach (T value in values)
			{
				if (!list.AddDistinct(value, comparer))
				{
					result = false;
				}
			}
			return result;
		}

		public static int IndexOf<T>(this IEnumerable<T> collection, Func<T, bool> predicate)
		{
			int num = 0;
			foreach (T item in collection)
			{
				if (predicate(item))
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		public static int IndexOf<TSource>(this IEnumerable<TSource> list, TSource value, IEqualityComparer<TSource> comparer)
		{
			int num = 0;
			foreach (TSource item in list)
			{
				if (comparer.Equals(item, value))
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		private static IList<int> GetDimensions(IList values, int dimensionsCount)
		{
			IList<int> list = new List<int>();
			IList list2 = values;
			while (true)
			{
				list.Add(list2.Count);
				if (list.Count == dimensionsCount || list2.Count == 0)
				{
					break;
				}
				object obj = list2[0];
				if (obj is IList)
				{
					list2 = (IList)obj;
					continue;
				}
				break;
			}
			return list;
		}

		private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, int[] indices)
		{
			int num = indices.Length;
			if (num == multidimensionalArray.Rank)
			{
				multidimensionalArray.SetValue(JaggedArrayGetValue(values, indices), indices);
				return;
			}
			int length = multidimensionalArray.GetLength(num);
			IList list = (IList)JaggedArrayGetValue(values, indices);
			int count = list.Count;
			if (count != length)
			{
				throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");
			}
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			for (int j = 0; j < multidimensionalArray.GetLength(num); j++)
			{
				array[num] = j;
				CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, array);
			}
		}

		private static object JaggedArrayGetValue(IList values, int[] indices)
		{
			IList list = values;
			for (int i = 0; i < indices.Length; i++)
			{
				int index = indices[i];
				if (i == indices.Length - 1)
				{
					return list[index];
				}
				list = (IList)list[index];
			}
			return list;
		}

		public static Array ToMultidimensionalArray(IList values, Type type, int rank)
		{
			IList<int> dimensions = GetDimensions(values, rank);
			while (dimensions.Count < rank)
			{
				dimensions.Add(0);
			}
			Array array = Array.CreateInstance(type, Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(dimensions));
			CopyFromJaggedToMultidimensionalArray(values, array, new int[0]);
			return array;
		}
	}
	internal interface IWrappedCollection : IList, IEnumerable, ICollection
	{
		object UnderlyingCollection { get; }
	}
	internal class CollectionWrapper<T> : ICollection<T>, IWrappedCollection, IEnumerable, IEnumerable<T>, IList, ICollection
	{
		private readonly IList _list;

		private readonly ICollection<T> _genericCollection;

		private object _syncRoot;

		bool IList.IsFixedSize
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsFixedSize;
			}
		}

		object IList.this[int index]
		{
			get
			{
				if (_genericCollection != null)
				{
					throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
				}
				return _list[index];
			}
			set
			{
				if (_genericCollection != null)
				{
					throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
				}
				VerifyValueType(value);
				_list[index] = (T)value;
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public virtual int Count
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.Count;
				}
				return _list.Count;
			}
		}

		public virtual bool IsReadOnly
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsReadOnly;
			}
		}

		public object UnderlyingCollection
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection;
				}
				return _list;
			}
		}

		public CollectionWrapper(IList list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			if (list is ICollection<T>)
			{
				_genericCollection = (ICollection<T>)list;
			}
			else
			{
				_list = list;
			}
		}

		public CollectionWrapper(ICollection<T> list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			_genericCollection = list;
		}

		public virtual void Add(T item)
		{
			if (_genericCollection != null)
			{
				_genericCollection.Add(item);
			}
			else
			{
				_list.Add(item);
			}
		}

		public virtual void Clear()
		{
			if (_genericCollection != null)
			{
				_genericCollection.Clear();
			}
			else
			{
				_list.Clear();
			}
		}

		public virtual bool Contains(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Contains(item);
			}
			return _list.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			if (_genericCollection != null)
			{
				_genericCollection.CopyTo(array, arrayIndex);
			}
			else
			{
				_list.CopyTo(array, arrayIndex);
			}
		}

		public virtual bool Remove(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Remove(item);
			}
			bool flag = _list.Contains(item);
			if (flag)
			{
				_list.Remove(item);
			}
			return flag;
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			if (_genericCollection != null)
			{
				return _genericCollection.GetEnumerator();
			}
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<T>(_list).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			if (_genericCollection != null)
			{
				return _genericCollection.GetEnumerator();
			}
			return _list.GetEnumerator();
		}

		int IList.Add(object value)
		{
			VerifyValueType(value);
			Add((T)value);
			return Count - 1;
		}

		bool IList.Contains(object value)
		{
			if (IsCompatibleObject(value))
			{
				return Contains((T)value);
			}
			return false;
		}

		int IList.IndexOf(object value)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support IndexOf.");
			}
			if (IsCompatibleObject(value))
			{
				return _list.IndexOf((T)value);
			}
			return -1;
		}

		void IList.RemoveAt(int index)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support RemoveAt.");
			}
			_list.RemoveAt(index);
		}

		void IList.Insert(int index, object value)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support Insert.");
			}
			VerifyValueType(value);
			_list.Insert(index, (T)value);
		}

		void IList.Remove(object value)
		{
			if (IsCompatibleObject(value))
			{
				Remove((T)value);
			}
		}

		void ICollection.CopyTo(Array array, int arrayIndex)
		{
			CopyTo((T[])array, arrayIndex);
		}

		private static void VerifyValueType(object value)
		{
			if (!IsCompatibleObject(value))
			{
				throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith(CultureInfo.InvariantCulture, value, typeof(T)), "value");
			}
		}

		private static bool IsCompatibleObject(object value)
		{
			if (!(value is T) && (value != null || (typeof(T).IsValueType() && !ReflectionUtils.IsNullableType(typeof(T)))))
			{
				return false;
			}
			return true;
		}
	}
	internal enum PrimitiveTypeCode
	{
		Empty,
		Object,
		Char,
		CharNullable,
		Boolean,
		BooleanNullable,
		SByte,
		SByteNullable,
		Int16,
		Int16Nullable,
		UInt16,
		UInt16Nullable,
		Int32,
		Int32Nullable,
		Byte,
		ByteNullable,
		UInt32,
		UInt32Nullable,
		Int64,
		Int64Nullable,
		UInt64,
		UInt64Nullable,
		Single,
		SingleNullable,
		Double,
		DoubleNullable,
		DateTime,
		DateTimeNullable,
		DateTimeOffset,
		DateTimeOffsetNullable,
		Decimal,
		DecimalNullable,
		Guid,
		GuidNullable,
		TimeSpan,
		TimeSpanNullable,
		BigInteger,
		BigIntegerNullable,
		Uri,
		String,
		Bytes
	}
	internal class TypeInformation
	{
		public Type Type { get; set; }

		public PrimitiveTypeCode TypeCode { get; set; }
	}
	internal enum ParseResult
	{
		None,
		Success,
		Overflow,
		Invalid
	}
	internal static class ConvertUtils
	{
		internal struct TypeConvertKey : IEquatable<TypeConvertKey>
		{
			internal readonly Type _initialType;

			internal readonly Type _targetType;

			public Type InitialType => _initialType;

			public Type TargetType => _targetType;

			public TypeConvertKey(Type initialType, Type targetType)
			{
				_initialType = initialType;
				_targetType = targetType;
			}

			public override int GetHashCode()
			{
				return _initialType.GetHashCode() ^ _targetType.GetHashCode();
			}

			public override bool Equals(object obj)
			{
				if (!(obj is TypeConvertKey))
				{
					return false;
				}
				return Equals((TypeConvertKey)obj);
			}

			public bool Equals(TypeConvertKey other)
			{
				return _initialType == other._initialType && _targetType == other._targetType;
			}
		}

		internal class TypeConvertKeyComparer : EqualityComparer<TypeConvertKey>
		{
			public override int GetHashCode(TypeConvertKey obj)
			{
				return obj.GetHashCode();
			}

			public override bool Equals(TypeConvertKey x, TypeConvertKey y)
			{
				return x.Equals(y);
			}
		}

		internal class TypeConvertKeyStringKey : StringKeyMaker<TypeConvertKey>
		{
			public string MakeStringKey(TypeConvertKey typeConvertKey)
			{
				string text = ((typeConvertKey._initialType == null) ? "null" : (typeConvertKey._initialType.Assembly.FullName + ":" + typeConvertKey._initialType.FullName));
				string text2 = ((typeConvertKey._targetType == null) ? "null" : (typeConvertKey._targetType.Assembly.FullName + ":" + typeConvertKey._targetType.FullName));
				return text + "/" + text2;
			}
		}

		internal enum ConvertResult
		{
			Success,
			CannotConvertNull,
			NotInstantiableType,
			NoValidConversion
		}

		private static readonly Dictionary<Type, PrimitiveTypeCode> TypeCodeMap = new Dictionary<Type, PrimitiveTypeCode>
		{
			{
				typeof(char),
				PrimitiveTypeCode.Char
			},
			{
				typeof(char?),
				PrimitiveTypeCode.CharNullable
			},
			{
				typeof(bool),
				PrimitiveTypeCode.Boolean
			},
			{
				typeof(bool?),
				PrimitiveTypeCode.BooleanNullable
			},
			{
				typeof(sbyte),
				PrimitiveTypeCode.SByte
			},
			{
				typeof(sbyte?),
				PrimitiveTypeCode.SByteNullable
			},
			{
				typeof(short),
				PrimitiveTypeCode.Int16
			},
			{
				typeof(short?),
				PrimitiveTypeCode.Int16Nullable
			},
			{
				typeof(ushort),
				PrimitiveTypeCode.UInt16
			},
			{
				typeof(ushort?),
				PrimitiveTypeCode.UInt16Nullable
			},
			{
				typeof(int),
				PrimitiveTypeCode.Int32
			},
			{
				typeof(int?),
				PrimitiveTypeCode.Int32Nullable
			},
			{
				typeof(byte),
				PrimitiveTypeCode.Byte
			},
			{
				typeof(byte?),
				PrimitiveTypeCode.ByteNullable
			},
			{
				typeof(uint),
				PrimitiveTypeCode.UInt32
			},
			{
				typeof(uint?),
				PrimitiveTypeCode.UInt32Nullable
			},
			{
				typeof(long),
				PrimitiveTypeCode.Int64
			},
			{
				typeof(long?),
				PrimitiveTypeCode.Int64Nullable
			},
			{
				typeof(ulong),
				PrimitiveTypeCode.UInt64
			},
			{
				typeof(ulong?),
				PrimitiveTypeCode.UInt64Nullable
			},
			{
				typeof(float),
				PrimitiveTypeCode.Single
			},
			{
				typeof(float?),
				PrimitiveTypeCode.SingleNullable
			},
			{
				typeof(double),
				PrimitiveTypeCode.Double
			},
			{
				typeof(double?),
				PrimitiveTypeCode.DoubleNullable
			},
			{
				typeof(DateTime),
				PrimitiveTypeCode.DateTime
			},
			{
				typeof(DateTime?),
				PrimitiveTypeCode.DateTimeNullable
			},
			{
				typeof(decimal),
				PrimitiveTypeCode.Decimal
			},
			{
				typeof(decimal?),
				PrimitiveTypeCode.DecimalNullable
			},
			{
				typeof(Guid),
				PrimitiveTypeCode.Guid
			},
			{
				typeof(Guid?),
				PrimitiveTypeCode.GuidNullable
			},
			{
				typeof(TimeSpan),
				PrimitiveTypeCode.TimeSpan
			},
			{
				typeof(TimeSpan?),
				PrimitiveTypeCode.TimeSpanNullable
			},
			{
				typeof(Uri),
				PrimitiveTypeCode.Uri
			},
			{
				typeof(string),
				PrimitiveTypeCode.String
			},
			{
				typeof(byte[]),
				PrimitiveTypeCode.Bytes
			}
		};

		private static readonly TypeInformation[] PrimitiveTypeCodes = new TypeInformation[18]
		{
			new TypeInformation
			{
				Type = typeof(object),
				TypeCode = PrimitiveTypeCode.Empty
			},
			new TypeInformation
			{
				Type = typeof(object),
				TypeCode = PrimitiveTypeCode.Object
			},
			new TypeInformation
			{
				Type = typeof(bool),
				TypeCode = PrimitiveTypeCode.Boolean
			},
			new TypeInformation
			{
				Type = typeof(char),
				TypeCode = PrimitiveTypeCode.Char
			},
			new TypeInformation
			{
				Type = typeof(sbyte),
				TypeCode = PrimitiveTypeCode.SByte
			},
			new TypeInformation
			{
				Type = typeof(byte),
				TypeCode = PrimitiveTypeCode.Byte
			},
			new TypeInformation
			{
				Type = typeof(short),
				TypeCode = PrimitiveTypeCode.Int16
			},
			new TypeInformation
			{
				Type = typeof(ushort),
				TypeCode = PrimitiveTypeCode.UInt16
			},
			new TypeInformation
			{
				Type = typeof(int),
				TypeCode = PrimitiveTypeCode.Int32
			},
			new TypeInformation
			{
				Type = typeof(uint),
				TypeCode = PrimitiveTypeCode.UInt32
			},
			new TypeInformation
			{
				Type = typeof(long),
				TypeCode = PrimitiveTypeCode.Int64
			},
			new TypeInformation
			{
				Type = typeof(ulong),
				TypeCode = PrimitiveTypeCode.UInt64
			},
			new TypeInformation
			{
				Type = typeof(float),
				TypeCode = PrimitiveTypeCode.Single
			},
			new TypeInformation
			{
				Type = typeof(double),
				TypeCode = PrimitiveTypeCode.Double
			},
			new TypeInformation
			{
				Type = typeof(decimal),
				TypeCode = PrimitiveTypeCode.Decimal
			},
			new TypeInformation
			{
				Type = typeof(DateTime),
				TypeCode = PrimitiveTypeCode.DateTime
			},
			new TypeInformation
			{
				Type = typeof(object),
				TypeCode = PrimitiveTypeCode.Empty
			},
			new TypeInformation
			{
				Type = typeof(string),
				TypeCode = PrimitiveTypeCode.String
			}
		};

		private static readonly ThreadSafeStore<TypeConvertKey, Func<object, object>> CastConverters = new ThreadSafeStore<TypeConvertKey, Func<object, object>>(CreateCastConverter, new TypeConvertKeyStringKey());

		public static PrimitiveTypeCode GetTypeCode(Type t)
		{
			bool isEnum;
			return GetTypeCode(t, out isEnum);
		}

		public static PrimitiveTypeCode GetTypeCode(Type t, out bool isEnum)
		{
			if (TypeCodeMap.TryGetValue(t, out var value))
			{
				isEnum = false;
				return value;
			}
			if (t.IsEnum())
			{
				isEnum = true;
				return GetTypeCode(Enum.GetUnderlyingType(t));
			}
			if (ReflectionUtils.IsNullableType(t))
			{
				Type underlyingType = Nullable.GetUnderlyingType(t);
				if (underlyingType.IsEnum())
				{
					Type t2 = typeof(Nullable<>).MakeGenericType(Enum.GetUnderlyingType(underlyingType));
					isEnum = true;
					return GetTypeCode(t2);
				}
			}
			isEnum = false;
			return PrimitiveTypeCode.Object;
		}

		public static TypeInformation GetTypeInformation(IConvertible convertable)
		{
			return PrimitiveTypeCodes[(int)convertable.GetTypeCode()];
		}

		public static bool IsConvertible(Type t)
		{
			return typeof(IConvertible).IsAssignableFrom(t);
		}

		public static TimeSpan ParseTimeSpan(string input)
		{
			return TimeSpan.Parse(input);
		}

		private static Func<object, object> CreateCastConverter(TypeConvertKey t)
		{
			MethodInfo method = t.TargetType.GetMethod("op_Implicit", new Type[1] { t.InitialType });
			if (method == null)
			{
				method = t.TargetType.GetMethod("op_Explicit", new Type[1] { t.InitialType });
			}
			if (method == null)
			{
				return null;
			}
			MethodCall<object, object> call = Newtonsoft.Json.Serialization.JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object o) => call(null, o);
		}

		public static object Convert(object initialValue, CultureInfo culture, Type targetType)
		{
			object value;
			return TryConvertInternal(initialValue, culture, targetType, out value) switch
			{
				ConvertResult.Success => value, 
				ConvertResult.CannotConvertNull => throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
				ConvertResult.NotInstantiableType => throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith(CultureInfo.InvariantCulture, targetType), "targetType"), 
				ConvertResult.NoValidConversion => throw new InvalidOperationException("Can not convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
				_ => throw new InvalidOperationException("Unexpected conversion result."), 
			};
		}

		private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, out object value)
		{
			try
			{
				if (TryConvertInternal(initialValue, culture, targetType, out value) == ConvertResult.Success)
				{
					return true;
				}
				value = null;
				return false;
			}
			catch
			{
				value = null;
				return false;
			}
		}

		private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, out object value)
		{
			if (initialValue == null)
			{
				throw new ArgumentNullException("initialValue");
			}
			if (ReflectionUtils.IsNullableType(targetType))
			{
				targetType = Nullable.GetUnderlyingType(targetType);
			}
			Type type = initialValue.GetType();
			if (targetType == type)
			{
				value = initialValue;
				return ConvertResult.Success;
			}
			if (IsConvertible(initialValue.GetType()) && IsConvertible(targetType))
			{
				if (targetType.IsEnum())
				{
					if (initialValue is string)
					{
						value = Enum.Parse(targetType, initialValue.ToString(), ignoreCase: true);
						return ConvertResult.Success;
					}
					if (IsInteger(initialValue))
					{
						value = Enum.ToObject(targetType, initialValue);
						return ConvertResult.Success;
					}
				}
				value = System.Convert.ChangeType(initialValue, targetType, culture);
				return ConvertResult.Success;
			}
			if (initialValue is byte[] && targetType == typeof(Guid))
			{
				value = new Guid((byte[])initialValue);
				return ConvertResult.Success;
			}
			if (initialValue is Guid && targetType == typeof(byte[]))
			{
				value = ((Guid)initialValue).ToByteArray();
				return ConvertResult.Success;
			}
			if (initialValue is string)
			{
				if (targetType == typeof(Guid))
				{
					value = new Guid((string)initialValue);
					return ConvertResult.Success;
				}
				if (targetType == typeof(Uri))
				{
					value = new Uri((string)initialValue, UriKind.RelativeOrAbsolute);
					return ConvertResult.Success;
				}
				if (targetType == typeof(TimeSpan))
				{
					value = ParseTimeSpan((string)initialValue);
					return ConvertResult.Success;
				}
				if (targetType == typeof(byte[]))
				{
					value = System.Convert.FromBase64String((string)initialValue);
					return ConvertResult.Success;
				}
				if (typeof(Type).IsAssignableFrom(targetType))
				{
					value = Type.GetType((string)initialValue, throwOnError: true);
					return ConvertResult.Success;
				}
			}
			TypeConverter converter = GetConverter(type);
			if (converter != null && converter.CanConvertTo(targetType))
			{
				value = converter.ConvertTo(null, culture, initialValue, targetType);
				return ConvertResult.Success;
			}
			TypeConverter converter2 = GetConverter(targetType);
			if (converter2 != null && converter2.CanConvertFrom(type))
			{
				value = converter2.ConvertFrom(null, culture, initialValue);
				return ConvertResult.Success;
			}
			if (initialValue == DBNull.Value)
			{
				if (ReflectionUtils.IsNullable(targetType))
				{
					value = EnsureTypeAssignable(null, type, targetType);
					return ConvertResult.Success;
				}
				value = null;
				return ConvertResult.CannotConvertNull;
			}
			if (targetType.IsInterface() || targetType.IsGenericTypeDefinition() || targetType.IsAbstract())
			{
				value = null;
				return ConvertResult.NotInstantiableType;
			}
			value = null;
			return ConvertResult.NoValidConversion;
		}

		public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
		{
			if (targetType == typeof(object))
			{
				return initialValue;
			}
			if (initialValue == null && ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			if (TryConvert(initialValue, culture, targetType, out var value))
			{
				return value;
			}
			return EnsureTypeAssignable(initialValue, ReflectionUtils.GetObjectType(initialValue), targetType);
		}

		private static object EnsureTypeAssignable(object value, Type initialType, Type targetType)
		{
			Type type = value?.GetType();
			if (value != null)
			{
				if (targetType.IsAssignableFrom(type))
				{
					return value;
				}
				Func<object, object> func = CastConverters.Get(new TypeConvertKey(type, targetType));
				if (func != null)
				{
					return func(value);
				}
			}
			else if (ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			throw new ArgumentException("Could not cast or convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, (initialType == null) ? "{null}" : initialType.ToString(), targetType));
		}

		internal static TypeConverter GetConverter(Type t)
		{
			return Newtonsoft.Json.Serialization.JsonTypeReflector.GetTypeConverter(t);
		}

		public static bool IsInteger(object value)
		{
			switch (GetTypeCode(value.GetType()))
			{
			case PrimitiveTypeCode.SByte:
			case PrimitiveTypeCode.Int16:
			case PrimitiveTypeCode.UInt16:
			case PrimitiveTypeCode.Int32:
			case PrimitiveTypeCode.Byte:
			case PrimitiveTypeCode.UInt32:
			case PrimitiveTypeCode.Int64:
			case PrimitiveTypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		public static ParseResult Int32TryParse(char[] chars, int start, int length, out int value)
		{
			value = 0;
			if (length == 0)
			{
				return ParseResult.Invalid;
			}
			bool flag = chars[start] == '-';
			if (flag)
			{
				if (length == 1)
				{
					return ParseResult.Invalid;
				}
				start++;
				length--;
			}
			int num = start + length;
			for (int i = start; i < num; i++)
			{
				int num2 = chars[i] - 48;
				if (num2 < 0 || num2 > 9)
				{
					return ParseResult.Invalid;
				}
				int num3 = 10 * value - num2;
				if (num3 > value)
				{
					for (i++; i < num; i++)
					{
						num2 = chars[i] - 48;
						if (num2 < 0 || num2 > 9)
						{
							return ParseResult.Invalid;
						}
					}
					return ParseResult.Overflow;
				}
				value = num3;
			}
			if (!flag)
			{
				if (value == int.MinValue)
				{
					return ParseResult.Overflow;
				}
				value = -value;
			}
			return ParseResult.Success;
		}

		public static ParseResult Int64TryParse(char[] chars, int start, int length, out long value)
		{
			value = 0L;
			if (length == 0)
			{
				return ParseResult.Invalid;
			}
			bool flag = chars[start] == '-';
			if (flag)
			{
				if (length == 1)
				{
					return ParseResult.Invalid;
				}
				start++;
				length--;
			}
			int num = start + length;
			for (int i = start; i < num; i++)
			{
				int num2 = chars[i] - 48;
				if (num2 < 0 || num2 > 9)
				{
					return ParseResult.Invalid;
				}
				long num3 = 10 * value - num2;
				if (num3 > value)
				{
					for (i++; i < num; i++)
					{
						num2 = chars[i] - 48;
						if (num2 < 0 || num2 > 9)
						{
							return ParseResult.Invalid;
						}
					}
					return ParseResult.Overflow;
				}
				value = num3;
			}
			if (!flag)
			{
				if (value == long.MinValue)
				{
					return ParseResult.Overflow;
				}
				value = -value;
			}
			return ParseResult.Success;
		}

		public static bool TryConvertGuid(string s, out Guid g)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			Regex regex = new Regex("^[A-Fa-f0-9]{32}$|^({|\\()?[A-Fa-f0-9]{8}-([A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}(}|\\))?$|^({)?[0xA-Fa-f0-9]{3,10}(, {0,1}[0xA-Fa-f0-9]{3,6}){2}, {0,1}({)([0xA-Fa-f0-9]{3,4}, {0,1}){7}[0xA-Fa-f0-9]{3,4}(}})$");
			Match match = regex.Match(s);
			if (match.Success)
			{
				g = new Guid(s);
				return true;
			}
			g = Guid.Empty;
			return false;
		}
	}
	internal enum ParserTimeZone
	{
		Unspecified,
		Utc,
		LocalWestOfUtc,
		LocalEastOfUtc
	}
	internal struct DateTimeParser
	{
		public int Year;

		public int Month;

		public int Day;

		public int Hour;

		public int Minute;

		public int Second;

		public int Fraction;

		public int ZoneHour;

		public int ZoneMinute;

		public ParserTimeZone Zone;

		private string _text;

		private int _length;

		private static readonly int[] Power10;

		private static readonly int Lzyyyy;

		private static readonly int Lzyyyy_;

		private static readonly int Lzyyyy_MM;

		private static readonly int Lzyyyy_MM_;

		private static readonly int Lzyyyy_MM_dd;

		private static readonly int Lzyyyy_MM_ddT;

		private static readonly int LzHH;

		private static readonly int LzHH_;

		private static readonly int LzHH_mm;

		private static readonly int LzHH_mm_;

		private static readonly int LzHH_mm_ss;

		private static readonly int Lz_;

		private static readonly int Lz_zz;

		private const short MaxFractionDigits = 7;

		static DateTimeParser()
		{
			Power10 = new int[7] { -1, 10, 100, 1000, 10000, 100000, 1000000 };
			Lzyyyy = "yyyy".Length;
			Lzyyyy_ = "yyyy-".Length;
			Lzyyyy_MM = "yyyy-MM".Length;
			Lzyyyy_MM_ = "yyyy-MM-".Length;
			Lzyyyy_MM_dd = "yyyy-MM-dd".Length;
			Lzyyyy_MM_ddT = "yyyy-MM-ddT".Length;
			LzHH = "HH".Length;
			LzHH_ = "HH:".Length;
			LzHH_mm = "HH:mm".Length;
			LzHH_mm_ = "HH:mm:".Length;
			LzHH_mm_ss = "HH:mm:ss".Length;
			Lz_ = "-".Length;
			Lz_zz = "-zz".Length;
		}

		public bool Parse(string text)
		{
			_text = text;
			_length = text.Length;
			if (ParseDate(0) && ParseChar(Lzyyyy_MM_dd, 'T') && ParseTimeAndZoneAndWhitespace(Lzyyyy_MM_ddT))
			{
				return true;
			}
			return false;
		}

		private bool ParseDate(int start)
		{
			return Parse4Digit(start, out Year) && 1 <= Year && ParseChar(start + Lzyyyy, '-') && Parse2Digit(start + Lzyyyy_, out Month) && 1 <= Month && Month <= 12 && ParseChar(start + Lzyyyy_MM, '-') && Parse2Digit(start + Lzyyyy_MM_, out Day) && 1 <= Day && Day <= DateTime.DaysInMonth(Year, Month);
		}

		private bool ParseTimeAndZoneAndWhitespace(int start)
		{
			return ParseTime(ref start) && ParseZone(start);
		}

		private bool ParseTime(ref int start)
		{
			if (!Parse2Digit(start, out Hour) || Hour >= 24 || !ParseChar(start + LzHH, ':') || !Parse2Digit(start + LzHH_, out Minute) || Minute >= 60 || !ParseChar(start + LzHH_mm, ':') || !Parse2Digit(start + LzHH_mm_, out Second) || Second >= 60)
			{
				return false;
			}
			start += LzHH_mm_ss;
			if (ParseChar(start, '.'))
			{
				Fraction = 0;
				int num = 0;
				while (++start < _length && num < 7)
				{
					int num2 = _text[start] - 48;
					if (num2 < 0 || num2 > 9)
					{
						break;
					}
					Fraction = Fraction * 10 + num2;
					num++;
				}
				if (num < 7)
				{
					if (num == 0)
					{
						return false;
					}
					Fraction *= Power10[7 - num];
				}
			}
			return true;
		}

		private bool ParseZone(int start)
		{
			if (start < _length)
			{
				char c = _text[start];
				if (c == 'Z' || c == 'z')
				{
					Zone = ParserTimeZone.Utc;
					start++;
				}
				else
				{
					if (start + 2 < _length && Parse2Digit(start + Lz_, out ZoneHour) && ZoneHour <= 99)
					{
						switch (c)
						{
						case '-':
							Zone = ParserTimeZone.LocalWestOfUtc;
							start += Lz_zz;
							break;
						case '+':
							Zone = ParserTimeZone.LocalEastOfUtc;
							start += Lz_zz;
							break;
						}
					}
					if (start < _length)
					{
						if (ParseChar(start, ':'))
						{
							start++;
							if (start + 1 < _length && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
							{
								start += 2;
							}
						}
						else if (start + 1 < _length && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
						{
							start += 2;
						}
					}
				}
			}
			return start == _length;
		}

		private bool Parse4Digit(int start, out int num)
		{
			if (start + 3 < _length)
			{
				int num2 = _text[start] - 48;
				int num3 = _text[start + 1] - 48;
				int num4 = _text[start + 2] - 48;
				int num5 = _text[start + 3] - 48;
				if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10 && 0 <= num4 && num4 < 10 && 0 <= num5 && num5 < 10)
				{
					num = ((num2 * 10 + num3) * 10 + num4) * 10 + num5;
					return true;
				}
			}
			num = 0;
			return false;
		}

		private bool Parse2Digit(int start, out int num)
		{
			if (start + 1 < _length)
			{
				int num2 = _text[start] - 48;
				int num3 = _text[start + 1] - 48;
				if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10)
				{
					num = num2 * 10 + num3;
					return true;
				}
			}
			num = 0;
			return false;
		}

		private bool ParseChar(int start, char ch)
		{
			return start < _length && _text[start] == ch;
		}
	}
	internal static class DateTimeUtils
	{
		internal static readonly long InitialJavaScriptDateTicks;

		private const int DaysPer100Years = 36524;

		private const int DaysPer400Years = 146097;

		private const int DaysPer4Years = 1461;

		private const int DaysPerYear = 365;

		private const long TicksPerDay = 864000000000L;

		private static readonly int[] DaysToMonth365;

		private static readonly int[] DaysToMonth366;

		static DateTimeUtils()
		{
			InitialJavaScriptDateTicks = 621355968000000000L;
			DaysToMonth365 = new int[13]
			{
				0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
				304, 334, 365
			};
			DaysToMonth366 = new int[13]
			{
				0, 31, 60, 91, 121, 152, 182, 213, 244, 274,
				305, 335, 366
			};
		}

		public static TimeSpan GetUtcOffset(this DateTime d)
		{
			return TimeZone.CurrentTimeZone.GetUtcOffset(d);
		}

		public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
		{
			return kind switch
			{
				DateTimeKind.Local => XmlDateTimeSerializationMode.Local, 
				DateTimeKind.Unspecified => XmlDateTimeSerializationMode.Unspecified, 
				DateTimeKind.Utc => XmlDateTimeSerializationMode.Utc, 
				_ => throw MiscellaneousUtils.CreateArgumentOutOfRangeException("kind", kind, "Unexpected DateTimeKind value."), 
			};
		}

		internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
		{
			switch (timeZone)
			{
			case DateTimeZoneHandling.Local:
				value = SwitchToLocalTime(value);
				break;
			case DateTimeZoneHandling.Utc:
				value = SwitchToUtcTime(value);
				break;
			case DateTimeZoneHandling.Unspecified:
				value = new DateTime(value.Ticks, DateTimeKind.Unspecified);
				break;
			default:
				throw new ArgumentException("Invalid date time handling value.");
			case DateTimeZoneHandling.RoundtripKind:
				break;
			}
			return value;
		}

		private static DateTime SwitchToLocalTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Local), 
				DateTimeKind.Utc => value.ToLocalTime(), 
				DateTimeKind.Local => value, 
				_ => value, 
			};
		}

		private static DateTime SwitchToUtcTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Utc), 
				DateTimeKind.Utc => value, 
				DateTimeKind.Local => value.ToUniversalTime(), 
				_ => value, 
			};
		}

		private static long ToUniversalTicks(DateTime dateTime)
		{
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				return dateTime.Ticks;
			}
			return ToUniversalTicks(dateTime, dateTime.GetUtcOffset());
		}

		private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
		{
			if (dateTime.Kind == DateTimeKind.Utc || dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue)
			{
				return dateTime.Ticks;
			}
			long num = dateTime.Ticks - offset.Ticks;
			if (num > 3155378975999999999L)
			{
				return 3155378975999999999L;
			}
			if (num < 0)
			{
				return 0L;
			}
			return num;
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
		{
			long universialTicks = ToUniversalTicks(dateTime, offset);
			return UniversialTicksToJavaScriptTicks(universialTicks);
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
		{
			return ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: true);
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
		{
			long universialTicks = ((!convertToUtc) ? dateTime.Ticks : ToUniversalTicks(dateTime));
			return UniversialTicksToJavaScriptTicks(universialTicks);
		}

		private static long UniversialTicksToJavaScriptTicks(long universialTicks)
		{
			return (universialTicks - InitialJavaScriptDateTicks) / 10000;
		}

		internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
		{
			return new DateTime(javaScriptTicks * 10000 + InitialJavaScriptDateTicks, DateTimeKind.Utc);
		}

		internal static bool TryParseDateIso(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, out object dt)
		{
			DateTimeParser dateTimeParser = default(DateTimeParser);
			if (!dateTimeParser.Parse(text))
			{
				dt = null;
				return false;
			}
			DateTime dateTime = new DateTime(dateTimeParser.Year, dateTimeParser.Month, dateTimeParser.Day, dateTimeParser.Hour, dateTimeParser.Minute, dateTimeParser.Second).AddTicks(dateTimeParser.Fraction);
			switch (dateTimeParser.Zone)
			{
			case ParserTimeZone.Utc:
				dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
				break;
			case ParserTimeZone.LocalWestOfUtc:
			{
				TimeSpan timeSpan2 = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
				long num = dateTime.Ticks + timeSpan2.Ticks;
				if (num <= DateTime.MaxValue.Ticks)
				{
					dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
					break;
				}
				num += dateTime.GetUtcOffset().Ticks;
				if (num > DateTime.MaxValue.Ticks)
				{
					num = DateTime.MaxValue.Ticks;
				}
				dateTime = new DateTime(num, DateTimeKind.Local);
				break;
			}
			case ParserTimeZone.LocalEastOfUtc:
			{
				TimeSpan timeSpan = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
				long num = dateTime.Ticks - timeSpan.Ticks;
				if (num >= DateTime.MinValue.Ticks)
				{
					dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
					break;
				}
				num += dateTime.GetUtcOffset().Ticks;
				if (num < DateTime.MinValue.Ticks)
				{
					num = DateTime.MinValue.Ticks;
				}
				dateTime = new DateTime(num, DateTimeKind.Local);
				break;
			}
			}
			dt = EnsureDateTime(dateTime, dateTimeZoneHandling);
			return true;
		}

		internal static bool TryParseDateTime(string s, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out object dt)
		{
			if (s.Length > 0)
			{
				if (s[0] == '/')
				{
					if (s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && TryParseDateMicrosoft(s, dateParseHandling, dateTimeZoneHandling, out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && TryParseDateIso(s, dateParseHandling, dateTimeZoneHandling, out dt))
				{
					return true;
				}
				if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateExact(s, dateParseHandling, dateTimeZoneHandling, dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = null;
			return false;
		}

		private static bool TryParseDateMicrosoft(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, out object dt)
		{
			string text2 = text.Substring(6, text.Length - 8);
			DateTimeKind dateTimeKind = DateTimeKind.Utc;
			int num = text2.IndexOf('+', 1);
			if (num == -1)
			{
				num = text2.IndexOf('-', 1);
			}
			if (num != -1)
			{
				dateTimeKind = DateTimeKind.Local;
				text2 = text2.Substring(0, num);
			}
			if (!long.TryParse(text2, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result))
			{
				dt = null;
				return false;
			}
			DateTime dateTime = ConvertJavaScriptTicksToDateTime(result);
			dt = EnsureDateTime(dateTimeKind switch
			{
				DateTimeKind.Unspecified => DateTime.SpecifyKind(dateTime.ToLocalTime(), DateTimeKind.Unspecified), 
				DateTimeKind.Local => dateTime.ToLocalTime(), 
				_ => dateTime, 
			}, dateTimeZoneHandling);
			return true;
		}

		private static bool TryParseDateExact(string text, DateParseHandling dateParseHandling, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out object dt)
		{
			if (DateTime.TryParseExact(text, dateFormatString, culture, DateTimeStyles.RoundtripKind, out var result))
			{
				result = EnsureDateTime(result, dateTimeZoneHandling);
				dt = result;
				return true;
			}
			dt = null;
			return false;
		}

		internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture)
		{
			if (string.IsNullOrEmpty(formatString))
			{
				char[] array = new char[64];
				int count = WriteDateTimeString(array, 0, value, null, value.Kind, format);
				writer.Write(array, 0, count);
			}
			else
			{
				writer.Write(value.ToString(formatString, culture));
			}
		}

		internal static int WriteDateTimeString(char[] chars, int start, DateTime value, TimeSpan? offset, DateTimeKind kind, DateFormatHandling format)
		{
			int num = start;
			if (format == DateFormatHandling.MicrosoftDateFormat)
			{
				TimeSpan offset2 = ((!offset.HasValue) ? value.GetUtcOffset() : offset.Value);
				long num2 = ConvertDateTimeToJavaScriptTicks(value, offset2);
				"\\/Date(".CopyTo(0, chars, num, 7);
				num += 7;
				string text = num2.ToString(CultureInfo.InvariantCulture);
				text.CopyTo(0, chars, num, text.Length);
				num += text.Length;
				switch (kind)
				{
				case DateTimeKind.Unspecified:
					if (value != DateTime.MaxValue && value != DateTime.MinValue)
					{
						num = WriteDateTimeOffset(chars, num, offset2, format);
					}
					break;
				case DateTimeKind.Local:
					num = WriteDateTimeOffset(chars, num, offset2, format);
					break;
				}
				")\\/".CopyTo(0, chars, num, 3);
				num += 3;
			}
			else
			{
				num = WriteDefaultIsoDate(chars, num, value);
				switch (kind)
				{
				case DateTimeKind.Local:
					num = WriteDateTimeOffset(chars, num, (!offset.HasValue) ? value.GetUtcOffset() : offset.Value, format);
					break;
				case DateTimeKind.Utc:
					chars[num++] = 'Z';
					break;
				}
			}
			return num;
		}

		internal static int WriteDefaultIsoDate(char[] chars, int start, DateTime dt)
		{
			int num = 19;
			GetDateValues(dt, out var year, out var month, out var day);
			CopyIntToCharArray(chars, start, year, 4);
			chars[start + 4] = '-';
			CopyIntToCharArray(chars, start + 5, month, 2);
			chars[start + 7] = '-';
			CopyIntToCharArray(chars, start + 8, day, 2);
			chars[start + 10] = 'T';
			CopyIntToCharArray(chars, start + 11, dt.Hour, 2);
			chars[start + 13] = ':';
			CopyIntToCharArray(chars, start + 14, dt.Minute, 2);
			chars[start + 16] = ':';
			CopyIntToCharArray(chars, start + 17, dt.Second, 2);
			int num2 = (int)(dt.Ticks % 10000000);
			if (num2 != 0)
			{
				int num3 = 7;
				while (num2 % 10 == 0)
				{
					num3--;
					num2 /= 10;
				}
				chars[start + 19] = '.';
				CopyIntToCharArray(chars, start + 20, num2, num3);
				num += num3 + 1;
			}
			return start + num;
		}

		private static void CopyIntToCharArray(char[] chars, int start, int value, int digits)
		{
			while (digits-- != 0)
			{
				chars[start + digits] = (char)(value % 10 + 48);
				value /= 10;
			}
		}

		internal static int WriteDateTimeOffset(char[] chars, int start, TimeSpan offset, DateFormatHandling format)
		{
			chars[start++] = ((offset.Ticks < 0) ? '-' : '+');
			int value = Math.Abs(offset.Hours);
			CopyIntToCharArray(chars, start, value, 2);
			start += 2;
			if (format == DateFormatHandling.IsoDateFormat)
			{
				chars[start++] = ':';
			}
			int value2 = Math.Abs(offset.Minutes);
			CopyIntToCharArray(chars, start, value2, 2);
			start += 2;
			return start;
		}

		private static void GetDateValues(DateTime td, out int year, out int month, out int day)
		{
			long ticks = td.Ticks;
			int num = (int)(ticks / 864000000000L);
			int num2 = num / 146097;
			num -= num2 * 146097;
			int num3 = num / 36524;
			if (num3 == 4)
			{
				num3 = 3;
			}
			num -= num3 * 36524;
			int num4 = num / 1461;
			num -= num4 * 1461;
			int num5 = num / 365;
			if (num5 == 4)
			{
				num5 = 3;
			}
			year = num2 * 400 + num3 * 100 + num4 * 4 + num5 + 1;
			num -= num5 * 365;
			int[] array = ((num5 != 3 || (num4 == 24 && num3 != 3)) ? DaysToMonth365 : DaysToMonth366);
			int i;
			for (i = num >> 6; num >= array[i]; i++)
			{
			}
			month = i;
			day = num - array[i - 1] + 1;
		}
	}
	internal interface IWrappedDictionary : IDictionary, IEnumerable, ICollection
	{
		object UnderlyingDictionary { get; }
	}
	internal class DictionaryWrapper<TKey, TValue> : IDictionary<TKey, TValue>, IWrappedDictionary, IEnumerable, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IDictionary, ICollection
	{
		private struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IDictionaryEnumerator, IEnumerator
		{
			private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

			public DictionaryEntry Entry => (DictionaryEntry)Current;

			public object Key => Entry.Key;

			public object Value => Entry.Value;

			public object Current => new DictionaryEntry(_e.Current.Key, _e.Current.Value);

			public DictionaryEnumerator(IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
			{
				ValidationUtils.ArgumentNotNull(e, "e");
				_e = e;
			}

			public bool MoveNext()
			{
				return _e.MoveNext();
			}

			public void Reset()
			{
				_e.Reset();
			}
		}

		private readonly IDictionary _dictionary;

		private readonly IDictionary<TKey, TValue> _genericDictionary;

		private object _syncRoot;

		object IDictionary.this[object key]
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary[key];
				}
				return _genericDictionary[(TKey)key];
			}
			set
			{
				if (_dictionary != null)
				{
					_dictionary[key] = value;
				}
				else
				{
					_genericDictionary[(TKey)key] = (TValue)value;
				}
			}
		}

		bool IDictionary.IsFixedSize
		{
			get
			{
				if (_genericDictionary != null)
				{
					return false;
				}
				return _dictionary.IsFixedSize;
			}
		}

		ICollection IDictionary.Keys
		{
			get
			{
				if (_genericDictionary != null)
				{
					return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(_genericDictionary.Keys);
				}
				return _dictionary.Keys;
			}
		}

		ICollection IDictionary.Values
		{
			get
			{
				if (_genericDictionary != null)
				{
					return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(_genericDictionary.Values);
				}
				return _dictionary.Values;
			}
		}

		bool ICollection.IsSynchronized
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.IsSynchronized;
				}
				return false;
			}
		}

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public ICollection<TKey> Keys
		{
			get
			{
				if (_dictionary != null)
				{
					return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<TKey>(_dictionary.Keys));
				}
				return _genericDictionary.Keys;
			}
		}

		public ICollection<TValue> Values
		{
			get
			{
				if (_dictionary != null)
				{
					return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<TValue>(_dictionary.Values));
				}
				return _genericDictionary.Values;
			}
		}

		public TValue this[TKey key]
		{
			get
			{
				if (_dictionary != null)
				{
					return (TValue)_dictionary[key];
				}
				return _genericDictionary[key];
			}
			set
			{
				if (_dictionary != null)
				{
					_dictionary[key] = value;
				}
				else
				{
					_genericDictionary[key] = value;
				}
			}
		}

		public int Count
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.Count;
				}
				return _genericDictionary.Count;
			}
		}

		public bool IsReadOnly
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.IsReadOnly;
				}
				return _genericDictionary.IsReadOnly;
			}
		}

		public object UnderlyingDictionary
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary;
				}
				return _genericDictionary;
			}
		}

		public DictionaryWrapper(IDictionary dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_dictionary = dictionary;
		}

		public DictionaryWrapper(IDictionary<TKey, TValue> dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_genericDictionary = dictionary;
		}

		public void Add(TKey key, TValue value)
		{
			if (_dictionary != null)
			{
				_dictionary.Add(key, value);
				return;
			}
			if (_genericDictionary != null)
			{
				_genericDictionary.Add(key, value);
				return;
			}
			throw new NotSupportedException();
		}

		public bool ContainsKey(TKey key)
		{
			if (_dictionary != null)
			{
				return _dictionary.Contains(key);
			}
			return _genericDictionary.ContainsKey(key);
		}

		public bool Remove(TKey key)
		{
			if (_dictionary != null)
			{
				if (_dictionary.Contains(key))
				{
					_dictionary.Remove(key);
					return true;
				}
				return false;
			}
			return _genericDictionary.Remove(key);
		}

		public bool TryGetValue(TKey key, out TValue value)
		{
			if (_dictionary != null)
			{
				if (!_dictionary.Contains(key))
				{
					value = default(TValue);
					return false;
				}
				value = (TValue)_dictionary[key];
				return true;
			}
			return _genericDictionary.TryGetValue(key, out value);
		}

		public void Add(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				((IList)_dictionary).Add(item);
			}
			else if (_genericDictionary != null)
			{
				_genericDictionary.Add(item);
			}
		}

		public void Clear()
		{
			if (_dictionary != null)
			{
				_dictionary.Clear();
			}
			else
			{
				_genericDictionary.Clear();
			}
		}

		public bool Contains(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				return ((IList)_dictionary).Contains(item);
			}
			return _genericDictionary.Contains(item);
		}

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			if (_dictionary != null)
			{
				foreach (DictionaryEntry item in _dictionary)
				{
					ref KeyValuePair<TKey, TValue> reference = ref array[arrayIndex++];
					reference = new KeyValuePair<TKey, TValue>((TKey)item.Key, (TValue)item.Value);
				}
				return;
			}
			_genericDictionary.CopyTo(array, arrayIndex);
		}

		public bool Remove(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				if (_dictionary.Contains(item.Key))
				{
					object objA = _dictionary[item.Key];
					if (object.Equals(objA, item.Value))
					{
						_dictionary.Remove(item.Key);
						return true;
					}
					return false;
				}
				return true;
			}
			return _genericDictionary.Remove(item);
		}

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
		{
			if (_dictionary != null)
			{
				return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Select(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<DictionaryEntry>(_dictionary), (DictionaryEntry de) => new KeyValuePair<TKey, TValue>((TKey)de.Key, (TValue)de.Value)).GetEnumerator();
			}
			return _genericDictionary.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		void IDictionary.Add(object key, object value)
		{
			if (_dictionary != null)
			{
				_dictionary.Add(key, value);
			}
			else
			{
				_genericDictionary.Add((TKey)key, (TValue)value);
			}
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			if (_dictionary != null)
			{
				return _dictionary.GetEnumerator();
			}
			return new DictionaryEnumerator<TKey, TValue>(_genericDictionary.GetEnumerator());
		}

		bool IDictionary.Contains(object key)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.ContainsKey((TKey)key);
			}
			return _dictionary.Contains(key);
		}

		public void Remove(object key)
		{
			if (_dictionary != null)
			{
				_dictionary.Remove(key);
			}
			else
			{
				_genericDictionary.Remove((TKey)key);
			}
		}

		void ICollection.CopyTo(Array array, int index)
		{
			if (_dictionary != null)
			{
				_dictionary.CopyTo(array, index);
			}
			else
			{
				_genericDictionary.CopyTo((KeyValuePair<TKey, TValue>[])array, index);
			}
		}
	}
	internal static class EnumUtils
	{
		private static readonly ThreadSafeStore<Type, BidirectionalDictionary<string, string>> EnumMemberNamesPerType = new ThreadSafeStore<Type, BidirectionalDictionary<string, string>>(InitializeEnumType, new TypeKeyMaker());

		private static BidirectionalDictionary<string, string> InitializeEnumType(Type type)
		{
			BidirectionalDictionary<string, string> bidirectionalDictionary = new BidirectionalDictionary<string, string>(StringComparer.OrdinalIgnoreCase, StringComparer.OrdinalIgnoreCase);
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				string name = fieldInfo.Name;
				string name2 = fieldInfo.Name;
				if (bidirectionalDictionary.TryGetBySecond(name2, out var _))
				{
					throw new InvalidOperationException("Enum name '{0}' already exists on enum '{1}'.".FormatWith(CultureInfo.InvariantCulture, name2, type.Name));
				}
				bidirectionalDictionary.Set(name, name2);
			}
			return bidirectionalDictionary;
		}

		public static IList<T> GetFlagsValues<T>(T value) where T : struct
		{
			Type typeFromHandle = typeof(T);
			if (!typeFromHandle.IsDefined(typeof(FlagsAttribute), inherit: false))
			{
				throw new ArgumentException("Enum type {0} is not a set of flags.".FormatWith(CultureInfo.InvariantCulture, typeFromHandle));
			}
			Type underlyingType = Enum.GetUnderlyingType(value.GetType());
			ulong num = Convert.ToUInt64(value, CultureInfo.InvariantCulture);
			IList<EnumValue<ulong>> namesAndValues = GetNamesAndValues<T>();
			IList<T> list = new List<T>();
			foreach (EnumValue<ulong> item in namesAndValues)
			{
				if ((num & item.Value) == item.Value && item.Value != 0)
				{
					list.Add((T)Convert.ChangeType(item.Value, underlyingType, CultureInfo.CurrentCulture));
				}
			}
			if (list.Count == 0 && Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SingleOrDefault(namesAndValues, (EnumValue<ulong> v) => v.Value == 0) != null)
			{
				list.Add(default(T));
			}
			return list;
		}

		public static IList<EnumValue<ulong>> GetNamesAndValues<T>() where T : struct
		{
			return GetNamesAndValues<ulong>(typeof(T));
		}

		public static IList<EnumValue<TUnderlyingType>> GetNamesAndValues<TUnderlyingType>(Type enumType) where TUnderlyingType : struct
		{
			if (enumType == null)
			{
				throw new ArgumentNullException("enumType");
			}
			ValidationUtils.ArgumentTypeIsEnum(enumType, "enumType");
			IList<object> values = GetValues(enumType);
			IList<string> names = GetNames(enumType);
			IList<EnumValue<TUnderlyingType>> list = new List<EnumValue<TUnderlyingType>>();
			for (int i = 0; i < values.Count; i++)
			{
				try
				{
					list.Add(new EnumValue<TUnderlyingType>(names[i], (TUnderlyingType)Convert.ChangeType(values[i], typeof(TUnderlyingType), CultureInfo.CurrentCulture)));
				}
				catch (OverflowException innerException)
				{
					throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "Value from enum with the underlying type of {0} cannot be added to dictionary with a value type of {1}. Value was too large: {2}", Enum.GetUnderlyingType(enumType), typeof(TUnderlyingType), Convert.ToUInt64(values[i], CultureInfo.InvariantCulture)), innerException);
				}
			}
			return list;
		}

		public static IList<object> GetValues(Type enumType)
		{
			if (!enumType.IsEnum())
			{
				throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
			}
			List<object> list = new List<object>();
			IEnumerable<FieldInfo> enumerable = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(enumType.GetFields(), (FieldInfo f) => f.IsLiteral);
			foreach (FieldInfo item in enumerable)
			{
				object value = item.GetValue(enumType);
				list.Add(value);
			}
			return list;
		}

		public static IList<string> GetNames(Type enumType)
		{
			if (!enumType.IsEnum())
			{
				throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
			}
			List<string> list = new List<string>();
			IEnumerable<FieldInfo> enumerable = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(enumType.GetFields(), (FieldInfo f) => f.IsLiteral);
			foreach (FieldInfo item in enumerable)
			{
				list.Add(item.Name);
			}
			return list;
		}

		public static object ParseEnumName(string enumText, bool isNullable, Type t)
		{
			if (enumText == string.Empty && isNullable)
			{
				return null;
			}
			BidirectionalDictionary<string, string> map = EnumMemberNamesPerType.Get(t);
			string value;
			if (enumText.IndexOf(',') != -1)
			{
				string[] array = enumText.Split(',');
				for (int i = 0; i < array.Length; i++)
				{
					string enumText2 = array[i].Trim();
					array[i] = ResolvedEnumName(map, enumText2);
				}
				value = string.Join(", ", array);
			}
			else
			{
				value = ResolvedEnumName(map, enumText);
			}
			return Enum.Parse(t, value, ignoreCase: true);
		}

		public static string ToEnumName(Type enumType, string enumText, bool camelCaseText)
		{
			BidirectionalDictionary<string, string> bidirectionalDictionary = EnumMemberNamesPerType.Get(enumType);
			string[] array = enumText.Split(',');
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				bidirectionalDictionary.TryGetByFirst(text, out var second);
				second = second ?? text;
				if (camelCaseText)
				{
					second = StringUtils.ToCamelCase(second);
				}
				array[i] = second;
			}
			return string.Join(", ", array);
		}

		private static string ResolvedEnumName(BidirectionalDictionary<string, string> map, string enumText)
		{
			map.TryGetBySecond(enumText, out var first);
			return first ?? enumText;
		}
	}
	internal class EnumValue<T> where T : struct
	{
		private readonly string _name;

		private readonly T _value;

		public string Name => _name;

		public T Value => _value;

		public EnumValue(string name, T value)
		{
			_name = name;
			_value = value;
		}
	}
	internal static class ILGeneratorExtensions
	{
		public static void PushInstance(this ILGenerator generator, Type type)
		{
			generator.Emit(OpCodes.Ldarg_0);
			if (type.IsValueType())
			{
				generator.Emit(OpCodes.Unbox, type);
			}
			else
			{
				generator.Emit(OpCodes.Castclass, type);
			}
		}

		public static void PushArrayInstance(this ILGenerator generator, int argsIndex, int arrayIndex)
		{
			generator.Emit(OpCodes.Ldarg, argsIndex);
			generator.Emit(OpCodes.Ldc_I4, arrayIndex);
			generator.Emit(OpCodes.Ldelem_Ref);
		}

		public static void BoxIfNeeded(this ILGenerator generator, Type type)
		{
			if (type.IsValueType())
			{
				generator.Emit(OpCodes.Box, type);
			}
			else
			{
				generator.Emit(OpCodes.Castclass, type);
			}
		}

		public static void UnboxIfNeeded(this ILGenerator generator, Type type)
		{
			if (type.IsValueType())
			{
				generator.Emit(OpCodes.Unbox_Any, type);
			}
			else
			{
				generator.Emit(OpCodes.Castclass, type);
			}
		}

		public static void CallMethod(this ILGenerator generator, MethodInfo methodInfo)
		{
			if (methodInfo.IsFinal || !methodInfo.IsVirtual)
			{
				generator.Emit(OpCodes.Call, methodInfo);
			}
			else
			{
				generator.Emit(OpCodes.Callvirt, methodInfo);
			}
		}

		public static void Return(this ILGenerator generator)
		{
			generator.Emit(OpCodes.Ret);
		}
	}
	internal static class JavaScriptUtils
	{
		internal static readonly bool[] SingleQuoteCharEscapeFlags;

		internal static readonly bool[] DoubleQuoteCharEscapeFlags;

		internal static readonly bool[] HtmlCharEscapeFlags;

		private const string EscapedUnicodeText = "!";

		static JavaScriptUtils()
		{
			SingleQuoteCharEscapeFlags = new bool[128];
			DoubleQuoteCharEscapeFlags = new bool[128];
			HtmlCharEscapeFlags = new bool[128];
			IList<char> list = new List<char> { '\n', '\r', '\t', '\\', '\f', '\b' };
			for (int i = 0; i < 32; i++)
			{
				list.Add((char)i);
			}
			foreach (char item in Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Union(list, new char[1] { '\'' }))
			{
				SingleQuoteCharEscapeFlags[(uint)item] = true;
			}
			foreach (char item2 in Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Union(list, new char[1] { '"' }))
			{
				DoubleQuoteCharEscapeFlags[(uint)item2] = true;
			}
			foreach (char item3 in Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Union(list, new char[5] { '"', '\'', '<', '>', '&' }))
			{
				HtmlCharEscapeFlags[(uint)item3] = true;
			}
		}

		public static bool[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar)
		{
			if (stringEscapeHandling == StringEscapeHandling.EscapeHtml)
			{
				return HtmlCharEscapeFlags;
			}
			if (quoteChar == '"')
			{
				return DoubleQuoteCharEscapeFlags;
			}
			return SingleQuoteCharEscapeFlags;
		}

		public static bool ShouldEscapeJavaScriptString(string s, bool[] charEscapeFlags)
		{
			if (s == null)
			{
				return false;
			}
			foreach (char c in s)
			{
				if (c >= charEscapeFlags.Length || charEscapeFlags[(uint)c])
				{
					return true;
				}
			}
			return false;
		}

		public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, ref char[] writeBuffer)
		{
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
			if (s != null)
			{
				int num = 0;
				for (int i = 0; i < s.Length; i++)
				{
					char c = s[i];
					if (c < charEscapeFlags.Length && !charEscapeFlags[(uint)c])
					{
						continue;
					}
					string text;
					switch (c)
					{
					case '\t':
						text = "\\t";
						break;
					case '\n':
						text = "\\n";
						break;
					case '\r':
						text = "\\r";
						break;
					case '\f':
						text = "\\f";
						break;
					case '\b':
						text = "\\b";
						break;
					case '\\':
						text = "\\\\";
						break;
					case '\u0085':
						text = "\\u0085";
						break;
					case '\u2028':
						text = "\\u2028";
						break;
					case '\u2029':
						text = "\\u2029";
						break;
					default:
						if (c < charEscapeFlags.Length || stringEscapeHandling == StringEscapeHandling.EscapeNonAscii)
						{
							if (c == '\'' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
							{
								text = "\\'";
								break;
							}
							if (c == '"' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
							{
								text = "\\\"";
								break;
							}
							if (writeBuffer == null)
							{
								writeBuffer = new char[6];
							}
							StringUtils.ToCharAsUnicode(c, writeBuffer);
							text = "!";
						}
						else
						{
							text = null;
						}
						break;
					}
					if (text == null)
					{
						continue;
					}
					bool flag = string.Equals(text, "!");
					if (i > num)
					{
						int num2 = i - num + (flag ? 6 : 0);
						int num3 = (flag ? 6 : 0);
						if (writeBuffer == null || writeBuffer.Length < num2)
						{
							char[] array = new char[num2];
							if (flag)
							{
								Array.Copy(writeBuffer, array, 6);
							}
							writeBuffer = array;
						}
						s.CopyTo(num, writeBuffer, num3, num2 - num3);
						writer.Write(writeBuffer, num3, num2 - num3);
					}
					num = i + 1;
					if (!flag)
					{
						writer.Write(text);
					}
					else
					{
						writer.Write(writeBuffer, 0, 6);
					}
				}
				if (num == 0)
				{
					writer.Write(s);
				}
				else
				{
					int num4 = s.Length - num;
					if (writeBuffer == null || writeBuffer.Length < num4)
					{
						writeBuffer = new char[num4];
					}
					s.CopyTo(num, writeBuffer, 0, num4);
					writer.Write(writeBuffer, 0, num4);
				}
			}
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
		}

		public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters)
		{
			return ToEscapedJavaScriptString(value, delimiter, appendDelimiters, StringEscapeHandling.Default);
		}

		public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling)
		{
			bool[] charEscapeFlags = GetCharEscapeFlags(stringEscapeHandling, delimiter);
			int? length = StringUtils.GetLength(value);
			using StringWriter stringWriter = StringUtils.CreateStringWriter((!length.HasValue) ? 16 : length.Value);
			char[] writeBuffer = null;
			WriteEscapedJavaScriptString(stringWriter, value, delimiter, appendDelimiters, charEscapeFlags, stringEscapeHandling, ref writeBuffer);
			return stringWriter.ToString();
		}
	}
	internal static class JsonTokenUtils
	{
		internal static bool IsEndToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.EndObject:
			case JsonToken.EndArray:
			case JsonToken.EndConstructor:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsStartToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.StartObject:
			case JsonToken.StartArray:
			case JsonToken.StartConstructor:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsPrimitiveToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return true;
			default:
				return false;
			}
		}
	}
	internal class LateBoundReflectionDelegateFactory : ReflectionDelegateFactory
	{
		private static readonly LateBoundReflectionDelegateFactory _instance = new LateBoundReflectionDelegateFactory();

		internal static ReflectionDelegateFactory Instance => _instance;

		public override Newtonsoft.Json.Serialization.ObjectConstructor<object> CreateParametrizedConstructor(MethodBase method)
		{
			ValidationUtils.ArgumentNotNull(method, "method");
			if (method is ConstructorInfo @object)
			{
				return @object.Invoke;
			}
			return (object[] a) => method.Invoke(null, a);
		}

		public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
		{
			ValidationUtils.ArgumentNotNull(method, "method");
			ConstructorInfo c = method as ConstructorInfo;
			if (c != null)
			{
				return (T o, object[] a) => c.Invoke(a);
			}
			return (T o, object[] a) => method.Invoke(o, a);
		}

		public override Func<T> CreateDefaultConstructor<T>(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsValueType())
			{
				return () => (T)Activator.CreateInstance(type);
			}
			ConstructorInfo constructorInfo = ReflectionUtils.GetDefaultConstructor(type, nonPublic: true);
			return () => (T)constructorInfo.Invoke(null);
		}

		public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return (T o) => propertyInfo.GetValue(o, null);
		}

		public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return (T o) => fieldInfo.GetValue(o);
		}

		public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return delegate(T o, object v)
			{
				fieldInfo.SetValue(o, v);
			};
		}

		public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return delegate(T o, object v)
			{
				propertyInfo.SetValue(o, v, null);
			};
		}
	}
}
namespace Newtonsoft.Json.Utilities.LinqBridge
{
	internal static class Enumerable
	{
		private static class Futures<T>
		{
			public static readonly Func<T> Default = () => default(T);

			public static readonly Func<T> Undefined = delegate
			{
				throw new InvalidOperationException();
			};
		}

		private static class Sequence<T>
		{
			public static readonly IEnumerable<T> Empty = new T[0];
		}

		private sealed class Grouping<K, V> : List<V>, IGrouping<K, V>, IEnumerable<V>, IEnumerable
		{
			public K Key { get; private set; }

			internal Grouping(K key)
			{
				Key = key;
			}
		}

		public static IEnumerable<TSource> AsEnumerable<TSource>(IEnumerable<TSource> source)
		{
			return source;
		}

		public static IEnumerable<TResult> Empty<TResult>()
		{
			return Sequence<TResult>.Empty;
		}

		public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source)
		{
			CheckNotNull(source, "source");
			return CastYield<TResult>(source);
		}

		private static IEnumerable<TResult> CastYield<TResult>(IEnumerable source)
		{
			IEnumerator enumerator = source.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					object item = enumerator.Current;
					yield return (TResult)item;
				}
			}
			finally
			{
				IDisposable disposable;
				IDisposable disposable2 = (disposable = enumerator as IDisposable);
				if (disposable != null)
				{
					disposable2.Dispose();
				}
			}
		}

		public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source)
		{
			CheckNotNull(source, "source");
			return OfTypeYield<TResult>(source);
		}

		private static IEnumerable<TResult> OfTypeYield<TResult>(IEnumerable source)
		{
			IEnumerator enumerator = source.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					object item = enumerator.Current;
					if (item is TResult)
					{
						yield return (TResult)item;
					}
				}
			}
			finally
			{
				IDisposable disposable;
				IDisposable disposable2 = (disposable = enumerator as IDisposable);
				if (disposable != null)
				{
					disposable2.Dispose();
				}
			}
		}

		public static IEnumerable<int> Range(int start, int count)
		{
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", count, null);
			}
			long num = (long)start + (long)count;
			if (num - 1 >= int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("count", count, null);
			}
			return RangeYield(start, num);
		}

		private static IEnumerable<int> RangeYield(int start, long end)
		{
			for (int i = start; i < end; i++)
			{
				yield return i;
			}
		}

		public static IEnumerable<TResult> Repeat<TResult>(TResult element, int count)
		{
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", count, null);
			}
			return RepeatYield(element, count);
		}

		private static IEnumerable<TResult> RepeatYield<TResult>(TResult element, int count)
		{
			for (int i = 0; i < count; i++)
			{
				yield return element;
			}
		}

		public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			CheckNotNull(predicate, "predicate");
			return source.Where((TSource item, int i) => predicate(item));
		}

		public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			CheckNotNull(source, "source");
			CheckNotNull(predicate, "predicate");
			return WhereYield(source, predicate);
		}

		private static IEnumerable<TSource> WhereYield<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (predicate(item, i++))
				{
					yield return item;
				}
			}
		}

		public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			CheckNotNull(selector, "selector");
			return source.Select((TSource item, int i) => selector(item));
		}

		public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> selector)
		{
			CheckNotNull(source, "source");
			CheckNotNull(selector, "selector");
			return SelectYield(source, selector);
		}

		private static IEnumerable<TResult> SelectYield<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> selector)
		{
			int i = 0;
			foreach (TSource item in source)
			{
				yield return selector(item, i++);
			}
		}

		public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector)
		{
			CheckNotNull(selector, "selector");
			return source.SelectMany((TSource item, int i) => selector(item));
		}

		public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector)
		{
			CheckNotNull(selector, "selector");
			return source.SelectMany(selector, (TSource item, TResult subitem) => subitem);
		}

		public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			CheckNotNull(collectionSelector, "collectionSelector");
			return source.SelectMany((TSource item, int i) => collectionSelector(item), resultSelector);
		}

		public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			CheckNotNull(source, "source");
			CheckNotNull(collectionSelector, "collectionSelector");
			CheckNotNull(resultSelector, "resultSelector");
			return source.SelectManyYield(collectionSelector, resultSelector);
		}

		private static IEnumerable<TResult> SelectManyYield<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			int i = 0;
			foreach (TSource item in source)
			{
				foreach (TCollection subitem in collectionSelector(item, i++))
				{
					yield return resultSelector(item, subitem);
				}
			}
		}

		public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			CheckNotNull(predicate, "predicate");
			return source.TakeWhile((TSource item, int i) => predicate(item));
		}

		public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			CheckNotNull(source, "source");
			CheckNotNull(predicate, "predicate");
			return source.TakeWhileYield(predicate);
		}

		private static IEnumerable<TSource> TakeWhileYield<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			int i = 0;
			foreach (TSource item in source)
			{
				if (predicate(item, i++))
				{
					yield return item;
					continue;
				}
				break;
			}
		}

		private static TSource FirstImpl<TSource>(this IEnumerable<TSource> source, Func<TSource> empty)
		{
			CheckNotNull(source, "source");
			if (source is IList<TSource> list)
			{
				return (list.Count <= 0) ? empty() : list[0];
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			return (!enumerator.MoveNext()) ? empty() : enumerator.Current;
		}

		public static TSource First<TSource>(this IEnumerable<TSource> source)
		{
			return source.FirstImpl(Futures<TSource>.Undefined);
		}

		public static TSource First<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).First();
		}

		public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			return source.FirstImpl(Futures<TSource>.Default);
		}

		public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).FirstOrDefault();
		}

		private static TSource LastImpl<TSource>(this IEnumerable<TSource> source, Func<TSource> empty)
		{
			CheckNotNull(source, "source");
			if (source is IList<TSource> list)
			{
				return (list.Count <= 0) ? empty() : list[list.Count - 1];
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				return empty();
			}
			TSource current = enumerator.Current;
			while (enumerator.MoveNext())
			{
				current = enumerator.Current;
			}
			return current;
		}

		public static TSource Last<TSource>(this IEnumerable<TSource> source)
		{
			return source.LastImpl(Futures<TSource>.Undefined);
		}

		public static TSource Last<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).Last();
		}

		public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			return source.LastImpl(Futures<TSource>.Default);
		}

		public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).LastOrDefault();
		}

		private static TSource SingleImpl<TSource>(this IEnumerable<TSource> source, Func<TSource> empty)
		{
			CheckNotNull(source, "source");
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (enumerator.MoveNext())
			{
				TSource current = enumerator.Current;
				if (!enumerator.MoveNext())
				{
					return current;
				}
				throw new InvalidOperationException();
			}
			return empty();
		}

		public static TSource Single<TSource>(this IEnumerable<TSource> source)
		{
			return source.SingleImpl(Futures<TSource>.Undefined);
		}

		public static TSource Single<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).Single();
		}

		public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			return source.SingleImpl(Futures<TSource>.Default);
		}

		public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).SingleOrDefault();
		}

		public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, int index)
		{
			CheckNotNull(source, "source");
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", index, null);
			}
			if (source is IList<TSource> list)
			{
				return list[index];
			}
			try
			{
				return source.SkipWhile((TSource item, int i) => i < index).First();
			}
			catch (InvalidOperationException)
			{
				throw new ArgumentOutOfRangeException("index", index, null);
			}
		}

		public static TSource ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, int index)
		{
			CheckNotNull(source, "source");
			if (index < 0)
			{
				return default(TSource);
			}
			if (source is IList<TSource> list)
			{
				return (index >= list.Count) ? default(TSource) : list[index];
			}
			return source.SkipWhile((TSource item, int i) => i < index).FirstOrDefault();
		}

		public static IEnumerable<TSource> Reverse<TSource>(this IEnumerable<TSource> source)
		{
			CheckNotNull(source, "source");
			return ReverseYield(source);
		}

		private static IEnumerable<TSource> ReverseYield<TSource>(IEnumerable<TSource> source)
		{
			Stack<TSource> stack = new Stack<TSource>();
			foreach (TSource item in source)
			{
				stack.Push(item);
			}
			foreach (TSource item2 in stack)
			{
				yield return item2;
			}
		}

		public static IEnumerable<TSource> Take<TSource>(this IEnumerable<TSource> source, int count)
		{
			return source.Where((TSource item, int i) => i < count);
		}

		public static IEnumerable<TSource> Skip<TSource>(this IEnumerable<TSource> source, int count)
		{
			return source.Where((TSource item, int i) => i >= count);
		}

		public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			CheckNotNull(predicate, "predicate");
			return source.SkipWhile((TSource item, int i) => predicate(item));
		}

		public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			CheckNotNull(source, "source");
			CheckNotNull(predicate, "predicate");
			return SkipWhileYield(source, predicate);
		}

		private static IEnumerable<TSource> SkipWhileYield<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			using IEnumerator<TSource> e = source.GetEnumerator();
			int num = 0;
			while (true)
			{
				if (!e.MoveNext())
				{
					yield break;
				}
				if (!predicate(e.Current, num))
				{
					break;
				}
				num++;
			}
			do
			{
				yield return e.Current;
			}
			while (e.MoveNext());
		}

		public static int Count<TSource>(this IEnumerable<TSource> source)
		{
			CheckNotNull(source, "source");
			return (!(source is ICollection collection)) ? source.Aggregate(0, (int count, TSource item) => checked(count + 1)) : collection.Count;
		}

		public static int Count<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).Count();
		}

		public static long LongCount<TSource>(this IEnumerable<TSource> source)
		{
			CheckNotNull(source, "source");
			return (!(source is Array array)) ? source.Aggregate(0L, (long count, TSource item) => count + 1) : array.LongLength;
		}

		public static long LongCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).LongCount();
		}

		public static IEnumerable<TSource> Concat<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			CheckNotNull(first, "first");
			CheckNotNull(second, "second");
			return ConcatYield(first, second);
		}

		private static IEnumerable<TSource> ConcatYield<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			foreach (TSource item in first)
			{
				yield return item;
			}
			foreach (TSource item2 in second)
			{
				yield return item2;
			}
		}

		public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)
		{
			CheckNotNull(source, "source");
			return new List<TSource>(source);
		}

		public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source)
		{
			return source.ToList().ToArray();
		}

		public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source)
		{
			return source.Distinct(null);
		}

		public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			CheckNotNull(source, "source");
			return DistinctYield(source, comparer);
		}

		private static IEnumerable<TSource> DistinctYield<TSource>(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			Dictionary<TSource, object> set = new Dictionary<TSource, object>(comparer);
			bool gotNull = false;
			foreach (TSource item in source)
			{
				if (item == null)
				{
					if (gotNull)
					{
						continue;
					}
					gotNull = true;
				}
				else
				{
					if (set.ContainsKey(item))
					{
						continue;
					}
					set.Add(item, null);
				}
				yield return item;
			}
		}

		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ToLookup(keySelector, (TSource e) => e, null);
		}

		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			return source.ToLookup(keySelector, (TSource e) => e, comparer);
		}

		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.ToLookup(keySelector, elementSelector, null);
		}

		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			CheckNotNull(keySelector, "keySelector");
			CheckNotNull(elementSelector, "elementSelector");
			Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
			foreach (TSource item in source)
			{
				TKey key = keySelector(item);
				Grouping<TKey, TElement> grouping = (Grouping<TKey, TElement>)lookup.Find(key);
				if (grouping == null)
				{
					grouping = new Grouping<TKey, TElement>(key);
					lookup.Add(grouping);
				}
				grouping.Add(elementSelector(item));
			}
			return lookup;
		}

		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.GroupBy(keySelector, null);
		}

		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			return source.GroupBy(keySelector, (TSource e) => e, comparer);
		}

		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.GroupBy(keySelector, elementSelector, null);
		}

		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			CheckNotNull(keySelector, "keySelector");
			CheckNotNull(elementSelector, "elementSelector");
			return source.ToLookup(keySelector, elementSelector, comparer);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector)
		{
			return source.GroupBy(keySelector, resultSelector, null);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			CheckNotNull(keySelector, "keySelector");
			CheckNotNull(resultSelector, "resultSelector");
			return from g in source.ToLookup(keySelector, comparer)
				select resultSelector(g.Key, g);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			return source.GroupBy(keySelector, elementSelector, resultSelector, null);
		}

		public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			CheckNotNull(keySelector, "keySelector");
			CheckNotNull(elementSelector, "elementSelector");
			CheckNotNull(resultSelector, "resultSelector");
			return from g in source.ToLookup(keySelector, elementSelector, comparer)
				select resultSelector(g.Key, g);
		}

		public static TSource Aggregate<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> func)
		{
			CheckNotNull(source, "source");
			CheckNotNull(func, "func");
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw new InvalidOperationException();
			}
			return enumerator.Renumerable().Skip(1).Aggregate(enumerator.Current, func);
		}

		public static TAccumulate Aggregate<TSource, TAccumulate>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)
		{
			return source.Aggregate(seed, func, (TAccumulate r) => r);
		}

		public static TResult Aggregate<TSource, TAccumulate, TResult>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector)
		{
			CheckNotNull(source, "source");
			CheckNotNull(func, "func");
			CheckNotNull(resultSelector, "resultSelector");
			TAccumulate arg = seed;
			foreach (TSource item in source)
			{
				arg = func(arg, item);
			}
			return resultSelector(arg);
		}

		public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			return first.Union(second, null);
		}

		public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			return first.Concat(second).Distinct(comparer);
		}

		public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source)
		{
			return source.DefaultIfEmpty(default(TSource));
		}

		public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source, TSource defaultValue)
		{
			CheckNotNull(source, "source");
			return DefaultIfEmptyYield(source, defaultValue);
		}

		private static IEnumerable<TSource> DefaultIfEmptyYield<TSource>(IEnumerable<TSource> source, TSource defaultValue)
		{
			using IEnumerator<TSource> e = source.GetEnumerator();
			if (!e.MoveNext())
			{
				yield return defaultValue;
				yield break;
			}
			do
			{
				yield return e.Current;
			}
			while (e.MoveNext());
		}

		public static bool All<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			CheckNotNull(source, "source");
			CheckNotNull(predicate, "predicate");
			foreach (TSource item in source)
			{
				if (!predicate(item))
				{
					return false;
				}
			}
			return true;
		}

		public static bool Any<TSource>(this IEnumerable<TSource> source)
		{
			CheckNotNull(source, "source");
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			return enumerator.MoveNext();
		}

		public static bool Any<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			return source.Where(predicate).Any();
		}

		public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value)
		{
			return source.Contains(value, null);
		}

		public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			CheckNotNull(source, "source");
			if (comparer == null && source is ICollection<TSource> collection)
			{
				return collection.Contains(value);
			}
			comparer = comparer ?? EqualityComparer<TSource>.Default;
			return source.Any((TSource item) => comparer.Equals(item, value));
		}

		public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			return first.SequenceEqual(second, null);
		}

		public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			CheckNotNull(first, "frist");
			CheckNotNull(second, "second");
			comparer = comparer ?? EqualityComparer<TSource>.Default;
			using (IEnumerator<TSource> enumerator = first.GetEnumerator())
			{
				using IEnumerator<TSource> enumerator2 = second.GetEnumerator();
				do
				{
					if (!enumerator.MoveNext())
					{
						return !enumerator2.MoveNext();
					}
					if (!enumerator2.MoveNext())
					{
						return false;
					}
				}
				while (comparer.Equals(enumerator.Current, enumerator2.Current));
			}
			return false;
		}

		private static TSource MinMaxImpl<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, bool> lesser)
		{
			CheckNotNull(source, "source");
			return source.Aggregate((TSource a, TSource item) => (!lesser(a, item)) ? item : a);
		}

		private static TSource? MinMaxImpl<TSource>(this IEnumerable<TSource?> source, TSource? seed, Func<TSource?, TSource?, bool> lesser) where TSource : struct
		{
			CheckNotNull(source, "source");
			return source.Aggregate(seed, (TSource? a, TSource? item) => (!lesser(a, item)) ? item : a);
		}

		public static TSource Min<TSource>(this IEnumerable<TSource> source)
		{
			Comparer<TSource> comparer = Comparer<TSource>.Default;
			return source.MinMaxImpl((TSource x, TSource y) => comparer.Compare(x, y) < 0);
		}

		public static TResult Min<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			return source.Select(selector).Min();
		}

		public static TSource Max<TSource>(this IEnumerable<TSource> source)
		{
			Comparer<TSource> comparer = Comparer<TSource>.Default;
			return source.MinMaxImpl((TSource x, TSource y) => comparer.Compare(x, y) > 0);
		}

		public static TResult Max<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			return source.Select(selector).Max();
		}

		private static IEnumerable<T> Renumerable<T>(this IEnumerator<T> e)
		{
			do
			{
				yield return e.Current;
			}
			while (e.MoveNext());
		}

		public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.OrderBy(keySelector, null);
		}

		public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			CheckNotNull(keySelector, "keySelector");
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, comparer, descending: false);
		}

		public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.OrderByDescending(keySelector, null);
		}

		public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			CheckNotNull(source, "keySelector");
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, comparer, descending: true);
		}

		public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ThenBy(keySelector, null);
		}

		public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			return source.CreateOrderedEnumerable(keySelector, comparer, descending: false);
		}

		public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ThenByDescending(keySelector, null);
		}

		public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			return source.CreateOrderedEnumerable(keySelector, comparer, descending: true);
		}

		private static IEnumerable<TSource> IntersectExceptImpl<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer, bool flag)
		{
			CheckNotNull(first, "first");
			CheckNotNull(second, "second");
			List<TSource> list = new List<TSource>();
			Dictionary<TSource, bool> flags = new Dictionary<TSource, bool>(comparer);
			foreach (TSource item in first.Where((TSource k) => !flags.ContainsKey(k)))
			{
				flags.Add(item, !flag);
				list.Add(item);
			}
			foreach (TSource item2 in second.Where(flags.ContainsKey))
			{
				flags[item2] = flag;
			}
			return list.Where((TSource item) => flags[item]);
		}

		public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			return first.Intersect(second, null);
		}

		public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			return first.IntersectExceptImpl(second, comparer, flag: true);
		}

		public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			return first.Except(second, null);
		}

		public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			return first.IntersectExceptImpl(second, comparer, flag: false);
		}

		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ToDictionary(keySelector, null);
		}

		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			return source.ToDictionary(keySelector, (TSource e) => e);
		}

		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.ToDictionary(keySelector, elementSelector, null);
		}

		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			CheckNotNull(source, "source");
			CheckNotNull(keySelector, "keySelector");
			CheckNotNull(elementSelector, "elementSelector");
			Dictionary<TKey, TElement> dictionary = new Dictionary<TKey, TElement>(comparer);
			foreach (TSource item in source)
			{
				dictionary.Add(keySelector(item), elementSelector(item));
			}
			return dictionary;
		}

		public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector)
		{
			return outer.Join(inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			CheckNotNull(outer, "outer");
			CheckNotNull(inner, "inner");
			CheckNotNull(outerKeySelector, "outerKeySelector");
			CheckNotNull(innerKeySelector, "innerKeySelector");
			CheckNotNull(resultSelector, "resultSelector");
			ILookup<TKey, TInner> lookup = inner.ToLookup(innerKeySelector, comparer);
			return from o in outer
				from i in lookup[outerKeySelector(o)]
				select resultSelector(o, i);
		}

		public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector)
		{
			return outer.GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			CheckNotNull(outer, "outer");
			CheckNotNull(inner, "inner");
			CheckNotNull(outerKeySelector, "outerKeySelector");
			CheckNotNull(innerKeySelector, "innerKeySelector");
			CheckNotNull(resultSelector, "resultSelector");
			ILookup<TKey, TInner> lookup = inner.ToLookup(innerKeySelector, comparer);
			return outer.Select((TOuter o) => resultSelector(o, lookup[outerKeySelector(o)]));
		}

		[DebuggerStepThrough]
		private static void CheckNotNull<T>(T value, string name) where T : class
		{
			if (value == null)
			{
				throw new ArgumentNullException(name);
			}
		}

		public static int Sum(this IEnumerable<int> source)
		{
			CheckNotNull(source, "source");
			int num = 0;
			foreach (int item in source)
			{
				num = checked(num + item);
			}
			return num;
		}

		public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double Average(this IEnumerable<int> source)
		{
			CheckNotNull(source, "source");
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (int item in source)
				{
					num += item;
					num2++;
				}
				if (num2 == 0)
				{
					throw new InvalidOperationException();
				}
				return (double)num / (double)num2;
			}
		}

		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Average();
		}

		public static int? Sum(this IEnumerable<int?> source)
		{
			CheckNotNull(source, "source");
			int num = 0;
			foreach (int? item in source)
			{
				num = checked(num + (item.HasValue ? item.Value : 0));
			}
			return num;
		}

		public static int? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double? Average(this IEnumerable<int?> source)
		{
			CheckNotNull(source, "source");
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (int? item in source.Where((int? n) => n.HasValue))
				{
					num += item.Value;
					num2++;
				}
				if (num2 == 0)
				{
					return null;
				}
				return new double?(num) / (double)num2;
			}
		}

		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Average();
		}

		public static int? Min(this IEnumerable<int?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((int? x) => x.HasValue).MinMaxImpl(null, (int? min, int? x) => (min.HasValue & x.HasValue) && min.GetValueOrDefault() < x.GetValueOrDefault());
		}

		public static int? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Min();
		}

		public static int? Max(this IEnumerable<int?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((int? x) => x.HasValue).MinMaxImpl(null, (int? max, int? x) => !x.HasValue || (max.HasValue && x.Value < max.Value));
		}

		public static int? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Max();
		}

		public static long Sum(this IEnumerable<long> source)
		{
			CheckNotNull(source, "source");
			long num = 0L;
			foreach (long item in source)
			{
				num = checked(num + item);
			}
			return num;
		}

		public static long Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double Average(this IEnumerable<long> source)
		{
			CheckNotNull(source, "source");
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (long item in source)
				{
					num += item;
					num2++;
				}
				if (num2 == 0)
				{
					throw new InvalidOperationException();
				}
				return (double)num / (double)num2;
			}
		}

		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Average();
		}

		public static long? Sum(this IEnumerable<long?> source)
		{
			CheckNotNull(source, "source");
			long num = 0L;
			foreach (long? item in source)
			{
				num = checked(num + ((!item.HasValue) ? 0 : item.Value));
			}
			return num;
		}

		public static long? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double? Average(this IEnumerable<long?> source)
		{
			CheckNotNull(source, "source");
			long num = 0L;
			long num2 = 0L;
			checked
			{
				foreach (long? item in source.Where((long? n) => n.HasValue))
				{
					num += item.Value;
					num2++;
				}
				if (num2 == 0)
				{
					return null;
				}
				return new double?(num) / (double)num2;
			}
		}

		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Average();
		}

		public static long? Min(this IEnumerable<long?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((long? x) => x.HasValue).MinMaxImpl(null, (long? min, long? x) => (min.HasValue & x.HasValue) && min.GetValueOrDefault() < x.GetValueOrDefault());
		}

		public static long? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Min();
		}

		public static long? Max(this IEnumerable<long?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((long? x) => x.HasValue).MinMaxImpl(null, (long? max, long? x) => !x.HasValue || (max.HasValue && x.Value < max.Value));
		}

		public static long? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Max();
		}

		public static float Sum(this IEnumerable<float> source)
		{
			CheckNotNull(source, "source");
			float num = 0f;
			foreach (float item in source)
			{
				num += item;
			}
			return num;
		}

		public static float Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Sum();
		}

		public static float Average(this IEnumerable<float> source)
		{
			CheckNotNull(source, "source");
			float num = 0f;
			long num2 = 0L;
			foreach (float item in source)
			{
				num += item;
				num2 = checked(num2 + 1);
			}
			if (num2 == 0)
			{
				throw new InvalidOperationException();
			}
			return num / (float)num2;
		}

		public static float Average<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Average();
		}

		public static float? Sum(this IEnumerable<float?> source)
		{
			CheckNotNull(source, "source");
			float num = 0f;
			foreach (float? item in source)
			{
				num += ((!item.HasValue) ? 0f : item.Value);
			}
			return num;
		}

		public static float? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static float? Average(this IEnumerable<float?> source)
		{
			CheckNotNull(source, "source");
			float num = 0f;
			long num2 = 0L;
			foreach (float? item in source.Where((float? n) => n.HasValue))
			{
				num += item.Value;
				num2 = checked(num2 + 1);
			}
			if (num2 == 0)
			{
				return null;
			}
			return new float?(num) / (float)num2;
		}

		public static float? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Average();
		}

		public static float? Min(this IEnumerable<float?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((float? x) => x.HasValue).MinMaxImpl(null, (float? min, float? x) => (min.HasValue & x.HasValue) && min.GetValueOrDefault() < x.GetValueOrDefault());
		}

		public static float? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Min();
		}

		public static float? Max(this IEnumerable<float?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((float? x) => x.HasValue).MinMaxImpl(null, (float? max, float? x) => !x.HasValue || (max.HasValue && x.Value < max.Value));
		}

		public static float? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Max();
		}

		public static double Sum(this IEnumerable<double> source)
		{
			CheckNotNull(source, "source");
			double num = 0.0;
			foreach (double item in source)
			{
				num += item;
			}
			return num;
		}

		public static double Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double Average(this IEnumerable<double> source)
		{
			CheckNotNull(source, "source");
			double num = 0.0;
			long num2 = 0L;
			foreach (double item in source)
			{
				num += item;
				num2 = checked(num2 + 1);
			}
			if (num2 == 0)
			{
				throw new InvalidOperationException();
			}
			return num / (double)num2;
		}

		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Average();
		}

		public static double? Sum(this IEnumerable<double?> source)
		{
			CheckNotNull(source, "source");
			double num = 0.0;
			foreach (double? item in source)
			{
				num += ((!item.HasValue) ? 0.0 : item.Value);
			}
			return num;
		}

		public static double? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static double? Average(this IEnumerable<double?> source)
		{
			CheckNotNull(source, "source");
			double num = 0.0;
			long num2 = 0L;
			foreach (double? item in source.Where((double? n) => n.HasValue))
			{
				num += item.Value;
				num2 = checked(num2 + 1);
			}
			if (num2 == 0)
			{
				return null;
			}
			return new double?(num) / (double)num2;
		}

		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Average();
		}

		public static double? Min(this IEnumerable<double?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((double? x) => x.HasValue).MinMaxImpl(null, (double? min, double? x) => (min.HasValue & x.HasValue) && min.GetValueOrDefault() < x.GetValueOrDefault());
		}

		public static double? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Min();
		}

		public static double? Max(this IEnumerable<double?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((double? x) => x.HasValue).MinMaxImpl(null, (double? max, double? x) => !x.HasValue || (max.HasValue && x.Value < max.Value));
		}

		public static double? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Max();
		}

		public static decimal Sum(this IEnumerable<decimal> source)
		{
			CheckNotNull(source, "source");
			decimal result = 0m;
			foreach (decimal item in source)
			{
				result += item;
			}
			return result;
		}

		public static decimal Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Sum();
		}

		public static decimal Average(this IEnumerable<decimal> source)
		{
			CheckNotNull(source, "source");
			decimal num = 0m;
			long num2 = 0L;
			foreach (decimal item in source)
			{
				num += item;
				num2 = checked(num2 + 1);
			}
			if (num2 == 0)
			{
				throw new InvalidOperationException();
			}
			return num / (decimal)num2;
		}

		public static decimal Average<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Average();
		}

		public static decimal? Sum(this IEnumerable<decimal?> source)
		{
			CheckNotNull(source, "source");
			decimal value = 0m;
			foreach (decimal? item in source)
			{
				value += ((!item.HasValue) ? 0m : item.Value);
			}
			return value;
		}

		public static decimal? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Sum();
		}

		public static decimal? Average(this IEnumerable<decimal?> source)
		{
			CheckNotNull(source, "source");
			decimal value = 0m;
			long num = 0L;
			foreach (decimal? item in source.Where((decimal? n) => n.HasValue))
			{
				value += item.Value;
				num = checked(num + 1);
			}
			if (num == 0)
			{
				return null;
			}
			decimal? num2 = value;
			return (!num2.HasValue) ? null : new decimal?(num2.GetValueOrDefault() / (decimal)num);
		}

		public static decimal? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Average();
		}

		public static decimal? Min(this IEnumerable<decimal?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((decimal? x) => x.HasValue).MinMaxImpl(null, (decimal? min, decimal? x) => min < x);
		}

		public static decimal? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Min();
		}

		public static decimal? Max(this IEnumerable<decimal?> source)
		{
			CheckNotNull(source, "source");
			return source.Where((decimal? x) => x.HasValue).MinMaxImpl(null, (decimal? max, decimal? x) => !x.HasValue || (max.HasValue && x.Value < max.Value));
		}

		public static decimal? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Max();
		}
	}
	internal interface IGrouping<TKey, TElement> : IEnumerable<TElement>, IEnumerable
	{
		TKey Key { get; }
	}
	internal interface ILookup<TKey, TElement> : IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		int Count { get; }

		IEnumerable<TElement> this[TKey key] { get; }

		bool Contains(TKey key);
	}
	internal interface IOrderedEnumerable<TElement> : IEnumerable<TElement>, IEnumerable
	{
		IOrderedEnumerable<TElement> CreateOrderedEnumerable<TKey>(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending);
	}
	internal sealed class Lookup<TKey, TElement> : ILookup<TKey, TElement>, IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		private readonly Dictionary<TKey, IGrouping<TKey, TElement>> _map;

		public int Count => _map.Count;

		public IEnumerable<TElement> this[TKey key]
		{
			get
			{
				IGrouping<TKey, TElement> value;
				return (!_map.TryGetValue(key, out value)) ? Enumerable.Empty<TElement>() : value;
			}
		}

		internal Lookup(IEqualityComparer<TKey> comparer)
		{
			_map = new Dictionary<TKey, IGrouping<TKey, TElement>>(comparer);
		}

		internal void Add(IGrouping<TKey, TElement> item)
		{
			_map.Add(item.Key, item);
		}

		internal IEnumerable<TElement> Find(TKey key)
		{
			IGrouping<TKey, TElement> value;
			return (!_map.TryGetValue(key, out value)) ? null : value;
		}

		public bool Contains(TKey key)
		{
			return _map.ContainsKey(key);
		}

		public IEnumerable<TResult> ApplyResultSelector<TResult>(Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			foreach (KeyValuePair<TKey, IGrouping<TKey, TElement>> pair in _map)
			{
				yield return resultSelector(pair.Key, pair.Value);
			}
		}

		public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
		{
			return _map.Values.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal sealed class OrderedEnumerable<T, K> : IOrderedEnumerable<T>, IEnumerable<T>, IEnumerable
	{
		private readonly IEnumerable<T> _source;

		private readonly List<Comparison<T>> _comparisons;

		public OrderedEnumerable(IEnumerable<T> source, Func<T, K> keySelector, IComparer<K> comparer, bool descending)
			: this(source, (List<Comparison<T>>)null, keySelector, comparer, descending)
		{
		}

		private OrderedEnumerable(IEnumerable<T> source, List<Comparison<T>> comparisons, Func<T, K> keySelector, IComparer<K> comparer, bool descending)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			_source = source;
			comparer = comparer ?? Comparer<K>.Default;
			if (comparisons == null)
			{
				comparisons = new List<Comparison<T>>(4);
			}
			comparisons.Add((T x, T y) => ((!descending) ? 1 : (-1)) * comparer.Compare(keySelector(x), keySelector(y)));
			_comparisons = comparisons;
		}

		public IOrderedEnumerable<T> CreateOrderedEnumerable<KK>(Func<T, KK> keySelector, IComparer<KK> comparer, bool descending)
		{
			return new OrderedEnumerable<T, KK>(_source, _comparisons, keySelector, comparer, descending);
		}

		public IEnumerator<T> GetEnumerator()
		{
			List<Tuple<T, int>> list = _source.Select(TagPosition).ToList();
			list.Sort(delegate(Tuple<T, int> x, Tuple<T, int> y)
			{
				List<Comparison<T>> comparisons = _comparisons;
				for (int i = 0; i < comparisons.Count; i++)
				{
					int num = comparisons[i](x.First, y.First);
					if (num != 0)
					{
						return num;
					}
				}
				return x.Second.CompareTo(y.Second);
			});
			return list.Select(GetFirst).GetEnumerator();
		}

		private static Tuple<T, int> TagPosition(T e, int i)
		{
			return new Tuple<T, int>(e, i);
		}

		private static T GetFirst(Tuple<T, int> pv)
		{
			return pv.First;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	[Serializable]
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct Tuple<TFirst, TSecond> : IEquatable<Tuple<TFirst, TSecond>>
	{
		public TFirst First { get; private set; }

		public TSecond Second { get; private set; }

		public Tuple(TFirst first, TSecond second)
		{
			this = default(Tuple<TFirst, TSecond>);
			First = first;
			Second = second;
		}

		public override bool Equals(object obj)
		{
			return obj != null && obj is Tuple<TFirst, TSecond> && ((ValueType)this).Equals((object)(Tuple<TFirst, TSecond>)obj);
		}

		public bool Equals(Tuple<TFirst, TSecond> other)
		{
			return EqualityComparer<TFirst>.Default.Equals(other.First, First) && EqualityComparer<TSecond>.Default.Equals(other.Second, Second);
		}

		public override int GetHashCode()
		{
			int num = 2049903426;
			num = -1521134295 * num + EqualityComparer<TFirst>.Default.GetHashCode(First);
			return -1521134295 * num + EqualityComparer<TSecond>.Default.GetHashCode(Second);
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{{ First = {0}, Second = {1} }}", First, Second);
		}
	}
}
namespace Newtonsoft.Json.Utilities
{
	internal static class MathUtils
	{
		public static int IntLength(ulong i)
		{
			if (i < 10000000000L)
			{
				if (i < 10)
				{
					return 1;
				}
				if (i < 100)
				{
					return 2;
				}
				if (i < 1000)
				{
					return 3;
				}
				if (i < 10000)
				{
					return 4;
				}
				if (i < 100000)
				{
					return 5;
				}
				if (i < 1000000)
				{
					return 6;
				}
				if (i < 10000000)
				{
					return 7;
				}
				if (i < 100000000)
				{
					return 8;
				}
				if (i < 1000000000)
				{
					return 9;
				}
				return 10;
			}
			if (i < 100000000000L)
			{
				return 11;
			}
			if (i < 1000000000000L)
			{
				return 12;
			}
			if (i < 10000000000000L)
			{
				return 13;
			}
			if (i < 100000000000000L)
			{
				return 14;
			}
			if (i < 1000000000000000L)
			{
				return 15;
			}
			if (i < 10000000000000000L)
			{
				return 16;
			}
			if (i < 100000000000000000L)
			{
				return 17;
			}
			if (i < 1000000000000000000L)
			{
				return 18;
			}
			if (i < 10000000000000000000uL)
			{
				return 19;
			}
			return 20;
		}

		public static char IntToHex(int n)
		{
			if (n <= 9)
			{
				return (char)(n + 48);
			}
			return (char)(n - 10 + 97);
		}

		public static int? Min(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Min(val1.Value, val2.Value);
		}

		public static int? Max(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.Value, val2.Value);
		}

		public static double? Max(double? val1, double? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.Value, val2.Value);
		}

		public static bool ApproxEquals(double d1, double d2)
		{
			if (d1 == d2)
			{
				return true;
			}
			double num = (Math.Abs(d1) + Math.Abs(d2) + 10.0) * 2.220446049250313E-16;
			double num2 = d1 - d2;
			return 0.0 - num < num2 && num > num2;
		}
	}
	internal delegate TResult MethodCall<T, TResult>(T target, params object[] args);
	internal delegate T Creator<T>();
	internal static class MiscellaneousUtils
	{
		public static bool ValueEquals(object objA, object objB)
		{
			if (objA == null && objB == null)
			{
				return true;
			}
			if (objA != null && objB == null)
			{
				return false;
			}
			if (objA == null && objB != null)
			{
				return false;
			}
			if (objA.GetType() != objB.GetType())
			{
				if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))
				{
					return Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture));
				}
				if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal))
				{
					return MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture));
				}
				return false;
			}
			return objA.Equals(objB);
		}

		public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
		{
			string message2 = message + Environment.NewLine + "Actual value was {0}.".FormatWith(CultureInfo.InvariantCulture, actualValue);
			return new ArgumentOutOfRangeException(paramName, message2);
		}

		public static string ToString(object value)
		{
			if (value == null)
			{
				return "{null}";
			}
			return (!(value is string)) ? value.ToString() : ("\"" + value.ToString() + "\"");
		}

		public static int ByteArrayCompare(byte[] a1, byte[] a2)
		{
			int num = a1.Length.CompareTo(a2.Length);
			if (num != 0)
			{
				return num;
			}
			for (int i = 0; i < a1.Length; i++)
			{
				int num2 = a1[i].CompareTo(a2[i]);
				if (num2 != 0)
				{
					return num2;
				}
			}
			return 0;
		}

		public static string GetPrefix(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out var prefix, out var _);
			return prefix;
		}

		public static string GetLocalName(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out var _, out var localName);
			return localName;
		}

		public static void GetQualifiedNameParts(string qualifiedName, out string prefix, out string localName)
		{
			int num = qualifiedName.IndexOf(':');
			if (num == -1 || num == 0 || qualifiedName.Length - 1 == num)
			{
				prefix = null;
				localName = qualifiedName;
			}
			else
			{
				prefix = qualifiedName.Substring(0, num);
				localName = qualifiedName.Substring(num + 1);
			}
		}

		internal static string FormatValueForPrint(object value)
		{
			if (value == null)
			{
				return "{null}";
			}
			if (value is string)
			{
				return string.Concat("\"", value, "\"");
			}
			return value.ToString();
		}
	}
	internal class PropertyNameTable
	{
		private class Entry
		{
			internal readonly string Value;

			internal readonly int HashCode;

			internal Entry Next;

			internal Entry(string value, int hashCode, Entry next)
			{
				Value = value;
				HashCode = hashCode;
				Next = next;
			}
		}

		private static readonly int HashCodeRandomizer;

		private int _count;

		private Entry[] _entries;

		private int _mask = 31;

		static PropertyNameTable()
		{
			HashCodeRandomizer = Environment.TickCount;
		}

		public PropertyNameTable()
		{
			_entries = new Entry[_mask + 1];
		}

		public string Get(char[] key, int start, int length)
		{
			if (length == 0)
			{
				return string.Empty;
			}
			int num = length + HashCodeRandomizer;
			num += (num << 7) ^ key[start];
			int num2 = start + length;
			for (int i = start + 1; i < num2; i++)
			{
				num += (num << 7) ^ key[i];
			}
			num -= num >> 17;
			num -= num >> 11;
			num -= num >> 5;
			for (Entry entry = _entries[num & _mask]; entry != null; entry = entry.Next)
			{
				if (entry.HashCode == num && TextEquals(entry.Value, key, start, length))
				{
					return entry.Value;
				}
			}
			return null;
		}

		public string Add(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			int length = key.Length;
			if (length == 0)
			{
				return string.Empty;
			}
			int num = length + HashCodeRandomizer;
			for (int i = 0; i < key.Length; i++)
			{
				num += (num << 7) ^ key[i];
			}
			num -= num >> 17;
			num -= num >> 11;
			num -= num >> 5;
			for (Entry entry = _entries[num & _mask]; entry != null; entry = entry.Next)
			{
				if (entry.HashCode == num && entry.Value.Equals(key))
				{
					return entry.Value;
				}
			}
			return AddEntry(key, num);
		}

		private string AddEntry(string str, int hashCode)
		{
			int num = hashCode & _mask;
			Entry entry = new Entry(str, hashCode, _entries[num]);
			_entries[num] = entry;
			if (_count++ == _mask)
			{
				Grow();
			}
			return entry.Value;
		}

		private void Grow()
		{
			Entry[] entries = _entries;
			int num = _mask * 2 + 1;
			Entry[] array = new Entry[num + 1];
			for (int i = 0; i < entries.Length; i++)
			{
				Entry entry = entries[i];
				while (entry != null)
				{
					int num2 = entry.HashCode & num;
					Entry next = entry.Next;
					entry.Next = array[num2];
					array[num2] = entry;
					entry = next;
				}
			}
			_entries = array;
			_mask = num;
		}

		private static bool TextEquals(string str1, char[] str2, int str2Start, int str2Length)
		{
			if (str1.Length != str2Length)
			{
				return false;
			}
			for (int i = 0; i < str1.Length; i++)
			{
				if (str1[i] != str2[str2Start + i])
				{
					return false;
				}
			}
			return true;
		}
	}
	internal abstract class ReflectionDelegateFactory
	{
		public Func<T, object> CreateGet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				return CreateGet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateGet<T>(fieldInfo);
			}
			throw new Exception("Could not create getter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public Action<T, object> CreateSet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				return CreateSet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateSet<T>(fieldInfo);
			}
			throw new Exception("Could not create setter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public abstract MethodCall<T, object> CreateMethodCall<T>(MethodBase method);

		public abstract Newtonsoft.Json.Serialization.ObjectConstructor<object> CreateParametrizedConstructor(MethodBase method);

		public abstract Func<T> CreateDefaultConstructor<T>(Type type);

		public abstract Func<T, object> CreateGet<T>(PropertyInfo propertyInfo);

		public abstract Func<T, object> CreateGet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object> CreateSet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object> CreateSet<T>(PropertyInfo propertyInfo);
	}
	internal class ReflectionMember
	{
		public Type MemberType { get; set; }

		public Func<object, object> Getter { get; set; }

		public Action<object, object> Setter { get; set; }
	}
	internal class ReflectionObject
	{
		public Newtonsoft.Json.Serialization.ObjectConstructor<object> Creator { get; private set; }

		public IDictionary<string, ReflectionMember> Members { get; private set; }

		public ReflectionObject()
		{
			Members = new Dictionary<string, ReflectionMember>();
		}

		public object GetValue(object target, string member)
		{
			Func<object, object> getter = Members[member].Getter;
			return getter(target);
		}

		public void SetValue(object target, string member, object value)
		{
			Action<object, object> setter = Members[member].Setter;
			setter(target, value);
		}

		public Type GetType(string member)
		{
			return Members[member].MemberType;
		}

		public static ReflectionObject Create(Type t, params string[] memberNames)
		{
			return Create(t, null, memberNames);
		}

		public static ReflectionObject Create(Type t, MethodBase creator, params string[] memberNames)
		{
			ReflectionObject reflectionObject = new ReflectionObject();
			ReflectionDelegateFactory reflectionDelegateFactory = Newtonsoft.Json.Serialization.JsonTypeReflector.ReflectionDelegateFactory;
			if (creator != null)
			{
				reflectionObject.Creator = reflectionDelegateFactory.CreateParametrizedConstructor(creator);
			}
			else if (ReflectionUtils.HasDefaultConstructor(t, nonPublic: false))
			{
				Func<object> ctor = reflectionDelegateFactory.CreateDefaultConstructor<object>(t);
				reflectionObject.Creator = (object[] args) => ctor();
			}
			foreach (string text in memberNames)
			{
				MemberInfo[] member = t.GetMember(text, BindingFlags.Instance | BindingFlags.Public);
				if (member.Length != 1)
				{
					throw new ArgumentException("Expected a single member with the name '{0}'.".FormatWith(CultureInfo.InvariantCulture, text));
				}
				MemberInfo memberInfo = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Single(member);
				ReflectionMember reflectionMember = new ReflectionMember();
				switch (memberInfo.MemberType())
				{
				case MemberTypes.Field:
				case MemberTypes.Property:
					if (ReflectionUtils.CanReadMemberValue(memberInfo, nonPublic: false))
					{
						reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
					}
					if (ReflectionUtils.CanSetMemberValue(memberInfo, nonPublic: false, canSetReadOnly: false))
					{
						reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
					}
					break;
				case MemberTypes.Method:
				{
					MethodInfo methodInfo = (MethodInfo)memberInfo;
					if (!methodInfo.IsPublic)
					{
						break;
					}
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters.Length == 0 && methodInfo.ReturnType != typeof(void))
					{
						MethodCall<object, object> call2 = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
						reflectionMember.Getter = (object target) => call2(target);
					}
					else if (parameters.Length == 1 && methodInfo.ReturnType == typeof(void))
					{
						MethodCall<object, object> call = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
						reflectionMember.Setter = delegate(object target, object arg)
						{
							call(target, arg);
						};
					}
					break;
				}
				default:
					throw new ArgumentException("Unexpected member type '{0}' for member '{1}'.".FormatWith(CultureInfo.InvariantCulture, memberInfo.MemberType(), memberInfo.Name));
				}
				if (ReflectionUtils.CanReadMemberValue(memberInfo, nonPublic: false))
				{
					reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
				}
				if (ReflectionUtils.CanSetMemberValue(memberInfo, nonPublic: false, canSetReadOnly: false))
				{
					reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
				}
				reflectionMember.MemberType = ReflectionUtils.GetMemberUnderlyingType(memberInfo);
				reflectionObject.Members[text] = reflectionMember;
			}
			return reflectionObject;
		}
	}
	internal static class ReflectionUtils
	{
		public static readonly Type[] EmptyTypes;

		static ReflectionUtils()
		{
			EmptyTypes = Type.EmptyTypes;
		}

		public static bool IsVirtual(this PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			MethodInfo getMethod = propertyInfo.GetGetMethod();
			if (getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			getMethod = propertyInfo.GetSetMethod();
			if (getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			return false;
		}

		public static MethodInfo GetBaseDefinition(this PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			MethodInfo getMethod = propertyInfo.GetGetMethod();
			if (getMethod != null)
			{
				return getMethod.GetBaseDefinition();
			}
			return propertyInfo.GetSetMethod()?.GetBaseDefinition();
		}

		public static bool IsPublic(PropertyInfo property)
		{
			if (property.GetGetMethod() != null && property.GetGetMethod().IsPublic)
			{
				return true;
			}
			if (property.GetSetMethod() != null && property.GetSetMethod().IsPublic)
			{
				return true;
			}
			return false;
		}

		public static Type GetObjectType(object v)
		{
			return v?.GetType();
		}

		public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder)
		{
			string assemblyQualifiedName = t.AssemblyQualifiedName;
			return assemblyFormat switch
			{
				FormatterAssemblyStyle.Simple => RemoveAssemblyDetails(assemblyQualifiedName), 
				FormatterAssemblyStyle.Full => assemblyQualifiedName, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		private static string RemoveAssemblyDetails(string fullyQualifiedTypeName)
		{
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = false;
			bool flag2 = false;
			foreach (char c in fullyQualifiedTypeName)
			{
				switch (c)
				{
				case '[':
					flag = false;
					flag2 = false;
					stringBuilder.Append(c);
					break;
				case ']':
					flag = false;
					flag2 = false;
					stringBuilder.Append(c);
					break;
				case ',':
					if (!flag)
					{
						flag = true;
						stringBuilder.Append(c);
					}
					else
					{
						flag2 = true;
					}
					break;
				default:
					if (!flag2)
					{
						stringBuilder.Append(c);
					}
					break;
				}
			}
			return stringBuilder.ToString();
		}

		public static bool HasDefaultConstructor(Type t, bool nonPublic)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType())
			{
				return true;
			}
			return GetDefaultConstructor(t, nonPublic) != null;
		}

		public static ConstructorInfo GetDefaultConstructor(Type t)
		{
			return GetDefaultConstructor(t, nonPublic: false);
		}

		public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (nonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SingleOrDefault(t.GetConstructors(bindingFlags), (ConstructorInfo c) => !Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Any(c.GetParameters()));
		}

		public static bool IsNullable(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType())
			{
				return IsNullableType(t);
			}
			return true;
		}

		public static bool IsNullableType(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			return t.IsGenericType() && t.GetGenericTypeDefinition() == typeof(Nullable<>);
		}

		public static Type EnsureNotNullableType(Type t)
		{
			return (!IsNullableType(t)) ? t : Nullable.GetUnderlyingType(t);
		}

		public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition)
		{
			if (!type.IsGenericType())
			{
				return false;
			}
			Type genericTypeDefinition = type.GetGenericTypeDefinition();
			return genericTypeDefinition == genericInterfaceDefinition;
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
		{
			Type implementingType;
			return ImplementsGenericDefinition(type, genericInterfaceDefinition, out implementingType);
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, out Type implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericInterfaceDefinition, "genericInterfaceDefinition");
			if (!genericInterfaceDefinition.IsInterface() || !genericInterfaceDefinition.IsGenericTypeDefinition())
			{
				throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith(CultureInfo.InvariantCulture, genericInterfaceDefinition));
			}
			if (type.IsInterface() && type.IsGenericType())
			{
				Type genericTypeDefinition = type.GetGenericTypeDefinition();
				if (genericInterfaceDefinition == genericTypeDefinition)
				{
					implementingType = type;
					return true;
				}
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				if (type2.IsGenericType())
				{
					Type genericTypeDefinition2 = type2.GetGenericTypeDefinition();
					if (genericInterfaceDefinition == genericTypeDefinition2)
					{
						implementingType = type2;
						return true;
					}
				}
			}
			implementingType = null;
			return false;
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
		{
			Type implementingType;
			return InheritsGenericDefinition(type, genericClassDefinition, out implementingType);
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, out Type implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericClassDefinition, "genericClassDefinition");
			if (!genericClassDefinition.IsClass() || !genericClassDefinition.IsGenericTypeDefinition())
			{
				throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith(CultureInfo.InvariantCulture, genericClassDefinition));
			}
			return InheritsGenericDefinitionInternal(type, genericClassDefinition, out implementingType);
		}

		private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, out Type implementingType)
		{
			if (currentType.IsGenericType())
			{
				Type genericTypeDefinition = currentType.GetGenericTypeDefinition();
				if (genericClassDefinition == genericTypeDefinition)
				{
					implementingType = currentType;
					return true;
				}
			}
			if (currentType.BaseType() == null)
			{
				implementingType = null;
				return false;
			}
			return InheritsGenericDefinitionInternal(currentType.BaseType(), genericClassDefinition, out implementingType);
		}

		public static Type GetCollectionItemType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsArray)
			{
				return type.GetElementType();
			}
			if (ImplementsGenericDefinition(type, typeof(IEnumerable<>), out var implementingType))
			{
				if (implementingType.IsGenericTypeDefinition())
				{
					throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
				}
				return implementingType.GetGenericArguments()[0];
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				return null;
			}
			throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
		}

		public static void GetDictionaryKeyValueTypes(Type dictionaryType, out Type keyType, out Type valueType)
		{
			ValidationUtils.ArgumentNotNull(dictionaryType, "type");
			if (ImplementsGenericDefinition(dictionaryType, typeof(IDictionary<, >), out var implementingType))
			{
				if (implementingType.IsGenericTypeDefinition())
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				Type[] genericArguments = implementingType.GetGenericArguments();
				keyType = genericArguments[0];
				valueType = genericArguments[1];
			}
			else
			{
				if (!typeof(IDictionary).IsAssignableFrom(dictionaryType))
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				keyType = null;
				valueType = null;
			}
		}

		public static Type GetMemberUnderlyingType(MemberInfo member)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			return member.MemberType() switch
			{
				MemberTypes.Field => ((FieldInfo)member).FieldType, 
				MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
				MemberTypes.Event => ((EventInfo)member).EventHandlerType, 
				MemberTypes.Method => ((MethodInfo)member).ReturnType, 
				_ => throw new ArgumentException("MemberInfo must be of type FieldInfo, PropertyInfo, EventInfo or MethodInfo", "member"), 
			};
		}

		public static bool IsIndexedProperty(MemberInfo member)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			if (member is PropertyInfo property)
			{
				return IsIndexedProperty(property);
			}
			return false;
		}

		public static bool IsIndexedProperty(PropertyInfo property)
		{
			ValidationUtils.ArgumentNotNull(property, "property");
			return property.GetIndexParameters().Length > 0;
		}

		public static object GetMemberValue(MemberInfo member, object target)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType())
			{
			case MemberTypes.Field:
				return ((FieldInfo)member).GetValue(target);
			case MemberTypes.Property:
				try
				{
					MethodInfo getMethod = ((PropertyInfo)member).GetGetMethod();
					return getMethod.Invoke(target, null);
				}
				catch (TargetParameterCountException innerException)
				{
					throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith(CultureInfo.InvariantCulture, member.Name), innerException);
				}
			default:
				throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static void SetMemberValue(MemberInfo member, object target, object value)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType())
			{
			case MemberTypes.Field:
				((FieldInfo)member).SetValue(target, value);
				break;
			case MemberTypes.Property:
				((PropertyInfo)member).SetValue(target, value, null);
				break;
			default:
				throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static bool CanReadMemberValue(MemberInfo member, bool nonPublic)
		{
			switch (member.MemberType())
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanRead)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return propertyInfo.GetGetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
		{
			switch (member.MemberType())
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (fieldInfo.IsLiteral)
				{
					return false;
				}
				if (fieldInfo.IsInitOnly && !canSetReadOnly)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanWrite)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return propertyInfo.GetSetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static List<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
		{
			List<MemberInfo> list = new List<MemberInfo>();
			list.AddRange(GetFields(type, bindingAttr));
			list.AddRange(GetProperties(type, bindingAttr));
			List<MemberInfo> list2 = new List<MemberInfo>(list.Count);
			foreach (Newtonsoft.Json.Utilities.LinqBridge.IGrouping<string, MemberInfo> item in Newtonsoft.Json.Utilities.LinqBridge.Enumerable.GroupBy(list, (MemberInfo m) => m.Name))
			{
				int num = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Count(item);
				IList<MemberInfo> list3 = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToList(item);
				if (num == 1)
				{
					list2.Add(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.First(list3));
					continue;
				}
				IList<MemberInfo> list4 = new List<MemberInfo>();
				foreach (MemberInfo item2 in list3)
				{
					if (list4.Count == 0)
					{
						list4.Add(item2);
					}
					else if (!IsOverridenGenericMember(item2, bindingAttr) || item2.Name == "Item")
					{
						list4.Add(item2);
					}
				}
				list2.AddRange(list4);
			}
			return list2;
		}

		private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
		{
			if (memberInfo.MemberType() != MemberTypes.Property)
			{
				return false;
			}
			PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
			if (!propertyInfo.IsVirtual())
			{
				return false;
			}
			Type declaringType = propertyInfo.DeclaringType;
			if (!declaringType.IsGenericType())
			{
				return false;
			}
			Type genericTypeDefinition = declaringType.GetGenericTypeDefinition();
			if (genericTypeDefinition == null)
			{
				return false;
			}
			MemberInfo[] member = genericTypeDefinition.GetMember(propertyInfo.Name, bindingAttr);
			if (member.Length == 0)
			{
				return false;
			}
			Type memberUnderlyingType = GetMemberUnderlyingType(member[0]);
			if (!memberUnderlyingType.IsGenericParameter)
			{
				return false;
			}
			return true;
		}

		public static T GetAttribute<T>(object attributeProvider) where T : Attribute
		{
			return GetAttribute<T>(attributeProvider, inherit: true);
		}

		public static T GetAttribute<T>(object attributeProvider, bool inherit) where T : Attribute
		{
			T[] attributes = GetAttributes<T>(attributeProvider, inherit);
			return (attributes == null) ? ((T)null) : Newtonsoft.Json.Utilities.LinqBridge.Enumerable.FirstOrDefault(attributes);
		}

		public static T[] GetAttributes<T>(object attributeProvider, bool inherit) where T : Attribute
		{
			Attribute[] attributes = GetAttributes(attributeProvider, typeof(T), inherit);
			if (attributes is T[] result)
			{
				return result;
			}
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<T>(attributes));
		}

		public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit)
		{
			ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
			if (attributeProvider is Type)
			{
				Type type = (Type)attributeProvider;
				object[] source = ((attributeType == null) ? type.GetCustomAttributes(inherit) : type.GetCustomAttributes(attributeType, inherit));
				Attribute[] array = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<Attribute>(source));
				if (inherit && type.BaseType != null)
				{
					array = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Union(array, GetAttributes(type.BaseType, attributeType, inherit)));
				}
				return array;
			}
			if (attributeProvider is Assembly)
			{
				Assembly element = (Assembly)attributeProvider;
				return (attributeType == null) ? Attribute.GetCustomAttributes(element) : Attribute.GetCustomAttributes(element, attributeType);
			}
			if (attributeProvider is MemberInfo)
			{
				MemberInfo element2 = (MemberInfo)attributeProvider;
				return (attributeType == null) ? Attribute.GetCustomAttributes(element2, inherit) : Attribute.GetCustomAttributes(element2, attributeType, inherit);
			}
			if (attributeProvider is Module)
			{
				Module element3 = (Module)attributeProvider;
				return (attributeType == null) ? Attribute.GetCustomAttributes(element3, inherit) : Attribute.GetCustomAttributes(element3, attributeType, inherit);
			}
			if (attributeProvider is ParameterInfo)
			{
				ParameterInfo element4 = (ParameterInfo)attributeProvider;
				return (attributeType == null) ? Attribute.GetCustomAttributes(element4, inherit) : Attribute.GetCustomAttributes(element4, attributeType, inherit);
			}
			ICustomAttributeProvider customAttributeProvider = (ICustomAttributeProvider)attributeProvider;
			object[] array2 = ((attributeType == null) ? customAttributeProvider.GetCustomAttributes(inherit) : customAttributeProvider.GetCustomAttributes(attributeType, inherit));
			return (Attribute[])array2;
		}

		public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, out string typeName, out string assemblyName)
		{
			int? assemblyDelimiterIndex = GetAssemblyDelimiterIndex(fullyQualifiedTypeName);
			if (assemblyDelimiterIndex.HasValue)
			{
				typeName = fullyQualifiedTypeName.Substring(0, assemblyDelimiterIndex.Value).Trim();
				assemblyName = fullyQualifiedTypeName.Substring(assemblyDelimiterIndex.Value + 1, fullyQualifiedTypeName.Length - assemblyDelimiterIndex.Value - 1).Trim();
			}
			else
			{
				typeName = fullyQualifiedTypeName;
				assemblyName = null;
			}
		}

		private static int? GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
		{
			int num = 0;
			for (int i = 0; i < fullyQualifiedTypeName.Length; i++)
			{
				switch (fullyQualifiedTypeName[i])
				{
				case '[':
					num++;
					break;
				case ']':
					num--;
					break;
				case ',':
					if (num == 0)
					{
						return i;
					}
					break;
				}
			}
			return null;
		}

		public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
		{
			MemberTypes memberTypes = memberInfo.MemberType();
			if (memberTypes == MemberTypes.Property)
			{
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				Type[] types = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.ToArray(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Select(propertyInfo.GetIndexParameters(), (ParameterInfo p) => p.ParameterType));
				return targetType.GetProperty(propertyInfo.Name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, propertyInfo.PropertyType, types, null);
			}
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SingleOrDefault(targetType.GetMember(memberInfo.Name, memberInfo.MemberType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
		}

		public static IEnumerable<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<MemberInfo> list = new List<MemberInfo>(targetType.GetFields(bindingAttr));
			GetChildPrivateFields(list, targetType, bindingAttr);
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<FieldInfo>(list);
		}

		private static void GetChildPrivateFields(IList<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
		{
			if ((bindingAttr & BindingFlags.NonPublic) == 0)
			{
				return;
			}
			BindingFlags bindingAttr2 = bindingAttr.RemoveFlag(BindingFlags.Public);
			while ((targetType = targetType.BaseType()) != null)
			{
				IEnumerable<MemberInfo> collection = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Cast<MemberInfo>(Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(targetType.GetFields(bindingAttr2), (FieldInfo f) => f.IsPrivate));
				initialFields.AddRange(collection);
			}
		}

		public static IEnumerable<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<PropertyInfo> list = new List<PropertyInfo>(targetType.GetProperties(bindingAttr));
			GetChildPrivateProperties(list, targetType, bindingAttr);
			for (int i = 0; i < list.Count; i++)
			{
				PropertyInfo propertyInfo = list[i];
				if (propertyInfo.DeclaringType != targetType)
				{
					PropertyInfo value = (PropertyInfo)GetMemberInfoFromType(propertyInfo.DeclaringType, propertyInfo);
					list[i] = value;
				}
			}
			return list;
		}

		public static BindingFlags RemoveFlag(this BindingFlags bindingAttr, BindingFlags flag)
		{
			return ((bindingAttr & flag) != flag) ? bindingAttr : (bindingAttr ^ flag);
		}

		private static void GetChildPrivateProperties(IList<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
		{
			while ((targetType = targetType.BaseType()) != null)
			{
				PropertyInfo[] properties = targetType.GetProperties(bindingAttr);
				foreach (PropertyInfo propertyInfo in properties)
				{
					PropertyInfo subTypeProperty = propertyInfo;
					if (!IsPublic(subTypeProperty))
					{
						int num = initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name);
						if (num == -1)
						{
							initialProperties.Add(subTypeProperty);
							continue;
						}
						PropertyInfo property = initialProperties[num];
						if (!IsPublic(property))
						{
							initialProperties[num] = subTypeProperty;
						}
					}
					else if (!subTypeProperty.IsVirtual())
					{
						int num2 = initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && p.DeclaringType == subTypeProperty.DeclaringType);
						if (num2 == -1)
						{
							initialProperties.Add(subTypeProperty);
						}
					}
					else
					{
						int num3 = initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && p.IsVirtual() && p.GetBaseDefinition() != null && p.GetBaseDefinition().DeclaringType.IsAssignableFrom(subTypeProperty.DeclaringType));
						if (num3 == -1)
						{
							initialProperties.Add(subTypeProperty);
						}
					}
				}
			}
		}

		public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method)
		{
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Any(currentType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic), (MethodInfo info) => info.Name == method && info.DeclaringType != methodDeclaringType && info.GetBaseDefinition().DeclaringType == methodDeclaringType);
		}

		public static object GetDefaultValue(Type type)
		{
			if (!type.IsValueType())
			{
				return null;
			}
			switch (ConvertUtils.GetTypeCode(type))
			{
			case PrimitiveTypeCode.Boolean:
				return false;
			case PrimitiveTypeCode.Char:
			case PrimitiveTypeCode.SByte:
			case PrimitiveTypeCode.Int16:
			case PrimitiveTypeCode.UInt16:
			case PrimitiveTypeCode.Int32:
			case PrimitiveTypeCode.Byte:
			case PrimitiveTypeCode.UInt32:
				return 0;
			case PrimitiveTypeCode.Int64:
			case PrimitiveTypeCode.UInt64:
				return 0L;
			case PrimitiveTypeCode.Single:
				return 0f;
			case PrimitiveTypeCode.Double:
				return 0.0;
			case PrimitiveTypeCode.Decimal:
				return 0m;
			case PrimitiveTypeCode.DateTime:
				return default(DateTime);
			case PrimitiveTypeCode.Guid:
				return default(Guid);
			default:
				if (IsNullable(type))
				{
					return null;
				}
				return Activator.CreateInstance(type);
			}
		}
	}
	internal class StringBuffer
	{
		private char[] _buffer;

		private int _position;

		private static readonly char[] EmptyBuffer = new char[0];

		public int Position
		{
			get
			{
				return _position;
			}
			set
			{
				_position = value;
			}
		}

		public StringBuffer()
		{
			_buffer = EmptyBuffer;
		}

		public StringBuffer(int initalSize)
		{
			_buffer = new char[initalSize];
		}

		public void Append(char value)
		{
			if (_position == _buffer.Length)
			{
				EnsureSize(1);
			}
			_buffer[_position++] = value;
		}

		public void Append(char[] buffer, int startIndex, int count)
		{
			if (_position + count >= _buffer.Length)
			{
				EnsureSize(count);
			}
			Array.Copy(buffer, startIndex, _buffer, _position, count);
			_position += count;
		}

		public void Clear()
		{
			_buffer = EmptyBuffer;
			_position = 0;
		}

		private void EnsureSize(int appendLength)
		{
			char[] array = new char[(_position + appendLength) * 2];
			Array.Copy(_buffer, array, _position);
			_buffer = array;
		}

		public override string ToString()
		{
			return ToString(0, _position);
		}

		public string ToString(int start, int length)
		{
			return new string(_buffer, start, length);
		}

		public char[] GetInternalBuffer()
		{
			return _buffer;
		}
	}
	internal struct StringReference
	{
		private readonly char[] _chars;

		private readonly int _startIndex;

		private readonly int _length;

		public char[] Chars => _chars;

		public int StartIndex => _startIndex;

		public int Length => _length;

		public StringReference(char[] chars, int startIndex, int length)
		{
			_chars = chars;
			_startIndex = startIndex;
			_length = length;
		}

		public override string ToString()
		{
			return new string(_chars, _startIndex, _length);
		}
	}
	internal static class StringUtils
	{
		public const string CarriageReturnLineFeed = "\r\n";

		public const string Empty = "";

		public const char CarriageReturn = '\r';

		public const char LineFeed = '\n';

		public const char Tab = '\t';

		public static string FormatWith(this string format, IFormatProvider provider, object arg0)
		{
			return format.FormatWith(provider, new object[1] { arg0 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1)
		{
			return format.FormatWith(provider, new object[2] { arg0, arg1 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1, object arg2)
		{
			return format.FormatWith(provider, new object[3] { arg0, arg1, arg2 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3)
		{
			return format.FormatWith(provider, new object[4] { arg0, arg1, arg2, arg3 });
		}

		private static string FormatWith(this string format, IFormatProvider provider, params object[] args)
		{
			ValidationUtils.ArgumentNotNull(format, "format");
			return string.Format(provider, format, args);
		}

		public static bool IsWhiteSpace(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (s.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < s.Length; i++)
			{
				if (!char.IsWhiteSpace(s[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static string NullEmptyString(string s)
		{
			return (!string.IsNullOrEmpty(s)) ? s : null;
		}

		public static StringWriter CreateStringWriter(int capacity)
		{
			StringBuilder sb = new StringBuilder(capacity);
			return new StringWriter(sb, CultureInfo.InvariantCulture);
		}

		public static int? GetLength(string value)
		{
			return value?.Length;
		}

		public static void ToCharAsUnicode(char c, char[] buffer)
		{
			buffer[0] = '\\';
			buffer[1] = 'u';
			buffer[2] = MathUtils.IntToHex(((int)c >> 12) & 0xF);
			buffer[3] = MathUtils.IntToHex(((int)c >> 8) & 0xF);
			buffer[4] = MathUtils.IntToHex(((int)c >> 4) & 0xF);
			buffer[5] = MathUtils.IntToHex(c & 0xF);
		}

		public static TSource ForgivingCaseSensitiveFind<TSource>(this IEnumerable<TSource> source, Func<TSource, string> valueSelector, string testValue)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (valueSelector == null)
			{
				throw new ArgumentNullException("valueSelector");
			}
			IEnumerable<TSource> source2 = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(source, (TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.OrdinalIgnoreCase));
			if (Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Count(source2) <= 1)
			{
				return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SingleOrDefault(source2);
			}
			IEnumerable<TSource> source3 = Newtonsoft.Json.Utilities.LinqBridge.Enumerable.Where(source, (TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.Ordinal));
			return Newtonsoft.Json.Utilities.LinqBridge.Enumerable.SingleOrDefault(source3);
		}

		public static string ToCamelCase(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return s;
			}
			if (!char.IsUpper(s[0]))
			{
				return s;
			}
			char[] array = s.ToCharArray();
			for (int i = 0; i < array.Length; i++)
			{
				bool flag = i + 1 < array.Length;
				if (i > 0 && flag && !char.IsUpper(array[i + 1]))
				{
					break;
				}
				array[i] = char.ToLower(array[i], CultureInfo.InvariantCulture);
			}
			return new string(array);
		}

		public static bool IsHighSurrogate(char c)
		{
			return char.IsHighSurrogate(c);
		}

		public static bool IsLowSurrogate(char c)
		{
			return char.IsLowSurrogate(c);
		}

		public static bool StartsWith(this string source, char value)
		{
			return source.Length > 0 && source[0] == value;
		}

		public static bool EndsWith(this string source, char value)
		{
			return source.Length > 0 && source[source.Length - 1] == value;
		}
	}
	internal class ThreadSafeStore<TKey, TValue>
	{
		private Dictionary<string, TValue> _store;

		private readonly Func<TKey, TValue> _creator;

		private StringKeyMaker<TKey> _keyMaker;

		public ThreadSafeStore(Func<TKey, TValue> creator, StringKeyMaker<TKey> keyMaker)
		{
			if (creator == null)
			{
				throw new ArgumentNullException("creator");
			}
			_creator = creator;
			_store = new Dictionary<string, TValue>();
			_keyMaker = keyMaker;
		}

		public TValue Get(TKey key)
		{
			string key2 = _keyMaker.MakeStringKey(key);
			if (!_store.TryGetValue(key2, out var value))
			{
				value = _creator(key);
				_store[key2] = value;
			}
			return value;
		}

		private TValue AddValue(TKey key)
		{
			TValue val = _creator(key);
			string key2 = _keyMaker.MakeStringKey(key);
			_store[key2] = val;
			return val;
		}
	}
	internal static class TypeExtensions
	{
		public static MethodInfo Method(this Delegate d)
		{
			return d.Method;
		}

		public static MemberTypes MemberType(this MemberInfo memberInfo)
		{
			return memberInfo.MemberType;
		}

		public static bool ContainsGenericParameters(this Type type)
		{
			return type.ContainsGenericParameters;
		}

		public static bool IsInterface(this Type type)
		{
			return type.IsInterface;
		}

		public static bool IsGenericType(this Type type)
		{
			return type.IsGenericType;
		}

		public static bool IsGenericTypeDefinition(this Type type)
		{
			return type.IsGenericTypeDefinition;
		}

		public static Type BaseType(this Type type)
		{
			return type.BaseType;
		}

		public static Assembly Assembly(this Type type)
		{
			return type.Assembly;
		}

		public static bool IsEnum(this Type type)
		{
			return type.IsEnum;
		}

		public static bool IsClass(this Type type)
		{
			return type.IsClass;
		}

		public static bool IsSealed(this Type type)
		{
			return type.IsSealed;
		}

		public static bool IsAbstract(this Type type)
		{
			return type.IsAbstract;
		}

		public static bool IsVisible(this Type type)
		{
			return type.IsVisible;
		}

		public static bool IsValueType(this Type type)
		{
			return type.IsValueType;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName, out Type match)
		{
			for (Type type2 = type; type2 != null; type2 = type2.BaseType())
			{
				if (string.Equals(type2.FullName, fullTypeName, StringComparison.Ordinal))
				{
					match = type2;
					return true;
				}
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type3 in interfaces)
			{
				if (string.Equals(type3.Name, fullTypeName, StringComparison.Ordinal))
				{
					match = type;
					return true;
				}
			}
			match = null;
			return false;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName)
		{
			Type match;
			return type.AssignableToTypeName(fullTypeName, out match);
		}
	}
	internal static class ValidationUtils
	{
		public static void ArgumentNotNullOrEmpty(string value, string parameterName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(parameterName);
			}
			if (value.Length == 0)
			{
				throw new ArgumentException("'{0}' cannot be empty.".FormatWith(CultureInfo.InvariantCulture, parameterName), parameterName);
			}
		}

		public static void ArgumentTypeIsEnum(Type enumType, string parameterName)
		{
			ArgumentNotNull(enumType, "enumType");
			if (!enumType.IsEnum())
			{
				throw new ArgumentException("Type {0} is not an Enum.".FormatWith(CultureInfo.InvariantCulture, enumType), parameterName);
			}
		}

		public static void ArgumentNotNull(object value, string parameterName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(parameterName);
			}
		}
	}
}
namespace Newtonsoft.Json
{
	public enum WriteState
	{
		Error,
		Closed,
		Object,
		Array,
		Constructor,
		Property,
		Start
	}
}
namespace PlayFab
{
	public class PlayFabClientAPI
	{
		public delegate void GetPhotonAuthenticationTokenCallback(GetPhotonAuthenticationTokenResult result);

		public delegate void LoginWithAndroidDeviceIDCallback(LoginResult result);

		public delegate void LoginWithCustomIDCallback(LoginResult result);

		public delegate void LoginWithEmailAddressCallback(LoginResult result);

		public delegate void LoginWithFacebookCallback(LoginResult result);

		public delegate void LoginWithGoogleAccountCallback(LoginResult result);

		public delegate void LoginWithIOSDeviceIDCallback(LoginResult result);

		public delegate void LoginWithKongregateCallback(LoginResult result);

		public delegate void LoginWithPlayFabCallback(LoginResult result);

		public delegate void LoginWithSteamCallback(LoginResult result);

		public delegate void RegisterPlayFabUserCallback(RegisterPlayFabUserResult result);

		public delegate void AddUsernamePasswordCallback(AddUsernamePasswordResult result);

		public delegate void GetAccountInfoCallback(GetAccountInfoResult result);

		public delegate void GetPlayFabIDsFromFacebookIDsCallback(GetPlayFabIDsFromFacebookIDsResult result);

		public delegate void GetPlayFabIDsFromGameCenterIDsCallback(GetPlayFabIDsFromGameCenterIDsResult result);

		public delegate void GetPlayFabIDsFromGoogleIDsCallback(GetPlayFabIDsFromGoogleIDsResult result);

		public delegate void GetPlayFabIDsFromSteamIDsCallback(GetPlayFabIDsFromSteamIDsResult result);

		public delegate void GetUserCombinedInfoCallback(GetUserCombinedInfoResult result);

		public delegate void LinkAndroidDeviceIDCallback(LinkAndroidDeviceIDResult result);

		public delegate void LinkCustomIDCallback(LinkCustomIDResult result);

		public delegate void LinkFacebookAccountCallback(LinkFacebookAccountResult result);

		public delegate void LinkGameCenterAccountCallback(LinkGameCenterAccountResult result);

		public delegate void LinkGoogleAccountCallback(LinkGoogleAccountResult result);

		public delegate void LinkIOSDeviceIDCallback(LinkIOSDeviceIDResult result);

		public delegate void LinkKongregateCallback(LinkKongregateAccountResult result);

		public delegate void LinkSteamAccountCallback(LinkSteamAccountResult result);

		public delegate void SendAccountRecoveryEmailCallback(SendAccountRecoveryEmailResult result);

		public delegate void UnlinkAndroidDeviceIDCallback(UnlinkAndroidDeviceIDResult result);

		public delegate void UnlinkCustomIDCallback(UnlinkCustomIDResult result);

		public delegate void UnlinkFacebookAccountCallback(UnlinkFacebookAccountResult result);

		public delegate void UnlinkGameCenterAccountCallback(UnlinkGameCenterAccountResult result);

		public delegate void UnlinkGoogleAccountCallback(UnlinkGoogleAccountResult result);

		public delegate void UnlinkIOSDeviceIDCallback(UnlinkIOSDeviceIDResult result);

		public delegate void UnlinkKongregateCallback(UnlinkKongregateAccountResult result);

		public delegate void UnlinkSteamAccountCallback(UnlinkSteamAccountResult result);

		public delegate void UpdateUserTitleDisplayNameCallback(UpdateUserTitleDisplayNameResult result);

		public delegate void GetFriendLeaderboardCallback(GetLeaderboardResult result);

		public delegate void GetLeaderboardCallback(GetLeaderboardResult result);

		public delegate void GetLeaderboardAroundCurrentUserCallback(GetLeaderboardAroundCurrentUserResult result);

		public delegate void GetUserDataCallback(GetUserDataResult result);

		public delegate void GetUserPublisherDataCallback(GetUserDataResult result);

		public delegate void GetUserPublisherReadOnlyDataCallback(GetUserDataResult result);

		public delegate void GetUserReadOnlyDataCallback(GetUserDataResult result);

		public delegate void GetUserStatisticsCallback(GetUserStatisticsResult result);

		public delegate void UpdateUserDataCallback(UpdateUserDataResult result);

		public delegate void UpdateUserPublisherDataCallback(UpdateUserDataResult result);

		public delegate void UpdateUserStatisticsCallback(UpdateUserStatisticsResult result);

		public delegate void GetCatalogItemsCallback(GetCatalogItemsResult result);

		public delegate void GetStoreItemsCallback(GetStoreItemsResult result);

		public delegate void GetTitleDataCallback(GetTitleDataResult result);

		public delegate void GetTitleNewsCallback(GetTitleNewsResult result);

		public delegate void AddUserVirtualCurrencyCallback(ModifyUserVirtualCurrencyResult result);

		public delegate void ConfirmPurchaseCallback(ConfirmPurchaseResult result);

		public delegate void ConsumeItemCallback(ConsumeItemResult result);

		public delegate void GetCharacterInventoryCallback(GetCharacterInventoryResult result);

		public delegate void GetPurchaseCallback(GetPurchaseResult result);

		public delegate void GetUserInventoryCallback(GetUserInventoryResult result);

		public delegate void PayForPurchaseCallback(PayForPurchaseResult result);

		public delegate void PurchaseItemCallback(PurchaseItemResult result);

		public delegate void RedeemCouponCallback(RedeemCouponResult result);

		public delegate void ReportPlayerCallback(ReportPlayerClientResult result);

		public delegate void StartPurchaseCallback(StartPurchaseResult result);

		public delegate void SubtractUserVirtualCurrencyCallback(ModifyUserVirtualCurrencyResult result);

		public delegate void UnlockContainerItemCallback(UnlockContainerItemResult result);

		public delegate void AddFriendCallback(AddFriendResult result);

		public delegate void GetFriendsListCallback(GetFriendsListResult result);

		public delegate void RemoveFriendCallback(RemoveFriendResult result);

		public delegate void SetFriendTagsCallback(SetFriendTagsResult result);

		public delegate void RegisterForIOSPushNotificationCallback(RegisterForIOSPushNotificationResult result);

		public delegate void RestoreIOSPurchasesCallback(RestoreIOSPurchasesResult result);

		public delegate void ValidateIOSReceiptCallback(ValidateIOSReceiptResult result);

		public delegate void GetCurrentGamesCallback(CurrentGamesResult result);

		public delegate void GetGameServerRegionsCallback(GameServerRegionsResult result);

		public delegate void MatchmakeCallback(MatchmakeResult result);

		public delegate void StartGameCallback(StartGameResult result);

		public delegate void AndroidDevicePushNotificationRegistrationCallback(AndroidDevicePushNotificationRegistrationResult result);

		public delegate void ValidateGooglePlayPurchaseCallback(ValidateGooglePlayPurchaseResult result);

		public delegate void LogEventCallback(LogEventResult result);

		public delegate void AddSharedGroupMembersCallback(AddSharedGroupMembersResult result);

		public delegate void CreateSharedGroupCallback(CreateSharedGroupResult result);

		public delegate void GetPublisherDataCallback(GetPublisherDataResult result);

		public delegate void GetSharedGroupDataCallback(GetSharedGroupDataResult result);

		public delegate void RemoveSharedGroupMembersCallback(RemoveSharedGroupMembersResult result);

		public delegate void UpdateSharedGroupDataCallback(UpdateSharedGroupDataResult result);

		public delegate void GetCloudScriptUrlCallback(GetCloudScriptUrlResult result);

		public delegate void RunCloudScriptCallback(RunCloudScriptResult result);

		public delegate void GetContentDownloadUrlCallback(GetContentDownloadUrlResult result);

		public delegate void GetAllUsersCharactersCallback(ListUsersCharactersResult result);

		public delegate void GetCharacterLeaderboardCallback(GetCharacterLeaderboardResult result);

		public delegate void GetLeaderboardAroundCharacterCallback(GetLeaderboardAroundCharacterResult result);

		public delegate void GetLeaderboardForUserCharactersCallback(GetLeaderboardForUsersCharactersResult result);

		public delegate void GrantCharacterToUserCallback(GrantCharacterToUserResult result);

		public delegate void GetCharacterDataCallback(GetCharacterDataResult result);

		public delegate void GetCharacterReadOnlyDataCallback(GetCharacterDataResult result);

		public delegate void UpdateCharacterDataCallback(UpdateCharacterDataResult result);

		public delegate void AcceptTradeCallback(AcceptTradeResponse result);

		public delegate void CancelTradeCallback(CancelTradeResponse result);

		public delegate void GetPlayerTradesCallback(GetPlayerTradesResponse result);

		public delegate void GetTradeStatusCallback(GetTradeStatusResponse result);

		public delegate void OpenTradeCallback(OpenTradeResponse result);

		private static string AuthKey;

		public static void GetPhotonAuthenticationToken(GetPhotonAuthenticationTokenRequest request, GetPhotonAuthenticationTokenCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPhotonAuthenticationTokenResult result = null;
				ResultContainer<GetPhotonAuthenticationTokenResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPhotonAuthenticationToken", data, "X-Authorization", AuthKey, callback);
		}

		public static void LoginWithAndroidDeviceID(LoginWithAndroidDeviceIDRequest request, LoginWithAndroidDeviceIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithAndroidDeviceID", data, null, null, callback);
		}

		public static void LoginWithCustomID(LoginWithCustomIDRequest request, LoginWithCustomIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithCustomID", data, null, null, callback);
		}

		public static void LoginWithEmailAddress(LoginWithEmailAddressRequest request, LoginWithEmailAddressCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithEmailAddress", data, null, null, callback);
		}

		public static void LoginWithFacebook(LoginWithFacebookRequest request, LoginWithFacebookCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithFacebook", data, null, null, callback);
		}

		public static void LoginWithGoogleAccount(LoginWithGoogleAccountRequest request, LoginWithGoogleAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithGoogleAccount", data, null, null, callback);
		}

		public static void LoginWithIOSDeviceID(LoginWithIOSDeviceIDRequest request, LoginWithIOSDeviceIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithIOSDeviceID", data, null, null, callback);
		}

		public static void LoginWithKongregate(LoginWithKongregateRequest request, LoginWithKongregateCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithKongregate", data, null, null, callback);
		}

		public static void LoginWithPlayFab(LoginWithPlayFabRequest request, LoginWithPlayFabCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithPlayFab", data, null, null, callback);
		}

		public static void LoginWithSteam(LoginWithSteamRequest request, LoginWithSteamCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LoginResult result = null;
				ResultContainer<LoginResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LoginWithSteam", data, null, null, callback);
		}

		public static void RegisterPlayFabUser(RegisterPlayFabUserRequest request, RegisterPlayFabUserCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			request.TitleId = PlayFabSettings.TitleId ?? request.TitleId;
			if (request.TitleId == null)
			{
				throw new Exception("Must be have PlayFabSettings.TitleId set to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				RegisterPlayFabUserResult result = null;
				ResultContainer<RegisterPlayFabUserResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					AuthKey = result.SessionTicket ?? AuthKey;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/RegisterPlayFabUser", data, null, null, callback);
		}

		public static void AddUsernamePassword(AddUsernamePasswordRequest request, AddUsernamePasswordCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				AddUsernamePasswordResult result = null;
				ResultContainer<AddUsernamePasswordResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/AddUsernamePassword", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetAccountInfo(GetAccountInfoRequest request, GetAccountInfoCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetAccountInfoResult result = null;
				ResultContainer<GetAccountInfoResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetAccountInfo", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetPlayFabIDsFromFacebookIDs(GetPlayFabIDsFromFacebookIDsRequest request, GetPlayFabIDsFromFacebookIDsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPlayFabIDsFromFacebookIDsResult result = null;
				ResultContainer<GetPlayFabIDsFromFacebookIDsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPlayFabIDsFromFacebookIDs", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetPlayFabIDsFromGameCenterIDs(GetPlayFabIDsFromGameCenterIDsRequest request, GetPlayFabIDsFromGameCenterIDsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPlayFabIDsFromGameCenterIDsResult result = null;
				ResultContainer<GetPlayFabIDsFromGameCenterIDsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPlayFabIDsFromGameCenterIDs", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetPlayFabIDsFromGoogleIDs(GetPlayFabIDsFromGoogleIDsRequest request, GetPlayFabIDsFromGoogleIDsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPlayFabIDsFromGoogleIDsResult result = null;
				ResultContainer<GetPlayFabIDsFromGoogleIDsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPlayFabIDsFromGoogleIDs", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetPlayFabIDsFromSteamIDs(GetPlayFabIDsFromSteamIDsRequest request, GetPlayFabIDsFromSteamIDsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPlayFabIDsFromSteamIDsResult result = null;
				ResultContainer<GetPlayFabIDsFromSteamIDsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPlayFabIDsFromSteamIDs", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetUserCombinedInfo(GetUserCombinedInfoRequest request, GetUserCombinedInfoCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetUserCombinedInfoResult result = null;
				ResultContainer<GetUserCombinedInfoResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetUserCombinedInfo", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkAndroidDeviceID(LinkAndroidDeviceIDRequest request, LinkAndroidDeviceIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkAndroidDeviceIDResult result = null;
				ResultContainer<LinkAndroidDeviceIDResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkAndroidDeviceID", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkCustomID(LinkCustomIDRequest request, LinkCustomIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkCustomIDResult result = null;
				ResultContainer<LinkCustomIDResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkCustomID", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkFacebookAccount(LinkFacebookAccountRequest request, LinkFacebookAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkFacebookAccountResult result = null;
				ResultContainer<LinkFacebookAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkFacebookAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkGameCenterAccount(LinkGameCenterAccountRequest request, LinkGameCenterAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkGameCenterAccountResult result = null;
				ResultContainer<LinkGameCenterAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkGameCenterAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkGoogleAccount(LinkGoogleAccountRequest request, LinkGoogleAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkGoogleAccountResult result = null;
				ResultContainer<LinkGoogleAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkGoogleAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkIOSDeviceID(LinkIOSDeviceIDRequest request, LinkIOSDeviceIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkIOSDeviceIDResult result = null;
				ResultContainer<LinkIOSDeviceIDResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkIOSDeviceID", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkKongregate(LinkKongregateAccountRequest request, LinkKongregateCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkKongregateAccountResult result = null;
				ResultContainer<LinkKongregateAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkKongregate", data, "X-Authorization", AuthKey, callback);
		}

		public static void LinkSteamAccount(LinkSteamAccountRequest request, LinkSteamAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LinkSteamAccountResult result = null;
				ResultContainer<LinkSteamAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LinkSteamAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void SendAccountRecoveryEmail(SendAccountRecoveryEmailRequest request, SendAccountRecoveryEmailCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				SendAccountRecoveryEmailResult result = null;
				ResultContainer<SendAccountRecoveryEmailResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/SendAccountRecoveryEmail", data, null, null, callback);
		}

		public static void UnlinkAndroidDeviceID(UnlinkAndroidDeviceIDRequest request, UnlinkAndroidDeviceIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkAndroidDeviceIDResult result = null;
				ResultContainer<UnlinkAndroidDeviceIDResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkAndroidDeviceID", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlinkCustomID(UnlinkCustomIDRequest request, UnlinkCustomIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkCustomIDResult result = null;
				ResultContainer<UnlinkCustomIDResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkCustomID", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlinkFacebookAccount(UnlinkFacebookAccountRequest request, UnlinkFacebookAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkFacebookAccountResult result = null;
				ResultContainer<UnlinkFacebookAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkFacebookAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlinkGameCenterAccount(UnlinkGameCenterAccountRequest request, UnlinkGameCenterAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkGameCenterAccountResult result = null;
				ResultContainer<UnlinkGameCenterAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkGameCenterAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlinkGoogleAccount(UnlinkGoogleAccountRequest request, UnlinkGoogleAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkGoogleAccountResult result = null;
				ResultContainer<UnlinkGoogleAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkGoogleAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlinkIOSDeviceID(UnlinkIOSDeviceIDRequest request, UnlinkIOSDeviceIDCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkIOSDeviceIDResult result = null;
				ResultContainer<UnlinkIOSDeviceIDResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkIOSDeviceID", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlinkKongregate(UnlinkKongregateAccountRequest request, UnlinkKongregateCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkKongregateAccountResult result = null;
				ResultContainer<UnlinkKongregateAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkKongregate", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlinkSteamAccount(UnlinkSteamAccountRequest request, UnlinkSteamAccountCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlinkSteamAccountResult result = null;
				ResultContainer<UnlinkSteamAccountResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlinkSteamAccount", data, "X-Authorization", AuthKey, callback);
		}

		public static void UpdateUserTitleDisplayName(UpdateUserTitleDisplayNameRequest request, UpdateUserTitleDisplayNameCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UpdateUserTitleDisplayNameResult result = null;
				ResultContainer<UpdateUserTitleDisplayNameResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UpdateUserTitleDisplayName", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetFriendLeaderboard(GetFriendLeaderboardRequest request, GetFriendLeaderboardCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetLeaderboardResult result = null;
				ResultContainer<GetLeaderboardResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetFriendLeaderboard", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetLeaderboard(GetLeaderboardRequest request, GetLeaderboardCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetLeaderboardResult result = null;
				ResultContainer<GetLeaderboardResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetLeaderboard", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetLeaderboardAroundCurrentUser(GetLeaderboardAroundCurrentUserRequest request, GetLeaderboardAroundCurrentUserCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetLeaderboardAroundCurrentUserResult result = null;
				ResultContainer<GetLeaderboardAroundCurrentUserResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetLeaderboardAroundCurrentUser", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetUserData(GetUserDataRequest request, GetUserDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetUserDataResult result = null;
				ResultContainer<GetUserDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetUserData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetUserPublisherData(GetUserDataRequest request, GetUserPublisherDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetUserDataResult result = null;
				ResultContainer<GetUserDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetUserPublisherData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetUserPublisherReadOnlyData(GetUserDataRequest request, GetUserPublisherReadOnlyDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetUserDataResult result = null;
				ResultContainer<GetUserDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetUserPublisherReadOnlyData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetUserReadOnlyData(GetUserDataRequest request, GetUserReadOnlyDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetUserDataResult result = null;
				ResultContainer<GetUserDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetUserReadOnlyData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetUserStatistics(GetUserStatisticsRequest request, GetUserStatisticsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetUserStatisticsResult result = null;
				ResultContainer<GetUserStatisticsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetUserStatistics", data, "X-Authorization", AuthKey, callback);
		}

		public static void UpdateUserData(UpdateUserDataRequest request, UpdateUserDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UpdateUserDataResult result = null;
				ResultContainer<UpdateUserDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UpdateUserData", data, "X-Authorization", AuthKey, callback);
		}

		public static void UpdateUserPublisherData(UpdateUserDataRequest request, UpdateUserPublisherDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UpdateUserDataResult result = null;
				ResultContainer<UpdateUserDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UpdateUserPublisherData", data, "X-Authorization", AuthKey, callback);
		}

		public static void UpdateUserStatistics(UpdateUserStatisticsRequest request, UpdateUserStatisticsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UpdateUserStatisticsResult result = null;
				ResultContainer<UpdateUserStatisticsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UpdateUserStatistics", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetCatalogItems(GetCatalogItemsRequest request, GetCatalogItemsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetCatalogItemsResult result = null;
				ResultContainer<GetCatalogItemsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetCatalogItems", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetStoreItems(GetStoreItemsRequest request, GetStoreItemsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetStoreItemsResult result = null;
				ResultContainer<GetStoreItemsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetStoreItems", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetTitleData(GetTitleDataRequest request, GetTitleDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetTitleDataResult result = null;
				ResultContainer<GetTitleDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetTitleData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetTitleNews(GetTitleNewsRequest request, GetTitleNewsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetTitleNewsResult result = null;
				ResultContainer<GetTitleNewsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetTitleNews", data, "X-Authorization", AuthKey, callback);
		}

		public static void AddUserVirtualCurrency(AddUserVirtualCurrencyRequest request, AddUserVirtualCurrencyCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ModifyUserVirtualCurrencyResult result = null;
				ResultContainer<ModifyUserVirtualCurrencyResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/AddUserVirtualCurrency", data, "X-Authorization", AuthKey, callback);
		}

		public static void ConfirmPurchase(ConfirmPurchaseRequest request, ConfirmPurchaseCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ConfirmPurchaseResult result = null;
				ResultContainer<ConfirmPurchaseResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/ConfirmPurchase", data, "X-Authorization", AuthKey, callback);
		}

		public static void ConsumeItem(ConsumeItemRequest request, ConsumeItemCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ConsumeItemResult result = null;
				ResultContainer<ConsumeItemResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/ConsumeItem", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetCharacterInventory(GetCharacterInventoryRequest request, GetCharacterInventoryCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetCharacterInventoryResult result = null;
				ResultContainer<GetCharacterInventoryResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetCharacterInventory", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetPurchase(GetPurchaseRequest request, GetPurchaseCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPurchaseResult result = null;
				ResultContainer<GetPurchaseResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPurchase", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetUserInventory(GetUserInventoryRequest request, GetUserInventoryCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetUserInventoryResult result = null;
				ResultContainer<GetUserInventoryResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetUserInventory", data, "X-Authorization", AuthKey, callback);
		}

		public static void PayForPurchase(PayForPurchaseRequest request, PayForPurchaseCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				PayForPurchaseResult result = null;
				ResultContainer<PayForPurchaseResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/PayForPurchase", data, "X-Authorization", AuthKey, callback);
		}

		public static void PurchaseItem(PurchaseItemRequest request, PurchaseItemCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				PurchaseItemResult result = null;
				ResultContainer<PurchaseItemResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/PurchaseItem", data, "X-Authorization", AuthKey, callback);
		}

		public static void RedeemCoupon(RedeemCouponRequest request, RedeemCouponCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				RedeemCouponResult result = null;
				ResultContainer<RedeemCouponResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/RedeemCoupon", data, "X-Authorization", AuthKey, callback);
		}

		public static void ReportPlayer(ReportPlayerClientRequest request, ReportPlayerCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ReportPlayerClientResult result = null;
				ResultContainer<ReportPlayerClientResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/ReportPlayer", data, "X-Authorization", AuthKey, callback);
		}

		public static void StartPurchase(StartPurchaseRequest request, StartPurchaseCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				StartPurchaseResult result = null;
				ResultContainer<StartPurchaseResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/StartPurchase", data, "X-Authorization", AuthKey, callback);
		}

		public static void SubtractUserVirtualCurrency(SubtractUserVirtualCurrencyRequest request, SubtractUserVirtualCurrencyCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ModifyUserVirtualCurrencyResult result = null;
				ResultContainer<ModifyUserVirtualCurrencyResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/SubtractUserVirtualCurrency", data, "X-Authorization", AuthKey, callback);
		}

		public static void UnlockContainerItem(UnlockContainerItemRequest request, UnlockContainerItemCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UnlockContainerItemResult result = null;
				ResultContainer<UnlockContainerItemResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UnlockContainerItem", data, "X-Authorization", AuthKey, callback);
		}

		public static void AddFriend(AddFriendRequest request, AddFriendCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				AddFriendResult result = null;
				ResultContainer<AddFriendResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/AddFriend", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetFriendsList(GetFriendsListRequest request, GetFriendsListCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetFriendsListResult result = null;
				ResultContainer<GetFriendsListResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetFriendsList", data, "X-Authorization", AuthKey, callback);
		}

		public static void RemoveFriend(RemoveFriendRequest request, RemoveFriendCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				RemoveFriendResult result = null;
				ResultContainer<RemoveFriendResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/RemoveFriend", data, "X-Authorization", AuthKey, callback);
		}

		public static void SetFriendTags(SetFriendTagsRequest request, SetFriendTagsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				SetFriendTagsResult result = null;
				ResultContainer<SetFriendTagsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/SetFriendTags", data, "X-Authorization", AuthKey, callback);
		}

		public static void RegisterForIOSPushNotification(RegisterForIOSPushNotificationRequest request, RegisterForIOSPushNotificationCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				RegisterForIOSPushNotificationResult result = null;
				ResultContainer<RegisterForIOSPushNotificationResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/RegisterForIOSPushNotification", data, "X-Authorization", AuthKey, callback);
		}

		public static void RestoreIOSPurchases(RestoreIOSPurchasesRequest request, RestoreIOSPurchasesCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				RestoreIOSPurchasesResult result = null;
				ResultContainer<RestoreIOSPurchasesResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/RestoreIOSPurchases", data, "X-Authorization", AuthKey, callback);
		}

		public static void ValidateIOSReceipt(ValidateIOSReceiptRequest request, ValidateIOSReceiptCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ValidateIOSReceiptResult result = null;
				ResultContainer<ValidateIOSReceiptResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/ValidateIOSReceipt", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetCurrentGames(CurrentGamesRequest request, GetCurrentGamesCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				CurrentGamesResult result = null;
				ResultContainer<CurrentGamesResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetCurrentGames", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetGameServerRegions(GameServerRegionsRequest request, GetGameServerRegionsCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GameServerRegionsResult result = null;
				ResultContainer<GameServerRegionsResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetGameServerRegions", data, "X-Authorization", AuthKey, callback);
		}

		public static void Matchmake(MatchmakeRequest request, MatchmakeCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				MatchmakeResult result = null;
				ResultContainer<MatchmakeResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/Matchmake", data, "X-Authorization", AuthKey, callback);
		}

		public static void StartGame(StartGameRequest request, StartGameCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				StartGameResult result = null;
				ResultContainer<StartGameResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/StartGame", data, "X-Authorization", AuthKey, callback);
		}

		public static void AndroidDevicePushNotificationRegistration(AndroidDevicePushNotificationRegistrationRequest request, AndroidDevicePushNotificationRegistrationCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				AndroidDevicePushNotificationRegistrationResult result = null;
				ResultContainer<AndroidDevicePushNotificationRegistrationResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/AndroidDevicePushNotificationRegistration", data, "X-Authorization", AuthKey, callback);
		}

		public static void ValidateGooglePlayPurchase(ValidateGooglePlayPurchaseRequest request, ValidateGooglePlayPurchaseCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ValidateGooglePlayPurchaseResult result = null;
				ResultContainer<ValidateGooglePlayPurchaseResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/ValidateGooglePlayPurchase", data, "X-Authorization", AuthKey, callback);
		}

		public static void LogEvent(LogEventRequest request, LogEventCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				LogEventResult result = null;
				ResultContainer<LogEventResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/LogEvent", data, "X-Authorization", AuthKey, callback);
		}

		public static void AddSharedGroupMembers(AddSharedGroupMembersRequest request, AddSharedGroupMembersCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				AddSharedGroupMembersResult result = null;
				ResultContainer<AddSharedGroupMembersResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/AddSharedGroupMembers", data, "X-Authorization", AuthKey, callback);
		}

		public static void CreateSharedGroup(CreateSharedGroupRequest request, CreateSharedGroupCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				CreateSharedGroupResult result = null;
				ResultContainer<CreateSharedGroupResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/CreateSharedGroup", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetPublisherData(GetPublisherDataRequest request, GetPublisherDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPublisherDataResult result = null;
				ResultContainer<GetPublisherDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPublisherData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetSharedGroupData(GetSharedGroupDataRequest request, GetSharedGroupDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetSharedGroupDataResult result = null;
				ResultContainer<GetSharedGroupDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetSharedGroupData", data, "X-Authorization", AuthKey, callback);
		}

		public static void RemoveSharedGroupMembers(RemoveSharedGroupMembersRequest request, RemoveSharedGroupMembersCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				RemoveSharedGroupMembersResult result = null;
				ResultContainer<RemoveSharedGroupMembersResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/RemoveSharedGroupMembers", data, "X-Authorization", AuthKey, callback);
		}

		public static void UpdateSharedGroupData(UpdateSharedGroupDataRequest request, UpdateSharedGroupDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UpdateSharedGroupDataResult result = null;
				ResultContainer<UpdateSharedGroupDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UpdateSharedGroupData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetCloudScriptUrl(GetCloudScriptUrlRequest request, GetCloudScriptUrlCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetCloudScriptUrlResult result = null;
				ResultContainer<GetCloudScriptUrlResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					PlayFabSettings.LogicServerURL = result.Url;
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetCloudScriptUrl", data, "X-Authorization", AuthKey, callback);
		}

		public static void RunCloudScript(RunCloudScriptRequest request, RunCloudScriptCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				RunCloudScriptResult result = null;
				ResultContainer<RunCloudScriptResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetLogicURL() + "/Client/RunCloudScript", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetContentDownloadUrl(GetContentDownloadUrlRequest request, GetContentDownloadUrlCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetContentDownloadUrlResult result = null;
				ResultContainer<GetContentDownloadUrlResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetContentDownloadUrl", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetAllUsersCharacters(ListUsersCharactersRequest request, GetAllUsersCharactersCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				ListUsersCharactersResult result = null;
				ResultContainer<ListUsersCharactersResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetAllUsersCharacters", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetCharacterLeaderboard(GetCharacterLeaderboardRequest request, GetCharacterLeaderboardCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetCharacterLeaderboardResult result = null;
				ResultContainer<GetCharacterLeaderboardResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetCharacterLeaderboard", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetLeaderboardAroundCharacter(GetLeaderboardAroundCharacterRequest request, GetLeaderboardAroundCharacterCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetLeaderboardAroundCharacterResult result = null;
				ResultContainer<GetLeaderboardAroundCharacterResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetLeaderboardAroundCharacter", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetLeaderboardForUserCharacters(GetLeaderboardForUsersCharactersRequest request, GetLeaderboardForUserCharactersCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetLeaderboardForUsersCharactersResult result = null;
				ResultContainer<GetLeaderboardForUsersCharactersResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetLeaderboardForUserCharacters", data, "X-Authorization", AuthKey, callback);
		}

		public static void GrantCharacterToUser(GrantCharacterToUserRequest request, GrantCharacterToUserCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GrantCharacterToUserResult result = null;
				ResultContainer<GrantCharacterToUserResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GrantCharacterToUser", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetCharacterData(GetCharacterDataRequest request, GetCharacterDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetCharacterDataResult result = null;
				ResultContainer<GetCharacterDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetCharacterData", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetCharacterReadOnlyData(GetCharacterDataRequest request, GetCharacterReadOnlyDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetCharacterDataResult result = null;
				ResultContainer<GetCharacterDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetCharacterReadOnlyData", data, "X-Authorization", AuthKey, callback);
		}

		public static void UpdateCharacterData(UpdateCharacterDataRequest request, UpdateCharacterDataCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				UpdateCharacterDataResult result = null;
				ResultContainer<UpdateCharacterDataResult>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/UpdateCharacterData", data, "X-Authorization", AuthKey, callback);
		}

		public static void AcceptTrade(AcceptTradeRequest request, AcceptTradeCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				AcceptTradeResponse result = null;
				ResultContainer<AcceptTradeResponse>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/AcceptTrade", data, "X-Authorization", AuthKey, callback);
		}

		public static void CancelTrade(CancelTradeRequest request, CancelTradeCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				CancelTradeResponse result = null;
				ResultContainer<CancelTradeResponse>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/CancelTrade", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetPlayerTrades(GetPlayerTradesRequest request, GetPlayerTradesCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetPlayerTradesResponse result = null;
				ResultContainer<GetPlayerTradesResponse>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetPlayerTrades", data, "X-Authorization", AuthKey, callback);
		}

		public static void GetTradeStatus(GetTradeStatusRequest request, GetTradeStatusCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				GetTradeStatusResponse result = null;
				ResultContainer<GetTradeStatusResponse>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/GetTradeStatus", data, "X-Authorization", AuthKey, callback);
		}

		public static void OpenTrade(OpenTradeRequest request, OpenTradeCallback resultCallback, ErrorCallback errorCallback, object customData = null)
		{
			if (AuthKey == null)
			{
				throw new Exception("Must be logged in to call this method");
			}
			string data = JsonConvert.SerializeObject(request, Util.JsonFormatting, Util.JsonSettings);
			Action<string, PlayFabError> callback = delegate(string responseStr, PlayFabError pfError)
			{
				OpenTradeResponse result = null;
				ResultContainer<OpenTradeResponse>.HandleResults(responseStr, ref pfError, out result);
				if (pfError != null && errorCallback != null)
				{
					errorCallback(pfError);
				}
				if (result != null)
				{
					result.CustomData = customData;
					result.Request = request;
					if (resultCallback != null)
					{
						resultCallback(result);
					}
				}
			};
			PlayFabHTTP.Post(PlayFabSettings.GetURL() + "/Client/OpenTrade", data, "X-Authorization", AuthKey, callback);
		}

		public static bool IsClientLoggedIn()
		{
			return !string.IsNullOrEmpty(AuthKey);
		}
	}
}
namespace PlayFab.ClientModels
{
	public class AcceptTradeRequest
	{
		public string OfferingPlayerId { get; set; }

		public string TradeId { get; set; }

		public List<string> AcceptedInventoryInstanceIds { get; set; }
	}
	public class AcceptTradeResponse
	{
		public TradeInfo Trade { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class AddFriendRequest
	{
		public string FriendPlayFabId { get; set; }

		public string FriendUsername { get; set; }

		public string FriendEmail { get; set; }

		public string FriendTitleDisplayName { get; set; }
	}
	public class AddFriendResult
	{
		public bool Created { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class AddSharedGroupMembersRequest
	{
		public string SharedGroupId { get; set; }

		public List<string> PlayFabIds { get; set; }
	}
	public class AddSharedGroupMembersResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class AddUsernamePasswordRequest
	{
		public string Username { get; set; }

		public string Email { get; set; }

		public string Password { get; set; }
	}
	public class AddUsernamePasswordResult
	{
		public string Username { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class AddUserVirtualCurrencyRequest
	{
		public string VirtualCurrency { get; set; }

		public int Amount { get; set; }
	}
	public class AndroidDevicePushNotificationRegistrationRequest
	{
		public string DeviceToken { get; set; }

		public bool? SendPushNotificationConfirmation { get; set; }

		public string ConfirmationMessege { get; set; }
	}
	public class AndroidDevicePushNotificationRegistrationResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class CancelTradeRequest
	{
		public string TradeId { get; set; }
	}
	public class CancelTradeResponse
	{
		public TradeInfo Trade { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class CartItem
	{
		public string ItemId { get; set; }

		public string ItemClass { get; set; }

		public string ItemInstanceId { get; set; }

		public string DisplayName { get; set; }

		public string Description { get; set; }

		public Dictionary<string, uint> VirtualCurrencyPrices { get; set; }

		public Dictionary<string, uint> RealCurrencyPrices { get; set; }

		public Dictionary<string, uint> VCAmount { get; set; }
	}
	public class CatalogItem
	{
		public string ItemId { get; set; }

		public string ItemClass { get; set; }

		public string CatalogVersion { get; set; }

		public string DisplayName { get; set; }

		public string Description { get; set; }

		public Dictionary<string, uint> VirtualCurrencyPrices { get; set; }

		public Dictionary<string, uint> RealCurrencyPrices { get; set; }

		public List<string> Tags { get; set; }

		public string CustomData { get; set; }

		public CatalogItemConsumableInfo Consumable { get; set; }

		public CatalogItemContainerInfo Container { get; set; }

		public CatalogItemBundleInfo Bundle { get; set; }

		public bool CanBecomeCharacter { get; set; }

		public bool IsStackable { get; set; }

		public bool IsTradable { get; set; }

		public string ItemImageUrl { get; set; }
	}
	public class CatalogItemBundleInfo
	{
		public List<string> BundledItems { get; set; }

		public List<string> BundledResultTables { get; set; }

		public Dictionary<string, uint> BundledVirtualCurrencies { get; set; }
	}
	public class CatalogItemConsumableInfo
	{
		public uint? UsageCount { get; set; }

		public uint? UsagePeriod { get; set; }

		public string UsagePeriodGroup { get; set; }
	}
	public class CatalogItemContainerInfo
	{
		public string KeyItemId { get; set; }

		public List<string> ItemContents { get; set; }

		public List<string> ResultTableContents { get; set; }

		public Dictionary<string, uint> VirtualCurrencyContents { get; set; }
	}
	public class CharacterLeaderboardEntry
	{
		public string PlayFabId { get; set; }

		public string CharacterId { get; set; }

		public string CharacterName { get; set; }

		public string DisplayName { get; set; }

		public string CharacterType { get; set; }

		public int StatValue { get; set; }

		public int Position { get; set; }
	}
	public class CharacterResult
	{
		public string CharacterId { get; set; }

		public string CharacterName { get; set; }

		public string CharacterType { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ConfirmPurchaseRequest
	{
		public string OrderId { get; set; }
	}
	public class ConfirmPurchaseResult
	{
		public string OrderId { get; set; }

		public DateTime PurchaseDate { get; set; }

		public List<ItemInstance> Items { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ConsumeItemRequest
	{
		public string ItemInstanceId { get; set; }

		public int ConsumeCount { get; set; }

		public string CharacterId { get; set; }
	}
	public class ConsumeItemResult
	{
		public string ItemInstanceId { get; set; }

		public int RemainingUses { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ConsumePSNEntitlementsRequest
	{
		public string CatalogVersion { get; set; }

		public int ServiceLabel { get; set; }
	}
	public class ConsumePSNEntitlementsResult
	{
		public List<ItemInstance> ItemsGranted { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class CreateSharedGroupRequest
	{
		public string SharedGroupId { get; set; }
	}
	public class CreateSharedGroupResult
	{
		public string SharedGroupId { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public enum Currency
	{
		AED,
		AFN,
		ALL,
		AMD,
		ANG,
		AOA,
		ARS,
		AUD,
		AWG,
		AZN,
		BAM,
		BBD,
		BDT,
		BGN,
		BHD,
		BIF,
		BMD,
		BND,
		BOB,
		BRL,
		BSD,
		BTN,
		BWP,
		BYR,
		BZD,
		CAD,
		CDF,
		CHF,
		CLP,
		CNY,
		COP,
		CRC,
		CUC,
		CUP,
		CVE,
		CZK,
		DJF,
		DKK,
		DOP,
		DZD,
		EGP,
		ERN,
		ETB,
		EUR,
		FJD,
		FKP,
		GBP,
		GEL,
		GGP,
		GHS,
		GIP,
		GMD,
		GNF,
		GTQ,
		GYD,
		HKD,
		HNL,
		HRK,
		HTG,
		HUF,
		IDR,
		ILS,
		IMP,
		INR,
		IQD,
		IRR,
		ISK,
		JEP,
		JMD,
		JOD,
		JPY,
		KES,
		KGS,
		KHR,
		KMF,
		KPW,
		KRW,
		KWD,
		KYD,
		KZT,
		LAK,
		LBP,
		LKR,
		LRD,
		LSL,
		LYD,
		MAD,
		MDL,
		MGA,
		MKD,
		MMK,
		MNT,
		MOP,
		MRO,
		MUR,
		MVR,
		MWK,
		MXN,
		MYR,
		MZN,
		NAD,
		NGN,
		NIO,
		NOK,
		NPR,
		NZD,
		OMR,
		PAB,
		PEN,
		PGK,
		PHP,
		PKR,
		PLN,
		PYG,
		QAR,
		RON,
		RSD,
		RUB,
		RWF,
		SAR,
		SBD,
		SCR,
		SDG,
		SEK,
		SGD,
		SHP,
		SLL,
		SOS,
		SPL,
		SRD,
		STD,
		SVC,
		SYP,
		SZL,
		THB,
		TJS,
		TMT,
		TND,
		TOP,
		TRY,
		TTD,
		TVD,
		TWD,
		TZS,
		UAH,
		UGX,
		USD,
		UYU,
		UZS,
		VEF,
		VND,
		VUV,
		WST,
		XAF,
		XCD,
		XDR,
		XOF,
		XPF,
		YER,
		ZAR,
		ZMW,
		ZWD
	}
	public class CurrentGamesRequest
	{
		public Region? Region { get; set; }

		public string BuildVersion { get; set; }

		public string GameMode { get; set; }

		public string StatisticName { get; set; }
	}
	public class CurrentGamesResult
	{
		public List<GameInfo> Games { get; set; }

		public int PlayerCount { get; set; }

		public int GameCount { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class EmptyResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class FacebookPlayFabIdPair
	{
		public string FacebookId { get; set; }

		public string PlayFabId { get; set; }
	}
	public class FriendInfo
	{
		public string FriendPlayFabId { get; set; }

		public string Username { get; set; }

		public string TitleDisplayName { get; set; }

		public List<string> Tags { get; set; }

		public string CurrentMatchmakerLobbyId { get; set; }

		public UserFacebookInfo FacebookInfo { get; set; }

		public UserSteamInfo SteamInfo { get; set; }

		public UserGameCenterInfo GameCenterInfo { get; set; }
	}
	public class GameCenterPlayFabIdPair
	{
		public string GameCenterId { get; set; }

		public string PlayFabId { get; set; }
	}
	public class GameInfo
	{
		public Region? Region { get; set; }

		public string LobbyID { get; set; }

		public string BuildVersion { get; set; }

		public string GameMode { get; set; }

		public string StatisticName { get; set; }

		public int? MaxPlayers { get; set; }

		public List<string> PlayerUserIds { get; set; }

		public uint RunTime { get; set; }

		public string GameServerState { get; set; }
	}
	public class GameServerRegionsRequest
	{
		public string BuildVersion { get; set; }

		public string TitleId { get; set; }
	}
	public class GameServerRegionsResult
	{
		public List<RegionInfo> Regions { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetAccountInfoRequest
	{
		public string PlayFabId { get; set; }

		public string Username { get; set; }

		public string Email { get; set; }

		public string TitleDisplayName { get; set; }
	}
	public class GetAccountInfoResult
	{
		public UserAccountInfo AccountInfo { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetCatalogItemsRequest
	{
		public string CatalogVersion { get; set; }
	}
	public class GetCatalogItemsResult
	{
		public List<CatalogItem> Catalog { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetCharacterDataRequest
	{
		public string PlayFabId { get; set; }

		public string CharacterId { get; set; }

		public List<string> Keys { get; set; }

		public int? IfChangedFromDataVersion { get; set; }
	}
	public class GetCharacterDataResult
	{
		public string CharacterId { get; set; }

		public Dictionary<string, UserDataRecord> Data { get; set; }

		public uint DataVersion { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetCharacterInventoryRequest
	{
		public string PlayFabId { get; set; }

		public string CharacterId { get; set; }

		public string CatalogVersion { get; set; }
	}
	public class GetCharacterInventoryResult
	{
		public string PlayFabId { get; set; }

		public string CharacterId { get; set; }

		public List<ItemInstance> Inventory { get; set; }

		public Dictionary<string, int> VirtualCurrency { get; set; }

		public Dictionary<string, VirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetCharacterLeaderboardRequest
	{
		public string CharacterType { get; set; }

		public string StatisticName { get; set; }

		public int StartPosition { get; set; }

		public int MaxResultsCount { get; set; }
	}
	public class GetCharacterLeaderboardResult
	{
		public List<CharacterLeaderboardEntry> Leaderboard { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetCloudScriptUrlRequest
	{
		public int? Version { get; set; }

		public bool? Testing { get; set; }
	}
	public class GetCloudScriptUrlResult
	{
		public string Url { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetContentDownloadUrlRequest
	{
		public string Key { get; set; }

		public string HttpMethod { get; set; }

		public bool? ThruCDN { get; set; }
	}
	public class GetContentDownloadUrlResult
	{
		public string URL { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetFriendLeaderboardRequest
	{
		public string StatisticName { get; set; }

		public int StartPosition { get; set; }

		public int MaxResultsCount { get; set; }

		public bool? IncludeSteamFriends { get; set; }

		public bool? IncludeFacebookFriends { get; set; }
	}
	public class GetFriendsListRequest
	{
		public bool? IncludeSteamFriends { get; set; }

		public bool? IncludeFacebookFriends { get; set; }
	}
	public class GetFriendsListResult
	{
		public List<FriendInfo> Friends { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetLeaderboardAroundCharacterRequest
	{
		public string StatisticName { get; set; }

		public string CharacterId { get; set; }

		public string CharacterType { get; set; }

		public int MaxResultsCount { get; set; }
	}
	public class GetLeaderboardAroundCharacterResult
	{
		public List<CharacterLeaderboardEntry> Leaderboard { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetLeaderboardAroundCurrentUserRequest
	{
		public string StatisticName { get; set; }

		public int MaxResultsCount { get; set; }
	}
	public class GetLeaderboardAroundCurrentUserResult
	{
		public List<PlayerLeaderboardEntry> Leaderboard { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetLeaderboardForUsersCharactersRequest
	{
		public string StatisticName { get; set; }

		public int MaxResultsCount { get; set; }
	}
	public class GetLeaderboardForUsersCharactersResult
	{
		public List<CharacterLeaderboardEntry> Leaderboard { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetLeaderboardRequest
	{
		public string StatisticName { get; set; }

		public int StartPosition { get; set; }

		public int MaxResultsCount { get; set; }
	}
	public class GetLeaderboardResult
	{
		public List<PlayerLeaderboardEntry> Leaderboard { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPhotonAuthenticationTokenRequest
	{
		public string PhotonApplicationId { get; set; }
	}
	public class GetPhotonAuthenticationTokenResult
	{
		public string PhotonCustomAuthenticationToken { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPlayerTradesRequest
	{
		public TradeStatus? StatusFilter { get; set; }
	}
	public class GetPlayerTradesResponse
	{
		public List<TradeInfo> OpenedTrades { get; set; }

		public List<TradeInfo> AcceptedTrades { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPlayFabIDsFromFacebookIDsRequest
	{
		public List<string> FacebookIDs { get; set; }
	}
	public class GetPlayFabIDsFromFacebookIDsResult
	{
		public List<FacebookPlayFabIdPair> Data { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPlayFabIDsFromGameCenterIDsRequest
	{
		public List<string> GameCenterIDs { get; set; }
	}
	public class GetPlayFabIDsFromGameCenterIDsResult
	{
		public List<GameCenterPlayFabIdPair> Data { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPlayFabIDsFromGoogleIDsRequest
	{
		public List<string> GoogleIDs { get; set; }
	}
	public class GetPlayFabIDsFromGoogleIDsResult
	{
		public List<GooglePlayFabIdPair> Data { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPlayFabIDsFromPSNAccountIDsRequest
	{
		public List<string> PSNAccountIDs { get; set; }

		public int? IssuerId { get; set; }
	}
	public class GetPlayFabIDsFromPSNAccountIDsResult
	{
		public List<PSNAccountPlayFabIdPair> Data { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPlayFabIDsFromSteamIDsRequest
	{
		public List<ulong> SteamIDs { get; set; }
	}
	public class GetPlayFabIDsFromSteamIDsResult
	{
		public List<SteamPlayFabIdPair> Data { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPublisherDataRequest
	{
		public List<string> Keys { get; set; }
	}
	public class GetPublisherDataResult
	{
		public Dictionary<string, string> Data { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetPurchaseRequest
	{
		public string OrderId { get; set; }
	}
	public class GetPurchaseResult
	{
		public string OrderId { get; set; }

		public string PaymentProvider { get; set; }

		public string TransactionId { get; set; }

		public string TransactionStatus { get; set; }

		public DateTime PurchaseDate { get; set; }

		public List<ItemInstance> Items { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetSharedGroupDataRequest
	{
		public string SharedGroupId { get; set; }

		public List<string> Keys { get; set; }

		public bool? GetMembers { get; set; }
	}
	public class GetSharedGroupDataResult
	{
		public Dictionary<string, SharedGroupDataRecord> Data { get; set; }

		public List<string> Members { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetStoreItemsRequest
	{
		public string StoreId { get; set; }

		public string CatalogVersion { get; set; }
	}
	public class GetStoreItemsResult
	{
		public List<StoreItem> Store { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetTitleDataRequest
	{
		public List<string> Keys { get; set; }
	}
	public class GetTitleDataResult
	{
		public Dictionary<string, string> Data { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetTitleNewsRequest
	{
		public int? Count { get; set; }
	}
	public class GetTitleNewsResult
	{
		public List<TitleNewsItem> News { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetTradeStatusRequest
	{
		public string OfferingPlayerId { get; set; }

		public string TradeId { get; set; }
	}
	public class GetTradeStatusResponse
	{
		public TradeInfo Trade { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetUserCombinedInfoRequest
	{
		public string PlayFabId { get; set; }

		public string Username { get; set; }

		public string Email { get; set; }

		public string TitleDisplayName { get; set; }

		public bool? GetAccountInfo { get; set; }

		public bool? GetInventory { get; set; }

		public bool? GetVirtualCurrency { get; set; }

		public bool? GetUserData { get; set; }

		public List<string> UserDataKeys { get; set; }

		public bool? GetReadOnlyData { get; set; }

		public List<string> ReadOnlyDataKeys { get; set; }
	}
	public class GetUserCombinedInfoResult
	{
		public string PlayFabId { get; set; }

		public UserAccountInfo AccountInfo { get; set; }

		public List<ItemInstance> Inventory { get; set; }

		public Dictionary<string, int> VirtualCurrency { get; set; }

		public Dictionary<string, VirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes { get; set; }

		public Dictionary<string, UserDataRecord> Data { get; set; }

		public uint DataVersion { get; set; }

		public Dictionary<string, UserDataRecord> ReadOnlyData { get; set; }

		public uint ReadOnlyDataVersion { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetUserDataRequest
	{
		public List<string> Keys { get; set; }

		public string PlayFabId { get; set; }

		public int? IfChangedFromDataVersion { get; set; }
	}
	public class GetUserDataResult
	{
		public Dictionary<string, UserDataRecord> Data { get; set; }

		public uint DataVersion { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetUserInventoryRequest
	{
	}
	public class GetUserInventoryResult
	{
		public List<ItemInstance> Inventory { get; set; }

		public Dictionary<string, int> VirtualCurrency { get; set; }

		public Dictionary<string, VirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GetUserStatisticsRequest
	{
	}
	public class GetUserStatisticsResult
	{
		public Dictionary<string, int> UserStatistics { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class GooglePlayFabIdPair
	{
		public string GoogleId { get; set; }

		public string PlayFabId { get; set; }
	}
	public class GrantCharacterToUserRequest
	{
		public string CatalogVersion { get; set; }

		public string ItemId { get; set; }

		public string CharacterName { get; set; }
	}
	public class GrantCharacterToUserResult
	{
		public string CharacterId { get; set; }

		public string CharacterType { get; set; }

		public bool Result { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ItemInstance
	{
		public string ItemId { get; set; }

		public string ItemInstanceId { get; set; }

		public string ItemClass { get; set; }

		public DateTime? PurchaseDate { get; set; }

		public DateTime? Expiration { get; set; }

		public int? RemainingUses { get; set; }

		public int? UsesIncrementedBy { get; set; }

		public string Annotation { get; set; }

		public string CatalogVersion { get; set; }

		public string BundleParent { get; set; }

		public string DisplayName { get; set; }

		public string UnitCurrency { get; set; }

		public uint UnitPrice { get; set; }

		public List<string> BundleContents { get; set; }

		public Dictionary<string, string> CustomData { get; set; }
	}
	public class ItemPuchaseRequest
	{
		public string ItemId { get; set; }

		public uint Quantity { get; set; }

		public string Annotation { get; set; }

		public List<string> UpgradeFromItems { get; set; }
	}
	public class LinkAndroidDeviceIDRequest
	{
		public string AndroidDeviceId { get; set; }

		public string OS { get; set; }

		public string AndroidDevice { get; set; }
	}
	public class LinkAndroidDeviceIDResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkCustomIDRequest
	{
		public string CustomId { get; set; }
	}
	public class LinkCustomIDResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkFacebookAccountRequest
	{
		public string AccessToken { get; set; }

		public bool? ForceLink { get; set; }
	}
	public class LinkFacebookAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkGameCenterAccountRequest
	{
		public string GameCenterId { get; set; }
	}
	public class LinkGameCenterAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkGoogleAccountRequest
	{
		public string AccessToken { get; set; }
	}
	public class LinkGoogleAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkIOSDeviceIDRequest
	{
		public string DeviceId { get; set; }

		public string OS { get; set; }

		public string DeviceModel { get; set; }
	}
	public class LinkIOSDeviceIDResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkKongregateAccountRequest
	{
		public string KongregateId { get; set; }

		public string AuthTicket { get; set; }
	}
	public class LinkKongregateAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkPSNAccountRequest
	{
		public string AuthCode { get; set; }

		public string RedirectUri { get; set; }

		public int? IssuerId { get; set; }
	}
	public class LinkPSNAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LinkSteamAccountRequest
	{
		public string SteamTicket { get; set; }
	}
	public class LinkSteamAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ListUsersCharactersRequest
	{
		public string PlayFabId { get; set; }
	}
	public class ListUsersCharactersResult
	{
		public List<CharacterResult> Characters { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LogEventRequest
	{
		public DateTime? Timestamp { get; set; }

		public string EventName { get; set; }

		public Dictionary<string, object> Body { get; set; }

		public bool ProfileSetEvent { get; set; }
	}
	public class LogEventResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LoginResult
	{
		public string SessionTicket { get; set; }

		public string PlayFabId { get; set; }

		public bool NewlyCreated { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class LoginWithAndroidDeviceIDRequest
	{
		public string TitleId { get; set; }

		public string AndroidDeviceId { get; set; }

		public string OS { get; set; }

		public string AndroidDevice { get; set; }

		public bool? CreateAccount { get; set; }
	}
	public class LoginWithCustomIDRequest
	{
		public string TitleId { get; set; }

		public string CustomId { get; set; }

		public bool? CreateAccount { get; set; }
	}
	public class LoginWithEmailAddressRequest
	{
		public string TitleId { get; set; }

		public string Email { get; set; }

		public string Password { get; set; }
	}
	public class LoginWithFacebookRequest
	{
		public string TitleId { get; set; }

		public string AccessToken { get; set; }

		public bool? CreateAccount { get; set; }
	}
	public class LoginWithGoogleAccountRequest
	{
		public string TitleId { get; set; }

		public string AccessToken { get; set; }

		public bool? CreateAccount { get; set; }

		public string PublisherId { get; set; }
	}
	public class LoginWithIOSDeviceIDRequest
	{
		public string TitleId { get; set; }

		public string DeviceId { get; set; }

		public string OS { get; set; }

		public string DeviceModel { get; set; }

		public bool? CreateAccount { get; set; }
	}
	public class LoginWithKongregateRequest
	{
		public string TitleId { get; set; }

		public string KongregateId { get; set; }

		public string AuthTicket { get; set; }

		public bool? CreateAccount { get; set; }
	}
	public class LoginWithPlayFabRequest
	{
		public string TitleId { get; set; }

		public string Username { get; set; }

		public string Password { get; set; }
	}
	public class LoginWithPSNRequest
	{
		public string TitleId { get; set; }

		public string AuthCode { get; set; }

		public string RedirectUri { get; set; }

		public int? IssuerId { get; set; }

		public bool? CreateAccount { get; set; }
	}
	public class LoginWithSteamRequest
	{
		public string TitleId { get; set; }

		public string SteamTicket { get; set; }

		public bool? CreateAccount { get; set; }
	}
	public class MatchmakeRequest
	{
		public string BuildVersion { get; set; }

		public Region? Region { get; set; }

		public string GameMode { get; set; }

		public string LobbyId { get; set; }

		public string StatisticName { get; set; }

		public string CharacterId { get; set; }

		public bool? EnableQueue { get; set; }
	}
	public class MatchmakeResult
	{
		public string LobbyID { get; set; }

		public string ServerHostname { get; set; }

		public int? ServerPort { get; set; }

		public string Ticket { get; set; }

		public string Expires { get; set; }

		public int? PollWaitTimeMS { get; set; }

		public MatchmakeStatus? Status { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public enum MatchmakeStatus
	{
		Complete,
		Waiting,
		GameNotFound
	}
	public class ModifyUserVirtualCurrencyResult
	{
		public string PlayFabId { get; set; }

		public string VirtualCurrency { get; set; }

		public int BalanceChange { get; set; }

		public int Balance { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class OpenTradeRequest
	{
		public List<string> OfferedInventoryInstanceIds { get; set; }

		public List<string> RequestedCatalogItemIds { get; set; }

		public List<string> AllowedPlayerIds { get; set; }
	}
	public class OpenTradeResponse
	{
		public TradeInfo Trade { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class PayForPurchaseRequest
	{
		public string OrderId { get; set; }

		public string ProviderName { get; set; }

		public string Currency { get; set; }

		public string ProviderTransactionId { get; set; }
	}
	public class PayForPurchaseResult
	{
		public string OrderId { get; set; }

		public TransactionStatus? Status { get; set; }

		public Dictionary<string, int> VCAmount { get; set; }

		public string PurchaseCurrency { get; set; }

		public uint PurchasePrice { get; set; }

		public uint CreditApplied { get; set; }

		public string ProviderData { get; set; }

		public string PurchaseConfirmationPageURL { get; set; }

		public Dictionary<string, int> VirtualCurrency { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class PaymentOption
	{
		public string Currency { get; set; }

		public string ProviderName { get; set; }

		public uint Price { get; set; }

		public uint StoreCredit { get; set; }
	}
	public class PlayerLeaderboardEntry
	{
		public string PlayFabId { get; set; }

		public string DisplayName { get; set; }

		public int StatValue { get; set; }

		public int Position { get; set; }
	}
	public class PSNAccountPlayFabIdPair
	{
		public string PSNAccountId { get; set; }

		public string PlayFabId { get; set; }
	}
	public class PurchaseItemRequest
	{
		public string ItemId { get; set; }

		public string VirtualCurrency { get; set; }

		public int Price { get; set; }

		public string CatalogVersion { get; set; }

		public string StoreId { get; set; }

		public string CharacterId { get; set; }
	}
	public class PurchaseItemResult
	{
		public List<ItemInstance> Items { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class RedeemCouponRequest
	{
		public string CouponCode { get; set; }

		public string CatalogVersion { get; set; }
	}
	public class RedeemCouponResult
	{
		public List<ItemInstance> GrantedItems { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class RefreshPSNAuthTokenRequest
	{
		public string AuthCode { get; set; }

		public string RedirectUri { get; set; }

		public int? IssuerId { get; set; }
	}
	public enum Region
	{
		USCentral,
		USEast,
		EUWest,
		Singapore,
		Japan,
		Brazil,
		Australia
	}
	public class RegionInfo
	{
		public Region? Region { get; set; }

		public string Name { get; set; }

		public bool Available { get; set; }

		public string PingUrl { get; set; }
	}
	public class RegisterForIOSPushNotificationRequest
	{
		public string DeviceToken { get; set; }

		public bool? SendPushNotificationConfirmation { get; set; }

		public string ConfirmationMessage { get; set; }
	}
	public class RegisterForIOSPushNotificationResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class RegisterPlayFabUserRequest
	{
		public string TitleId { get; set; }

		public string Username { get; set; }

		public string Email { get; set; }

		public string Password { get; set; }

		public bool? RequireBothUsernameAndEmail { get; set; }

		public string DisplayName { get; set; }

		public string Origination { get; set; }
	}
	public class RegisterPlayFabUserResult
	{
		public string PlayFabId { get; set; }

		public string SessionTicket { get; set; }

		public string Username { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class RemoveFriendRequest
	{
		public string FriendPlayFabId { get; set; }
	}
	public class RemoveFriendResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class RemoveSharedGroupMembersRequest
	{
		public string SharedGroupId { get; set; }

		public List<string> PlayFabIds { get; set; }
	}
	public class RemoveSharedGroupMembersResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ReportPlayerClientRequest
	{
		public string ReporteeId { get; set; }

		public string Comment { get; set; }
	}
	public class ReportPlayerClientResult
	{
		public bool Updated { get; set; }

		public int SubmissionsRemaining { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class RestoreIOSPurchasesRequest
	{
		public string ReceiptData { get; set; }
	}
	public class RestoreIOSPurchasesResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class RunCloudScriptRequest
	{
		public string ActionId { get; set; }

		public object Params { get; set; }

		public string ParamsEncoded { get; set; }
	}
	public class RunCloudScriptResult
	{
		public string ActionId { get; set; }

		public int Version { get; set; }

		public int Revision { get; set; }

		public object Results { get; set; }

		public string ResultsEncoded { get; set; }

		public string ActionLog { get; set; }

		public double ExecutionTime { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class SendAccountRecoveryEmailRequest
	{
		public string Email { get; set; }

		public string TitleId { get; set; }

		public string PublisherId { get; set; }
	}
	public class SendAccountRecoveryEmailResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class SetFriendTagsRequest
	{
		public string FriendPlayFabId { get; set; }

		public List<string> Tags { get; set; }
	}
	public class SetFriendTagsResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class SharedGroupDataRecord
	{
		public string Value { get; set; }

		public string LastUpdatedBy { get; set; }

		public DateTime LastUpdated { get; set; }

		public UserDataPermission? Permission { get; set; }
	}
	public class StartGameRequest
	{
		public string BuildVersion { get; set; }

		public Region Region { get; set; }

		public string GameMode { get; set; }

		public string StatisticName { get; set; }

		public string CharacterId { get; set; }

		public string CustomCommandLineData { get; set; }
	}
	public class StartGameResult
	{
		public string LobbyID { get; set; }

		public string ServerHostname { get; set; }

		public int? ServerPort { get; set; }

		public string Ticket { get; set; }

		public string Expires { get; set; }

		public string Password { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class StartPurchaseRequest
	{
		public string CatalogVersion { get; set; }

		public string StoreId { get; set; }

		public List<ItemPuchaseRequest> Items { get; set; }
	}
	public class StartPurchaseResult
	{
		public string OrderId { get; set; }

		public List<CartItem> Contents { get; set; }

		public List<PaymentOption> PaymentOptions { get; set; }

		public Dictionary<string, int> VirtualCurrencyBalances { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class SteamPlayFabIdPair
	{
		public ulong SteamId { get; set; }

		public string PlayFabId { get; set; }
	}
	public class StoreItem
	{
		public string ItemId { get; set; }

		public Dictionary<string, uint> VirtualCurrencyPrices { get; set; }

		public Dictionary<string, uint> RealCurrencyPrices { get; set; }
	}
	public class SubtractUserVirtualCurrencyRequest
	{
		public string VirtualCurrency { get; set; }

		public int Amount { get; set; }
	}
	public enum TitleActivationStatus
	{
		None,
		ActivatedTitleKey,
		PendingSteam,
		ActivatedSteam,
		RevokedSteam
	}
	public class TitleNewsItem
	{
		public DateTime Timestamp { get; set; }

		public string NewsId { get; set; }

		public string Title { get; set; }

		public string Body { get; set; }
	}
	public class TradeInfo
	{
		public TradeStatus? Status { get; set; }

		public string TradeId { get; set; }

		public string OfferingPlayerId { get; set; }

		public List<string> OfferedInventoryInstanceIds { get; set; }

		public List<string> OfferedCatalogItemIds { get; set; }

		public List<string> RequestedCatalogItemIds { get; set; }

		public List<string> AllowedPlayerIds { get; set; }

		public string AcceptedPlayerId { get; set; }

		public List<string> AcceptedInventoryInstanceIds { get; set; }

		public DateTime? OpenedAt { get; set; }

		public DateTime? FilledAt { get; set; }

		public DateTime? CancelledAt { get; set; }

		public DateTime? InvalidatedAt { get; set; }
	}
	public enum TradeStatus
	{
		Invalid,
		Opening,
		Open,
		Accepting,
		Accepted,
		Filled,
		Cancelled
	}
	public enum TransactionStatus
	{
		CreateCart,
		Init,
		Approved,
		Succeeded,
		FailedByProvider,
		DisputePending,
		RefundPending,
		Refunded,
		RefundFailed,
		ChargedBack,
		FailedByUber,
		FailedByPlayFab,
		Revoked,
		TradePending,
		Traded,
		Upgraded,
		StackPending,
		Stacked,
		Other,
		Failed
	}
	public class UnlinkAndroidDeviceIDRequest
	{
		public string AndroidDeviceId { get; set; }
	}
	public class UnlinkAndroidDeviceIDResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkCustomIDRequest
	{
		public string CustomId { get; set; }
	}
	public class UnlinkCustomIDResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkFacebookAccountRequest
	{
	}
	public class UnlinkFacebookAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkGameCenterAccountRequest
	{
	}
	public class UnlinkGameCenterAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkGoogleAccountRequest
	{
	}
	public class UnlinkGoogleAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkIOSDeviceIDRequest
	{
		public string DeviceId { get; set; }
	}
	public class UnlinkIOSDeviceIDResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkKongregateAccountRequest
	{
	}
	public class UnlinkKongregateAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkPSNAccountRequest
	{
	}
	public class UnlinkPSNAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlinkSteamAccountRequest
	{
	}
	public class UnlinkSteamAccountResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UnlockContainerItemRequest
	{
		public string ContainerItemId { get; set; }

		public string CatalogVersion { get; set; }

		public string CharacterId { get; set; }
	}
	public class UnlockContainerItemResult
	{
		public string UnlockedItemInstanceId { get; set; }

		public string UnlockedWithItemInstanceId { get; set; }

		public List<ItemInstance> GrantedItems { get; set; }

		public Dictionary<string, uint> VirtualCurrency { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UpdateCharacterDataRequest
	{
		public string CharacterId { get; set; }

		public Dictionary<string, string> Data { get; set; }

		public UserDataPermission? Permission { get; set; }
	}
	public class UpdateCharacterDataResult
	{
		public uint DataVersion { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UpdateSharedGroupDataRequest
	{
		public string SharedGroupId { get; set; }

		public Dictionary<string, string> Data { get; set; }

		public UserDataPermission? Permission { get; set; }
	}
	public class UpdateSharedGroupDataResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UpdateUserDataRequest
	{
		public Dictionary<string, string> Data { get; set; }

		public UserDataPermission? Permission { get; set; }
	}
	public class UpdateUserDataResult
	{
		public uint DataVersion { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UpdateUserStatisticsRequest
	{
		public Dictionary<string, int> UserStatistics { get; set; }
	}
	public class UpdateUserStatisticsResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UpdateUserTitleDisplayNameRequest
	{
		public string DisplayName { get; set; }
	}
	public class UpdateUserTitleDisplayNameResult
	{
		public string DisplayName { get; set; }

		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class UserAccountInfo
	{
		public string PlayFabId { get; set; }

		public DateTime Created { get; set; }

		public string Username { get; set; }

		public UserTitleInfo TitleInfo { get; set; }

		public UserPrivateAccountInfo PrivateInfo { get; set; }

		public UserFacebookInfo FacebookInfo { get; set; }

		public UserSteamInfo SteamInfo { get; set; }

		public UserGameCenterInfo GameCenterInfo { get; set; }
	}
	public enum UserDataPermission
	{
		Private,
		Public
	}
	public class UserDataRecord
	{
		public string Value { get; set; }

		public DateTime LastUpdated { get; set; }

		public UserDataPermission? Permission { get; set; }
	}
	public class UserFacebookInfo
	{
		public string FacebookId { get; set; }

		public string FullName { get; set; }
	}
	public class UserGameCenterInfo
	{
		public string GameCenterId { get; set; }
	}
	public enum UserOrigination
	{
		Organic,
		Steam,
		Google,
		Amazon,
		Facebook,
		Kongregate,
		GamersFirst,
		Unknown,
		IOS,
		LoadTest,
		Android,
		PSN,
		GameCenter,
		CustomId
	}
	public class UserPrivateAccountInfo
	{
		public string Email { get; set; }
	}
	public class UserSteamInfo
	{
		public string SteamId { get; set; }

		public string SteamCountry { get; set; }

		public Currency? SteamCurrency { get; set; }

		public TitleActivationStatus? SteamActivationStatus { get; set; }
	}
	public class UserTitleInfo
	{
		public string DisplayName { get; set; }

		public UserOrigination? Origination { get; set; }

		public DateTime Created { get; set; }

		public DateTime? LastLogin { get; set; }

		public DateTime? FirstLogin { get; set; }

		public bool? isBanned { get; set; }
	}
	public class ValidateAmazonReceiptRequest
	{
		public string ReceiptId { get; set; }

		public string UserId { get; set; }

		public string CatalogVersion { get; set; }

		public string CurrencyCode { get; set; }

		public int PurchasePrice { get; set; }
	}
	public class ValidateAmazonReceiptResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ValidateGooglePlayPurchaseRequest
	{
		public string ReceiptJson { get; set; }

		public string Signature { get; set; }

		public string CurrencyCode { get; set; }

		public uint? PurchasePrice { get; set; }
	}
	public class ValidateGooglePlayPurchaseResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class ValidateIOSReceiptRequest
	{
		public string ReceiptData { get; set; }

		public string CurrencyCode { get; set; }

		public int PurchasePrice { get; set; }
	}
	public class ValidateIOSReceiptResult
	{
		public object Request { get; set; }

		public object CustomData { get; set; }
	}
	public class VirtualCurrencyRechargeTime
	{
		public int SecondsToRecharge { get; set; }

		public DateTime RechargeTime { get; set; }

		public int RechargeMax { get; set; }
	}
}
namespace PlayFab
{
	public enum PlayFabErrorCode
	{
		Unknown = 1,
		Success = 0,
		InvalidParams = 1000,
		AccountNotFound = 1001,
		AccountBanned = 1002,
		InvalidUsernameOrPassword = 1003,
		InvalidTitleId = 1004,
		InvalidEmailAddress = 1005,
		EmailAddressNotAvailable = 1006,
		InvalidUsername = 1007,
		InvalidPassword = 1008,
		UsernameNotAvailable = 1009,
		InvalidSteamTicket = 1010,
		AccountAlreadyLinked = 1011,
		LinkedAccountAlreadyClaimed = 1012,
		InvalidFacebookToken = 1013,
		AccountNotLinked = 1014,
		FailedByPaymentProvider = 1015,
		CouponCodeNotFound = 1016,
		InvalidContainerItem = 1017,
		ContainerNotOwned = 1018,
		KeyNotOwned = 1019,
		InvalidItemIdInTable = 1020,
		InvalidReceipt = 1021,
		ReceiptAlreadyUsed = 1022,
		ReceiptCancelled = 1023,
		GameNotFound = 1024,
		GameModeNotFound = 1025,
		InvalidGoogleToken = 1026,
		UserIsNotPartOfDeveloper = 1027,
		InvalidTitleForDeveloper = 1028,
		TitleNameConflicts = 1029,
		UserisNotValid = 1030,
		ValueAlreadyExists = 1031,
		BuildNotFound = 1032,
		PlayerNotInGame = 1033,
		InvalidTicket = 1034,
		InvalidDeveloper = 1035,
		InvalidOrderInfo = 1036,
		RegistrationIncomplete = 1037,
		InvalidPlatform = 1038,
		UnknownError = 1039,
		SteamApplicationNotOwned = 1040,
		WrongSteamAccount = 1041,
		TitleNotActivated = 1042,
		RegistrationSessionNotFound = 1043,
		NoSuchMod = 1044,
		FileNotFound = 1045,
		DuplicateEmail = 1046,
		ItemNotFound = 1047,
		ItemNotOwned = 1048,
		ItemNotRecycleable = 1049,
		ItemNotAffordable = 1050,
		InvalidVirtualCurrency = 1051,
		WrongVirtualCurrency = 1052,
		WrongPrice = 1053,
		NonPositiveValue = 1054,
		InvalidRegion = 1055,
		RegionAtCapacity = 1056,
		ServerFailedToStart = 1057,
		NameNotAvailable = 1058,
		InsufficientFunds = 1059,
		InvalidDeviceID = 1060,
		InvalidPushNotificationToken = 1061,
		NoRemainingUses = 1062,
		InvalidPaymentProvider = 1063,
		PurchaseInitializationFailure = 1064,
		DuplicateUsername = 1065,
		InvalidBuyerInfo = 1066,
		NoGameModeParamsSet = 1067,
		BodyTooLarge = 1068,
		ReservedWordInBody = 1069,
		InvalidTypeInBody = 1070,
		InvalidRequest = 1071,
		ReservedEventName = 1072,
		InvalidUserStatistics = 1073,
		NotAuthenticated = 1074,
		StreamAlreadyExists = 1075,
		ErrorCreatingStream = 1076,
		StreamNotFound = 1077,
		InvalidAccount = 1078,
		PurchaseDoesNotExist = 1080,
		InvalidPurchaseTransactionStatus = 1081,
		APINotEnabledForGameClientAccess = 1082,
		NoPushNotificationARNForTitle = 1083,
		BuildAlreadyExists = 1084,
		BuildPackageDoesNotExist = 1085,
		CustomAnalyticsEventsNotEnabledForTitle = 1087,
		InvalidSharedGroupId = 1088,
		NotAuthorized = 1089,
		MissingTitleGoogleProperties = 1090,
		InvalidItemProperties = 1091,
		InvalidPSNAuthCode = 1092,
		InvalidItemId = 1093,
		PushNotEnabledForAccount = 1094,
		PushServiceError = 1095,
		ReceiptDoesNotContainInAppItems = 1096,
		ReceiptContainsMultipleInAppItems = 1097,
		InvalidBundleID = 1098,
		JavascriptException = 1099,
		InvalidSessionTicket = 1100,
		UnableToConnectToDatabase = 1101,
		InternalServerError = 1110,
		InvalidReportDate = 1111,
		ReportNotAvailable = 1112,
		DatabaseThroughputExceeded = 1113,
		InvalidLobbyId = 1114,
		InvalidGameTicket = 1115,
		ExpiredGameTicket = 1116,
		GameTicketDoesNotMatchLobby = 1117,
		LinkedDeviceAlreadyClaimed = 1118,
		DeviceAlreadyLinked = 1119,
		DeviceNotLinked = 1120,
		PartialFailure = 1121,
		PublisherNotSet = 1122,
		ServiceUnavailable = 1123,
		VersionNotFound = 1124,
		RevisionNotFound = 1125,
		InvalidPublisherId = 1126,
		DownstreamServiceUnavailable = 1127,
		APINotIncludedInTitleUsageTier = 1128,
		DAULimitExceeded = 1129,
		APIRequestLimitExceeded = 1130,
		InvalidAPIEndpoint = 1131,
		BuildNotAvailable = 1132,
		ConcurrentEditError = 1133,
		ContentNotFound = 1134,
		CharacterNotFound = 1135,
		CloudScriptNotFound = 1136,
		ContentQuotaExceeded = 1137,
		InvalidCharacterStatistics = 1138,
		PhotonNotEnabledForTitle = 1139,
		PhotonApplicationNotFound = 1140,
		PhotonApplicationNotAssociatedWithTitle = 1141,
		InvalidEmailOrPassword = 1142,
		FacebookAPIError = 1143,
		InvalidContentType = 1144,
		KeyLengthExceeded = 1145,
		DataLengthExceeded = 1146,
		TooManyKeys = 1147,
		FreeTierCannotHaveVirtualCurrency = 1148,
		MissingAmazonSharedKey = 1149,
		AmazonValidationError = 1150,
		InvalidPSNIssuerId = 1151,
		PSNInaccessible = 1152,
		ExpiredAuthToken = 1153,
		FailedToGetEntitlements = 1154,
		FailedToConsumeEntitlement = 1155,
		TradeAcceptingUserNotAllowed = 1156,
		TradeInventoryItemIsAssignedToCharacter = 1157,
		TradeInventoryItemIsBundle = 1158,
		TradeStatusNotValidForCancelling = 1159,
		TradeStatusNotValidForAccepting = 1160,
		TradeDoesNotExist = 1161,
		TradeCancelled = 1162,
		TradeAlreadyFilled = 1163,
		TradeWaitForStatusTimeout = 1164,
		TradeInventoryItemExpired = 1165,
		TradeMissingOfferedAndAcceptedItems = 1166,
		TradeAcceptedItemIsBundle = 1167,
		TradeAcceptedItemIsStackable = 1168,
		TradeInventoryItemInvalidStatus = 1169,
		TradeAcceptedCatalogItemInvalid = 1170,
		TradeAllowedUsersInvalid = 1171,
		TradeInventoryItemDoesNotExist = 1172,
		TradeInventoryItemIsConsumed = 1173,
		TradeInventoryItemIsStackable = 1174,
		TradeAcceptedItemsMismatch = 1175,
		InvalidKongregateToken = 1176,
		FeatureNotConfiguredForTitle = 1177,
		NoMatchingCatalogItemForReceipt = 1178,
		InvalidCurrencyCode = 1179,
		NoRealMoneyPriceForCatalogItem = 1180,
		TradeInventoryItemIsNotTradable = 1181,
		TradeAcceptedCatalogItemIsNotTradable = 1182,
		UsersAlreadyFriends = 1183,
		LinkedIdentifierAlreadyClaimed = 1184,
		CustomIdNotLinked = 1185
	}
	public class PlayFabError
	{
		public int HttpCode;

		public string HttpStatus;

		public PlayFabErrorCode Error;

		public string ErrorMessage;

		public Dictionary<string, List<string>> ErrorDetails;
	}
	public delegate void ErrorCallback(PlayFabError error);
	public enum PlayFabLogLevel
	{
		None = 0,
		Debug = 1,
		Info = 2,
		Warning = 4,
		Error = 8,
		All = 15
	}
	public enum WebRequestType
	{
		UnityWWW,
		HttpWebRequest
	}
	public class PlayFabSettings
	{
		public static string ProductionEnvironmentURL = ".playfabapi.com";

		public static string LogicServerURL;

		public static string TitleId;

		public static PlayFabLogLevel LogLevel = (PlayFabLogLevel)12;

		public static bool IsTesting;

		public static WebRequestType RequestType;

		public static int RequestTimeout = 2000;

		public static bool RequestKeepAlive = true;

		public static string DeveloperSecretKey;

		public static ErrorCallback GlobalErrorHandler { get; set; }

		public static string GetURL()
		{
			if (!IsTesting)
			{
				string productionEnvironmentURL = ProductionEnvironmentURL;
				if (productionEnvironmentURL.StartsWith("http"))
				{
					return productionEnvironmentURL;
				}
				return "https://" + TitleId + productionEnvironmentURL;
			}
			return "http://localhost:11289/";
		}

		public static string GetLogicURL()
		{
			return LogicServerURL;
		}
	}
}
namespace PlayFab.UUnit
{
	public static class UUnitAssert
	{
		public const double DEFAULT_DOUBLE_PRECISION = 1E-06;

		public static void Skip()
		{
			throw new UUnitSkipException();
		}

		public static void Fail(string message = null)
		{
			if (string.IsNullOrEmpty(message))
			{
				message = "fail";
			}
			throw new UUnitAssertException(message);
		}

		public static void True(bool boolean, string message = null)
		{
			if (boolean)
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = "Expected: true, Actual: false";
			}
			throw new UUnitAssertException(true, false, message);
		}

		public static void False(bool boolean, string message = null)
		{
			if (!boolean)
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = "Expected: false, Actual: true";
			}
			throw new UUnitAssertException(true, false, message);
		}

		public static void NotNull(object something, string message = null)
		{
			if (something != null)
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = "Null object";
			}
			throw new UUnitAssertException(message);
		}

		public static void Null(object something, string message = null)
		{
			if (something == null)
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = "Not null object";
			}
			throw new UUnitAssertException(message);
		}

		public static void Equals(string wanted, string got, string message = null)
		{
			if (wanted == got)
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = "Expected: " + wanted + ", Actual: " + got;
			}
			throw new UUnitAssertException(wanted, got, message);
		}

		public static void Equals(int wanted, int got, string message = null)
		{
			if (wanted == got)
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = "Expected: " + wanted + ", Actual: " + got;
			}
			throw new UUnitAssertException(wanted, got, message);
		}

		public static void DblEquals(double wanted, double got, double precision = 1E-06, string message = null)
		{
			if (Math.Abs(wanted - got) < precision)
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = "Expected: " + wanted + ", Actual: " + got;
			}
			throw new UUnitAssertException(wanted, got, message);
		}

		public static void ObjEquals(object wanted, object got, string message = null)
		{
			if (wanted.Equals(got))
			{
				return;
			}
			if (string.IsNullOrEmpty(message))
			{
				message = string.Concat("Expected: ", wanted, ", Actual: ", got);
			}
			throw new UUnitAssertException(wanted, got, message);
		}
	}
	public class UUnitSkipException : Exception
	{
	}
	public class UUnitAssertException : Exception
	{
		public object expected;

		public object received;

		public string message;

		public UUnitAssertException(string message)
			: base(message)
		{
			this.message = message;
		}

		public UUnitAssertException(object expected, object received, string message)
			: base(string.Concat("[UUnit] - Assert Failed - Expected: ", expected, " Received: ", received, "\n\t\t(", message, ")"))
		{
			this.expected = ((expected != null) ? expected : "null");
			this.received = ((received != null) ? received : "null");
			this.message = ((message != null) ? message : string.Empty);
		}

		public UUnitAssertException(object expected, object received)
			: base(string.Concat("[UUnit] - Assert Failed - Expected: ", expected, " Received: ", received))
		{
			this.expected = ((expected != null) ? expected : "null");
			this.received = ((received != null) ? received : "null");
		}
	}
	public class UUnitTestCase
	{
		private delegate void UUnitTestDelegate();

		private Stopwatch setUpStopwatch = new Stopwatch();

		private Stopwatch tearDownStopwatch = new Stopwatch();

		private Stopwatch eachTestStopwatch = new Stopwatch();

		private string testMethodName;

		public void SetTest(string testMethodName)
		{
			this.testMethodName = testMethodName;
		}

		public void Run(UUnitTestResult testResult)
		{
			UUnitTestResult.TestState testState = UUnitTestResult.TestState.FAILED;
			string message = null;
			eachTestStopwatch.Reset();
			setUpStopwatch.Reset();
			tearDownStopwatch.Reset();
			try
			{
				testResult.TestStarted();
				setUpStopwatch.Start();
				SetUp();
				setUpStopwatch.Stop();
				Type type = GetType();
				MethodInfo method = type.GetMethod(testMethodName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				UUnitAssert.NotNull(method, "Could not execute: " + testMethodName + ", it's probably not public.");
				eachTestStopwatch.Start();
				method.Invoke(this, null);
				testState = UUnitTestResult.TestState.PASSED;
			}
			catch (UUnitSkipException)
			{
				testState = UUnitTestResult.TestState.SKIPPED;
			}
			catch (UUnitAssertException ex2)
			{
				message = ex2.ToString();
				testState = UUnitTestResult.TestState.FAILED;
			}
			catch (TargetInvocationException ex3)
			{
				if (ex3.InnerException is UUnitSkipException)
				{
					testState = UUnitTestResult.TestState.SKIPPED;
				}
				else
				{
					message = ex3.InnerException.ToString();
					testState = UUnitTestResult.TestState.FAILED;
				}
			}
			catch (Exception ex4)
			{
				message = ex4.ToString();
				testState = UUnitTestResult.TestState.FAILED;
			}
			finally
			{
				eachTestStopwatch.Stop();
				if (testState != UUnitTestResult.TestState.SKIPPED)
				{
					try
					{
						tearDownStopwatch.Start();
						TearDown();
						tearDownStopwatch.Stop();
					}
					catch (Exception ex5)
					{
						message = ex5.ToString();
						testState = UUnitTestResult.TestState.FAILED;
					}
				}
			}
			testResult.TestComplete(testMethodName, testState, eachTestStopwatch.ElapsedMilliseconds, message);
		}

		protected virtual void SetUp()
		{
		}

		protected virtual void TearDown()
		{
		}
	}
	public class UUnitTestResult
	{
		public enum TestState
		{
			PASSED,
			FAILED,
			SKIPPED
		}

		private int runCount;

		private int successCount;

		private int failedCount;

		private int skippedCount;

		private static StringBuilder sb = new StringBuilder();

		private List<string> messages = new List<string>();

		public void TestStarted()
		{
			runCount++;
		}

		public void TestComplete(string testName, TestState success, long stopwatchMS, string message)
		{
			sb.Length = 0;
			sb.Append(stopwatchMS);
			while (sb.Length < 10)
			{
				sb.Insert(0, ' ');
			}
			sb.Append(" ms - ").Append(success.ToString());
			sb.Append(" - ").Append(testName);
			if (!string.IsNullOrEmpty(message))
			{
				sb.Append(" - ").Append(message);
			}
			messages.Add(sb.ToString());
			sb.Length = 0;
			switch (success)
			{
			case TestState.PASSED:
				successCount++;
				break;
			case TestState.FAILED:
				failedCount++;
				break;
			case TestState.SKIPPED:
				skippedCount++;
				break;
			}
		}

		public string Summary()
		{
			sb.Length = 0;
			sb.AppendFormat("Testing complete:  {0} test run, {1} tests passed, {2} tests failed, {3} tests skipped.", runCount, successCount, failedCount, skippedCount);
			messages.Add(sb.ToString());
			return string.Join("\n", messages.ToArray());
		}

		public bool AllTestsPassed()
		{
			return runCount > 0 && runCount == successCount + skippedCount && failedCount == 0;
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	public class UUnitTestAttribute : Attribute
	{
	}
	public class UUnitTestSuite
	{
		private List<UUnitTestCase> tests = new List<UUnitTestCase>();

		private int lastTestIndex = -1;

		private UUnitTestResult testResult = new UUnitTestResult();

		public void Add(UUnitTestCase testCase)
		{
			tests.Add(testCase);
		}

		public void RunAllTests()
		{
			bool flag = false;
			while (!flag)
			{
				flag = RunOneTest();
			}
		}

		public bool RunOneTest()
		{
			if (lastTestIndex >= tests.Count)
			{
				return true;
			}
			lastTestIndex++;
			bool flag = lastTestIndex >= tests.Count;
			if (!flag)
			{
				tests[lastTestIndex].Run(testResult);
			}
			return flag;
		}

		public UUnitTestResult GetResults()
		{
			return (lastTestIndex < tests.Count) ? null : testResult;
		}

		public void FindAndAddAllTestCases(Type parent)
		{
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			Assembly[] array = assemblies;
			foreach (Assembly assembly in array)
			{
				Type[] types = assembly.GetTypes();
				Type[] array2 = types;
				foreach (Type type in array2)
				{
					if (!type.IsAbstract && type.IsSubclassOf(parent))
					{
						AddAll(type);
					}
				}
			}
		}

		private void AddAll(Type testCaseType)
		{
			MethodInfo[] methods = testCaseType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			MethodInfo[] array = methods;
			foreach (MethodInfo methodInfo in array)
			{
				object[] customAttributes = methodInfo.GetCustomAttributes(typeof(UUnitTestAttribute), inherit: false);
				if (customAttributes.Length > 0)
				{
					ConstructorInfo constructorInfo = testCaseType.GetConstructors()[0];
					UUnitTestCase uUnitTestCase = (UUnitTestCase)constructorInfo.Invoke(null);
					uUnitTestCase.SetTest(methodInfo.Name);
					Add(uUnitTestCase);
				}
			}
		}

		public bool AllTestsPassed()
		{
			return testResult.AllTestsPassed();
		}
	}
	public class UnityIncrementalTestRunner : UnityEngine.MonoBehaviour
	{
		private UUnitTestSuite suite = new UUnitTestSuite();

		public void Start()
		{
			suite.FindAndAddAllTestCases(typeof(UUnitTestCase));
		}

		public void Update()
		{
			if (suite.RunOneTest())
			{
				UUnitTestResult results = suite.GetResults();
				UnityEngine.Debug.Log(results.Summary());
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
public class PreciseLocaleText : UnityEngine.MonoBehaviour
{
	private void Start()
	{
		GetComponent<Text>().text = $"LANGUAGE ID: {PreciseLocale.GetLanguageID()} \nLANGUAGE: {PreciseLocale.GetLanguage()} \n REGION: {PreciseLocale.GetRegion()} \n CURRENCY CODE: {PreciseLocale.GetCurrencyCode()} \n CURRENCY SYMBOL: {PreciseLocale.GetCurrencySymbol()}";
	}
}
public class PreciseLocale
{
	private class PreciseLocaleAndroid
	{
		private static AndroidJavaClass _preciseLocale = new AndroidJavaClass("com.kokosoft.preciselocale.PreciseLocale");

		public static string GetRegion()
		{
			return _preciseLocale.CallStatic<string>("getRegion", new object[0]);
		}

		public static string GetLanguage()
		{
			return _preciseLocale.CallStatic<string>("getLanguage", new object[0]);
		}

		public static string GetLanguageID()
		{
			return _preciseLocale.CallStatic<string>("getLanguageID", new object[0]);
		}

		public static string GetCurrencyCode()
		{
			return _preciseLocale.CallStatic<string>("getCurrencyCode", new object[0]);
		}

		public static string GetCurrencySymbol()
		{
			return _preciseLocale.CallStatic<string>("getCurrencySymbol", new object[0]);
		}
	}

	public static string GetRegion()
	{
		return PreciseLocaleAndroid.GetRegion();
	}

	public static string GetLanguageID()
	{
		return PreciseLocaleAndroid.GetLanguageID();
	}

	public static string GetLanguage()
	{
		return PreciseLocaleAndroid.GetLanguage();
	}

	public static string GetCurrencyCode()
	{
		return PreciseLocaleAndroid.GetCurrencyCode();
	}

	public static string GetCurrencySymbol()
	{
		return PreciseLocaleAndroid.GetCurrencySymbol();
	}
}
public class GizmoSimple : UnityEngine.MonoBehaviour
{
	private void OnDrawGizmos()
	{
		Gizmos.color = UnityEngine.Color.yellow;
		Gizmos.DrawWireCube(base.transform.position, new Vector3(0.1f, 0.1f, 0.1f));
	}
}
[RequireComponent(typeof(Animator))]
public class IKControl : UnityEngine.MonoBehaviour
{
	protected Animator animator;

	public bool ikActive;

	private float ikWeightLeftArm;

	private float ikWeightRightArm;

	[Space(20f)]
	public Transform rightHandObj;

	public Transform rightHandHintObj;

	[Space(20f)]
	public Transform leftHandObj;

	public Transform leftHandHintObj;

	[Space(20f)]
	public Transform lookObj;

	private void Start()
	{
		animator = GetComponent<Animator>();
	}

	private void OnAnimatorIK()
	{
		if (!animator)
		{
			return;
		}
		if (ikActive)
		{
			ikWeightLeftArm = animator.GetFloat("IKWeightLeftArm");
			ikWeightRightArm = animator.GetFloat("IKWeightRightArm");
			if (lookObj != null)
			{
				animator.SetLookAtWeight(1f);
				animator.SetLookAtPosition(lookObj.position);
			}
			if (rightHandObj != null)
			{
				animator.SetIKPositionWeight(AvatarIKGoal.RightHand, ikWeightRightArm);
				animator.SetIKRotationWeight(AvatarIKGoal.RightHand, ikWeightRightArm);
				animator.SetIKPosition(AvatarIKGoal.RightHand, rightHandObj.position);
				animator.SetIKRotation(AvatarIKGoal.RightHand, rightHandObj.rotation);
			}
			if (rightHandHintObj != null)
			{
				animator.SetIKHintPositionWeight(AvatarIKHint.RightElbow, ikWeightRightArm);
				animator.SetIKHintPosition(AvatarIKHint.RightElbow, rightHandHintObj.position);
			}
			if (leftHandObj != null)
			{
				animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, ikWeightLeftArm);
				animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, ikWeightLeftArm);
				animator.SetIKPosition(AvatarIKGoal.LeftHand, leftHandObj.position);
				animator.SetIKRotation(AvatarIKGoal.LeftHand, leftHandObj.rotation);
			}
			if (leftHandHintObj != null)
			{
				animator.SetIKHintPositionWeight(AvatarIKHint.LeftElbow, ikWeightLeftArm);
				animator.SetIKHintPosition(AvatarIKHint.LeftElbow, leftHandHintObj.position);
			}
		}
		else
		{
			animator.SetIKPositionWeight(AvatarIKGoal.RightHand, 0f);
			animator.SetIKRotationWeight(AvatarIKGoal.RightHand, 0f);
			animator.SetIKPositionWeight(AvatarIKGoal.LeftHand, 0f);
			animator.SetIKRotationWeight(AvatarIKGoal.LeftHand, 0f);
			animator.SetLookAtWeight(0f);
		}
	}
}
public class BlackSmearCorrection : UnityEngine.MonoBehaviour
{
	[Range(-100f, 100f)]
	public float correctionContrastLevel = -2f;

	[Range(-100f, 100f)]
	public float correctionBrightnessLevel = 10f;

	public float smoothTime = 0.1f;

	public bool initiallyApplyCorrection = true;

	public KeyCode keyToToggleCorrection = KeyCode.F10;

	private BlackSmearCorrectionEffect[] blackSmearCorrectionEffects;

	private bool isApplyingCorrection = true;

	private float targetContrast;

	private float currentContrast;

	private float currentContrastVelocity;

	private float targetBrightness;

	private float currentBrightness;

	private float currentBrightnessVelocity;

	private void Start()
	{
		blackSmearCorrectionEffects = GetComponentsInChildren<BlackSmearCorrectionEffect>(includeInactive: true);
		isApplyingCorrection = initiallyApplyCorrection;
		SetUpCorrection();
		currentContrast = targetContrast;
		currentContrastVelocity = 0f;
		currentBrightness = targetBrightness;
		currentBrightnessVelocity = 0f;
	}

	private void Update()
	{
		if (keyToToggleCorrection != 0 && Input.GetKeyDown(keyToToggleCorrection))
		{
			isApplyingCorrection = !isApplyingCorrection;
			SetUpCorrection();
		}
		if (currentContrast != targetContrast)
		{
			currentContrast = Mathf.SmoothDamp(currentContrast, targetContrast, ref currentContrastVelocity, smoothTime, 100f, Time.deltaTime);
			if (Approximately(currentContrast, targetContrast, 0.01f))
			{
				currentContrast = targetContrast;
			}
		}
		if (currentBrightness != targetBrightness)
		{
			currentBrightness = Mathf.SmoothDamp(currentBrightness, targetBrightness, ref currentBrightnessVelocity, smoothTime, 100f, Time.deltaTime);
			if (Approximately(currentBrightness, targetBrightness, 0.01f))
			{
				currentBrightness = targetBrightness;
			}
		}
		for (int i = 0; i < blackSmearCorrectionEffects.Length; i++)
		{
			blackSmearCorrectionEffects[i].contrast = currentContrast;
			blackSmearCorrectionEffects[i].brightness = currentBrightness;
			blackSmearCorrectionEffects[i].enabled = currentContrast != 0f || currentBrightness != 0f;
		}
	}

	private void SetUpCorrection()
	{
		if (isApplyingCorrection)
		{
			targetContrast = correctionContrastLevel;
			targetBrightness = correctionBrightnessLevel;
		}
		else
		{
			targetContrast = 0f;
			targetBrightness = 0f;
		}
	}

	private bool Approximately(float value, float about, float range = 0.001f)
	{
		return Mathf.Abs(value - about) < range;
	}
}
[ExecuteInEditMode]
public class BlackSmearCorrectionEffect : UnityEngine.MonoBehaviour
{
	public Shader shader;

	[HideInInspector]
	public float brightness;

	[HideInInspector]
	public float contrast;

	private Material material;

	private void OnEnable()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
			return;
		}
		if (!shader || !shader.isSupported)
		{
			base.enabled = false;
			return;
		}
		material = new Material(shader);
		material.hideFlags = HideFlags.HideAndDontSave;
	}

	private void OnDisable()
	{
		if ((bool)material)
		{
			UnityEngine.Object.DestroyImmediate(material);
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (brightness == 0f && contrast == 0f)
		{
			UnityEngine.Graphics.Blit(source, destination);
			return;
		}
		material.SetFloat("_Brightness", (brightness + 100f) * 0.01f);
		material.SetFloat("_Contrast", (contrast + 100f) * 0.01f);
		UnityEngine.Graphics.Blit(source, destination, material);
	}
}
public class FSPlayer : UnityEngine.MonoBehaviour
{
	public Light[] m_LightList;

	public Material[] m_SkyboxList;

	private UnityEngine.Color[] FogColorList;

	private UnityEngine.Color[] AmbientLightList;

	private int m_CurrentSkyBox;

	private void Start()
	{
		FogColorList = new UnityEngine.Color[4];
		ref UnityEngine.Color reference = ref FogColorList[0];
		reference = new UnityEngine.Color(0.11764706f, 10f / 51f, 20f / 51f, 1f);
		ref UnityEngine.Color reference2 = ref FogColorList[1];
		reference2 = new UnityEngine.Color(4f / 51f, 8f / 51f, 20f / 51f, 1f);
		ref UnityEngine.Color reference3 = ref FogColorList[2];
		reference3 = new UnityEngine.Color(22f / 51f, 0.7058824f, 1f, 1f);
		ref UnityEngine.Color reference4 = ref FogColorList[3];
		reference4 = new UnityEngine.Color(0.3529412f, 0.8235294f, 1f, 1f);
		AmbientLightList = new UnityEngine.Color[4];
		ref UnityEngine.Color reference5 = ref AmbientLightList[0];
		reference5 = new UnityEngine.Color(7f / 51f, 7f / 51f, 7f / 51f, 1f);
		ref UnityEngine.Color reference6 = ref AmbientLightList[1];
		reference6 = new UnityEngine.Color(7f / 51f, 7f / 51f, 7f / 51f, 1f);
		ref UnityEngine.Color reference7 = ref AmbientLightList[2];
		reference7 = new UnityEngine.Color(32f / 51f, 0.7058824f, 0.7058824f, 1f);
		ref UnityEngine.Color reference8 = ref AmbientLightList[3];
		reference8 = new UnityEngine.Color(0.7058824f, 0.7058824f, 0.7058824f, 1f);
		SwitchSkyBox(0);
	}

	private void Update()
	{
		if (Input.GetKeyUp(KeyCode.Q))
		{
			SwitchSkyBox(-1);
		}
		if (Input.GetKeyUp(KeyCode.E))
		{
			SwitchSkyBox(1);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		UnityEngine.Debug.Log("OnTriggerExit=" + other.name);
		base.transform.localPosition = new Vector3(0f, 1f, 0f);
	}

	private void OnGUI()
	{
		GUI.Window(1, new Rect(Screen.width - 220, 5f, 210f, 80f), InfoWindow, "Info");
		GUI.Window(2, new Rect(Screen.width - 220, Screen.height - 85, 210f, 80f), HelpWindow, $"{m_CurrentSkyBox + 1:00}/{m_SkyboxList.Length:00}" + " (" + m_SkyboxList[m_CurrentSkyBox].name + ")");
	}

	private void SwitchSkyBox(int DiffNum)
	{
		m_CurrentSkyBox += DiffNum;
		if (m_CurrentSkyBox < 0)
		{
			m_CurrentSkyBox = m_SkyboxList.Length - 1;
		}
		if (m_CurrentSkyBox >= m_SkyboxList.Length)
		{
			m_CurrentSkyBox = 0;
		}
		RenderSettings.skybox = m_SkyboxList[m_CurrentSkyBox];
		for (int i = 0; i < m_LightList.Length; i++)
		{
			if (i == m_CurrentSkyBox)
			{
				m_LightList[i].gameObject.SetActive(value: true);
			}
			else
			{
				m_LightList[i].gameObject.SetActive(value: false);
			}
		}
		RenderSettings.fog = true;
		if (m_CurrentSkyBox >= 0 && m_CurrentSkyBox < FogColorList.Length)
		{
			RenderSettings.fogColor = FogColorList[m_CurrentSkyBox];
		}
		else
		{
			RenderSettings.fogColor = UnityEngine.Color.white;
		}
		if (m_CurrentSkyBox >= 0 && m_CurrentSkyBox < AmbientLightList.Length)
		{
			RenderSettings.ambientLight = AmbientLightList[m_CurrentSkyBox];
		}
		else
		{
			RenderSettings.ambientLight = UnityEngine.Color.white;
		}
	}

	private void HelpWindow(int id)
	{
		GUI.Label(new Rect(12f, 25f, 240f, 20f), "W/S/A/D: Move player");
		GUI.Label(new Rect(12f, 50f, 240f, 20f), "Q/E: Switch Skybox");
	}

	private void InfoWindow(int id)
	{
		GUI.Label(new Rect(15f, 25f, 240f, 20f), "Fantasy Skybox FREE 1.2");
		GUI.Label(new Rect(15f, 50f, 240f, 20f), "www.ge-team.com/pages");
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class CFX_AutoDestructShuriken : UnityEngine.MonoBehaviour
{
	public bool OnlyDeactivate;

	private void OnEnable()
	{
		StartCoroutine("CheckIfAlive");
	}

	private IEnumerator CheckIfAlive()
	{
		do
		{
			yield return new WaitForSeconds(0.5f);
		}
		while (GetComponent<ParticleSystem>().IsAlive(withChildren: true));
		if (OnlyDeactivate)
		{
			base.gameObject.SetActive(value: false);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class CFX_InspectorHelp : UnityEngine.MonoBehaviour
{
	public bool Locked;

	public string Title;

	public string HelpText;

	public int MsgType;

	[ContextMenu("Unlock editing")]
	private void Unlock()
	{
		Locked = false;
	}
}
public class MoverioCameraController : UnityEngine.MonoBehaviour
{
	private static MoverioCameraController _instance;

	public Camera LeftEyeCam;

	public Camera RightEyeCam;

	public Camera Cam2D;

	public float PupillaryDistance = 0.05f;

	private MoverioDisplayType _displayState;

	public static MoverioCameraController Instance
	{
		get
		{
			if (_instance == null)
			{
				UnityEngine.Debug.Log("Please Add MoverioCameraRig Prefab To Scene!");
			}
			return _instance;
		}
	}

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		SetPupillaryDistance(PupillaryDistance);
	}

	public void SetPupillaryDistance(float pDist)
	{
		PupillaryDistance = pDist;
		LeftEyeCam.transform.localPosition = new Vector3(0f - PupillaryDistance, 0f, 0f);
		RightEyeCam.transform.localPosition = new Vector3(PupillaryDistance, 0f, 0f);
	}

	private void OnEnable()
	{
		MoverioController.OnMoverioStateChange += HandleOnMoverioStateChange;
	}

	private void OnDisable()
	{
		MoverioController.OnMoverioStateChange -= HandleOnMoverioStateChange;
	}

	private void HandleOnMoverioStateChange(MoverioEventType type)
	{
		switch (type)
		{
		case MoverioEventType.Display3DOff:
			SetCurrentDisplayType(MoverioDisplayType.Display2D);
			break;
		case MoverioEventType.Display3DOn:
			SetCurrentDisplayType(MoverioDisplayType.Display3D);
			break;
		}
	}

	public MoverioDisplayType GetCurrentDisplayState()
	{
		return _displayState;
	}

	public void SetCurrentDisplayType(MoverioDisplayType type)
	{
		_displayState = type;
		switch (_displayState)
		{
		case MoverioDisplayType.Display2D:
		{
			Camera leftEyeCam2 = LeftEyeCam;
			bool flag = false;
			RightEyeCam.enabled = flag;
			leftEyeCam2.enabled = flag;
			Cam2D.enabled = true;
			break;
		}
		case MoverioDisplayType.Display3D:
		{
			Camera leftEyeCam = LeftEyeCam;
			bool flag = true;
			RightEyeCam.enabled = flag;
			leftEyeCam.enabled = flag;
			Cam2D.enabled = false;
			break;
		}
		}
	}
}
public enum MoverioEventType
{
	Display3DOn,
	Display3DOff,
	DisplayBrightnessChange,
	MuteAudioOn,
	MuteAudioOff,
	MuteDisplayOn,
	MuteDisplayOff,
	SensorHeadTrack,
	SensorHandController
}
public enum MoverioDisplayType
{
	Display3D,
	Display2D
}
public enum MoverioSensorType
{
	SensorHeadTracking,
	SensorHandController
}
public class MoverioController : UnityEngine.MonoBehaviour
{
	public delegate void MoverioEvent(MoverioEventType type);

	public int InitialScreenBrightness = 20;

	public MoverioDisplayType InitialDisplayMode = MoverioDisplayType.Display2D;

	public MoverioSensorType InitialSensorMode;

	private AndroidJavaClass _unityPlayer;

	private AndroidJavaObject _currentActivity;

	private static MoverioController _instance;

	private bool MoverioDevice = true;

	public static MoverioController Instance
	{
		get
		{
			if (_instance == null)
			{
				UnityEngine.Debug.Log("Please Add MoverioController Prefab To Scene!");
			}
			return _instance;
		}
	}

	public static event MoverioEvent OnMoverioStateChange;

	private void Awake()
	{
		_instance = this;
	}

	private void Start()
	{
		CheckDeviceType();
		SetJavaClass();
		SetDefaultSettings();
	}

	private void CheckDeviceType()
	{
		if (SystemInfo.deviceModel.Equals("EPSON embt2"))
		{
			AndroidJNI.AttachCurrentThread();
		}
		else
		{
			MoverioDevice = false;
		}
	}

	private void SetDefaultSettings()
	{
		if (InitialDisplayMode.Equals(MoverioDisplayType.Display3D))
		{
			SetDisplay3D(on: true);
		}
		else
		{
			SetDisplay3D(on: false);
		}
		if (!InitialScreenBrightness.Equals(20))
		{
			string empty = string.Empty;
			empty = SetDisplayBrightness(InitialScreenBrightness);
			UnityEngine.Debug.Log(empty);
		}
		if (InitialSensorMode.Equals(MoverioSensorType.SensorHandController))
		{
			SetSensorMode(MoverioSensorType.SensorHandController);
		}
	}

	private void SetJavaClass()
	{
		if (MoverioDevice)
		{
			using (_unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				_currentActivity = _unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
			}
			_currentActivity.Call("SetMoverioDevice");
		}
	}

	public string SetSensorMode(MoverioSensorType sType)
	{
		string result = "NOT SET";
		if (MoverioDevice)
		{
			int num = 0;
			if (sType.Equals(MoverioSensorType.SensorHandController))
			{
				num = 1;
			}
			result = _currentActivity.Call<string>("SetSensorMode", new object[1] { num });
		}
		if (sType.Equals(MoverioSensorType.SensorHandController))
		{
			if (MoverioController.OnMoverioStateChange != null)
			{
				MoverioController.OnMoverioStateChange(MoverioEventType.SensorHandController);
			}
		}
		else if (MoverioController.OnMoverioStateChange != null)
		{
			MoverioController.OnMoverioStateChange(MoverioEventType.SensorHeadTrack);
		}
		return result;
	}

	public string SetDisplayBrightness(int brightness)
	{
		string result = "NOT SET";
		if (MoverioDevice)
		{
			result = _currentActivity.Call<string>("SetDisplayBrightness", new object[1] { brightness });
		}
		if (MoverioController.OnMoverioStateChange != null)
		{
			MoverioController.OnMoverioStateChange(MoverioEventType.DisplayBrightnessChange);
		}
		return result;
	}

	public int GetDisplayBrightness()
	{
		int result = -1;
		if (MoverioDevice)
		{
			result = _currentActivity.Call<int>("GetDisplayBrightness", new object[0]);
		}
		return result;
	}

	public void SetDisplay3D(bool on)
	{
		if (MoverioDevice)
		{
			_currentActivity.Call("SetDisplay3D", on);
		}
		if (MoverioController.OnMoverioStateChange != null)
		{
			MoverioEventType type = ((!on) ? MoverioEventType.Display3DOff : MoverioEventType.Display3DOn);
			MoverioController.OnMoverioStateChange(type);
		}
	}

	public void MuteAudio(bool mute)
	{
		if (MoverioDevice)
		{
			_currentActivity.Call("MuteAudio", mute);
		}
		if (MoverioController.OnMoverioStateChange != null)
		{
			MoverioEventType type = ((!mute) ? MoverioEventType.MuteAudioOff : MoverioEventType.MuteAudioOn);
			MoverioController.OnMoverioStateChange(type);
		}
	}

	public void MuteDisplay(bool mute)
	{
		if (MoverioDevice)
		{
			_currentActivity.Call("MuteDisplay", mute);
		}
		if (MoverioController.OnMoverioStateChange != null)
		{
			MoverioEventType type = ((!mute) ? MoverioEventType.MuteDisplayOff : MoverioEventType.MuteDisplayOn);
			MoverioController.OnMoverioStateChange(type);
		}
	}
}
public class MoverioTutorialController : UnityEngine.MonoBehaviour
{
	public GUIText TextView;

	private void Start()
	{
		TextView.text = "Welcome to the Tutorial!";
		StartCoroutine(TutorialSequence());
	}

	private IEnumerator TutorialSequence()
	{
		yield return new WaitForSeconds(3f);
		TextView.text = "Starting Dimmer";
		yield return new WaitForSeconds(3f);
		MoverioController.Instance.SetDisplayBrightness(10);
		TextView.text = "Brightness at 10!";
		yield return new WaitForSeconds(2f);
		MoverioController.Instance.SetDisplay3D(on: true);
		TextView.text = "3D Mode on!";
		yield return new WaitForSeconds(3f);
		MoverioController.Instance.SetDisplay3D(on: false);
		TextView.text = "3D Mode off!";
		yield return new WaitForSeconds(3f);
		MoverioController.Instance.SetDisplayBrightness(5);
		TextView.text = "Brightness at 5!";
		yield return new WaitForSeconds(3f);
		MoverioController.Instance.SetDisplayBrightness(15);
		TextView.text = "Brightness at 15!";
		yield return new WaitForSeconds(3f);
		MoverioController.Instance.SetDisplayBrightness(20);
		TextView.text = "Brightness at 20!";
	}
}
public class AccelRotator : UnityEngine.MonoBehaviour
{
	public float Speed = 10f;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.localEulerAngles += Input.acceleration * Speed;
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Blur/Blur")]
public class BlurEffect : UnityEngine.MonoBehaviour
{
	public int iterations = 3;

	public float blurSpread = 0.6f;

	public Shader blurShader;

	private static Material m_Material;

	protected Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = new Material(blurShader);
				m_Material.hideFlags = HideFlags.DontSave;
			}
			return m_Material;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_Material)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!blurShader || !material.shader.isSupported)
		{
			base.enabled = false;
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * blurSpread;
		UnityEngine.Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
	}

	private void DownSample4x(RenderTexture source, RenderTexture dest)
	{
		float num = 1f;
		UnityEngine.Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		int width = source.width / 4;
		int height = source.height / 4;
		RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
		DownSample4x(source, renderTexture);
		for (int i = 0; i < iterations; i++)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			FourTapCone(renderTexture, temporary, i);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		UnityEngine.Graphics.Blit(renderTexture, destination);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
public class ColorCorrectionEffect : ImageEffectBase
{
	public Texture textureRamp;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_RampTex", textureRamp);
		UnityEngine.Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
public class ContrastStretchEffect : UnityEngine.MonoBehaviour
{
	public float adaptationSpeed = 0.02f;

	public float limitMinimum = 0.2f;

	public float limitMaximum = 0.6f;

	private RenderTexture[] adaptRenderTex = new RenderTexture[2];

	private int curAdaptIndex;

	public Shader shaderLum;

	private Material m_materialLum;

	public Shader shaderReduce;

	private Material m_materialReduce;

	public Shader shaderAdapt;

	private Material m_materialAdapt;

	public Shader shaderApply;

	private Material m_materialApply;

	protected Material materialLum
	{
		get
		{
			if (m_materialLum == null)
			{
				m_materialLum = new Material(shaderLum);
				m_materialLum.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialLum;
		}
	}

	protected Material materialReduce
	{
		get
		{
			if (m_materialReduce == null)
			{
				m_materialReduce = new Material(shaderReduce);
				m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialReduce;
		}
	}

	protected Material materialAdapt
	{
		get
		{
			if (m_materialAdapt == null)
			{
				m_materialAdapt = new Material(shaderAdapt);
				m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialAdapt;
		}
	}

	protected Material materialApply
	{
		get
		{
			if (m_materialApply == null)
			{
				m_materialApply = new Material(shaderApply);
				m_materialApply.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_materialApply;
		}
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
		{
			base.enabled = false;
		}
	}

	private void OnEnable()
	{
		for (int i = 0; i < 2; i++)
		{
			if (!adaptRenderTex[i])
			{
				adaptRenderTex[i] = new RenderTexture(1, 1, 0);
				adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
			}
		}
	}

	private void OnDisable()
	{
		for (int i = 0; i < 2; i++)
		{
			UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
			adaptRenderTex[i] = null;
		}
		if ((bool)m_materialLum)
		{
			UnityEngine.Object.DestroyImmediate(m_materialLum);
		}
		if ((bool)m_materialReduce)
		{
			UnityEngine.Object.DestroyImmediate(m_materialReduce);
		}
		if ((bool)m_materialAdapt)
		{
			UnityEngine.Object.DestroyImmediate(m_materialAdapt);
		}
		if ((bool)m_materialApply)
		{
			UnityEngine.Object.DestroyImmediate(m_materialApply);
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		RenderTexture renderTexture = RenderTexture.GetTemporary(source.width, source.height);
		UnityEngine.Graphics.Blit(source, renderTexture, materialLum);
		while (renderTexture.width > 1 || renderTexture.height > 1)
		{
			int num = renderTexture.width / 2;
			if (num < 1)
			{
				num = 1;
			}
			int num2 = renderTexture.height / 2;
			if (num2 < 1)
			{
				num2 = 1;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
			UnityEngine.Graphics.Blit(renderTexture, temporary, materialReduce);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		CalculateAdaptation(renderTexture);
		materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
		UnityEngine.Graphics.Blit(source, destination, materialApply);
		RenderTexture.ReleaseTemporary(renderTexture);
	}

	private void CalculateAdaptation(Texture curTexture)
	{
		int num = curAdaptIndex;
		curAdaptIndex = (curAdaptIndex + 1) % 2;
		float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
		value = Mathf.Clamp(value, 0.01f, 1f);
		materialAdapt.SetTexture("_CurTex", curTexture);
		materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
		UnityEngine.Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
		GL.Clear(clearDepth: false, clearColor: true, UnityEngine.Color.black);
		UnityEngine.Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Bloom and Glow/Glow (Deprecated)")]
public class GlowEffect : UnityEngine.MonoBehaviour
{
	public float glowIntensity = 1.5f;

	public int blurIterations = 3;

	public float blurSpread = 0.7f;

	public UnityEngine.Color glowTint = new UnityEngine.Color(1f, 1f, 1f, 0f);

	public Shader compositeShader;

	private Material m_CompositeMaterial;

	public Shader blurShader;

	private Material m_BlurMaterial;

	public Shader downsampleShader;

	private Material m_DownsampleMaterial;

	protected Material compositeMaterial
	{
		get
		{
			if (m_CompositeMaterial == null)
			{
				m_CompositeMaterial = new Material(compositeShader);
				m_CompositeMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_CompositeMaterial;
		}
	}

	protected Material blurMaterial
	{
		get
		{
			if (m_BlurMaterial == null)
			{
				m_BlurMaterial = new Material(blurShader);
				m_BlurMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_BlurMaterial;
		}
	}

	protected Material downsampleMaterial
	{
		get
		{
			if (m_DownsampleMaterial == null)
			{
				m_DownsampleMaterial = new Material(downsampleShader);
				m_DownsampleMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_DownsampleMaterial;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_CompositeMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_CompositeMaterial);
		}
		if ((bool)m_BlurMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_BlurMaterial);
		}
		if ((bool)m_DownsampleMaterial)
		{
			UnityEngine.Object.DestroyImmediate(m_DownsampleMaterial);
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
			return;
		}
		if (downsampleShader == null)
		{
			UnityEngine.Debug.Log("No downsample shader assigned! Disabling glow.");
			base.enabled = false;
			return;
		}
		if (!blurMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!compositeMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
		if (!downsampleMaterial.shader.isSupported)
		{
			base.enabled = false;
		}
	}

	public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
	{
		float num = 0.5f + (float)iteration * blurSpread;
		UnityEngine.Graphics.BlitMultiTap(source, dest, blurMaterial, new Vector2(num, num), new Vector2(0f - num, num), new Vector2(num, 0f - num), new Vector2(0f - num, 0f - num));
	}

	private void DownSample4x(RenderTexture source, RenderTexture dest)
	{
		downsampleMaterial.color = new UnityEngine.Color(glowTint.r, glowTint.g, glowTint.b, glowTint.a / 4f);
		UnityEngine.Graphics.Blit(source, dest, downsampleMaterial);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		glowIntensity = Mathf.Clamp(glowIntensity, 0f, 10f);
		blurIterations = Mathf.Clamp(blurIterations, 0, 30);
		blurSpread = Mathf.Clamp(blurSpread, 0.5f, 1f);
		int width = source.width / 4;
		int height = source.height / 4;
		RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
		DownSample4x(source, renderTexture);
		float num = Mathf.Clamp01((glowIntensity - 1f) / 4f);
		blurMaterial.color = new UnityEngine.Color(1f, 1f, 1f, 0.25f + num);
		for (int i = 0; i < blurIterations; i++)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			FourTapCone(renderTexture, temporary, i);
			RenderTexture.ReleaseTemporary(renderTexture);
			renderTexture = temporary;
		}
		UnityEngine.Graphics.Blit(source, destination);
		BlitGlow(renderTexture, destination);
		RenderTexture.ReleaseTemporary(renderTexture);
	}

	public void BlitGlow(RenderTexture source, RenderTexture dest)
	{
		compositeMaterial.color = new UnityEngine.Color(1f, 1f, 1f, Mathf.Clamp01(glowIntensity));
		UnityEngine.Graphics.Blit(source, dest, compositeMaterial);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
public class GrayscaleEffect : ImageEffectBase
{
	public Texture textureRamp;

	public float rampOffset;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetTexture("_RampTex", textureRamp);
		base.material.SetFloat("_RampOffset", rampOffset);
		UnityEngine.Graphics.Blit(source, destination, base.material);
	}
}
[RequireComponent(typeof(Camera))]
[AddComponentMenu("")]
public class ImageEffectBase : UnityEngine.MonoBehaviour
{
	public Shader shader;

	private Material m_Material;

	protected Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = new Material(shader);
				m_Material.hideFlags = HideFlags.HideAndDontSave;
			}
			return m_Material;
		}
	}

	protected virtual void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (!shader || !shader.isSupported)
		{
			base.enabled = false;
		}
	}

	protected virtual void OnDisable()
	{
		if ((bool)m_Material)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
	}
}
[AddComponentMenu("")]
public class ImageEffects
{
	public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
	{
		if (source.texelSize.y < 0f)
		{
			center.y = 1f - center.y;
			angle = 0f - angle;
		}
		Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
		material.SetMatrix("_RotationMatrix", value);
		material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
		material.SetFloat("_Angle", angle * ((float)Math.PI / 180f));
		UnityEngine.Graphics.Blit(source, destination, material);
	}

	[Obsolete("Use Graphics.Blit(source,dest) instead")]
	public static void Blit(RenderTexture source, RenderTexture dest)
	{
		UnityEngine.Graphics.Blit(source, dest);
	}

	[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
	public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
	{
		UnityEngine.Graphics.Blit(source, dest, material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
[RequireComponent(typeof(Camera))]
public class MotionBlur : ImageEffectBase
{
	public float blurAmount = 0.8f;

	public bool extraBlur;

	private RenderTexture accumTexture;

	protected override void Start()
	{
		if (!SystemInfo.supportsRenderTextures)
		{
			base.enabled = false;
		}
		else
		{
			base.Start();
		}
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		UnityEngine.Object.DestroyImmediate(accumTexture);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
		{
			UnityEngine.Object.DestroyImmediate(accumTexture);
			accumTexture = new RenderTexture(source.width, source.height, 0);
			accumTexture.hideFlags = HideFlags.HideAndDontSave;
			UnityEngine.Graphics.Blit(source, accumTexture);
		}
		if (extraBlur)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
			accumTexture.MarkRestoreExpected();
			UnityEngine.Graphics.Blit(accumTexture, temporary);
			UnityEngine.Graphics.Blit(temporary, accumTexture);
			RenderTexture.ReleaseTemporary(temporary);
		}
		blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
		base.material.SetTexture("_MainTex", accumTexture);
		base.material.SetFloat("_AccumOrig", 1f - blurAmount);
		accumTexture.MarkRestoreExpected();
		UnityEngine.Graphics.Blit(source, accumTexture, base.material);
		UnityEngine.Graphics.Blit(accumTexture, destination);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
public class NoiseEffect : UnityEngine.MonoBehaviour
{
	public bool monochrome = true;

	private bool rgbFallback;

	public float grainIntensityMin = 0.1f;

	public float grainIntensityMax = 0.2f;

	public float grainSize = 2f;

	public float scratchIntensityMin = 0.05f;

	public float scratchIntensityMax = 0.25f;

	public float scratchFPS = 10f;

	public float scratchJitter = 0.01f;

	public Texture grainTexture;

	public Texture scratchTexture;

	public Shader shaderRGB;

	public Shader shaderYUV;

	private Material m_MaterialRGB;

	private Material m_MaterialYUV;

	private float scratchTimeLeft;

	private float scratchX;

	private float scratchY;

	protected Material material
	{
		get
		{
			if (m_MaterialRGB == null)
			{
				m_MaterialRGB = new Material(shaderRGB);
				m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
			}
			if (m_MaterialYUV == null && !rgbFallback)
			{
				m_MaterialYUV = new Material(shaderYUV);
				m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
			}
			return (rgbFallback || monochrome) ? m_MaterialRGB : m_MaterialYUV;
		}
	}

	protected void Start()
	{
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
		else if (shaderRGB == null || shaderYUV == null)
		{
			UnityEngine.Debug.Log("Noise shaders are not set up! Disabling noise effect.");
			base.enabled = false;
		}
		else if (!shaderRGB.isSupported)
		{
			base.enabled = false;
		}
		else if (!shaderYUV.isSupported)
		{
			rgbFallback = true;
		}
	}

	protected void OnDisable()
	{
		if ((bool)m_MaterialRGB)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
		}
		if ((bool)m_MaterialYUV)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
		}
	}

	private void SanitizeParameters()
	{
		grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
		grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
		scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
		scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
		scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
		scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
		grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		SanitizeParameters();
		if (scratchTimeLeft <= 0f)
		{
			scratchTimeLeft = UnityEngine.Random.value * 2f / scratchFPS;
			scratchX = UnityEngine.Random.value;
			scratchY = UnityEngine.Random.value;
		}
		scratchTimeLeft -= Time.deltaTime;
		Material material = this.material;
		material.SetTexture("_GrainTex", grainTexture);
		material.SetTexture("_ScratchTex", scratchTexture);
		float num = 1f / grainSize;
		material.SetVector("_GrainOffsetScale", new Vector4(UnityEngine.Random.value, UnityEngine.Random.value, (float)Screen.width / (float)grainTexture.width * num, (float)Screen.height / (float)grainTexture.height * num));
		material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + UnityEngine.Random.value * scratchJitter, scratchY + UnityEngine.Random.value * scratchJitter, (float)Screen.width / (float)scratchTexture.width, (float)Screen.height / (float)scratchTexture.height));
		material.SetVector("_Intensity", new Vector4(UnityEngine.Random.Range(grainIntensityMin, grainIntensityMax), UnityEngine.Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
		UnityEngine.Graphics.Blit(source, destination, material);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
public class SSAOEffect : UnityEngine.MonoBehaviour
{
	public enum SSAOSamples
	{
		Low,
		Medium,
		High
	}

	public float m_Radius = 0.4f;

	public SSAOSamples m_SampleCount = SSAOSamples.Medium;

	public float m_OcclusionIntensity = 1.5f;

	public int m_Blur = 2;

	public int m_Downsampling = 2;

	public float m_OcclusionAttenuation = 1f;

	public float m_MinZ = 0.01f;

	public Shader m_SSAOShader;

	private Material m_SSAOMaterial;

	public Texture2D m_RandomTexture;

	private bool m_Supported;

	private static Material CreateMaterial(Shader shader)
	{
		if (!shader)
		{
			return null;
		}
		Material material = new Material(shader);
		material.hideFlags = HideFlags.HideAndDontSave;
		return material;
	}

	private static void DestroyMaterial(Material mat)
	{
		if ((bool)mat)
		{
			UnityEngine.Object.DestroyImmediate(mat);
			mat = null;
		}
	}

	private void OnDisable()
	{
		DestroyMaterial(m_SSAOMaterial);
	}

	private void Start()
	{
		if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			m_Supported = false;
			base.enabled = false;
			return;
		}
		CreateMaterials();
		if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
		{
			m_Supported = false;
			base.enabled = false;
		}
		else
		{
			m_Supported = true;
		}
	}

	private void OnEnable()
	{
		GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
	}

	private void CreateMaterials()
	{
		if (!m_SSAOMaterial && m_SSAOShader.isSupported)
		{
			m_SSAOMaterial = CreateMaterial(m_SSAOShader);
			m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
		}
	}

	[ImageEffectOpaque]
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!m_Supported || !m_SSAOShader.isSupported)
		{
			base.enabled = false;
			return;
		}
		CreateMaterials();
		m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
		m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
		m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
		m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
		m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
		m_Blur = Mathf.Clamp(m_Blur, 0, 4);
		RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
		float fieldOfView = GetComponent<Camera>().fieldOfView;
		float farClipPlane = GetComponent<Camera>().farClipPlane;
		float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
		float x = num * GetComponent<Camera>().aspect;
		m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
		int num2;
		int num3;
		if ((bool)m_RandomTexture)
		{
			num2 = m_RandomTexture.width;
			num3 = m_RandomTexture.height;
		}
		else
		{
			num2 = 1;
			num3 = 1;
		}
		m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
		m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
		bool flag = m_Blur > 0;
		UnityEngine.Graphics.Blit((!flag) ? source : null, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
		if (flag)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
			UnityEngine.Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(renderTexture);
			RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
			m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
			m_SSAOMaterial.SetTexture("_SSAO", temporary);
			UnityEngine.Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
			RenderTexture.ReleaseTemporary(temporary);
			renderTexture = temporary2;
		}
		m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
		UnityEngine.Graphics.Blit(source, destination, m_SSAOMaterial, 4);
		RenderTexture.ReleaseTemporary(renderTexture);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
public class SepiaToneEffect : ImageEffectBase
{
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		UnityEngine.Graphics.Blit(source, destination, base.material);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Displacement/Twirl")]
public class TwirlEffect : ImageEffectBase
{
	public Vector2 radius = new Vector2(0.3f, 0.3f);

	public float angle = 50f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Displacement/Vortex")]
public class VortexEffect : ImageEffectBase
{
	public Vector2 radius = new Vector2(0.4f, 0.4f);

	public float angle = 50f;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
	}
}
public class demoGUI : UnityEngine.MonoBehaviour
{
	public GameObject[] explosions;

	private void OnGUI()
	{
		for (int i = 0; i < explosions.Length / 2; i++)
		{
			GUI.color = new UnityEngine.Color(1f, 0.75f, 0.5f);
			if (GUI.Button(new Rect(10f, 10 + i * 30, 100f, 20f), explosions[i].name))
			{
				UnityEngine.Object.Instantiate(explosions[i], new Vector3(0f, 2f, 0f), Quaternion.identity);
			}
		}
		int num = 0;
		for (int j = explosions.Length / 2; j < explosions.Length; j++)
		{
			GUI.color = new UnityEngine.Color(1f, 0.75f, 0.5f);
			if (GUI.Button(new Rect(Screen.width - 120, 10 + num * 30, 100f, 20f), explosions[j].name))
			{
				UnityEngine.Object.Instantiate(explosions[j], new Vector3(0f, 2f, 0f), Quaternion.identity);
			}
			num++;
		}
	}
}
public class HTExplosion : UnityEngine.MonoBehaviour
{
	public enum CameraFacingMode
	{
		BillBoard,
		Horizontal,
		Vertical,
		Never
	}

	public Material spriteSheetMaterial;

	public int spriteCount;

	public int uvAnimationTileX;

	public int uvAnimationTileY;

	public int framesPerSecond;

	public Vector3 size = new Vector3(1f, 1f, 1f);

	public float speedGrowing;

	public bool randomRotation;

	public bool isOneShot = true;

	public CameraFacingMode billboarding;

	public bool addLightEffect;

	public float lightRange;

	public UnityEngine.Color lightColor;

	public float lightFadeSpeed = 1f;

	private Material mat;

	private Mesh mesh;

	private MeshRenderer meshRender;

	private AudioSource soundEffect;

	private float startTime;

	private Camera mainCam;

	private bool effectEnd;

	private float randomZAngle;

	private void Awake()
	{
		CreateParticle();
		mainCam = GameObject.FindGameObjectWithTag("MainCamera").GetComponent<Camera>();
		soundEffect = GetComponent("AudioSource") as AudioSource;
		if (addLightEffect)
		{
			base.gameObject.AddComponent<Light>();
			base.gameObject.GetComponent<Light>().color = lightColor;
			base.gameObject.GetComponent<Light>().range = lightRange;
		}
		GetComponent<Renderer>().enabled = false;
	}

	private void Start()
	{
		startTime = Time.time;
		base.transform.localScale = size;
		if (randomRotation)
		{
			randomZAngle = UnityEngine.Random.Range(-180f, 180f);
		}
		else
		{
			randomZAngle = 0f;
		}
	}

	private void Update()
	{
		bool flag = false;
		Camera_BillboardingMode();
		float num = (Time.time - startTime) * (float)framesPerSecond;
		if ((num <= (float)spriteCount || !isOneShot) && !effectEnd)
		{
			num %= (float)(uvAnimationTileX * uvAnimationTileY);
			if (num == (float)spriteCount)
			{
				startTime = Time.time;
				num = 0f;
			}
			Vector2 value = new Vector2(1f / (float)uvAnimationTileX, 1f / (float)uvAnimationTileY);
			float num2 = Mathf.Floor(num % (float)uvAnimationTileX);
			float num3 = Mathf.Floor(num / (float)uvAnimationTileX);
			Vector2 value2 = new Vector2(num2 * value.x, 1f - value.y - num3 * value.y);
			GetComponent<Renderer>().material.SetTextureOffset("_MainTex", value2);
			GetComponent<Renderer>().material.SetTextureScale("_MainTex", value);
			base.transform.localScale += new Vector3(speedGrowing, speedGrowing, speedGrowing) * Time.deltaTime;
			GetComponent<Renderer>().enabled = true;
		}
		else
		{
			effectEnd = true;
			GetComponent<Renderer>().enabled = false;
			flag = true;
			if ((bool)soundEffect && soundEffect.isPlaying)
			{
				flag = false;
			}
			if (addLightEffect && flag && base.gameObject.GetComponent<Light>().intensity > 0f)
			{
				flag = false;
			}
			if (flag)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		if (addLightEffect && lightFadeSpeed != 0f)
		{
			base.gameObject.GetComponent<Light>().intensity -= lightFadeSpeed * Time.deltaTime;
		}
	}

	private void CreateParticle()
	{
		mesh = base.gameObject.AddComponent<MeshFilter>().mesh;
		meshRender = base.gameObject.AddComponent<MeshRenderer>();
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 2, 3, 0 };
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		meshRender.shadowCastingMode = ShadowCastingMode.Off;
		meshRender.receiveShadows = false;
		mesh.RecalculateNormals();
		GetComponent<Renderer>().material = spriteSheetMaterial;
	}

	private void Camera_BillboardingMode()
	{
		Vector3 vector = mainCam.transform.position - base.transform.position;
		switch (billboarding)
		{
		case CameraFacingMode.BillBoard:
			base.transform.LookAt(vector);
			break;
		case CameraFacingMode.Horizontal:
			vector.x = (vector.z = 0f);
			base.transform.LookAt(mainCam.transform.position - vector);
			break;
		case CameraFacingMode.Vertical:
			vector.y = (vector.z = 0f);
			base.transform.LookAt(mainCam.transform.position - vector);
			break;
		}
		base.transform.eulerAngles = new Vector3(base.transform.eulerAngles.x, base.transform.eulerAngles.y, randomZAngle);
	}
}
public class CarCamera : UnityEngine.MonoBehaviour
{
	public Transform target;

	public float height = 1f;

	public float positionDamping = 3f;

	public float velocityDamping = 3f;

	public float distance = 4f;

	public LayerMask ignoreLayers = -1;

	private RaycastHit hit = default(RaycastHit);

	private Vector3 prevVelocity = Vector3.zero;

	private LayerMask raycastLayers = -1;

	private Vector3 currentVelocity = Vector3.zero;

	private void Start()
	{
		raycastLayers = ~(int)ignoreLayers;
	}

	private void FixedUpdate()
	{
		currentVelocity = Vector3.Lerp(prevVelocity, target.root.GetComponent<Rigidbody>().velocity, velocityDamping * Time.deltaTime);
		currentVelocity.y = 0f;
		prevVelocity = currentVelocity;
	}

	private void LateUpdate()
	{
		float t = Mathf.Clamp01(target.root.GetComponent<Rigidbody>().velocity.magnitude / 70f);
		GetComponent<Camera>().fieldOfView = Mathf.Lerp(55f, 72f, t);
		float num = Mathf.Lerp(7.5f, 6.5f, t);
		currentVelocity = currentVelocity.normalized;
		Vector3 vector = target.position + Vector3.up * height;
		Vector3 vector2 = vector - currentVelocity * num;
		vector2.y = vector.y;
		Vector3 direction = vector2 - vector;
		if (Physics.Raycast(vector, direction, out hit, num, raycastLayers))
		{
			vector2 = hit.point;
		}
		base.transform.position = vector2;
		base.transform.LookAt(vector);
	}
}
public class Fog : UnityEngine.MonoBehaviour
{
	public UnityEngine.Color fogColor;

	private void Start()
	{
		RenderSettings.fogColor = fogColor;
	}
}
public class Kart : UnityEngine.MonoBehaviour
{
	public WheelCollider Fleft;

	public WheelCollider Fright;

	public WheelCollider Rleft;

	public WheelCollider Rright;

	public GameObject fLeftModel;

	public GameObject fRightModel;

	public GameObject rLeftModel;

	public GameObject rRightModel;

	public GameObject volant;

	public float AntiRoll;

	private Vector3 startPosition;

	private Vector3 startRotation;

	private float power;

	private float steerPower;

	private float speed;

	private void Start()
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation.eulerAngles;
	}

	private void OnGUI()
	{
		GUI.color = UnityEngine.Color.red;
		GUILayout.Label("Arrow key to move");
		GUILayout.Label("Esc to restart");
		GUILayout.Label("Space to reset");
		GUILayout.Label("It's an example, you must implement your own physic");
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.Escape))
		{
			GetComponent<Rigidbody>().freezeRotation = true;
			GetComponent<Rigidbody>().transform.eulerAngles = Vector3.zero;
			GetComponent<Rigidbody>().freezeRotation = false;
			if (Input.GetKey(KeyCode.Escape))
			{
				base.transform.position = startPosition;
				base.transform.rotation = Quaternion.Euler(startRotation);
			}
		}
	}

	private void OnCollisionEnter()
	{
		GetComponent<AudioSource>().pitch = 0.5f;
	}

	private void FixedUpdate()
	{
		speed = Fleft.rpm / 60f * 2f * (float)Math.PI * 0.45f * 3.6f;
		GetComponent<AudioSource>().pitch = 0.5f + speed / 200f;
		float axis = Input.GetAxis("Vertical");
		float axis2 = Input.GetAxis("Horizontal");
		if (axis != 0f)
		{
			power += 10f * Time.deltaTime;
			power = Mathf.Clamp(power, -50f, 60f);
			Rleft.brakeTorque = 0f;
			Rright.brakeTorque = 0f;
		}
		else
		{
			power -= 10f * Time.deltaTime;
			power = Mathf.Clamp(power, 0f, 60f);
			Rleft.brakeTorque = 10f;
			Rright.brakeTorque = 10f;
		}
		Rleft.motorTorque = axis * power;
		Rright.motorTorque = axis * power;
		if (axis2 != 0f)
		{
			steerPower += 0.3f;
		}
		else
		{
			steerPower = 0f;
		}
		if (speed > 0f)
		{
			Fleft.steerAngle = axis2 * steerPower;
			Fright.steerAngle = axis2 * steerPower;
		}
		GetComponent<Rigidbody>().velocity = Vector3.ClampMagnitude(GetComponent<Rigidbody>().velocity, 70f);
		if (axis2 != 0f)
		{
			GetComponent<Rigidbody>().AddForceAtPosition(Fleft.transform.up * (0f - AntiRoll), Fleft.transform.position);
			GetComponent<Rigidbody>().AddForceAtPosition(Fright.transform.up * (0f - AntiRoll), Fright.transform.position);
			GetComponent<Rigidbody>().AddForceAtPosition(Rleft.transform.up * (0f - AntiRoll), Rleft.transform.position);
			GetComponent<Rigidbody>().AddForceAtPosition(Rright.transform.up * (0f - AntiRoll), Rright.transform.position);
		}
		fLeftModel.transform.Rotate(Vector3.right * Fleft.rpm * Time.deltaTime);
		fRightModel.transform.Rotate(Vector3.right * Fright.rpm * Time.deltaTime);
		rLeftModel.transform.Rotate(Vector3.right * Rleft.rpm * Time.deltaTime);
		rRightModel.transform.Rotate(Vector3.right * Rright.rpm * Time.deltaTime);
		GetComponent<Rigidbody>().centerOfMass = new Vector3(0f, -2f * axis);
		volant.transform.Rotate(Vector3.up * axis2, Space.Self);
	}
}
public class LevelJump : UnityEngine.MonoBehaviour
{
	public string levelName;

	private void OnTriggerEnter()
	{
		UnityEngine.Application.LoadLevel(levelName);
	}
}
public class RotateObject : UnityEngine.MonoBehaviour
{
	public Vector3 axisSpeed;

	private void Update()
	{
		base.transform.Rotate(axisSpeed * Time.deltaTime);
	}
}
public class Spawner : UnityEngine.MonoBehaviour
{
	public Vector3 startPosition;

	public float underY;

	private void Start()
	{
		base.transform.position = startPosition;
	}

	private void Update()
	{
		if (base.transform.position.y < underY)
		{
			base.transform.position = startPosition;
		}
	}
}
public class AnimatedUVs : UnityEngine.MonoBehaviour
{
	public int materialIndex;

	public Vector2 uvAnimationRate = new Vector2(1f, 0f);

	public string textureName = "_MainTex";

	private Vector2 uvOffset = Vector2.zero;

	private void LateUpdate()
	{
		uvOffset += uvAnimationRate * Time.deltaTime;
		if (GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().materials[materialIndex].SetTextureOffset(textureName, uvOffset);
		}
	}
}
public class BillboardLaub : UnityEngine.MonoBehaviour
{
	private Transform mainCamTransform;

	private Transform cachedTransform;

	private void Start()
	{
		mainCamTransform = Camera.main.transform;
		cachedTransform = base.transform;
	}

	private void Update()
	{
		if (mainCamTransform.InverseTransformPoint(cachedTransform.position).z >= 0f)
		{
			Vector3 vector = mainCamTransform.position - cachedTransform.position;
			vector.x = (vector.z = 0f);
			cachedTransform.LookAt(mainCamTransform.position - vector);
			GetComponent<Renderer>().enabled = true;
		}
		else
		{
			GetComponent<Renderer>().enabled = false;
		}
	}
}
public class Butterfly : UnityEngine.MonoBehaviour
{
	public Vector3 zoneSize = Vector3.one;

	public GameObject[] butterflyObjects;

	public int butterflyCount;

	public float maxSpeed = 1f;

	public float arrivalRadius = 0.2f;

	private Vector3[] targets;

	private Transform[] flies;

	private Vector3[] velocities;

	private void Start()
	{
		targets = new Vector3[butterflyCount];
		flies = new Transform[butterflyCount];
		velocities = new Vector3[butterflyCount];
		for (int i = 0; i < butterflyCount; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(butterflyObjects[UnityEngine.Random.Range(0, butterflyObjects.Length - 1)], new Vector3(base.transform.position.x + UnityEngine.Random.Range(0f - zoneSize.x, zoneSize.x) / 2f, base.transform.position.y + UnityEngine.Random.Range(0f - zoneSize.y, zoneSize.y) / 2f, base.transform.position.z + UnityEngine.Random.Range(0f - zoneSize.z, zoneSize.z) / 2f), Quaternion.identity);
			gameObject.transform.parent = Gameplay.Instance.transform;
			flies[i] = gameObject.transform;
			ref Vector3 reference = ref targets[i];
			reference = GetRandomTarget(flies[i].position);
		}
	}

	private void Update()
	{
		for (int i = 0; i < butterflyCount; i++)
		{
			flies[i].LookAt(targets[i]);
			if (Seek(i))
			{
				ref Vector3 reference = ref targets[i];
				reference = GetRandomTarget(flies[i].position);
			}
		}
	}

	private Vector3 GetRandomTarget(Vector3 position)
	{
		return new Vector3(base.transform.position.x + UnityEngine.Random.Range(0f - zoneSize.x, zoneSize.x) / 2f, base.transform.position.y + UnityEngine.Random.Range(0f - zoneSize.y, zoneSize.y) / 2f, base.transform.position.z + UnityEngine.Random.Range(0f - zoneSize.z, zoneSize.z) / 2f);
	}

	private bool Seek(int index)
	{
		flies[index].position += velocities[index];
		Vector3 vector = targets[index] - flies[index].position;
		if (vector.magnitude > arrivalRadius)
		{
			vector.Normalize();
			vector *= maxSpeed * Time.deltaTime;
			velocities[index] = vector;
			return false;
		}
		return true;
	}
}
public class FpsCounter : UnityEngine.MonoBehaviour
{
	private int frame;

	private double frameStartTime;

	private float fps;

	private bool bShow;

	private void Start()
	{
		frameStartTime = Time.realtimeSinceStartup;
		bShow = true;
	}

	private void Update()
	{
		frame++;
		if ((double)Time.realtimeSinceStartup - frameStartTime > 1.0)
		{
			fps = frame;
			frame = 0;
			frameStartTime = Time.realtimeSinceStartup;
		}
		if (Input.GetKeyDown(KeyCode.F1))
		{
			if (bShow)
			{
				bShow = false;
			}
			else
			{
				bShow = true;
			}
		}
	}

	private void OnGUI()
	{
		if (bShow)
		{
			GUI.Label(new Rect(0f, 0f, 200f, 20f), "FPS : " + fps.ToString("f2"));
		}
	}
}
public class HTLiquidSpriteSheet : UnityEngine.MonoBehaviour
{
	private Texture2D[] _diffuseTexture;

	public int uvAnimationTileX;

	public int uvAnimationTileY;

	public int spriteCount;

	public int framesPerSecond;

	public Vector2 textureSize;

	public Vector2 scrollSpeed;

	private float _startTime;

	private Vector2 currentOffset;

	private void Start()
	{
		_diffuseTexture = new Texture2D[spriteCount];
		InitSpriteTexture();
		_startTime = Time.time;
	}

	private void Update()
	{
		GetComponent<Renderer>().material.SetTextureScale("_MainTex", new Vector2(1f, 1f));
		float num = (Time.time - _startTime) * (float)framesPerSecond;
		num %= (float)(uvAnimationTileX * uvAnimationTileY);
		if (num == (float)spriteCount)
		{
			_startTime = Time.time;
			num = 0f;
		}
		GetComponent<Renderer>().material.SetTextureScale("_MainTex", textureSize);
		currentOffset += scrollSpeed * Time.deltaTime;
		GetComponent<Renderer>().material.SetTextureOffset("_MainTex", currentOffset);
		GetComponent<Renderer>().material.SetTexture("_MainTex", _diffuseTexture[(int)num]);
	}

	public void InitSpriteTexture()
	{
		Texture2D texture2D = (Texture2D)GetComponent<Renderer>().material.GetTexture("_MainTex");
		int num = GetComponent<Renderer>().material.mainTexture.width / uvAnimationTileX;
		int num2 = GetComponent<Renderer>().material.mainTexture.height / uvAnimationTileY;
		int num3 = 0;
		int num4 = 0;
		int num5 = uvAnimationTileY - 1;
		while (num5 >= 0 && num3 < spriteCount)
		{
			while (num4 < uvAnimationTileX && num3 < spriteCount)
			{
				UnityEngine.Color[] pixels = texture2D.GetPixels(num * num4, num2 * num5, num, num2);
				_diffuseTexture[num3] = new Texture2D(num, num2);
				_diffuseTexture[num3].SetPixels(pixels);
				_diffuseTexture[num3].Apply();
				num4++;
				num3++;
			}
			num4 = 0;
			num5--;
		}
	}
}
public class HTSpriteSheet : UnityEngine.MonoBehaviour
{
	public enum CameraFacingMode
	{
		BillBoard,
		Horizontal,
		Vertical,
		Never
	}

	public Material spriteSheetMaterial;

	public int spriteCount;

	public int uvAnimationTileX;

	public int uvAnimationTileY;

	public int framesPerSecond;

	public Vector3 sizeStart = new Vector3(1f, 1f, 1f);

	public Vector3 sizeEnd = new Vector3(1f, 1f, 1f);

	public bool randomRotation;

	public float rotationStart;

	public float rotationEnd;

	public bool isOneShot = true;

	public float life;

	public CameraFacingMode billboarding;

	public bool addLightEffect;

	public float lightRange;

	public UnityEngine.Color lightColor;

	public float lightFadeSpeed = 1f;

	public bool addColorEffect;

	public UnityEngine.Color colorStart = new UnityEngine.Color(1f, 1f, 1f, 1f);

	public UnityEngine.Color colorEnd = new UnityEngine.Color(1f, 1f, 1f, 1f);

	public bool foldOut;

	public Vector3 offset;

	public float waittingTime;

	public bool copy;

	private Mesh mesh;

	private MeshRenderer meshRender;

	private AudioSource soundEffect;

	private float startTime;

	private Transform mainCamTransform;

	private bool effectEnd;

	private float randomZAngle;

	private UnityEngine.Color colorStep;

	private UnityEngine.Color currentColor;

	private Vector3 sizeStep;

	private Vector3 currentSize;

	private float currentRotation;

	private float rotationStep;

	private float lifeStart;

	private Transform myTransform;

	private void Awake()
	{
		CreateParticle();
		mainCamTransform = Camera.main.transform;
		soundEffect = GetComponent<AudioSource>();
		if (addLightEffect)
		{
			base.gameObject.AddComponent<Light>();
			base.gameObject.GetComponent<Light>().color = lightColor;
			base.gameObject.GetComponent<Light>().range = lightRange;
		}
		GetComponent<Renderer>().enabled = false;
	}

	private void Start()
	{
		InitSpriteSheet();
	}

	private void Update()
	{
		bool flag = false;
		Camera_BillboardingMode();
		float num = (Time.time - startTime) * (float)framesPerSecond;
		if (!isOneShot && life > 0f && Time.time - lifeStart > life)
		{
			effectEnd = true;
		}
		if ((num <= (float)spriteCount || !isOneShot) && !effectEnd)
		{
			if (num >= (float)spriteCount)
			{
				startTime = Time.time;
				num = 0f;
				if (addColorEffect)
				{
					currentColor = colorStart;
					meshRender.material.SetColor("_Color", currentColor);
				}
				currentSize = sizeStart;
				myTransform.localScale = currentSize;
				if (randomRotation)
				{
					currentRotation = UnityEngine.Random.Range(-180f, 180f);
				}
				else
				{
					currentRotation = rotationStart;
				}
			}
			num %= (float)(uvAnimationTileX * uvAnimationTileY);
			Vector2 value = new Vector2(1f / (float)uvAnimationTileX, 1f / (float)uvAnimationTileY);
			float num2 = Mathf.Floor(num % (float)uvAnimationTileX);
			float num3 = Mathf.Floor(num / (float)uvAnimationTileX);
			Vector2 value2 = new Vector2(num2 * value.x, 1f - value.y - num3 * value.y);
			GetComponent<Renderer>().material.SetTextureOffset("_MainTex", value2);
			GetComponent<Renderer>().material.SetTextureScale("_MainTex", value);
			GetComponent<Renderer>().enabled = true;
		}
		else
		{
			effectEnd = true;
			GetComponent<Renderer>().enabled = false;
			flag = true;
			if ((bool)soundEffect && soundEffect.isPlaying)
			{
				flag = false;
			}
			if (addLightEffect && flag && base.gameObject.GetComponent<Light>().intensity > 0f)
			{
				flag = false;
			}
			if (flag)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		if (sizeStart != sizeEnd)
		{
			myTransform.localScale += sizeStep * Time.deltaTime;
		}
		if (addLightEffect && lightFadeSpeed != 0f)
		{
			base.gameObject.GetComponent<Light>().intensity -= lightFadeSpeed * Time.deltaTime;
		}
		if (addColorEffect)
		{
			currentColor = new UnityEngine.Color(currentColor.r + colorStep.r * Time.deltaTime, currentColor.g + colorStep.g * Time.deltaTime, currentColor.b + colorStep.b * Time.deltaTime, currentColor.a + colorStep.a * Time.deltaTime);
			meshRender.material.SetColor("_TintColor", currentColor);
		}
	}

	private void CreateParticle()
	{
		mesh = base.gameObject.AddComponent<MeshFilter>().mesh;
		meshRender = base.gameObject.AddComponent<MeshRenderer>();
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 2, 3, 0 };
		mesh.uv = new Vector2[4]
		{
			new Vector2(1f, 0f),
			new Vector2(1f, 1f),
			new Vector2(0f, 1f),
			new Vector2(0f, 0f)
		};
		meshRender.shadowCastingMode = ShadowCastingMode.Off;
		meshRender.receiveShadows = false;
		mesh.RecalculateNormals();
		GetComponent<Renderer>().material = spriteSheetMaterial;
	}

	private void Camera_BillboardingMode()
	{
		Vector3 vector = mainCamTransform.position - myTransform.position;
		switch (billboarding)
		{
		case CameraFacingMode.BillBoard:
			myTransform.LookAt(mainCamTransform.position - vector);
			myTransform.LookAt(mainCamTransform.position);
			break;
		case CameraFacingMode.Horizontal:
			vector.x = (vector.z = 0f);
			myTransform.LookAt(mainCamTransform.position - vector);
			break;
		case CameraFacingMode.Vertical:
			vector.y = (vector.z = 0f);
			myTransform.LookAt(mainCamTransform.position - vector);
			break;
		}
		if (rotationStart != rotationEnd)
		{
			currentRotation += rotationStep * Time.deltaTime;
		}
	}

	public void InitSpriteSheet()
	{
		startTime = Time.time;
		lifeStart = Time.time;
		myTransform = base.transform;
		float num = (float)spriteCount / (float)framesPerSecond;
		sizeStep = new Vector3((sizeEnd.x - sizeStart.x) / num, (sizeEnd.y - sizeStart.y) / num, (sizeEnd.z - sizeStart.z) / num);
		currentSize = sizeStart;
		myTransform.localScale = currentSize;
		rotationStep = (rotationEnd - rotationStart) / num;
		if (randomRotation)
		{
			currentRotation = UnityEngine.Random.Range(-180f, 180f);
		}
		else
		{
			currentRotation = rotationStart;
		}
		if (addColorEffect)
		{
			colorStep = new UnityEngine.Color((colorEnd.r - colorStart.r) / num, (colorEnd.g - colorStart.g) / num, (colorEnd.b - colorStart.b) / num, (colorEnd.a - colorStart.a) / num);
			currentColor = colorStart;
			meshRender.material.SetColor("_TintColor", currentColor);
		}
	}
}
public class LightProbeMerge : UnityEngine.MonoBehaviour
{
	[SerializeField]
	private string NameOfNewGroup;

	[Tooltip("If a probe exists, it will get replaced")]
	[SerializeField]
	private bool RemoveExistingProbeGroup;

	[SerializeField]
	private LightProbeGroup[] ProbeGroupsToMerge;

	public void MergeProbeGroups()
	{
		if (ProbeGroupsToMerge.Length == 0)
		{
			return;
		}
		string text = NameOfNewGroup;
		int num = 1;
		if (RemoveExistingProbeGroup)
		{
			LightProbeGroup[] array = UnityEngine.Object.FindObjectsOfType<LightProbeGroup>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].name == NameOfNewGroup)
				{
					UnityEngine.Object.DestroyImmediate(array[i].gameObject);
					break;
				}
			}
		}
		else
		{
			bool flag = false;
			do
			{
				flag = false;
				LightProbeGroup[] array2 = UnityEngine.Object.FindObjectsOfType<LightProbeGroup>();
				for (int j = 0; j < array2.Length; j++)
				{
					if (array2[j].name == text)
					{
						text = NameOfNewGroup + "_" + num;
						num++;
						flag = true;
						break;
					}
				}
			}
			while (flag);
		}
		GameObject gameObject = new GameObject();
		LightProbeGroup lightProbeGroup = gameObject.AddComponent<LightProbeGroup>();
		gameObject.name = text;
		int num2 = 0;
		for (int k = 0; k < ProbeGroupsToMerge.Length; k++)
		{
			num2 += ProbeGroupsToMerge[k].probePositions.Length;
		}
		Vector3[] array3 = new Vector3[num2];
		int num3 = 0;
		for (int l = 0; l < ProbeGroupsToMerge.Length; l++)
		{
			for (int m = 0; m < ProbeGroupsToMerge[l].probePositions.Length; m++)
			{
				Vector3 vector = ProbeGroupsToMerge[l].probePositions[m] + ProbeGroupsToMerge[l].transform.position;
				vector -= ProbeGroupsToMerge[l].transform.position;
				vector.x *= ProbeGroupsToMerge[l].transform.localScale.x;
				vector.y *= ProbeGroupsToMerge[l].transform.localScale.y;
				vector.z *= ProbeGroupsToMerge[l].transform.localScale.z;
				vector = ProbeGroupsToMerge[l].transform.rotation * vector;
				vector += ProbeGroupsToMerge[l].transform.position;
				array3[num3++] = vector;
			}
		}
		lightProbeGroup.probePositions = array3;
	}
}
public class BakeTexturesAtRuntime : UnityEngine.MonoBehaviour
{
	public GameObject target;

	private float elapsedTime;

	private MB3_TextureBaker.CreateAtlasesCoroutineResult result = new MB3_TextureBaker.CreateAtlasesCoroutineResult();

	private void OnGUI()
	{
		GUILayout.Label("Time to bake textures: " + elapsedTime);
		if (GUILayout.Button("Combine textures & build combined mesh all at once"))
		{
			MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
			MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
			component.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component.resultMaterial = new Material(Shader.Find("Diffuse"));
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			component.CreateAtlases();
			elapsedTime = Time.realtimeSinceStartup - realtimeSinceStartup;
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		if (GUILayout.Button("Combine textures & build combined mesh using coroutine"))
		{
			UnityEngine.Debug.Log("Starting to bake textures on frame " + Time.frameCount);
			MB3_TextureBaker component2 = target.GetComponent<MB3_TextureBaker>();
			component2.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component2.resultMaterial = new Material(Shader.Find("Diffuse"));
			component2.onBuiltAtlasesSuccess = OnBuiltAtlasesSuccess;
			StartCoroutine(component2.CreateAtlasesCoroutine(null, result));
		}
	}

	private void OnBuiltAtlasesSuccess()
	{
		UnityEngine.Debug.Log("Calling success callback. baking meshes");
		MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
		MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
		if (result.isFinished && result.success)
		{
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		UnityEngine.Debug.Log("Completed baking textures on frame " + Time.frameCount);
	}
}
public class MB_BatchPrepareObjectsForDynamicBatchingDescription : UnityEngine.MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene is set up to create a combined material and meshes with adjusted UVs so \n objects can share a material and be batched by Unity's static/dynamic batching.\n This scene has added a BatchPrefabBaker component to a Mesh and Material Baker which \n  can bake many prefabs (each of which can have several renderers) in one click.\n The batching tool accepts prefab assets instead of scene objects. \n");
	}
}
public class MB_PrepareObjectsForDynamicBatchingDescription : UnityEngine.MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene creates a combined material and meshes with adjusted UVs so objects \n can share a material and be batched by Unity's static/dynamic batching.\n Output has been set to 'bakeMeshAssetsInPlace' on the Mesh Baker\n Position, Scale and Rotation will be baked into meshes so place them appropriately.\n Dynamic batching requires objects with uniform scale. You can fix non-uniform scale here\n After baking you need to duplicate your source prefab assets and replace the  \n meshes and materials with the generated ones.\n");
	}
}
public class MB_DynamicAddDeleteExample : UnityEngine.MonoBehaviour
{
	public GameObject prefab;

	private List<GameObject> objsInCombined = new List<GameObject>();

	private MB3_MeshBaker mbd;

	private GameObject[] objs;

	private float GaussianValue()
	{
		float num;
		float num3;
		do
		{
			num = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			float num2 = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			num3 = num * num + num2 * num2;
		}
		while (num3 >= 1f);
		num3 = Mathf.Sqrt(-2f * Mathf.Log(num3) / num3);
		return num * num3;
	}

	private void Start()
	{
		mbd = GetComponentInChildren<MB3_MeshBaker>();
		int num = 25;
		GameObject[] array = new GameObject[num * num];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
				array[i * num + j] = gameObject.GetComponentInChildren<MeshRenderer>().gameObject;
				float num2 = UnityEngine.Random.Range(-4f, 4f);
				float num3 = UnityEngine.Random.Range(-4f, 4f);
				gameObject.transform.position = new Vector3(9f * (float)i + num2, 0f, 9f * (float)j + num3);
				float y = UnityEngine.Random.Range(0, 360);
				gameObject.transform.rotation = Quaternion.Euler(0f, y, 0f);
				Vector3 localScale = Vector3.one + Vector3.one * GaussianValue() * 0.15f;
				gameObject.transform.localScale = localScale;
				if ((i * num + j) % 3 == 0)
				{
					objsInCombined.Add(array[i * num + j]);
				}
			}
		}
		mbd.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		mbd.Apply();
		objs = objsInCombined.ToArray();
		StartCoroutine(largeNumber());
	}

	private IEnumerator largeNumber()
	{
		while (true)
		{
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(null, objs, disableRendererInSource: true);
			mbd.Apply();
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(objs, null, disableRendererInSource: true);
			mbd.Apply();
		}
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically instantiates game objects. \nRepeatedly adds and removes some of them\n from the combined mesh.");
	}
}
public class MB_Example : UnityEngine.MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public GameObject[] objsToCombine;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToCombine, null, disableRendererInSource: true);
		meshbaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToCombine);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: false, uv2: false, uv3: false, uv4: false, colors: false);
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically updates the vertices, normals and tangents in combined mesh every frame.\nThis is similar to dynamic batching. It is not recommended to do this every frame.\nAlso consider baking the mesh renderer objects into a skinned mesh renderer\nThe skinned mesh approach is faster for objects that need to move independently of each other every frame.");
	}
}
public class MB_ExampleMover : UnityEngine.MonoBehaviour
{
	public int axis;

	private void Update()
	{
		Vector3 position = new Vector3(5f, 5f, 5f);
		position[axis] *= Mathf.Sin(Time.time);
		base.transform.position = position;
	}
}
public class MB_ExampleSkinnedMeshDescription : UnityEngine.MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("Mesh Renderer objects have been baked into a skinned mesh. Each source object\n is still in the scene (with renderer disabled) and becomes a bone. Any scripts, animations,\n or physics that affect the invisible source objects will be visible in the\nSkinned Mesh. This approach is more efficient than either dynamic batching or updating every frame \n for many small objects that constantly and independently move. \n With this approach pay attention to the SkinnedMeshRenderer Bounds and Animation Culling\nsettings. You may need to write your own script to manage/update these or your object may vanish or stop animating.\n You can update the combined mesh at runtime as objects are added and deleted from the scene.");
	}
}
public class MB_SkinnedMeshSceneController : UnityEngine.MonoBehaviour
{
	public GameObject swordPrefab;

	public GameObject hatPrefab;

	public GameObject glassesPrefab;

	public GameObject workerPrefab;

	public GameObject targetCharacter;

	public MB3_MeshBaker skinnedMeshBaker;

	private GameObject swordInstance;

	private GameObject glassesInstance;

	private GameObject hatInstance;

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(workerPrefab);
		gameObject.transform.position = new Vector3(1.31f, 0.985f, -0.25f);
		Animation component = gameObject.GetComponent<Animation>();
		component.wrapMode = WrapMode.Loop;
		component.cullingType = AnimationCullingType.AlwaysAnimate;
		component.Play("run");
		GameObject[] gos = new GameObject[1] { gameObject.GetComponentInChildren<SkinnedMeshRenderer>().gameObject };
		skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		skinnedMeshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Add/Remove Sword"))
		{
			if (swordInstance == null)
			{
				Transform parent = SearchHierarchyForBone(targetCharacter.transform, "RightHandAttachPoint");
				swordInstance = UnityEngine.Object.Instantiate(swordPrefab);
				swordInstance.transform.parent = parent;
				swordInstance.transform.localPosition = Vector3.zero;
				swordInstance.transform.localRotation = Quaternion.identity;
				swordInstance.transform.localScale = Vector3.one;
				GameObject[] gos = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(swordInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(swordInstance);
				swordInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Hat"))
		{
			if (hatInstance == null)
			{
				Transform parent2 = SearchHierarchyForBone(targetCharacter.transform, "HeadAttachPoint");
				hatInstance = UnityEngine.Object.Instantiate(hatPrefab);
				hatInstance.transform.parent = parent2;
				hatInstance.transform.localPosition = Vector3.zero;
				hatInstance.transform.localRotation = Quaternion.identity;
				hatInstance.transform.localScale = Vector3.one;
				GameObject[] gos2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos2, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(hatInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs2, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(hatInstance);
				hatInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Glasses"))
		{
			if (glassesInstance == null)
			{
				Transform parent3 = SearchHierarchyForBone(targetCharacter.transform, "NoseAttachPoint");
				glassesInstance = UnityEngine.Object.Instantiate(glassesPrefab);
				glassesInstance.transform.parent = parent3;
				glassesInstance.transform.localPosition = Vector3.zero;
				glassesInstance.transform.localRotation = Quaternion.identity;
				glassesInstance.transform.localScale = Vector3.one;
				GameObject[] gos3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos3, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs3, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(glassesInstance);
				glassesInstance = null;
			}
		}
	}

	public Transform SearchHierarchyForBone(Transform current, string name)
	{
		if (current.name.Equals(name))
		{
			return current;
		}
		for (int i = 0; i < current.childCount; i++)
		{
			Transform transform = SearchHierarchyForBone(current.GetChild(i), name);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}
}
[Serializable]
public class MB_AtlasesAndRects
{
	public Texture2D[] atlases;

	[NonSerialized]
	public List<MB_MaterialAndUVRect> mat2rect_map;

	public string[] texPropertyNames;
}
[Serializable]
public class MB_MultiMaterial
{
	public Material combinedMaterial;

	public bool considerMeshUVs;

	public List<Material> sourceMaterials = new List<Material>();
}
[Serializable]
public class MB_MaterialAndUVRect
{
	public Material material;

	public Rect atlasRect;

	public string srcObjName;

	public Rect samplingRectMatAndUVTiling;

	public Rect sourceMaterialTiling;

	public Rect samplingEncapsulatinRect;

	public MB_MaterialAndUVRect(Material m, Rect destRect, Rect samplingRectMatAndUVTiling, Rect sourceMaterialTiling, Rect samplingEncapsulatinRect, string objName)
	{
		material = m;
		atlasRect = destRect;
		this.samplingRectMatAndUVTiling = samplingRectMatAndUVTiling;
		this.sourceMaterialTiling = sourceMaterialTiling;
		this.samplingEncapsulatinRect = samplingEncapsulatinRect;
		srcObjName = objName;
	}

	public override int GetHashCode()
	{
		return material.GetInstanceID() ^ samplingEncapsulatinRect.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (!(obj is MB_MaterialAndUVRect))
		{
			return false;
		}
		return material == ((MB_MaterialAndUVRect)obj).material && samplingEncapsulatinRect == ((MB_MaterialAndUVRect)obj).samplingEncapsulatinRect;
	}
}
public class MB2_TextureBakeResults : ScriptableObject
{
	public class Material2AtlasRectangleMapper
	{
		private MB2_TextureBakeResults tbr;

		private int[] numTimesMatAppearsInAtlas;

		private MB_MaterialAndUVRect[] matsAndSrcUVRect;

		public Material2AtlasRectangleMapper(MB2_TextureBakeResults res)
		{
			tbr = res;
			matsAndSrcUVRect = res.materialsAndUVRects;
			numTimesMatAppearsInAtlas = new int[matsAndSrcUVRect.Length];
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (numTimesMatAppearsInAtlas[i] > 1)
				{
					continue;
				}
				int num = 1;
				for (int j = i + 1; j < matsAndSrcUVRect.Length; j++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[j].material)
					{
						num++;
					}
				}
				numTimesMatAppearsInAtlas[i] = num;
				if (num <= 1)
				{
					continue;
				}
				for (int k = i + 1; k < matsAndSrcUVRect.Length; k++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[k].material)
					{
						numTimesMatAppearsInAtlas[k] = num;
					}
				}
			}
		}

		public bool TryMapMaterialToUVRect(Material mat, Mesh m, int submeshIdx, int idxInResultMats, MB3_MeshCombinerSingle.MeshChannelsCache meshChannelCache, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisCache, out Rect rectInAtlas, out Rect encapsulatingRect, out Rect sourceMaterialTilingOut, ref string errorMsg, MB2_LogLevel logLevel)
		{
			if (tbr.materialsAndUVRects.Length == 0 && tbr.materials.Length > 0)
			{
				errorMsg = "The 'Texture Bake Result' needs to be re-baked to be compatible with this version of Mesh Baker. Please re-bake using the MB3_TextureBaker.";
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			if (mat == null)
			{
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Mesh {m.name} Had no material on submesh {submeshIdx} cannot map to a material in the atlas";
				return false;
			}
			if (submeshIdx >= m.subMeshCount)
			{
				errorMsg = "Submesh index is greater than the number of submeshes";
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			int num = -1;
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (mat == matsAndSrcUVRect[i].material)
				{
					num = i;
					break;
				}
			}
			if (num == -1)
			{
				rectInAtlas = default(Rect);
				encapsulatingRect = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Material {mat.name} could not be found in the Texture Bake Result";
				return false;
			}
			if (!tbr.resultMaterials[idxInResultMats].considerMeshUVs)
			{
				if (numTimesMatAppearsInAtlas[num] != 1)
				{
					UnityEngine.Debug.LogError("There is a problem with this TextureBakeResults. FixOutOfBoundsUVs is false and a material appears more than once.");
				}
				rectInAtlas = matsAndSrcUVRect[num].atlasRect;
				encapsulatingRect = matsAndSrcUVRect[num].samplingEncapsulatinRect;
				sourceMaterialTilingOut = matsAndSrcUVRect[num].sourceMaterialTiling;
				return true;
			}
			if (!meshAnalysisCache.TryGetValue(m.GetInstanceID(), out var value))
			{
				value = new MB_Utility.MeshAnalysisResult[m.subMeshCount];
				for (int j = 0; j < m.subMeshCount; j++)
				{
					Vector2[] uv0Raw = meshChannelCache.GetUv0Raw(m);
					MB_Utility.hasOutOfBoundsUVs(uv0Raw, m, ref value[j], j);
				}
				meshAnalysisCache.Add(m.GetInstanceID(), value);
			}
			bool flag = false;
			if (logLevel >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"Trying to find a rectangle in atlas capable of holding tiled sampling rect for mesh {m} using material {mat}");
			}
			for (int k = num; k < matsAndSrcUVRect.Length; k++)
			{
				if (matsAndSrcUVRect[k].material == mat && IsMeshAndMaterialRectEnclosedByAtlasRect(value[submeshIdx].uvRect, matsAndSrcUVRect[k].sourceMaterialTiling, matsAndSrcUVRect[k].samplingEncapsulatinRect, logLevel))
				{
					if (logLevel >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log(string.Concat("Found rect in atlas capable of containing tiled sampling rect for mesh ", m, " at idx=", k));
					}
					num = k;
					flag = true;
					break;
				}
			}
			if (flag)
			{
				rectInAtlas = matsAndSrcUVRect[num].atlasRect;
				encapsulatingRect = matsAndSrcUVRect[num].samplingEncapsulatinRect;
				sourceMaterialTilingOut = matsAndSrcUVRect[num].sourceMaterialTiling;
				return true;
			}
			rectInAtlas = default(Rect);
			encapsulatingRect = default(Rect);
			sourceMaterialTilingOut = default(Rect);
			errorMsg = $"Could not find a tiled rectangle in the atlas capable of containing the uv and material tiling on mesh {m.name} for material {mat}";
			return false;
		}
	}

	private const int VERSION = 3230;

	public int version;

	public MB_MaterialAndUVRect[] materialsAndUVRects;

	public MB_MultiMaterial[] resultMaterials;

	public bool doMultiMaterial;

	public Material[] materials;

	public bool fixOutOfBoundsUVs;

	public Material resultMaterial;

	private void OnEnable()
	{
		if (version < 3230 && resultMaterials != null)
		{
			for (int i = 0; i < resultMaterials.Length; i++)
			{
				resultMaterials[i].considerMeshUVs = fixOutOfBoundsUVs;
			}
		}
		version = 3230;
	}

	public static MB2_TextureBakeResults CreateForMaterialsOnRenderer(GameObject[] gos, List<Material> matsOnTargetRenderer)
	{
		HashSet<Material> hashSet = new HashSet<Material>(matsOnTargetRenderer);
		for (int i = 0; i < gos.Length; i++)
		{
			if (gos[i] == null)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add was null");
				return null;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(gos[i]);
			if (gOMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add no renderer");
				return null;
			}
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (!hashSet.Contains(gOMaterials[j]))
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		Material[] array = new Material[hashSet.Count];
		hashSet.CopyTo(array);
		MB2_TextureBakeResults mB2_TextureBakeResults = (MB2_TextureBakeResults)ScriptableObject.CreateInstance(typeof(MB2_TextureBakeResults));
		List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
		for (int k = 0; k < array.Length; k++)
		{
			if (array[k] != null)
			{
				MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(array[k], new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), string.Empty);
				if (!list.Contains(item))
				{
					list.Add(item);
				}
			}
		}
		Material[] array2 = (mB2_TextureBakeResults.materials = new Material[list.Count]);
		mB2_TextureBakeResults.resultMaterials = new MB_MultiMaterial[list.Count];
		for (int l = 0; l < list.Count; l++)
		{
			array2[l] = list[l].material;
			mB2_TextureBakeResults.resultMaterials[l] = new MB_MultiMaterial();
			List<Material> list2 = new List<Material>();
			list2.Add(list[l].material);
			mB2_TextureBakeResults.resultMaterials[l].sourceMaterials = list2;
			mB2_TextureBakeResults.resultMaterials[l].combinedMaterial = array2[l];
			mB2_TextureBakeResults.resultMaterials[l].considerMeshUVs = false;
		}
		if (array.Length == 1)
		{
			mB2_TextureBakeResults.doMultiMaterial = false;
		}
		else
		{
			mB2_TextureBakeResults.doMultiMaterial = true;
		}
		mB2_TextureBakeResults.materialsAndUVRects = list.ToArray();
		return mB2_TextureBakeResults;
	}

	public bool DoAnyResultMatsUseConsiderMeshUVs()
	{
		if (resultMaterials == null)
		{
			return false;
		}
		for (int i = 0; i < resultMaterials.Length; i++)
		{
			if (resultMaterials[i].considerMeshUVs)
			{
				return true;
			}
		}
		return false;
	}

	public bool ContainsMaterial(Material m)
	{
		for (int i = 0; i < materialsAndUVRects.Length; i++)
		{
			if (materialsAndUVRects[i].material == m)
			{
				return true;
			}
		}
		return false;
	}

	public string GetDescription()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("Shaders:\n");
		HashSet<Shader> hashSet = new HashSet<Shader>();
		if (materialsAndUVRects != null)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				if (materialsAndUVRects[i].material != null)
				{
					hashSet.Add(materialsAndUVRects[i].material.shader);
				}
			}
		}
		foreach (Shader item in hashSet)
		{
			stringBuilder.Append("  ").Append(item.name).AppendLine();
		}
		stringBuilder.Append("Materials:\n");
		if (materialsAndUVRects != null)
		{
			for (int j = 0; j < materialsAndUVRects.Length; j++)
			{
				if (materialsAndUVRects[j].material != null)
				{
					stringBuilder.Append("  ").Append(materialsAndUVRects[j].material.name).AppendLine();
				}
			}
		}
		return stringBuilder.ToString();
	}

	public static bool IsMeshAndMaterialRectEnclosedByAtlasRect(Rect uvR, Rect sourceMaterialTiling, Rect samplingEncapsulatinRect, MB2_LogLevel logLevel)
	{
		Rect rect = default(Rect);
		Rect r = sourceMaterialTiling;
		Rect r2 = samplingEncapsulatinRect;
		MB3_UVTransformUtility.Canonicalize(ref r2, 0f, 0f);
		rect = MB3_UVTransformUtility.CombineTransforms(ref uvR, ref r);
		if (logLevel >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("uvR=" + uvR.ToString("f5") + " matR=" + r.ToString("f5") + "Potential Rect " + rect.ToString("f5") + " encapsulating=" + r2.ToString("f5"));
		}
		MB3_UVTransformUtility.Canonicalize(ref rect, r2.x, r2.y);
		if (logLevel >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("Potential Rect Cannonical " + rect.ToString("f5") + " encapsulating=" + r2.ToString("f5"));
		}
		if (MB3_UVTransformUtility.RectContains(ref r2, ref rect))
		{
			return true;
		}
		return false;
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBones : UnityEngine.MonoBehaviour
{
	private SkinnedMeshRenderer smr;

	private Transform[] bones;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBones script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		bones = smr.bones;
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, smr);
		}
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBounds : UnityEngine.MonoBehaviour
{
	public List<GameObject> objects;

	private SkinnedMeshRenderer smr;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBounds script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		if (objects == null || objects.Count == 0)
		{
			UnityEngine.Debug.LogWarning("The MB2_UpdateSkinnedMeshBoundsFromBounds had no Game Objects. It should have the same list of game objects that the MeshBaker does.");
			smr = null;
			return;
		}
		for (int i = 0; i < objects.Count; i++)
		{
			if (objects[i] == null || objects[i].GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("The list of objects had nulls or game objects without a renderer attached at position " + i);
				smr = null;
				return;
			}
		}
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null && objects != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objects, smr);
		}
	}
}
public class MB3_BatchPrefabBaker : UnityEngine.MonoBehaviour
{
	[Serializable]
	public class MB3_PrefabBakerRow
	{
		public GameObject sourcePrefab;

		public GameObject resultPrefab;
	}

	public MB3_PrefabBakerRow[] prefabRows;

	public string outputPrefabFolder;
}
public class MB3_BoneWeightCopier : UnityEngine.MonoBehaviour
{
	public GameObject inputGameObject;

	public GameObject outputPrefab;

	public float radius = 0.01f;

	public SkinnedMeshRenderer seamMesh;

	public string outputFolder;
}
public class MB3_DisableHiddenAnimations : UnityEngine.MonoBehaviour
{
	public List<Animation> animationsToCull = new List<Animation>();

	private void Start()
	{
		if (GetComponent<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogError("The MB3_CullHiddenAnimations script was placed on and object " + base.name + " which has no SkinnedMeshRenderer attached");
		}
	}

	private void OnBecameVisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = true;
			}
		}
	}

	private void OnBecameInvisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = false;
			}
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public class MBVersionConcrete : MBVersionInterface
	{
		private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

		public string version()
		{
			return "3.23.2";
		}

		public int GetMajorVersion()
		{
			string unityVersion = UnityEngine.Application.unityVersion;
			string[] array = unityVersion.Split('.');
			return int.Parse(array[0]);
		}

		public int GetMinorVersion()
		{
			string unityVersion = UnityEngine.Application.unityVersion;
			string[] array = unityVersion.Split('.');
			return int.Parse(array[1]);
		}

		public bool GetActive(GameObject go)
		{
			return go.activeInHierarchy;
		}

		public void SetActive(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public void SetActiveRecursively(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			return UnityEngine.Object.FindObjectsOfType(t);
		}

		public void OptimizeMesh(Mesh m)
		{
		}

		public bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (UnityEngine.Application.isPlaying)
			{
				return !m.isReadable;
			}
			return false;
		}

		public Vector2[] GetMeshUV1s(Mesh m, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.warn)
			{
				MB2_Log.LogDebug("UV1 does not exist in Unity 5+");
			}
			Vector2[] array = m.uv;
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv1s. Generating"));
				}
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv1s. Generating uv1s."));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					ref Vector2 reference = ref array[i];
					reference = _HALF_UV;
				}
			}
			return array;
		}

		public Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			Vector2[] array = ((!get3) ? m.uv4 : m.uv3);
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv", (!get3) ? "4" : "3", ". Generating"));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					ref Vector2 reference = ref array[i];
					reference = _HALF_UV;
				}
			}
			return array;
		}

		public void MeshClear(Mesh m, bool t)
		{
			m.Clear(t);
		}

		public void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			m.uv3 = uv3s;
		}

		public void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			m.uv4 = uv4s;
		}

		public Vector4 GetLightmapTilingOffset(Renderer r)
		{
			return r.lightmapScaleOffset;
		}

		public Transform[] GetBones(Renderer r)
		{
			if (r is SkinnedMeshRenderer)
			{
				return ((SkinnedMeshRenderer)r).bones;
			}
			if (r is MeshRenderer)
			{
				return new Transform[1] { r.transform };
			}
			UnityEngine.Debug.LogError("Could not getBones. Object does not have a renderer");
			return null;
		}

		public int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			return m.GetBlendShapeFrameCount(shapeIndex);
		}

		public float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			return m.GetBlendShapeFrameWeight(shapeIndex, frameIndex);
		}

		public void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.GetBlendShapeFrameVertices(shapeIndex, frameIndex, vs, ns, ts);
		}

		public void ClearBlendShapes(Mesh m)
		{
			m.ClearBlendShapes();
		}

		public void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.AddBlendShapeFrame(nm, wt, vs, ns, ts);
		}
	}
}
public class MB3_MeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MeshCombinerSingle _meshCombiner = new MB3_MeshCombinerSingle();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public void BuildSceneMeshObject()
	{
		_meshCombiner.BuildSceneMeshObject();
	}

	public virtual bool ShowHide(GameObject[] gos, GameObject[] deleteGOs)
	{
		return _meshCombiner.ShowHideGameObjects(gos, deleteGOs);
	}

	public virtual void ApplyShowHide()
	{
		_meshCombiner.ApplyShowHide();
	}

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOinstanceIDs, disableRendererInSource);
	}
}
public abstract class MB3_MeshBakerCommon : MB3_MeshBakerRoot
{
	public List<GameObject> objsToMesh;

	public bool useObjsToMeshFromTexBaker = true;

	public bool clearBuffersAfterBake = true;

	public string bakeAssetsInPlaceFolderPath;

	[HideInInspector]
	public GameObject resultPrefab;

	public abstract MB3_MeshCombiner meshCombiner { get; }

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return meshCombiner.textureBakeResults;
		}
		set
		{
			meshCombiner.textureBakeResults = value;
		}
	}

	public override List<GameObject> GetObjectsToCombine()
	{
		if (useObjsToMeshFromTexBaker)
		{
			MB3_TextureBaker component = base.gameObject.GetComponent<MB3_TextureBaker>();
			if (component == null)
			{
				component = base.gameObject.transform.parent.GetComponent<MB3_TextureBaker>();
			}
			if (component != null)
			{
				return component.GetObjectsToCombine();
			}
			UnityEngine.Debug.LogWarning("Use Objects To Mesh From Texture Baker was checked but no texture baker");
			return new List<GameObject>();
		}
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public void EnableDisableSourceObjectRenderers(bool show)
	{
		for (int i = 0; i < GetObjectsToCombine().Count; i++)
		{
			GameObject gameObject = GetObjectsToCombine()[i];
			if (!(gameObject != null))
			{
				continue;
			}
			Renderer renderer = MB_Utility.GetRenderer(gameObject);
			if (renderer != null)
			{
				renderer.enabled = show;
			}
			LODGroup componentInParent = renderer.GetComponentInParent<LODGroup>();
			if (!(componentInParent != null))
			{
				continue;
			}
			bool flag = true;
			LOD[] lODs = componentInParent.GetLODs();
			for (int j = 0; j < lODs.Length; j++)
			{
				for (int k = 0; k < lODs[j].renderers.Length; k++)
				{
					if (lODs[j].renderers[k] != renderer)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				componentInParent.enabled = show;
			}
		}
	}

	public virtual void ClearMesh()
	{
		meshCombiner.ClearMesh();
	}

	public virtual void DestroyMesh()
	{
		meshCombiner.DestroyMesh();
	}

	public virtual void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
	{
		meshCombiner.DestroyMeshEditor(editorMethods);
	}

	public virtual int GetNumObjectsInCombined()
	{
		return meshCombiner.GetNumObjectsInCombined();
	}

	public virtual int GetNumVerticesFor(GameObject go)
	{
		return meshCombiner.GetNumVerticesFor(go);
	}

	public MB3_TextureBaker GetTextureBaker()
	{
		MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
		if (component != null)
		{
			return component;
		}
		if (base.transform.parent != null)
		{
			return base.transform.parent.GetComponent<MB3_TextureBaker>();
		}
		return null;
	}

	public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

	public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true);

	public virtual void Apply(MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(uv2GenerationMethod);
	}

	public virtual void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
	}

	public virtual bool CombinedMeshContains(GameObject go)
	{
		return meshCombiner.CombinedMeshContains(go);
	}

	public virtual void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV1 = false, bool updateUV2 = false, bool updateColors = false, bool updateSkinningInfo = false)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.UpdateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV1, updateUV2, updateColors, updateSkinningInfo);
	}

	public virtual void UpdateSkinnedMeshApproximateBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBounds();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBones()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBones();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBounds();
		}
	}

	protected virtual bool _ValidateForUpdateSkinnedMeshBounds()
	{
		if (meshCombiner.outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
		{
			UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
			return false;
		}
		if (meshCombiner.resultSceneObject == null)
		{
			UnityEngine.Debug.LogWarning("Result Scene Object does not exist. No point in calling UpdateSkinnedMeshApproximateBounds.");
			return false;
		}
		SkinnedMeshRenderer componentInChildren = meshCombiner.resultSceneObject.GetComponentInChildren<SkinnedMeshRenderer>();
		if (componentInChildren == null)
		{
			UnityEngine.Debug.LogWarning("No SkinnedMeshRenderer on result scene object.");
			return false;
		}
		return true;
	}
}
public class MB3_MeshBakerGrouper : UnityEngine.MonoBehaviour
{
	public enum ClusterType
	{
		none,
		grid,
		pie,
		agglomerative
	}

	public MB3_MeshBakerGrouperCore grouper;

	public ClusterType clusterType;

	public GrouperData data = new GrouperData();

	[HideInInspector]
	public Bounds sourceObjectBounds = new Bounds(Vector3.zero, Vector3.one);

	private void OnDrawGizmosSelected()
	{
		if (grouper == null)
		{
			grouper = CreateGrouper(clusterType, data);
		}
		if (grouper.d == null)
		{
			grouper.d = data;
		}
		grouper.DrawGizmos(sourceObjectBounds);
	}

	public MB3_MeshBakerGrouperCore CreateGrouper(ClusterType t, GrouperData data)
	{
		if (t == ClusterType.grid)
		{
			grouper = new MB3_MeshBakerGrouperGrid(data);
		}
		if (t == ClusterType.pie)
		{
			grouper = new MB3_MeshBakerGrouperPie(data);
		}
		if (t == ClusterType.agglomerative)
		{
			MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
			List<GameObject> gos = ((!(component != null)) ? new List<GameObject>() : component.GetObjectsToCombine());
			grouper = new MB3_MeshBakerGrouperCluster(data, gos);
		}
		if (t == ClusterType.none)
		{
			grouper = new MB3_MeshBakerGrouperNone(data);
		}
		return grouper;
	}
}
namespace DigitalOpus.MB.Core
{
	[Serializable]
	public class GrouperData
	{
		public bool clusterOnLMIndex;

		public bool clusterByLODLevel;

		public Vector3 origin;

		public Vector3 cellSize;

		public int pieNumSegments = 4;

		public Vector3 pieAxis = Vector3.up;

		public int height = 1;

		public float maxDistBetweenClusters = 1f;

		public bool includeCellsWithOnlyOneRenderer = true;
	}
	[Serializable]
	public abstract class MB3_MeshBakerGrouperCore
	{
		public GrouperData d;

		public abstract Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection);

		public abstract void DrawGizmos(Bounds sourceObjectBounds);

		public void DoClustering(MB3_TextureBaker tb, MB3_MeshBakerGrouper grouper)
		{
			Dictionary<string, List<Renderer>> dictionary = FilterIntoGroups(tb.GetObjectsToCombine());
			if (d.clusterOnLMIndex)
			{
				Dictionary<string, List<Renderer>> dictionary2 = new Dictionary<string, List<Renderer>>();
				foreach (string key4 in dictionary.Keys)
				{
					List<Renderer> gaws = dictionary[key4];
					Dictionary<int, List<Renderer>> dictionary3 = GroupByLightmapIndex(gaws);
					foreach (int key5 in dictionary3.Keys)
					{
						string key = key4 + "-LM-" + key5;
						dictionary2.Add(key, dictionary3[key5]);
					}
				}
				dictionary = dictionary2;
			}
			if (d.clusterByLODLevel)
			{
				Dictionary<string, List<Renderer>> dictionary4 = new Dictionary<string, List<Renderer>>();
				foreach (string key6 in dictionary.Keys)
				{
					List<Renderer> list = dictionary[key6];
					foreach (Renderer r in list)
					{
						if (r == null)
						{
							continue;
						}
						bool flag = false;
						LODGroup componentInParent = r.GetComponentInParent<LODGroup>();
						if (componentInParent != null)
						{
							LOD[] lODs = componentInParent.GetLODs();
							for (int i = 0; i < lODs.Length; i++)
							{
								LOD lOD = lODs[i];
								if (Array.Find(lOD.renderers, (Renderer x) => x == r) != null)
								{
									flag = true;
									string key2 = $"{key6}_LOD{i}";
									if (!dictionary4.TryGetValue(key2, out var value))
									{
										value = new List<Renderer>();
										dictionary4.Add(key2, value);
									}
									if (!value.Contains(r))
									{
										value.Add(r);
									}
								}
							}
						}
						if (!flag)
						{
							string key3 = $"{key6}_LOD0";
							if (!dictionary4.TryGetValue(key3, out var value2))
							{
								value2 = new List<Renderer>();
								dictionary4.Add(key3, value2);
							}
							if (!value2.Contains(r))
							{
								value2.Add(r);
							}
						}
					}
				}
				dictionary = dictionary4;
			}
			int num = 0;
			foreach (string key7 in dictionary.Keys)
			{
				List<Renderer> list2 = dictionary[key7];
				if (list2.Count > 1 || grouper.data.includeCellsWithOnlyOneRenderer)
				{
					AddMeshBaker(tb, key7, list2);
				}
				else
				{
					num++;
				}
			}
			UnityEngine.Debug.Log($"Found {dictionary.Count} cells with Renderers. Not creating bakers for {num} because there is only one mesh in the cell. Creating {dictionary.Count - num} bakers.");
		}

		private Dictionary<int, List<Renderer>> GroupByLightmapIndex(List<Renderer> gaws)
		{
			Dictionary<int, List<Renderer>> dictionary = new Dictionary<int, List<Renderer>>();
			for (int i = 0; i < gaws.Count; i++)
			{
				List<Renderer> list = null;
				if (dictionary.ContainsKey(gaws[i].lightmapIndex))
				{
					list = dictionary[gaws[i].lightmapIndex];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(gaws[i].lightmapIndex, list);
				}
				list.Add(gaws[i]);
			}
			return dictionary;
		}

		private void AddMeshBaker(MB3_TextureBaker tb, string key, List<Renderer> gaws)
		{
			int num = 0;
			for (int i = 0; i < gaws.Count; i++)
			{
				Mesh mesh = MB_Utility.GetMesh(gaws[i].gameObject);
				if (mesh != null)
				{
					num += mesh.vertexCount;
				}
			}
			GameObject gameObject = new GameObject("MeshBaker-" + key);
			gameObject.transform.position = Vector3.zero;
			MB3_MeshBakerCommon mB3_MeshBakerCommon;
			if (num >= 65535)
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MultiMeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			else
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			mB3_MeshBakerCommon.textureBakeResults = tb.textureBakeResults;
			mB3_MeshBakerCommon.transform.parent = tb.transform;
			for (int j = 0; j < gaws.Count; j++)
			{
				mB3_MeshBakerCommon.GetObjectsToCombine().Add(gaws[j].gameObject);
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperNone : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperNone(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			UnityEngine.Debug.Log("Filtering into groups none");
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<Renderer> list = new List<Renderer>();
			for (int i = 0; i < selection.Count; i++)
			{
				if (selection[i] != null)
				{
					list.Add(selection[i].GetComponent<Renderer>());
				}
			}
			dictionary.Add("MeshBaker", list);
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperGrid : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperGrid(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.cellSize.x <= 0f || d.cellSize.y <= 0f || d.cellSize.z <= 0f)
			{
				UnityEngine.Debug.LogError("cellSize x,y,z must all be greater than zero.");
				return dictionary;
			}
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				GameObject gameObject = item;
				Renderer component = gameObject.GetComponent<Renderer>();
				if (component is MeshRenderer || component is SkinnedMeshRenderer)
				{
					Vector3 center = component.bounds.center;
					center.x = Mathf.Floor((center.x - d.origin.x) / d.cellSize.x) * d.cellSize.x;
					center.y = Mathf.Floor((center.y - d.origin.y) / d.cellSize.y) * d.cellSize.y;
					center.z = Mathf.Floor((center.z - d.origin.z) / d.cellSize.z) * d.cellSize.z;
					List<Renderer> list = null;
					string key = center.ToString();
					if (dictionary.ContainsKey(key))
					{
						list = dictionary[key];
					}
					else
					{
						list = new List<Renderer>();
						dictionary.Add(key, list);
					}
					if (!list.Contains(component))
					{
						list.Add(component);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			Vector3 cellSize = d.cellSize;
			if (cellSize.x <= 1E-05f || cellSize.y <= 1E-05f || cellSize.z <= 1E-05f)
			{
				return;
			}
			Vector3 vector = sourceObjectBounds.center - sourceObjectBounds.extents;
			Vector3 origin = d.origin;
			origin.x %= cellSize.x;
			origin.y %= cellSize.y;
			origin.z %= cellSize.z;
			vector.x = Mathf.Round(vector.x / cellSize.x) * cellSize.x + origin.x;
			vector.y = Mathf.Round(vector.y / cellSize.y) * cellSize.y + origin.y;
			vector.z = Mathf.Round(vector.z / cellSize.z) * cellSize.z + origin.z;
			if (vector.x > sourceObjectBounds.center.x - sourceObjectBounds.extents.x)
			{
				vector.x -= cellSize.x;
			}
			if (vector.y > sourceObjectBounds.center.y - sourceObjectBounds.extents.y)
			{
				vector.y -= cellSize.y;
			}
			if (vector.z > sourceObjectBounds.center.z - sourceObjectBounds.extents.z)
			{
				vector.z -= cellSize.z;
			}
			Vector3 vector2 = vector;
			int num = Mathf.CeilToInt(sourceObjectBounds.size.x / cellSize.x + sourceObjectBounds.size.y / cellSize.y + sourceObjectBounds.size.z / cellSize.z);
			if (num > 200)
			{
				Gizmos.DrawWireCube(d.origin + cellSize / 2f, cellSize);
				return;
			}
			while (vector.x < sourceObjectBounds.center.x + sourceObjectBounds.extents.x)
			{
				vector.y = vector2.y;
				while (vector.y < sourceObjectBounds.center.y + sourceObjectBounds.extents.y)
				{
					vector.z = vector2.z;
					while (vector.z < sourceObjectBounds.center.z + sourceObjectBounds.extents.z)
					{
						Gizmos.DrawWireCube(vector + cellSize / 2f, cellSize);
						vector.z += cellSize.z;
					}
					vector.y += cellSize.y;
				}
				vector.x += cellSize.x;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperPie : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperPie(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.pieNumSegments == 0)
			{
				UnityEngine.Debug.LogError("pieNumSegments must be greater than zero.");
				return dictionary;
			}
			if (d.pieAxis.magnitude <= 1E-06f)
			{
				UnityEngine.Debug.LogError("Pie axis must have length greater than zero.");
				return dictionary;
			}
			d.pieAxis.Normalize();
			Quaternion quaternion = Quaternion.FromToRotation(d.pieAxis, Vector3.up);
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				GameObject gameObject = item;
				Renderer component = gameObject.GetComponent<Renderer>();
				if (!(component is MeshRenderer) && !(component is SkinnedMeshRenderer))
				{
					continue;
				}
				Vector3 vector = component.bounds.center - d.origin;
				vector.Normalize();
				vector = quaternion * vector;
				float num = 0f;
				if (Mathf.Abs(vector.x) < 0.0001f && Mathf.Abs(vector.z) < 0.0001f)
				{
					num = 0f;
				}
				else
				{
					num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
					if (num < 0f)
					{
						num = 360f + num;
					}
				}
				int num2 = Mathf.FloorToInt(num / 360f * (float)d.pieNumSegments);
				List<Renderer> list = null;
				string key = "seg_" + num2;
				if (dictionary.ContainsKey(key))
				{
					list = dictionary[key];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(key, list);
				}
				if (!list.Contains(component))
				{
					list.Add(component);
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			if (!(d.pieAxis.magnitude < 0.1f) && d.pieNumSegments >= 1)
			{
				float magnitude = sourceObjectBounds.extents.magnitude;
				DrawCircle(d.pieAxis, d.origin, magnitude, 24);
				Quaternion quaternion = Quaternion.FromToRotation(Vector3.up, d.pieAxis);
				Quaternion quaternion2 = Quaternion.AngleAxis(180f / (float)d.pieNumSegments, Vector3.up);
				Vector3 vector = Vector3.forward;
				for (int i = 0; i < d.pieNumSegments; i++)
				{
					Vector3 vector2 = quaternion * vector;
					Gizmos.DrawLine(d.origin, d.origin + vector2 * magnitude);
					vector = quaternion2 * vector;
					vector = quaternion2 * vector;
				}
			}
		}

		public static void DrawCircle(Vector3 axis, Vector3 center, float radius, int subdiv)
		{
			Quaternion quaternion = Quaternion.AngleAxis(360 / subdiv, axis);
			Vector3 vector = new Vector3(axis.y, 0f - axis.x, axis.z);
			vector.Normalize();
			vector *= radius;
			for (int i = 0; i < subdiv + 1; i++)
			{
				Vector3 vector2 = quaternion * vector;
				Gizmos.DrawLine(center + vector, center + vector2);
				vector = vector2;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperKMeans : MB3_MeshBakerGrouperCore
	{
		public int numClusters = 4;

		public Vector3[] clusterCenters = new Vector3[0];

		public float[] clusterSizes = new float[0];

		public MB3_MeshBakerGrouperKMeans(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<GameObject> list = new List<GameObject>();
			int num = 20;
			foreach (GameObject item in selection)
			{
				if (!(item == null))
				{
					GameObject gameObject = item;
					Renderer component = gameObject.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(gameObject);
					}
				}
			}
			if (list.Count > 0 && num > 0 && num < list.Count)
			{
				MB3_KMeansClustering mB3_KMeansClustering = new MB3_KMeansClustering(list, num);
				mB3_KMeansClustering.Cluster();
				clusterCenters = new Vector3[num];
				clusterSizes = new float[num];
				for (int i = 0; i < num; i++)
				{
					List<Renderer> cluster = mB3_KMeansClustering.GetCluster(i, out clusterCenters[i], out clusterSizes[i]);
					if (cluster.Count > 0)
					{
						dictionary.Add("Cluster_" + i, cluster);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (clusterCenters != null && clusterSizes != null && clusterCenters.Length == clusterSizes.Length)
			{
				for (int i = 0; i < clusterSizes.Length; i++)
				{
					Gizmos.DrawWireSphere(clusterCenters[i], clusterSizes[i]);
				}
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperCluster : MB3_MeshBakerGrouperCore
	{
		public MB3_AgglomerativeClustering cluster;

		private float _lastMaxDistBetweenClusters;

		public float _ObjsExtents = 10f;

		public float _minDistBetweenClusters = 0.001f;

		private List<MB3_AgglomerativeClustering.ClusterNode> _clustersToDraw = new List<MB3_AgglomerativeClustering.ClusterNode>();

		private float[] _radii;

		public MB3_MeshBakerGrouperCluster(GrouperData data, List<GameObject> gos)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			for (int i = 0; i < _clustersToDraw.Count; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = _clustersToDraw[i];
				List<Renderer> list = new List<Renderer>();
				for (int j = 0; j < clusterNode.leafs.Length; j++)
				{
					Renderer component = cluster.clusters[clusterNode.leafs[j]].leaf.go.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(component);
					}
				}
				dictionary.Add("Cluster_" + i, list);
			}
			return dictionary;
		}

		public void BuildClusters(List<GameObject> gos, ProgressUpdateCancelableDelegate progFunc)
		{
			if (gos.Count == 0)
			{
				UnityEngine.Debug.LogWarning("No objects to cluster. Add some objects to the list of Objects To Combine.");
				return;
			}
			if (cluster == null)
			{
				cluster = new MB3_AgglomerativeClustering();
			}
			List<MB3_AgglomerativeClustering.item_s> list = new List<MB3_AgglomerativeClustering.item_s>();
			for (int i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null && list.Find((MB3_AgglomerativeClustering.item_s x) => x.go == gos[i]) == null)
				{
					Renderer component = gos[i].GetComponent<Renderer>();
					if (component != null && (component is MeshRenderer || component is SkinnedMeshRenderer))
					{
						MB3_AgglomerativeClustering.item_s item_s = new MB3_AgglomerativeClustering.item_s();
						item_s.go = gos[i];
						item_s.coord = component.bounds.center;
						list.Add(item_s);
					}
				}
			}
			cluster.items = list;
			cluster.agglomerate(progFunc);
			if (!cluster.wasCanceled)
			{
				_BuildListOfClustersToDraw(progFunc, out var smallest, out var largest);
				d.maxDistBetweenClusters = Mathf.Lerp(smallest, largest, 0.9f);
			}
		}

		private void _BuildListOfClustersToDraw(ProgressUpdateCancelableDelegate progFunc, out float smallest, out float largest)
		{
			_clustersToDraw.Clear();
			if (cluster.clusters == null)
			{
				smallest = 1f;
				largest = 10f;
				return;
			}
			progFunc?.Invoke("Building Clusters To Draw A:", 0f);
			List<MB3_AgglomerativeClustering.ClusterNode> list = new List<MB3_AgglomerativeClustering.ClusterNode>();
			largest = 1f;
			smallest = 10000000f;
			for (int i = 0; i < cluster.clusters.Length; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = cluster.clusters[i];
				if (clusterNode.distToMergedCentroid <= d.maxDistBetweenClusters)
				{
					if (d.includeCellsWithOnlyOneRenderer)
					{
						_clustersToDraw.Add(clusterNode);
					}
					else if (clusterNode.leaf == null)
					{
						_clustersToDraw.Add(clusterNode);
					}
				}
				if (clusterNode.distToMergedCentroid > largest)
				{
					largest = clusterNode.distToMergedCentroid;
				}
				if (clusterNode.height > 0 && clusterNode.distToMergedCentroid < smallest)
				{
					smallest = clusterNode.distToMergedCentroid;
				}
			}
			progFunc?.Invoke("Building Clusters To Draw B:", 0f);
			for (int j = 0; j < _clustersToDraw.Count; j++)
			{
				list.Add(_clustersToDraw[j].cha);
				list.Add(_clustersToDraw[j].chb);
			}
			for (int k = 0; k < list.Count; k++)
			{
				_clustersToDraw.Remove(list[k]);
			}
			_radii = new float[_clustersToDraw.Count];
			progFunc?.Invoke("Building Clusters To Draw C:", 0f);
			for (int l = 0; l < _radii.Length; l++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode2 = _clustersToDraw[l];
				Bounds bounds = new Bounds(clusterNode2.centroid, Vector3.one);
				for (int m = 0; m < clusterNode2.leafs.Length; m++)
				{
					Renderer component = cluster.clusters[clusterNode2.leafs[m]].leaf.go.GetComponent<Renderer>();
					if (component != null)
					{
						bounds.Encapsulate(component.bounds);
					}
				}
				_radii[l] = bounds.extents.magnitude;
			}
			progFunc?.Invoke("Building Clusters To Draw D:", 0f);
			_ObjsExtents = largest + 1f;
			_minDistBetweenClusters = Mathf.Lerp(smallest, 0f, 0.9f);
			if (_ObjsExtents < 2f)
			{
				_ObjsExtents = 2f;
			}
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (cluster != null && cluster.clusters != null)
			{
				if (_lastMaxDistBetweenClusters != d.maxDistBetweenClusters)
				{
					_BuildListOfClustersToDraw(null, out var _, out var _);
					_lastMaxDistBetweenClusters = d.maxDistBetweenClusters;
				}
				for (int i = 0; i < _clustersToDraw.Count; i++)
				{
					Gizmos.color = UnityEngine.Color.white;
					MB3_AgglomerativeClustering.ClusterNode clusterNode = _clustersToDraw[i];
					Gizmos.DrawWireSphere(clusterNode.centroid, _radii[i]);
				}
			}
		}
	}
}
public abstract class MB3_MeshBakerRoot : UnityEngine.MonoBehaviour
{
	public class ZSortObjects
	{
		public class Item
		{
			public GameObject go;

			public Vector3 point;
		}

		public class ItemComparer : IComparer<Item>
		{
			public int Compare(Item a, Item b)
			{
				return (int)Mathf.Sign(b.point.z - a.point.z);
			}
		}

		public Vector3 sortAxis;

		public void SortByDistanceAlongAxis(List<GameObject> gos)
		{
			if (sortAxis == Vector3.zero)
			{
				UnityEngine.Debug.LogError("The sort axis cannot be the zero vector.");
				return;
			}
			UnityEngine.Debug.Log("Z sorting meshes along axis numObjs=" + gos.Count);
			List<Item> list = new List<Item>();
			Quaternion quaternion = Quaternion.FromToRotation(sortAxis, Vector3.forward);
			for (int i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null)
				{
					Item item = new Item();
					item.point = gos[i].transform.position;
					item.go = gos[i];
					item.point = quaternion * item.point;
					list.Add(item);
				}
			}
			list.Sort(new ItemComparer());
			for (int j = 0; j < gos.Count; j++)
			{
				gos[j] = list[j].go;
			}
		}
	}

	public static bool DO_INTEGRITY_CHECKS = true;

	public Vector3 sortAxis;

	[HideInInspector]
	public abstract MB2_TextureBakeResults textureBakeResults { get; set; }

	public virtual List<GameObject> GetObjectsToCombine()
	{
		return null;
	}

	public static bool DoCombinedValidate(MB3_MeshBakerRoot mom, MB_ObjsToCombineTypes objToCombineType, MB2_EditorMethodsInterface editorMethods, MB2_ValidationLevel validationLevel)
	{
		if (mom.textureBakeResults == null)
		{
			UnityEngine.Debug.LogError("Need to set Texture Bake Result on " + mom);
			return false;
		}
		if (mom is MB3_MeshBakerCommon)
		{
			MB3_MeshBakerCommon mB3_MeshBakerCommon = (MB3_MeshBakerCommon)mom;
			MB3_TextureBaker textureBaker = mB3_MeshBakerCommon.GetTextureBaker();
			if (textureBaker != null && textureBaker.textureBakeResults != mom.textureBakeResults)
			{
				UnityEngine.Debug.LogWarning("Texture Bake Result on this component is not the same as the Texture Bake Result on the MB3_TextureBaker.");
			}
		}
		Dictionary<int, MB_Utility.MeshAnalysisResult> dictionary = null;
		if (validationLevel == MB2_ValidationLevel.robust)
		{
			dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult>();
		}
		List<GameObject> objectsToCombine = mom.GetObjectsToCombine();
		for (int i = 0; i < objectsToCombine.Count; i++)
		{
			GameObject gameObject = objectsToCombine[i];
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError("The list of objects to combine contains a null at position." + i + " Select and use [shift] delete to remove");
				return false;
			}
			for (int j = i + 1; j < objectsToCombine.Count; j++)
			{
				if (objectsToCombine[i] == objectsToCombine[j])
				{
					UnityEngine.Debug.LogError("The list of objects to combine contains duplicates at " + i + " and " + j);
					return false;
				}
			}
			if (MB_Utility.GetGOMaterials(gameObject).Length == 0)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a material"));
				return false;
			}
			Mesh mesh = MB_Utility.GetMesh(gameObject);
			if (mesh == null)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a mesh"));
				return false;
			}
			if (mesh != null && !UnityEngine.Application.isEditor && UnityEngine.Application.isPlaying && mom.textureBakeResults.doMultiMaterial && validationLevel >= MB2_ValidationLevel.robust)
			{
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value);
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (value.hasOverlappingSubmeshVerts)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", objectsToCombine[i], " in the list of objects to combine has overlapping submeshes (submeshes share vertices). If the UVs associated with the shared vertices are important then this bake may not work. If you are using multiple materials then this object can only be combined with objects that use the exact same set of textures (each atlas contains one texture). There may be other undesirable side affects as well. Mesh Master, available in the asset store can fix overlapping submeshes."));
				}
			}
		}
		List<GameObject> list = objectsToCombine;
		if (mom is MB3_MeshBaker)
		{
			list = mom.GetObjectsToCombine();
			if (list == null || list.Count == 0)
			{
				UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
				return false;
			}
			if (mom is MB3_MeshBaker && ((MB3_MeshBaker)mom).meshCombiner.renderType == MB_RenderType.skinnedMeshRenderer && !editorMethods.ValidateSkinnedMeshes(list))
			{
				return false;
			}
		}
		editorMethods?.CheckPrefabTypes(objToCombineType, objectsToCombine);
		return true;
	}
}
public class MB3_MultiMeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MultiMeshCombiner _meshCombiner = new MB3_MultiMeshCombiner();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOs, disableRendererInSource);
	}
}
public class MB3_TextureBaker : MB3_MeshBakerRoot
{
	public delegate void OnCombinedTexturesCoroutineSuccess();

	public delegate void OnCombinedTexturesCoroutineFail();

	public class CreateAtlasesCoroutineResult
	{
		public bool success = true;

		public bool isFinished;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	[SerializeField]
	protected MB2_TextureBakeResults _textureBakeResults;

	[SerializeField]
	protected int _atlasPadding = 1;

	[SerializeField]
	protected int _maxAtlasSize = 4096;

	[SerializeField]
	protected bool _resizePowerOfTwoTextures;

	[SerializeField]
	protected bool _fixOutOfBoundsUVs;

	[SerializeField]
	protected int _maxTilingBakeSize = 1024;

	[SerializeField]
	protected MB2_PackingAlgorithmEnum _packingAlgorithm = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;

	[SerializeField]
	protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

	[SerializeField]
	protected List<ShaderTextureProperty> _customShaderProperties = new List<ShaderTextureProperty>();

	[SerializeField]
	protected List<string> _customShaderPropNames_Depricated = new List<string>();

	[SerializeField]
	protected bool _doMultiMaterial;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfTooBig = true;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfOBUVs = true;

	[SerializeField]
	protected Material _resultMaterial;

	[SerializeField]
	protected bool _considerNonTextureProperties;

	[SerializeField]
	protected bool _doSuggestTreatment = true;

	private CreateAtlasesCoroutineResult _coroutineResult;

	public MB_MultiMaterial[] resultMaterials = new MB_MultiMaterial[0];

	public List<GameObject> objsToMesh;

	public OnCombinedTexturesCoroutineSuccess onBuiltAtlasesSuccess;

	public OnCombinedTexturesCoroutineFail onBuiltAtlasesFail;

	public MB_AtlasesAndRects[] OnCombinedTexturesCoroutineAtlasesAndRects;

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return _textureBakeResults;
		}
		set
		{
			_textureBakeResults = value;
		}
	}

	public virtual int atlasPadding
	{
		get
		{
			return _atlasPadding;
		}
		set
		{
			_atlasPadding = value;
		}
	}

	public virtual int maxAtlasSize
	{
		get
		{
			return _maxAtlasSize;
		}
		set
		{
			_maxAtlasSize = value;
		}
	}

	public virtual bool resizePowerOfTwoTextures
	{
		get
		{
			return _resizePowerOfTwoTextures;
		}
		set
		{
			_resizePowerOfTwoTextures = value;
		}
	}

	public virtual bool fixOutOfBoundsUVs
	{
		get
		{
			return _fixOutOfBoundsUVs;
		}
		set
		{
			_fixOutOfBoundsUVs = value;
		}
	}

	public virtual int maxTilingBakeSize
	{
		get
		{
			return _maxTilingBakeSize;
		}
		set
		{
			_maxTilingBakeSize = value;
		}
	}

	public virtual MB2_PackingAlgorithmEnum packingAlgorithm
	{
		get
		{
			return _packingAlgorithm;
		}
		set
		{
			_packingAlgorithm = value;
		}
	}

	public bool meshBakerTexturePackerForcePowerOfTwo
	{
		get
		{
			return _meshBakerTexturePackerForcePowerOfTwo;
		}
		set
		{
			_meshBakerTexturePackerForcePowerOfTwo = value;
		}
	}

	public virtual List<ShaderTextureProperty> customShaderProperties
	{
		get
		{
			return _customShaderProperties;
		}
		set
		{
			_customShaderProperties = value;
		}
	}

	public virtual List<string> customShaderPropNames
	{
		get
		{
			return _customShaderPropNames_Depricated;
		}
		set
		{
			_customShaderPropNames_Depricated = value;
		}
	}

	public virtual bool doMultiMaterial
	{
		get
		{
			return _doMultiMaterial;
		}
		set
		{
			_doMultiMaterial = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfTooBig
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfTooBig;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfTooBig = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfOBUVs
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfOBUVs;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfOBUVs = value;
		}
	}

	public virtual Material resultMaterial
	{
		get
		{
			return _resultMaterial;
		}
		set
		{
			_resultMaterial = value;
		}
	}

	public bool considerNonTextureProperties
	{
		get
		{
			return _considerNonTextureProperties;
		}
		set
		{
			_considerNonTextureProperties = value;
		}
	}

	public bool doSuggestTreatment
	{
		get
		{
			return _doSuggestTreatment;
		}
		set
		{
			_doSuggestTreatment = value;
		}
	}

	public CreateAtlasesCoroutineResult CoroutineResult => _coroutineResult;

	public override List<GameObject> GetObjectsToCombine()
	{
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public MB_AtlasesAndRects[] CreateAtlases()
	{
		return CreateAtlases(null);
	}

	public IEnumerator CreateAtlasesCoroutine(ProgressUpdateDelegate progressInfo, CreateAtlasesCoroutineResult coroutineResult, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null, float maxTimePerFrame = 0.01f)
	{
		MBVersionConcrete mbv = new MBVersionConcrete();
		if (!MB3_TextureCombiner._RunCorutineWithoutPauseIsRunning && (mbv.GetMajorVersion() < 5 || (mbv.GetMajorVersion() == 5 && mbv.GetMinorVersion() < 3)))
		{
			UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
			coroutineResult.success = false;
			yield break;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = null;
		if (maxTimePerFrame <= 0f)
		{
			UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
			coroutineResult.isFinished = true;
			yield break;
		}
		MB2_ValidationLevel vl = (UnityEngine.Application.isPlaying ? MB2_ValidationLevel.quick : MB2_ValidationLevel.robust);
		if (!MB3_MeshBakerRoot.DoCombinedValidate(this, MB_ObjsToCombineTypes.dontCare, null, vl))
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (_doMultiMaterial && !_ValidateResultMaterials())
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (!_doMultiMaterial)
		{
			if (_resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				coroutineResult.isFinished = true;
				yield break;
			}
			Shader shader = _resultMaterial.shader;
			for (int j = 0; j < objsToMesh.Count; j++)
			{
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[j]);
				foreach (Material material in gOMaterials)
				{
					if (material != null && material.shader != shader)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Game object ", objsToMesh[j], " does not use shader ", shader, " it may not have the required textures. If not small solid color textures will be generated."));
					}
				}
			}
		}
		MB3_TextureCombiner combiner = CreateAndConfigureTextureCombiner();
		combiner.saveAtlasesAsAssets = saveAtlasesAsAssets;
		int numResults = 1;
		if (_doMultiMaterial)
		{
			numResults = resultMaterials.Length;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = new MB_AtlasesAndRects[numResults];
		for (int l = 0; l < OnCombinedTexturesCoroutineAtlasesAndRects.Length; l++)
		{
			OnCombinedTexturesCoroutineAtlasesAndRects[l] = new MB_AtlasesAndRects();
		}
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			Material resMatToPass2 = null;
			List<Material> sourceMats = null;
			if (_doMultiMaterial)
			{
				sourceMats = resultMaterials[i].sourceMaterials;
				resMatToPass2 = resultMaterials[i].combinedMaterial;
				combiner.fixOutOfBoundsUVs = resultMaterials[i].considerMeshUVs;
			}
			else
			{
				resMatToPass2 = _resultMaterial;
			}
			UnityEngine.Debug.Log($"Creating atlases for result material {resMatToPass2} using shader {resMatToPass2.shader}");
			MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult coroutineResult2 = new MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult();
			yield return combiner.CombineTexturesIntoAtlasesCoroutine(progressInfo, OnCombinedTexturesCoroutineAtlasesAndRects[i], resMatToPass2, objsToMesh, sourceMats, editorMethods, coroutineResult2, maxTimePerFrame);
			coroutineResult.success = coroutineResult2.success;
			if (!coroutineResult.success)
			{
				coroutineResult.isFinished = true;
				yield break;
			}
		}
		unpackMat2RectMap(textureBakeResults);
		textureBakeResults.doMultiMaterial = _doMultiMaterial;
		if (_doMultiMaterial)
		{
			textureBakeResults.resultMaterials = resultMaterials;
		}
		else
		{
			MB_MultiMaterial[] array = new MB_MultiMaterial[1]
			{
				new MB_MultiMaterial()
			};
			array[0].combinedMaterial = _resultMaterial;
			array[0].considerMeshUVs = _fixOutOfBoundsUVs;
			array[0].sourceMaterials = new List<Material>();
			array[0].sourceMaterials.AddRange(textureBakeResults.materials);
			textureBakeResults.resultMaterials = array;
		}
		MB3_MeshBakerCommon[] mb = GetComponentsInChildren<MB3_MeshBakerCommon>();
		for (int m = 0; m < mb.Length; m++)
		{
			mb[m].textureBakeResults = textureBakeResults;
		}
		if (LOG_LEVEL >= MB2_LogLevel.info)
		{
			UnityEngine.Debug.Log("Created Atlases");
		}
		coroutineResult.isFinished = true;
		if (coroutineResult.success && onBuiltAtlasesSuccess != null)
		{
			onBuiltAtlasesSuccess();
		}
		if (!coroutineResult.success && onBuiltAtlasesFail != null)
		{
			onBuiltAtlasesFail();
		}
	}

	public MB_AtlasesAndRects[] CreateAtlases(ProgressUpdateDelegate progressInfo, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null)
	{
		MB_AtlasesAndRects[] array = null;
		try
		{
			_coroutineResult = new CreateAtlasesCoroutineResult();
			MB3_TextureCombiner.RunCorutineWithoutPause(CreateAtlasesCoroutine(progressInfo, _coroutineResult, saveAtlasesAsAssets, editorMethods, 1000f), 0);
			if (_coroutineResult.success && textureBakeResults != null)
			{
				array = OnCombinedTexturesCoroutineAtlasesAndRects;
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
		}
		finally
		{
			if (saveAtlasesAsAssets && array != null)
			{
				foreach (MB_AtlasesAndRects mB_AtlasesAndRects in array)
				{
					if (mB_AtlasesAndRects == null || mB_AtlasesAndRects.atlases == null)
					{
						continue;
					}
					for (int j = 0; j < mB_AtlasesAndRects.atlases.Length; j++)
					{
						if (mB_AtlasesAndRects.atlases[j] != null)
						{
							if (editorMethods != null)
							{
								editorMethods.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
							else
							{
								MB_Utility.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
						}
					}
				}
			}
		}
		return array;
	}

	private void unpackMat2RectMap(MB2_TextureBakeResults tbr)
	{
		List<Material> list = new List<Material>();
		List<MB_MaterialAndUVRect> list2 = new List<MB_MaterialAndUVRect>();
		List<Rect> list3 = new List<Rect>();
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			MB_AtlasesAndRects mB_AtlasesAndRects = OnCombinedTexturesCoroutineAtlasesAndRects[i];
			List<MB_MaterialAndUVRect> mat2rect_map = mB_AtlasesAndRects.mat2rect_map;
			if (mat2rect_map != null)
			{
				for (int j = 0; j < mat2rect_map.Count; j++)
				{
					list2.Add(mat2rect_map[j]);
					list.Add(mat2rect_map[j].material);
					list3.Add(mat2rect_map[j].atlasRect);
				}
			}
		}
		tbr.materials = list.ToArray();
		tbr.materialsAndUVRects = list2.ToArray();
	}

	public MB3_TextureCombiner CreateAndConfigureTextureCombiner()
	{
		MB3_TextureCombiner mB3_TextureCombiner = new MB3_TextureCombiner();
		mB3_TextureCombiner.LOG_LEVEL = LOG_LEVEL;
		mB3_TextureCombiner.atlasPadding = _atlasPadding;
		mB3_TextureCombiner.maxAtlasSize = _maxAtlasSize;
		mB3_TextureCombiner.customShaderPropNames = _customShaderProperties;
		mB3_TextureCombiner.fixOutOfBoundsUVs = _fixOutOfBoundsUVs;
		mB3_TextureCombiner.maxTilingBakeSize = _maxTilingBakeSize;
		mB3_TextureCombiner.packingAlgorithm = _packingAlgorithm;
		mB3_TextureCombiner.meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo;
		mB3_TextureCombiner.resizePowerOfTwoTextures = _resizePowerOfTwoTextures;
		mB3_TextureCombiner.considerNonTextureProperties = _considerNonTextureProperties;
		return mB3_TextureCombiner;
	}

	public static void ConfigureNewMaterialToMatchOld(Material newMat, Material original)
	{
		if (original == null)
		{
			UnityEngine.Debug.LogWarning(string.Concat("Original material is null, could not copy properties to ", newMat, ". Setting shader to ", newMat.shader));
			return;
		}
		newMat.shader = original.shader;
		newMat.CopyPropertiesFromMaterial(original);
		ShaderTextureProperty[] shaderTexPropertyNames = MB3_TextureCombiner.shaderTexPropertyNames;
		for (int i = 0; i < shaderTexPropertyNames.Length; i++)
		{
			Vector2 one = Vector2.one;
			Vector2 zero = Vector2.zero;
			if (newMat.HasProperty(shaderTexPropertyNames[i].name))
			{
				newMat.SetTextureOffset(shaderTexPropertyNames[i].name, zero);
				newMat.SetTextureScale(shaderTexPropertyNames[i].name, one);
			}
		}
	}

	private string PrintSet(HashSet<Material> s)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (Material item in s)
		{
			stringBuilder.Append(string.Concat(item, ","));
		}
		return stringBuilder.ToString();
	}

	private bool _ValidateResultMaterials()
	{
		HashSet<Material> hashSet = new HashSet<Material>();
		for (int i = 0; i < objsToMesh.Count; i++)
		{
			if (!(objsToMesh[i] != null))
			{
				continue;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (gOMaterials[j] != null)
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		HashSet<Material> hashSet2 = new HashSet<Material>();
		for (int k = 0; k < resultMaterials.Length; k++)
		{
			MB_MultiMaterial mB_MultiMaterial = resultMaterials[k];
			if (mB_MultiMaterial.combinedMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				return false;
			}
			Shader shader = mB_MultiMaterial.combinedMaterial.shader;
			for (int l = 0; l < mB_MultiMaterial.sourceMaterials.Count; l++)
			{
				if (mB_MultiMaterial.sourceMaterials[l] == null)
				{
					UnityEngine.Debug.LogError("There are null entries in the list of Source Materials");
					return false;
				}
				if (shader != mB_MultiMaterial.sourceMaterials[l].shader)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Source material ", mB_MultiMaterial.sourceMaterials[l], " does not use shader ", shader, " it may not have the required textures. If not empty textures will be generated."));
				}
				if (hashSet2.Contains(mB_MultiMaterial.sourceMaterials[l]))
				{
					UnityEngine.Debug.LogError(string.Concat("A Material ", mB_MultiMaterial.sourceMaterials[l], " appears more than once in the list of source materials in the source material to combined mapping. Each source material must be unique."));
					return false;
				}
				hashSet2.Add(mB_MultiMaterial.sourceMaterials[l]);
			}
		}
		if (hashSet.IsProperSubsetOf(hashSet2))
		{
			hashSet2.ExceptWith(hashSet);
			UnityEngine.Debug.LogWarning("There are materials in the mapping that are not used on your source objects: " + PrintSet(hashSet2));
		}
		if (resultMaterials != null && resultMaterials.Length > 0 && hashSet2.IsProperSubsetOf(hashSet))
		{
			hashSet.ExceptWith(hashSet2);
			UnityEngine.Debug.LogError("There are materials on the objects to combine that are not in the mapping: " + PrintSet(hashSet));
			return false;
		}
		return true;
	}
}
public class MB2_TestShowHide : UnityEngine.MonoBehaviour
{
	public MB3_MeshBaker mb;

	public GameObject[] objs;

	private void Update()
	{
		if (Time.frameCount == 100)
		{
			mb.ShowHide(null, objs);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should have disappeared");
		}
		if (Time.frameCount == 200)
		{
			mb.ShowHide(objs, null);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should show");
		}
	}
}
public class MB2_TestUpdate : UnityEngine.MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public MB3_MultiMeshBaker multiMeshBaker;

	public GameObject[] objsToMove;

	public GameObject objWithChangingUVs;

	private Vector2[] uvs;

	private Mesh m;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		meshbaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		MeshFilter component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		meshbaker.Apply();
		multiMeshBaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		multiMeshBaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		multiMeshBaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		Vector2[] uv = m.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			ref Vector2 reference = ref uv[i];
			reference = Mathf.Sin(Time.time) * uvs[i];
		}
		m.uv = uv;
		meshbaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
		multiMeshBaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		uv = m.uv;
		for (int j = 0; j < uv.Length; j++)
		{
			ref Vector2 reference2 = ref uv[j];
			reference2 = Mathf.Sin(Time.time) * uvs[j];
		}
		m.uv = uv;
		multiMeshBaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		multiMeshBaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
	}
}
public class MB3_TestAddingRemovingSkinnedMeshes : UnityEngine.MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public GameObject[] g;

	private void Start()
	{
		StartCoroutine(TestScript());
	}

	private IEnumerator TestScript()
	{
		UnityEngine.Debug.Log("Test 1 adding 0,1,2");
		GameObject[] a4 = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(a4, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 2 remove 1 and add 3,4,5");
		GameObject[] d3 = new GameObject[1] { g[1] };
		a4 = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		meshBaker.AddDeleteGameObjects(a4, d3, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove 0,2,5 and add 1");
		d3 = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		a4 = new GameObject[1] { g[1] };
		meshBaker.AddDeleteGameObjects(a4, d3, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove all remaining");
		d3 = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(null, d3, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 add all");
		meshBaker.AddDeleteGameObjects(g, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(1f);
		UnityEngine.Debug.Log("Done");
	}
}
public class MB3_TestBakeAllWithSameMaterial : UnityEngine.MonoBehaviour
{
	public GameObject[] listOfObjsToCombineGood;

	public GameObject[] listOfObjsToCombineBad;

	private void Start()
	{
		testCombine();
	}

	private void testCombine()
	{
		MB3_MeshCombinerSingle mB3_MeshCombinerSingle = new MB3_MeshCombinerSingle();
		UnityEngine.Debug.Log("About to bake 1");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 1");
		UnityEngine.Debug.Log("About to bake 2 should get error that one material doesn't match");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 2");
		UnityEngine.Debug.Log("Doing same with multi mesh combiner");
		MB3_MultiMeshCombiner mB3_MultiMeshCombiner = new MB3_MultiMeshCombiner();
		UnityEngine.Debug.Log("About to bake 3");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 3");
		UnityEngine.Debug.Log("About to bake 4  should get error that one material doesn't match");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 4");
	}
}
public class MB3_TestRenderTextureTestHarness : UnityEngine.MonoBehaviour
{
	public Texture2D input;

	public bool doColor;

	public Color32 color;

	public Texture2D Create3x3Tex()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipmap: false);
		Color32[] array = new Color32[texture2D.width * texture2D.height];
		for (int i = 0; i < array.Length; i++)
		{
			ref Color32 reference = ref array[i];
			reference = color;
		}
		texture2D.SetPixels32(array);
		texture2D.Apply();
		return texture2D;
	}

	public Texture2D Create3x3Clone()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipmap: false);
		Color32[] pixels = new Color32[9]
		{
			new Color32(54, 54, 201, byte.MaxValue),
			new Color32(128, 37, 218, byte.MaxValue),
			new Color32(201, 54, 201, byte.MaxValue),
			new Color32(37, 128, 218, byte.MaxValue),
			new Color32(128, 128, byte.MaxValue, byte.MaxValue),
			new Color32(218, 128, 218, byte.MaxValue),
			new Color32(54, 201, 201, byte.MaxValue),
			new Color32(128, 218, 218, byte.MaxValue),
			new Color32(201, 201, 201, byte.MaxValue)
		};
		texture2D.SetPixels32(pixels);
		texture2D.Apply();
		return texture2D;
	}

	public static void TestRender(Texture2D input, Texture2D output)
	{
		int num = 1;
		ShaderTextureProperty[] array = new ShaderTextureProperty[1]
		{
			new ShaderTextureProperty("_BumpMap", norm: false)
		};
		int width = input.width;
		int height = input.height;
		int padding = 0;
		Rect[] rects = new Rect[1]
		{
			new Rect(0f, 0f, 1f, 1f)
		};
		List<MB3_TextureCombiner.MB_TexSet> list = new List<MB3_TextureCombiner.MB_TexSet>();
		MB3_TextureCombiner.MeshBakerMaterialTexture[] tss = new MB3_TextureCombiner.MeshBakerMaterialTexture[1]
		{
			new MB3_TextureCombiner.MeshBakerMaterialTexture(input)
		};
		MB3_TextureCombiner.MB_TexSet item = new MB3_TextureCombiner.MB_TexSet(tss, Vector2.zero, Vector2.one);
		list.Add(item);
		GameObject gameObject = null;
		gameObject = new GameObject("MBrenderAtlasesGO");
		MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = gameObject.AddComponent<MB3_AtlasPackerRenderTexture>();
		gameObject.AddComponent<Camera>();
		for (int i = 0; i < num; i++)
		{
			Texture2D texture2D = null;
			UnityEngine.Debug.Log("About to render " + array[i].name + " isNormal=" + array[i].isNormalMap);
			mB3_AtlasPackerRenderTexture.LOG_LEVEL = MB2_LogLevel.trace;
			mB3_AtlasPackerRenderTexture.width = width;
			mB3_AtlasPackerRenderTexture.height = height;
			mB3_AtlasPackerRenderTexture.padding = padding;
			mB3_AtlasPackerRenderTexture.rects = rects;
			mB3_AtlasPackerRenderTexture.textureSets = list;
			mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
			mB3_AtlasPackerRenderTexture.isNormalMap = array[i].isNormalMap;
			texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(null);
			UnityEngine.Debug.Log("Created atlas " + array[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
			UnityEngine.Debug.Log(string.Concat("Color ", texture2D.GetPixel(5, 5), " ", UnityEngine.Color.red));
			byte[] bytes = texture2D.EncodeToPNG();
			File.WriteAllBytes(UnityEngine.Application.dataPath + "/_Experiment/red.png", bytes);
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public delegate void ProgressUpdateDelegate(string msg, float progress);
	public delegate bool ProgressUpdateCancelableDelegate(string msg, float progress);
	public enum MB_ObjsToCombineTypes
	{
		prefabOnly,
		sceneObjOnly,
		dontCare
	}
	public enum MB_OutputOptions
	{
		bakeIntoPrefab,
		bakeMeshsInPlace,
		bakeTextureAtlasesOnly,
		bakeIntoSceneObject
	}
	public enum MB_RenderType
	{
		meshRenderer,
		skinnedMeshRenderer
	}
	public enum MB2_OutputOptions
	{
		bakeIntoSceneObject,
		bakeMeshAssetsInPlace,
		bakeIntoPrefab
	}
	public enum MB2_LightmapOptions
	{
		preserve_current_lightmapping,
		ignore_UV2,
		copy_UV2_unchanged,
		generate_new_UV2_layout,
		copy_UV2_unchanged_to_separate_rects
	}
	public enum MB2_PackingAlgorithmEnum
	{
		UnitysPackTextures,
		MeshBakerTexturePacker,
		MeshBakerTexturePacker_Fast
	}
	public enum MB2_ValidationLevel
	{
		none,
		quick,
		robust
	}
	public interface MB2_EditorMethodsInterface
	{
		void Clear();

		void RestoreReadFlagsAndFormats(ProgressUpdateDelegate progressInfo);

		void SetReadWriteFlag(Texture2D tx, bool isReadable, bool addToList);

		void AddTextureFormat(Texture2D tx, bool isNormalMap);

		void SaveAtlasToAssetDatabase(Texture2D atlas, ShaderTextureProperty texPropertyName, int atlasNum, Material resMat);

		void SetMaterialTextureProperty(Material target, ShaderTextureProperty texPropName, string texturePath);

		void SetNormalMap(Texture2D tx);

		bool IsNormalMap(Texture2D tx);

		string GetPlatformString();

		void SetTextureSize(Texture2D tx, int size);

		bool IsCompressed(Texture2D tx);

		void CheckBuildSettings(long estimatedAtlasSize);

		bool CheckPrefabTypes(MB_ObjsToCombineTypes prefabType, List<GameObject> gos);

		bool ValidateSkinnedMeshes(List<GameObject> mom);

		void CommitChangesToAssets();

		void OnPreTextureBake();

		void OnPostTextureBake();

		void Destroy(UnityEngine.Object o);
	}
	public enum MB2_LogLevel
	{
		none,
		error,
		warn,
		info,
		debug,
		trace
	}
	public class MB2_Log
	{
		public static void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			if (l <= currentThreshold)
			{
				if (l == MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError(msg);
				}
				if (l == MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning($"frm={Time.frameCount} WARN {msg}");
				}
				if (l == MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} INFO {msg}");
				}
				if (l == MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} DEBUG {msg}");
				}
				if (l == MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} TRACE {msg}");
				}
			}
		}

		public static string Error(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} ERROR {arg}";
			UnityEngine.Debug.LogError(text);
			return text;
		}

		public static string Warn(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} WARN {arg}";
			UnityEngine.Debug.LogWarning(text);
			return text;
		}

		public static string Info(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} INFO {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string LogDebug(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} DEBUG {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string Trace(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} TRACE {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}
	}
	public class ObjectLog
	{
		private int pos;

		private string[] logMessages;

		public ObjectLog(short bufferSize)
		{
			logMessages = new string[bufferSize];
		}

		private void _CacheLogMessage(string msg)
		{
			if (logMessages.Length != 0)
			{
				logMessages[pos] = msg;
				pos++;
				if (pos >= logMessages.Length)
				{
					pos = 0;
				}
			}
		}

		public void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			MB2_Log.Log(l, msg, currentThreshold);
			_CacheLogMessage(msg);
		}

		public void Error(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Error(msg, args));
		}

		public void Warn(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Warn(msg, args));
		}

		public void Info(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Info(msg, args));
		}

		public void LogDebug(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.LogDebug(msg, args));
		}

		public void Trace(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Trace(msg, args));
		}

		public string Dump()
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			if (logMessages[logMessages.Length - 1] != null)
			{
				num = pos;
			}
			for (int i = 0; i < logMessages.Length; i++)
			{
				int num2 = (num + i) % logMessages.Length;
				if (logMessages[num2] == null)
				{
					break;
				}
				stringBuilder.AppendLine(logMessages[num2]);
			}
			return stringBuilder.ToString();
		}
	}
	public interface MBVersionInterface
	{
		string version();

		int GetMajorVersion();

		int GetMinorVersion();

		bool GetActive(GameObject go);

		void SetActive(GameObject go, bool isActive);

		void SetActiveRecursively(GameObject go, bool isActive);

		UnityEngine.Object[] FindSceneObjectsOfType(Type t);

		bool IsRunningAndMeshNotReadWriteable(Mesh m);

		Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL);

		void MeshClear(Mesh m, bool t);

		void MeshAssignUV3(Mesh m, Vector2[] uv3s);

		void MeshAssignUV4(Mesh m, Vector2[] uv4s);

		Vector4 GetLightmapTilingOffset(Renderer r);

		Transform[] GetBones(Renderer r);

		void OptimizeMesh(Mesh m);

		int GetBlendShapeFrameCount(Mesh m, int shapeIndex);

		float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex);

		void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts);

		void ClearBlendShapes(Mesh m);

		void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts);
	}
	public class MBVersion
	{
		private static MBVersionInterface _MBVersion;

		private static MBVersionInterface _CreateMBVersionConcrete()
		{
			Type type = null;
			type = typeof(MBVersionConcrete);
			return (MBVersionInterface)Activator.CreateInstance(type);
		}

		public static string version()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.version();
		}

		public static int GetMajorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMajorVersion();
		}

		public static int GetMinorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMinorVersion();
		}

		public static bool GetActive(GameObject go)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetActive(go);
		}

		public static void SetActive(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActive(go, isActive);
		}

		public static void SetActiveRecursively(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActiveRecursively(go, isActive);
		}

		public static UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.FindSceneObjectsOfType(t);
		}

		public static bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.IsRunningAndMeshNotReadWriteable(m);
		}

		public static Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMeshUV3orUV4(m, get3, LOG_LEVEL);
		}

		public static void MeshClear(Mesh m, bool t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshClear(m, t);
		}

		public static void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV3(m, uv3s);
		}

		public static void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV4(m, uv4s);
		}

		public static Vector4 GetLightmapTilingOffset(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetLightmapTilingOffset(r);
		}

		public static Transform[] GetBones(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBones(r);
		}

		public static void OptimizeMesh(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.OptimizeMesh(m);
		}

		public static int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameCount(m, shapeIndex);
		}

		public static float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameWeight(m, shapeIndex, frameIndex);
		}

		public static void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.GetBlendShapeFrameVertices(m, shapeIndex, frameIndex, vs, ns, ts);
		}

		public static void ClearBlendShapes(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.ClearBlendShapes(m);
		}

		public static void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.AddBlendShapeFrame(m, nm, wt, vs, ns, ts);
		}
	}
	public class MB2_TexturePacker
	{
		private enum NodeType
		{
			Container,
			maxDim,
			regular
		}

		private class PixRect
		{
			public int x;

			public int y;

			public int w;

			public int h;

			public PixRect()
			{
			}

			public PixRect(int xx, int yy, int ww, int hh)
			{
				x = xx;
				y = yy;
				w = ww;
				h = hh;
			}

			public override string ToString()
			{
				return $"x={x},y={y},w={w},h={h}";
			}
		}

		private class Image
		{
			public int imgId;

			public int w;

			public int h;

			public int x;

			public int y;

			public Image(int id, int tw, int th, int padding, int minImageSizeX, int minImageSizeY)
			{
				imgId = id;
				w = Mathf.Max(tw + padding * 2, minImageSizeX);
				h = Mathf.Max(th + padding * 2, minImageSizeY);
			}

			public Image(Image im)
			{
				imgId = im.imgId;
				w = im.w;
				h = im.h;
				x = im.x;
				y = im.y;
			}
		}

		private class ImgIDComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.imgId > y.imgId)
				{
					return 1;
				}
				if (x.imgId == y.imgId)
				{
					return 0;
				}
				return -1;
			}
		}

		private class ImageHeightComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.h > y.h)
				{
					return -1;
				}
				if (x.h == y.h)
				{
					return 0;
				}
				return 1;
			}
		}

		private class ImageWidthComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.w > y.w)
				{
					return -1;
				}
				if (x.w == y.w)
				{
					return 0;
				}
				return 1;
			}
		}

		private class ImageAreaComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				int num = x.w * x.h;
				int num2 = y.w * y.h;
				if (num > num2)
				{
					return -1;
				}
				if (num == num2)
				{
					return 0;
				}
				return 1;
			}
		}

		private class ProbeResult
		{
			public int w;

			public int h;

			public int outW;

			public int outH;

			public Node root;

			public bool largerOrEqualToMaxDim;

			public float efficiency;

			public float squareness;

			public float totalAtlasArea;

			public int numAtlases;

			public void Set(int ww, int hh, int outw, int outh, Node r, bool fits, float e, float sq)
			{
				w = ww;
				h = hh;
				outW = outw;
				outH = outh;
				root = r;
				largerOrEqualToMaxDim = fits;
				efficiency = e;
				squareness = sq;
			}

			public float GetScore(bool doPowerOfTwoScore)
			{
				float num = ((!largerOrEqualToMaxDim) ? 0f : 1f);
				if (doPowerOfTwoScore)
				{
					return num * 2f + efficiency;
				}
				return squareness + 2f * efficiency + num;
			}

			public void PrintTree()
			{
				printTree(root, "  ");
			}
		}

		private class Node
		{
			public NodeType isFullAtlas;

			public Node[] child = new Node[2];

			public PixRect r;

			public Image img;

			public Node(NodeType rootType)
			{
				isFullAtlas = rootType;
			}

			private bool isLeaf()
			{
				if (child[0] == null || child[1] == null)
				{
					return true;
				}
				return false;
			}

			public Node Insert(Image im, bool handed)
			{
				int num;
				int num2;
				if (handed)
				{
					num = 0;
					num2 = 1;
				}
				else
				{
					num = 1;
					num2 = 0;
				}
				if (!isLeaf())
				{
					Node node = child[num].Insert(im, handed);
					if (node != null)
					{
						return node;
					}
					return child[num2].Insert(im, handed);
				}
				if (img != null)
				{
					return null;
				}
				if (r.w < im.w || r.h < im.h)
				{
					return null;
				}
				if (r.w == im.w && r.h == im.h)
				{
					img = im;
					return this;
				}
				child[num] = new Node(NodeType.regular);
				child[num2] = new Node(NodeType.regular);
				int num3 = r.w - im.w;
				int num4 = r.h - im.h;
				if (num3 > num4)
				{
					child[num].r = new PixRect(r.x, r.y, im.w, r.h);
					child[num2].r = new PixRect(r.x + im.w, r.y, r.w - im.w, r.h);
				}
				else
				{
					child[num].r = new PixRect(r.x, r.y, r.w, im.h);
					child[num2].r = new PixRect(r.x, r.y + im.h, r.w, r.h - im.h);
				}
				return child[num].Insert(im, handed);
			}
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private ProbeResult bestRoot;

		public int atlasY;

		public bool doPowerOfTwoTextures = true;

		private static void printTree(Node r, string spc)
		{
			UnityEngine.Debug.Log(spc + "Nd img=" + (r.img != null) + " r=" + r.r);
			if (r.child[0] != null)
			{
				printTree(r.child[0], spc + "      ");
			}
			if (r.child[1] != null)
			{
				printTree(r.child[1], spc + "      ");
			}
		}

		private static void flattenTree(Node r, List<Image> putHere)
		{
			if (r.img != null)
			{
				r.img.x = r.r.x;
				r.img.y = r.r.y;
				putHere.Add(r.img);
			}
			if (r.child[0] != null)
			{
				flattenTree(r.child[0], putHere);
			}
			if (r.child[1] != null)
			{
				flattenTree(r.child[1], putHere);
			}
		}

		private static void drawGizmosNode(Node r)
		{
			Vector3 size = new Vector3(r.r.w, r.r.h, 0f);
			Vector3 center = new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f);
			Gizmos.color = UnityEngine.Color.yellow;
			Gizmos.DrawWireCube(center, size);
			if (r.img != null)
			{
				Gizmos.color = new UnityEngine.Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
				size = new Vector3(r.img.w, r.img.h, 0f);
				center = new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f);
				Gizmos.DrawCube(center, size);
			}
			if (r.child[0] != null)
			{
				Gizmos.color = UnityEngine.Color.red;
				drawGizmosNode(r.child[0]);
			}
			if (r.child[1] != null)
			{
				Gizmos.color = UnityEngine.Color.green;
				drawGizmosNode(r.child[1]);
			}
		}

		private static Texture2D createFilledTex(UnityEngine.Color c, int w, int h)
		{
			Texture2D texture2D = new Texture2D(w, h);
			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					texture2D.SetPixel(i, j, c);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		public void DrawGizmos()
		{
			if (bestRoot != null)
			{
				drawGizmosNode(bestRoot.root);
				Gizmos.color = UnityEngine.Color.yellow;
				Vector3 size = new Vector3(bestRoot.outW, -bestRoot.outH, 0f);
				Vector3 center = new Vector3(size.x / 2f, size.y / 2f, 0f);
				Gizmos.DrawWireCube(center, size);
			}
		}

		private bool ProbeSingleAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDim, ProbeResult pr)
		{
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				Node node2 = node.Insert(imgsToAdd[i], handed: false);
				if (node2 == null)
				{
					return false;
				}
				if (i != imgsToAdd.Length - 1)
				{
					continue;
				}
				int x = 0;
				int y = 0;
				GetExtent(node, ref x, ref y);
				int num = x;
				int num2 = y;
				bool flag;
				float num6;
				float num7;
				if (doPowerOfTwoTextures)
				{
					num = Mathf.Min(CeilToNearestPowerOfTwo(x), maxAtlasDim);
					num2 = Mathf.Min(CeilToNearestPowerOfTwo(y), maxAtlasDim);
					if (num2 < num / 2)
					{
						num2 = num / 2;
					}
					if (num < num2 / 2)
					{
						num = num2 / 2;
					}
					flag = x <= maxAtlasDim && y <= maxAtlasDim;
					float num3 = Mathf.Max(1f, (float)x / (float)maxAtlasDim);
					float num4 = Mathf.Max(1f, (float)y / (float)maxAtlasDim);
					float num5 = (float)num * num3 * (float)num2 * num4;
					num6 = 1f - (num5 - imgArea) / num5;
					num7 = 1f;
				}
				else
				{
					num6 = 1f - ((float)(x * y) - imgArea) / (float)(x * y);
					num7 = ((x >= y) ? ((float)y / (float)x) : ((float)x / (float)y));
					flag = x <= maxAtlasDim && y <= maxAtlasDim;
				}
				pr.Set(x, y, num, num2, node, flag, num6, num7);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Probe success efficiency w=" + x + " h=" + y + " e=" + num6 + " sq=" + num7 + " fits=" + flag);
				}
				return true;
			}
			UnityEngine.Debug.LogError("Should never get here.");
			return false;
		}

		private bool ProbeMultiAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDim, ProbeResult pr)
		{
			int num = 0;
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				Node node2 = node.Insert(imgsToAdd[i], handed: false);
				if (node2 == null)
				{
					if (imgsToAdd[i].x > idealAtlasW && imgsToAdd[i].y > idealAtlasH)
					{
						return false;
					}
					Node node3 = new Node(NodeType.Container);
					node3.r = new PixRect(0, 0, node.r.w + idealAtlasW, idealAtlasH);
					Node node4 = new Node(NodeType.maxDim);
					node4.r = new PixRect(node.r.w, 0, idealAtlasW, idealAtlasH);
					node3.child[1] = node4;
					node3.child[0] = node;
					node = node3;
					node2 = node.Insert(imgsToAdd[i], handed: false);
					num++;
				}
			}
			pr.numAtlases = num;
			pr.root = node;
			pr.totalAtlasArea = num * maxAtlasDim * maxAtlasDim;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("Probe success efficiency numAtlases=" + num + " totalArea=" + pr.totalAtlasArea);
			}
			return true;
		}

		private void GetExtent(Node r, ref int x, ref int y)
		{
			if (r.img != null)
			{
				if (r.r.x + r.img.w > x)
				{
					x = r.r.x + r.img.w;
				}
				if (r.r.y + r.img.h > y)
				{
					y = r.r.y + r.img.h;
				}
			}
			if (r.child[0] != null)
			{
				GetExtent(r.child[0], ref x, ref y);
			}
			if (r.child[1] != null)
			{
				GetExtent(r.child[1], ref x, ref y);
			}
		}

		private int StepWidthHeight(int oldVal, int step, int maxDim)
		{
			if (doPowerOfTwoTextures && oldVal < maxDim)
			{
				return oldVal * 2;
			}
			int num = oldVal + step;
			if (num > maxDim && oldVal < maxDim)
			{
				num = maxDim;
			}
			return num;
		}

		public static int RoundToNearestPositivePowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.RoundToInt(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public static int CeilToNearestPowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.Ceil(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimension, int padding)
		{
			return GetRects(imgWidthHeights, maxDimension, padding, doMultiAtlas: false);
		}

		public AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimension, int padding, bool doMultiAtlas)
		{
			if (doMultiAtlas)
			{
				return _GetRectsMultiAtlas(imgWidthHeights, maxDimension, padding, 2 + padding * 2, 2 + padding * 2, 2 + padding * 2, 2 + padding * 2);
			}
			AtlasPackingResult atlasPackingResult = _GetRectsSingleAtlas(imgWidthHeights, maxDimension, padding, 2 + padding * 2, 2 + padding * 2, 2 + padding * 2, 2 + padding * 2, 0);
			if (atlasPackingResult == null)
			{
				return null;
			}
			return new AtlasPackingResult[1] { atlasPackingResult };
		}

		private AtlasPackingResult _GetRectsSingleAtlas(List<Vector2> imgWidthHeights, int maxDimension, int padding, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int recursionDepth)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimension={maxDimension}, padding={padding}, minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}, recursionDepth={recursionDepth}");
			}
			if (recursionDepth > 10)
			{
				if (LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Maximum recursion depth reached. Couldn't find packing for these textures.");
				}
				return null;
			}
			float num = 0f;
			int num2 = 0;
			int num3 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			for (int i = 0; i < array.Length; i++)
			{
				int tw = (int)imgWidthHeights[i].x;
				int th = (int)imgWidthHeights[i].y;
				Image image = (array[i] = new Image(i, tw, th, padding, minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				num2 = Mathf.Max(num2, image.w);
				num3 = Mathf.Max(num3, image.h);
			}
			if ((float)num3 / (float)num2 > 2f)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using height Comparer");
				}
				Array.Sort(array, new ImageHeightComparer());
			}
			else if ((double)((float)num3 / (float)num2) < 0.5)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using width Comparer");
				}
				Array.Sort(array, new ImageWidthComparer());
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using area Comparer");
				}
				Array.Sort(array, new ImageAreaComparer());
			}
			int num4 = (int)Mathf.Sqrt(num);
			int num6;
			int num5;
			if (doPowerOfTwoTextures)
			{
				num6 = (num5 = RoundToNearestPositivePowerOfTwo(num4));
				if (num2 > num6)
				{
					num6 = CeilToNearestPowerOfTwo(num6);
				}
				if (num3 > num5)
				{
					num5 = CeilToNearestPowerOfTwo(num5);
				}
			}
			else
			{
				num6 = num4;
				num5 = num4;
				if (num2 > num4)
				{
					num6 = num2;
					num5 = Mathf.Max(Mathf.CeilToInt(num / (float)num2), num3);
				}
				if (num3 > num4)
				{
					num6 = Mathf.Max(Mathf.CeilToInt(num / (float)num3), num2);
					num5 = num3;
				}
			}
			if (num6 == 0)
			{
				num6 = 4;
			}
			if (num5 == 0)
			{
				num5 = 4;
			}
			int num7 = (int)((float)num6 * 0.15f);
			int num8 = (int)((float)num5 * 0.15f);
			if (num7 == 0)
			{
				num7 = 1;
			}
			if (num8 == 0)
			{
				num8 = 1;
			}
			int num9 = 2;
			int num10 = num6;
			int num11 = num5;
			while (num9 >= 1 && num11 < num4 * 1000)
			{
				bool flag = false;
				num9 = 0;
				num10 = num6;
				while (!flag && num10 < num4 * 1000)
				{
					ProbeResult probeResult = new ProbeResult();
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Probing h=" + num11 + " w=" + num10);
					}
					if (ProbeSingleAtlas(array, num10, num11, num, maxDimension, probeResult))
					{
						flag = true;
						if (bestRoot == null)
						{
							bestRoot = probeResult;
						}
						else if (probeResult.GetScore(doPowerOfTwoTextures) > bestRoot.GetScore(doPowerOfTwoTextures))
						{
							bestRoot = probeResult;
						}
						continue;
					}
					num9++;
					num10 = StepWidthHeight(num10, num7, maxDimension);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						MB2_Log.LogDebug("increasing Width h=" + num11 + " w=" + num10);
					}
				}
				num11 = StepWidthHeight(num11, num8, maxDimension);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("increasing Height h=" + num11 + " w=" + num10);
				}
			}
			if (bestRoot == null)
			{
				return null;
			}
			int num12 = 0;
			int num13 = 0;
			if (doPowerOfTwoTextures)
			{
				num12 = Mathf.Min(CeilToNearestPowerOfTwo(bestRoot.w), maxDimension);
				num13 = Mathf.Min(CeilToNearestPowerOfTwo(bestRoot.h), maxDimension);
				if (num13 < num12 / 2)
				{
					num13 = num12 / 2;
				}
				if (num12 < num13 / 2)
				{
					num12 = num13 / 2;
				}
			}
			else
			{
				num12 = Mathf.Min(bestRoot.w, maxDimension);
				num13 = Mathf.Min(bestRoot.h, maxDimension);
			}
			bestRoot.outW = num12;
			bestRoot.outH = num13;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: atlasW=" + num12 + " atlasH" + num13 + " w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim);
			}
			List<Image> list = new List<Image>();
			flattenTree(bestRoot.root, list);
			list.Sort(new ImgIDComparer());
			AtlasPackingResult result = ScaleAtlasToFitMaxDim(bestRoot, imgWidthHeights, list, maxDimension, padding, minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, num12, num13, recursionDepth);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug($"Done GetRects atlasW={bestRoot.w} atlasH={bestRoot.h}");
			}
			return result;
		}

		private AtlasPackingResult ScaleAtlasToFitMaxDim(ProbeResult root, List<Vector2> imgWidthHeights, List<Image> images, int maxDimension, int padding, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int outW, int outH, int recursionDepth)
		{
			int minImageSizeX2 = minImageSizeX;
			int minImageSizeY2 = minImageSizeY;
			bool flag = false;
			float num = (float)padding / (float)outW;
			if (root.w > maxDimension)
			{
				num = (float)padding / (float)maxDimension;
				float num2 = (float)maxDimension / (float)root.w;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas width shrinking to " + num2);
				}
				for (int i = 0; i < images.Count; i++)
				{
					Image image = images[i];
					if ((float)image.w * num2 < (float)masterImageSizeX)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeX.");
						}
						flag = true;
						minImageSizeX2 = Mathf.CeilToInt((float)minImageSizeX / num2);
					}
					int num3 = (int)((float)(image.x + image.w) * num2);
					image.x = (int)(num2 * (float)image.x);
					image.w = num3 - image.x;
				}
				outW = maxDimension;
			}
			float num4 = (float)padding / (float)outH;
			if (root.h > maxDimension)
			{
				num4 = (float)padding / (float)maxDimension;
				float num5 = (float)maxDimension / (float)root.h;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas height shrinking to " + num5);
				}
				for (int j = 0; j < images.Count; j++)
				{
					Image image2 = images[j];
					if ((float)image2.h * num5 < (float)masterImageSizeY)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeY.");
						}
						flag = true;
						minImageSizeY2 = Mathf.CeilToInt((float)minImageSizeY / num5);
					}
					int num6 = (int)((float)(image2.y + image2.h) * num5);
					image2.y = (int)(num5 * (float)image2.y);
					image2.h = num6 - image2.y;
				}
				outH = maxDimension;
			}
			if (!flag)
			{
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult();
				atlasPackingResult.rects = new Rect[images.Count];
				atlasPackingResult.srcImgIdxs = new int[images.Count];
				atlasPackingResult.atlasX = outW;
				atlasPackingResult.atlasY = outH;
				atlasPackingResult.usedW = -1;
				atlasPackingResult.usedH = -1;
				for (int k = 0; k < images.Count; k++)
				{
					Image image3 = images[k];
					ref Rect reference = ref atlasPackingResult.rects[k];
					Rect rect = (reference = new Rect((float)image3.x / (float)outW + num, (float)image3.y / (float)outH + num4, (float)image3.w / (float)outW - num * 2f, (float)image3.h / (float)outH - num4 * 2f));
					atlasPackingResult.srcImgIdxs[k] = image3.imgId;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Image: " + k + " imgID=" + image3.imgId + " x=" + rect.x * (float)outW + " y=" + rect.y * (float)outH + " w=" + rect.width * (float)outW + " h=" + rect.height * (float)outH + " padding=" + padding);
					}
				}
				return atlasPackingResult;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("==================== REDOING PACKING ================");
			}
			root = null;
			return _GetRectsSingleAtlas(imgWidthHeights, maxDimension, padding, minImageSizeX2, minImageSizeY2, masterImageSizeX, masterImageSizeY, recursionDepth + 1);
		}

		private AtlasPackingResult[] _GetRectsMultiAtlas(List<Vector2> imgWidthHeights, int maxDimensionPassed, int padding, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimension={maxDimensionPassed}, padding={padding}, minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}");
			}
			float num = 0f;
			int a = 0;
			int a2 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			int num2 = maxDimensionPassed;
			if (doPowerOfTwoTextures)
			{
				num2 = RoundToNearestPositivePowerOfTwo(num2);
			}
			for (int i = 0; i < array.Length; i++)
			{
				int a3 = (int)imgWidthHeights[i].x;
				int a4 = (int)imgWidthHeights[i].y;
				a3 = Mathf.Min(a3, num2 - padding * 2);
				a4 = Mathf.Min(a4, num2 - padding * 2);
				Image image = (array[i] = new Image(i, a3, a4, padding, minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				a = Mathf.Max(a, image.w);
				a2 = Mathf.Max(a2, image.h);
			}
			int num3;
			int num4;
			if (doPowerOfTwoTextures)
			{
				num3 = RoundToNearestPositivePowerOfTwo(num2);
				num4 = RoundToNearestPositivePowerOfTwo(num2);
			}
			else
			{
				num3 = num2;
				num4 = num2;
			}
			if (num4 == 0)
			{
				num4 = 4;
			}
			if (num3 == 0)
			{
				num3 = 4;
			}
			ProbeResult probeResult = new ProbeResult();
			Array.Sort(array, new ImageHeightComparer());
			if (ProbeMultiAtlas(array, num4, num3, num, num2, probeResult))
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageWidthComparer());
			if (ProbeMultiAtlas(array, num4, num3, num, num2, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageAreaComparer());
			if (ProbeMultiAtlas(array, num4, num3, num, num2, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			if (bestRoot == null)
			{
				return null;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim);
			}
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			List<Node> list2 = new List<Node>();
			Stack<Node> stack = new Stack<Node>();
			for (Node node = bestRoot.root; node != null; node = node.child[0])
			{
				stack.Push(node);
			}
			while (stack.Count > 0)
			{
				Node node = stack.Pop();
				if (node.isFullAtlas == NodeType.maxDim)
				{
					list2.Add(node);
				}
				if (node.child[1] != null)
				{
					for (node = node.child[1]; node != null; node = node.child[0])
					{
						stack.Push(node);
					}
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				List<Image> list3 = new List<Image>();
				flattenTree(list2[j], list3);
				Rect[] array2 = new Rect[list3.Count];
				int[] array3 = new int[list3.Count];
				for (int k = 0; k < list3.Count; k++)
				{
					ref Rect reference = ref array2[k];
					reference = new Rect(list3[k].x - list2[j].r.x, list3[k].y, list3[k].w, list3[k].h);
					array3[k] = list3[k].imgId;
				}
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult();
				GetExtent(list2[j], ref atlasPackingResult.usedW, ref atlasPackingResult.usedH);
				atlasPackingResult.usedW -= list2[j].r.x;
				int w = list2[j].r.w;
				int h = list2[j].r.h;
				if (doPowerOfTwoTextures)
				{
					w = Mathf.Min(CeilToNearestPowerOfTwo(atlasPackingResult.usedW), list2[j].r.w);
					h = Mathf.Min(CeilToNearestPowerOfTwo(atlasPackingResult.usedH), list2[j].r.h);
					if (h < w / 2)
					{
						h = w / 2;
					}
					if (w < h / 2)
					{
						w = h / 2;
					}
				}
				else
				{
					w = atlasPackingResult.usedW;
					h = atlasPackingResult.usedH;
				}
				atlasPackingResult.atlasY = h;
				atlasPackingResult.atlasX = w;
				atlasPackingResult.rects = array2;
				atlasPackingResult.srcImgIdxs = array3;
				list.Add(atlasPackingResult);
				normalizeRects(atlasPackingResult, padding);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug($"Done GetRects ");
				}
			}
			return list.ToArray();
		}

		private void normalizeRects(AtlasPackingResult rr, int padding)
		{
			for (int i = 0; i < rr.rects.Length; i++)
			{
				rr.rects[i].x = (rr.rects[i].x + (float)padding) / (float)rr.atlasX;
				rr.rects[i].y = (rr.rects[i].y + (float)padding) / (float)rr.atlasY;
				rr.rects[i].width = (rr.rects[i].width - (float)(padding * 2)) / (float)rr.atlasX;
				rr.rects[i].height = (rr.rects[i].height - (float)(padding * 2)) / (float)rr.atlasY;
			}
		}
	}
	public class AtlasPackingResult
	{
		public int atlasX;

		public int atlasY;

		public int usedW;

		public int usedH;

		public Rect[] rects;

		public int[] srcImgIdxs;

		public object data;
	}
}
public class MB_TextureCombinerRenderTexture
{
	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	private Material mat;

	private RenderTexture _destinationTexture;

	private Camera myCamera;

	private int _padding;

	private bool _isNormalMap;

	private bool _fixOutOfBoundsUVs;

	private bool _doRenderAtlas;

	private Rect[] rs;

	private List<MB3_TextureCombiner.MB_TexSet> textureSets;

	private int indexOfTexSetToRender;

	private ShaderTextureProperty _texPropertyName;

	private TextureBlender _resultMaterialTextureBlender;

	private Texture2D targTex;

	private MB3_TextureCombiner combiner;

	public Texture2D DoRenderAtlas(GameObject gameObject, int width, int height, int padding, Rect[] rss, List<MB3_TextureCombiner.MB_TexSet> textureSetss, int indexOfTexSetToRenders, ShaderTextureProperty texPropertyname, TextureBlender resultMaterialTextureBlender, bool isNormalMap, bool fixOutOfBoundsUVs, bool considerNonTextureProperties, MB3_TextureCombiner texCombiner, MB2_LogLevel LOG_LEV)
	{
		LOG_LEVEL = LOG_LEV;
		textureSets = textureSetss;
		indexOfTexSetToRender = indexOfTexSetToRenders;
		_texPropertyName = texPropertyname;
		_padding = padding;
		_isNormalMap = isNormalMap;
		_fixOutOfBoundsUVs = fixOutOfBoundsUVs;
		_resultMaterialTextureBlender = resultMaterialTextureBlender;
		combiner = texCombiner;
		rs = rss;
		Shader shader = ((!_isNormalMap) ? Shader.Find("MeshBaker/AlbedoShader") : Shader.Find("MeshBaker/NormalMapShader"));
		if (shader == null)
		{
			UnityEngine.Debug.LogError("Could not find shader for RenderTexture. Try reimporting mesh baker");
			return null;
		}
		mat = new Material(shader);
		_destinationTexture = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
		_destinationTexture.filterMode = FilterMode.Point;
		myCamera = gameObject.GetComponent<Camera>();
		myCamera.orthographic = true;
		myCamera.orthographicSize = height >> 1;
		myCamera.aspect = width / height;
		myCamera.targetTexture = _destinationTexture;
		myCamera.clearFlags = CameraClearFlags.Color;
		Transform component = myCamera.GetComponent<Transform>();
		component.localPosition = new Vector3((float)width / 2f, (float)height / 2f, 3f);
		component.localRotation = Quaternion.Euler(0f, 180f, 180f);
		_doRenderAtlas = true;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log($"Begin Camera.Render destTex w={width} h={height} camPos={component.localPosition}");
		}
		myCamera.Render();
		_doRenderAtlas = false;
		MB_Utility.Destroy(mat);
		MB_Utility.Destroy(_destinationTexture);
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Finished Camera.Render ");
		}
		Texture2D result = targTex;
		targTex = null;
		return result;
	}

	public void OnRenderObject()
	{
		if (!_doRenderAtlas)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		for (int i = 0; i < rs.Length; i++)
		{
			MB3_TextureCombiner.MeshBakerMaterialTexture meshBakerMaterialTexture = textureSets[i].ts[indexOfTexSetToRender];
			if (LOG_LEVEL >= MB2_LogLevel.trace && meshBakerMaterialTexture.t != null)
			{
				UnityEngine.Debug.Log(string.Concat("Added ", meshBakerMaterialTexture.t, " to atlas w=", meshBakerMaterialTexture.t.width, " h=", meshBakerMaterialTexture.t.height, " offset=", meshBakerMaterialTexture.matTilingRect.min, " scale=", meshBakerMaterialTexture.matTilingRect.size, " rect=", rs[i], " padding=", _padding));
				_printTexture(meshBakerMaterialTexture.t);
			}
			CopyScaledAndTiledToAtlas(textureSets[i], meshBakerMaterialTexture, textureSets[i].obUVoffset, textureSets[i].obUVscale, rs[i], _texPropertyName, _resultMaterialTextureBlender);
		}
		stopwatch.Stop();
		stopwatch.Start();
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time for Graphics.DrawTexture calls " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Copying RenderTexture to Texture2D. destW" + _destinationTexture.width + " destH" + _destinationTexture.height);
		}
		Texture2D texture2D = new Texture2D(_destinationTexture.width, _destinationTexture.height, TextureFormat.ARGB32, mipmap: true);
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		int num = _destinationTexture.width / 512;
		int num2 = _destinationTexture.height / 512;
		if (num == 0 || num2 == 0)
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Copying all in one shot");
			}
			texture2D.ReadPixels(new Rect(0f, 0f, _destinationTexture.width, _destinationTexture.height), 0, 0, recalculateMipMaps: true);
		}
		else if (IsOpenGL())
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("OpenGL copying blocks");
			}
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num2; k++)
				{
					texture2D.ReadPixels(new Rect(j * 512, k * 512, 512f, 512f), j * 512, k * 512, recalculateMipMaps: true);
				}
			}
		}
		else
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Not OpenGL copying blocks");
			}
			for (int l = 0; l < num; l++)
			{
				for (int m = 0; m < num2; m++)
				{
					texture2D.ReadPixels(new Rect(l * 512, _destinationTexture.height - 512 - m * 512, 512f, 512f), l * 512, m * 512, recalculateMipMaps: true);
				}
			}
		}
		RenderTexture.active = active;
		texture2D.Apply();
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("TempTexture ");
			_printTexture(texture2D);
		}
		myCamera.targetTexture = null;
		RenderTexture.active = null;
		targTex = texture2D;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time to copy RenderTexture to Texture2D " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
	}

	private Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
	{
		Vector3 zero = Vector3.zero;
		zero.x = (float)(int)c.a * 2f - 1f;
		zero.y = (float)(int)c.g * 2f - 1f;
		zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
		Color32 result = default(Color32);
		result.a = 1;
		result.r = (byte)((zero.x + 1f) * 0.5f);
		result.g = (byte)((zero.y + 1f) * 0.5f);
		result.b = (byte)((zero.z + 1f) * 0.5f);
		return result;
	}

	private bool IsOpenGL()
	{
		string graphicsDeviceVersion = SystemInfo.graphicsDeviceVersion;
		return graphicsDeviceVersion.StartsWith("OpenGL");
	}

	private void CopyScaledAndTiledToAtlas(MB3_TextureCombiner.MB_TexSet texSet, MB3_TextureCombiner.MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, Rect rec, ShaderTextureProperty texturePropertyName, TextureBlender resultMatTexBlender)
	{
		Rect rect = rec;
		if (resultMatTexBlender != null)
		{
			myCamera.backgroundColor = resultMatTexBlender.GetColorIfNoTexture(texSet.matsAndGOs.mats[0].mat, texturePropertyName);
		}
		else
		{
			myCamera.backgroundColor = MB3_TextureCombiner.GetColorIfNoTexture(texturePropertyName);
		}
		if (source.t == null)
		{
			source.t = combiner._createTemporaryTexture(16, 16, TextureFormat.ARGB32, mipMaps: true);
		}
		rect.y = 1f - (rect.y + rect.height);
		rect.x *= _destinationTexture.width;
		rect.y *= _destinationTexture.height;
		rect.width *= _destinationTexture.width;
		rect.height *= _destinationTexture.height;
		Rect rect2 = rect;
		rect2.x -= _padding;
		rect2.y -= _padding;
		rect2.width += _padding * 2;
		rect2.height += _padding * 2;
		Rect r = source.matTilingRect.GetRect();
		Rect screenRect = default(Rect);
		if (_fixOutOfBoundsUVs)
		{
			Rect r2 = new Rect(obUVoffset.x, obUVoffset.y, obUVscale.x, obUVscale.y);
			r = MB3_UVTransformUtility.CombineTransforms(ref r, ref r2);
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Fixing out of bounds UVs for tex " + source.t);
			}
		}
		Texture2D t = source.t;
		TextureWrapMode wrapMode = t.wrapMode;
		if (r.width == 1f && r.height == 1f && r.x == 0f && r.y == 0f)
		{
			t.wrapMode = TextureWrapMode.Clamp;
		}
		else
		{
			t.wrapMode = TextureWrapMode.Repeat;
		}
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log(string.Concat("DrawTexture tex=", t.name, " destRect=", rect, " srcRect=", r, " Mat=", mat));
		}
		Rect sourceRect = default(Rect);
		sourceRect.x = r.x;
		sourceRect.y = r.y + 1f - 1f / (float)t.height;
		sourceRect.width = r.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x;
		screenRect.y = rect2.y;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y;
		sourceRect.width = r.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = r.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x + 1f - 1f / (float)t.width;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = r.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y + 1f - 1f / (float)t.height;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect2.x;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x + 1f - 1f / (float)t.width;
		sourceRect.y = r.y + 1f - 1f / (float)t.height;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = r.x + 1f - 1f / (float)t.width;
		sourceRect.y = r.y;
		sourceRect.width = 1f / (float)t.width;
		sourceRect.height = 1f / (float)t.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		UnityEngine.Graphics.DrawTexture(screenRect, t, sourceRect, 0, 0, 0, 0, mat);
		UnityEngine.Graphics.DrawTexture(rect, t, r, 0, 0, 0, 0, mat);
		RenderTexture.active = active;
		t.wrapMode = wrapMode;
	}

	private void _printTexture(Texture2D t)
	{
		if (t.width * t.height > 100)
		{
			UnityEngine.Debug.Log("Not printing texture too large.");
		}
		try
		{
			Color32[] pixels = t.GetPixels32();
			string text = string.Empty;
			for (int i = 0; i < t.height; i++)
			{
				for (int j = 0; j < t.width; j++)
				{
					text = string.Concat(text, pixels[i * t.width + j], ", ");
				}
				text += "\n";
			}
			UnityEngine.Debug.Log(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("Could not print texture. texture may not be readable." + ex.ToString());
		}
	}
}
[ExecuteInEditMode]
public class MB3_AtlasPackerRenderTexture : UnityEngine.MonoBehaviour
{
	private MB_TextureCombinerRenderTexture fastRenderer;

	private bool _doRenderAtlas;

	public int width;

	public int height;

	public int padding;

	public bool isNormalMap;

	public bool fixOutOfBoundsUVs;

	public bool considerNonTextureProperties;

	public TextureBlender resultMaterialTextureBlender;

	public Rect[] rects;

	public Texture2D tex1;

	public List<MB3_TextureCombiner.MB_TexSet> textureSets;

	public int indexOfTexSetToRender;

	public ShaderTextureProperty texPropertyName;

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public Texture2D testTex;

	public Material testMat;

	public Texture2D OnRenderAtlas(MB3_TextureCombiner combiner)
	{
		fastRenderer = new MB_TextureCombinerRenderTexture();
		_doRenderAtlas = true;
		Texture2D result = fastRenderer.DoRenderAtlas(base.gameObject, width, height, padding, rects, textureSets, indexOfTexSetToRender, texPropertyName, resultMaterialTextureBlender, isNormalMap, fixOutOfBoundsUVs, considerNonTextureProperties, combiner, LOG_LEVEL);
		_doRenderAtlas = false;
		return result;
	}

	private void OnRenderObject()
	{
		if (_doRenderAtlas)
		{
			fastRenderer.OnRenderObject();
			_doRenderAtlas = false;
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public class MB3_CopyBoneWeights
	{
		public static void CopyBoneWeightsFromSeamMeshToOtherMeshes(float radius, Mesh seamMesh, Mesh[] targetMeshes)
		{
			List<int> list = new List<int>();
			if (seamMesh == null)
			{
				UnityEngine.Debug.LogError($"The SeamMesh cannot be null");
				return;
			}
			if (seamMesh.vertexCount == 0)
			{
				UnityEngine.Debug.LogError("The seam mesh has no vertices. Check that the Asset Importer for the seam mesh does not have 'Optimize Mesh' checked.");
				return;
			}
			Vector3[] vertices = seamMesh.vertices;
			BoneWeight[] boneWeights = seamMesh.boneWeights;
			Vector3[] normals = seamMesh.normals;
			Vector4[] tangents = seamMesh.tangents;
			Vector2[] uv = seamMesh.uv;
			if (uv.Length != vertices.Length)
			{
				UnityEngine.Debug.LogError("The seam mesh needs uvs to identify which vertices are part of the seam. Vertices with UV > .5 are part of the seam. Vertices with UV < .5 are not part of the seam.");
				return;
			}
			for (int i = 0; i < uv.Length; i++)
			{
				if (uv[i].x > 0.5f && uv[i].y > 0.5f)
				{
					list.Add(i);
				}
			}
			UnityEngine.Debug.Log($"The seam mesh has {seamMesh.vertices.Length} vertices of which {list.Count} are seam vertices.");
			if (list.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the vertices in the Seam Mesh were marked as seam vertices. To mark a vertex as a seam vertex the UV must be greater than (.5,.5). Vertices with UV less than (.5,.5) are excluded.");
				return;
			}
			bool flag = false;
			for (int j = 0; j < targetMeshes.Length; j++)
			{
				if (targetMeshes[j] == null)
				{
					UnityEngine.Debug.LogError($"Mesh {j} was null");
					flag = true;
				}
				if (radius < 0f)
				{
					UnityEngine.Debug.LogError("radius must be zero or positive.");
				}
			}
			if (flag)
			{
				return;
			}
			for (int k = 0; k < targetMeshes.Length; k++)
			{
				Mesh mesh = targetMeshes[k];
				Vector3[] vertices2 = mesh.vertices;
				BoneWeight[] boneWeights2 = mesh.boneWeights;
				Vector3[] normals2 = mesh.normals;
				Vector4[] tangents2 = mesh.tangents;
				int num = 0;
				for (int l = 0; l < vertices2.Length; l++)
				{
					for (int m = 0; m < list.Count; m++)
					{
						int num2 = list[m];
						if (Vector3.Distance(vertices2[l], vertices[num2]) <= radius)
						{
							num++;
							ref BoneWeight reference = ref boneWeights2[l];
							reference = boneWeights[num2];
							ref Vector3 reference2 = ref vertices2[l];
							reference2 = vertices[num2];
							if (normals2.Length == vertices2.Length && normals.Length == normals.Length)
							{
								ref Vector3 reference3 = ref normals2[l];
								reference3 = normals[num2];
							}
							if (tangents2.Length == vertices2.Length && tangents.Length == vertices.Length)
							{
								ref Vector4 reference4 = ref tangents2[l];
								reference4 = tangents[num2];
							}
						}
					}
				}
				if (num > 0)
				{
					targetMeshes[k].vertices = vertices2;
					targetMeshes[k].boneWeights = boneWeights2;
					targetMeshes[k].normals = normals2;
					targetMeshes[k].tangents = tangents2;
				}
				UnityEngine.Debug.Log(string.Format("Copied boneweights for {1} vertices in mesh {0} that matched positions in the seam mesh.", targetMeshes[k].name, num));
			}
		}
	}
	[Serializable]
	public abstract class MB3_MeshCombiner
	{
		public delegate void GenerateUV2Delegate(Mesh m, float hardAngle, float packMargin);

		public class MBBlendShapeKey
		{
			public int gameObjecID;

			public int blendShapeIndexInSrc;

			public MBBlendShapeKey(int srcSkinnedMeshRenderGameObjectID, int blendShapeIndexInSource)
			{
				gameObjecID = srcSkinnedMeshRenderGameObjectID;
				blendShapeIndexInSrc = blendShapeIndexInSource;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MBBlendShapeKey) || obj == null)
				{
					return false;
				}
				MBBlendShapeKey mBBlendShapeKey = (MBBlendShapeKey)obj;
				return gameObjecID == mBBlendShapeKey.gameObjecID && blendShapeIndexInSrc == mBBlendShapeKey.blendShapeIndexInSrc;
			}

			public override int GetHashCode()
			{
				int num = 23;
				num = num * 31 + gameObjecID;
				return num * 31 + blendShapeIndexInSrc;
			}
		}

		public class MBBlendShapeValue
		{
			public GameObject combinedMeshGameObject;

			public int blendShapeIndex;
		}

		[SerializeField]
		protected MB2_LogLevel _LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_ValidationLevel _validationLevel = MB2_ValidationLevel.robust;

		[SerializeField]
		protected string _name;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected GameObject _resultSceneObject;

		[SerializeField]
		protected Renderer _targetRenderer;

		[SerializeField]
		protected MB_RenderType _renderType;

		[SerializeField]
		protected MB2_OutputOptions _outputOption;

		[SerializeField]
		protected MB2_LightmapOptions _lightmapOption = MB2_LightmapOptions.ignore_UV2;

		[SerializeField]
		protected bool _doNorm = true;

		[SerializeField]
		protected bool _doTan = true;

		[SerializeField]
		protected bool _doCol;

		[SerializeField]
		protected bool _doUV = true;

		[SerializeField]
		protected bool _doUV3;

		[SerializeField]
		protected bool _doUV4;

		[SerializeField]
		protected bool _doBlendShapes;

		[SerializeField]
		protected bool _recenterVertsToBoundsCenter;

		[SerializeField]
		public bool _optimizeAfterBake = true;

		[SerializeField]
		public float uv2UnwrappingParamsHardAngle = 60f;

		[SerializeField]
		public float uv2UnwrappingParamsPackMargin = 0.005f;

		protected bool _usingTemporaryTextureBakeResult;

		public static bool EVAL_VERSION => false;

		public virtual MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
			}
		}

		public virtual MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
			}
		}

		public string name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public virtual MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public virtual GameObject resultSceneObject
		{
			get
			{
				return _resultSceneObject;
			}
			set
			{
				_resultSceneObject = value;
			}
		}

		public virtual Renderer targetRenderer
		{
			get
			{
				return _targetRenderer;
			}
			set
			{
				if (_targetRenderer != null && _targetRenderer != value)
				{
					UnityEngine.Debug.LogWarning("Previous targetRenderer was not null. Combined mesh may be being used by more than one Renderer");
				}
				_targetRenderer = value;
			}
		}

		public virtual MB_RenderType renderType
		{
			get
			{
				return _renderType;
			}
			set
			{
				_renderType = value;
			}
		}

		public virtual MB2_OutputOptions outputOption
		{
			get
			{
				return _outputOption;
			}
			set
			{
				_outputOption = value;
			}
		}

		public virtual MB2_LightmapOptions lightmapOption
		{
			get
			{
				return _lightmapOption;
			}
			set
			{
				_lightmapOption = value;
			}
		}

		public virtual bool doNorm
		{
			get
			{
				return _doNorm;
			}
			set
			{
				_doNorm = value;
			}
		}

		public virtual bool doTan
		{
			get
			{
				return _doTan;
			}
			set
			{
				_doTan = value;
			}
		}

		public virtual bool doCol
		{
			get
			{
				return _doCol;
			}
			set
			{
				_doCol = value;
			}
		}

		public virtual bool doUV
		{
			get
			{
				return _doUV;
			}
			set
			{
				_doUV = value;
			}
		}

		public virtual bool doUV1
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public virtual bool doUV3
		{
			get
			{
				return _doUV3;
			}
			set
			{
				_doUV3 = value;
			}
		}

		public virtual bool doUV4
		{
			get
			{
				return _doUV4;
			}
			set
			{
				_doUV4 = value;
			}
		}

		public virtual bool doBlendShapes
		{
			get
			{
				return _doBlendShapes;
			}
			set
			{
				_doBlendShapes = value;
			}
		}

		public virtual bool recenterVertsToBoundsCenter
		{
			get
			{
				return _recenterVertsToBoundsCenter;
			}
			set
			{
				_recenterVertsToBoundsCenter = value;
			}
		}

		public bool optimizeAfterBake
		{
			get
			{
				return _optimizeAfterBake;
			}
			set
			{
				_optimizeAfterBake = value;
			}
		}

		public virtual bool doUV2()
		{
			return _lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged || _lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping || _lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects;
		}

		public abstract int GetLightmapIndex();

		public abstract void ClearBuffers();

		public abstract void ClearMesh();

		public abstract void DestroyMesh();

		public abstract void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods);

		public abstract List<GameObject> GetObjectsInCombined();

		public abstract int GetNumObjectsInCombined();

		public abstract int GetNumVerticesFor(GameObject go);

		public abstract int GetNumVerticesFor(int instanceID);

		public abstract Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap();

		public virtual void Apply()
		{
			Apply(null);
		}

		public abstract void Apply(GenerateUV2Delegate uv2GenerationMethod);

		public abstract void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapeFlag = false, GenerateUV2Delegate uv2GenerationMethod = null);

		public abstract void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false);

		public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

		public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource);

		public abstract bool CombinedMeshContains(GameObject go);

		public abstract void UpdateSkinnedMeshApproximateBounds();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBones();

		public abstract void CheckIntegrity();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBounds();

		public static void UpdateSkinnedMeshApproximateBoundsFromBonesStatic(Transform[] bs, SkinnedMeshRenderer smr)
		{
			Vector3 position = bs[0].position;
			Vector3 position2 = bs[0].position;
			for (int i = 1; i < bs.Length; i++)
			{
				Vector3 position3 = bs[i].position;
				if (position3.x < position2.x)
				{
					position2.x = position3.x;
				}
				if (position3.y < position2.y)
				{
					position2.y = position3.y;
				}
				if (position3.z < position2.z)
				{
					position2.z = position3.z;
				}
				if (position3.x > position.x)
				{
					position.x = position3.x;
				}
				if (position3.y > position.y)
				{
					position.y = position3.y;
				}
				if (position3.z > position.z)
				{
					position.z = position3.z;
				}
			}
			Vector3 vector = (position + position2) / 2f;
			Vector3 vector2 = position - position2;
			Matrix4x4 worldToLocalMatrix = smr.worldToLocalMatrix;
			Bounds localBounds = new Bounds(worldToLocalMatrix * vector, worldToLocalMatrix * vector2);
			smr.localBounds = localBounds;
		}

		public static void UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(List<GameObject> objectsInCombined, SkinnedMeshRenderer smr)
		{
			Bounds b = default(Bounds);
			Bounds bounds = default(Bounds);
			if (MB_Utility.GetBounds(objectsInCombined[0], out b))
			{
				bounds = b;
				for (int i = 1; i < objectsInCombined.Count; i++)
				{
					if (MB_Utility.GetBounds(objectsInCombined[i], out b))
					{
						bounds.Encapsulate(b);
						continue;
					}
					UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
					return;
				}
				smr.localBounds = bounds;
			}
			else
			{
				UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
			}
		}

		protected virtual bool _CreateTemporaryTextrueBakeResult(GameObject[] gos, List<Material> matsOnTargetRenderer)
		{
			if (GetNumObjectsInCombined() > 0)
			{
				UnityEngine.Debug.LogError("Can't add objects if there are already objects in combined mesh when 'Texture Bake Result' is not set. Perhaps enable 'Clear Buffers After Bake'");
				return false;
			}
			_usingTemporaryTextureBakeResult = true;
			_textureBakeResults = MB2_TextureBakeResults.CreateForMaterialsOnRenderer(gos, matsOnTargetRenderer);
			return true;
		}

		public abstract List<Material> GetMaterialsOnTargetRenderer();
	}
	[Serializable]
	public class MB3_MeshCombinerSingle : MB3_MeshCombiner
	{
		[Serializable]
		public class SerializableIntArray
		{
			public int[] data;

			public SerializableIntArray()
			{
			}

			public SerializableIntArray(int len)
			{
				data = new int[len];
			}
		}

		[Serializable]
		public class MB_DynamicGameObject : IComparable<MB_DynamicGameObject>
		{
			public int instanceID;

			public string name;

			public int vertIdx;

			public int blendShapeIdx;

			public int numVerts;

			public int numBlendShapes;

			public int[] indexesOfBonesUsed = new int[0];

			public int lightmapIndex = -1;

			public Vector4 lightmapTilingOffset = new Vector4(1f, 1f, 0f, 0f);

			public Vector3 meshSize = Vector3.one;

			public bool show = true;

			public bool invertTriangles;

			public int[] submeshTriIdxs;

			public int[] submeshNumTris;

			public int[] targetSubmeshIdxs;

			public Rect[] uvRects;

			public Rect[] encapsulatingRect;

			public Rect[] sourceMaterialTiling;

			public Rect[] obUVRects;

			public bool _beingDeleted;

			public int _triangleIdxAdjustment;

			[NonSerialized]
			public SerializableIntArray[] _tmpSubmeshTris;

			[NonSerialized]
			public Transform[] _tmpCachedBones;

			[NonSerialized]
			public Matrix4x4[] _tmpCachedBindposes;

			[NonSerialized]
			public BoneWeight[] _tmpCachedBoneWeights;

			[NonSerialized]
			public int[] _tmpIndexesOfSourceBonesUsed;

			public int CompareTo(MB_DynamicGameObject b)
			{
				return vertIdx - b.vertIdx;
			}
		}

		public class MeshChannels
		{
			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector4[] tangents;

			public Vector2[] uv0raw;

			public Vector2[] uv0modified;

			public Vector2[] uv2;

			public Vector2[] uv3;

			public Vector2[] uv4;

			public UnityEngine.Color[] colors;

			public BoneWeight[] boneWeights;

			public Matrix4x4[] bindPoses;

			public int[] triangles;

			public MBBlendShape[] blendShapes;
		}

		[Serializable]
		public class MBBlendShapeFrame
		{
			public float frameWeight;

			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector3[] tangents;
		}

		[Serializable]
		public class MBBlendShape
		{
			public int gameObjectID;

			public string name;

			public int indexInSource;

			public MBBlendShapeFrame[] frames;
		}

		public class MeshChannelsCache
		{
			private MB3_MeshCombinerSingle mc;

			protected Dictionary<int, MeshChannels> meshID2MeshChannels = new Dictionary<int, MeshChannels>();

			private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

			internal MeshChannelsCache(MB3_MeshCombinerSingle mcs)
			{
				mc = mcs;
			}

			internal Vector3[] GetVertices(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.vertices == null)
				{
					value.vertices = m.vertices;
				}
				return value.vertices;
			}

			internal Vector3[] GetNormals(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.normals == null)
				{
					value.normals = _getMeshNormals(m);
				}
				return value.normals;
			}

			internal Vector4[] GetTangents(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.tangents == null)
				{
					value.tangents = _getMeshTangents(m);
				}
				return value.tangents;
			}

			internal Vector2[] GetUv0Raw(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0raw == null)
				{
					value.uv0raw = _getMeshUVs(m);
				}
				return value.uv0raw;
			}

			internal Vector2[] GetUv0Modified(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0modified == null)
				{
					value.uv0modified = null;
				}
				return value.uv0modified;
			}

			internal Vector2[] GetUv2(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv2 == null)
				{
					value.uv2 = _getMeshUV2s(m);
				}
				return value.uv2;
			}

			internal Vector2[] GetUv3(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv3 == null)
				{
					value.uv3 = MBVersion.GetMeshUV3orUV4(m, get3: true, mc.LOG_LEVEL);
				}
				return value.uv3;
			}

			internal Vector2[] GetUv4(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv4 == null)
				{
					value.uv4 = MBVersion.GetMeshUV3orUV4(m, get3: false, mc.LOG_LEVEL);
				}
				return value.uv4;
			}

			internal UnityEngine.Color[] GetColors(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.colors == null)
				{
					value.colors = _getMeshColors(m);
				}
				return value.colors;
			}

			internal Matrix4x4[] GetBindposes(Renderer r)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.bindPoses == null)
				{
					value.bindPoses = _getBindPoses(r);
				}
				return value.bindPoses;
			}

			internal BoneWeight[] GetBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.boneWeights == null)
				{
					value.boneWeights = _getBoneWeights(r, numVertsInMeshBeingAdded);
				}
				return value.boneWeights;
			}

			internal int[] GetTriangles(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.triangles == null)
				{
					value.triangles = m.triangles;
				}
				return value.triangles;
			}

			internal MBBlendShape[] GetBlendShapes(Mesh m, int gameObjectID)
			{
				if (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3))
				{
					if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
					{
						value = new MeshChannels();
						meshID2MeshChannels.Add(m.GetInstanceID(), value);
					}
					if (value.blendShapes == null)
					{
						MBBlendShape[] array = new MBBlendShape[m.blendShapeCount];
						int vertexCount = m.vertexCount;
						for (int i = 0; i < array.Length; i++)
						{
							MBBlendShape mBBlendShape = (array[i] = new MBBlendShape());
							mBBlendShape.frames = new MBBlendShapeFrame[MBVersion.GetBlendShapeFrameCount(m, i)];
							mBBlendShape.name = m.GetBlendShapeName(i);
							mBBlendShape.indexInSource = i;
							mBBlendShape.gameObjectID = gameObjectID;
							for (int j = 0; j < mBBlendShape.frames.Length; j++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = (mBBlendShape.frames[j] = new MBBlendShapeFrame());
								mBBlendShapeFrame.frameWeight = MBVersion.GetBlendShapeFrameWeight(m, i, j);
								mBBlendShapeFrame.vertices = new Vector3[vertexCount];
								mBBlendShapeFrame.normals = new Vector3[vertexCount];
								mBBlendShapeFrame.tangents = new Vector3[vertexCount];
								MBVersion.GetBlendShapeFrameVertices(m, i, j, mBBlendShapeFrame.vertices, mBBlendShapeFrame.normals, mBBlendShapeFrame.tangents);
							}
						}
						value.blendShapes = array;
						return value.blendShapes;
					}
					MBBlendShape[] array2 = new MBBlendShape[value.blendShapes.Length];
					for (int k = 0; k < array2.Length; k++)
					{
						array2[k] = new MBBlendShape();
						array2[k].name = value.blendShapes[k].name;
						array2[k].indexInSource = value.blendShapes[k].indexInSource;
						array2[k].frames = value.blendShapes[k].frames;
						array2[k].gameObjectID = gameObjectID;
					}
					return array2;
				}
				return new MBBlendShape[0];
			}

			private UnityEngine.Color[] _getMeshColors(Mesh m)
			{
				UnityEngine.Color[] array = m.colors;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no colors. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have colors. Generating an array of white colors"));
					}
					array = new UnityEngine.Color[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						ref UnityEngine.Color reference = ref array[i];
						reference = UnityEngine.Color.white;
					}
				}
				return array;
			}

			private Vector3[] _getMeshNormals(Mesh m)
			{
				Vector3[] normals = m.normals;
				if (normals.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no normals. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have normals. Generating normals."));
					}
					Mesh mesh = UnityEngine.Object.Instantiate(m);
					mesh.RecalculateNormals();
					normals = mesh.normals;
					MB_Utility.Destroy(mesh);
				}
				return normals;
			}

			private Vector4[] _getMeshTangents(Mesh m)
			{
				Vector4[] array = m.tangents;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no tangents. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have tangents. Generating tangents."));
					}
					Vector3[] vertices = m.vertices;
					Vector2[] uv0Raw = GetUv0Raw(m);
					Vector3[] normals = _getMeshNormals(m);
					array = new Vector4[m.vertexCount];
					for (int i = 0; i < m.subMeshCount; i++)
					{
						int[] triangles = m.GetTriangles(i);
						_generateTangents(triangles, vertices, uv0Raw, normals, array);
					}
				}
				return array;
			}

			private Vector2[] _getMeshUVs(Mesh m)
			{
				Vector2[] array = m.uv;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uvs. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uvs. Generating uvs."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						ref Vector2 reference = ref array[i];
						reference = _HALF_UV;
					}
				}
				return array;
			}

			private Vector2[] _getMeshUV2s(Mesh m)
			{
				Vector2[] array = m.uv2;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv2s. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv2s. Generating uv2s."));
					}
					if (mc._lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
					{
						UnityEngine.Debug.LogError(string.Concat("Mesh ", m, " did not have a UV2 channel. Nothing to copy when trying to copy UV2 to separate rects. The combined mesh will not lightmap properly. Try using generate new uv2 layout."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						ref Vector2 reference = ref array[i];
						reference = _HALF_UV;
					}
				}
				return array;
			}

			public static Matrix4x4[] _getBindPoses(Renderer r)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.bindposes;
				}
				if (r is MeshRenderer)
				{
					Matrix4x4 identity = Matrix4x4.identity;
					return new Matrix4x4[1] { identity };
				}
				UnityEngine.Debug.LogError("Could not _getBindPoses. Object does not have a renderer");
				return null;
			}

			public static BoneWeight[] _getBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.boneWeights;
				}
				if (r is MeshRenderer)
				{
					BoneWeight boneWeight = default(BoneWeight);
					int num2 = (boneWeight.boneIndex3 = 0);
					num2 = (boneWeight.boneIndex2 = num2);
					num2 = (boneWeight.boneIndex1 = num2);
					boneWeight.boneIndex0 = num2;
					boneWeight.weight0 = 1f;
					float num6 = (boneWeight.weight3 = 0f);
					num6 = (boneWeight.weight2 = num6);
					boneWeight.weight1 = num6;
					BoneWeight[] array = new BoneWeight[numVertsInMeshBeingAdded];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = boneWeight;
					}
					return array;
				}
				UnityEngine.Debug.LogError("Could not _getBoneWeights. Object does not have a renderer");
				return null;
			}

			private void _generateTangents(int[] triangles, Vector3[] verts, Vector2[] uvs, Vector3[] normals, Vector4[] outTangents)
			{
				int num = triangles.Length;
				int num2 = verts.Length;
				Vector3[] array = new Vector3[num2];
				Vector3[] array2 = new Vector3[num2];
				for (int i = 0; i < num; i += 3)
				{
					int num3 = triangles[i];
					int num4 = triangles[i + 1];
					int num5 = triangles[i + 2];
					Vector3 vector = verts[num3];
					Vector3 vector2 = verts[num4];
					Vector3 vector3 = verts[num5];
					Vector2 vector4 = uvs[num3];
					Vector2 vector5 = uvs[num4];
					Vector2 vector6 = uvs[num5];
					float num6 = vector2.x - vector.x;
					float num7 = vector3.x - vector.x;
					float num8 = vector2.y - vector.y;
					float num9 = vector3.y - vector.y;
					float num10 = vector2.z - vector.z;
					float num11 = vector3.z - vector.z;
					float num12 = vector5.x - vector4.x;
					float num13 = vector6.x - vector4.x;
					float num14 = vector5.y - vector4.y;
					float num15 = vector6.y - vector4.y;
					float num16 = num12 * num15 - num13 * num14;
					if (num16 == 0f)
					{
						UnityEngine.Debug.LogError("Could not compute tangents. All UVs need to form a valid triangles in UV space. If any UV triangles are collapsed, tangents cannot be generated.");
						return;
					}
					float num17 = 1f / num16;
					Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num17, (num15 * num8 - num14 * num9) * num17, (num15 * num10 - num14 * num11) * num17);
					Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num17, (num12 * num9 - num13 * num8) * num17, (num12 * num11 - num13 * num10) * num17);
					array[num3] += vector7;
					array[num4] += vector7;
					array[num5] += vector7;
					array2[num3] += vector8;
					array2[num4] += vector8;
					array2[num5] += vector8;
				}
				for (int j = 0; j < num2; j++)
				{
					Vector3 vector9 = normals[j];
					Vector3 vector10 = array[j];
					Vector3 normalized = (vector10 - vector9 * Vector3.Dot(vector9, vector10)).normalized;
					ref Vector4 reference = ref outTangents[j];
					reference = new Vector4(normalized.x, normalized.y, normalized.z);
					outTangents[j].w = ((!(Vector3.Dot(Vector3.Cross(vector9, vector10), array2[j]) < 0f)) ? 1f : (-1f));
				}
			}
		}

		public struct BoneAndBindpose
		{
			public Transform bone;

			public Matrix4x4 bindPose;

			public BoneAndBindpose(Transform t, Matrix4x4 bp)
			{
				bone = t;
				bindPose = bp;
			}

			public override bool Equals(object obj)
			{
				if (obj is BoneAndBindpose && bone == ((BoneAndBindpose)obj).bone && bindPose == ((BoneAndBindpose)obj).bindPose)
				{
					return true;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (bone.GetInstanceID() % int.MaxValue) ^ (int)bindPose[0, 0];
			}
		}

		[SerializeField]
		protected List<GameObject> objectsInCombinedMesh = new List<GameObject>();

		[SerializeField]
		private int lightmapIndex = -1;

		[SerializeField]
		private List<MB_DynamicGameObject> mbDynamicObjectsInCombinedMesh = new List<MB_DynamicGameObject>();

		private Dictionary<int, MB_DynamicGameObject> _instance2combined_map = new Dictionary<int, MB_DynamicGameObject>();

		[SerializeField]
		private Vector3[] verts = new Vector3[0];

		[SerializeField]
		private Vector3[] normals = new Vector3[0];

		[SerializeField]
		private Vector4[] tangents = new Vector4[0];

		[SerializeField]
		private Vector2[] uvs = new Vector2[0];

		[SerializeField]
		private Vector2[] uv2s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv3s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv4s = new Vector2[0];

		[SerializeField]
		private UnityEngine.Color[] colors = new UnityEngine.Color[0];

		[SerializeField]
		private Matrix4x4[] bindPoses = new Matrix4x4[0];

		[SerializeField]
		private Transform[] bones = new Transform[0];

		[SerializeField]
		internal MBBlendShape[] blendShapes = new MBBlendShape[0];

		[SerializeField]
		internal MBBlendShape[] blendShapesInCombined = new MBBlendShape[0];

		[SerializeField]
		private SerializableIntArray[] submeshTris = new SerializableIntArray[0];

		[SerializeField]
		private Mesh _mesh;

		private BoneWeight[] boneWeights = new BoneWeight[0];

		private GameObject[] empty = new GameObject[0];

		private int[] emptyIDs = new int[0];

		public override MB2_TextureBakeResults textureBakeResults
		{
			set
			{
				if (mbDynamicObjectsInCombinedMesh.Count > 0 && _textureBakeResults != value && _textureBakeResults != null && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("If Texture Bake Result is changed then objects currently in combined mesh may be invalid.");
				}
				_textureBakeResults = value;
			}
		}

		public override MB_RenderType renderType
		{
			set
			{
				if (value == MB_RenderType.skinnedMeshRenderer && _renderType == MB_RenderType.meshRenderer && boneWeights.Length != verts.Length)
				{
					UnityEngine.Debug.LogError("Can't set the render type to SkinnedMeshRenderer without clearing the mesh first. Try deleteing the CombinedMesh scene object.");
				}
				_renderType = value;
			}
		}

		public override GameObject resultSceneObject
		{
			set
			{
				if (_resultSceneObject != value)
				{
					_targetRenderer = null;
					if (_mesh != null && _LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result Scene Object was changed when this mesh baker component had a reference to a mesh. If mesh is being used by another object make sure to reset the mesh to none before baking to avoid overwriting the other mesh.");
					}
				}
				_resultSceneObject = value;
			}
		}

		private MB_DynamicGameObject instance2Combined_MapGet(int gameObjectID)
		{
			return _instance2combined_map[gameObjectID];
		}

		private void instance2Combined_MapAdd(int gameObjectID, MB_DynamicGameObject dgo)
		{
			_instance2combined_map.Add(gameObjectID, dgo);
		}

		private void instance2Combined_MapRemove(int gameObjectID)
		{
			_instance2combined_map.Remove(gameObjectID);
		}

		private bool instance2Combined_MapTryGetValue(int gameObjectID, out MB_DynamicGameObject dgo)
		{
			return _instance2combined_map.TryGetValue(gameObjectID, out dgo);
		}

		private int instance2Combined_MapCount()
		{
			return _instance2combined_map.Count;
		}

		private void instance2Combined_MapClear()
		{
			_instance2combined_map.Clear();
		}

		private bool instance2Combined_MapContainsKey(int gameObjectID)
		{
			return _instance2combined_map.ContainsKey(gameObjectID);
		}

		public override int GetNumObjectsInCombined()
		{
			return mbDynamicObjectsInCombinedMesh.Count;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			list.AddRange(objectsInCombinedMesh);
			return list;
		}

		public Mesh GetMesh()
		{
			if (_mesh == null)
			{
				_mesh = new Mesh();
			}
			return _mesh;
		}

		public Transform[] GetBones()
		{
			return bones;
		}

		public override int GetLightmapIndex()
		{
			if (lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout || lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				return lightmapIndex;
			}
			return -1;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			return GetNumVerticesFor(go.GetInstanceID());
		}

		public override int GetNumVerticesFor(int instanceID)
		{
			if (instance2Combined_MapTryGetValue(instanceID, out var dgo))
			{
				return dgo.numVerts;
			}
			return -1;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < blendShapesInCombined.Length; i++)
			{
				MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
				mBBlendShapeValue.combinedMeshGameObject = _targetRenderer.gameObject;
				mBBlendShapeValue.blendShapeIndex = i;
				dictionary.Add(new MBBlendShapeKey(blendShapesInCombined[i].gameObjectID, blendShapesInCombined[i].indexInSource), mBBlendShapeValue);
			}
			return dictionary;
		}

		private void _initialize(int numResultMats)
		{
			if (mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				lightmapIndex = -1;
			}
			if (_mesh == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("_initialize Creating new Mesh");
				}
				_mesh = GetMesh();
			}
			if (instance2Combined_MapCount() != mbDynamicObjectsInCombinedMesh.Count)
			{
				instance2Combined_MapClear();
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					if (mbDynamicObjectsInCombinedMesh[i] != null)
					{
						instance2Combined_MapAdd(mbDynamicObjectsInCombinedMesh[i].instanceID, mbDynamicObjectsInCombinedMesh[i]);
					}
				}
				boneWeights = _mesh.boneWeights;
			}
			if (objectsInCombinedMesh.Count == 0 && submeshTris.Length != numResultMats)
			{
				submeshTris = new SerializableIntArray[numResultMats];
				for (int j = 0; j < submeshTris.Length; j++)
				{
					submeshTris[j] = new SerializableIntArray(0);
				}
			}
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && mbDynamicObjectsInCombinedMesh[0].indexesOfBonesUsed.Length == 0 && renderType == MB_RenderType.skinnedMeshRenderer && boneWeights.Length > 0)
			{
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					HashSet<int> hashSet = new HashSet<int>();
					for (int l = mB_DynamicGameObject.vertIdx; l < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; l++)
					{
						if (boneWeights[l].weight0 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex0);
						}
						if (boneWeights[l].weight1 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex1);
						}
						if (boneWeights[l].weight2 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex2);
						}
						if (boneWeights[l].weight3 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex3);
						}
					}
					mB_DynamicGameObject.indexesOfBonesUsed = new int[hashSet.Count];
					hashSet.CopyTo(mB_DynamicGameObject.indexesOfBonesUsed);
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Baker used old systems that duplicated bones. Upgrading to new system by building indexesOfBonesUsed");
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_initialize numObjsInCombined={mbDynamicObjectsInCombinedMesh.Count}");
			}
		}

		private bool _collectMaterialTriangles(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map)
		{
			int num = m.subMeshCount;
			if (sharedMaterials.Length < num)
			{
				num = sharedMaterials.Length;
			}
			dgo._tmpSubmeshTris = new SerializableIntArray[num];
			dgo.targetSubmeshIdxs = new int[num];
			for (int i = 0; i < num; i++)
			{
				if (_textureBakeResults.doMultiMaterial)
				{
					if (!sourceMats2submeshIdx_map.Contains(sharedMaterials[i]))
					{
						UnityEngine.Debug.LogError("Object " + dgo.name + " has a material that was not found in the result materials maping. " + sharedMaterials[i]);
						return false;
					}
					dgo.targetSubmeshIdxs[i] = (int)sourceMats2submeshIdx_map[sharedMaterials[i]];
				}
				else
				{
					dgo.targetSubmeshIdxs[i] = 0;
				}
				dgo._tmpSubmeshTris[i] = new SerializableIntArray();
				dgo._tmpSubmeshTris[i].data = m.GetTriangles(i);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Collecting triangles for: " + dgo.name + " submesh:" + i + " maps to submesh:" + dgo.targetSubmeshIdxs[i] + " added:" + dgo._tmpSubmeshTris[i].data.Length, LOG_LEVEL);
				}
			}
			return true;
		}

		private bool _collectOutOfBoundsUVRects2(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisResults, MeshChannelsCache meshChannelCache)
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Need to bake textures into combined material");
				return false;
			}
			if (meshAnalysisResults.TryGetValue(m.GetInstanceID(), out var value))
			{
				dgo.obUVRects = new Rect[sharedMaterials.Length];
				for (int i = 0; i < dgo.obUVRects.Length; i++)
				{
					ref Rect reference = ref dgo.obUVRects[i];
					reference = value[i].uvRect;
				}
			}
			else
			{
				int subMeshCount = m.subMeshCount;
				int num = subMeshCount;
				if (sharedMaterials.Length < subMeshCount)
				{
					num = sharedMaterials.Length;
				}
				dgo.obUVRects = new Rect[num];
				value = new MB_Utility.MeshAnalysisResult[subMeshCount];
				for (int j = 0; j < subMeshCount; j++)
				{
					int num2 = dgo.targetSubmeshIdxs[j];
					if (_textureBakeResults.resultMaterials[num2].considerMeshUVs)
					{
						Vector2[] uv0Raw = meshChannelCache.GetUv0Raw(m);
						MB_Utility.hasOutOfBoundsUVs(uv0Raw, m, ref value[j], j);
						Rect uvRect = value[j].uvRect;
						if (j < num)
						{
							dgo.obUVRects[j] = uvRect;
						}
					}
				}
				meshAnalysisResults.Add(m.GetInstanceID(), value);
			}
			return true;
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length <= 0 || _textureBakeResults.doMultiMaterial || !(_textureBakeResults.resultMaterial != null))
				{
					UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
					return false;
				}
				MB_MultiMaterial[] array = (_textureBakeResults.resultMaterials = new MB_MultiMaterial[1]);
				array[0] = new MB_MultiMaterial();
				array[0].combinedMaterial = _textureBakeResults.resultMaterial;
				array[0].considerMeshUVs = _textureBakeResults.fixOutOfBoundsUVs;
				List<Material> list = (array[0].sourceMaterials = new List<Material>());
				for (int i = 0; i < _textureBakeResults.materialsAndUVRects.Length; i++)
				{
					if (!list.Contains(_textureBakeResults.materialsAndUVRects[i].material))
					{
						list.Add(_textureBakeResults.materialsAndUVRects[i].material);
					}
				}
			}
			return true;
		}

		private bool _validateMeshFlags()
		{
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && ((!_doNorm && doNorm) || (!_doTan && doTan) || (!_doCol && doCol) || (!_doUV && doUV) || (!_doUV3 && doUV3) || (!_doUV4 && doUV4)))
			{
				UnityEngine.Debug.LogError("The channels have changed. There are already objects in the combined mesh that were added with a different set of channels.");
				return false;
			}
			_doNorm = doNorm;
			_doTan = doTan;
			_doCol = doCol;
			_doUV = doUV;
			_doUV3 = doUV3;
			_doUV4 = doUV4;
			return true;
		}

		private bool _showHide(GameObject[] goToShow, GameObject[] goToHide)
		{
			if (goToShow == null)
			{
				goToShow = empty;
			}
			if (goToHide == null)
			{
				goToHide = empty;
			}
			int numResultMats = _textureBakeResults.resultMaterials.Length;
			_initialize(numResultMats);
			for (int i = 0; i < goToHide.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(goToHide[i].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to hide an object ", goToHide[i], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int j = 0; j < goToShow.Length; j++)
			{
				if (!instance2Combined_MapContainsKey(goToShow[j].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to show an object ", goToShow[j], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int k = 0; k < goToHide.Length; k++)
			{
				_instance2combined_map[goToHide[k].GetInstanceID()].show = false;
			}
			for (int l = 0; l < goToShow.Length; l++)
			{
				_instance2combined_map[goToShow[l].GetInstanceID()].show = true;
			}
			return true;
		}

		private bool _addToCombined(GameObject[] goToAdd, int[] goToDelete, bool disableRendererInSource)
		{
			if (!_validateTextureBakeResults())
			{
				return false;
			}
			if (!_validateMeshFlags())
			{
				return false;
			}
			if (!ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return false;
			}
			if (outputOption != MB2_OutputOptions.bakeMeshAssetsInPlace && renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (_targetRenderer == null || !(_targetRenderer is SkinnedMeshRenderer))
				{
					UnityEngine.Debug.LogError("Target renderer must be set and must be a SkinnedMeshRenderer");
					return false;
				}
				SkinnedMeshRenderer skinnedMeshRenderer = (SkinnedMeshRenderer)targetRenderer;
				if (skinnedMeshRenderer.sharedMesh != _mesh)
				{
					UnityEngine.Debug.LogError("The combined mesh was not assigned to the targetRenderer. Try using buildSceneMeshObject to set up the combined mesh correctly");
				}
			}
			if (_doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("If doBlendShapes is set then RenderType must be skinnedMeshRenderer.");
				return false;
			}
			GameObject[] _goToAdd;
			if (goToAdd == null)
			{
				_goToAdd = empty;
			}
			else
			{
				_goToAdd = (GameObject[])goToAdd.Clone();
			}
			int[] array = ((goToDelete != null) ? ((int[])goToDelete.Clone()) : emptyIDs);
			if (_mesh == null)
			{
				DestroyMesh();
			}
			MB2_TextureBakeResults.Material2AtlasRectangleMapper material2AtlasRectangleMapper = new MB2_TextureBakeResults.Material2AtlasRectangleMapper(textureBakeResults);
			int num = _textureBakeResults.resultMaterials.Length;
			_initialize(num);
			if (submeshTris.Length != num)
			{
				UnityEngine.Debug.LogError("The number of submeshes " + submeshTris.Length + " in the combined mesh was not equal to the number of result materials " + num + " in the Texture Bake Result");
				return false;
			}
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("==== Calling _addToCombined objs adding:" + _goToAdd.Length + " objs deleting:" + array.Length + " fixOutOfBounds:" + textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs() + " doMultiMaterial:" + textureBakeResults.doMultiMaterial + " disableRenderersInSource:" + disableRendererInSource, LOG_LEVEL);
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				_textureBakeResults.resultMaterials = new MB_MultiMaterial[1];
				_textureBakeResults.resultMaterials[0] = new MB_MultiMaterial();
				_textureBakeResults.resultMaterials[0].combinedMaterial = _textureBakeResults.resultMaterial;
				_textureBakeResults.resultMaterials[0].considerMeshUVs = false;
				List<Material> list = (_textureBakeResults.resultMaterials[0].sourceMaterials = new List<Material>());
				for (int j = 0; j < _textureBakeResults.materialsAndUVRects.Length; j++)
				{
					list.Add(_textureBakeResults.materialsAndUVRects[j].material);
				}
			}
			OrderedDictionary orderedDictionary = new OrderedDictionary();
			for (int k = 0; k < num; k++)
			{
				MB_MultiMaterial mB_MultiMaterial = _textureBakeResults.resultMaterials[k];
				for (int l = 0; l < mB_MultiMaterial.sourceMaterials.Count; l++)
				{
					if (mB_MultiMaterial.sourceMaterials[l] == null)
					{
						UnityEngine.Debug.LogError("Found null material in source materials for combined mesh materials " + k);
						return false;
					}
					if (!orderedDictionary.Contains(mB_MultiMaterial.sourceMaterials[l]))
					{
						orderedDictionary.Add(mB_MultiMaterial.sourceMaterials[l], k);
					}
				}
			}
			int num2 = 0;
			int[] array2 = new int[num];
			int num3 = 0;
			List<MB_DynamicGameObject>[] array3 = null;
			HashSet<int> hashSet = new HashSet<int>();
			HashSet<BoneAndBindpose> hashSet2 = new HashSet<BoneAndBindpose>();
			if (renderType == MB_RenderType.skinnedMeshRenderer && array.Length > 0)
			{
				array3 = _buildBoneIdx2dgoMap();
			}
			for (int m = 0; m < array.Length; m++)
			{
				if (instance2Combined_MapTryGetValue(array[m], out var dgo))
				{
					num2 += dgo.numVerts;
					num3 += dgo.numBlendShapes;
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						for (int n = 0; n < dgo.indexesOfBonesUsed.Length; n++)
						{
							if (array3[dgo.indexesOfBonesUsed[n]].Contains(dgo))
							{
								array3[dgo.indexesOfBonesUsed[n]].Remove(dgo);
								if (array3[dgo.indexesOfBonesUsed[n]].Count == 0)
								{
									hashSet.Add(dgo.indexesOfBonesUsed[n]);
								}
							}
						}
					}
					for (int num4 = 0; num4 < dgo.submeshNumTris.Length; num4++)
					{
						array2[num4] += dgo.submeshNumTris[num4];
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Trying to delete an object that is not in combined mesh");
				}
			}
			List<MB_DynamicGameObject> list2 = new List<MB_DynamicGameObject>();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			MeshChannelsCache meshChannelsCache = new MeshChannelsCache(this);
			int num5 = 0;
			int[] array4 = new int[num];
			int num6 = 0;
			Dictionary<Transform, int> dictionary2 = new Dictionary<Transform, int>();
			for (int num7 = 0; num7 < bones.Length; num7++)
			{
				dictionary2.Add(bones[num7], num7);
			}
			for (int i = 0; i < _goToAdd.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(_goToAdd[i].GetInstanceID()) || Array.FindIndex(array, (int o) => o == _goToAdd[i].GetInstanceID()) != -1)
				{
					MB_DynamicGameObject mB_DynamicGameObject = new MB_DynamicGameObject();
					GameObject gameObject = _goToAdd[i];
					Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log($"Getting {gOMaterials.Length} shared materials for {gameObject}");
					}
					if (gOMaterials == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " does not have a Renderer");
						_goToAdd[i] = null;
						return false;
					}
					Mesh mesh = MB_Utility.GetMesh(gameObject);
					if (mesh == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " MeshFilter or SkinedMeshRenderer had no mesh");
						_goToAdd[i] = null;
						return false;
					}
					if (MBVersion.IsRunningAndMeshNotReadWriteable(mesh))
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " Mesh Importer has read/write flag set to 'false'. This needs to be set to 'true' in order to read data from this mesh.");
						_goToAdd[i] = null;
						return false;
					}
					Rect[] array5 = new Rect[gOMaterials.Length];
					Rect[] array6 = new Rect[gOMaterials.Length];
					Rect[] array7 = new Rect[gOMaterials.Length];
					string errorMsg = string.Empty;
					for (int num8 = 0; num8 < gOMaterials.Length; num8++)
					{
						object obj = orderedDictionary[gOMaterials[num8]];
						if (obj == null)
						{
							UnityEngine.Debug.LogError(string.Concat("Source object ", gameObject.name, " used a material ", gOMaterials[num8], " that was not in the baked materials."));
							return false;
						}
						int idxInResultMats = (int)obj;
						if (!material2AtlasRectangleMapper.TryMapMaterialToUVRect(gOMaterials[num8], mesh, num8, idxInResultMats, meshChannelsCache, dictionary, out array5[num8], out array6[num8], out array7[num8], ref errorMsg, LOG_LEVEL))
						{
							UnityEngine.Debug.LogError(errorMsg);
							_goToAdd[i] = null;
							return false;
						}
					}
					if (!(_goToAdd[i] != null))
					{
						continue;
					}
					list2.Add(mB_DynamicGameObject);
					mB_DynamicGameObject.name = $"{_goToAdd[i].ToString()} {_goToAdd[i].GetInstanceID()}";
					mB_DynamicGameObject.instanceID = _goToAdd[i].GetInstanceID();
					mB_DynamicGameObject.uvRects = array5;
					mB_DynamicGameObject.encapsulatingRect = array6;
					mB_DynamicGameObject.sourceMaterialTiling = array7;
					mB_DynamicGameObject.numVerts = mesh.vertexCount;
					if (_doBlendShapes)
					{
						mB_DynamicGameObject.numBlendShapes = mesh.blendShapeCount;
					}
					Renderer renderer = MB_Utility.GetRenderer(gameObject);
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						_CollectBonesToAddForDGO(mB_DynamicGameObject, dictionary2, hashSet, hashSet2, renderer, meshChannelsCache);
					}
					if (lightmapIndex == -1)
					{
						lightmapIndex = renderer.lightmapIndex;
					}
					if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
					{
						if (lightmapIndex != renderer.lightmapIndex && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " has a different lightmap index. Lightmapping will not work.");
						}
						if (!MBVersion.GetActive(gameObject) && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " is inactive. Can only get lightmap index of active objects.");
						}
						if (renderer.lightmapIndex == -1 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " does not have an index to a lightmap.");
						}
					}
					mB_DynamicGameObject.lightmapIndex = renderer.lightmapIndex;
					mB_DynamicGameObject.lightmapTilingOffset = MBVersion.GetLightmapTilingOffset(renderer);
					if (!_collectMaterialTriangles(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary))
					{
						return false;
					}
					mB_DynamicGameObject.meshSize = renderer.bounds.size;
					mB_DynamicGameObject.submeshNumTris = new int[num];
					mB_DynamicGameObject.submeshTriIdxs = new int[num];
					if (textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs() && !_collectOutOfBoundsUVRects2(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary, dictionary, meshChannelsCache))
					{
						return false;
					}
					num5 += mB_DynamicGameObject.numVerts;
					num6 += mB_DynamicGameObject.numBlendShapes;
					for (int num9 = 0; num9 < mB_DynamicGameObject._tmpSubmeshTris.Length; num9++)
					{
						array4[mB_DynamicGameObject.targetSubmeshIdxs[num9]] += mB_DynamicGameObject._tmpSubmeshTris[num9].data.Length;
					}
					mB_DynamicGameObject.invertTriangles = IsMirrored(gameObject.transform.localToWorldMatrix);
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + _goToAdd[i].name + " has already been added");
					}
					_goToAdd[i] = null;
				}
			}
			for (int num10 = 0; num10 < _goToAdd.Length; num10++)
			{
				if (_goToAdd[num10] != null && disableRendererInSource)
				{
					MB_Utility.DisableRendererInSource(_goToAdd[num10]);
					if (LOG_LEVEL == MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Disabling renderer on " + _goToAdd[num10].name + " id=" + _goToAdd[num10].GetInstanceID());
					}
				}
			}
			int num11 = verts.Length + num5 - num2;
			int num12 = bindPoses.Length + hashSet2.Count - hashSet.Count;
			int[] array8 = new int[num];
			int num13 = blendShapes.Length + num6 - num3;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Verts adding:" + num5 + " deleting:" + num2 + " submeshes:" + array8.Length + " bones:" + num12 + " blendShapes:" + num13);
			}
			for (int num14 = 0; num14 < array8.Length; num14++)
			{
				array8[num14] = submeshTris[num14].data.Length + array4[num14] - array2[num14];
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("    submesh :" + num14 + " already contains:" + submeshTris[num14].data.Length + " tris to be Added:" + array4[num14] + " tris to be Deleted:" + array2[num14]);
				}
			}
			if (num11 > 65534)
			{
				UnityEngine.Debug.LogError("Cannot add objects. Resulting mesh will have more than 64k vertices. Try using a Multi-MeshBaker component. This will split the combined mesh into several meshes. You don't have to re-configure the MB2_TextureBaker. Just remove the MB2_MeshBaker component and add a MB2_MultiMeshBaker component.");
				return false;
			}
			Vector3[] destinationArray = null;
			Vector4[] destinationArray2 = null;
			Vector2[] destinationArray3 = null;
			Vector2[] destinationArray4 = null;
			Vector2[] destinationArray5 = null;
			Vector2[] destinationArray6 = null;
			UnityEngine.Color[] destinationArray7 = null;
			MBBlendShape[] array9 = null;
			Vector3[] destinationArray8 = new Vector3[num11];
			if (_doNorm)
			{
				destinationArray = new Vector3[num11];
			}
			if (_doTan)
			{
				destinationArray2 = new Vector4[num11];
			}
			if (_doUV)
			{
				destinationArray3 = new Vector2[num11];
			}
			if (_doUV3)
			{
				destinationArray5 = new Vector2[num11];
			}
			if (_doUV4)
			{
				destinationArray6 = new Vector2[num11];
			}
			if (doUV2())
			{
				destinationArray4 = new Vector2[num11];
			}
			if (_doCol)
			{
				destinationArray7 = new UnityEngine.Color[num11];
			}
			if (_doBlendShapes)
			{
				array9 = new MBBlendShape[num13];
			}
			BoneWeight[] array10 = new BoneWeight[num11];
			Matrix4x4[] array11 = new Matrix4x4[num12];
			Transform[] array12 = new Transform[num12];
			SerializableIntArray[] array13 = new SerializableIntArray[num];
			for (int num15 = 0; num15 < array13.Length; num15++)
			{
				array13[num15] = new SerializableIntArray(array8[num15]);
			}
			for (int num16 = 0; num16 < array.Length; num16++)
			{
				MB_DynamicGameObject dgo2 = null;
				if (instance2Combined_MapTryGetValue(array[num16], out dgo2))
				{
					dgo2._beingDeleted = true;
				}
			}
			mbDynamicObjectsInCombinedMesh.Sort();
			int num17 = 0;
			int num18 = 0;
			int[] array14 = new int[num];
			int num19 = 0;
			for (int num20 = 0; num20 < mbDynamicObjectsInCombinedMesh.Count; num20++)
			{
				MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[num20];
				if (!mB_DynamicGameObject2._beingDeleted)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Copying obj in combined arrays idx:" + num20, LOG_LEVEL);
					}
					Array.Copy(verts, mB_DynamicGameObject2.vertIdx, destinationArray8, num17, mB_DynamicGameObject2.numVerts);
					if (_doNorm)
					{
						Array.Copy(normals, mB_DynamicGameObject2.vertIdx, destinationArray, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doTan)
					{
						Array.Copy(tangents, mB_DynamicGameObject2.vertIdx, destinationArray2, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV)
					{
						Array.Copy(uvs, mB_DynamicGameObject2.vertIdx, destinationArray3, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV3)
					{
						Array.Copy(uv3s, mB_DynamicGameObject2.vertIdx, destinationArray5, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV4)
					{
						Array.Copy(uv4s, mB_DynamicGameObject2.vertIdx, destinationArray6, num17, mB_DynamicGameObject2.numVerts);
					}
					if (doUV2())
					{
						Array.Copy(uv2s, mB_DynamicGameObject2.vertIdx, destinationArray4, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doCol)
					{
						Array.Copy(colors, mB_DynamicGameObject2.vertIdx, destinationArray7, num17, mB_DynamicGameObject2.numVerts);
					}
					if (_doBlendShapes)
					{
						Array.Copy(blendShapes, mB_DynamicGameObject2.blendShapeIdx, array9, num18, mB_DynamicGameObject2.numBlendShapes);
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						Array.Copy(boneWeights, mB_DynamicGameObject2.vertIdx, array10, num17, mB_DynamicGameObject2.numVerts);
					}
					for (int num21 = 0; num21 < num; num21++)
					{
						int[] data = submeshTris[num21].data;
						int num22 = mB_DynamicGameObject2.submeshTriIdxs[num21];
						int num23 = mB_DynamicGameObject2.submeshNumTris[num21];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug("    Adjusting submesh triangles submesh:" + num21 + " startIdx:" + num22 + " num:" + num23 + " nsubmeshTris:" + array13.Length + " targSubmeshTidx:" + array14.Length, LOG_LEVEL);
						}
						for (int num24 = num22; num24 < num22 + num23; num24++)
						{
							data[num24] -= num19;
						}
						Array.Copy(data, num22, array13[num21].data, array14[num21], num23);
					}
					mB_DynamicGameObject2.vertIdx = num17;
					mB_DynamicGameObject2.blendShapeIdx = num18;
					for (int num25 = 0; num25 < array14.Length; num25++)
					{
						mB_DynamicGameObject2.submeshTriIdxs[num25] = array14[num25];
						array14[num25] += mB_DynamicGameObject2.submeshNumTris[num25];
					}
					num18 += mB_DynamicGameObject2.numBlendShapes;
					num17 += mB_DynamicGameObject2.numVerts;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Not copying obj: " + num20, LOG_LEVEL);
					}
					num19 += mB_DynamicGameObject2.numVerts;
				}
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				_CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(hashSet, hashSet2, array12, array11, array10, num2);
			}
			for (int num26 = mbDynamicObjectsInCombinedMesh.Count - 1; num26 >= 0; num26--)
			{
				if (mbDynamicObjectsInCombinedMesh[num26]._beingDeleted)
				{
					instance2Combined_MapRemove(mbDynamicObjectsInCombinedMesh[num26].instanceID);
					objectsInCombinedMesh.RemoveAt(num26);
					mbDynamicObjectsInCombinedMesh.RemoveAt(num26);
				}
			}
			verts = destinationArray8;
			if (_doNorm)
			{
				normals = destinationArray;
			}
			if (_doTan)
			{
				tangents = destinationArray2;
			}
			if (_doUV)
			{
				uvs = destinationArray3;
			}
			if (_doUV3)
			{
				uv3s = destinationArray5;
			}
			if (_doUV4)
			{
				uv4s = destinationArray6;
			}
			if (doUV2())
			{
				uv2s = destinationArray4;
			}
			if (_doCol)
			{
				colors = destinationArray7;
			}
			if (_doBlendShapes)
			{
				blendShapes = array9;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				boneWeights = array10;
			}
			int num27 = bones.Length - hashSet.Count;
			bindPoses = array11;
			bones = array12;
			submeshTris = array13;
			int num28 = 0;
			foreach (BoneAndBindpose item in hashSet2)
			{
				array12[num27 + num28] = item.bone;
				ref Matrix4x4 reference = ref array11[num27 + num28];
				reference = item.bindPose;
				num28++;
			}
			for (int num29 = 0; num29 < list2.Count; num29++)
			{
				MB_DynamicGameObject mB_DynamicGameObject3 = list2[num29];
				GameObject gameObject2 = _goToAdd[num29];
				int num30 = num17;
				int index = num18;
				Mesh mesh2 = MB_Utility.GetMesh(gameObject2);
				Matrix4x4 localToWorldMatrix = gameObject2.transform.localToWorldMatrix;
				Matrix4x4 matrix4x = localToWorldMatrix;
				float num32 = (matrix4x[2, 3] = 0f);
				num32 = (matrix4x[1, 3] = num32);
				matrix4x[0, 3] = num32;
				destinationArray8 = meshChannelsCache.GetVertices(mesh2);
				Vector3[] array15 = null;
				Vector4[] array16 = null;
				if (_doNorm)
				{
					array15 = meshChannelsCache.GetNormals(mesh2);
				}
				if (_doTan)
				{
					array16 = meshChannelsCache.GetTangents(mesh2);
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer)
				{
					for (int num34 = 0; num34 < destinationArray8.Length; num34++)
					{
						int num35 = num30 + num34;
						ref Vector3 reference2 = ref verts[num30 + num34];
						reference2 = localToWorldMatrix.MultiplyPoint3x4(destinationArray8[num34]);
						if (_doNorm)
						{
							ref Vector3 reference3 = ref normals[num35];
							reference3 = matrix4x.MultiplyPoint3x4(array15[num34]);
							ref Vector3 reference4 = ref normals[num35];
							reference4 = normals[num35].normalized;
						}
						if (_doTan)
						{
							float w = array16[num34].w;
							Vector3 vector = matrix4x.MultiplyPoint3x4(array16[num34]);
							vector.Normalize();
							ref Vector4 reference5 = ref tangents[num35];
							reference5 = vector;
							tangents[num35].w = w;
						}
					}
				}
				else
				{
					if (_doNorm)
					{
						array15.CopyTo(normals, num30);
					}
					if (_doTan)
					{
						array16.CopyTo(tangents, num30);
					}
					destinationArray8.CopyTo(verts, num30);
				}
				int subMeshCount = mesh2.subMeshCount;
				if (mB_DynamicGameObject3.uvRects.Length < subMeshCount)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + mB_DynamicGameObject3.name + " has more submeshes than materials");
					}
					subMeshCount = mB_DynamicGameObject3.uvRects.Length;
				}
				else if (mB_DynamicGameObject3.uvRects.Length > subMeshCount && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Mesh " + mB_DynamicGameObject3.name + " has fewer submeshes than materials");
				}
				if (_doUV)
				{
					_copyAndAdjustUVsFromMesh(mB_DynamicGameObject3, mesh2, num30, meshChannelsCache);
				}
				if (doUV2())
				{
					_copyAndAdjustUV2FromMesh(mB_DynamicGameObject3, mesh2, num30, meshChannelsCache);
				}
				if (_doUV3)
				{
					destinationArray5 = meshChannelsCache.GetUv3(mesh2);
					destinationArray5.CopyTo(uv3s, num30);
				}
				if (_doUV4)
				{
					destinationArray6 = meshChannelsCache.GetUv4(mesh2);
					destinationArray6.CopyTo(uv4s, num30);
				}
				if (_doCol)
				{
					destinationArray7 = meshChannelsCache.GetColors(mesh2);
					destinationArray7.CopyTo(colors, num30);
				}
				if (_doBlendShapes)
				{
					array9 = meshChannelsCache.GetBlendShapes(mesh2, mB_DynamicGameObject3.instanceID);
					array9.CopyTo(blendShapes, index);
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					Renderer renderer2 = MB_Utility.GetRenderer(gameObject2);
					_AddBonesToNewBonesArrayAndAdjustBWIndexes(mB_DynamicGameObject3, renderer2, num30, array12, array10, meshChannelsCache);
				}
				for (int num36 = 0; num36 < array14.Length; num36++)
				{
					mB_DynamicGameObject3.submeshTriIdxs[num36] = array14[num36];
				}
				for (int num37 = 0; num37 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num37++)
				{
					int[] data2 = mB_DynamicGameObject3._tmpSubmeshTris[num37].data;
					for (int num38 = 0; num38 < data2.Length; num38++)
					{
						data2[num38] += num30;
					}
					if (mB_DynamicGameObject3.invertTriangles)
					{
						for (int num39 = 0; num39 < data2.Length; num39 += 3)
						{
							int num40 = data2[num39];
							data2[num39] = data2[num39 + 1];
							data2[num39 + 1] = num40;
						}
					}
					int num41 = mB_DynamicGameObject3.targetSubmeshIdxs[num37];
					data2.CopyTo(submeshTris[num41].data, array14[num41]);
					mB_DynamicGameObject3.submeshNumTris[num41] += data2.Length;
					array14[num41] += data2.Length;
				}
				mB_DynamicGameObject3.vertIdx = num17;
				mB_DynamicGameObject3.blendShapeIdx = num18;
				instance2Combined_MapAdd(gameObject2.GetInstanceID(), mB_DynamicGameObject3);
				objectsInCombinedMesh.Add(gameObject2);
				mbDynamicObjectsInCombinedMesh.Add(mB_DynamicGameObject3);
				num17 += destinationArray8.Length;
				if (_doBlendShapes)
				{
					num18 += array9.Length;
				}
				for (int num42 = 0; num42 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num42++)
				{
					mB_DynamicGameObject3._tmpSubmeshTris[num42] = null;
				}
				mB_DynamicGameObject3._tmpSubmeshTris = null;
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Added to combined:" + mB_DynamicGameObject3.name + " verts:" + destinationArray8.Length + " bindPoses:" + array11.Length, LOG_LEVEL);
				}
			}
			if (lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
			{
				_copyUV2unchangedToSeparateRects();
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("===== _addToCombined completed. Verts in buffer: " + verts.Length, LOG_LEVEL);
			}
			return true;
		}

		private void _copyAndAdjustUVsFromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv0Raw = meshChannelsCache.GetUv0Raw(mesh);
			bool flag = true;
			if (!_textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs())
			{
				Rect rect = new Rect(0f, 0f, 1f, 1f);
				bool flag2 = true;
				for (int i = 0; i < _textureBakeResults.materialsAndUVRects.Length; i++)
				{
					if (_textureBakeResults.materialsAndUVRects[i].atlasRect != rect)
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = false;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("All atlases have only one texture in atlas UVs will be copied without adjusting");
					}
				}
			}
			if (flag)
			{
				int[] array = new int[uv0Raw.Length];
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = -1;
				}
				bool flag3 = false;
				for (int k = 0; k < dgo.targetSubmeshIdxs.Length; k++)
				{
					int[] array2 = ((dgo._tmpSubmeshTris == null) ? mesh.GetTriangles(k) : dgo._tmpSubmeshTris[k].data);
					DRect r = new DRect(dgo.uvRects[k]);
					DRect t = ((!textureBakeResults.resultMaterials[dgo.targetSubmeshIdxs[k]].considerMeshUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : new DRect(dgo.obUVRects[k]));
					DRect r2 = new DRect(dgo.sourceMaterialTiling[k]);
					DRect t2 = new DRect(dgo.encapsulatingRect[k]);
					DRect r3 = MB3_UVTransformUtility.InverseTransform(ref t2);
					DRect r4 = MB3_UVTransformUtility.InverseTransform(ref t);
					DRect r5 = MB3_UVTransformUtility.CombineTransforms(ref t, ref r2);
					DRect r6 = MB3_UVTransformUtility.CombineTransforms(ref r5, ref r3);
					DRect r7 = MB3_UVTransformUtility.CombineTransforms(ref r4, ref r6);
					Rect rect2 = MB3_UVTransformUtility.CombineTransforms(ref r7, ref r).GetRect();
					foreach (int num in array2)
					{
						if (array[num] == -1)
						{
							array[num] = k;
							Vector2 vector = uv0Raw[num];
							vector.x = rect2.x + vector.x * rect2.width;
							vector.y = rect2.y + vector.y * rect2.height;
							uvs[vertsIdx + num] = vector;
						}
						if (array[num] != k)
						{
							flag3 = true;
						}
					}
				}
				if (flag3 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning(dgo.name + "has submeshes which share verticies. Adjusted uvs may not map correctly in combined atlas.");
				}
			}
			else
			{
				uv0Raw.CopyTo(uvs, vertsIdx);
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_copyAndAdjustUVsFromMesh copied {uv0Raw.Length} verts");
			}
		}

		private void _copyAndAdjustUV2FromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv = meshChannelsCache.GetUv2(mesh);
			if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				Vector4 lightmapTilingOffset = dgo.lightmapTilingOffset;
				Vector2 vector = new Vector2(lightmapTilingOffset.x, lightmapTilingOffset.y);
				Vector2 vector2 = new Vector2(lightmapTilingOffset.z, lightmapTilingOffset.w);
				Vector2 vector3 = default(Vector2);
				for (int i = 0; i < uv.Length; i++)
				{
					vector3.x = vector.x * uv[i].x;
					vector3.y = vector.y * uv[i].y;
					ref Vector2 reference = ref uv2s[vertsIdx + i];
					reference = vector2 + vector3;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied and modify for preserve current lightmapping " + uv.Length);
				}
			}
			else
			{
				uv.CopyTo(uv2s, vertsIdx);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied without modifying " + uv.Length);
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			UpdateSkinnedMeshApproximateBoundsFromBounds();
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (bones.Length == 0)
			{
				if (verts.Length > 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("No bones in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBoundsFromBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (verts.Length == 0 || mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				if (verts.Length > 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Nothing in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objectsInCombinedMesh, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		private int _getNumBones(Renderer r)
		{
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).bones.Length;
				}
				if (r is MeshRenderer)
				{
					return 1;
				}
				UnityEngine.Debug.LogError("Could not _getNumBones. Object does not have a renderer");
				return 0;
			}
			return 0;
		}

		private Transform[] _getBones(Renderer r)
		{
			return MBVersion.GetBones(r);
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			bool flag = false;
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				flag = true;
			}
			Apply(triangles: true, vertices: true, _doNorm, _doTan, _doUV, doUV2(), _doUV3, _doUV4, doCol, flag, doBlendShapes, uv2GenerationMethod);
		}

		public virtual void ApplyShowHide()
		{
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (renderType == MB_RenderType.meshRenderer)
				{
					MBVersion.MeshClear(_mesh, t: true);
					_mesh.vertices = verts;
				}
				SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
				if (textureBakeResults.doMultiMaterial)
				{
					int num = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied);
					_mesh.subMeshCount = num;
					int numNonZeroLengthSubmeshTris = num;
					int num2 = 0;
					for (int i = 0; i < submeshTrisWithShowHideApplied.Length; i++)
					{
						if (submeshTrisWithShowHideApplied[i].data.Length != 0)
						{
							_mesh.SetTriangles(submeshTrisWithShowHideApplied[i].data, num2);
							num2++;
						}
					}
					_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
				}
				else
				{
					_mesh.triangles = submeshTrisWithShowHideApplied[0].data;
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("ApplyShowHide");
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling ApplyShowHide");
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Apply called tri={triangles} vert={vertices} norm={normals} tan={tangents} uv={uvs} col={colors} uv3={uv3} uv4={uv4} uv2={uv2} bone={bones} blendShape{blendShapes} meshID={_mesh.GetInstanceID()}");
				}
				if (triangles || _mesh.vertexCount != verts.Length)
				{
					if (triangles && !vertices && !normals && !tangents && !uvs && !colors && !uv3 && !uv4 && !uv2 && !bones)
					{
						MBVersion.MeshClear(_mesh, t: true);
					}
					else
					{
						MBVersion.MeshClear(_mesh, t: false);
					}
				}
				if (vertices)
				{
					Vector3[] array = verts;
					if (verts.Length > 0)
					{
						if (_recenterVertsToBoundsCenter && _renderType == MB_RenderType.meshRenderer)
						{
							array = new Vector3[verts.Length];
							Vector3 vector = verts[0];
							Vector3 vector2 = verts[0];
							for (int i = 1; i < verts.Length; i++)
							{
								Vector3 vector3 = verts[i];
								if (vector.x < vector3.x)
								{
									vector.x = vector3.x;
								}
								if (vector.y < vector3.y)
								{
									vector.y = vector3.y;
								}
								if (vector.z < vector3.z)
								{
									vector.z = vector3.z;
								}
								if (vector2.x > vector3.x)
								{
									vector2.x = vector3.x;
								}
								if (vector2.y > vector3.y)
								{
									vector2.y = vector3.y;
								}
								if (vector2.z > vector3.z)
								{
									vector2.z = vector3.z;
								}
							}
							Vector3 vector4 = (vector + vector2) / 2f;
							for (int j = 0; j < verts.Length; j++)
							{
								ref Vector3 reference = ref array[j];
								reference = verts[j] - vector4;
							}
							targetRenderer.transform.position = vector4;
						}
						else
						{
							targetRenderer.transform.position = Vector3.zero;
						}
					}
					_mesh.vertices = array;
				}
				if (triangles && (bool)_textureBakeResults)
				{
					if (_textureBakeResults == null)
					{
						UnityEngine.Debug.LogError("Texture Bake Result was not set.");
					}
					else
					{
						SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
						int num = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied);
						_mesh.subMeshCount = num;
						int numNonZeroLengthSubmeshTris = num;
						int num2 = 0;
						for (int k = 0; k < submeshTrisWithShowHideApplied.Length; k++)
						{
							if (submeshTrisWithShowHideApplied[k].data.Length != 0)
							{
								_mesh.SetTriangles(submeshTrisWithShowHideApplied[k].data, num2);
								num2++;
							}
						}
						_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
					}
				}
				if (normals)
				{
					if (_doNorm)
					{
						_mesh.normals = this.normals;
					}
					else
					{
						UnityEngine.Debug.LogError("normal flag was set in Apply but MeshBaker didn't generate normals");
					}
				}
				if (tangents)
				{
					if (_doTan)
					{
						_mesh.tangents = this.tangents;
					}
					else
					{
						UnityEngine.Debug.LogError("tangent flag was set in Apply but MeshBaker didn't generate tangents");
					}
				}
				if (uvs)
				{
					if (_doUV)
					{
						_mesh.uv = this.uvs;
					}
					else
					{
						UnityEngine.Debug.LogError("uv flag was set in Apply but MeshBaker didn't generate uvs");
					}
				}
				if (colors)
				{
					if (_doCol)
					{
						_mesh.colors = this.colors;
					}
					else
					{
						UnityEngine.Debug.LogError("color flag was set in Apply but MeshBaker didn't generate colors");
					}
				}
				if (uv3)
				{
					if (_doUV3)
					{
						MBVersion.MeshAssignUV3(_mesh, uv3s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv3 flag was set in Apply but MeshBaker didn't generate uv3s");
					}
				}
				if (uv4)
				{
					if (_doUV4)
					{
						MBVersion.MeshAssignUV4(_mesh, uv4s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv4 flag was set in Apply but MeshBaker didn't generate uv4s");
					}
				}
				if (uv2)
				{
					if (doUV2())
					{
						_mesh.uv2 = uv2s;
					}
					else
					{
						UnityEngine.Debug.LogError("uv2 flag was set in Apply but lightmapping option was set to " + lightmapOption);
					}
				}
				bool flag = false;
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
				{
					if (uv2GenerationMethod != null)
					{
						uv2GenerationMethod(_mesh, uv2UnwrappingParamsHardAngle, uv2UnwrappingParamsPackMargin);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log("generating new UV2 layout for the combined mesh ");
						}
					}
					else
					{
						UnityEngine.Debug.LogError("No GenerateUV2Delegate method was supplied. UV2 cannot be generated.");
					}
					flag = true;
				}
				else if (renderType == MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("UV2 cannot be generated for SkinnedMeshRenderer objects.");
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && !flag)
				{
					UnityEngine.Debug.LogError("Failed to generate new UV2 layout. Only works in editor.");
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (bones)
				{
					_mesh.bindposes = bindPoses;
					_mesh.boneWeights = boneWeights;
				}
				if (blendShapesFlag && (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3)))
				{
					if (blendShapesInCombined.Length != blendShapes.Length)
					{
						blendShapesInCombined = new MBBlendShape[blendShapes.Length];
					}
					Vector3[] array2 = new Vector3[verts.Length];
					Vector3[] array3 = new Vector3[verts.Length];
					Vector3[] array4 = new Vector3[verts.Length];
					MBVersion.ClearBlendShapes(_mesh);
					for (int l = 0; l < blendShapes.Length; l++)
					{
						MB_DynamicGameObject mB_DynamicGameObject = instance2Combined_MapGet(blendShapes[l].gameObjectID);
						if (mB_DynamicGameObject != null)
						{
							for (int m = 0; m < blendShapes[l].frames.Length; m++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = blendShapes[l].frames[m];
								int vertIdx = mB_DynamicGameObject.vertIdx;
								Array.Copy(mBBlendShapeFrame.vertices, 0, array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								Array.Copy(mBBlendShapeFrame.normals, 0, array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								Array.Copy(mBBlendShapeFrame.tangents, 0, array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
								MBVersion.AddBlendShapeFrame(_mesh, blendShapes[l].name + blendShapes[l].gameObjectID, mBBlendShapeFrame.frameWeight, array2, array3, array4);
								_ZeroArray(array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								_ZeroArray(array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								_ZeroArray(array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
							}
						}
						else
						{
							UnityEngine.Debug.LogError("InstanceID in blend shape that was not in instance2combinedMap");
						}
						blendShapesInCombined[l] = blendShapes[l];
					}
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = null;
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = _mesh;
				}
				if (triangles || vertices)
				{
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("recalculating bounds on mesh.");
					}
					_mesh.RecalculateBounds();
				}
				if (_optimizeAfterBake && !UnityEngine.Application.isPlaying)
				{
					MBVersion.OptimizeMesh(_mesh);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling Apply or ApplyAll");
			}
		}

		private int _numNonZeroLengthSubmeshTris(SerializableIntArray[] subTris)
		{
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length > 0)
				{
					num++;
				}
			}
			return num;
		}

		private void _updateMaterialsOnTargetRenderer(SerializableIntArray[] subTris, int numNonZeroLengthSubmeshTris)
		{
			if (subTris.Length != textureBakeResults.resultMaterials.Length)
			{
				UnityEngine.Debug.LogError("Mismatch between number of submeshes and number of result materials");
			}
			Material[] array = new Material[numNonZeroLengthSubmeshTris];
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length > 0)
				{
					array[num] = _textureBakeResults.resultMaterials[i].combinedMaterial;
					num++;
				}
			}
			targetRenderer.materials = array;
		}

		public SerializableIntArray[] GetSubmeshTrisWithShowHideApplied()
		{
			bool flag = false;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				if (!mbDynamicObjectsInCombinedMesh[i].show)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				int[] array = new int[submeshTris.Length];
				SerializableIntArray[] array2 = new SerializableIntArray[submeshTris.Length];
				for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
					if (mB_DynamicGameObject.show)
					{
						for (int k = 0; k < mB_DynamicGameObject.submeshNumTris.Length; k++)
						{
							array[k] += mB_DynamicGameObject.submeshNumTris[k];
						}
					}
				}
				for (int l = 0; l < array2.Length; l++)
				{
					array2[l] = new SerializableIntArray(array[l]);
				}
				int[] array3 = new int[array2.Length];
				for (int m = 0; m < mbDynamicObjectsInCombinedMesh.Count; m++)
				{
					MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[m];
					if (!mB_DynamicGameObject2.show)
					{
						continue;
					}
					for (int n = 0; n < submeshTris.Length; n++)
					{
						int[] data = submeshTris[n].data;
						int num = mB_DynamicGameObject2.submeshTriIdxs[n];
						int num2 = num + mB_DynamicGameObject2.submeshNumTris[n];
						for (int num3 = num; num3 < num2; num3++)
						{
							array2[n].data[array3[n]] = data[num3];
							array3[n]++;
						}
					}
				}
				return array2;
			}
			return submeshTris;
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			_updateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
		}

		private void _updateGameObjects(GameObject[] gos, bool recalcBounds, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("UpdateGameObjects called on " + gos.Length + " objects.");
			}
			int numResultMats = 1;
			if (textureBakeResults.doMultiMaterial)
			{
				numResultMats = textureBakeResults.resultMaterials.Length;
			}
			_initialize(numResultMats);
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			MeshChannelsCache meshChannelCache = new MeshChannelsCache(this);
			for (int i = 0; i < gos.Length; i++)
			{
				_updateGameObject(gos[i], updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo, meshChannelCache);
			}
			if (recalcBounds)
			{
				_mesh.RecalculateBounds();
			}
		}

		private void _updateGameObject(GameObject go, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo, MeshChannelsCache meshChannelCache)
		{
			MB_DynamicGameObject dgo = null;
			if (!instance2Combined_MapTryGetValue(go.GetInstanceID(), out dgo))
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has not been added");
				return;
			}
			Mesh mesh = MB_Utility.GetMesh(go);
			if (dgo.numVerts != mesh.vertexCount)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " source mesh has been modified since being added. To update it must have the same number of verts");
				return;
			}
			if (_doUV && updateUV)
			{
				_copyAndAdjustUVsFromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (doUV2() && updateUV2)
			{
				_copyAndAdjustUV2FromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer && updateSkinningInfo)
			{
				Renderer renderer = MB_Utility.GetRenderer(go);
				BoneWeight[] array = meshChannelCache.GetBoneWeights(renderer, dgo.numVerts);
				Transform[] array2 = _getBones(renderer);
				int num = dgo.vertIdx;
				bool flag = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (array2[array[i].boneIndex0] != bones[boneWeights[num].boneIndex0])
					{
						flag = true;
						break;
					}
					boneWeights[num].weight0 = array[i].weight0;
					boneWeights[num].weight1 = array[i].weight1;
					boneWeights[num].weight2 = array[i].weight2;
					boneWeights[num].weight3 = array[i].weight3;
					num++;
				}
				if (flag)
				{
					UnityEngine.Debug.LogError("Detected that some of the boneweights reference different bones than when initial added. Boneweights must reference the same bones " + dgo.name);
				}
			}
			Matrix4x4 localToWorldMatrix = go.transform.localToWorldMatrix;
			if (updateVertices)
			{
				Vector3[] vertices = meshChannelCache.GetVertices(mesh);
				for (int j = 0; j < vertices.Length; j++)
				{
					ref Vector3 reference = ref verts[dgo.vertIdx + j];
					reference = localToWorldMatrix.MultiplyPoint3x4(vertices[j]);
				}
			}
			float num3 = (localToWorldMatrix[2, 3] = 0f);
			num3 = (localToWorldMatrix[1, 3] = num3);
			localToWorldMatrix[0, 3] = num3;
			if (_doNorm && updateNormals)
			{
				Vector3[] array3 = meshChannelCache.GetNormals(mesh);
				for (int k = 0; k < array3.Length; k++)
				{
					int num5 = dgo.vertIdx + k;
					ref Vector3 reference2 = ref normals[num5];
					reference2 = localToWorldMatrix.MultiplyPoint3x4(array3[k]);
					ref Vector3 reference3 = ref normals[num5];
					reference3 = normals[num5].normalized;
				}
			}
			if (_doTan && updateTangents)
			{
				Vector4[] array4 = meshChannelCache.GetTangents(mesh);
				for (int l = 0; l < array4.Length; l++)
				{
					int num6 = dgo.vertIdx + l;
					float w = array4[l].w;
					Vector3 vector = localToWorldMatrix.MultiplyPoint3x4(array4[l]);
					vector.Normalize();
					ref Vector4 reference4 = ref tangents[num6];
					reference4 = vector;
					tangents[num6].w = w;
				}
			}
			if (_doCol && updateColors)
			{
				UnityEngine.Color[] array5 = meshChannelCache.GetColors(mesh);
				for (int m = 0; m < array5.Length; m++)
				{
					ref UnityEngine.Color reference5 = ref colors[dgo.vertIdx + m];
					reference5 = array5[m];
				}
			}
			if (_doUV3 && updateUV3)
			{
				Vector2[] uv = meshChannelCache.GetUv3(mesh);
				for (int n = 0; n < uv.Length; n++)
				{
					ref Vector2 reference6 = ref uv3s[dgo.vertIdx + n];
					reference6 = uv[n];
				}
			}
			if (_doUV4 && updateUV4)
			{
				Vector2[] uv2 = meshChannelCache.GetUv4(mesh);
				for (int num7 = 0; num7 < uv2.Length; num7++)
				{
					ref Vector2 reference7 = ref uv4s[dgo.vertIdx + num7];
					reference7 = uv2[num7];
				}
			}
		}

		public bool ShowHideGameObjects(GameObject[] toShow, GameObject[] toHide)
		{
			if (textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("TextureBakeResults must be set.");
				return false;
			}
			return _showHide(toShow, toHide);
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			if (validationLevel > MB2_ValidationLevel.none)
			{
				if (gos != null)
				{
					for (int i = 0; i < gos.Length; i++)
					{
						if (gos[i] == null)
						{
							UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
							return false;
						}
						if (validationLevel < MB2_ValidationLevel.robust)
						{
							continue;
						}
						for (int j = i + 1; j < gos.Length; j++)
						{
							if (gos[i] == gos[j])
							{
								UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " appears twice in list of game objects to add"));
								return false;
							}
						}
					}
				}
				if (deleteGOinstanceIDs != null && validationLevel >= MB2_ValidationLevel.robust)
				{
					for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
					{
						for (int l = k + 1; l < deleteGOinstanceIDs.Length; l++)
						{
							if (deleteGOinstanceIDs[k] == deleteGOinstanceIDs[l])
							{
								UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[k] + "appears twice in list of game objects to delete");
								return false;
							}
						}
					}
				}
			}
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length > 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length > 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			BuildSceneMeshObject(gos);
			if (!_addToCombined(gos, deleteGOinstanceIDs, disableRendererInSource))
			{
				UnityEngine.Debug.LogError("Failed to add/delete objects to combined mesh");
				return false;
			}
			if (targetRenderer != null)
			{
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					SkinnedMeshRenderer skinnedMeshRenderer = (SkinnedMeshRenderer)targetRenderer;
					skinnedMeshRenderer.bones = bones;
					UpdateSkinnedMeshApproximateBoundsFromBounds();
				}
				targetRenderer.lightmapIndex = GetLightmapIndex();
			}
			return true;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return objectsInCombinedMesh.Contains(go);
		}

		public override void ClearBuffers()
		{
			verts = new Vector3[0];
			normals = new Vector3[0];
			tangents = new Vector4[0];
			uvs = new Vector2[0];
			uv2s = new Vector2[0];
			uv3s = new Vector2[0];
			uv4s = new Vector2[0];
			colors = new UnityEngine.Color[0];
			bones = new Transform[0];
			bindPoses = new Matrix4x4[0];
			boneWeights = new BoneWeight[0];
			submeshTris = new SerializableIntArray[0];
			blendShapes = new MBBlendShape[0];
			if (blendShapesInCombined == null)
			{
				blendShapesInCombined = new MBBlendShape[0];
			}
			else
			{
				for (int i = 0; i < blendShapesInCombined.Length; i++)
				{
					blendShapesInCombined[i].frames = new MBBlendShapeFrame[0];
				}
			}
			mbDynamicObjectsInCombinedMesh.Clear();
			objectsInCombinedMesh.Clear();
			instance2Combined_MapClear();
			if (_usingTemporaryTextureBakeResult)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				MB2_Log.LogDebug("ClearBuffers called");
			}
		}

		public override void ClearMesh()
		{
			if (_mesh != null)
			{
				MBVersion.MeshClear(_mesh, t: false);
			}
			else
			{
				_mesh = new Mesh();
			}
			ClearBuffers();
		}

		public override void DestroyMesh()
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				MB_Utility.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				editorMethods.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public bool ValidateTargRendererAndMeshAndResultSceneObj()
		{
			if (_resultSceneObject == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Result Scene Object was not set.");
				}
				return false;
			}
			if (_targetRenderer == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer was not set.");
				}
				return false;
			}
			if (_targetRenderer.transform.parent != _resultSceneObject.transform)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer game object is not a child of Result Scene Object was not set.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (!(_targetRenderer is SkinnedMeshRenderer))
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Render Type is skinned mesh renderer but Target Renderer is not.");
					}
					return false;
				}
				if (((SkinnedMeshRenderer)_targetRenderer).sharedMesh != _mesh)
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Target renderer mesh is not equal to mesh.");
					}
					return false;
				}
			}
			if (_renderType == MB_RenderType.meshRenderer)
			{
				if (!(_targetRenderer is MeshRenderer))
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Render Type is mesh renderer but Target Renderer is not.");
					}
					return false;
				}
				MeshFilter component = _targetRenderer.GetComponent<MeshFilter>();
				if (_mesh != component.sharedMesh)
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Target renderer mesh is not equal to mesh.");
					}
					return false;
				}
			}
			return true;
		}

		internal static Renderer BuildSceneHierarchPreBake(MB3_MeshCombinerSingle mom, GameObject root, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			if (mom._LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Building Scene Hierarchy createNewChild=" + createNewChild);
			}
			MeshFilter meshFilter = null;
			MeshRenderer meshRenderer = null;
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			Transform transform = null;
			if (root == null)
			{
				UnityEngine.Debug.LogError("root was null.");
				return null;
			}
			if (mom.textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("textureBakeResults must be set.");
				return null;
			}
			if (root.GetComponent<Renderer>() != null)
			{
				UnityEngine.Debug.LogError("root game object cannot have a renderer component");
				return null;
			}
			if (!createNewChild)
			{
				if (mom.targetRenderer != null && mom.targetRenderer.transform.parent == root.transform)
				{
					transform = mom.targetRenderer.transform;
				}
				else
				{
					Renderer[] componentsInChildren = root.GetComponentsInChildren<Renderer>();
					if (componentsInChildren.Length == 1)
					{
						if (componentsInChildren[0].transform.parent != root.transform)
						{
							UnityEngine.Debug.LogError("Target Renderer is not an immediate child of Result Scene Object. Try using a game object with no children as the Result Scene Object..");
						}
						transform = componentsInChildren[0].transform;
					}
				}
			}
			if (transform != null && transform.parent != root.transform)
			{
				transform = null;
			}
			GameObject gameObject;
			if (transform == null)
			{
				gameObject = new GameObject(mom.name + "-mesh");
				gameObject.transform.parent = root.transform;
				transform = gameObject.transform;
			}
			transform.parent = root.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
			}
			_ConfigureSceneHierarch(mom, root, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				return skinnedMeshRenderer;
			}
			return meshRenderer;
		}

		public static void BuildPrefabHierarchy(MB3_MeshCombinerSingle mom, GameObject instantiatedPrefabRoot, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			MeshRenderer meshRenderer = null;
			MeshFilter meshFilter = null;
			GameObject gameObject = new GameObject(mom.name + "-mesh");
			gameObject.transform.parent = instantiatedPrefabRoot.transform;
			Transform transform = gameObject.transform;
			transform.parent = instantiatedPrefabRoot.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
			}
			_ConfigureSceneHierarch(mom, instantiatedPrefabRoot, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.targetRenderer != null)
			{
				Material[] array = new Material[mom.targetRenderer.sharedMaterials.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = mom.targetRenderer.sharedMaterials[i];
				}
				if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
				{
					skinnedMeshRenderer.sharedMaterial = null;
					skinnedMeshRenderer.sharedMaterials = array;
				}
				else
				{
					meshRenderer.sharedMaterial = null;
					meshRenderer.sharedMaterials = array;
				}
			}
		}

		private static void _ConfigureSceneHierarch(MB3_MeshCombinerSingle mom, GameObject root, MeshRenderer mr, MeshFilter mf, SkinnedMeshRenderer smr, Mesh m, GameObject[] objsToBeAdded = null)
		{
			GameObject gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				gameObject = smr.gameObject;
				smr.sharedMesh = m;
				smr.lightmapIndex = mom.GetLightmapIndex();
			}
			else
			{
				gameObject = mr.gameObject;
				mf.sharedMesh = m;
				mr.lightmapIndex = mom.GetLightmapIndex();
			}
			if (mom.lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping || mom.lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
			{
				gameObject.isStatic = true;
			}
			if (objsToBeAdded == null || objsToBeAdded.Length <= 0 || !(objsToBeAdded[0] != null))
			{
				return;
			}
			bool flag = true;
			bool flag2 = true;
			string tag = objsToBeAdded[0].tag;
			int layer = objsToBeAdded[0].layer;
			for (int i = 0; i < objsToBeAdded.Length; i++)
			{
				if (objsToBeAdded[i] != null)
				{
					if (!objsToBeAdded[i].tag.Equals(tag))
					{
						flag = false;
					}
					if (objsToBeAdded[i].layer != layer)
					{
						flag2 = false;
					}
				}
			}
			if (flag)
			{
				root.tag = tag;
				gameObject.tag = tag;
			}
			if (flag2)
			{
				root.layer = layer;
				gameObject.layer = layer;
			}
		}

		public void BuildSceneMeshObject(GameObject[] gos = null, bool createNewChild = false)
		{
			if (_resultSceneObject == null)
			{
				_resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			_targetRenderer = BuildSceneHierarchPreBake(this, _resultSceneObject, GetMesh(), createNewChild, gos);
		}

		private bool IsMirrored(Matrix4x4 tm)
		{
			Vector3 lhs = tm.GetRow(0);
			Vector3 rhs = tm.GetRow(1);
			Vector3 rhs2 = tm.GetRow(2);
			lhs.Normalize();
			rhs.Normalize();
			rhs2.Normalize();
			float num = Vector3.Dot(Vector3.Cross(lhs, rhs), rhs2);
			return !(num >= 0f);
		}

		public override void CheckIntegrity()
		{
			if (!MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[i];
					HashSet<int> hashSet = new HashSet<int>();
					HashSet<int> hashSet2 = new HashSet<int>();
					for (int j = mB_DynamicGameObject.vertIdx; j < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; j++)
					{
						hashSet.Add(boneWeights[j].boneIndex0);
						hashSet.Add(boneWeights[j].boneIndex1);
						hashSet.Add(boneWeights[j].boneIndex2);
						hashSet.Add(boneWeights[j].boneIndex3);
					}
					for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
					{
						hashSet2.Add(mB_DynamicGameObject.indexesOfBonesUsed[k]);
					}
					hashSet2.ExceptWith(hashSet);
					if (hashSet2.Count > 0)
					{
						UnityEngine.Debug.LogError("The bone indexes were not the same. " + hashSet.Count + " " + hashSet2.Count);
					}
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						if (l < 0 || l > bones.Length)
						{
							UnityEngine.Debug.LogError("Bone index was out of bounds.");
						}
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer && mB_DynamicGameObject.indexesOfBonesUsed.Length < 1)
					{
						UnityEngine.Debug.Log("DGO had no bones");
					}
				}
			}
			if (doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("Blend shapes can only be used with skinned meshes.");
			}
		}

		private void _ZeroArray(Vector3[] arr, int idx, int length)
		{
			int num = idx + length;
			for (int i = idx; i < num; i++)
			{
				ref Vector3 reference = ref arr[i];
				reference = Vector3.zero;
			}
		}

		private List<MB_DynamicGameObject>[] _buildBoneIdx2dgoMap()
		{
			List<MB_DynamicGameObject>[] array = new List<MB_DynamicGameObject>[bones.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new List<MB_DynamicGameObject>();
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
				for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
				{
					array[mB_DynamicGameObject.indexesOfBonesUsed[k]].Add(mB_DynamicGameObject);
				}
			}
			return array;
		}

		private void _CollectBonesToAddForDGO(MB_DynamicGameObject dgo, Dictionary<Transform, int> bone2idx, HashSet<int> boneIdxsToDelete, HashSet<BoneAndBindpose> bonesToAdd, Renderer r, MeshChannelsCache meshChannelCache)
		{
			Matrix4x4[] array = (dgo._tmpCachedBindposes = meshChannelCache.GetBindposes(r));
			BoneWeight[] array2 = (dgo._tmpCachedBoneWeights = meshChannelCache.GetBoneWeights(r, dgo.numVerts));
			Transform[] array3 = (dgo._tmpCachedBones = _getBones(r));
			HashSet<int> hashSet = new HashSet<int>();
			for (int i = 0; i < array2.Length; i++)
			{
				hashSet.Add(array2[i].boneIndex0);
				hashSet.Add(array2[i].boneIndex1);
				hashSet.Add(array2[i].boneIndex2);
				hashSet.Add(array2[i].boneIndex3);
			}
			int[] array4 = new int[hashSet.Count];
			hashSet.CopyTo(array4);
			for (int j = 0; j < array4.Length; j++)
			{
				bool flag = false;
				int num = array4[j];
				if (bone2idx.TryGetValue(array3[num], out var value) && array3[num] == bones[value] && !boneIdxsToDelete.Contains(value) && array[num] == bindPoses[value])
				{
					flag = true;
				}
				if (!flag)
				{
					BoneAndBindpose item = new BoneAndBindpose(array3[num], array[num]);
					if (!bonesToAdd.Contains(item))
					{
						bonesToAdd.Add(item);
					}
				}
			}
			dgo._tmpIndexesOfSourceBonesUsed = array4;
		}

		private void _CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(HashSet<int> boneIdxsToDeleteHS, HashSet<BoneAndBindpose> bonesToAdd, Transform[] nbones, Matrix4x4[] nbindPoses, BoneWeight[] nboneWeights, int totalDeleteVerts)
		{
			if (boneIdxsToDeleteHS.Count > 0)
			{
				int[] array = new int[boneIdxsToDeleteHS.Count];
				boneIdxsToDeleteHS.CopyTo(array);
				Array.Sort(array);
				int[] array2 = new int[bones.Length];
				int num = 0;
				int num2 = 0;
				for (int i = 0; i < bones.Length; i++)
				{
					if (num2 < array.Length && array[num2] == i)
					{
						num2++;
						array2[i] = -1;
						continue;
					}
					array2[i] = num;
					nbones[num] = bones[i];
					ref Matrix4x4 reference = ref nbindPoses[num];
					reference = bindPoses[i];
					num++;
				}
				int num3 = boneWeights.Length - totalDeleteVerts;
				for (int j = 0; j < num3; j++)
				{
					nboneWeights[j].boneIndex0 = array2[nboneWeights[j].boneIndex0];
					nboneWeights[j].boneIndex1 = array2[nboneWeights[j].boneIndex1];
					nboneWeights[j].boneIndex2 = array2[nboneWeights[j].boneIndex2];
					nboneWeights[j].boneIndex3 = array2[nboneWeights[j].boneIndex3];
				}
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						mB_DynamicGameObject.indexesOfBonesUsed[l] = array2[mB_DynamicGameObject.indexesOfBonesUsed[l]];
					}
				}
			}
			else
			{
				Array.Copy(bones, nbones, bones.Length);
				Array.Copy(bindPoses, nbindPoses, bindPoses.Length);
			}
		}

		private void _AddBonesToNewBonesArrayAndAdjustBWIndexes(MB_DynamicGameObject dgo, Renderer r, int vertsIdx, Transform[] nbones, BoneWeight[] nboneWeights, MeshChannelsCache meshChannelCache)
		{
			Transform[] tmpCachedBones = dgo._tmpCachedBones;
			Matrix4x4[] tmpCachedBindposes = dgo._tmpCachedBindposes;
			BoneWeight[] tmpCachedBoneWeights = dgo._tmpCachedBoneWeights;
			int[] array = new int[tmpCachedBones.Length];
			for (int i = 0; i < dgo._tmpIndexesOfSourceBonesUsed.Length; i++)
			{
				int num = dgo._tmpIndexesOfSourceBonesUsed[i];
				for (int j = 0; j < nbones.Length; j++)
				{
					if (tmpCachedBones[num] == nbones[j] && tmpCachedBindposes[num] == bindPoses[j])
					{
						array[num] = j;
						break;
					}
				}
			}
			for (int k = 0; k < tmpCachedBoneWeights.Length; k++)
			{
				int num2 = vertsIdx + k;
				nboneWeights[num2].boneIndex0 = array[tmpCachedBoneWeights[k].boneIndex0];
				nboneWeights[num2].boneIndex1 = array[tmpCachedBoneWeights[k].boneIndex1];
				nboneWeights[num2].boneIndex2 = array[tmpCachedBoneWeights[k].boneIndex2];
				nboneWeights[num2].boneIndex3 = array[tmpCachedBoneWeights[k].boneIndex3];
				nboneWeights[num2].weight0 = tmpCachedBoneWeights[k].weight0;
				nboneWeights[num2].weight1 = tmpCachedBoneWeights[k].weight1;
				nboneWeights[num2].weight2 = tmpCachedBoneWeights[k].weight2;
				nboneWeights[num2].weight3 = tmpCachedBoneWeights[k].weight3;
			}
			for (int l = 0; l < dgo._tmpIndexesOfSourceBonesUsed.Length; l++)
			{
				dgo._tmpIndexesOfSourceBonesUsed[l] = array[dgo._tmpIndexesOfSourceBonesUsed[l]];
			}
			dgo.indexesOfBonesUsed = dgo._tmpIndexesOfSourceBonesUsed;
			dgo._tmpIndexesOfSourceBonesUsed = null;
			dgo._tmpCachedBones = null;
			dgo._tmpCachedBindposes = null;
			dgo._tmpCachedBoneWeights = null;
		}

		private void _copyUV2unchangedToSeparateRects()
		{
			int padding = 16;
			List<Vector2> list = new List<Vector2>();
			float num = 1E+11f;
			float num2 = 0f;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				float magnitude = mbDynamicObjectsInCombinedMesh[i].meshSize.magnitude;
				if (magnitude > num2)
				{
					num2 = magnitude;
				}
				if (magnitude < num)
				{
					num = magnitude;
				}
			}
			float num3 = 1000f;
			float num4 = 10f;
			float num5 = 0f;
			float num6 = 1f;
			if (num2 - num > num3 - num4)
			{
				num6 = (num3 - num4) / (num2 - num);
				num5 = num4 - num * num6;
			}
			else
			{
				num6 = num3 / num2;
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				float magnitude2 = mbDynamicObjectsInCombinedMesh[j].meshSize.magnitude;
				magnitude2 = magnitude2 * num6 + num5;
				Vector2 item = Vector2.one * magnitude2;
				list.Add(item);
			}
			MB2_TexturePacker mB2_TexturePacker = new MB2_TexturePacker();
			mB2_TexturePacker.doPowerOfTwoTextures = false;
			AtlasPackingResult[] rects = mB2_TexturePacker.GetRects(list, 8192, padding);
			for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
				float x;
				float num7 = (x = uv2s[mB_DynamicGameObject.vertIdx].x);
				float y;
				float num8 = (y = uv2s[mB_DynamicGameObject.vertIdx].y);
				int num9 = mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts;
				for (int l = mB_DynamicGameObject.vertIdx; l < num9; l++)
				{
					if (uv2s[l].x < num7)
					{
						num7 = uv2s[l].x;
					}
					if (uv2s[l].x > x)
					{
						x = uv2s[l].x;
					}
					if (uv2s[l].y < num8)
					{
						num8 = uv2s[l].y;
					}
					if (uv2s[l].y > y)
					{
						y = uv2s[l].y;
					}
				}
				Rect rect = rects[0].rects[k];
				for (int m = mB_DynamicGameObject.vertIdx; m < num9; m++)
				{
					float num10 = x - num7;
					float num11 = y - num8;
					if (num10 == 0f)
					{
						num10 = 1f;
					}
					if (num11 == 0f)
					{
						num11 = 1f;
					}
					uv2s[m].x = (uv2s[m].x - num7) / num10 * rect.width + rect.x;
					uv2s[m].y = (uv2s[m].y - num8) / num11 * rect.height + rect.y;
				}
			}
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			List<Material> list = new List<Material>();
			if (_targetRenderer != null)
			{
				list.AddRange(_targetRenderer.sharedMaterials);
			}
			return list;
		}
	}
	[Serializable]
	public class MB3_MultiMeshCombiner : MB3_MeshCombiner
	{
		[Serializable]
		public class CombinedMesh
		{
			public MB3_MeshCombinerSingle combinedMesh;

			public int extraSpace = -1;

			public int numVertsInListToDelete;

			public int numVertsInListToAdd;

			public List<GameObject> gosToAdd;

			public List<int> gosToDelete;

			public List<GameObject> gosToUpdate;

			public bool isDirty;

			public CombinedMesh(int maxNumVertsInMesh, GameObject resultSceneObject, MB2_LogLevel ll)
			{
				combinedMesh = new MB3_MeshCombinerSingle();
				combinedMesh.resultSceneObject = resultSceneObject;
				combinedMesh.LOG_LEVEL = ll;
				extraSpace = maxNumVertsInMesh;
				numVertsInListToDelete = 0;
				numVertsInListToAdd = 0;
				gosToAdd = new List<GameObject>();
				gosToDelete = new List<int>();
				gosToUpdate = new List<GameObject>();
			}

			public bool isEmpty()
			{
				List<GameObject> list = new List<GameObject>();
				list.AddRange(combinedMesh.GetObjectsInCombined());
				for (int i = 0; i < gosToDelete.Count; i++)
				{
					for (int j = 0; j < list.Count; j++)
					{
						if (list[j].GetInstanceID() == gosToDelete[i])
						{
							list.RemoveAt(j);
							break;
						}
					}
				}
				if (list.Count == 0)
				{
					return true;
				}
				return false;
			}
		}

		private static GameObject[] empty = new GameObject[0];

		private static int[] emptyIDs = new int[0];

		public Dictionary<int, CombinedMesh> obj2MeshCombinerMap = new Dictionary<int, CombinedMesh>();

		[SerializeField]
		public List<CombinedMesh> meshCombiners = new List<CombinedMesh>();

		[SerializeField]
		private int _maxVertsInMesh = 65535;

		public override MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.LOG_LEVEL = value;
				}
			}
		}

		public override MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.validationLevel = _validationLevel;
				}
			}
		}

		public int maxVertsInMesh
		{
			get
			{
				return _maxVertsInMesh;
			}
			set
			{
				if (obj2MeshCombinerMap.Count <= 0)
				{
					if (value < 3)
					{
						UnityEngine.Debug.LogError("Max verts in mesh must be greater than three.");
					}
					else if (value > 65535)
					{
						UnityEngine.Debug.LogError("Meshes in unity cannot have more than 65535 vertices.");
					}
					else
					{
						_maxVertsInMesh = value;
					}
				}
			}
		}

		public override int GetNumObjectsInCombined()
		{
			return obj2MeshCombinerMap.Count;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(go.GetInstanceID(), out value))
			{
				return value.combinedMesh.GetNumVerticesFor(go);
			}
			return -1;
		}

		public override int GetNumVerticesFor(int gameObjectID)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(gameObjectID, out value))
			{
				return value.combinedMesh.GetNumVerticesFor(gameObjectID);
			}
			return -1;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				list.AddRange(meshCombiners[i].combinedMesh.GetObjectsInCombined());
			}
			return list;
		}

		public override int GetLightmapIndex()
		{
			if (meshCombiners.Count > 0)
			{
				return meshCombiners[0].combinedMesh.GetLightmapIndex();
			}
			return -1;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return obj2MeshCombinerMap.ContainsKey(go.GetInstanceID());
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length <= 0 || _textureBakeResults.doMultiMaterial || !(_textureBakeResults.resultMaterial != null))
				{
					UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
					return false;
				}
				MB_MultiMaterial[] array = (_textureBakeResults.resultMaterials = new MB_MultiMaterial[1]);
				array[0] = new MB_MultiMaterial();
				array[0].combinedMaterial = _textureBakeResults.resultMaterial;
				array[0].considerMeshUVs = _textureBakeResults.fixOutOfBoundsUVs;
				List<Material> list = (array[0].sourceMaterials = new List<Material>());
				for (int i = 0; i < _textureBakeResults.materialsAndUVRects.Length; i++)
				{
					if (!list.Contains(_textureBakeResults.materialsAndUVRects[i].material))
					{
						list.Add(_textureBakeResults.materialsAndUVRects[i].material);
					}
				}
			}
			return true;
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBounds();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBones();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBounds();
			}
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			if (gos == null)
			{
				UnityEngine.Debug.LogError("list of game objects cannot be null");
				return;
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].gosToUpdate.Clear();
			}
			for (int j = 0; j < gos.Length; j++)
			{
				CombinedMesh value = null;
				obj2MeshCombinerMap.TryGetValue(gos[j].GetInstanceID(), out value);
				if (value != null)
				{
					value.gosToUpdate.Add(gos[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", gos[j], " is not in the combined mesh."));
				}
			}
			for (int k = 0; k < meshCombiners.Count; k++)
			{
				if (meshCombiners[k].gosToUpdate.Count > 0)
				{
					meshCombiners[k].isDirty = true;
					GameObject[] gos2 = meshCombiners[k].gosToUpdate.ToArray();
					meshCombiners[k].combinedMesh.UpdateGameObjects(gos2, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
				}
			}
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true)
		{
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length > 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length > 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			if (!_validate(gos, deleteGOinstanceIDs))
			{
				return false;
			}
			_distributeAmongBakers(gos, deleteGOinstanceIDs);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.AddDeleteGameObjects numCombinedMeshes: ", meshCombiners.Count, " added:", gos, " deleted:", deleteGOinstanceIDs, " disableRendererInSource:", disableRendererInSource, " maxVertsPerCombined:", _maxVertsInMesh));
			}
			return _bakeStep1(gos, deleteGOinstanceIDs, disableRendererInSource);
		}

		private bool _validate(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (_validationLevel == MB2_ValidationLevel.none)
			{
				return true;
			}
			if (_maxVertsInMesh < 3)
			{
				UnityEngine.Debug.LogError("Invalid value for maxVertsInMesh=" + _maxVertsInMesh);
			}
			_validateTextureBakeResults();
			if (gos != null)
			{
				for (int i = 0; i < gos.Length; i++)
				{
					if (gos[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
						return false;
					}
					if (_validationLevel < MB2_ValidationLevel.robust)
					{
						continue;
					}
					for (int j = i + 1; j < gos.Length; j++)
					{
						if (gos[i] == gos[j])
						{
							UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], "appears twice in list of game objects to add"));
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(gos[i].GetInstanceID()))
					{
						continue;
					}
					bool flag = false;
					if (deleteGOinstanceIDs != null)
					{
						for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
						{
							if (deleteGOinstanceIDs[k] == gos[i].GetInstanceID())
							{
								flag = true;
							}
						}
					}
					if (!flag)
					{
						UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " is already in the combined mesh ", gos[i].GetInstanceID()));
						return false;
					}
				}
			}
			if (deleteGOinstanceIDs != null && _validationLevel >= MB2_ValidationLevel.robust)
			{
				for (int l = 0; l < deleteGOinstanceIDs.Length; l++)
				{
					for (int m = l + 1; m < deleteGOinstanceIDs.Length; m++)
					{
						if (deleteGOinstanceIDs[l] == deleteGOinstanceIDs[m])
						{
							UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[l] + "appears twice in list of game objects to delete");
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(deleteGOinstanceIDs[l]))
					{
						UnityEngine.Debug.LogWarning("GameObject with instance ID " + deleteGOinstanceIDs[l] + " on the list of objects to delete is not in the combined mesh.");
					}
				}
			}
			return true;
		}

		private void _distributeAmongBakers(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (gos == null)
			{
				gos = empty;
			}
			if (deleteGOinstanceIDs == null)
			{
				deleteGOinstanceIDs = emptyIDs;
			}
			if (resultSceneObject == null)
			{
				resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].extraSpace = _maxVertsInMesh - meshCombiners[i].combinedMesh.GetMesh().vertexCount;
			}
			for (int j = 0; j < deleteGOinstanceIDs.Length; j++)
			{
				CombinedMesh value = null;
				if (obj2MeshCombinerMap.TryGetValue(deleteGOinstanceIDs[j], out value))
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Removing " + deleteGOinstanceIDs[j] + " from meshCombiner " + meshCombiners.IndexOf(value));
					}
					value.numVertsInListToDelete += value.combinedMesh.GetNumVerticesFor(deleteGOinstanceIDs[j]);
					value.gosToDelete.Add(deleteGOinstanceIDs[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Object " + deleteGOinstanceIDs[j] + " in the list of objects to delete is not in the combined mesh.");
				}
			}
			for (int k = 0; k < gos.Length; k++)
			{
				GameObject gameObject = gos[k];
				int vertexCount = MB_Utility.GetMesh(gameObject).vertexCount;
				CombinedMesh combinedMesh = null;
				for (int l = 0; l < meshCombiners.Count; l++)
				{
					if (meshCombiners[l].extraSpace + meshCombiners[l].numVertsInListToDelete - meshCombiners[l].numVertsInListToAdd > vertexCount)
					{
						combinedMesh = meshCombiners[l];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.Added ", gos[k], " to combinedMesh ", l), LOG_LEVEL);
						}
						break;
					}
				}
				if (combinedMesh == null)
				{
					combinedMesh = new CombinedMesh(maxVertsInMesh, _resultSceneObject, _LOG_LEVEL);
					_setMBValues(combinedMesh.combinedMesh);
					meshCombiners.Add(combinedMesh);
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Created new combinedMesh");
					}
				}
				combinedMesh.gosToAdd.Add(gameObject);
				combinedMesh.numVertsInListToAdd += vertexCount;
			}
		}

		private bool _bakeStep1(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				CombinedMesh combinedMesh = meshCombiners[i];
				if (combinedMesh.combinedMesh.targetRenderer == null)
				{
					combinedMesh.combinedMesh.resultSceneObject = _resultSceneObject;
					combinedMesh.combinedMesh.BuildSceneMeshObject(gos, createNewChild: true);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("BuildSO combiner {0} goID {1} targetRenID {2} meshID {3}", i, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				else if (combinedMesh.combinedMesh.targetRenderer.transform.parent != resultSceneObject.transform)
				{
					UnityEngine.Debug.LogError("targetRender objects must be children of resultSceneObject");
					return false;
				}
				if (combinedMesh.gosToAdd.Count > 0 || combinedMesh.gosToDelete.Count > 0)
				{
					combinedMesh.combinedMesh.AddDeleteGameObjectsByID(combinedMesh.gosToAdd.ToArray(), combinedMesh.gosToDelete.ToArray(), disableRendererInSource);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Baked combiner {0} obsAdded {1} objsRemoved {2} goID {3} targetRenID {4} meshID {5}", i, combinedMesh.gosToAdd.Count, combinedMesh.gosToDelete.Count, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				Renderer renderer = combinedMesh.combinedMesh.targetRenderer;
				Mesh mesh = combinedMesh.combinedMesh.GetMesh();
				if (renderer is MeshRenderer)
				{
					MeshFilter component = renderer.gameObject.GetComponent<MeshFilter>();
					component.sharedMesh = mesh;
				}
				else
				{
					SkinnedMeshRenderer skinnedMeshRenderer = (SkinnedMeshRenderer)renderer;
					skinnedMeshRenderer.sharedMesh = mesh;
				}
			}
			for (int j = 0; j < meshCombiners.Count; j++)
			{
				CombinedMesh combinedMesh2 = meshCombiners[j];
				for (int k = 0; k < combinedMesh2.gosToDelete.Count; k++)
				{
					obj2MeshCombinerMap.Remove(combinedMesh2.gosToDelete[k]);
				}
			}
			for (int l = 0; l < meshCombiners.Count; l++)
			{
				CombinedMesh combinedMesh3 = meshCombiners[l];
				for (int m = 0; m < combinedMesh3.gosToAdd.Count; m++)
				{
					obj2MeshCombinerMap.Add(combinedMesh3.gosToAdd[m].GetInstanceID(), combinedMesh3);
				}
				if (combinedMesh3.gosToAdd.Count > 0 || combinedMesh3.gosToDelete.Count > 0)
				{
					combinedMesh3.gosToDelete.Clear();
					combinedMesh3.gosToAdd.Clear();
					combinedMesh3.numVertsInListToDelete = 0;
					combinedMesh3.numVertsInListToAdd = 0;
					combinedMesh3.isDirty = true;
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				string text = "Meshes in combined:";
				for (int n = 0; n < meshCombiners.Count; n++)
				{
					string text2 = text;
					text = text2 + " mesh" + n + "(" + meshCombiners[n].combinedMesh.GetObjectsInCombined().Count + ")\n";
				}
				text = text + "children in result: " + resultSceneObject.transform.childCount;
				MB2_Log.LogDebug(text, LOG_LEVEL);
			}
			if (meshCombiners.Count > 0)
			{
				return true;
			}
			return false;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				for (int j = 0; j < meshCombiners[i].combinedMesh.blendShapes.Length; j++)
				{
					MB3_MeshCombinerSingle.MBBlendShape mBBlendShape = meshCombiners[i].combinedMesh.blendShapes[j];
					MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
					mBBlendShapeValue.combinedMeshGameObject = meshCombiners[i].combinedMesh.targetRenderer.gameObject;
					mBBlendShapeValue.blendShapeIndex = j;
					dictionary.Add(new MBBlendShapeKey(mBBlendShape.gameObjectID, mBBlendShape.indexInSource), mBBlendShapeValue);
				}
			}
			return dictionary;
		}

		public override void ClearBuffers()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.ClearBuffers();
			}
			obj2MeshCombinerMap.Clear();
		}

		public override void ClearMesh()
		{
			DestroyMesh();
		}

		public override void DestroyMesh()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					MB_Utility.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					editorMethods.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		private void _setMBValues(MB3_MeshCombinerSingle targ)
		{
			targ.validationLevel = _validationLevel;
			targ.renderType = renderType;
			targ.outputOption = MB2_OutputOptions.bakeIntoSceneObject;
			targ.lightmapOption = lightmapOption;
			targ.textureBakeResults = textureBakeResults;
			targ.doNorm = doNorm;
			targ.doTan = doTan;
			targ.doCol = doCol;
			targ.doUV = doUV;
			targ.doUV3 = doUV3;
			targ.doUV4 = doUV4;
			targ.doBlendShapes = doBlendShapes;
			targ.optimizeAfterBake = base.optimizeAfterBake;
			targ.recenterVertsToBoundsCenter = recenterVertsToBoundsCenter;
			targ.uv2UnwrappingParamsHardAngle = uv2UnwrappingParamsHardAngle;
			targ.uv2UnwrappingParamsPackMargin = uv2UnwrappingParamsPackMargin;
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			HashSet<Material> hashSet = new HashSet<Material>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				hashSet.UnionWith(meshCombiners[i].combinedMesh.GetMaterialsOnTargetRenderer());
			}
			return new List<Material>(hashSet);
		}

		public override void CheckIntegrity()
		{
			if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.CheckIntegrity();
				}
			}
		}
	}
	[Serializable]
	public class ShaderTextureProperty
	{
		public string name;

		public bool isNormalMap;

		public ShaderTextureProperty(string n, bool norm)
		{
			name = n;
			isNormalMap = norm;
		}

		public static string[] GetNames(List<ShaderTextureProperty> props)
		{
			string[] array = new string[props.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = props[i].name;
			}
			return array;
		}
	}
	[Serializable]
	public class MB3_TextureCombiner
	{
		public class MeshBakerMaterialTexture
		{
			public Texture2D t;

			public float texelDensity;

			public DRect encapsulatingSamplingRect;

			public DRect matTilingRect;

			public MeshBakerMaterialTexture()
			{
			}

			public MeshBakerMaterialTexture(Texture2D tx)
			{
				t = tx;
			}

			public MeshBakerMaterialTexture(Texture2D tx, Vector2 o, Vector2 s, float texelDens)
			{
				t = tx;
				matTilingRect = new DRect(o, s);
				texelDensity = texelDens;
			}
		}

		public class MatAndTransformToMerged
		{
			public Material mat;

			public DRect obUVRectIfTilingSame = new DRect(0f, 0f, 1f, 1f);

			public DRect samplingRectMatAndUVTiling = default(DRect);

			public DRect materialTiling = default(DRect);

			public string objName;

			public MatAndTransformToMerged(Material m)
			{
				mat = m;
			}

			public override bool Equals(object obj)
			{
				if (obj is MatAndTransformToMerged)
				{
					MatAndTransformToMerged matAndTransformToMerged = (MatAndTransformToMerged)obj;
					if (matAndTransformToMerged.mat == mat && matAndTransformToMerged.obUVRectIfTilingSame == obUVRectIfTilingSame)
					{
						return true;
					}
				}
				return false;
			}

			public override int GetHashCode()
			{
				return mat.GetHashCode() ^ obUVRectIfTilingSame.GetHashCode() ^ samplingRectMatAndUVTiling.GetHashCode();
			}
		}

		public class SamplingRectEnclosesComparer : IComparer<MatAndTransformToMerged>
		{
			public int Compare(MatAndTransformToMerged x, MatAndTransformToMerged y)
			{
				if (x.samplingRectMatAndUVTiling.Equals(y.samplingRectMatAndUVTiling))
				{
					return 0;
				}
				if (x.samplingRectMatAndUVTiling.Encloses(y.samplingRectMatAndUVTiling))
				{
					return -1;
				}
				return 1;
			}
		}

		public class MatsAndGOs
		{
			public List<MatAndTransformToMerged> mats;

			public List<GameObject> gos;
		}

		public class MB_TexSet
		{
			public MeshBakerMaterialTexture[] ts;

			public MatsAndGOs matsAndGOs;

			public bool allTexturesUseSameMatTiling;

			public Vector2 obUVoffset = new Vector2(0f, 0f);

			public Vector2 obUVscale = new Vector2(1f, 1f);

			public int idealWidth;

			public int idealHeight;

			public DRect obUVrect => new DRect(obUVoffset, obUVscale);

			public MB_TexSet(MeshBakerMaterialTexture[] tss, Vector2 uvOffset, Vector2 uvScale)
			{
				ts = tss;
				obUVoffset = uvOffset;
				obUVscale = uvScale;
				allTexturesUseSameMatTiling = false;
				matsAndGOs = new MatsAndGOs();
				matsAndGOs.mats = new List<MatAndTransformToMerged>();
				matsAndGOs.gos = new List<GameObject>();
			}

			public bool IsEqual(object obj, bool fixOutOfBoundsUVs, bool considerNonTextureProperties, TextureBlender resultMaterialTextureBlender)
			{
				if (!(obj is MB_TexSet))
				{
					return false;
				}
				MB_TexSet mB_TexSet = (MB_TexSet)obj;
				if (mB_TexSet.ts.Length != ts.Length)
				{
					return false;
				}
				for (int i = 0; i < ts.Length; i++)
				{
					if (ts[i].matTilingRect != mB_TexSet.ts[i].matTilingRect)
					{
						return false;
					}
					if (ts[i].t != mB_TexSet.ts[i].t)
					{
						return false;
					}
					if (considerNonTextureProperties && resultMaterialTextureBlender != null && !resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, mB_TexSet.matsAndGOs.mats[0].mat))
					{
						return false;
					}
				}
				if (fixOutOfBoundsUVs && (obUVoffset.x != mB_TexSet.obUVoffset.x || obUVoffset.y != mB_TexSet.obUVoffset.y))
				{
					return false;
				}
				if (fixOutOfBoundsUVs && (obUVscale.x != mB_TexSet.obUVscale.x || obUVscale.y != mB_TexSet.obUVscale.y))
				{
					return false;
				}
				return true;
			}

			public void CalcInitialFullSamplingRects(bool fixOutOfBoundsUVs)
			{
				DRect encapsulatingSamplingRect = new DRect(0f, 0f, 1f, 1f);
				if (fixOutOfBoundsUVs)
				{
					encapsulatingSamplingRect = obUVrect;
				}
				for (int i = 0; i < ts.Length; i++)
				{
					if (ts[i].t != null)
					{
						DRect r = ts[i].matTilingRect;
						DRect r2 = ((!fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : obUVrect);
						ts[i].encapsulatingSamplingRect = MB3_UVTransformUtility.CombineTransforms(ref r2, ref r);
						encapsulatingSamplingRect = ts[i].encapsulatingSamplingRect;
					}
				}
				for (int j = 0; j < ts.Length; j++)
				{
					if (ts[j].t == null)
					{
						ts[j].encapsulatingSamplingRect = encapsulatingSamplingRect;
					}
				}
			}

			public void CalcMatAndUVSamplingRects()
			{
				if (allTexturesUseSameMatTiling)
				{
					DRect r = new DRect(0f, 0f, 1f, 1f);
					for (int i = 0; i < ts.Length; i++)
					{
						if (ts[i].t != null)
						{
							r = ts[i].matTilingRect;
						}
					}
					for (int j = 0; j < matsAndGOs.mats.Count; j++)
					{
						matsAndGOs.mats[j].materialTiling = r;
						matsAndGOs.mats[j].samplingRectMatAndUVTiling = MB3_UVTransformUtility.CombineTransforms(ref matsAndGOs.mats[j].obUVRectIfTilingSame, ref r);
					}
				}
				else
				{
					for (int k = 0; k < matsAndGOs.mats.Count; k++)
					{
						DRect r2 = new DRect(0f, 0f, 1f, 1f);
						matsAndGOs.mats[k].materialTiling = r2;
						matsAndGOs.mats[k].samplingRectMatAndUVTiling = MB3_UVTransformUtility.CombineTransforms(ref matsAndGOs.mats[k].obUVRectIfTilingSame, ref r2);
					}
				}
			}

			public bool AllTexturesAreSameForMerge(MB_TexSet other, bool considerNonTextureProperties, TextureBlender resultMaterialTextureBlender)
			{
				if (other.ts.Length != ts.Length)
				{
					return false;
				}
				if (!other.allTexturesUseSameMatTiling || !allTexturesUseSameMatTiling)
				{
					return false;
				}
				int num = -1;
				for (int i = 0; i < ts.Length; i++)
				{
					if (ts[i].t != other.ts[i].t)
					{
						return false;
					}
					if (num == -1 && ts[i].t != null)
					{
						num = i;
					}
					if (considerNonTextureProperties && resultMaterialTextureBlender != null && !resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, other.matsAndGOs.mats[0].mat))
					{
						return false;
					}
				}
				if (num != -1)
				{
					for (int j = 0; j < ts.Length; j++)
					{
						if (ts[j].t != other.ts[j].t)
						{
							return false;
						}
					}
				}
				return true;
			}

			internal string GetDescription()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendFormat("[GAME_OBJS=");
				for (int i = 0; i < matsAndGOs.gos.Count; i++)
				{
					stringBuilder.AppendFormat("{0},", matsAndGOs.gos[i].name);
				}
				stringBuilder.AppendFormat("MATS=");
				for (int j = 0; j < matsAndGOs.mats.Count; j++)
				{
					stringBuilder.AppendFormat("{0},", matsAndGOs.mats[j].mat.name);
				}
				stringBuilder.Append("]");
				return stringBuilder.ToString();
			}

			internal string GetMatSubrectDescriptions()
			{
				StringBuilder stringBuilder = new StringBuilder();
				for (int i = 0; i < matsAndGOs.mats.Count; i++)
				{
					stringBuilder.AppendFormat("\n    {0}={1},", matsAndGOs.mats[i].mat.name, matsAndGOs.mats[i].samplingRectMatAndUVTiling);
				}
				return stringBuilder.ToString();
			}
		}

		public class CombineTexturesIntoAtlasesCoroutineResult
		{
			public bool success = true;

			public bool isFinished;
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		public static ShaderTextureProperty[] shaderTexPropertyNames = new ShaderTextureProperty[19]
		{
			new ShaderTextureProperty("_MainTex", norm: false),
			new ShaderTextureProperty("_BumpMap", norm: true),
			new ShaderTextureProperty("_Normal", norm: true),
			new ShaderTextureProperty("_BumpSpecMap", norm: false),
			new ShaderTextureProperty("_DecalTex", norm: false),
			new ShaderTextureProperty("_Detail", norm: false),
			new ShaderTextureProperty("_GlossMap", norm: false),
			new ShaderTextureProperty("_Illum", norm: false),
			new ShaderTextureProperty("_LightTextureB0", norm: false),
			new ShaderTextureProperty("_ParallaxMap", norm: false),
			new ShaderTextureProperty("_ShadowOffset", norm: false),
			new ShaderTextureProperty("_TranslucencyMap", norm: false),
			new ShaderTextureProperty("_SpecMap", norm: false),
			new ShaderTextureProperty("_SpecGlossMap", norm: false),
			new ShaderTextureProperty("_TranspMap", norm: false),
			new ShaderTextureProperty("_MetallicGlossMap", norm: false),
			new ShaderTextureProperty("_OcclusionMap", norm: false),
			new ShaderTextureProperty("_EmissionMap", norm: false),
			new ShaderTextureProperty("_DetailMask", norm: false)
		};

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected int _atlasPadding = 1;

		[SerializeField]
		protected int _maxAtlasSize = 1;

		[SerializeField]
		protected bool _resizePowerOfTwoTextures;

		[SerializeField]
		protected bool _fixOutOfBoundsUVs;

		[SerializeField]
		protected int _maxTilingBakeSize = 1024;

		[SerializeField]
		protected bool _saveAtlasesAsAssets;

		[SerializeField]
		protected MB2_PackingAlgorithmEnum _packingAlgorithm;

		[SerializeField]
		protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

		[SerializeField]
		protected List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

		[SerializeField]
		protected bool _normalizeTexelDensity;

		[SerializeField]
		protected bool _considerNonTextureProperties;

		protected TextureBlender resultMaterialTextureBlender;

		protected TextureBlender[] textureBlenders = new TextureBlender[0];

		protected List<Texture2D> _temporaryTextures = new List<Texture2D>();

		public static bool _RunCorutineWithoutPauseIsRunning = false;

		private int __step2_CalculateIdealSizesForTexturesInAtlasAndPadding;

		private Rect[] __createAtlasesMBTexturePacker;

		private static bool LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS = true;

		public MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public int atlasPadding
		{
			get
			{
				return _atlasPadding;
			}
			set
			{
				_atlasPadding = value;
			}
		}

		public int maxAtlasSize
		{
			get
			{
				return _maxAtlasSize;
			}
			set
			{
				_maxAtlasSize = value;
			}
		}

		public bool resizePowerOfTwoTextures
		{
			get
			{
				return _resizePowerOfTwoTextures;
			}
			set
			{
				_resizePowerOfTwoTextures = value;
			}
		}

		public bool fixOutOfBoundsUVs
		{
			get
			{
				return _fixOutOfBoundsUVs;
			}
			set
			{
				_fixOutOfBoundsUVs = value;
			}
		}

		public int maxTilingBakeSize
		{
			get
			{
				return _maxTilingBakeSize;
			}
			set
			{
				_maxTilingBakeSize = value;
			}
		}

		public bool saveAtlasesAsAssets
		{
			get
			{
				return _saveAtlasesAsAssets;
			}
			set
			{
				_saveAtlasesAsAssets = value;
			}
		}

		public MB2_PackingAlgorithmEnum packingAlgorithm
		{
			get
			{
				return _packingAlgorithm;
			}
			set
			{
				_packingAlgorithm = value;
			}
		}

		public bool meshBakerTexturePackerForcePowerOfTwo
		{
			get
			{
				return _meshBakerTexturePackerForcePowerOfTwo;
			}
			set
			{
				_meshBakerTexturePackerForcePowerOfTwo = value;
			}
		}

		public List<ShaderTextureProperty> customShaderPropNames
		{
			get
			{
				return _customShaderPropNames;
			}
			set
			{
				_customShaderPropNames = value;
			}
		}

		public bool considerNonTextureProperties
		{
			get
			{
				return _considerNonTextureProperties;
			}
			set
			{
				_considerNonTextureProperties = value;
			}
		}

		public static void RunCorutineWithoutPause(IEnumerator cor, int recursionDepth)
		{
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = true;
			}
			if (recursionDepth > 20)
			{
				UnityEngine.Debug.LogError("Recursion Depth Exceeded.");
				return;
			}
			while (cor.MoveNext())
			{
				object current = cor.Current;
				if (!(current is YieldInstruction) && current != null && current is IEnumerator)
				{
					RunCorutineWithoutPause((IEnumerator)cor.Current, recursionDepth + 1);
				}
			}
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = false;
			}
		}

		public bool CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			CombineTexturesIntoAtlasesCoroutineResult combineTexturesIntoAtlasesCoroutineResult = new CombineTexturesIntoAtlasesCoroutineResult();
			RunCorutineWithoutPause(_CombineTexturesIntoAtlases(progressInfo, combineTexturesIntoAtlasesCoroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects), 0);
			return combineTexturesIntoAtlasesCoroutineResult.success;
		}

		public IEnumerator CombineTexturesIntoAtlasesCoroutine(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, CombineTexturesIntoAtlasesCoroutineResult coroutineResult = null, float maxTimePerFrame = 0.01f, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			if (!_RunCorutineWithoutPauseIsRunning && (MBVersion.GetMajorVersion() < 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() < 3)))
			{
				UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
				yield return null;
			}
			coroutineResult.success = true;
			coroutineResult.isFinished = false;
			if (maxTimePerFrame <= 0f)
			{
				UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
				coroutineResult.isFinished = true;
			}
			else
			{
				yield return _CombineTexturesIntoAtlases(progressInfo, coroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects);
				coroutineResult.isFinished = true;
			}
		}

		private static bool InterfaceFilter(Type typeObj, object criteriaObj)
		{
			return typeObj.ToString() == criteriaObj.ToString();
		}

		private void _LoadTextureBlenders()
		{
			string filterCriteria = "DigitalOpus.MB.Core.TextureBlender";
			TypeFilter filter = InterfaceFilter;
			List<Type> list = new List<Type>();
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly in assemblies)
			{
				IEnumerable enumerable = null;
				try
				{
					enumerable = assembly.GetTypes();
				}
				catch (Exception ex)
				{
					ex.Equals(null);
				}
				if (enumerable == null)
				{
					continue;
				}
				Type[] types = assembly.GetTypes();
				foreach (Type type in types)
				{
					Type[] array = type.FindInterfaces(filter, filterCriteria);
					if (array.Length > 0)
					{
						list.Add(type);
					}
				}
			}
			TextureBlender textureBlender = null;
			List<TextureBlender> list2 = new List<TextureBlender>();
			foreach (Type item in list)
			{
				if (!item.IsAbstract && !item.IsInterface)
				{
					TextureBlender textureBlender2 = (TextureBlender)Activator.CreateInstance(item);
					if (textureBlender2 is TextureBlenderFallback)
					{
						textureBlender = textureBlender2;
					}
					else
					{
						list2.Add(textureBlender2);
					}
				}
			}
			if (textureBlender != null)
			{
				list2.Add(textureBlender);
			}
			textureBlenders = list2.ToArray();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Loaded {textureBlenders.Length} TextureBlenders.");
			}
		}

		private bool _CollectPropertyNames(Material resultMaterial, List<ShaderTextureProperty> texPropertyNames)
		{
			for (int i = 0; i < texPropertyNames.Count; i++)
			{
				ShaderTextureProperty shaderTextureProperty = _customShaderPropNames.Find((ShaderTextureProperty x) => x.name.Equals(texPropertyNames[i].name));
				if (shaderTextureProperty != null)
				{
					_customShaderPropNames.Remove(shaderTextureProperty);
				}
			}
			if (resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Please assign a result material. The combined mesh will use this material.");
				return false;
			}
			string text = string.Empty;
			for (int j = 0; j < shaderTexPropertyNames.Length; j++)
			{
				if (resultMaterial.HasProperty(shaderTexPropertyNames[j].name))
				{
					text = text + ", " + shaderTexPropertyNames[j].name;
					if (!texPropertyNames.Contains(shaderTexPropertyNames[j]))
					{
						texPropertyNames.Add(shaderTexPropertyNames[j]);
					}
					if (resultMaterial.GetTextureOffset(shaderTexPropertyNames[j].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is may be incorrect.");
					}
					if (resultMaterial.GetTextureScale(shaderTexPropertyNames[j].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should have tiling of 1,1");
					}
				}
			}
			for (int k = 0; k < _customShaderPropNames.Count; k++)
			{
				if (resultMaterial.HasProperty(_customShaderPropNames[k].name))
				{
					text = text + ", " + _customShaderPropNames[k].name;
					texPropertyNames.Add(_customShaderPropNames[k]);
					if (resultMaterial.GetTextureOffset(_customShaderPropNames[k].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is probably incorrect.");
					}
					if (resultMaterial.GetTextureScale(_customShaderPropNames[k].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should probably have tiling of 1,1.");
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Result material shader does not use property " + _customShaderPropNames[k].name + " in the list of custom shader property names");
				}
			}
			return true;
		}

		private IEnumerator _CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> atlasPackingResult, bool onlyPackRects)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			try
			{
				_temporaryTextures.Clear();
				if (textureEditorMethods != null)
				{
					textureEditorMethods.Clear();
					textureEditorMethods.OnPreTextureBake();
				}
				if (objsToMesh == null || objsToMesh.Count == 0)
				{
					UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
					result.success = false;
					yield break;
				}
				if (_atlasPadding < 0)
				{
					UnityEngine.Debug.LogError("Atlas padding must be zero or greater.");
					result.success = false;
					yield break;
				}
				if (_maxTilingBakeSize < 2 || _maxTilingBakeSize > 4096)
				{
					UnityEngine.Debug.LogError("Invalid value for max tiling bake size.");
					result.success = false;
					yield break;
				}
				for (int i = 0; i < objsToMesh.Count; i++)
				{
					Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
					foreach (Material material in gOMaterials)
					{
						if (material == null)
						{
							UnityEngine.Debug.LogError(string.Concat("Game object ", objsToMesh[i], " has a null material"));
							result.success = false;
							yield break;
						}
					}
				}
				progressInfo?.Invoke("Collecting textures for " + objsToMesh.Count + " meshes.", 0.01f);
				List<ShaderTextureProperty> texPropertyNames = new List<ShaderTextureProperty>();
				if (!_CollectPropertyNames(resultMaterial, texPropertyNames))
				{
					result.success = false;
					yield break;
				}
				if (_considerNonTextureProperties)
				{
					_LoadTextureBlenders();
					resultMaterialTextureBlender = FindMatchingTextureBlender(resultMaterial.shader.name);
					if (resultMaterialTextureBlender != null)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Using _considerNonTextureProperties found a TextureBlender for result material. Using: " + resultMaterialTextureBlender);
						}
					}
					else
					{
						if (LOG_LEVEL >= MB2_LogLevel.error)
						{
							UnityEngine.Debug.LogWarning("Using _considerNonTextureProperties could not find a TextureBlender that matches the shader on the result material. Using the Fallback Texture Blender.");
						}
						resultMaterialTextureBlender = new TextureBlenderFallback();
					}
				}
				if (onlyPackRects)
				{
					yield return __RunTexturePacker(result, texPropertyNames, objsToMesh, allowedMaterialsFilter, textureEditorMethods, atlasPackingResult);
				}
				else
				{
					yield return __CombineTexturesIntoAtlases(progressInfo, result, resultAtlasesAndRects, resultMaterial, texPropertyNames, objsToMesh, allowedMaterialsFilter, textureEditorMethods);
				}
			}
			finally
			{
				_destroyTemporaryTextures();
				if (textureEditorMethods != null)
				{
					textureEditorMethods.RestoreReadFlagsAndFormats(progressInfo);
					textureEditorMethods.OnPostTextureBake();
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log(string.Concat("===== Done creating atlases for ", resultMaterial, " Total time to create atlases ", sw.Elapsed.ToString()));
				}
			}
		}

		private IEnumerator __CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<ShaderTextureProperty> texPropertyNames, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__CombineTexturesIntoAtlases texture properties in shader:" + texPropertyNames.Count + " objsToMesh:" + objsToMesh.Count + " _fixOutOfBoundsUVs:" + _fixOutOfBoundsUVs);
			}
			progressInfo?.Invoke("Collecting textures ", 0.01f);
			List<MB_TexSet> distinctMaterialTextures = new List<MB_TexSet>();
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return __Step1_CollectDistinctMatTexturesAndUsedObjects(progressInfo, result, objsToMesh, allowedMaterialsFilter, texPropertyNames, textureEditorMethods, distinctMaterialTextures, usedObjsToMesh);
			if (!result.success)
			{
				yield break;
			}
			if (MB3_MeshCombiner.EVAL_VERSION)
			{
				bool flag = true;
				for (int i = 0; i < distinctMaterialTextures.Count; i++)
				{
					for (int j = 0; j < distinctMaterialTextures[i].matsAndGOs.mats.Count; j++)
					{
						if (!distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Diffuse") && !distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Bumped Diffuse"))
						{
							UnityEngine.Debug.LogError("The free version of Mesh Baker only works with Diffuse and Bumped Diffuse Shaders. The full version can be used with any shader. Material " + distinctMaterialTextures[i].matsAndGOs.mats[j].mat.name + " uses shader " + distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name);
							flag = false;
						}
					}
				}
				if (!flag)
				{
					result.success = false;
					yield break;
				}
			}
			bool[] allTexturesAreNullAndSameColor = new bool[texPropertyNames.Count];
			yield return __Step2_CalculateIdealSizesForTexturesInAtlasAndPadding(progressInfo, result, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, textureEditorMethods);
			if (result.success)
			{
				int _padding = __step2_CalculateIdealSizesForTexturesInAtlasAndPadding;
				yield return __Step3_BuildAndSaveAtlasesAndStoreResults(result, progressInfo, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, _padding, textureEditorMethods, resultAtlasesAndRects, resultMaterial);
			}
		}

		private IEnumerator __RunTexturePacker(CombineTexturesIntoAtlasesCoroutineResult result, List<ShaderTextureProperty> texPropertyNames, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> packingResult)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__RunTexturePacker texture properties in shader:" + texPropertyNames.Count + " objsToMesh:" + objsToMesh.Count + " _fixOutOfBoundsUVs:" + _fixOutOfBoundsUVs);
			}
			List<MB_TexSet> distinctMaterialTextures = new List<MB_TexSet>();
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return __Step1_CollectDistinctMatTexturesAndUsedObjects(null, result, objsToMesh, allowedMaterialsFilter, texPropertyNames, textureEditorMethods, distinctMaterialTextures, usedObjsToMesh);
			if (!result.success)
			{
				yield break;
			}
			bool[] allTexturesAreNullAndSameColor = new bool[texPropertyNames.Count];
			yield return __Step2_CalculateIdealSizesForTexturesInAtlasAndPadding(null, result, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, textureEditorMethods);
			if (result.success)
			{
				int _padding = __step2_CalculateIdealSizesForTexturesInAtlasAndPadding;
				AtlasPackingResult[] aprs = __Step3_RunTexturePacker(distinctMaterialTextures, _padding);
				for (int i = 0; i < aprs.Length; i++)
				{
					packingResult.Add(aprs[i]);
				}
			}
		}

		private IEnumerator __Step1_CollectDistinctMatTexturesAndUsedObjects(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, List<GameObject> allObjsToMesh, List<Material> allowedMaterialsFilter, List<ShaderTextureProperty> texPropertyNames, MB2_EditorMethodsInterface textureEditorMethods, List<MB_TexSet> distinctMaterialTextures, List<GameObject> usedObjsToMesh)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			bool flag = false;
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < allObjsToMesh.Count; i++)
			{
				GameObject gameObject = allObjsToMesh[i];
				progressInfo?.Invoke("Collecting textures for " + gameObject, (float)i / (float)allObjsToMesh.Count / 2f);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Collecting textures for object " + gameObject);
				}
				if (gameObject == null)
				{
					UnityEngine.Debug.LogError("The list of objects to mesh contained nulls.");
					result.success = false;
					yield break;
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (mesh == null)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh has no mesh.");
					result.success = false;
					yield break;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
				if (gOMaterials.Length == 0)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects has no materials.");
					result.success = false;
					yield break;
				}
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						if (_normalizeTexelDensity)
						{
							value[j].submeshArea = GetSubmeshArea(mesh, j);
						}
						if (_fixOutOfBoundsUVs && !value[j].hasUVs)
						{
							value[j].uvRect = new Rect(0f, 0f, 1f, 1f);
							UnityEngine.Debug.LogWarning(string.Concat("Mesh for object ", gameObject, " has no UV channel but 'consider UVs' is enabled. Assuming UVs will be generated filling 0,0,1,1 rectangle."));
						}
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (_fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log(string.Concat("Mesh Analysis for object ", gameObject, " numSubmesh=", value.Length, " HasOBUV=", value[0].hasOutOfBoundsUVs, " UVrectSubmesh0=", value[0].uvRect));
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					progressInfo?.Invoke($"Collecting textures for {gameObject} submesh {k}", (float)i / (float)allObjsToMesh.Count / 2f);
					Material material = gOMaterials[k];
					if (allowedMaterialsFilter != null && !allowedMaterialsFilter.Contains(material))
					{
						continue;
					}
					flag = flag || value[k].hasOutOfBoundsUVs;
					if (material.name.Contains("(Instance)"))
					{
						UnityEngine.Debug.LogError("The sharedMaterial on object " + gameObject.name + " has been 'Instanced'. This was probably caused by a script accessing the meshRender.material property in the editor.  The material to UV Rectangle mapping will be incorrect. To fix this recreate the object from its prefab or re-assign its material from the correct asset.");
						result.success = false;
						yield break;
					}
					if (_fixOutOfBoundsUVs && !MB_Utility.AreAllSharedMaterialsDistinct(gOMaterials) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + gameObject.name + " uses the same material on multiple submeshes. This may generate strange resultAtlasesAndRects especially when used with fix out of bounds uvs. Try duplicating the material.");
					}
					MeshBakerMaterialTexture[] array = new MeshBakerMaterialTexture[texPropertyNames.Count];
					for (int l = 0; l < texPropertyNames.Count; l++)
					{
						Texture2D texture2D = null;
						Vector2 s = Vector2.one;
						Vector2 o = Vector2.zero;
						float texelDens = 0f;
						if (material.HasProperty(texPropertyNames[l].name))
						{
							Texture texture = material.GetTexture(texPropertyNames[l].name);
							if (texture != null)
							{
								if (!(texture is Texture2D))
								{
									UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh uses a Texture that is not a Texture2D. Cannot build atlases.");
									result.success = false;
									yield break;
								}
								texture2D = (Texture2D)texture;
								TextureFormat format = texture2D.format;
								bool flag2 = false;
								if (!UnityEngine.Application.isPlaying && textureEditorMethods != null)
								{
									flag2 = textureEditorMethods.IsNormalMap(texture2D);
								}
								if ((format != TextureFormat.ARGB32 && format != TextureFormat.RGBA32 && format != TextureFormat.BGRA32 && format != TextureFormat.RGB24 && format != TextureFormat.Alpha8) || flag2)
								{
									if (UnityEngine.Application.isPlaying && _packingAlgorithm != MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast)
									{
										UnityEngine.Debug.LogError(string.Concat("Object ", gameObject.name, " in the list of objects to mesh uses Texture ", texture2D.name, " uses format ", format, " that is not in: ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT. These textures cannot be resized at runtime. Try changing texture format. If format says 'compressed' try changing it to 'truecolor'"));
										result.success = false;
										yield break;
									}
									texture2D = (Texture2D)material.GetTexture(texPropertyNames[l].name);
								}
							}
							if (texture2D != null && _normalizeTexelDensity)
							{
								texelDens = ((value[l].submeshArea != 0f) ? ((float)(texture2D.width * texture2D.height) / value[l].submeshArea) : 0f);
							}
							s = material.GetTextureScale(texPropertyNames[l].name);
							o = material.GetTextureOffset(texPropertyNames[l].name);
						}
						array[l] = new MeshBakerMaterialTexture(texture2D, o, s, texelDens);
					}
					Vector2 uvScale = new Vector2(value[k].uvRect.width, value[k].uvRect.height);
					Vector2 uvOffset = new Vector2(value[k].uvRect.x, value[k].uvRect.y);
					MB_TexSet setOfTexs = new MB_TexSet(array, uvOffset, uvScale);
					MatAndTransformToMerged item = new MatAndTransformToMerged(material);
					setOfTexs.matsAndGOs.mats.Add(item);
					MB_TexSet mB_TexSet = distinctMaterialTextures.Find((MB_TexSet x) => x.IsEqual(setOfTexs, _fixOutOfBoundsUVs, _considerNonTextureProperties, resultMaterialTextureBlender));
					if (mB_TexSet != null)
					{
						setOfTexs = mB_TexSet;
					}
					else
					{
						distinctMaterialTextures.Add(setOfTexs);
					}
					if (!setOfTexs.matsAndGOs.mats.Contains(item))
					{
						setOfTexs.matsAndGOs.mats.Add(item);
					}
					if (!setOfTexs.matsAndGOs.gos.Contains(gameObject))
					{
						setOfTexs.matsAndGOs.gos.Add(gameObject);
						if (!usedObjsToMesh.Contains(gameObject))
						{
							usedObjsToMesh.Add(gameObject);
						}
					}
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Step1_CollectDistinctTextures collected {distinctMaterialTextures.Count} sets of textures fixOutOfBoundsUV={_fixOutOfBoundsUVs} considerNonTextureProperties={_considerNonTextureProperties}");
			}
			if (distinctMaterialTextures.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the source object materials matched any of the allowed materials for this submesh.");
				result.success = false;
				yield break;
			}
			MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(distinctMaterialTextures, fixOutOfBoundsUVs);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step1_CollectDistinctTextures " + stopwatch.ElapsedMilliseconds.ToString("f5"));
			}
		}

		private IEnumerator __Step2_CalculateIdealSizesForTexturesInAtlasAndPadding(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, MB2_EditorMethodsInterface textureEditorMethods)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			for (int i = 0; i < texPropertyNames.Count; i++)
			{
				bool flag = true;
				bool flag2 = true;
				for (int j = 0; j < distinctMaterialTextures.Count; j++)
				{
					if (distinctMaterialTextures[j].ts[i].t != null)
					{
						flag = false;
						break;
					}
					if (!_considerNonTextureProperties)
					{
						continue;
					}
					for (int k = j + 1; k < distinctMaterialTextures.Count; k++)
					{
						UnityEngine.Color colorIfNoTexture = resultMaterialTextureBlender.GetColorIfNoTexture(distinctMaterialTextures[j].matsAndGOs.mats[0].mat, texPropertyNames[i]);
						UnityEngine.Color colorIfNoTexture2 = resultMaterialTextureBlender.GetColorIfNoTexture(distinctMaterialTextures[k].matsAndGOs.mats[0].mat, texPropertyNames[i]);
						if (colorIfNoTexture != colorIfNoTexture2)
						{
							flag2 = false;
							break;
						}
					}
				}
				allTexturesAreNullAndSameColor[i] = flag && flag2;
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"AllTexturesAreNullAndSameColor prop: {texPropertyNames[i].name} val:{allTexturesAreNullAndSameColor[i]}");
				}
			}
			int num = _atlasPadding;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log("All objects use the same textures in this set of atlases. Original textures will be reused instead of creating atlases.");
				}
				num = 0;
			}
			else
			{
				if (allTexturesAreNullAndSameColor.Length != texPropertyNames.Count)
				{
					UnityEngine.Debug.LogError("allTexturesAreNullAndSameColor array must be the same length of texPropertyNames.");
				}
				for (int l = 0; l < distinctMaterialTextures.Count; l++)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Calculating ideal sizes for texSet TexSet " + l + " of " + distinctMaterialTextures.Count);
					}
					MB_TexSet mB_TexSet = distinctMaterialTextures[l];
					mB_TexSet.idealWidth = 1;
					mB_TexSet.idealHeight = 1;
					int num2 = 1;
					int num3 = 1;
					if (mB_TexSet.ts.Length != texPropertyNames.Count)
					{
						UnityEngine.Debug.LogError("length of arrays in each element of distinctMaterialTextures must be texPropertyNames.Count");
					}
					for (int m = 0; m < texPropertyNames.Count; m++)
					{
						MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[m];
						if (!meshBakerMaterialTexture.matTilingRect.size.Equals(Vector2.one) && distinctMaterialTextures.Count > 1 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.t, "is tiled by ", meshBakerMaterialTexture.matTilingRect.size, " tiling will be baked into a texture with maxSize:", _maxTilingBakeSize));
						}
						if (!mB_TexSet.obUVscale.Equals(Vector2.one) && distinctMaterialTextures.Count > 1 && _fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.t, "has out of bounds UVs that effectively tile by ", mB_TexSet.obUVscale, " tiling will be baked into a texture with maxSize:", _maxTilingBakeSize));
						}
						if (!allTexturesAreNullAndSameColor[m] && meshBakerMaterialTexture.t == null)
						{
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								UnityEngine.Debug.Log("No source texture creating a 16x16 texture.");
							}
							meshBakerMaterialTexture.t = _createTemporaryTexture(16, 16, TextureFormat.ARGB32, mipMaps: true);
							if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
							{
								UnityEngine.Color colorIfNoTexture3 = resultMaterialTextureBlender.GetColorIfNoTexture(mB_TexSet.matsAndGOs.mats[0].mat, texPropertyNames[m]);
								if (LOG_LEVEL >= MB2_LogLevel.trace)
								{
									UnityEngine.Debug.Log("Setting texture to solid color " + colorIfNoTexture3);
								}
								MB_Utility.setSolidColor(meshBakerMaterialTexture.t, colorIfNoTexture3);
							}
							else
							{
								UnityEngine.Color colorIfNoTexture4 = GetColorIfNoTexture(texPropertyNames[m]);
								MB_Utility.setSolidColor(meshBakerMaterialTexture.t, colorIfNoTexture4);
							}
							if (fixOutOfBoundsUVs)
							{
								meshBakerMaterialTexture.encapsulatingSamplingRect = mB_TexSet.obUVrect;
							}
							else
							{
								meshBakerMaterialTexture.encapsulatingSamplingRect = new DRect(0f, 0f, 1f, 1f);
							}
						}
						if (!(meshBakerMaterialTexture.t != null))
						{
							continue;
						}
						Vector2 adjustedForScaleAndOffset2Dimensions = GetAdjustedForScaleAndOffset2Dimensions(meshBakerMaterialTexture, mB_TexSet.obUVoffset, mB_TexSet.obUVscale);
						if ((int)(adjustedForScaleAndOffset2Dimensions.x * adjustedForScaleAndOffset2Dimensions.y) > num2 * num3)
						{
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								UnityEngine.Debug.Log(string.Concat("    matTex ", meshBakerMaterialTexture.t, " ", adjustedForScaleAndOffset2Dimensions, " has a bigger size than ", num2, " ", num3));
							}
							num2 = (int)adjustedForScaleAndOffset2Dimensions.x;
							num3 = (int)adjustedForScaleAndOffset2Dimensions.y;
						}
					}
					if (_resizePowerOfTwoTextures)
					{
						if (num2 <= num * 5)
						{
							UnityEngine.Debug.LogWarning(string.Format("Some of the textures have widths close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with widths this small.", mB_TexSet.ToString()));
						}
						if (num3 <= num * 5)
						{
							UnityEngine.Debug.LogWarning(string.Format("Some of the textures have heights close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with heights this small.", mB_TexSet.ToString()));
						}
						if (IsPowerOfTwo(num2))
						{
							num2 -= num * 2;
						}
						if (IsPowerOfTwo(num3))
						{
							num3 -= num * 2;
						}
						if (num2 < 1)
						{
							num2 = 1;
						}
						if (num3 < 1)
						{
							num3 = 1;
						}
					}
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("    Ideal size is " + num2 + " " + num3);
					}
					mB_TexSet.idealWidth = num2;
					mB_TexSet.idealHeight = num3;
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step2 Calculate Ideal Sizes part1: " + stopwatch.Elapsed.ToString());
			}
			if (distinctMaterialTextures.Count > 1 && _packingAlgorithm != MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast)
			{
				for (int n = 0; n < distinctMaterialTextures.Count; n++)
				{
					for (int num4 = 0; num4 < texPropertyNames.Count; num4++)
					{
						Texture2D t = distinctMaterialTextures[n].ts[num4].t;
						if (t != null && textureEditorMethods != null)
						{
							progressInfo?.Invoke($"Convert texture {t} to readable format ", 0.5f);
							textureEditorMethods.AddTextureFormat(t, texPropertyNames[num4].isNormalMap);
						}
					}
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step2 Calculate Ideal Sizes part2: " + stopwatch.Elapsed.ToString());
			}
			__step2_CalculateIdealSizesForTexturesInAtlasAndPadding = num;
			yield break;
		}

		private AtlasPackingResult[] __Step3_RunTexturePacker(List<MB_TexSet> distinctMaterialTextures, int _padding)
		{
			AtlasPackingResult[] array = __RuntTexturePackerOnly(distinctMaterialTextures, _padding);
			for (int i = 0; i < array.Length; i++)
			{
				List<MatsAndGOs> list = new List<MatsAndGOs>();
				array[i].data = list;
				for (int j = 0; j < array[i].srcImgIdxs.Length; j++)
				{
					MB_TexSet mB_TexSet = distinctMaterialTextures[array[i].srcImgIdxs[j]];
					list.Add(mB_TexSet.matsAndGOs);
				}
			}
			return array;
		}

		private IEnumerator __Step3_BuildAndSaveAtlasesAndStoreResults(CombineTexturesIntoAtlasesCoroutineResult result, ProgressUpdateDelegate progressInfo, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, int _padding, MB2_EditorMethodsInterface textureEditorMethods, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			int numAtlases = texPropertyNames.Count;
			StringBuilder report = new StringBuilder();
			if (numAtlases > 0)
			{
				report = new StringBuilder();
				report.AppendLine("Report");
				for (int i = 0; i < distinctMaterialTextures.Count; i++)
				{
					MB_TexSet mB_TexSet = distinctMaterialTextures[i];
					report.AppendLine("----------");
					report.Append("This set of textures will be resized to:" + mB_TexSet.idealWidth + "x" + mB_TexSet.idealHeight + "\n");
					for (int j = 0; j < mB_TexSet.ts.Length; j++)
					{
						if (mB_TexSet.ts[j].t != null)
						{
							report.Append("   [" + texPropertyNames[j].name + " " + mB_TexSet.ts[j].t.name + " " + mB_TexSet.ts[j].t.width + "x" + mB_TexSet.ts[j].t.height + "]");
							if (mB_TexSet.ts[j].matTilingRect.size != Vector2.one || mB_TexSet.ts[j].matTilingRect.min != Vector2.zero)
							{
								report.AppendFormat(" material scale {0} offset{1} ", mB_TexSet.ts[j].matTilingRect.size.ToString("G4"), mB_TexSet.ts[j].matTilingRect.min.ToString("G4"));
							}
							if (mB_TexSet.obUVscale != Vector2.one || mB_TexSet.obUVoffset != Vector2.zero)
							{
								report.AppendFormat(" obUV scale {0} offset{1} ", mB_TexSet.obUVscale.ToString("G4"), mB_TexSet.obUVoffset.ToString("G4"));
							}
							report.AppendLine(string.Empty);
						}
						else
						{
							report.Append("   [" + texPropertyNames[j].name + " null ");
							if (allTexturesAreNullAndSameColor[j])
							{
								report.Append("no atlas will be created all textures null]\n");
							}
							else
							{
								report.AppendFormat("a 16x16 texture will be created]\n");
							}
						}
					}
					report.AppendLine(string.Empty);
					report.Append("Materials using:");
					for (int k = 0; k < mB_TexSet.matsAndGOs.mats.Count; k++)
					{
						report.Append(mB_TexSet.matsAndGOs.mats[k].mat.name + ", ");
					}
					report.AppendLine(string.Empty);
				}
			}
			GC.Collect();
			Texture2D[] atlases = new Texture2D[numAtlases];
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("time Step 3 Create And Save Atlases part 1 " + sw.Elapsed.ToString());
			}
			Rect[] rectsInAtlas;
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.UnitysPackTextures)
			{
				rectsInAtlas = __CreateAtlasesUnityTexturePacker(progressInfo, numAtlases, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, resultMaterial, atlases, textureEditorMethods, _padding);
			}
			else if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker)
			{
				yield return __CreateAtlasesMBTexturePacker(progressInfo, numAtlases, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, resultMaterial, atlases, textureEditorMethods, _padding);
				rectsInAtlas = __createAtlasesMBTexturePacker;
			}
			else
			{
				rectsInAtlas = __CreateAtlasesMBTexturePackerFast(progressInfo, numAtlases, distinctMaterialTextures, texPropertyNames, allTexturesAreNullAndSameColor, resultMaterial, atlases, textureEditorMethods, _padding);
			}
			float t3 = sw.ElapsedMilliseconds;
			AdjustNonTextureProperties(resultMaterial, texPropertyNames, distinctMaterialTextures, _considerNonTextureProperties, textureEditorMethods);
			progressInfo?.Invoke("Building Report", 0.7f);
			StringBuilder atlasMessage = new StringBuilder();
			atlasMessage.AppendLine("---- Atlases ------");
			for (int l = 0; l < numAtlases; l++)
			{
				if (atlases[l] != null)
				{
					atlasMessage.AppendLine("Created Atlas For: " + texPropertyNames[l].name + " h=" + atlases[l].height + " w=" + atlases[l].width);
				}
				else if (allTexturesAreNullAndSameColor[l])
				{
					atlasMessage.AppendLine("Did not create atlas for " + texPropertyNames[l].name + " because all source textures were null.");
				}
			}
			report.Append(atlasMessage.ToString());
			List<MB_MaterialAndUVRect> mat2rect_map = new List<MB_MaterialAndUVRect>();
			for (int m = 0; m < distinctMaterialTextures.Count; m++)
			{
				List<MatAndTransformToMerged> mats = distinctMaterialTextures[m].matsAndGOs.mats;
				Rect samplingEncapsulatinRect = new Rect(0f, 0f, 1f, 1f);
				if (distinctMaterialTextures[m].ts.Length > 0)
				{
					samplingEncapsulatinRect = ((!distinctMaterialTextures[m].allTexturesUseSameMatTiling) ? distinctMaterialTextures[m].obUVrect.GetRect() : distinctMaterialTextures[m].ts[0].encapsulatingSamplingRect.GetRect());
				}
				for (int n = 0; n < mats.Count; n++)
				{
					MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(mats[n].mat, rectsInAtlas[m], mats[n].samplingRectMatAndUVTiling.GetRect(), mats[n].materialTiling.GetRect(), samplingEncapsulatinRect, mats[n].objName);
					if (!mat2rect_map.Contains(item))
					{
						mat2rect_map.Add(item);
					}
				}
			}
			resultAtlasesAndRects.atlases = atlases;
			resultAtlasesAndRects.texPropertyNames = ShaderTextureProperty.GetNames(texPropertyNames);
			resultAtlasesAndRects.mat2rect_map = mat2rect_map;
			progressInfo?.Invoke("Restoring Texture Formats & Read Flags", 0.8f);
			_destroyTemporaryTextures();
			textureEditorMethods?.RestoreReadFlagsAndFormats(progressInfo);
			if (report != null && LOG_LEVEL >= MB2_LogLevel.info)
			{
				UnityEngine.Debug.Log(report.ToString());
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Time Step 3 Create And Save Atlases part 3 " + ((float)sw.ElapsedMilliseconds - t3).ToString("f5"));
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step 3 Create And Save Atlases " + sw.Elapsed.ToString());
			}
		}

		private AtlasPackingResult[] __RuntTexturePackerOnly(List<MB_TexSet> distinctMaterialTextures, int _padding)
		{
			AtlasPackingResult[] array;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
				}
				array = new AtlasPackingResult[1]
				{
					new AtlasPackingResult()
				};
				array[0].rects = new Rect[1];
				array[0].srcImgIdxs = new int[1];
				ref Rect reference = ref array[0].rects[0];
				reference = new Rect(0f, 0f, 1f, 1f);
				Texture2D texture2D = null;
				MeshBakerMaterialTexture meshBakerMaterialTexture = null;
				if (distinctMaterialTextures[0].ts.Length > 0)
				{
					meshBakerMaterialTexture = distinctMaterialTextures[0].ts[0];
					texture2D = meshBakerMaterialTexture.t;
				}
				array[0].atlasX = ((!(texture2D == null)) ? meshBakerMaterialTexture.t.width : 16);
				array[0].atlasY = ((!(texture2D == null)) ? meshBakerMaterialTexture.t.height : 16);
				array[0].usedW = ((!(texture2D == null)) ? meshBakerMaterialTexture.t.width : 16);
				array[0].usedH = ((!(texture2D == null)) ? meshBakerMaterialTexture.t.height : 16);
			}
			else
			{
				List<Vector2> list = new List<Vector2>();
				for (int i = 0; i < distinctMaterialTextures.Count; i++)
				{
					list.Add(new Vector2(distinctMaterialTextures[i].idealWidth, distinctMaterialTextures[i].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = new MB2_TexturePacker();
				mB2_TexturePacker.doPowerOfTwoTextures = _meshBakerTexturePackerForcePowerOfTwo;
				array = mB2_TexturePacker.GetRects(list, _maxAtlasSize, _padding, doMultiAtlas: true);
			}
			return array;
		}

		private IEnumerator __CreateAtlasesMBTexturePacker(ProgressUpdateDelegate progressInfo, int numAtlases, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, Material resultMaterial, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, int _padding)
		{
			Rect[] uvRects;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
				}
				uvRects = new Rect[1]
				{
					new Rect(0f, 0f, 1f, 1f)
				};
				for (int i = 0; i < numAtlases; i++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = distinctMaterialTextures[0].ts[i];
					atlases[i] = meshBakerMaterialTexture.t;
					resultMaterial.SetTexture(texPropertyNames[i].name, atlases[i]);
					resultMaterial.SetTextureScale(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.size);
					resultMaterial.SetTextureOffset(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.min);
				}
			}
			else
			{
				List<Vector2> imageSizes = new List<Vector2>();
				for (int j = 0; j < distinctMaterialTextures.Count; j++)
				{
					imageSizes.Add(new Vector2(distinctMaterialTextures[j].idealWidth, distinctMaterialTextures[j].idealHeight));
				}
				MB2_TexturePacker tp = new MB2_TexturePacker
				{
					doPowerOfTwoTextures = _meshBakerTexturePackerForcePowerOfTwo
				};
				int atlasSizeX2 = 1;
				int atlasSizeY2 = 1;
				int atlasMaxDimension = _maxAtlasSize;
				AtlasPackingResult[] packerRects = tp.GetRects(imageSizes, atlasMaxDimension, _padding);
				atlasSizeX2 = packerRects[0].atlasX;
				atlasSizeY2 = packerRects[0].atlasY;
				uvRects = packerRects[0].rects;
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Generated atlas will be " + atlasSizeX2 + "x" + atlasSizeY2 + " (Max atlas size for platform: " + atlasMaxDimension + ")");
				}
				for (int propIdx = 0; propIdx < numAtlases; propIdx++)
				{
					Texture2D atlas2 = null;
					if (allTexturesAreNullAndSameColor[propIdx])
					{
						atlas2 = null;
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("=== Not creating atlas for " + texPropertyNames[propIdx].name + " because textures are null and default value parameters are the same.");
						}
					}
					else
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("=== Creating atlas for " + texPropertyNames[propIdx].name);
						}
						GC.Collect();
						UnityEngine.Color[][] atlasPixels = new UnityEngine.Color[atlasSizeY2][];
						for (int k = 0; k < atlasPixels.Length; k++)
						{
							atlasPixels[k] = new UnityEngine.Color[atlasSizeX2];
						}
						bool isNormalMap = false;
						if (texPropertyNames[propIdx].isNormalMap)
						{
							isNormalMap = true;
						}
						for (int texSetIdx = 0; texSetIdx < distinctMaterialTextures.Count; texSetIdx++)
						{
							string s = "Creating Atlas '" + texPropertyNames[propIdx].name + "' texture " + distinctMaterialTextures[texSetIdx];
							progressInfo?.Invoke(s, 0.01f);
							MB_TexSet texSet = distinctMaterialTextures[texSetIdx];
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								UnityEngine.Debug.Log(string.Format("Adding texture {0} to atlas {1}", (!(texSet.ts[propIdx].t == null)) ? texSet.ts[propIdx].t.ToString() : "null", texPropertyNames[propIdx]));
							}
							Rect r = uvRects[texSetIdx];
							Texture2D t = texSet.ts[propIdx].t;
							int x = Mathf.RoundToInt(r.x * (float)atlasSizeX2);
							int y = Mathf.RoundToInt(r.y * (float)atlasSizeY2);
							int ww = Mathf.RoundToInt(r.width * (float)atlasSizeX2);
							int hh = Mathf.RoundToInt(r.height * (float)atlasSizeY2);
							if (ww == 0 || hh == 0)
							{
								UnityEngine.Debug.LogError("Image in atlas has no height or width");
							}
							progressInfo?.Invoke(s + " set ReadWrite flag", 0.01f);
							textureEditorMethods?.SetReadWriteFlag(t, isReadable: true, addToList: true);
							progressInfo?.Invoke(string.Concat(s, "Copying to atlas: '", texSet.ts[propIdx].t, "'"), 0.02f);
							yield return CopyScaledAndTiledToAtlas(srcSamplingRect: texSet.ts[propIdx].encapsulatingSamplingRect, source: texSet.ts[propIdx], sourceMaterial: texSet, shaderPropertyName: texPropertyNames[propIdx], targX: x, targY: y, targW: ww, targH: hh, _fixOutOfBoundsUVs: _fixOutOfBoundsUVs, maxSize: _maxTilingBakeSize, atlasPixels: atlasPixels, atlasWidth: atlasSizeX2, isNormalMap: isNormalMap, progressInfo: progressInfo);
						}
						yield return numAtlases;
						progressInfo?.Invoke("Applying changes to atlas: '" + texPropertyNames[propIdx].name + "'", 0.03f);
						atlas2 = new Texture2D(atlasSizeX2, atlasSizeY2, TextureFormat.ARGB32, mipmap: true);
						for (int l = 0; l < atlasPixels.Length; l++)
						{
							atlas2.SetPixels(0, l, atlasSizeX2, 1, atlasPixels[l]);
						}
						atlas2.Apply();
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Saving atlas " + texPropertyNames[propIdx].name + " w=" + atlas2.width + " h=" + atlas2.height);
						}
					}
					atlases[propIdx] = atlas2;
					progressInfo?.Invoke("Saving atlas: '" + texPropertyNames[propIdx].name + "'", 0.04f);
					if (_saveAtlasesAsAssets && textureEditorMethods != null)
					{
						textureEditorMethods.SaveAtlasToAssetDatabase(atlases[propIdx], texPropertyNames[propIdx], propIdx, resultMaterial);
					}
					else
					{
						resultMaterial.SetTexture(texPropertyNames[propIdx].name, atlases[propIdx]);
					}
					resultMaterial.SetTextureOffset(texPropertyNames[propIdx].name, Vector2.zero);
					resultMaterial.SetTextureScale(texPropertyNames[propIdx].name, Vector2.one);
					_destroyTemporaryTextures();
				}
			}
			__createAtlasesMBTexturePacker = uvRects;
		}

		private Rect[] __CreateAtlasesMBTexturePackerFast(ProgressUpdateDelegate progressInfo, int numAtlases, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, Material resultMaterial, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, int _padding)
		{
			Rect[] array;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
				}
				array = new Rect[1]
				{
					new Rect(0f, 0f, 1f, 1f)
				};
				for (int i = 0; i < numAtlases; i++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = distinctMaterialTextures[0].ts[i];
					atlases[i] = meshBakerMaterialTexture.t;
					resultMaterial.SetTexture(texPropertyNames[i].name, atlases[i]);
					resultMaterial.SetTextureScale(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.size);
					resultMaterial.SetTextureOffset(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.min);
				}
			}
			else
			{
				List<Vector2> list = new List<Vector2>();
				for (int j = 0; j < distinctMaterialTextures.Count; j++)
				{
					list.Add(new Vector2(distinctMaterialTextures[j].idealWidth, distinctMaterialTextures[j].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = new MB2_TexturePacker();
				mB2_TexturePacker.doPowerOfTwoTextures = _meshBakerTexturePackerForcePowerOfTwo;
				int num = 1;
				int num2 = 1;
				int num3 = _maxAtlasSize;
				AtlasPackingResult[] rects = mB2_TexturePacker.GetRects(list, num3, _padding);
				num = rects[0].atlasX;
				num2 = rects[0].atlasY;
				array = rects[0].rects;
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Generated atlas will be " + num + "x" + num2 + " (Max atlas size for platform: " + num3 + ")");
				}
				GameObject gameObject = null;
				try
				{
					gameObject = new GameObject("MBrenderAtlasesGO");
					MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = gameObject.AddComponent<MB3_AtlasPackerRenderTexture>();
					gameObject.AddComponent<Camera>();
					if (_considerNonTextureProperties && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Blend Non-Texture Properties has limited functionality when used with Mesh Baker Texture Packer Fast.");
					}
					for (int k = 0; k < numAtlases; k++)
					{
						Texture2D texture2D = null;
						if (allTexturesAreNullAndSameColor[k])
						{
							texture2D = null;
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.Log("Not creating atlas for " + texPropertyNames[k].name + " because textures are null and default value parameters are the same.");
							}
						}
						else
						{
							GC.Collect();
							progressInfo?.Invoke("Creating Atlas '" + texPropertyNames[k].name + "'", 0.01f);
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.Log("About to render " + texPropertyNames[k].name + " isNormal=" + texPropertyNames[k].isNormalMap);
							}
							mB3_AtlasPackerRenderTexture.LOG_LEVEL = LOG_LEVEL;
							mB3_AtlasPackerRenderTexture.width = num;
							mB3_AtlasPackerRenderTexture.height = num2;
							mB3_AtlasPackerRenderTexture.padding = _padding;
							mB3_AtlasPackerRenderTexture.rects = array;
							mB3_AtlasPackerRenderTexture.textureSets = distinctMaterialTextures;
							mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = k;
							mB3_AtlasPackerRenderTexture.texPropertyName = texPropertyNames[k];
							mB3_AtlasPackerRenderTexture.isNormalMap = texPropertyNames[k].isNormalMap;
							mB3_AtlasPackerRenderTexture.fixOutOfBoundsUVs = _fixOutOfBoundsUVs;
							mB3_AtlasPackerRenderTexture.considerNonTextureProperties = _considerNonTextureProperties;
							mB3_AtlasPackerRenderTexture.resultMaterialTextureBlender = resultMaterialTextureBlender;
							texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(this);
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.Log("Saving atlas " + texPropertyNames[k].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
							}
						}
						atlases[k] = texture2D;
						progressInfo?.Invoke("Saving atlas: '" + texPropertyNames[k].name + "'", 0.04f);
						if (_saveAtlasesAsAssets && textureEditorMethods != null)
						{
							textureEditorMethods.SaveAtlasToAssetDatabase(atlases[k], texPropertyNames[k], k, resultMaterial);
						}
						else
						{
							resultMaterial.SetTexture(texPropertyNames[k].name, atlases[k]);
						}
						resultMaterial.SetTextureOffset(texPropertyNames[k].name, Vector2.zero);
						resultMaterial.SetTextureScale(texPropertyNames[k].name, Vector2.one);
						_destroyTemporaryTextures();
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				finally
				{
					if (gameObject != null)
					{
						MB_Utility.Destroy(gameObject);
					}
				}
			}
			return array;
		}

		private Rect[] __CreateAtlasesUnityTexturePacker(ProgressUpdateDelegate progressInfo, int numAtlases, List<MB_TexSet> distinctMaterialTextures, List<ShaderTextureProperty> texPropertyNames, bool[] allTexturesAreNullAndSameColor, Material resultMaterial, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, int _padding)
		{
			Rect[] array;
			if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
				}
				array = new Rect[1]
				{
					new Rect(0f, 0f, 1f, 1f)
				};
				for (int i = 0; i < numAtlases; i++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = distinctMaterialTextures[0].ts[i];
					atlases[i] = meshBakerMaterialTexture.t;
					resultMaterial.SetTexture(texPropertyNames[i].name, atlases[i]);
					resultMaterial.SetTextureScale(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.size);
					resultMaterial.SetTextureOffset(texPropertyNames[i].name, meshBakerMaterialTexture.matTilingRect.min);
				}
			}
			else
			{
				long num = 0L;
				int w = 1;
				int h = 1;
				array = null;
				for (int j = 0; j < numAtlases; j++)
				{
					Texture2D texture2D = null;
					if (allTexturesAreNullAndSameColor[j])
					{
						texture2D = null;
					}
					else
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.LogWarning("Beginning loop " + j + " num temporary textures " + _temporaryTextures.Count);
						}
						for (int k = 0; k < distinctMaterialTextures.Count; k++)
						{
							MB_TexSet mB_TexSet = distinctMaterialTextures[k];
							int idealWidth = mB_TexSet.idealWidth;
							int idealHeight = mB_TexSet.idealHeight;
							Texture2D texture2D2 = mB_TexSet.ts[j].t;
							if (texture2D2 == null)
							{
								texture2D2 = (mB_TexSet.ts[j].t = _createTemporaryTexture(idealWidth, idealHeight, TextureFormat.ARGB32, mipMaps: true));
								if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
								{
									UnityEngine.Color colorIfNoTexture = resultMaterialTextureBlender.GetColorIfNoTexture(mB_TexSet.matsAndGOs.mats[0].mat, texPropertyNames[j]);
									if (LOG_LEVEL >= MB2_LogLevel.trace)
									{
										UnityEngine.Debug.Log("Setting texture to solid color " + colorIfNoTexture);
									}
									MB_Utility.setSolidColor(texture2D2, colorIfNoTexture);
								}
								else
								{
									UnityEngine.Color colorIfNoTexture2 = GetColorIfNoTexture(texPropertyNames[j]);
									MB_Utility.setSolidColor(texture2D2, colorIfNoTexture2);
								}
							}
							progressInfo?.Invoke("Adjusting for scale and offset " + texture2D2, 0.01f);
							textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
							texture2D2 = GetAdjustedForScaleAndOffset2(mB_TexSet.ts[j], mB_TexSet.obUVoffset, mB_TexSet.obUVscale);
							if (texture2D2.width != idealWidth || texture2D2.height != idealHeight)
							{
								progressInfo?.Invoke(string.Concat("Resizing texture '", texture2D2, "'"), 0.01f);
								if (LOG_LEVEL >= MB2_LogLevel.debug)
								{
									UnityEngine.Debug.LogWarning("Copying and resizing texture " + texPropertyNames[j].name + " from " + texture2D2.width + "x" + texture2D2.height + " to " + idealWidth + "x" + idealHeight);
								}
								texture2D2 = _resizeTexture(texture2D2, idealWidth, idealHeight);
							}
							mB_TexSet.ts[j].t = texture2D2;
						}
						Texture2D[] array2 = new Texture2D[distinctMaterialTextures.Count];
						for (int l = 0; l < distinctMaterialTextures.Count; l++)
						{
							Texture2D texture2D3 = distinctMaterialTextures[l].ts[j].t;
							num += texture2D3.width * texture2D3.height;
							if (_considerNonTextureProperties)
							{
								texture2D3 = TintTextureWithTextureCombiner(texture2D3, distinctMaterialTextures[l], texPropertyNames[j]);
							}
							array2[l] = texture2D3;
						}
						textureEditorMethods?.CheckBuildSettings(num);
						if (Math.Sqrt(num) > 3500.0 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("The maximum possible atlas size is 4096. Textures may be shrunk");
						}
						texture2D = new Texture2D(1, 1, TextureFormat.ARGB32, mipmap: true);
						progressInfo?.Invoke("Packing texture atlas " + texPropertyNames[j].name, 0.25f);
						if (j == 0)
						{
							progressInfo?.Invoke("Estimated min size of atlases: " + Math.Sqrt(num).ToString("F0"), 0.1f);
							if (LOG_LEVEL >= MB2_LogLevel.info)
							{
								UnityEngine.Debug.Log("Estimated atlas minimum size:" + Math.Sqrt(num).ToString("F0"));
							}
							_addWatermark(array2);
							if (distinctMaterialTextures.Count == 1 && !_fixOutOfBoundsUVs)
							{
								array = new Rect[1]
								{
									new Rect(0f, 0f, 1f, 1f)
								};
								texture2D = _copyTexturesIntoAtlas(array2, _padding, array, array2[0].width, array2[0].height);
							}
							else
							{
								int maximumAtlasSize = 4096;
								array = texture2D.PackTextures(array2, _padding, maximumAtlasSize, makeNoLongerReadable: false);
							}
							if (LOG_LEVEL >= MB2_LogLevel.info)
							{
								UnityEngine.Debug.Log("After pack textures atlas size " + texture2D.width + " " + texture2D.height);
							}
							w = texture2D.width;
							h = texture2D.height;
							texture2D.Apply();
						}
						else
						{
							progressInfo?.Invoke("Copying Textures Into: " + texPropertyNames[j].name, 0.1f);
							texture2D = _copyTexturesIntoAtlas(array2, _padding, array, w, h);
						}
					}
					atlases[j] = texture2D;
					if (_saveAtlasesAsAssets)
					{
						textureEditorMethods?.SaveAtlasToAssetDatabase(atlases[j], texPropertyNames[j], j, resultMaterial);
					}
					resultMaterial.SetTextureOffset(texPropertyNames[j].name, Vector2.zero);
					resultMaterial.SetTextureScale(texPropertyNames[j].name, Vector2.one);
					_destroyTemporaryTextures();
					GC.Collect();
				}
			}
			return array;
		}

		private void _addWatermark(Texture2D[] texToPack)
		{
		}

		private Texture2D _addWatermark(Texture2D texToPack)
		{
			return texToPack;
		}

		private Texture2D _copyTexturesIntoAtlas(Texture2D[] texToPack, int padding, Rect[] rs, int w, int h)
		{
			Texture2D texture2D = new Texture2D(w, h, TextureFormat.ARGB32, mipmap: true);
			MB_Utility.setSolidColor(texture2D, UnityEngine.Color.clear);
			for (int i = 0; i < rs.Length; i++)
			{
				Rect rect = rs[i];
				Texture2D texture2D2 = texToPack[i];
				int x = Mathf.RoundToInt(rect.x * (float)w);
				int y = Mathf.RoundToInt(rect.y * (float)h);
				int num = Mathf.RoundToInt(rect.width * (float)w);
				int num2 = Mathf.RoundToInt(rect.height * (float)h);
				if (texture2D2.width != num && texture2D2.height != num2)
				{
					texture2D2 = MB_Utility.resampleTexture(texture2D2, num, num2);
					_temporaryTextures.Add(texture2D2);
				}
				texture2D.SetPixels(x, y, num, num2, texture2D2.GetPixels());
			}
			texture2D.Apply();
			return texture2D;
		}

		private bool IsPowerOfTwo(int x)
		{
			return (x & (x - 1)) == 0;
		}

		private void MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(List<MB_TexSet> distinctMaterialTextures, bool fixOutOfBoundsUVs)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects");
			}
			int num = 0;
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				int num2 = -1;
				bool flag = true;
				DRect dRect = default(DRect);
				for (int j = 0; j < mB_TexSet.ts.Length; j++)
				{
					if (num2 != -1)
					{
						if (mB_TexSet.ts[j].t != null && dRect != mB_TexSet.ts[j].matTilingRect)
						{
							flag = false;
						}
					}
					else if (mB_TexSet.ts[j].t != null)
					{
						num2 = j;
						dRect = mB_TexSet.ts[j].matTilingRect;
					}
				}
				if (LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS)
				{
					UnityEngine.Debug.LogFormat("TextureSet {0} allTexturesUseSameMatTiling = {1}", i, flag);
				}
				if (flag)
				{
					mB_TexSet.allTexturesUseSameMatTiling = true;
					continue;
				}
				if (LOG_LEVEL <= MB2_LogLevel.info || LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS)
				{
					UnityEngine.Debug.Log($"Textures in material(s) do not all use the same material tiling. This set of textures will not be considered for merge: {mB_TexSet.GetDescription()} ");
				}
				mB_TexSet.allTexturesUseSameMatTiling = false;
			}
			for (int k = 0; k < distinctMaterialTextures.Count; k++)
			{
				MB_TexSet mB_TexSet2 = distinctMaterialTextures[k];
				DRect obUVRectIfTilingSame = ((!fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : new DRect(mB_TexSet2.obUVoffset, mB_TexSet2.obUVscale));
				for (int l = 0; l < mB_TexSet2.matsAndGOs.mats.Count; l++)
				{
					mB_TexSet2.matsAndGOs.mats[l].obUVRectIfTilingSame = obUVRectIfTilingSame;
					mB_TexSet2.matsAndGOs.mats[l].objName = distinctMaterialTextures[k].matsAndGOs.gos[0].name;
				}
				mB_TexSet2.CalcInitialFullSamplingRects(fixOutOfBoundsUVs);
				mB_TexSet2.CalcMatAndUVSamplingRects();
			}
			List<int> list = new List<int>();
			for (int m = 0; m < distinctMaterialTextures.Count; m++)
			{
				MB_TexSet mB_TexSet3 = distinctMaterialTextures[m];
				for (int n = m + 1; n < distinctMaterialTextures.Count; n++)
				{
					MB_TexSet mB_TexSet4 = distinctMaterialTextures[n];
					if (!mB_TexSet4.AllTexturesAreSameForMerge(mB_TexSet3, _considerNonTextureProperties, resultMaterialTextureBlender))
					{
						continue;
					}
					double num3 = 0.0;
					double num4 = 0.0;
					DRect dRect2 = default(DRect);
					int num5 = -1;
					for (int num6 = 0; num6 < mB_TexSet3.ts.Length; num6++)
					{
						if (mB_TexSet3.ts[num6].t != null && num5 == -1)
						{
							num5 = num6;
						}
					}
					if (num5 != -1)
					{
						DRect uvRect = mB_TexSet4.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num7 = 1; num7 < mB_TexSet4.matsAndGOs.mats.Count; num7++)
						{
							uvRect = MB3_UVTransformUtility.GetEncapsulatingRect(ref uvRect, ref mB_TexSet4.matsAndGOs.mats[num7].samplingRectMatAndUVTiling);
						}
						DRect uvRect2 = mB_TexSet3.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num8 = 1; num8 < mB_TexSet3.matsAndGOs.mats.Count; num8++)
						{
							uvRect2 = MB3_UVTransformUtility.GetEncapsulatingRect(ref uvRect2, ref mB_TexSet3.matsAndGOs.mats[num8].samplingRectMatAndUVTiling);
						}
						dRect2 = MB3_UVTransformUtility.GetEncapsulatingRect(ref uvRect, ref uvRect2);
						num3 += dRect2.width * dRect2.height;
						num4 += uvRect.width * uvRect.height + uvRect2.width * uvRect2.height;
					}
					else
					{
						dRect2 = new DRect(0f, 0f, 1f, 1f);
					}
					if (num3 < num4)
					{
						num++;
						StringBuilder stringBuilder = null;
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							stringBuilder = new StringBuilder();
							stringBuilder.AppendFormat("About To Merge:\n   TextureSet1 {0}\n   TextureSet2 {1}\n", mB_TexSet4.GetDescription(), mB_TexSet3.GetDescription());
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								for (int num9 = 0; num9 < mB_TexSet4.matsAndGOs.mats.Count; num9++)
								{
									stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num9].mat, mB_TexSet4.matsAndGOs.mats[num9].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].encapsulatingSamplingRect);
								}
								for (int num10 = 0; num10 < mB_TexSet3.matsAndGOs.mats.Count; num10++)
								{
									stringBuilder.AppendFormat("tx2 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet3.matsAndGOs.mats[num10].mat, mB_TexSet3.matsAndGOs.mats[num10].samplingRectMatAndUVTiling, mB_TexSet3.ts[0].encapsulatingSamplingRect);
								}
							}
						}
						for (int num11 = 0; num11 < mB_TexSet3.matsAndGOs.gos.Count; num11++)
						{
							if (!mB_TexSet4.matsAndGOs.gos.Contains(mB_TexSet3.matsAndGOs.gos[num11]))
							{
								mB_TexSet4.matsAndGOs.gos.Add(mB_TexSet3.matsAndGOs.gos[num11]);
							}
						}
						for (int num12 = 0; num12 < mB_TexSet3.matsAndGOs.mats.Count; num12++)
						{
							mB_TexSet4.matsAndGOs.mats.Add(mB_TexSet3.matsAndGOs.mats[num12]);
						}
						mB_TexSet4.matsAndGOs.mats.Sort(new SamplingRectEnclosesComparer());
						for (int num13 = 0; num13 < mB_TexSet4.ts.Length; num13++)
						{
							mB_TexSet4.ts[num13].encapsulatingSamplingRect = dRect2;
						}
						if (!list.Contains(m))
						{
							list.Add(m);
						}
						if (LOG_LEVEL < MB2_LogLevel.debug)
						{
							break;
						}
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							stringBuilder.AppendFormat("=== After Merge TextureSet {0}\n", mB_TexSet4.GetDescription());
							for (int num14 = 0; num14 < mB_TexSet4.matsAndGOs.mats.Count; num14++)
							{
								stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num14].mat, mB_TexSet4.matsAndGOs.mats[num14].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].encapsulatingSamplingRect);
							}
							if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS && MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
							{
								DoIntegrityCheckMergedAtlasRects(distinctMaterialTextures);
							}
						}
						UnityEngine.Debug.Log(stringBuilder.ToString());
						break;
					}
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log($"Considered merging {mB_TexSet4.GetDescription()} and {mB_TexSet3.GetDescription()} but there was not enough overlap. It is more efficient to bake these to separate rectangles.");
					}
				}
			}
			for (int num15 = list.Count - 1; num15 >= 0; num15--)
			{
				distinctMaterialTextures.RemoveAt(list[num15]);
			}
			list.Clear();
			if (LOG_LEVEL >= MB2_LogLevel.info)
			{
				UnityEngine.Debug.Log($"MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects complete merged {num}");
			}
			if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				DoIntegrityCheckMergedAtlasRects(distinctMaterialTextures);
			}
		}

		private void DoIntegrityCheckMergedAtlasRects(List<MB_TexSet> distinctMaterialTextures)
		{
			if (!MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				if (!mB_TexSet.allTexturesUseSameMatTiling)
				{
					continue;
				}
				for (int j = 0; j < mB_TexSet.matsAndGOs.mats.Count; j++)
				{
					MatAndTransformToMerged matAndTransformToMerged = mB_TexSet.matsAndGOs.mats[j];
					DRect obUVRectIfTilingSame = matAndTransformToMerged.obUVRectIfTilingSame;
					DRect materialTiling = matAndTransformToMerged.materialTiling;
					if (!MB2_TextureBakeResults.IsMeshAndMaterialRectEnclosedByAtlasRect(obUVRectIfTilingSame.GetRect(), materialTiling.GetRect(), mB_TexSet.ts[0].encapsulatingSamplingRect.GetRect(), LOG_LEVEL))
					{
						UnityEngine.Debug.LogErrorFormat(string.Concat("mesh ", mB_TexSet.matsAndGOs.mats[j].objName, "\n uv=", obUVRectIfTilingSame, "\n mat=", materialTiling.GetRect().ToString("f5"), "\n samplingRect=", mB_TexSet.matsAndGOs.mats[j].samplingRectMatAndUVTiling.GetRect().ToString("f4"), "\n encapsulatingRect ", mB_TexSet.ts[0].encapsulatingSamplingRect.GetRect().ToString("f4"), "\n"));
						UnityEngine.Debug.LogErrorFormat(string.Format("Integrity check failed. " + mB_TexSet.matsAndGOs.mats[j].objName + " Encapsulating sampling rect failed to contain potentialRect\n"));
					}
				}
			}
		}

		private Vector2 GetAdjustedForScaleAndOffset2Dimensions(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale)
		{
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!_fixOutOfBoundsUVs)
				{
					return new Vector2(source.t.width, source.t.height);
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return new Vector2(source.t.width, source.t.height);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log(string.Concat("GetAdjustedForScaleAndOffset2Dimensions: ", source.t, " ", obUVoffset, " ", obUVscale));
			}
			float num = (float)source.encapsulatingSamplingRect.width * (float)source.t.width;
			float num2 = (float)source.encapsulatingSamplingRect.height * (float)source.t.height;
			if (num > (float)_maxTilingBakeSize)
			{
				num = _maxTilingBakeSize;
			}
			if (num2 > (float)_maxTilingBakeSize)
			{
				num2 = _maxTilingBakeSize;
			}
			if (num < 1f)
			{
				num = 1f;
			}
			if (num2 < 1f)
			{
				num2 = 1f;
			}
			return new Vector2(num, num2);
		}

		public Texture2D GetAdjustedForScaleAndOffset2(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale)
		{
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!_fixOutOfBoundsUVs)
				{
					return source.t;
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return source.t;
				}
			}
			Vector2 adjustedForScaleAndOffset2Dimensions = GetAdjustedForScaleAndOffset2Dimensions(source, obUVoffset, obUVscale);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.LogWarning(string.Concat("GetAdjustedForScaleAndOffset2: ", source.t, " ", obUVoffset, " ", obUVscale));
			}
			float x = adjustedForScaleAndOffset2Dimensions.x;
			float y = adjustedForScaleAndOffset2Dimensions.y;
			float num = (float)source.matTilingRect.width;
			float num2 = (float)source.matTilingRect.height;
			float num3 = (float)source.matTilingRect.x;
			float num4 = (float)source.matTilingRect.y;
			if (_fixOutOfBoundsUVs)
			{
				num *= obUVscale.x;
				num2 *= obUVscale.y;
				num3 = (float)(source.matTilingRect.x * (double)obUVscale.x + (double)obUVoffset.x);
				num4 = (float)(source.matTilingRect.y * (double)obUVscale.y + (double)obUVoffset.y);
			}
			Texture2D texture2D = _createTemporaryTexture((int)x, (int)y, TextureFormat.ARGB32, mipMaps: true);
			for (int i = 0; i < texture2D.width; i++)
			{
				for (int j = 0; j < texture2D.height; j++)
				{
					float u = (float)i / x * num + num3;
					float v = (float)j / y * num2 + num4;
					texture2D.SetPixel(i, j, source.t.GetPixelBilinear(u, v));
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		internal static DRect GetSourceSamplingRect(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale)
		{
			DRect r = source.matTilingRect;
			DRect r2 = new DRect(obUVoffset, obUVscale);
			return MB3_UVTransformUtility.CombineTransforms(ref r, ref r2);
		}

		private Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"Blending texture {t.name} mat {sourceMaterial.matsAndGOs.mats[0].mat} with non-texture properties using TextureBlender {resultMaterialTextureBlender}");
			}
			resultMaterialTextureBlender.OnBeforeTintTexture(sourceMaterial.matsAndGOs.mats[0].mat, shaderPropertyName.name);
			t = _createTextureCopy(t);
			for (int i = 0; i < t.height; i++)
			{
				UnityEngine.Color[] pixels = t.GetPixels(0, i, t.width, 1);
				for (int j = 0; j < pixels.Length; j++)
				{
					ref UnityEngine.Color reference = ref pixels[j];
					reference = resultMaterialTextureBlender.OnBlendTexturePixel(shaderPropertyName.name, pixels[j]);
				}
				t.SetPixels(0, i, t.width, 1, pixels);
			}
			t.Apply();
			return t;
		}

		public IEnumerator CopyScaledAndTiledToAtlas(MeshBakerMaterialTexture source, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName, DRect srcSamplingRect, int targX, int targY, int targW, int targH, bool _fixOutOfBoundsUVs, int maxSize, UnityEngine.Color[][] atlasPixels, int atlasWidth, bool isNormalMap, ProgressUpdateDelegate progressInfo = null)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log(string.Concat("CopyScaledAndTiledToAtlas: ", source.t, " inAtlasX=", targX, " inAtlasY=", targY, " inAtlasW=", targW, " inAtlasH=", targH));
			}
			float newWidth = targW;
			float newHeight = targH;
			float scx = (float)srcSamplingRect.width;
			float scy = (float)srcSamplingRect.height;
			float ox = (float)srcSamplingRect.x;
			float oy = (float)srcSamplingRect.y;
			int w = (int)newWidth;
			int h = (int)newHeight;
			Texture2D t2 = source.t;
			if (t2 == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("No source texture creating a 16x16 texture.");
				}
				t2 = _createTemporaryTexture(16, 16, TextureFormat.ARGB32, mipMaps: true);
				scx = 1f;
				scy = 1f;
				if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
				{
					UnityEngine.Color colorIfNoTexture = resultMaterialTextureBlender.GetColorIfNoTexture(sourceMaterial.matsAndGOs.mats[0].mat, shaderPropertyName);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Setting texture to solid color " + colorIfNoTexture);
					}
					MB_Utility.setSolidColor(t2, colorIfNoTexture);
				}
				else
				{
					UnityEngine.Color colorIfNoTexture2 = GetColorIfNoTexture(shaderPropertyName);
					MB_Utility.setSolidColor(t2, colorIfNoTexture2);
				}
			}
			if (_considerNonTextureProperties && resultMaterialTextureBlender != null)
			{
				t2 = TintTextureWithTextureCombiner(t2, sourceMaterial, shaderPropertyName);
			}
			t2 = _addWatermark(t2);
			for (int k = 0; k < w; k++)
			{
				if (progressInfo != null && w > 0)
				{
					progressInfo("CopyScaledAndTiledToAtlas " + ((float)k / (float)w * 100f).ToString("F0"), 0.2f);
				}
				for (int l = 0; l < h; l++)
				{
					float u = (float)k / newWidth * scx + ox;
					float v = (float)l / newHeight * scy + oy;
					ref UnityEngine.Color reference = ref atlasPixels[targY + l][targX + k];
					reference = t2.GetPixelBilinear(u, v);
				}
			}
			for (int m = 0; m < w; m++)
			{
				for (int n = 1; n <= atlasPadding; n++)
				{
					ref UnityEngine.Color reference2 = ref atlasPixels[targY - n][targX + m];
					reference2 = atlasPixels[targY][targX + m];
					ref UnityEngine.Color reference3 = ref atlasPixels[targY + h - 1 + n][targX + m];
					reference3 = atlasPixels[targY + h - 1][targX + m];
				}
			}
			for (int num = 0; num < h; num++)
			{
				for (int num2 = 1; num2 <= _atlasPadding; num2++)
				{
					ref UnityEngine.Color reference4 = ref atlasPixels[targY + num][targX - num2];
					reference4 = atlasPixels[targY + num][targX];
					ref UnityEngine.Color reference5 = ref atlasPixels[targY + num][targX + w + num2 - 1];
					reference5 = atlasPixels[targY + num][targX + w - 1];
				}
			}
			for (int i = 1; i <= _atlasPadding; i++)
			{
				for (int j = 1; j <= _atlasPadding; j++)
				{
					ref UnityEngine.Color reference6 = ref atlasPixels[targY - j][targX - i];
					reference6 = atlasPixels[targY][targX];
					ref UnityEngine.Color reference7 = ref atlasPixels[targY + h - 1 + j][targX - i];
					reference7 = atlasPixels[targY + h - 1][targX];
					ref UnityEngine.Color reference8 = ref atlasPixels[targY + h - 1 + j][targX + w + i - 1];
					reference8 = atlasPixels[targY + h - 1][targX + w - 1];
					ref UnityEngine.Color reference9 = ref atlasPixels[targY - j][targX + w + i - 1];
					reference9 = atlasPixels[targY][targX + w - 1];
					yield return null;
				}
				yield return null;
			}
		}

		public Texture2D _createTemporaryTexture(int w, int h, TextureFormat texFormat, bool mipMaps)
		{
			Texture2D texture2D = new Texture2D(w, h, texFormat, mipMaps);
			MB_Utility.setSolidColor(texture2D, UnityEngine.Color.clear);
			_temporaryTextures.Add(texture2D);
			return texture2D;
		}

		internal Texture2D _createTextureCopy(Texture2D t)
		{
			Texture2D texture2D = MB_Utility.createTextureCopy(t);
			_temporaryTextures.Add(texture2D);
			return texture2D;
		}

		private Texture2D _resizeTexture(Texture2D t, int w, int h)
		{
			Texture2D texture2D = MB_Utility.resampleTexture(t, w, h);
			_temporaryTextures.Add(texture2D);
			return texture2D;
		}

		private void _destroyTemporaryTextures()
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + _temporaryTextures.Count + " temporary textures");
			}
			for (int i = 0; i < _temporaryTextures.Count; i++)
			{
				MB_Utility.Destroy(_temporaryTextures[i]);
			}
			_temporaryTextures.Clear();
		}

		public void SuggestTreatment(List<GameObject> objsToMesh, Material[] resultMaterials, List<ShaderTextureProperty> _customShaderPropNames)
		{
			this._customShaderPropNames = _customShaderPropNames;
			StringBuilder stringBuilder = new StringBuilder();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < objsToMesh.Count; i++)
			{
				GameObject gameObject = objsToMesh[i];
				if (gameObject == null)
				{
					continue;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
				if (gOMaterials.Length > 1)
				{
					stringBuilder.AppendFormat("\nObject {0} uses {1} materials. Possible treatments:\n", objsToMesh[i].name, gOMaterials.Length);
					stringBuilder.AppendFormat("  1) Collapse the submeshes together into one submesh in the combined mesh. Each of the original submesh materials will map to a different UV rectangle in the atlas(es) used by the combined material.\n");
					stringBuilder.AppendFormat("  2) Use the multiple materials feature to map submeshes in the source mesh to submeshes in the combined mesh.\n");
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value[0]);
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						value[j].hasOverlappingSubmeshTris = value[0].hasOverlappingSubmeshTris;
						value[j].hasOverlappingSubmeshVerts = value[0].hasOverlappingSubmeshVerts;
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					if (value[k].hasOutOfBoundsUVs)
					{
						DRect dRect = new DRect(value[k].uvRect);
						stringBuilder.AppendFormat("\nObject {0} submesh={1} material={2} uses UVs outside the range 0,0 .. 1,1 to create tiling that tiles the box {3},{4} .. {5},{6}. This is a problem because the UVs outside the 0,0 .. 1,1 rectangle will pick up neighboring textures in the atlas. Possible Treatments:\n", gameObject, k, gOMaterials[k], dRect.x.ToString("G4"), dRect.y.ToString("G4"), (dRect.x + dRect.width).ToString("G4"), (dRect.y + dRect.height).ToString("G4"));
						stringBuilder.AppendFormat("    1) Ignore the problem. The tiling may not affect result significantly.\n");
						stringBuilder.AppendFormat("    2) Use the 'fix out of bounds UVs' feature to bake the tiling and scale the UVs to fit in the 0,0 .. 1,1 rectangle.\n");
						stringBuilder.AppendFormat("    3) Use the Multiple Materials feature to map the material on this submesh to its own submesh in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
						stringBuilder.AppendFormat("    4) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
					}
				}
				if (value[0].hasOverlappingSubmeshVerts)
				{
					stringBuilder.AppendFormat("\nObject {0} has submeshes that share vertices. This is a problem because each vertex can have only one UV coordinate and may be required to map to different positions in the various atlases that are generated. Possible treatments:\n", objsToMesh[i]);
					stringBuilder.AppendFormat(" 1) Ignore the problem. The vertices may not affect the result.\n");
					stringBuilder.AppendFormat(" 2) Use the Multiple Materials feature to map the submeshs that overlap to their own submeshs in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
					stringBuilder.AppendFormat(" 3) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
				}
			}
			Dictionary<Material, List<GameObject>> dictionary2 = new Dictionary<Material, List<GameObject>>();
			for (int l = 0; l < objsToMesh.Count; l++)
			{
				if (!(objsToMesh[l] != null))
				{
					continue;
				}
				Material[] gOMaterials2 = MB_Utility.GetGOMaterials(objsToMesh[l]);
				for (int m = 0; m < gOMaterials2.Length; m++)
				{
					if (gOMaterials2[m] != null)
					{
						if (!dictionary2.TryGetValue(gOMaterials2[m], out var value2))
						{
							value2 = new List<GameObject>();
							dictionary2.Add(gOMaterials2[m], value2);
						}
						if (!value2.Contains(objsToMesh[l]))
						{
							value2.Add(objsToMesh[l]);
						}
					}
				}
			}
			List<ShaderTextureProperty> list = new List<ShaderTextureProperty>();
			for (int n = 0; n < resultMaterials.Length; n++)
			{
				_CollectPropertyNames(resultMaterials[n], list);
				foreach (Material key in dictionary2.Keys)
				{
					for (int num = 0; num < list.Count; num++)
					{
						if (!key.HasProperty(list[num].name))
						{
							continue;
						}
						Texture texture = key.GetTexture(list[num].name);
						if (texture != null)
						{
							Vector2 textureOffset = key.GetTextureOffset(list[num].name);
							Vector3 vector = key.GetTextureScale(list[num].name);
							if (textureOffset.x < 0f || textureOffset.x + vector.x > 1f || textureOffset.y < 0f || textureOffset.y + vector.y > 1f)
							{
								stringBuilder.AppendFormat("\nMaterial {0} used by objects {1} uses texture {2} that is tiled (scale={3} offset={4}). If there is more than one texture in the atlas  then Mesh Baker will bake the tiling into the atlas. If the baked tiling is large then quality can be lost. Possible treatments:\n", key, PrintList(dictionary2[key]), texture, vector, textureOffset);
								stringBuilder.AppendFormat("  1) Use the baked tiling.\n");
								stringBuilder.AppendFormat("  2) Use the Multiple Materials feature to map the material on this object/submesh to its own submesh in the combined mesh. No other materials should map to this submesh. The original material can be applied to this submesh.\n");
								stringBuilder.AppendFormat("  3) Combine only meshes that use the same (or subset of) the set of textures on this mesh. The original material can be applied to the result.\n");
							}
						}
					}
				}
			}
			string empty = string.Empty;
			empty = ((stringBuilder.Length != 0) ? ("====== There are possible problems with these meshes that may prevent them from combining well. TREATMENT SUGGESTIONS (copy and paste to text editor if too big) =====\n" + stringBuilder.ToString()) : "====== No problems detected. These meshes should combine well ====\n  If there are problems with the combined meshes please report the problem to digitalOpus.ca so we can improve Mesh Baker.");
			UnityEngine.Debug.Log(empty);
		}

		private TextureBlender FindMatchingTextureBlender(string shaderName)
		{
			for (int i = 0; i < textureBlenders.Length; i++)
			{
				if (textureBlenders[i].DoesShaderNameMatch(shaderName))
				{
					return textureBlenders[i];
				}
			}
			return null;
		}

		private void AdjustNonTextureProperties(Material mat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, bool considerTintColor, MB2_EditorMethodsInterface editorMethods)
		{
			if (mat == null || texPropertyNames == null)
			{
				return;
			}
			if (_considerNonTextureProperties)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Adjusting non texture properties using TextureBlender for shader: " + mat.shader.name);
				}
				resultMaterialTextureBlender.SetNonTexturePropertyValuesOnResultMaterial(mat);
				return;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Adjusting non texture properties on result material");
			}
			for (int i = 0; i < texPropertyNames.Count; i++)
			{
				string name = texPropertyNames[i].name;
				if (name.Equals("_MainTex") && mat.HasProperty("_Color"))
				{
					try
					{
						if (considerTintColor)
						{
							mat.SetColor("_Color", UnityEngine.Color.white);
						}
					}
					catch (Exception)
					{
					}
				}
				if (name.Equals("_BumpMap") && mat.HasProperty("_BumpScale"))
				{
					try
					{
						mat.SetFloat("_BumpScale", 1f);
					}
					catch (Exception)
					{
					}
				}
				if (name.Equals("_ParallaxMap") && mat.HasProperty("_Parallax"))
				{
					try
					{
						mat.SetFloat("_Parallax", 0.02f);
					}
					catch (Exception)
					{
					}
				}
				if (name.Equals("_OcclusionMap") && mat.HasProperty("_OcclusionStrength"))
				{
					try
					{
						mat.SetFloat("_OcclusionStrength", 1f);
					}
					catch (Exception)
					{
					}
				}
				if (!name.Equals("_EmissionMap"))
				{
					continue;
				}
				if (mat.HasProperty("_EmissionColor"))
				{
					try
					{
						mat.SetColor("_EmissionColor", new UnityEngine.Color(0f, 0f, 0f, 0f));
					}
					catch (Exception)
					{
					}
				}
				if (mat.HasProperty("_EmissionScaleUI"))
				{
					try
					{
						mat.SetFloat("_EmissionScaleUI", 1f);
					}
					catch (Exception)
					{
					}
				}
			}
			editorMethods?.CommitChangesToAssets();
		}

		public static UnityEngine.Color GetColorIfNoTexture(ShaderTextureProperty texProperty)
		{
			if (texProperty.isNormalMap)
			{
				return new UnityEngine.Color(0.5f, 0.5f, 1f);
			}
			if (texProperty.name.Equals("_MetallicGlossMap"))
			{
				return new UnityEngine.Color(0f, 0f, 0f, 1f);
			}
			if (texProperty.name.Equals("_ParallaxMap"))
			{
				return new UnityEngine.Color(0f, 0f, 0f, 0f);
			}
			if (texProperty.name.Equals("_OcclusionMap"))
			{
				return new UnityEngine.Color(1f, 1f, 1f, 1f);
			}
			if (texProperty.name.Equals("_EmissionMap"))
			{
				return new UnityEngine.Color(0f, 0f, 0f, 0f);
			}
			if (texProperty.name.Equals("_DetailMask"))
			{
				return new UnityEngine.Color(0f, 0f, 0f, 0f);
			}
			return new UnityEngine.Color(1f, 1f, 1f, 0f);
		}

		private Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
		{
			Vector3 zero = Vector3.zero;
			zero.x = (float)(int)c.a * 2f - 1f;
			zero.y = (float)(int)c.g * 2f - 1f;
			zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
			Color32 result = default(Color32);
			result.a = 1;
			result.r = (byte)((zero.x + 1f) * 0.5f);
			result.g = (byte)((zero.y + 1f) * 0.5f);
			result.b = (byte)((zero.z + 1f) * 0.5f);
			return result;
		}

		private float GetSubmeshArea(Mesh m, int submeshIdx)
		{
			if (submeshIdx >= m.subMeshCount || submeshIdx < 0)
			{
				return 0f;
			}
			Vector3[] vertices = m.vertices;
			int[] indices = m.GetIndices(submeshIdx);
			float num = 0f;
			for (int i = 0; i < indices.Length; i += 3)
			{
				Vector3 vector = vertices[indices[i]];
				Vector3 vector2 = vertices[indices[i + 1]];
				Vector3 vector3 = vertices[indices[i + 2]];
				num += Vector3.Cross(vector2 - vector, vector3 - vector).magnitude / 2f;
			}
			return num;
		}

		private string PrintList(List<GameObject> gos)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < gos.Count; i++)
			{
				stringBuilder.Append(string.Concat(gos[i], ","));
			}
			return stringBuilder.ToString();
		}
	}
	public class MB_Utility
	{
		public struct MeshAnalysisResult
		{
			public Rect uvRect;

			public bool hasOutOfBoundsUVs;

			public bool hasOverlappingSubmeshVerts;

			public bool hasOverlappingSubmeshTris;

			public bool hasUVs;

			public float submeshArea;
		}

		private class MB_Triangle
		{
			private int submeshIdx;

			private int[] vs = new int[3];

			public bool isSame(object obj)
			{
				MB_Triangle mB_Triangle = (MB_Triangle)obj;
				if (vs[0] == mB_Triangle.vs[0] && vs[1] == mB_Triangle.vs[1] && vs[2] == mB_Triangle.vs[2] && submeshIdx != mB_Triangle.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public bool sharesVerts(MB_Triangle obj)
			{
				if ((vs[0] == obj.vs[0] || vs[0] == obj.vs[1] || vs[0] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[1] == obj.vs[0] || vs[1] == obj.vs[1] || vs[1] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[2] == obj.vs[0] || vs[2] == obj.vs[1] || vs[2] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public void Initialize(int[] ts, int idx, int sIdx)
			{
				vs[0] = ts[idx];
				vs[1] = ts[idx + 1];
				vs[2] = ts[idx + 2];
				submeshIdx = sIdx;
				Array.Sort(vs);
			}
		}

		public static Texture2D createTextureCopy(Texture2D source)
		{
			Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.ARGB32, mipmap: true);
			texture2D.SetPixels(source.GetPixels());
			return texture2D;
		}

		public static bool ArrayBIsSubsetOfA(object[] a, object[] b)
		{
			for (int i = 0; i < b.Length; i++)
			{
				bool flag = false;
				for (int j = 0; j < a.Length; j++)
				{
					if (a[j] == b[i])
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public static Material[] GetGOMaterials(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			Material[] array = null;
			Mesh mesh = null;
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				array = component.sharedMaterials;
				MeshFilter component2 = go.GetComponent<MeshFilter>();
				if (component2 == null)
				{
					throw new Exception(string.Concat("Object ", go, " has a MeshRenderer but no MeshFilter."));
				}
				mesh = component2.sharedMesh;
			}
			SkinnedMeshRenderer component3 = go.GetComponent<SkinnedMeshRenderer>();
			if (component3 != null)
			{
				array = component3.sharedMaterials;
				mesh = component3.sharedMesh;
			}
			if (array == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " does not have a MeshRenderer or a SkinnedMeshRenderer component");
				return new Material[0];
			}
			if (mesh == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has a MeshRenderer or SkinnedMeshRenderer but no mesh.");
				return new Material[0];
			}
			if (mesh.subMeshCount < array.Length)
			{
				UnityEngine.Debug.LogWarning(string.Concat("Object ", go, " has only ", mesh.subMeshCount, " submeshes and has ", array.Length, " materials. Extra materials do nothing."));
				Material[] array2 = new Material[mesh.subMeshCount];
				Array.Copy(array, array2, array2.Length);
				array = array2;
			}
			return array;
		}

		public static Mesh GetMesh(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				return component.sharedMesh;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2.sharedMesh;
			}
			UnityEngine.Debug.LogError("Object " + go.name + " does not have a MeshFilter or a SkinnedMeshRenderer component");
			return null;
		}

		public static void SetMesh(GameObject go, Mesh m)
		{
			if (go == null)
			{
				return;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				component.sharedMesh = m;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.sharedMesh = m;
			}
		}

		public static Renderer GetRenderer(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				return component;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2;
			}
			return null;
		}

		public static void DisableRendererInSource(GameObject go)
		{
			if (go == null)
			{
				return;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.enabled = false;
			}
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref Rect uvBounds)
		{
			MeshAnalysisResult putResultHere = default(MeshAnalysisResult);
			bool result = hasOutOfBoundsUVs(m, ref putResultHere);
			uvBounds = putResultHere.uvRect;
			return result;
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1, int uvChannel = 0)
		{
			if (m == null)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				return putResultHere.hasOutOfBoundsUVs;
			}
			return hasOutOfBoundsUVs(uvChannel switch
			{
				0 => m.uv, 
				1 => m.uv2, 
				2 => m.uv3, 
				_ => m.uv4, 
			}, m, ref putResultHere, submeshIndex);
		}

		public static bool hasOutOfBoundsUVs(Vector2[] uvs, Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1)
		{
			putResultHere.hasUVs = true;
			if (uvs.Length == 0)
			{
				putResultHere.hasUVs = false;
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			if (submeshIndex >= m.subMeshCount)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			float num;
			float x;
			float num2;
			float y;
			if (submeshIndex >= 0)
			{
				int[] triangles = m.GetTriangles(submeshIndex);
				if (triangles.Length == 0)
				{
					putResultHere.hasOutOfBoundsUVs = false;
					putResultHere.uvRect = default(Rect);
					return putResultHere.hasOutOfBoundsUVs;
				}
				num = (x = uvs[triangles[0]].x);
				num2 = (y = uvs[triangles[0]].y);
				foreach (int num3 in triangles)
				{
					if (uvs[num3].x < num)
					{
						num = uvs[num3].x;
					}
					if (uvs[num3].x > x)
					{
						x = uvs[num3].x;
					}
					if (uvs[num3].y < num2)
					{
						num2 = uvs[num3].y;
					}
					if (uvs[num3].y > y)
					{
						y = uvs[num3].y;
					}
				}
			}
			else
			{
				num = (x = uvs[0].x);
				num2 = (y = uvs[0].y);
				for (int j = 0; j < uvs.Length; j++)
				{
					if (uvs[j].x < num)
					{
						num = uvs[j].x;
					}
					if (uvs[j].x > x)
					{
						x = uvs[j].x;
					}
					if (uvs[j].y < num2)
					{
						num2 = uvs[j].y;
					}
					if (uvs[j].y > y)
					{
						y = uvs[j].y;
					}
				}
			}
			Rect uvRect = default(Rect);
			uvRect.x = num;
			uvRect.y = num2;
			uvRect.width = x - num;
			uvRect.height = y - num2;
			if (x > 1f || num < 0f || y > 1f || num2 < 0f)
			{
				putResultHere.hasOutOfBoundsUVs = true;
			}
			else
			{
				putResultHere.hasOutOfBoundsUVs = false;
			}
			putResultHere.uvRect = uvRect;
			return putResultHere.hasOutOfBoundsUVs;
		}

		public static void setSolidColor(Texture2D t, UnityEngine.Color c)
		{
			UnityEngine.Color[] pixels = t.GetPixels();
			for (int i = 0; i < pixels.Length; i++)
			{
				pixels[i] = c;
			}
			t.SetPixels(pixels);
			t.Apply();
		}

		public static Texture2D resampleTexture(Texture2D source, int newWidth, int newHeight)
		{
			TextureFormat format = source.format;
			if (format == TextureFormat.ARGB32 || format == TextureFormat.RGBA32 || format == TextureFormat.BGRA32 || format == TextureFormat.RGB24 || format == TextureFormat.Alpha8 || format == TextureFormat.DXT1)
			{
				Texture2D texture2D = new Texture2D(newWidth, newHeight, TextureFormat.ARGB32, mipmap: true);
				float num = newWidth;
				float num2 = newHeight;
				for (int i = 0; i < newWidth; i++)
				{
					for (int j = 0; j < newHeight; j++)
					{
						float u = (float)i / num;
						float v = (float)j / num2;
						texture2D.SetPixel(i, j, source.GetPixelBilinear(u, v));
					}
				}
				texture2D.Apply();
				return texture2D;
			}
			UnityEngine.Debug.LogError("Can only resize textures in formats ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT");
			return null;
		}

		public static bool AreAllSharedMaterialsDistinct(Material[] sharedMaterials)
		{
			for (int i = 0; i < sharedMaterials.Length; i++)
			{
				for (int j = i + 1; j < sharedMaterials.Length; j++)
				{
					if (sharedMaterials[i] == sharedMaterials[j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public static int doSubmeshesShareVertsOrTris(Mesh m, ref MeshAnalysisResult mar)
		{
			MB_Triangle mB_Triangle = new MB_Triangle();
			MB_Triangle mB_Triangle2 = new MB_Triangle();
			int[][] array = new int[m.subMeshCount][];
			for (int i = 0; i < m.subMeshCount; i++)
			{
				array[i] = m.GetTriangles(i);
			}
			bool flag = false;
			bool flag2 = false;
			for (int j = 0; j < m.subMeshCount; j++)
			{
				int[] array2 = array[j];
				for (int k = j + 1; k < m.subMeshCount; k++)
				{
					int[] array3 = array[k];
					for (int l = 0; l < array2.Length; l += 3)
					{
						mB_Triangle.Initialize(array2, l, j);
						for (int n = 0; n < array3.Length; n += 3)
						{
							mB_Triangle2.Initialize(array3, n, k);
							if (mB_Triangle.isSame(mB_Triangle2))
							{
								flag2 = true;
								break;
							}
							if (mB_Triangle.sharesVerts(mB_Triangle2))
							{
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (flag2)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = true;
				return 2;
			}
			if (flag)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = false;
				return 1;
			}
			mar.hasOverlappingSubmeshTris = false;
			mar.hasOverlappingSubmeshVerts = false;
			return 0;
		}

		public static bool GetBounds(GameObject go, out Bounds b)
		{
			if (go == null)
			{
				UnityEngine.Debug.LogError("go paramater was null");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			Renderer renderer = GetRenderer(go);
			if (renderer == null)
			{
				UnityEngine.Debug.LogError("GetBounds must be called on an object with a Renderer");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			if (renderer is MeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			if (renderer is SkinnedMeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			UnityEngine.Debug.LogError("GetBounds must be called on an object with a MeshRender or a SkinnedMeshRenderer.");
			b = new Bounds(Vector3.zero, Vector3.zero);
			return false;
		}

		public static void Destroy(UnityEngine.Object o)
		{
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Object.Destroy(o);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(o, allowDestroyingAssets: false);
			}
		}
	}
}
namespace HSVR
{
	public class MeshCombined : UnityEngine.MonoBehaviour
	{
		public Material originalMaterial;

		private void Start()
		{
			MeshFilter meshFilter = base.gameObject.AddComponent<MeshFilter>();
			MeshRenderer meshRenderer = GetComponent<MeshRenderer>();
			if (!meshRenderer)
			{
				meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
			MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
			List<CombineInstance> list = new List<CombineInstance>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (!(meshFilter == componentsInChildren[i]) && !(componentsInChildren[i].mesh == null))
				{
					MeshRenderer component = componentsInChildren[i].GetComponent<MeshRenderer>();
					if ((bool)component && !(component.sharedMaterial != originalMaterial))
					{
						CombineInstance item = default(CombineInstance);
						item.mesh = componentsInChildren[i].sharedMesh;
						item.transform = componentsInChildren[i].transform.localToWorldMatrix;
						componentsInChildren[i].gameObject.SetActive(value: false);
						list.Add(item);
					}
				}
			}
			CombineInstance[] combine = list.ToArray();
			MeshFilter component2 = base.transform.GetComponent<MeshFilter>();
			if ((bool)component2)
			{
				component2.mesh = new Mesh();
				component2.mesh.CombineMeshes(combine, mergeSubMeshes: true);
			}
			base.transform.position = Vector3.zero;
			base.transform.rotation = Quaternion.identity;
			base.transform.gameObject.SetActive(value: true);
			meshRenderer.sharedMaterial = originalMaterial;
			RecalculateLODBounds();
		}

		private void RecalculateLODBounds()
		{
			LODGroup component = GetComponent<LODGroup>();
			if ((bool)component)
			{
				component.RecalculateBounds();
			}
		}
	}
}
public class RemoveRenderers : UnityEngine.MonoBehaviour
{
	public void RemoveAll()
	{
		Renderer[] componentsInChildren = base.transform.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			UnityEngine.Object.DestroyImmediate(componentsInChildren[i]);
		}
	}
}
public class StaticBatchCombine : UnityEngine.MonoBehaviour
{
	private void Awake()
	{
		StaticBatchingUtility.Combine(base.gameObject);
	}
}
